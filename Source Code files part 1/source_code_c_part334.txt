dma->lDBGState==2,
        "CommitDMAPtr called, but previous without calling Reserve before");
    pP2dma->lDBGState=0;
    if (pDMAPtr==NULL) return;

    pP2dma->ICB.pDMAWritePos=pDMAPtr;

    ASSERTDD(pP2dma->ICB.pDMAWritePos<=
        pP2dma->ICB.pDMABufferEnd,"CommitDMAPtr: DMA buffer overrun");

    if (pP2dma->pDBGReservedEntries!=NULL)
    {
        ASSERTDD(pP2dma->ICB.pDMAWritePos<=pP2dma->pDBGReservedEntries, 
            "reserved not enough entries in ReserveDMAPtr");
    }
}


//----------------------------------------------------------------------------
//
//  GetFreeEntries
//
//  Get free entries available for consecutive writing to the DMA buffer.
//  The maximum number of returned entries is now MAXBLKSIZE.
// 
//  returns---number of available entries in ULONGS
//
//----------------------------------------------------------------------------

LONG  GetFreeEntries(P2DMA *pP2dma)
{   
    LONG EntriesAvailable;
    ASSERTDD(pP2dma->bEnabled, "GetFreeEntries: not enabled");
    EntriesAvailable = (LONG)(pP2dma->ICB.pDMAWriteEnd - pP2dma->ICB.pDMAWritePos);
    return min(MAXBLKSIZE,EntriesAvailable);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\pointer.c ===
/******************************Module*Header**********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: pointer.c
 *
 * This module contains the hardware pointer support for the display driver.
 * We also have support for color space double buffering using the RAMDAC pixel
 * read mask.
 *
 * Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "precomp.h"
#include "pointer.h"
#include "tvp4020.h"
#include "p2rd.h"
#include "gdi.h"
#include "heap.h"

//
// Look-up table for masking the right edge of the given pointer bitmap:
//
BYTE gajMask[] =
{
    0x00, 0x80, 0xC0, 0xE0,
    0xF0, 0xF8, 0xFC, 0xFE,
};

UCHAR nibbleToByteP2RD[] =
{
    0x00,   // 0000 --> 00000000
    0x80,   // 0001 --> 10000000
    0x20,   // 0010 --> 00100000
    0xA0,   // 0011 --> 10100000
    0x08,   // 0100 --> 00001000
    0x88,   // 0101 --> 10001000
    0x28,   // 0110 --> 00101000
    0xA8,   // 0111 --> 10101000
    0x02,   // 1000 --> 00000010
    0x82,   // 1001 --> 10000010
    0x22,   // 1010 --> 00100010
    0xA2,   // 1011 --> 10100010
    0x0A,   // 1100 --> 00001010
    0x8A,   // 1101 --> 10001010
    0x2A,   // 1110 --> 00101010
    0xAA,   // 1111 --> 10101010
};

//-----------------------------------------------------------------------------
//
// LONG HWPointerCacheInit()
//
// Initialise the hardware pointer cache.
//
//-----------------------------------------------------------------------------
VOID
HWPointerCacheInit(HWPointerCache* ptrCache)
{
    ptrCache->cPtrCacheInUseCount = 0;
    ptrCache->ptrCacheCurTimeStamp = 0;
}// HWPointerCacheInit()

//-----------------------------------------------------------------------------
//
// 64 x 64 Hardware Pointer Caching
// --------------------------------
// The code below implements hardware independent caching of pointers. It
// maintains a cache big enough to store ONE 64x64 cursor or FOUR 32x32
// cursors. The code will work with all RAMDACs that support this form of
// caching.
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// LONG HWPointerCacheCheckAndAdd()
//
// This function does a byte-by-byte comparison of the supplied pointer data
// with each pointer that is in cache, if it finds a matching one then it
// returns the index of the item in the cache (0 to 3) otherwise it adds it to
// the cache and returns the index.
//
//-----------------------------------------------------------------------------
LONG
HWPointerCacheCheckAndAdd(HWPointerCache*   ptrCache,
                          HSURF             hsurf,
                          ULONG             ulKey,
                          BOOL*             isCached)
{
    BOOL pointerIsCached = FALSE;
    LONG i, j, z;
    LONG cacheItem;

    DBG_GDI((6, "HWPointerCacheCheckAndAdd called"));

    //
    // If there are entries in the cache and they are the same format as the
    // one that we are looking for then search the cache.
    //
    if (  ptrCache->cPtrCacheInUseCount )
    {
        DBG_GDI((6, "Found entry in cache with the same format"));

        //
        // Search the cache
        //
        LONG lTotalcached = ptrCache->cPtrCacheInUseCount;

        //
        // Examine all valid entries in the cache to see if they are the same
        // as the pointer that we've been handed based on its unique key number
        // and the surface handle.
        // Note: the reason we check "hsurf" here is that it is possible that
        // two surfaces has the same iUniq number since Every time the surface
        // changes this value is incremented
        //
        for ( z = 0; !pointerIsCached && z < lTotalcached; z++ )
        {
            if ( (ulKey == ptrCache->ptrCacheItemList[z].ulKey)
               &&(hsurf == ptrCache->ptrCacheItemList[z].hsurf) )
            {
                cacheItem = z;
                pointerIsCached = TRUE;
            }
        }// loop through all the cached items
    }// Found entry in cache with the same format

    DBG_GDI((6, "Found an entry in cache (%s)",  pointerIsCached?"YES":"NO"));

    //
    // If we couldn't find an entry in the pointer cache then add one to the
    // cache.
    //
    if ( !pointerIsCached )
    {
        //
        // Add the pointer to the cache
        //
        LONG  z2;

        //
        // If there are some spare entries then allocate a free entry, otherwise
        // find the least recently used entry and use that.
        //
        if ( ptrCache->cPtrCacheInUseCount < SMALL_POINTER_MAX )
        {
            cacheItem = ptrCache->cPtrCacheInUseCount++;
        }
        else
        {
            ULONG oldestValue = 0xFFFFFFFF;

            //
            // Look for the LRU entry
            //
            for ( z2 = 0, cacheItem = 0; z2 < SMALL_POINTER_MAX; z2++ )
            {
                if ( ptrCache->ptrCacheItemList[z2].ptrCacheTimeStamp
                     < oldestValue )
                {
                    cacheItem = z2;
                    oldestValue =
                        ptrCache->ptrCacheItemList[z2].ptrCacheTimeStamp;
                }
            }
        }// Determine cacheItem

        ptrCache->ptrCacheItemList[cacheItem].ulKey = ulKey;
        ptrCache->ptrCacheItemList[cacheItem].hsurf = hsurf;
    }// If not found entry, add one

    //
    // Set the timestamp
    //
    ptrCache->ptrCacheItemList[cacheItem].ptrCacheTimeStamp
            = ptrCache->ptrCacheCurTimeStamp++;

    //
    // Set up the return value to say whether the pointer was cached and return
    // the number of the current cached position
    //
    *isCached = pointerIsCached;

    DBG_GDI((6, "HWPointerCacheCheckAndAdd finished and return item %d",
             cacheItem));
    return(cacheItem);
}// HWPointerCacheCheckAndAdd()

//-----------------------------------------------------------------------------
//
// VOID vShowPointerP2RD()
//
// Show or hide the 3Dlabs P2RD hardware pointer.
//
//-----------------------------------------------------------------------------
VOID
vShowPointerP2RD(PDev*   ppdev,
                 BOOL    bShow)
{
    ULONG cmr;
    PERMEDIA_DECL_VARS;
    P2RD_DECL_VARS;

    PERMEDIA_DECL_INIT;
    P2RD_DECL_INIT;

    DBG_GDI((6, "vShowPointerP2RD (%s)", bShow ? "on" : "off"));
    if ( bShow )
    {
        //
        // No need to sync since this case is called only if we've just
        // moved the cursor and that will already have done a sync.
        //
        P2RD_LOAD_INDEX_REG(P2RD_CURSOR_MODE, (pP2RDinfo->cursorModeCurrent | P2RD_CURSOR_MODE_ENABLED));
        P2RD_MOVE_CURSOR (pP2RDinfo->x, pP2RDinfo->y);
    }
    else
    {
        //
        // move the cursor off screen
        //
        P2RD_LOAD_INDEX_REG(P2RD_CURSOR_Y_HIGH, 0xff);
    }
}// vShowPointerP2RD()

//-----------------------------------------------------------------------------
//
// VOID vMovePointerP2RD()
//
// Move the 3Dlabs P2RD hardware pointer.
//
//-----------------------------------------------------------------------------
VOID
vMovePointerP2RD(PDev*   ppdev,
                 LONG    x,
                 LONG    y)
{
    PERMEDIA_DECL_VARS;
    P2RD_DECL_VARS;

    PERMEDIA_DECL_INIT;
    P2RD_DECL_INIT;

    DBG_GDI((6, "vMovePointerP2RD to (%d, %d)", x, y));

    pP2RDinfo->x = x;
    pP2RDinfo->y = y;

    P2RD_SYNC_WITH_PERMEDIA;
    P2RD_MOVE_CURSOR(x, y);
}// vMovePointerP2RD()

//-----------------------------------------------------------------------------
//
// BOOL bSet3ColorPointerShapeP2RD()
//
// Stores the 3-color cursor in the RAMDAC: currently only 32bpp and 15/16bpp
// cursors are supported
//
//-----------------------------------------------------------------------------
BOOL
bSet3ColorPointerShapeP2RD(PDev*    ppdev,
                           SURFOBJ* psoMask,    // defines AND and MASK bits
                                                // for cursor
                           SURFOBJ* psoColor,   // we may handle some color
                                                // cursors at some point
                           LONG     x,          // If -1, pointer should be
                                                // created hidden
                           LONG     y,
                           LONG     xHot,
                           LONG     yHot)
{
    LONG    cx, cy;
    LONG    cxcyCache;
    LONG    cjCacheRow, cjCacheRemx, cjCacheRemy, cj;
    BYTE    *pjAndMask, *pj;
    ULONG   *pulColor, *pul;
    LONG    cjAndDelta, cjColorDelta;
    LONG    iRow, iCol;
    BYTE    AndBit, AndByte;
    ULONG   CI2ColorIndex, CI2ColorData;
    ULONG   ulColor;
    ULONG   aulColorsIndexed[3];
    LONG    Index, HighestIndex = 0;
    ULONG   r, g, b;
    
    PERMEDIA_DECL_VARS;
    P2RD_DECL_VARS;

    PERMEDIA_DECL_INIT;
    P2RD_DECL_INIT;

    DBG_GDI((6, "bSet3ColorPointerShapeP2RD started"));

    cx = psoColor->sizlBitmap.cx;
    cy = psoColor->sizlBitmap.cy;

    if ( cx <= 32 && cy <= 32 )
    {
        //
        // 32x32 cursor : we'll cache it in cursor partition 0 and scrub the
        // old cache
        //
        cxcyCache = 32;

        pP2RDinfo->cursorSize = P2RD_CURSOR_SIZE_32_3COLOR;
        pP2RDinfo->cursorModeCurrent = pP2RDinfo->cursorModeOff
                                   | P2RD_CURSOR_SEL(pP2RDinfo->cursorSize, 0)
                                   | P2RD_CURSOR_MODE_3COLOR;

        //
        // We don't cache color cursors
        //
        HWPointerCacheInvalidate (&(ppdev->HWPtrCache));
    }
    else if ( cx <= 64 && cy <= 64 )
    {
        //
        // 64x64 cursor : we'll cache it in cursor partition 0 and scrub the
        // old cache
        //
        cxcyCache = 64;

        pP2RDinfo->cursorSize = P2RD_CURSOR_SIZE_64_3COLOR;
        pP2RDinfo->cursorModeCurrent = pP2RDinfo->cursorModeOff
                                | P2RD_CURSOR_SEL(pP2RDinfo->cursorSize, 0)
                                | P2RD_CURSOR_MODE_3COLOR;

        //
        // We don't cache color cursors
        //
        HWPointerCacheInvalidate (&(ppdev->HWPtrCache));
    }
    else
    {
        DBG_GDI((6, "declining cursor: %d x %d is too big", cx, cy));
        return(FALSE);          // cursor is too big to fit in the hardware
    }

    //
    // work out the remaining bytes in the cache (in x and y) that will need
    // clearing
    //
    cjCacheRow  = 2 * cxcyCache / 8;
    cjCacheRemx =  cjCacheRow - 2 * ((cx+7) / 8);
    cjCacheRemy = (cxcyCache - cy) * cjCacheRow;

    //
    // Set-up a pointer to the 1bpp AND mask bitmap
    //
    pjAndMask = (UCHAR*)psoMask->pvScan0;
    cjAndDelta = psoMask->lDelta;

    //
    // Set-up a pointer to the 32bpp color bitmap
    //
    pulColor = (ULONG*)psoColor->pvScan0;
    cjColorDelta = psoColor->lDelta;

    //
    // Hide the pointer
    //
    vShowPointerP2RD(ppdev, FALSE);

    //
    // Load the cursor array (we have auto-increment turned on so initialize
    // to entry 0 here)
    //
    P2RD_CURSOR_ARRAY_START(0);
    for ( iRow = 0;
          iRow < cy;
          ++iRow, pjAndMask += cjAndDelta,
          pulColor = (ULONG*)((BYTE*)pulColor+cjColorDelta) )
    {
        DBG_GDI((7, "bSet3ColorPointerShapeP2RD: Row %d (of %d): pjAndMask(%p) pulColor(%p)",
                 iRow, cy, pjAndMask, pulColor));
        pj = pjAndMask;
        pul = pulColor;
        CI2ColorIndex = CI2ColorData = 0;

        for ( iCol = 0; iCol < cx; ++iCol, CI2ColorIndex += 2 )
        {
            AndBit = (BYTE)(7 - (iCol & 7));
            if ( AndBit == 7 )
            {
                //
                // We're onto the next byte of the and mask
                //
                AndByte = *pj++;
            }

            if ( CI2ColorIndex == 8 )
            {
                //
                // We've filled a byte with 4 CI2 colors
                //
                DBG_GDI((7, "bSet3ColorPointerShapeP2RD: writing cursor data %xh",
                         CI2ColorData));
                P2RD_LOAD_CURSOR_ARRAY(CI2ColorData);
                CI2ColorData = 0;
                CI2ColorIndex = 0;
            }

            //
            // Get the source pixel
            //
            if ( ppdev->cPelSize == P2DEPTH32 )
            {
                ulColor = *pul++;
            }
            else
            {
                ulColor = *(USHORT*)pul;
                pul = (ULONG*)((USHORT*)pul + 1);
            }

            DBG_GDI((7, "bSet3ColorPointerShapeP2RD: Column %d (of %d) AndByte(%08xh) AndBit(%d) ulColor(%08xh)",
                     iCol, cx, AndByte, AndBit, ulColor));

            //
            // Figure out what to do with it:-
            // AND  Color   Result
            //  0     X             color
            //  1     0     transparent
            //  1     1     inverse
            //
            if ( AndByte & (1 << AndBit) )
            {
                //
                // Transparent or inverse
                //
                if ( ulColor == 0 )
                {
                    //
                    // color == black:
                    // transparent and seeing as the CI2ColorData is
                    // initialized to 0 we don't have to explicitly clear these
                    // bits - go on to the next pixel
                    //
                    DBG_GDI((7, "bSet3ColorPointerShapeP2RD: transparent - ignore"));
                    continue;
                }

                if ( ulColor == ppdev->ulWhite )
                {
                    //
                    // color == white:
                    // inverse, but we don't support this. We've destroyed the
                    // cache for nothing
                    //
                    DBG_GDI((7, "bSet3ColorPointerShapeP2RD: failed - inverted colors aren't supported"));
                    return(FALSE);
                }
            }

            //
            // Get the index for this color: first see if we've already indexed
            // it
            //
            DBG_GDI((7, "bSet3ColorPointerShapeP2RD: looking up color %08xh",
                     ulColor));

            for ( Index = 0;
                  Index < HighestIndex && aulColorsIndexed[Index] != ulColor;
                  ++Index );

            if ( Index == 3 )
            {
                //
                // Too many colors in this cursor
                //
                DBG_GDI((7, "bSet3ColorPointerShapeP2RD: failed - cursor has more than 3 colors"));
                return(FALSE);
            }
            else if ( Index == HighestIndex )
            {
                //
                // We've found another color: add it to the color index
                //
                DBG_GDI((7, "bSet3ColorPointerShapeP2RD: adding %08xh to cursor palette",
                         ulColor));
                aulColorsIndexed[HighestIndex++] = ulColor;
            }

            //
            // Add this pixel's index to the CI2 cursor data. NB. Need Index+1
            // as 0 == transparent
            //
            CI2ColorData |= (Index + 1) <<  CI2ColorIndex;
        }

        //
        // End of the cursor row: save the remaining indexed pixels then blank
        // any unused columns
        //
        DBG_GDI((7, "bSet3ColorPointerShapeP2RD: writing remaining data for this row (%08xh) and %d trailing bytes",
                 CI2ColorData, cjCacheRemx));

        P2RD_LOAD_CURSOR_ARRAY(CI2ColorData);
        if ( cjCacheRemx )
        {
            for ( cj = cjCacheRemx; --cj >=0; )
            {
                P2RD_LOAD_CURSOR_ARRAY(P2RD_CURSOR_3_COLOR_TRANSPARENT);
            }
        }
    }

    //
    // End of cursor: blank any unused rows Nb. cjCacheRemy == cy blank
    // rows * cj bytes per row
    //
    DBG_GDI((7, "bSet3ColorPointerShapeP2RD: writing %d trailing bytes for this cursor",
             cjCacheRemy));

    for ( cj = cjCacheRemy; --cj >= 0; )
    {
        //
        // 0 == transparent
        //
        P2RD_LOAD_CURSOR_ARRAY(P2RD_CURSOR_3_COLOR_TRANSPARENT);
    }

    DBG_GDI((7, "bSet3ColorPointerShapeP2RD: setting up the cursor palette"));

    //
    // Now set-up the cursor palette
    //
    for ( iCol = 0; iCol < HighestIndex; ++iCol )
    {
        //
        // The cursor colors are at native depth, convert them to 24bpp
        //
        if ( ppdev->cPelSize == P2DEPTH32 )
        {
            //
            // 32bpp
            //
            b = 0xff &  aulColorsIndexed[iCol];
            g = 0xff & (aulColorsIndexed[iCol] >> 8);
            r = 0xff & (aulColorsIndexed[iCol] >> 16);
        }
        else
        {
            //
            // (ppdev->cPelSize == P2DEPTH16)
            //
            if ( ppdev->ulWhite == 0xffff )
            {
                //
                // 16bpp
                //
                b = (0x1f &  aulColorsIndexed[iCol])         << 3;
                g = (0x3f & (aulColorsIndexed[iCol] >> 5))   << 2;
                r = (0x1f & (aulColorsIndexed[iCol] >> 11))  << 3;
            }
            else
            {
                //
                // 15bpp
                //
                b = (0x1f &  aulColorsIndexed[iCol])         << 3;
                g = (0x1f & (aulColorsIndexed[iCol] >> 5))   << 3;
                r = (0x1f & (aulColorsIndexed[iCol] >> 10))  << 3;
            }
        }

        P2RD_CURSOR_PALETTE_CURSOR_RGB(iCol, r, g, b);
    }

    //
    // Enable the cursor
    //
    P2RD_CURSOR_HOTSPOT(xHot, yHot);
    if ( x != -1 )
    {
        vMovePointerP2RD (ppdev, x, y);
        //
        // Need to explicitly show the pointer if not using interrupts
        //
        vShowPointerP2RD(ppdev, TRUE);
    }

    DBG_GDI((6, "b3ColorSetPointerShapeP2RD done"));
    return(TRUE);
}// bSet3ColorPointerShapeP2RD()

//-----------------------------------------------------------------------------
//
// BOOL bSet15ColorPointerShapeP2RD
//
// Stores the 15-color cursor in the RAMDAC: currently only 32bpp and 15/16bpp
// cursors are supported
//
//-----------------------------------------------------------------------------
BOOL
bSet15ColorPointerShapeP2RD(PDev*       ppdev,
                            SURFOBJ*    psoMask,    // defines AND and MASK
                                                    // bits for cursor
                            SURFOBJ*    psoColor,   // we may handle some color
                                                    // cursors at some point
                            LONG        x,          // If -1, pointer should be
                                                    // created hidden
                            LONG        y,
                            LONG        xHot,
                            LONG        yHot)
{
    LONG    cx, cy;
    LONG    cxcyCache;
    LONG    cjCacheRow, cjCacheRemx, cjCacheRemy, cj;
    BYTE*   pjAndMask;
    BYTE*   pj;
    ULONG*  pulColor;
    ULONG*  pul;
    LONG    cjAndDelta;
    LONG    cjColorDelta;
    LONG    iRow;
    LONG    iCol;
    BYTE    AndBit;
    BYTE    AndByte;
    ULONG   CI4ColorIndex;
    ULONG   CI4ColorData;
    ULONG   ulColor;
    ULONG   aulColorsIndexed[15];
    LONG    Index;
    LONG    HighestIndex = 0;
    ULONG   r;
    ULONG   g;
    ULONG   b;

    PERMEDIA_DECL_VARS;
    P2RD_DECL_VARS;

    PERMEDIA_DECL_INIT;
    P2RD_DECL_INIT;

    DBG_GDI((6, "bSet15ColorPointerShapeP2RD started"));

    cx = psoColor->sizlBitmap.cx;
    cy = psoColor->sizlBitmap.cy;

    if ( cx <= 32 && cy <= 32 )
    {
        //
        // 32x32 cursor : we'll cache it in cursor partition 0 and scrub the
        // old cache
        //
        cxcyCache = 32;

        pP2RDinfo->cursorSize = P2RD_CURSOR_SIZE_32_15COLOR;
        pP2RDinfo->cursorModeCurrent = pP2RDinfo->cursorModeOff
                                     | P2RD_CURSOR_SEL(pP2RDinfo->cursorSize, 0)
                                     | P2RD_CURSOR_MODE_15COLOR;

        //
        // We don't cache color cursors
        //
        HWPointerCacheInvalidate (&(ppdev->HWPtrCache));
    }
    else if ( cx <= 64 && cy <= 64 )
    {
        //
        // It's too big to cache as a fifteen color cursor, but we might just
        // be able to cache it if it has 3 or fewer colors
        //
        BOOL bRet;

        bRet = bSet3ColorPointerShapeP2RD(ppdev, psoMask, psoColor, x, y, xHot,
                                          yHot);
        return(bRet);
    }
    else
    {
        DBG_GDI((6, "declining cursor: %d x %d is too big", cx, cy));
        return(FALSE);          // cursor is too big to fit in the hardware
    }

    //
    // Work out the remaining bytes in the cache (in x and y) that will need
    // clearing
    //
    cjCacheRow  = 2 * cxcyCache / 8;
    cjCacheRemx =  cjCacheRow - 2 * ((cx+7) / 8);
    cjCacheRemy = (cxcyCache - cy) * cjCacheRow;

    //
    // Set-up a pointer to the 1bpp AND mask bitmap
    //
    pjAndMask = (UCHAR*)psoMask->pvScan0;
    cjAndDelta = psoMask->lDelta;

    //
    // Set-up a pointer to the 32bpp color bitmap
    //
    pulColor = (ULONG*)psoColor->pvScan0;
    cjColorDelta = psoColor->lDelta;

    //
    // Hide the pointer
    //
    vShowPointerP2RD(ppdev, FALSE);

    //
    // Load the cursor array (we have auto-increment turned on so initialize to
    // entry 0 here)
    //
    P2RD_CURSOR_ARRAY_START(0);
    for ( iRow = 0; iRow < cy;
         ++iRow, pjAndMask += cjAndDelta,
         pulColor = (ULONG*)((BYTE*)pulColor + cjColorDelta) )
    {
        DBG_GDI((7, "bSet15ColorPointerShapeP2RD: Row %d (of %d): pjAndMask(%p) pulColor(%p)",
                 iRow, cy, pjAndMask, pulColor));
        pj = pjAndMask;
        pul = pulColor;
        CI4ColorIndex = CI4ColorData = 0;

        for ( iCol = 0; iCol < cx; ++iCol, CI4ColorIndex += 4 )
        {
            AndBit = (BYTE)(7 - (iCol & 7));
            if ( AndBit == 7 )
            {
                //
                // We're onto the next byte of the and mask
                //
                AndByte = *pj++;
            }
            if ( CI4ColorIndex == 8 )
            {
                //
                // We've filled a byte with 2 CI4 colors
                //
                DBG_GDI((7, "bSet15ColorPointerShapeP2RD: writing cursor data %xh",
                         CI4ColorData));
                P2RD_LOAD_CURSOR_ARRAY(CI4ColorData);
                CI4ColorData = 0;
                CI4ColorIndex = 0;
            }

            //
            // Get the source pixel
            //
            if ( ppdev->cPelSize == P2DEPTH32 )
            {
                ulColor = *pul++;
            }
            else
            {
                ulColor = *(USHORT *)pul;
                pul = (ULONG *)((USHORT *)pul + 1);
            }

            DBG_GDI((7, "bSet15ColorPointerShapeP2RD: Column %d (of %d) AndByte(%08xh) AndBit(%d) ulColor(%08xh)",
                     iCol, cx, AndByte, AndBit, ulColor));

            //
            // figure out what to do with it:-
            // AND  Color   Result
            //  0     X             color
            //  1     0     transparent
            //  1     1     inverse
            if ( AndByte & (1 << AndBit) )
            {
                //
                // Transparent or inverse
                //
                if ( ulColor == 0 )
                {
                    //
                    // color == black:
                    // Transparent and seeing as the CI2ColorData is initialized
                    // to 0 we don't have to explicitly clear these bits - go on
                    // to the next pixel
                    //
                    DBG_GDI((7, "bSet15ColorPointerShapeP2RD: transparent - ignore"));
                    continue;
                }

                if ( ulColor == ppdev->ulWhite )
                {
                    //
                    // color == white:
                    // Inverse, but we don't support this. We've destroyed the
                    // cache for nothing
                    //
                    DBG_GDI((7, "bSet15ColorPointerShapeP2RD: failed - inverted colors aren't supported"));
                    return(FALSE);
                }
            }

            //
            // Get the index for this color: first see if we've already indexed
            // it
            //
            DBG_GDI((7, "bSet15ColorPointerShapeP2RD: looking up color %08xh",
                     ulColor));

            for ( Index = 0;
                  Index < HighestIndex && aulColorsIndexed[Index] != ulColor;
                  ++Index );

            if ( Index == 15 )
            {
                //
                // Too many colors in this cursor
                //
                DBG_GDI((7, "bSet15ColorPointerShapeP2RD: failed - cursor has more than 15 colors"));
                return(FALSE);
            }
            else if ( Index == HighestIndex )
            {
                //
                // We've found another color: add it to the color index
                //
                DBG_GDI((7, "bSet15ColorPointerShapeP2RD: adding %08xh to cursor palette",
                         ulColor));
                aulColorsIndexed[HighestIndex++] = ulColor;
            }
            
            //
            // Add this pixel's index to the CI4 cursor data.
            // Note: Need Index+1 as 0 == transparent
            //
            CI4ColorData |= (Index + 1) << CI4ColorIndex;
        }

        //
        // End of the cursor row: save the remaining indexed pixels then blank
        // any unused columns
        //
        DBG_GDI((7, "bSet15ColorPointerShapeP2RD: writing remaining data for this row (%08xh) and %d trailing bytes", CI4ColorData, cjCacheRemx));

        P2RD_LOAD_CURSOR_ARRAY(CI4ColorData);
        if ( cjCacheRemx )
        {
            for ( cj = cjCacheRemx; --cj >=0; )
            {
                P2RD_LOAD_CURSOR_ARRAY(P2RD_CURSOR_15_COLOR_TRANSPARENT);
            }
        }
    }

    //
    // End of cursor: blank any unused rows Nb. cjCacheRemy == cy blank
    // rows * cj bytes per row
    //
    DBG_GDI((7, "bSet15ColorPointerShapeP2RD: writing %d trailing bytes for this cursor", cjCacheRemy));
    for ( cj = cjCacheRemy; --cj >= 0; )
    {
        //
        // 0 == transparent
        //
        P2RD_LOAD_CURSOR_ARRAY(P2RD_CURSOR_15_COLOR_TRANSPARENT);
    }

    DBG_GDI((7, "bSet15ColorPointerShapeP2RD: setting up the cursor palette"));

    // now set-up the cursor palette
    for ( iCol = 0; iCol < HighestIndex; ++iCol )
    {
        //
        // The cursor colors are at native depth, convert them to 24bpp
        //
        if ( ppdev->cPelSize == P2DEPTH32 )
        {
            //
            // 32bpp
            //
            b = 0xff &  aulColorsIndexed[iCol];
            g = 0xff & (aulColorsIndexed[iCol] >> 8);
            r = 0xff & (aulColorsIndexed[iCol] >> 16);
        }
        else
        {
            //
            // (ppdev->cPelSize == P2DEPTH16)
            //
            if ( ppdev->ulWhite == 0xffff )
            {
                //
                // 16bpp
                //
                b = (0x1f &  aulColorsIndexed[iCol])         << 3;
                g = (0x3f & (aulColorsIndexed[iCol] >> 5))   << 2;
                r = (0x1f & (aulColorsIndexed[iCol] >> 11))  << 3;
            }
            else
            {
                //
                // 15bpp
                //
                b = (0x1f &  aulColorsIndexed[iCol])         << 3;
                g = (0x1f & (aulColorsIndexed[iCol] >> 5))   << 3;
                r = (0x1f & (aulColorsIndexed[iCol] >> 10))  << 3;
            }
        }

        P2RD_CURSOR_PALETTE_CURSOR_RGB(iCol, r, g, b);
    }

    //
    // Enable the cursor
    //
    P2RD_CURSOR_HOTSPOT(xHot, yHot);
    if ( x != -1 )
    {
        vMovePointerP2RD (ppdev, x, y);
        
        //
        // need to explicitly show the pointer if not using interrupts
        //
        vShowPointerP2RD(ppdev, TRUE);
    }

    DBG_GDI((6, "b3ColorSetPointerShapeP2RD done"));
    return(TRUE);
}// bSet15ColorPointerShapeP2RD()

//-----------------------------------------------------------------------------
//
// VOID vShowPointerTVP4020
//
// Show or hide the TI TVP4020 hardware pointer.
//
//-----------------------------------------------------------------------------
VOID
vShowPointerTVP4020(PDev*   ppdev,
                    BOOL    bShow)
{
    ULONG ccr;
    PERMEDIA_DECL_VARS;
    TVP4020_DECL_VARS;

    PERMEDIA_DECL_INIT;
    TVP4020_DECL_INIT;

    DBG_GDI((6, "vShowPointerTVP4020 (%s)", bShow ? "on" : "off"));
    if ( bShow )
    {
        //
        // No need to sync since this case is called only if we've just moved
        // the cursor and that will already have done a sync.
        //
        ccr = (pTVP4020info->cursorControlCurrent | TVP4020_CURSOR_XGA);
    }
    else
    {
        ccr = pTVP4020info->cursorControlOff & ~TVP4020_CURSOR_XGA;
    }

    TVP4020_WRITE_INDEX_REG(__TVP4020_CURSOR_CONTROL, ccr);
}// vShowPointerTVP4020()

//-----------------------------------------------------------------------------
//
// VOID vMovePointerTVP4020
//
// Move the TI TVP4020 hardware pointer.
//
//-----------------------------------------------------------------------------
VOID
vMovePointerTVP4020(PDev*   ppdev,
                    LONG    x,
                    LONG    y)
{
    PERMEDIA_DECL_VARS;
    TVP4020_DECL_VARS;

    PERMEDIA_DECL_INIT;
    TVP4020_DECL_INIT;

    DBG_GDI((6, "vMovePointerTVP4020 to (%d, %d)", x, y));

    TVP4020_MOVE_CURSOR(x + ppdev->xPointerHot , y + ppdev->yPointerHot);
}// vMovePointerTVP4020()

//-----------------------------------------------------------------------------
//
// BOOL bSetPointerShapeTVP4020
//
// Set the TI TVP4020 hardware pointer shape.
//
// Parameters:
//  psoMask-----defines AND and MASK bits for cursor
//  psoColor----we may handle some color cursors at some point
//  x-----------If -1, pointer should be created hidden
//
//-----------------------------------------------------------------------------
BOOL
bSetPointerShapeTVP4020(PDev*       ppdev,
                        SURFOBJ*    psoMask,
                        SURFOBJ*    psoColor,
                        LONG        x,
                        LONG        y,
                        LONG        xHot,
                        LONG        yHot)
{
    ULONG   cx;
    ULONG   cy;
    ULONG   i, iMax;
    ULONG   j, jMax;
    BYTE    bValue;
    BYTE*   pjScan;
    LONG    lDelta;
    ULONG   cValid;
    ULONG   ulMask;
    ULONG   cursorRAMxOff;
    ULONG   cursorRAMyOff;
    BOOL    pointerIsCached;
    LONG    cacheItem;

    PERMEDIA_DECL_VARS;
    TVP4020_DECL_VARS;

    PERMEDIA_DECL_INIT;
    TVP4020_DECL_INIT;

    DBG_GDI((6, "bSetPointerShapeTVP4020 started"));

    cx = psoMask->sizlBitmap.cx;        // Note that 'sizlBitmap.cy' accounts
    cy = psoMask->sizlBitmap.cy >> 1;   // for the double height due to the
                                        // inclusion of both the AND masks
                                        // and the XOR masks.  We're
                                        // only interested in the true
                                        // pointer dimensions, so we divide
                                        // by 2.

    //
    // We currently don't handle colored cursors. Later, we could handle
    // cursors up to 64x64 with <= 3 colors. Checking this and setting it up
    // may be more trouble than it's worth.
    //
    if ( psoColor != NULL )
    {
        DBG_GDI((6, "bSetPointerShapeTVP4020: declining colored cursor"));
        return FALSE;
    }

    //
    // We only handle 32x32.
    //
    if ( (cx > 32) || (cy > 32) )
    {
        DBG_GDI((6, "declining cursor: %d x %d is too big", cx, cy));
        return(FALSE);  // cursor is too big to fit in the hardware
    }

    //
    // Check to see if the pointer is cached, add it to the cache if it isn't
    //
    DBG_GDI((6, "iUniq =%ld hsurf=0x%x", psoMask->iUniq, psoMask->hsurf));

    cacheItem = HWPointerCacheCheckAndAdd(&(ppdev->HWPtrCache),
                                          psoMask->hsurf,
                                          psoMask->iUniq,
                                          &pointerIsCached);

    DBG_GDI((7, "bSetPointerShapeTVP4020: Add Cache iscac %d item %d",
             (int)pointerIsCached, cacheItem));

    vMovePointerTVP4020(ppdev, 0, ppdev->cyScreen + 64);

    pTVP4020info->cursorControlCurrent = pTVP4020info->cursorControlOff
                                       | TVP4020_CURSOR_SIZE_32
                                       | TVP4020_CURSOR_32_SEL(cacheItem);

    //
    // Cursor slots 1 & 3 have an x offset of 8 bytes, cursor slots 2 & 3 have
    // a y offset of 256 bytes
    //
    cursorRAMxOff = (cacheItem & 1) << 2;
    cursorRAMyOff = (cacheItem & 2) << 7;

    //
    // If the pointer is not cached, then download the pointer data to the DAC
    //
    if ( !pointerIsCached )
    {
        //
        // Disable the pointer
        //
        TVP4020_WRITE_INDEX_REG(__TVP4020_CURSOR_CONTROL,
                                pTVP4020info->cursorControlCurrent);

        cValid = (cx + 7) / 8;
        ulMask = gajMask[cx & 0x07];
        if ( ulMask == 0 )
        {
            ulMask = 0xFF;
        }

        pjScan = (UCHAR*)psoMask->pvScan0;
        lDelta = psoMask->lDelta;

        iMax = 32;      // max rows for 32 x 32 cursor
        jMax = 4;       // max column bytes

        //
        // Send cursor plane 0 - in our case XOR
        //
        for ( i = 0; i < iMax; ++i )
        {
            TVP4020_CURSOR_ARRAY_START(CURSOR_PLANE0_OFFSET + cursorRAMyOff
                                       + (i * 8) + cursorRAMxOff);
            for ( j = 0; j < jMax; ++j )
            {
                if ( (j < cValid) && ( i < cy ) )
                {
                    bValue = *(pjScan + j + (i + cy) * lDelta);
                }
                else
                {
                    bValue = 0;
                }
                TVP4020_LOAD_CURSOR_ARRAY((ULONG)bValue);
            }
        }

        //
        // Send cursor plane 1 - in our case AND
        //
        for ( i = 0; i < iMax; ++i )
        {
            TVP4020_CURSOR_ARRAY_START(CURSOR_PLANE1_OFFSET + cursorRAMyOff
                                       + (i * 8) + cursorRAMxOff);
            for ( j = 0; j < jMax; ++j )
            {
                if ( (j < cValid) && ( i < cy ) )
                {
                    bValue = *(pjScan + j + i * lDelta);
                }
                else
                {
                    bValue = 0xFF;
                }
                TVP4020_LOAD_CURSOR_ARRAY((ULONG)bValue);
            }
        }
    }// If pointer is not cached

    //
    // If the new cursor is different to the last cursor then set up the hot
    // spot and other bits'n'pieces.
    //
    if ( ppdev->HWPtrLastCursor != cacheItem || !pointerIsCached )
    {
        //
        // Make this item the last item
        //
        ppdev->HWPtrLastCursor = cacheItem;

        ppdev->xPointerHot = 32 - xHot;
        ppdev->yPointerHot = 32 - yHot;
    }

    if ( x != -1 )
    {
        vShowPointerTVP4020(ppdev, TRUE);
        vMovePointerTVP4020(ppdev, x, y);

        // Enable the cursor:
    }

    DBG_GDI((6, "bSetPointerShapeTVP4020 done"));
    return(TRUE);
}// bSetPointerShapeTVP4020()

//-----------------------------------------------------------------------------
//
// VOID vEnablePointerTVP4020
//
// Get the hardware ready to use the TI TVP4020 hardware pointer.
//
//-----------------------------------------------------------------------------
VOID
vEnablePointerTVP4020(PDev* ppdev)
{
    pTVP4020RAMDAC      pRamdac;
    ULONG               ulMask;

    PERMEDIA_DECL_VARS;
    TVP4020_DECL_VARS;

    PERMEDIA_DECL_INIT;

    DBG_GDI((6, "vEnablePointerTVP4020 called"));
    ppdev->pvPointerData = &ppdev->ajPointerData[0];

    TVP4020_DECL_INIT;

    //
    // Get a pointer to the RAMDAC registers from the memory mapped
    // control register space.
    //
    pRamdac = (pTVP4020RAMDAC)(ppdev->pulRamdacBase);

    //
    // set up memory mapping for the control registers and save in the pointer
    // specific area provided in ppdev.
    //
    __TVP4020_PAL_WR_ADDR = (UINT_PTR)
                            TRANSLATE_ADDR_ULONG(&(pRamdac->pciAddrWr));
    __TVP4020_PAL_RD_ADDR = (UINT_PTR)
                            TRANSLATE_ADDR_ULONG(&(pRamdac->pciAddrRd));
    __TVP4020_PAL_DATA    = (UINT_PTR)
                            TRANSLATE_ADDR_ULONG(&(pRamdac->palData));
    __TVP4020_PIXEL_MASK  = (UINT_PTR)
                            TRANSLATE_ADDR_ULONG(&(pRamdac->pixelMask));
    __TVP4020_INDEX_DATA  = (UINT_PTR)
                            TRANSLATE_ADDR_ULONG(&(pRamdac->indexData));

    __TVP4020_CUR_RAM_DATA    = (UINT_PTR)
                                TRANSLATE_ADDR_ULONG(&(pRamdac->curRAMData));
    __TVP4020_CUR_RAM_WR_ADDR = (UINT_PTR)
                                TRANSLATE_ADDR_ULONG(&(pRamdac->pciAddrWr));
    __TVP4020_CUR_RAM_RD_ADDR = (UINT_PTR)
                                TRANSLATE_ADDR_ULONG(&(pRamdac->pciAddrRd));
    __TVP4020_CUR_COL_ADDR    = (UINT_PTR)
                                TRANSLATE_ADDR_ULONG(&(pRamdac->curColAddr));
    __TVP4020_CUR_COL_DATA    = (UINT_PTR)
                                TRANSLATE_ADDR_ULONG(&(pRamdac->curColData));
    __TVP4020_CUR_X_LSB       = (UINT_PTR)
                                TRANSLATE_ADDR_ULONG(&(pRamdac->cursorXLow));
    __TVP4020_CUR_X_MSB       = (UINT_PTR)
                                TRANSLATE_ADDR_ULONG(&(pRamdac->cursorXHigh));
    __TVP4020_CUR_Y_LSB       = (UINT_PTR)
                                TRANSLATE_ADDR_ULONG(&(pRamdac->cursorYLow));
    __TVP4020_CUR_Y_MSB       = (UINT_PTR)
                                TRANSLATE_ADDR_ULONG(&(pRamdac->cursorYHigh));

    //
    // Initialize Cursor Control register. disables cursor. save a copy for
    // enabling/disabling and setting the size. Then reset the cursor position,
    // hot spot and colors.
    //
    // ulMask is used to prepare initial cursor control register
    //
    ulMask = TVP4020_CURSOR_RAM_MASK
           | TVP4020_CURSOR_MASK
           | TVP4020_CURSOR_SIZE_MASK;

    //
    // Set the cursor control to default values.
    //
    TVP4020_READ_INDEX_REG(__TVP4020_CURSOR_CONTROL,
                           pTVP4020info->cursorControlOff);
    pTVP4020info->cursorControlOff &= ~ulMask;
    pTVP4020info->cursorControlOff |=  TVP4020_CURSOR_OFF;

    TVP4020_WRITE_INDEX_REG(__TVP4020_CURSOR_CONTROL,
                            pTVP4020info->cursorControlOff);
    pTVP4020info->cursorControlCurrent = pTVP4020info->cursorControlOff;

    ppdev->xPointerHot = 0;
    ppdev->yPointerHot = 0;

    //
    // Zero the RGB colors for foreground and background. The mono cursor is
    // always black and white so we don't have to reload these values again.
    //
    TVP4020_SET_CURSOR_COLOR0(0, 0, 0);
    TVP4020_SET_CURSOR_COLOR1(0xFF, 0xFF, 0xFF);
}// vEnablePointerTVP4020()

//-----------------------------------------------------------------------------
//
// BOOL bTVP4020CheckCSBuffering
//
// Determine whether we can do color space double buffering in the current
// mode.
//
// Returns
//   TRUE if we can do the color space double buffering, FALSE otherwise.
//
//-----------------------------------------------------------------------------
BOOL
bTVP4020CheckCSBuffering(PDev* ppdev)
{
    return FALSE;
}

//-----------------------------------------------------------------------------
//
// BOOL bSetPointerShapeP2RD
//
// Set the P2RD hardware pointer shape.
//
//-----------------------------------------------------------------------------
BOOL
bSetPointerShapeP2RD(PDev*      ppdev,
                     SURFOBJ*   pso,       // defines AND and MASK bits for cursor
                     SURFOBJ*   psoColor,  // we may handle some color cursors at some point
                     XLATEOBJ*  pxlo,
                     LONG       x,          // If -1, pointer should be created hidden
                     LONG       y,
                     LONG       xHot,
                     LONG       yHot)
{
    ULONG   cx;
    ULONG   cy;
    LONG    i;
    LONG    j;
    ULONG   ulValue;
    BYTE*   pjAndScan;
    BYTE*   pjXorScan;
    BYTE*   pjAnd;
    BYTE*   pjXor;
    BYTE    andByte;
    BYTE    xorByte;
    BYTE    jMask;
    LONG    lDelta;
    LONG    cpelFraction;
    LONG    cjWhole;
    LONG    cClear;
    LONG    cRemPels;
    BOOL    pointerIsCached;
    LONG    cacheItem;
    LONG    cursorBytes;
    LONG    cursorRAMOff;

    PERMEDIA_DECL_VARS;
    P2RD_DECL_VARS;

    PERMEDIA_DECL_INIT;
    P2RD_DECL_INIT;

    DBG_GDI((6, "bSetPointerShapeP2RD called"));

    if ( psoColor != NULL )
    {
        Surf*  psurfSrc = (Surf*)psoColor->dhsurf;

        //
        // It's a colored cursor
        //
        if ( (psoColor->dhsurf != NULL)
           ||(!(psoColor->iBitmapFormat == BMF_16BPP))
           ||(psoColor->iBitmapFormat == BMF_32BPP) )
        {
            //
            // Currently we only handle DIB cursors at 32bpp
            //
            DBG_GDI((2, "declining colored cursor - iType(%d) iBMPFormat(%d)",
                     psoColor->iType, psoColor->iBitmapFormat));
            return FALSE;
        }

        if ( pxlo != NULL )
        {
            if ( pxlo->flXlate != XO_TRIVIAL )
            {
                DBG_GDI((2, "declining colored cursor - flXlate(%xh)",
                         pxlo->flXlate));
                return FALSE;
            }
        }

        if ( !bSet15ColorPointerShapeP2RD(ppdev, pso, psoColor, x, y, xHot,
                                          yHot) )
        {
            DBG_GDI((2, "declining colored cursor"));
            return FALSE;
        }

        DBG_GDI((6, "bSetPointerShapeP2RD done"));
        return(TRUE);
    }// if ( psoColor != NULL )

    //
    // Note that 'sizlBitmap.cy' accounts for the double height due to the
    // inclusion of both the AND masks and the XOR masks. We're only
    // interested in the true pointer dimensions, so we divide by 2.
    //
    cx = pso->sizlBitmap.cx;
    cy = pso->sizlBitmap.cy >> 1;

    //
    // We can handle up to 64x64.  cValid indicates the number of bytes
    // occupied by cursor on one line
    //
    if ( cx <= 32 && cy <= 32 )
    {
        //
        // 32 horiz pixels: 2 bits per pixel, 1 horiz line per 8 bytes
        //
        pP2RDinfo->cursorSize = P2RD_CURSOR_SIZE_32_MONO;
        cursorBytes = 32 * 32 * 2 / 8;
        cClear   = 8 - 2 * ((cx+7) / 8);
        cRemPels = (32 - cy) << 3;
    }
    else
    {
        DBG_GDI((6, "declining cursor: %d x %d is too big", cx, cy));
        return(FALSE);  // cursor is too big to fit in the hardware
    }

    //
    // Check to see if the pointer is cached, add it to the cache if it isn't
    //
    cacheItem = HWPointerCacheCheckAndAdd(&(ppdev->HWPtrCache),
                                          pso->hsurf,
                                          pso->iUniq,
                                          &pointerIsCached);

    DBG_GDI((7, "bSetPointerShapeP2RD: Add Cache iscac %d item %d",
             (int)pointerIsCached, cacheItem));

    pP2RDinfo->cursorModeCurrent = pP2RDinfo->cursorModeOff
                                 | P2RD_CURSOR_SEL(pP2RDinfo->cursorSize,
                                                   cacheItem);

    //
    // Hide the pointer
    //
    vShowPointerP2RD(ppdev, FALSE);

    if ( !pointerIsCached )
    {
        //
        // Now we're going to take the requested pointer AND masks and XOR
        // masks and interleave them by taking a nibble at a time from each,
        // expanding each out and or'ing together. Use the nibbleToByteP2RD
        // array to help this.
        //
        // 'psoMsk' is actually cy * 2 scans high; the first 'cy' scans
        // define the AND mask.
        //
        pjAndScan = (UCHAR*)pso->pvScan0;
        lDelta    = pso->lDelta;
        pjXorScan = pjAndScan + (cy * lDelta);

        cjWhole      = cx >> 3;     // Each byte accounts for 8 pels
        cpelFraction = cx & 0x7;    // Number of fractional pels
        jMask        = gajMask[cpelFraction];

        //
        // We've got auto-increment turned on so just point to the first entry
        // to write to in the array then write repeatedly until the cursor
        // pattern has been transferred
        //
        cursorRAMOff = cacheItem * cursorBytes;
        P2RD_CURSOR_ARRAY_START(cursorRAMOff);

        for ( i = cy; --i >= 0; pjXorScan += lDelta, pjAndScan += lDelta )
        {
            pjAnd = pjAndScan;
            pjXor = pjXorScan;

            //
            // Interleave nibbles from whole words. We are using Windows cursor
            // mode.
            // Note, the AND bit occupies the higher bit position for each
            // 2bpp cursor pel; the XOR bit is in the lower bit position.
            // The nibbleToByteP2RD array expands each nibble to occupy the bit
            // positions for the AND bytes. So when we use it to calculate the
            // XOR bits we shift the result right by 1.
            //
            for ( j = cjWhole; --j >= 0; ++pjAnd, ++pjXor )
            {
                andByte = *pjAnd;
                xorByte = *pjXor;
                ulValue = nibbleToByteP2RD[andByte >> 4]
                        | (nibbleToByteP2RD[xorByte >> 4] >> 1);
                P2RD_LOAD_CURSOR_ARRAY (ulValue);

                andByte &= 0xf;
                xorByte &= 0xf;
                ulValue = nibbleToByteP2RD[andByte]
                        | (nibbleToByteP2RD[xorByte] >> 1);
                P2RD_LOAD_CURSOR_ARRAY (ulValue);
            }

            if ( cpelFraction )
            {
                andByte = *pjAnd & jMask;
                xorByte = *pjXor & jMask;
                ulValue = nibbleToByteP2RD[andByte >> 4]
                        | (nibbleToByteP2RD[xorByte >> 4] >> 1);
                P2RD_LOAD_CURSOR_ARRAY (ulValue);

                andByte &= 0xf;
                xorByte &= 0xf;
                ulValue = nibbleToByteP2RD[andByte]
                        | (nibbleToByteP2RD[xorByte] >> 1);
                P2RD_LOAD_CURSOR_ARRAY (ulValue);
            }

            //
            // Finally clear out any remaining cursor pels on this line.
            //
            if ( cClear )
            {
                for ( j = 0; j < cClear; ++j )
                {
                    P2RD_LOAD_CURSOR_ARRAY (P2RD_CURSOR_2_COLOR_TRANSPARENT);
                }
            }
        }

        //
        // If we've loaded fewer than the full number of lines configured in
        // the cursor RAM, clear out the remaining lines. cRemPels is
        // precalculated to be the number of lines * number of pels per line.
        //
        if ( cRemPels > 0 )
        {
            do
            {
                P2RD_LOAD_CURSOR_ARRAY (P2RD_CURSOR_2_COLOR_TRANSPARENT);
            }
            while ( --cRemPels > 0 );
        }
    }// if ( !pointerIsCached )

    //
    // Now set-up the cursor colors
    //
    P2RD_CURSOR_PALETTE_CURSOR_RGB(0, 0x00, 0x00, 0x00);
    P2RD_CURSOR_PALETTE_CURSOR_RGB(1, 0xFF, 0xFF, 0xFF);

    //
    // If the new cursor is different to the last cursor then set up
    // the hot spot and other bits'n'pieces. As we currently only support
    // mono cursors we don't need to reload the cursor palette
    //
    if ( ppdev->HWPtrLastCursor != cacheItem || !pointerIsCached )
    {
        //
        // Make this item the last item
        //
        ppdev->HWPtrLastCursor = cacheItem;

        P2RD_CURSOR_HOTSPOT(xHot, yHot);
    }

    if ( x != -1 )
    {
        vMovePointerP2RD (ppdev, x, y);
        
        //
        // Need to explicitly show the pointer if not using interrupts
        //
        vShowPointerP2RD(ppdev, TRUE);
    }

    DBG_GDI((6, "bSetPointerShapeP2RD done"));
    return(TRUE);
}// bSetPointerShapeP2RD()

//-----------------------------------------------------------------------------
//
// VOID vEnablePointerP2RD
//
// Get the hardware ready to use the 3Dlabs P2RD hardware pointer.
//
//-----------------------------------------------------------------------------
VOID
vEnablePointerP2RD(PDev* ppdev)
{
    pP2RDRAMDAC pRamdac;
    ULONG       ul;

    PERMEDIA_DECL_VARS;
    P2RD_DECL_VARS;

    PERMEDIA_DECL_INIT;

    DBG_GDI((6, "vEnablePointerP2RD called"));

    ppdev->pvPointerData = &ppdev->ajPointerData[0];

    P2RD_DECL_INIT;

    //
    // get a pointer to the RAMDAC registers from the memory mapped
    // control register space.
    //
    pRamdac = (pP2RDRAMDAC)(ppdev->pulRamdacBase);

    //
    // set up memory mapping for the control registers and save in the pointer
    // specific area provided in ppdev.
    //
    P2RD_PAL_WR_ADDR
        = (ULONG_PTR)TRANSLATE_ADDR_ULONG(&(pRamdac->RDPaletteWriteAddress));
    P2RD_PAL_RD_ADDR
        = (ULONG_PTR)TRANSLATE_ADDR_ULONG(&(pRamdac->RDPaletteAddressRead));
    P2RD_PAL_DATA
        = (ULONG_PTR)TRANSLATE_ADDR_ULONG(&(pRamdac->RDPaletteData));
    P2RD_PIXEL_MASK
        = (ULONG_PTR)TRANSLATE_ADDR_ULONG(&(pRamdac->RDPixelMask));
    P2RD_INDEX_ADDR_HI
        = (ULONG_PTR)TRANSLATE_ADDR_ULONG(&(pRamdac->RDIndexHigh));
    P2RD_INDEX_ADDR_LO
        = (ULONG_PTR)TRANSLATE_ADDR_ULONG(&(pRamdac->RDIndexLow));
    P2RD_INDEX_DATA
        = (ULONG_PTR)TRANSLATE_ADDR_ULONG(&(pRamdac->RDIndexedData));
    P2RD_INDEX_CONTROL 
        = (ULONG_PTR)TRANSLATE_ADDR_ULONG(&(pRamdac->RDIndexControl));

    //
    // Not used, but set-up zero anyway
    //
    ppdev->xPointerHot = 0;
    ppdev->yPointerHot = 0;

    //
    // Enable auto-increment
    //
    ul = READ_P2RDREG_ULONG(P2RD_INDEX_CONTROL);
    ul |= P2RD_IDX_CTL_AUTOINCREMENT_ENABLED;
    WRITE_P2RDREG_ULONG(P2RD_INDEX_CONTROL, ul);

    P2RD_READ_INDEX_REG(P2RD_CURSOR_CONTROL, pP2RDinfo->cursorControl);

    pP2RDinfo->cursorModeCurrent = pP2RDinfo->cursorModeOff = 0;
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_MODE, pP2RDinfo->cursorModeOff);

    P2RD_INDEX_REG(P2RD_CURSOR_X_LOW);
    P2RD_LOAD_DATA(0);      // cursor x low
    P2RD_LOAD_DATA(0);      // cursor x high
    P2RD_LOAD_DATA(0);      // cursor y low
    P2RD_LOAD_DATA(0xff);   // cursor y high
    P2RD_LOAD_DATA(0);      // cursor x hotspot
    P2RD_LOAD_DATA(0);      // cursor y hotspot
}// vEnablePointerP2RD()

//-----------------------------------------------------------------------------
//
// BOOL bP2RDCheckCSBuffering
//
// Determine whether we can do color space double buffering in the current mode
//
// Returns
//   TRUE if we can do the color space double buffering, FALSE otherwise.
//
//-----------------------------------------------------------------------------
BOOL
bP2RDCheckCSBuffering(PDev* ppdev)
{
    return (FALSE);
}// bP2RDCheckCSBuffering()

//-----------------------------------------------------------------------------
//
// BOOL bP2RDSwapCSBuffers
//
// Use the pixel read mask to perform color space double buffering. This is
// only called when we have 12bpp with interleaved nibbles. We do a polled
// wait for VBLANK before the swap. In the future we may do all this in the
// miniport via interrupts.
//
// Returns
//   We should never be called if this is inappropriate so return TRUE.
//
//-----------------------------------------------------------------------------
BOOL
bP2RDSwapCSBuffers(PDev*   ppdev,
                   LONG    bufNo)
{
    ULONG index;
    ULONG color;
    PERMEDIA_DECL_VARS;
    P2RD_DECL_VARS;
    PERMEDIA_DECL_INIT;
    P2RD_DECL_INIT;

    //
    // Work out the RAMDAC read pixel mask for the buffer
    //
    DBG_GDI((6, "loading the palette to swap to buffer %d", bufNo));
    P2RD_PALETTE_START_WR (0);
    
    if ( bufNo == 0 )
    {
        for ( index = 0; index < 16; ++index )
            for ( color = 0; color <= 0xff; color += 0x11 )
                P2RD_LOAD_PALETTE (color, color, color);
    }
    else
    {
        for ( color = 0; color <= 0xff; color += 0x11 )
            for ( index = 0; index < 16; ++index )
                P2RD_LOAD_PALETTE (color, color, color);
    }

    return(TRUE);
}// bP2RDSwapCSBuffers()

//-------------------------------Public*Routine-------------------------------
//
// VOID DrvMovePointer
//
// This function moves the pointer to a new position and ensures that GDI does
// not interfere with the display of the pointer.
//
// Parameters:
// pso-------Points to a SURFOBJ structure that describes the surface of a
//           display device.
// x,y-------Specify the x and y coordinates on the display where the hot spot
//           of the pointer should be positioned.
//           A negative x value indicates that the pointer should be removed
//           from the display because drawing is about to occur where it is
//           presently located. If the pointer has been removed from the display
//           and the x value is nonnegative, the pointer should be restored.
//
//           A negative y value indicates that GDI is calling this function only
//           to notify the driver of the cursor's current position. The current
//           position can be computed as (x, y+pso->sizlBitmap.cy).
// prcl------Points to a RECTL structure defining an area that bounds all pixels
//           affected by the pointer on the display. GDI will not draw in this
//           rectangle without first removing the pointer from the screen. This
//           parameter can be null.
//
// NOTE: Because we have set GCAPS_ASYNCMOVE, this call may occur at any
//       time, even while we're executing another drawing call!
//
//-----------------------------------------------------------------------------
VOID
DrvMovePointer(SURFOBJ* pso,
               LONG     x,
               LONG     y,
               RECTL*   prcl)
{
    PDev*   ppdev = (PDev*)pso->dhpdev;

    DBG_GDI((6, "DrvMovePointer called, dhpdev(%xh), to pos(%ld, %ld)",
             ppdev, x, y));

    //
    // A negative y value indicates that GDI is calling this function only to
    // notify the driver of the cursor's current position. So, at least, for
    // HW cursor, we don't need to move this pointer. Just return
    //
    if ( ( y < 0 ) && ( x > 0 ) )
    {
        DBG_GDI((6, "DrvMovePointer return because x and y both < 0"));
        return;
    }

    DBG_GDI((6, "DrvMovePointer really moves HW pointer"));

    //
    // Negative X indicates that the pointer should be removed from the display
    // because drawing is about to occur where it is presently located.
    //
    if ( x > -1 )
    {
        //
        // If we're doing any hardware zooming then the cusor position will
        // have to be doubled.
        //
        if ( (ppdev->flCaps & CAPS_P2RD_POINTER) == 0 )
        {
            if ( ppdev->flCaps & CAPS_ZOOM_Y_BY2 )
            {
                DBG_GDI((6,"HW zooming Y_BY2"));
                y *= 2;
            }
            if ( ppdev->flCaps & CAPS_ZOOM_X_BY2 )
            {
                DBG_GDI((6,"HW zooming X_BY2"));
                x *= 2;
            }
        }

        //
        // If they have genuinely moved the cursor, then move it
        //
        if ( (x != ppdev->HWPtrPos_X) || (y != ppdev->HWPtrPos_Y) )
        {
            if ( ppdev->flCaps & CAPS_TVP4020_POINTER )
            {
                vMovePointerTVP4020(ppdev, x, y);
            }
            else if ( ppdev->flCaps & CAPS_P2RD_POINTER )
            {
                vMovePointerP2RD(ppdev, x, y);
            }

            ppdev->HWPtrPos_X = x;
            ppdev->HWPtrPos_Y = y;
        }

        //
        // We may have to make the pointer visible:
        //
        if ( !(ppdev->flPointer & PTR_HW_ACTIVE) )
        {
            DBG_GDI((6, "Showing hardware pointer"));
            ppdev->flPointer |= PTR_HW_ACTIVE;

            if ( ppdev->flCaps & CAPS_TVP4020_POINTER )
            {
                vShowPointerTVP4020(ppdev, TRUE);
            }
            else if ( ppdev->flCaps & CAPS_P2RD_POINTER )
            {
                vShowPointerP2RD(ppdev, TRUE);
            }
        }
    }// if ( x > -1 )
    else if ( ppdev->flPointer & PTR_HW_ACTIVE )
    {
        //
        // The pointer is visible, and we've been asked to hide it
        //
        DBG_GDI((6, "Hiding hardware pointer"));
        ppdev->flPointer &= ~PTR_HW_ACTIVE;

        if ( ppdev->flCaps & CAPS_TVP4020_POINTER )
        {
            DBG_GDI((7, "Showing hardware pointer"));
            vShowPointerTVP4020(ppdev, FALSE);
        }
        else if ( ppdev->flCaps & CAPS_P2RD_POINTER )
        {
            vShowPointerP2RD(ppdev, FALSE);
        }
    }

    //
    // Note that we don't have to modify 'prcl', since we have a
    // NOEXCLUDE pointer...
    //
    DBG_GDI((6, "DrvMovePointer exited, dhpdev(%xh)", ppdev));
}// DrvMovePointer()

//---------------------------Public*Routine------------------------------------
//
// VOID DrvSetPointerShape
//
// This function is used to request the driver to:
//
// 1) Take the pointer off the display, if the driver has drawn it there.
// 2) Attempt to set a new pointer shape.
// 3) Put the new pointer on the display at a specified position.
//
// Parameters:
// psO-------Points to a SURFOBJ structure that describes the surface on which
//           TO draw.
// psoMask---Points to a SURFOBJ structure that defines the AND-XOR mask. (The
//           AND-XOR mask is described in Drawing Monochrome Pointers.) The
//           dimensions of this bitmap determine the size of the pointer. There
//           are no implicit constraints on pointer sizes, but optimal pointer
//           sizes are 32 x 32, 48 x 48, and 64 x 64 pixels. If this parameter
//           IS NULL, the pointer is transparent.
// psoColor--Points to a SURFOBJ structure that defines the colors for a color
//           pointer. If this parameter is NULL, the pointer is monochrome. The
//           pointer bitmap has the same width as psoMask and half the height.
// pxlo------Points to a XLATEOBJ structure that defines the colors in psoColor.
// xHot,yHot-Specify the x and y positions of the pointer's hot spot relative
//           to its upper-left pixel. The pixel indicated by the hot spot should
//           be positioned at the new pointer position.
// x, y------Specify the new pointer position.
// prcl------Is the location in which the driver should write a rectangle that
//           specifies a tight bound for the visible portion of the pointer.
// fl--------Specifies an extensible set of flags. The driver should decline the
//           call if any flags are set that it does not understand. This
//           parameter can be one or more of the following predefined values,
//           and one or more driver-defined values:
//   Flag Meaning
//   SPS_CHANGE----------The driver is requested to change the pointer shape.
//   SPS_ASYNCCHANGE-----This flag is obsolete. For legacy drivers, the driver
//                       should accept the change only if it is capable of
//                       changing the pointer shape in the hardware while other
//                       drawing is underway on the device. GDI uses this option
//                       only if the now obsolete GCAPS_ASYNCCHANGE flag is set
//                       in the flGraphicsCaps member of the DEVINFO structure.
//   SPS_ANIMATESTART----The driver should be prepared to receive a series of
//                       similarly-sized pointer shapes that will comprise an
//                       animated pointer effect.
//   SPS_ANIMATEUPDATE---The driver should draw the next pointer shape in the
//                       animated series.
//   SPS_ALPHA-----------The pointer has per-pixel alpha values.
//
// Return Value
//   The return value can be one of the following values:
//
//   Value Meaning
//   SPS_ERROR-----------The driver normally supports this shape, but failed for
//                       unusual reasons.
//   SPS_DECLINE---------The driver does not support the shape, so GDI must
//                       simulate it.
//   SPS_ACCEPT_NOEXCLUDE-The driver accepts the shape. The shape is supported
//                       in hardware and GDI is not concerned about other
//                       drawings overwriting the pointer.
//   SPS_ACCEPT_EXCLUDE--Is obsolete. GDI will disable the driver's pointer and
//                       revert to software simulation if the driver returns
//                       this value.
//
//-----------------------------------------------------------------------------
ULONG
DrvSetPointerShape(SURFOBJ*    pso,
                   SURFOBJ*    psoMsk,
                   SURFOBJ*    psoColor,
                   XLATEOBJ*   pxlo,
                   LONG        xHot,
                   LONG        yHot,
                   LONG        x,
                   LONG        y,
                   RECTL*      prcl,
                   FLONG       fl)
{
    PDev*   ppdev;
    BOOL    bAccept = FALSE;
    
    ppdev = (PDev*)pso->dhpdev;
    
    DBG_GDI((6, "DrvSetPointerShape called, dhpdev(%x)", ppdev));
    DBG_GDI((6, "DrvSetPointerShape psocolor (0x%x)", psoColor));

    //
    // When CAPS_SW_POINTER is set, we have no hardware pointer available,
    // so we always ask GDI to simulate the pointer for us, using
    // DrvCopyBits calls:
    //
    if ( ppdev->flCaps & CAPS_SW_POINTER )
    {
        DBG_GDI((6, "SetPtrShape: CAPS_SW_POINTER not set, rtn SPS_DECLINE"));
        return (SPS_DECLINE);
    }

    //
    // We're not going to handle flags that we don't understand.
    //
    if ( !(fl & SPS_CHANGE) )
    {
        DBG_GDI((6, "DrvSetPointerShape decline: Unknown flag =%x", fl));
        goto HideAndDecline;
    }

    //
    // Remove any pointer first.
    // We have a special x value for the software cursor to indicate that
    // it should be removed immediatly, not delayed. DrvMovePointer needs to
    // recognise it as remove for any pointers though.
    // Note: CAPS_{P2RD, TVP4020, SW}_POINTER should be set in miniport after
    // it detects the DAC type
    //
    if ( x != -1 )
    {
        if ( (ppdev->flCaps & CAPS_P2RD_POINTER) == 0 )
        {
            //
            // If we're doing any hardware zooming then the cusor position will
            // have to be doubled.
            //
            if ( ppdev->flCaps & CAPS_ZOOM_Y_BY2 )
            {
                y *= 2;
            }
            if ( ppdev->flCaps & CAPS_ZOOM_X_BY2 )
            {
                x *= 2;
            }
        }
    }

    DBG_GDI((6, "iUniq is %ld", psoMsk->iUniq));

    if ( ppdev->flCaps & CAPS_TVP4020_POINTER )
    {
        DBG_GDI((6, "DrvSetPointerShape tring to set TVP4020 pointer"));
        bAccept = bSetPointerShapeTVP4020(ppdev, psoMsk, psoColor,
                                          x, y, xHot, yHot);
    }
    else if ( ppdev->flCaps & CAPS_P2RD_POINTER )
    {
        bAccept = bSetPointerShapeP2RD(ppdev, psoMsk, psoColor, pxlo,
                                       x, y, xHot, yHot);
    }

    //
    // If we failed setup the hardware pointer shape, then return SPS_DECLINE
    // and let GDI handles it
    //
    if ( !bAccept )
    {
        DBG_GDI((6, "set hardware pointer shape failed"));
        return (SPS_DECLINE);
    }

    //
    // Set flag to indicate that we have initialized hardware pointer shape
    // so that in vAssertModePointer, we can do some clean up
    //
    ppdev->bPointerInitialized = TRUE;

    if ( x != -1 )
    {
        //
        // Save the X and Y values
        //
        ppdev->HWPtrPos_X = x;
        ppdev->HWPtrPos_Y = y;

        ppdev->flPointer |= PTR_HW_ACTIVE;
    }
    else
    {
        ppdev->flPointer &= ~PTR_HW_ACTIVE;
    }

    //
    // Since it's a hardware pointer, GDI doesn't have to worry about
    // overwriting the pointer on drawing operations (meaning that it
    // doesn't have to exclude the pointer), so we return 'NOEXCLUDE'.
    // Since we're returning 'NOEXCLUDE', we also don't have to update
    // the 'prcl' that GDI passed us.
    //
    DBG_GDI((6, "DrvSetPointerShape return SPS_ACCEPT_NOEXCLUDE"));
    return (SPS_ACCEPT_NOEXCLUDE);

HideAndDecline:

    //
    // Remove whatever pointer is installed.
    //
    DrvMovePointer(pso, -2, -1, NULL);
    ppdev->flPointer &= ~PTR_SW_ACTIVE;
    DBG_GDI((6, "Cursor declined"));

    DBG_GDI((6, "DrvSetPointerShape exited (cursor declined)"));

    return (SPS_DECLINE);
}// DrvSetPointerShape()

//-----------------------------------------------------------------------------
//
// VOID vAssertModePointer
//
// Do whatever has to be done to enable everything but hide the pointer.
//
//-----------------------------------------------------------------------------
VOID
vAssertModePointer(PDev*   ppdev,
                   BOOL    bEnable)
{
    DBG_GDI((6, "vAssertModePointer called"));

    if ( (ppdev->bPointerInitialized == FALSE)
       ||(ppdev->flCaps & CAPS_SW_POINTER) )
    {
        //
        // With a software pointer, or the pointer hasn't been initialized,
        // we don't have to do anything.
        //

        return;
    }

    //
    // Invalidate the hardware pointer cache
    //
    HWPointerCacheInvalidate(&(ppdev->HWPtrCache));

    if ( ppdev->flCaps & CAPS_TVP4020_POINTER )
    {
        vShowPointerTVP4020(ppdev, FALSE);
    }
    else if ( ppdev->flCaps & CAPS_P2RD_POINTER )
    {
        vShowPointerP2RD(ppdev, FALSE);
    }
    else if ( ppdev->flCaps & CAPS_P2RD_POINTER )
    {
        vEnablePointerP2RD(ppdev);
    }

    ppdev->flPointer &= ~(PTR_HW_ACTIVE | PTR_SW_ACTIVE);
}// vAssertModePointer()

//-----------------------------------------------------------------------------
//
// BOOL bEnablePointer(PDev* ppdev)
//
// This function initializes hardware pointer or software pointer depends on
// on the CAPS settinsg in ppdev->flCaps
//
// This function always returns TRUE
//
//-----------------------------------------------------------------------------
BOOL
bEnablePointer(PDev* ppdev)
{
    DBG_GDI((6, "bEnablePointer called"));

    //
    // Initialise the pointer cache.
    //
    HWPointerCacheInit(&(ppdev->HWPtrCache));

    //
    // Set the last cursor to something invalid
    //
    ppdev->HWPtrLastCursor = HWPTRCACHE_INVALIDENTRY;

    //
    // Initialise the X and Y values to something silly
    //
    ppdev->HWPtrPos_X = 1000000000;
    ppdev->HWPtrPos_Y = 1000000000;

    if ( ppdev->flCaps & CAPS_SW_POINTER )
    {
        // With a software pointer, we don't have to do anything.
    }
    else if ( ppdev->flCaps & CAPS_TVP4020_POINTER )
    {
        vEnablePointerTVP4020(ppdev);
    }
    else if ( ppdev->flCaps & CAPS_P2RD_POINTER )
    {
        vEnablePointerP2RD(ppdev);
    }

    return (TRUE);
}// bEnablePointer()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\permedia.h ===
/******************************Module*Header**********************************\
*
*                           ***************
*                           * SAMPLE CODE *
*                           ***************
*
* Module Name: Permedia.h
*
* Content:     various definitions for the Permedia DMA and FIFO interface
*              and the Permedia class
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef __permedia__
#define __permedia__

#include "mini.h"

#define FASTCALL __fastcall

#if defined(_X86_)
typedef LONG __fastcall _InterlockedExchange( IN OUT PLONG, IN LONG);
typedef _InterlockedExchange *PInterlockedExchange;
#endif

#if defined(_ALPHA_)
extern "C" VOID  __MB(VOID);
#endif

//
//  handy typedefs for FlushDMA and CheckForEOB function pointers
//
typedef VOID (GFNFLUSHDMA)(P2DMA*);
typedef VOID (GFNCHECKEOB)(P2DMA*, LONG);

// Some macros for DirectDraw
#define IN_VRETRACE(xppdev) bInVerticalRetrace(xppdev)
#define IN_DISPLAY(xppdev)  (!IN_VRETRACE(xppdev))
#define CURRENT_VLINE(xppdev) lCurrentLine(xppdev)
#define DRAW_ENGINE_BUSY    bDrawEngineBusy(pP2dma)
#define SYNC_WITH_PERMEDIA  vSyncWithPermedia(pP2dma)

#define READ_CTRL_REG(uiReg)\
    READ_REGISTER_ULONG(&pP2dma->pCtrlBase[uiReg/sizeof(ULONG)])

#define P2_READ_CTRL_REG(uiReg)\
    READ_REGISTER_ULONG(&ppdev->pCtrlBase[uiReg/sizeof(ULONG)])

#define WRITE_CTRL_REG(uiReg, uiValue)\
{   \
    WRITE_REGISTER_ULONG(&pP2dma->pCtrlBase[uiReg/sizeof(ULONG)],uiValue); \
    MEMORY_BARRIER();\
}


// For sending permedia tags.
#define SEND_PERMEDIA_DATA(tag,data)                                    \
    LD_INPUT_FIFO(__Permedia2Tag##tag, data)

#define SEND_PERMEDIA_DATA_OFFSET(tag,data, i)  \
    LD_INPUT_FIFO(__Permedia2Tag##tag+i, data)

#define COPY_PERMEDIA_DATA(tag,data)                            \
    LD_INPUT_FIFO( __Permedia2Tag##tag, *((unsigned long*) &(data)))

#define HOLD_CMD(tag, count) ( __Permedia2Tag##tag | ((count-1) << 16))

// use macros instead of inlines for Fifo downloads.

//@@BEGIN_DDKSPLIT
#if DBG && MULTITHREADED
#define PERMEDIA_DEFS(xppdev)       \
    P2DMA *pP2dma=xppdev->pP2dma;   \
    PULONG pTmp;                    \
    if (pP2dma != NULL) { pP2dma->ppdev = xppdev; }
#else
//@@END_DDKSPLIT

#define PERMEDIA_DEFS(xppdev)  \
    P2DMA *pP2dma=xppdev->pP2dma;\
    PULONG pTmp;

//@@BEGIN_DDKSPLIT
#endif
//@@END_DDKSPLIT

//----------------------------------------------------------------------------
//
//  here are the API macros for DMA transport
//
//
//  RESERVEDMAPTR(n)                // reserve n entries for DMA 
//  n=GetFreeEntries()              // get number of free entries to fill
//                                      (optional)
//  up to n LD_INPUT_FIFO  
//  COMMITDMAPTR()                 // adjust DMA buffer pointer
//
//  FLUSHDMA();
//
//----------------------------------------------------------------------------

//@@BEGIN_DDKSPLIT
#if 1

#define RESERVEDMAWORDS(n) \
{ \
    ASSERTLOCK(pP2dma->ppdev, RESERVEDMAWORDS); \
    pTmp=ReserveDMAPtr(pP2dma,n); \
}

#define RESERVEDMAPTR(n) \
{ \
    ASSERTLOCK(pP2dma->ppdev, RESERVEDMAPTR); \
    pTmp=ReserveDMAPtr(pP2dma,2*n); \
}

#else
//@@END_DDKSPLIT

#define RESERVEDMAWORDS(n) \
{    pTmp=ReserveDMAPtr(pP2dma,n);}

#define RESERVEDMAPTR(n) \
{    pTmp=ReserveDMAPtr(pP2dma,2*n);}

//@@BEGIN_DDKSPLIT
#endif
//@@END_DDKSPLIT

#define COMMITDMAPTR() \
{    CommitDMAPtr(pP2dma,pTmp);}

#define GETFREEENTRIES() \
    GetFreeEntries(pP2dma)

#define FLUSHDMA()    (pP2dma->pgfnFlushDMA)(pP2dma)

// compiler does not resolve C++ inlines until use of /Ob1,
// so write inline as a real macro
#define LD_INPUT_FIFO(uiTag, uiData) \
{   *pTmp++=(uiTag);\
    *pTmp++=(uiData);\
}    

#define LD_INPUT_FIFO_DATA(uiData)    \
    *pTmp++=(uiData); 




//-----------------------------------------------------------------------------
//
// define register file of Permedia 2 chip and other chip constants
//
//-----------------------------------------------------------------------------

#define PREG_RESETSTATUS  0x0
#define PREG_INTENABLE    0x8
#define PREG_INTFLAGS     0x10
#define PREG_INFIFOSPACE  0x18
#define PREG_OUTFIFOWORDS 0x20
#define PREG_INDMAADDRESS   0x28
#define PREG_INDMACOUNT     0x30
#define PREG_ERRORFLAGS   0x38
#define PREG_VCLKCTL      0x40
#define PERMEDIA_REG_TESTREGISTER 0x48
#define PREG_APERTUREONE  0x50
#define PREG_APERTURETWO  0x58
#define PREG_DMACONTROL   0x60
#define PREG_FIFODISCON   0x68
#define PREG_FIFODISCON_GPACTIVE   0x80000000L
#define PREG_CHIPCONFIG   0x70
#define PREG_OUTDMAADDRESS 0x80
#define PREG_OUTDMACOUNT     0x88
#define PREG_AGPTEXBASEADDRESS  0x90
#define PREG_BYDMAADDRESS   0xa0
#define PREG_BYDMASTRIDE    0xb8
#define PREG_BYDMAMEMADDR   0xc0
#define PREG_BYDMASIZE      0xc8
#define PREG_BYDMABYTEMASK  0xd0
#define PREG_BYDMACONTROL   0xd8
#define PREG_BYDMACOMPLETE  0xe8
#define PREG_FIFOINTERFACE  0x2000 

#define PREG_LINECOUNT      0x3070
#define PREG_VBEND          0x3040

#define PREG_SCREENBASE      0x3000
#define PREG_SCREENBASERIGHT 0x3080
#define PREG_VIDEOCONTROL    0x3058

#define PREG_VC_STEREOENABLE 0x800
// use this for stereo
#define PREG_VC_SCREENBASEPENDING 0xc180
#define PREG_VC_RIGHTFRAME   0x2000

// for non stereo modes
// #define PREG_VC_SCREENBASEPENDING 0x080

// GP video enabled/disabled bit of VideoControl
#define PREG_VC_VIDEO_ENABLE 0x0001

#define P2_EXTERNALVIDEO  0x4000

#define CTRLBASE    0
#define COREBASE    0x8000
#define GPFIFO      0x2000

#define MAXINPUTFIFOLENGTH 0x100

//-----------------------------------------------------------------------------
//
//  various register flags
//
//-----------------------------------------------------------------------------

#define PREG_INTFLAGS_DMA   1
#define PREG_INTFLAGS_VS    0x10
#define PREG_INTFLAGS_ERROR 0x8
#define PREG_INTFLAGS_SYNC  2

//
// DisconnectControl bits
//
#define DISCONNECT_INPUT_FIFO_ENABLE    0x1
#define DISCONNECT_OUTPUT_FIFO_ENABLE   0x2
#define DISCONNECT_INOUT_ENABLE         (DISCONNECT_INPUT_FIFO_ENABLE | \
                                         DISCONNECT_OUTPUT_FIFO_ENABLE)
#define DISCONNECT_INOUT_DISABLE        0x0

//-----------------------------------------------------------------------------
//
// Size of DMA buffer. Since we use only one wraparound DMA Buffer
// with continous physical memory, it should not be too long.
// We allocate this buffer at start of day and keep it forever, unless
// somebody forces an unload of the display driver. Selecting a larger
// size makes it more likely for the call to fail.
//
// The usage counter for the DMA memory is handled in the miniport, because
// the Permedia class gets unloaded on a mode switch.
//
//-----------------------------------------------------------------------------

// DMA command buffer stream size and minimum size
#define DMACMDSIZE     DMA_BUFFERSIZE
#define DMACMDMINSIZE  0x2000L
#define MAXBLKSIZE     0x1000       // limit block transfers to 16 kb per chunk
                                    // to have a good balance between download
                                    // speed and latencies
#define ALIGNFACTOR    0x400        // alignment factor (4kb page)

//-----------------------------------------------------------------------------
//
// shared memory section of P2 interrupt driven DMA handler
//
//-----------------------------------------------------------------------------

struct _P2DMA {
    INTERRUPT_CONTROL_BLOCK ICB;

    // these are the linear Permedia base addresses of the control registers
    // and the Fifo area
    ULONG *pCtrlBase;
    ULONG *pGPFifo;

    // handle to videoport of instance
    HANDLE hDriver;

    LONG  lDMABufferSize;         // size of DMA buffer in ULONGs

    ULONG uiInstances;            // currently active driver instances using 
                                  // the shared memory

    ULONG ulIntFlags;             // cache for interrupt flag register

#if defined(_X86_)
                                  // pointer to Interlockedexchange function in
                                  // the kernel.
    PInterlockedExchange pInterlockedExchange;
#endif

    BOOL bDMAEmulation;           // remember if we run in DMA emulation

    GFNCHECKEOB*pgfnCheckEOB;     // DMA CheckEOB buffer function pointer
    GFNFLUSHDMA*pgfnFlushDMA;     // DMA FlushDMA buffer function pointer

    ULONG *pSharedDMABuffer;      // virtual address of shared DMA buffer
    LONG   lSharedDMABufferSize;  // size of shared DMA buffer in BYTEs

    ULONG *pEmulatedDMABuffer;    // address of DMA emulation buffer
    LONG   lEmulatedDMABufferSize;// size of DMA emulation buffer in BYTEs

    BOOL bEnabled;                // check if the DMA code is enabled

#if DBG
    LONG lDBGState;               // keep track of state in debug version
                                  // 0:   idle
                                  // 2:   ReserveDMAPtr was called
    LONG bDBGIgnoreAssert;
    ULONG *pDBGReservedEntries;   // pointer to which we have reserved
                                  // for debugging checks
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    PPDev ppdev;                  // For checking multithreaded semaphore
#endif
//@@END_DDKSPLIT
#endif

} ;

//-----------------------------------------------------------------------------
//
//  definitions for functions which are different in non-DMA, DMA and 
//  multiprocessing DMA cases. bInitializeP2DMA will decide which ones to use
//  and preset the function pointers.
//
//-----------------------------------------------------------------------------

VOID vFlushDMA(P2DMA *pP2dma);
VOID vFlushDMAMP(P2DMA *pP2dma);
VOID vFlushDMAEmulation(P2DMA *pP2dma);

VOID vCheckForEOB(P2DMA *pP2dma,LONG lEntries);
VOID vCheckForEOBMP(P2DMA *pP2dma,LONG lEntries);
VOID vCheckForEOBEmulation(P2DMA *pP2dma,LONG lEntries);

//-----------------------------------------------------------------------------
//
//  more helper and blockdownload functions
//
//-----------------------------------------------------------------------------

VOID vWaitDMAComplete(P2DMA *pP2dma);
LONG lWaitOutputFifoReady(P2DMA *pP2dma);
BOOL bDrawEngineBusy(P2DMA *pP2dma);
BOOL bInVerticalRetrace(PPDev ppdev);
LONG lCurrentLine(PPDev ppdev);

VOID vBlockLoadInputFifoByte (P2DMA *pP2dma, 
                              ULONG uiTag, 
                              BYTE *pImage, 
                              LONG lWords);
VOID vBlockLoadInputFifo     (P2DMA *pP2dma, 
                              ULONG uiTag,
                              ULONG *pImage, 
                              LONG lWords);

//-----------------------------------------------------------------------------
//
// Basic reserve/commit Api functions. They are provided as inlines for free 
// builds and as functions with debug checks in checked builds.
//
//-----------------------------------------------------------------------------

ULONG *ReserveDMAPtr (P2DMA *pP2dma, const LONG nEntries);
VOID   CommitDMAPtr  (P2DMA *pP2dma, ULONG *pDMAPtr);
LONG   GetFreeEntries(P2DMA *pP2dma);


//
//  completely synchronize chip here 
//

VOID vSyncWithPermedia(P2DMA *pP2dma);

//
// initialization and cleanup routines
//
BOOL bInitializeP2DMA(  P2DMA *pP2dma,
                        HANDLE hDriver, 
                        ULONG *pChipBase, 
                        DWORD dwAccelerationLevel,
                        BOOL NewReference
                      );
VOID vFree(P2DMA *pP2dma);


#if !DBG

//----------------------------------------------------------------------------
//
//  ReserveDMAPtr
//
//  return a pointer to current position in DMA buffer. The function guarantees
//  that there are at least lEntries available in the buffer.
//  Otherwise the caller can ask GetFreeEntries and adjust the download to 
//  batch more entries. The caller MUST call CommitDMAPtr after a call to
//  to ReserveDMAPtr to readjust the Index pointer.
//
//----------------------------------------------------------------------------

inline ULONG *ReserveDMAPtr(P2DMA *pP2dma,const LONG lEntries)
{
    while (pP2dma->ICB.pDMAWritePos+lEntries>=
           pP2dma->ICB.pDMAWriteEnd)
    {
        (*pP2dma->pgfnCheckEOB)(pP2dma,lEntries);
    }   

    return (ULONG *)pP2dma->ICB.pDMAWritePos;  
}


//----------------------------------------------------------------------------
//
//  CommitDMAPtr
//
//  pDMAPtr----DMA buffer address to which the caller has written to.
//
//  Readjust write pointer after being reserved by ReserveDMAPtr. 
//  By committing the pointer a DMA to the committed position could already
//  be started by interrupt handler!
//
//----------------------------------------------------------------------------

inline VOID CommitDMAPtr(P2DMA *pP2dma,ULONG *pDMAPtr)
{
    pP2dma->ICB.pDMAWritePos=pDMAPtr;
}

//----------------------------------------------------------------------------
//
//  GetFreeEntries
//
//  Get free entries available for consecutive writing to the DMA buffer.
//  The maximum number of returned entries is now MAXBLKSIZE.
// 
//  returns---number of available entries in ULONGS
//
//----------------------------------------------------------------------------

inline LONG GetFreeEntries(P2DMA *pP2dma)
{   
    LONG EntriesAvailable = (LONG)(pP2dma->ICB.pDMAWriteEnd - pP2dma->ICB.pDMAWritePos);
    return min(MAXBLKSIZE,EntriesAvailable);
}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\pointer.h ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: pointer.h
*
* This module contains all the definitions for pointer related stuff
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\**************************************************************************/
#ifndef __POINTER__H__
#define __POINTER__H__

//
// Some size definition
//
#define POINTER_DATA_SIZE        128    // Number of bytes to allocate for the
                                        // miniport down-loaded pointer code
                                        // working space
#define HW_INVISIBLE_OFFSET        2    // Offset from 'ppdev->yPointerBuffer'
                                        // to the invisible pointer
#define HW_POINTER_DIMENSION      64    // Maximum dimension of default
                                        // (built-in) hardware pointer
#define HW_POINTER_TOTAL_SIZE   1024    // Total size in bytes required
                                        // to define the hardware pointer

typedef enum
{
    PTR_HW_ACTIVE   = 1,                // The hardware pointer is active and
                                        // visible
    PTR_SW_ACTIVE   = 2,                // The software pointer is active
} ;
typedef int PtrFlags;

typedef struct _PDev PDev;

//
// 64 x 64 Hardware Pointer Caching data structures
//
#define SMALL_POINTER_MEM (32 * 4 * 2)  // Bytes read for 32x32 cursor
#define LARGE_POINTER_MEM (SMALL_POINTER_MEM * 4)
                                        // Bytes read for 64x64 cursor

// Hardware workaround.  We have had to stop using the hardware pointer
// cache due to problems with changing pointer shape.  Occasionaly it
// caused the pointer to jump around on the screen.  We don't currently
// have time to work with 3Dlabs to find out how we can stop this jumpyness
// so instead we will just not use the hardware pointer cache for the time
// being.
//#define SMALL_POINTER_MAX 4             // No. of cursors in cache
#define SMALL_POINTER_MAX 1             // Hardware pointer cache workaround

#define HWPTRCACHE_INVALIDENTRY (SMALL_POINTER_MAX + 1)
                                        // Well-known value

//
// Pointer cache item data structure, there is one of these for every cached
// pointer
//
typedef struct
{
    ULONG   ptrCacheTimeStamp;          // Timestamp used for LRU cache ageing
    ULONG   ulKey;                      // iUniq value of pointer mask surface
    HSURF   hsurf;                      // hsurf of the pointer mask surface
} HWPointerCacheItemEntry;

//
// The complete cache looks like this
//
typedef struct
{
    BYTE    cPtrCacheInUseCount;        // The no. of cache items used
    ULONG   ptrCacheCurTimeStamp;       // The date stamp used for LRU stuff
    ULONG   ptrCacheData[LARGE_POINTER_MEM / 4];
                                        // The cached pointer data
    HWPointerCacheItemEntry ptrCacheItemList [SMALL_POINTER_MAX];
                                        // The cache item list
} HWPointerCache;

//
// Capabilities flags
//
// These are private flags passed to us from the Permedia2 miniport.  They
// come from the high word of the 'AttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to us via an 'VIDEO_QUERY_AVAIL_MODES' or 'VIDEO_QUERY_CURRENT_MODE'
// IOCTL.
//
// NOTE: These definitions must match those in the Permedia2 miniport's
// 'permedia.h'!
//
typedef enum
{
    //
    // NT4 uses the DeviceSpecificAttributes field so the low word is available
    //
    CAPS_ZOOM_X_BY2         = 0x00000001,   // Hardware has zoomed by 2 in X
    CAPS_ZOOM_Y_BY2         = 0x00000002,   // Hardware has zoomed by 2 in Y
    CAPS_SPARSE_SPACE       = 0x00000004,   // Framebuffer is sparsely mapped
                                            // (don't allow direct access).
                                            // The machine is probably an Alpha
    CAPS_SW_POINTER         = 0x00010000,   // No hardware pointer; use
                                            // software simulation
    CAPS_TVP4020_POINTER    = 0x20000000,   // Use Permedia2 builtin pointer
    CAPS_P2RD_POINTER       = 0x80000000    // Use the 3Dlabs P2RD RAMDAC
} /*CAPS*/;

typedef int CAPS;

//
// Initializes hardware pointer or software pointer
//
BOOL    bEnablePointer(PDev* ppdev);

//
// Determine whether we can do color space double buffering in the current mode
//
BOOL    bP2RDCheckCSBuffering(PDev* ppdev);

//
// Use the pixel read mask to perform color space double buffering
//
BOOL    bP2RDSwapCSBuffers(PDev* ppdev, LONG bufNo);

//
// Stores the 15-color cursor in the RAMDAC
//
BOOL    bSet15ColorPointerShapeP2RD(PDev* ppdev, SURFOBJ* psoMask, 
                                    SURFOBJ* psoColor,
                                    LONG        x,
                                    LONG        y,
                                    LONG        xHot,
                                    LONG        yHot);

//
// Stores the 3-color cursor in the RAMDAC
//
BOOL    bSet3ColorPointerShapeP2RD(PDev*    ppdev,
                                   SURFOBJ* psoMask,
                                   SURFOBJ* psoColor,
                                   LONG     x,
                                   LONG     y,
                                   LONG     xHot,
                                   LONG     yHot);

//
// Set pointer shape for P2RD
//
BOOL    bSetPointerShapeP2RD(PDev*      ppdev,
                             SURFOBJ*   pso,
                             SURFOBJ*   psoColor,
                             XLATEOBJ*  pxlo,
                             LONG       x,
                             LONG       y,
                             LONG       xHot,
                             LONG       yHot);

//
// Set the TI TVP4020 hardware pointer shape
//
BOOL    bSetPointerShapeTVP4020(PDev*       ppdev,
                                SURFOBJ*    pso,
                                SURFOBJ*    psoColor,
                                LONG        x,
                                LONG        y,
                                LONG        xHot,
                                LONG        yHot);


//
// Determine whether we can do color space double buffering in the current mode
//
BOOL    bTVP4020CheckCSBuffering(PDev* ppdev);

//
// Set cache index
//
LONG    HWPointerCacheCheckAndAdd(HWPointerCache*   ptrCache,
                                  HSURF             hsurf,
                                  ULONG             ulKey,
                                  BOOL*             isCached);

//
// Initialise the hardware pointer cache.
//
VOID    HWPointerCacheInit(HWPointerCache* ptrCache);

//
// Hardware pointer caching functions/macros.
//
#define HWPointerCacheInvalidate(ptrCache) (ptrCache)->cPtrCacheInUseCount = 0

//
// Enable everything but hide the pointer
//
VOID    vAssertModePointer(PDev* ppdev, BOOL bEnable);

//
// Get the hardware ready to use the 3Dlabs P2RD hardware pointer.
//
VOID    vEnablePointerP2RD(PDev* ppdev);

//
// Get the hardware ready to use the TI TVP4020 hardware pointer.
//
VOID    vEnablePointerTVP4020(PDev* ppdev);

//
// Move the 3Dlabs P2RD hardware pointer.
//
VOID    vMovePointerP2RD(PDev* ppdev, LONG x, LONG y);

//
// Move the TI TVP4020 hardware pointer.
//
VOID    vMovePointerTVP4020(PDev* ppdev, LONG x, LONG y);

//
// Show or hide the 3Dlabs P2RD hardware pointer.
//
VOID    vShowPointerP2RD(PDev* ppdev, BOOL bShow);

//
// Show or hide the TI TVP4020 hardware pointer.
//
VOID    vShowPointerTVP4020(PDev* ppdev, BOOL bShow);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\registry.h ===
/******************************Module*Header*******************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: registry.h
*
* utility routines to help with accessing the registry.
*
* Copyright (c) 1998 Microsoft Corporation. All rights reserved.
*
\**************************************************************************/
#ifndef _REGISTRY_H_
#define _REGISTRY_H_

extern 	BOOL bRegistryRetrieveGammaLUT(PPDev ppdev, PVIDEO_CLUT pScreenClut);

extern 	BOOL bRegistrySaveGammaLUT(PPDev ppdev, PVIDEO_CLUT pScreenClut);

extern BOOL bRegistryQueryUlong(PPDev, LPWSTR, PULONG);

#endif // __REGISTRY_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\rops.c ===
/******************************Module*Header*******************************\
* Module Name: rops.c
*
*
* Utility routines to manilpulate rop codes.
*
* Copyright (c) 1998 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"

//
// The gaMix table converts a mix code (1-16) and converts it to a rop3
// Note that we also define mix code 0 == code 16 to allow for the masking
// of the mix code by 0xff to produce the correct result.
// 

ULONG gaMix[] =
{
    ROP3_WHITENESS,     // (R2_WHITE & 0xff)
    ROP3_BLACKNESS,     // R2_BLACK
    0x05,               // R2_NOTMERGEPEN
    0x0A,               // R2_MASKNOTPEN
    0x0F,               // R2_NOTCOPYPEN
    0x50,               // R2_MASKPENNOT
    ROP3_DSTINVERT,     // R2_NOT
    ROP3_PATINVERT,     // R2_XORPEN
    0x5F,               // R2_NOTMASKPEN
    0xA0,               // R2_MASKPEN
    0xA5,               // R2_NOTXORPEN
    0xAA,               // R2_NOP
    0xAF,               // R2_MERGENOTPEN
    ROP3_PATCOPY,       // R2_COPYPEN
    0xF5,               // R2_MERGEPENNOT
    0xFA,               // R2_MERGEPEN
    ROP3_WHITENESS      // R2_WHITE
};

//
// Convert a rop2 code to a hardware specific logical operation code
//

ULONG gRop2ToLogicop[] =
{
    K_LOGICOP_CLEAR,        // 0
    K_LOGICOP_NOR,          // DSon
    K_LOGICOP_AND_INVERTED, // DSna
    K_LOGICOP_COPY_INVERT,  // Sn
    K_LOGICOP_AND_REVERSE,  // SDna
    K_LOGICOP_INVERT,       // Dn
    K_LOGICOP_XOR,          // DSx
    K_LOGICOP_NAND,         // DSan
    K_LOGICOP_AND,          // DSa
    K_LOGICOP_EQUIV,        // DSxn
    K_LOGICOP_NOOP,         // D
    K_LOGICOP_OR_INVERT,    // DSno
    K_LOGICOP_COPY,         // S
    K_LOGICOP_OR_REVERSE,   // SDno
    K_LOGICOP_OR,           // DSo
    K_LOGICOP_SET
};

//------------------------------------------------------------------------------
//
// ULONG ulRop3ToLogicop
//
//
// Convert a source invariant rop3 code into a hardware specific logical 
// operation.
// Note we could instead define this routine as a macro.
//
//------------------------------------------------------------------------------

ULONG
ulRop3ToLogicop(ULONG ulRop3)
{
    ASSERTDD(ulRop3 <= 0xFF, "ulRop3ToLogicop: unexpected rop3 code");
    
    ULONG ulRop2;

    ulRop2 = ((ulRop3 & 0x3) | ((ulRop3 & 0xC0) >> 4));

    return gRop2ToLogicop[ulRop2];
}

//------------------------------------------------------------------------------
//
// ULONG ulRop2ToLogicop
//
// Convert a rop2 code into a hardware dependent logical operation.
// Note we could instead define this routine as a macro.
//
//------------------------------------------------------------------------------

ULONG
ulRop2ToLogicop(ULONG ulRop2)
{
    ASSERTDD(ulRop2 <= 0xF, "ulRop2ToLogicop: unexpected rop2 code");

    return (ULONG)(gRop2ToLogicop[ulRop2]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\registry.c ===
/******************************Module*Header***********************************\
* Module Name: registry.c
*
* Routines to initialize the registry and lookup string values.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
*
\******************************************************************************/
#include "precomp.h"
                        
//------------------------------------------------------------------------------
//  BOOL bRegistryQueryUlong
// 
//  Take a string and look up its value in the registry. We assume that the
//  value fits into 4 bytes. Fill in the supplied DWORD pointer with the value.
// 
//  Returns:
//    TRUE if we found the string, FALSE if not. Note, if we failed to init
//    the registry the query funtion will simply fail and we act as though
//    the string was not defined.
// 
//------------------------------------------------------------------------------

BOOL
bRegistryQueryUlong(PPDev ppdev, LPWSTR valueStr, PULONG pData)
{
    ULONG ReturnedDataLength;
    ULONG inSize;
    ULONG outData;
    PWCHAR inStr;
    
    // get the string length including the NULL
    
    for (inSize = 2, inStr = valueStr; *inStr != 0; ++inStr, inSize += 2);

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_QUERY_REGISTRY_DWORD,
                           valueStr,                  // input buffer
                           inSize,
                           &outData,         // output buffer
                           sizeof(ULONG),
                           &ReturnedDataLength))
    {
        DBG_GDI((1, "bQueryRegistryValueUlong failed"));
        return(FALSE);
    }
    *pData = outData;
    DBG_GDI((1, "bQueryRegistryValueUlong returning 0x%x (ReturnedDataLength = %d)",
                                                        *pData, ReturnedDataLength));
    return(TRUE);
}

//------------------------------------------------------------------------------
//  BOOL bRegistryRetrieveGammaLUT
// 
//  Look up the registry to reload the saved gamma LUT into memory.
// 
//  Returns:
//    TRUE if we found the string, FALSE if not. Note, if we failed to init
//    the registry the query funtion will simply fail and we act as though
//    the string was not defined.
// 
//------------------------------------------------------------------------------

BOOL
bRegistryRetrieveGammaLUT(
    PPDev ppdev,
    PVIDEO_CLUT pScreenClut
    )
{
    ULONG ReturnedDataLength;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT,
                           NULL,         // input buffer
                           0,
                           pScreenClut,  // output buffer
                           MAX_CLUT_SIZE,
                           &ReturnedDataLength))
    {
        DBG_GDI((1, "IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT failed"));
        return(FALSE);
    }

    return(TRUE);
}

//------------------------------------------------------------------------------
//  BOOL bRegistrySaveGammaLUT
// 
//  Save the gamma lut in the registry for later reloading.
// 
//  Returns:
//    TRUE if we found the string, FALSE if not. Note, if we failed to init
//    the registry the query funtion will simply fail and we act as though
//    the string was not defined.
// 
//------------------------------------------------------------------------------

BOOL
bRegistrySaveGammaLUT(
    PPDev ppdev,
    PVIDEO_CLUT pScreenClut
    )
{
    ULONG ReturnedDataLength;

    if (EngDeviceIoControl(ppdev->hDriver,
                           IOCTL_VIDEO_REG_SAVE_GAMMA_LUT,
                           pScreenClut,  // input buffer
                           MAX_CLUT_SIZE,
                           NULL,         // output buffer
                           0,
                           &ReturnedDataLength))
    {
        DBG_GDI((1, "IOCTL_VIDEO_REG_SAVE_GAMMA_LUT failed"));
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\precomp.h ===
/******************************Module*Header***********************************\
* Module Name: precomp.h
*
* Common headers used throughout the display driver.  This entire include
* file will typically be pre-compiled.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\******************************************************************************/

#define __NTDDKCOMP__

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <windef.h>
#include <d3d.h>
#include <winerror.h>
#include <wingdi.h>
#include <math.h>

#ifdef __cplusplus
extern "C" { 
#endif

/*****************************************************************************\
*                                                                             *
* NT 5.0  -> NT 4.0 single binary support:                                    *
*                                                                             *
\*****************************************************************************/

// The following macros thunk the corresponding APIs to Dynamically loaded ones
// when running on NT5 or later and no-ops on NT4.  This is because on NT5+ we
// use the direct draw heap and other newly added Eng function calls which are
// not available on NT4.  All the thunks are implemented in thunks.c.  The
// macros are defined prior to including winddi.h to insure correct typing.

// NT5.0 Thunks
#define EngAlphaBlend           THUNK_EngAlphaBlend
#define EngGradientFill         THUNK_EngGradientFill
#define EngTransparentBlt       THUNK_EngTransparentBlt
#define EngMapFile              THUNK_EngMapFile
#define EngUnmapFile            THUNK_EngUnmapFile
#define EngQuerySystemAttribute THUNK_EngQuerySystemAttribute
#define EngDitherColor          THUNK_EngDitherColor
#define EngModifySurface        THUNK_EngModifySurface
#define EngQueryDeviceAttribute THUNK_EngQueryDeviceAttribute
#define HeapVidMemAllocAligned  THUNK_HeapVidMemAllocAligned
#define VidMemFree              THUNK_VidMemFree

// NT5.1 Thunks
#define EngHangNotification     THUNK_EngHangNotification


#include <winddi.h>
#include <devioctl.h>
#include <ntddvdeo.h>
#include <ioaccess.h>

#ifdef __cplusplus
}
#endif

#include <memory.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include <dmemmgr.h>
#include "dx95type.h"

// define Size for DMA Buffer.
#if defined(_ALPHA_)
#define DMA_BUFFERSIZE 0x2000
#else
#define DMA_BUFFERSIZE 0x40000
#endif


// DX7 Stereo support
#define DX7_STEREO 1
//@@BEGIN_DDKSPLIT
// for now DX7_STEREO should only be enabled in the build,
// not in the DDK, because some defs are still missing.
#define DX7_ALPHABLT 0
//@@END_DDKSPLIT

//@@BEGIN_DDKSPLIT
// enable GDI testing
#define GDI_TEST 0
//@@END_DDKSPLIT

// enable memory tracking
// to find leaking memory
#define TRACKMEMALLOC 0

#include "pointer.h"
#include "brush.h"
#include "driver.h"
#include "debug.h"
#include "permedia.h"
#include "hw.h"
#include "pmdef.h"
#include "lines.h"
#include "math64.h"
#include "rops.h"
#include "registry.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\rops.h ===
/******************************Module*Header*******************************\
* Module Name: rops.h
*
* Utility defines and routines for manipulation of rop codes.
*
* Copyright (c) 1998 Microsoft Corporation
*
\**************************************************************************/

#ifndef __ROPS__
#define __ROPS__

//------------------------------------------------------------------------------
//
// ULONG MixToRop4(MIX mix) - Translates a MIX into a ROP3.
//
//------------------------------------------------------------------------------

extern ULONG gaMix[];

#define MixToRop4(mix) \
    (( gaMix[mix >> 8] << 8) | gaMix[mix & 0xf])


//------------------------------------------------------------------------------
//
// Some usefull ROP3 code defines
//
//------------------------------------------------------------------------------

#define ROP3_NOP            0xAA
#define ROP3_SRCCOPY        (SRCCOPY >> 16)     // 0xCC
#define ROP3_SRCPAINT       (SRCPAINT >> 16)    // 0xEE
#define ROP3_SRCAND         (SRCAND >> 16)      // 0x88
#define ROP3_SRCINVERT      (SRCINVERT >> 16)   // 0x66
#define ROP3_SRCERASE       (SRCERASE >> 16)    // 0x44
#define ROP3_NOTSRCCOPY     (NOTSRCCOPY >> 16)  // 0x33
#define ROP3_NOTSRCERASE    (NOTSRCERASE >> 16) // 0x11
#define ROP3_MERGECOPY      (MERGECOPY >> 16)   // 0xC0
#define ROP3_MERGEPAINT     (MERGEPAINT >> 16)  // 0xBB
#define ROP3_PATCOPY        (PATCOPY >> 16)     // 0xF0
#define ROP3_PATPAINT       (PATPAINT >> 16)    // 0xFB
#define ROP3_PATINVERT      (PATINVERT >> 16)   // 0x5A
#define ROP3_DSTINVERT      (DSTINVERT >> 16)   // 0x55
#define ROP3_BLACKNESS      (BLACKNESS >> 16)   // 0x00
#define ROP3_WHITENESS      (WHITENESS >> 16)   // 0xFF

//------------------------------------------------------------------------------
//
// Some usefull ROP4 code defines
//
//------------------------------------------------------------------------------

#define ROP4_SRCCOPY       (ROP3_SRCCOPY | (ROP3_SRCCOPY << 8))       // 0xCCCC
#define ROP4_NOTSRCCOPY    (ROP3_NOTSRCCOPY | (ROP3_NOTSRCCOPY << 8)) // 0x3333
#define ROP4_NOP           (ROP3_NOP | (ROP3_NOP << 8))               // 0xAAAA
#define ROP4_PATCOPY       (ROP3_PATCOPY | (ROP3_PATCOPY << 8))       // 0xFOFO
#define ROP4_BLACKNESS     (ROP3_BLACKNESS | (ROP3_BLACKNESS << 8))   // 0x0000
#define ROP4_WHITENESS     (ROP3_WHITENESS | (ROP3_WHITENESS << 8))   // 0xFFFF


//------------------------------------------------------------------------------
//
// ULONG ulRop3ToLogicop
//
//
// Convert a source invariant rop3 code into a hardware specific logical 
// operation.
// Note we could instead define this routine as a macro.
//
//------------------------------------------------------------------------------

extern ULONG ulRop3ToLogicop(ULONG ucRop3);

//------------------------------------------------------------------------------
//
// ULONG ulRop2ToLogicop
//
// Convert a rop2 code into a hardware dependent logical operation.
// Note we could instead define this routine as a macro.
//
//------------------------------------------------------------------------------

extern ULONG ulRop2ToLogicop(ULONG ucRop2);

#endif // __ROPS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\solidfil.c ===
/******************************Module*Header***********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: solidfil.c
*
* Contains grab bag collection of hardware acceleration entry points.
*
* Note, we will be moving several of the routines in this file to there
* modle leaving only the solid fill related entry points.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\******************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "directx.h"

// The shift equations are a nuisance. We want x<<32 to be
// zero but some processors only use the bottom 5 bits
// of the shift value. So if we want to shift by n bits
// where we know that (32 >= n > 0), we do it in two parts.
// In some places the algorithm guarantees n < 32 so we can
// use a single shift.
#define SHIFT_LEFT(src, n)  (((src) << ((n)-1)) << 1)

VOID
vMonoBitsDownload(PPDev   ppdev,
                  BYTE*   pSrcBase,       // ptr to word containing first bit we want to download
                  LONG    lSrcDelta,      // offset in bytes from one scanline to the next
                  LONG    xOffset,        // offset of first bit to download in pSrcBase 
                  LONG    widthInBits,    // number of bits to download on each scanline
                  LONG    nScanLines)     // number of scanlines to download

{
    ULONG   bitWord;
    ULONG   bitMask;
    ULONG   bits;
    LONG    unused;
    LONG    nStart;
    LONG    nRemainder;
    LONG    nBits;
    ULONG   *pSrc;

    ULONG*          pBuffer;
    ULONG*          pReservationEnd;
    ULONG*          pBufferEnd;

    InputBufferStart(ppdev, MAX_INPUT_BUFFER_RESERVATION,
                      &pBuffer, &pBufferEnd, &pReservationEnd);
    
    DBG_GDI((6, "vDoMonoBitsDownload called"));
    ASSERTDD(((INT_PTR)pSrcBase & 3) == 0,
             "vDoMonoBitsDownload: non-dword aligned source");

    //
    // Special case where the source width is a multiple of 32 bits.
    // This is true for many small resources such as icons.
    //
    if ( (xOffset | (widthInBits & 31)) == 0 )
    {

        //
        // Simplest case: one 32 bit word per scanline
        //
        if ( widthInBits == 32 )
        {
            
            *pBuffer++ = ((nScanLines - 1) << 16)
                       | __Permedia2TagBitMaskPattern;

            do
            {
                LSWAP_BYTES(bits, pSrcBase);
                *pBuffer++ = bits;
                if(pBuffer == pReservationEnd)
                {
                    InputBufferContinue(ppdev, MAX_INPUT_BUFFER_RESERVATION,
                                      &pBuffer, &pBufferEnd, &pReservationEnd);
                }
                pSrcBase += lSrcDelta;
            } while ( --nScanLines > 0 );
            
            InputBufferCommit(ppdev, pBuffer);
            
            return;
        }

        //
        // Multiple 32 bit words per scanline. convert the delta to the
        // delta as we need it at the end of each line by subtracting the
        // width in bytes of the data we're downloading. Note, pSrcBase
        // is always 1 LONG short of the end of the line because we break
        // before adding on the last ULONG. Thus, we subtract sizeof(ULONG)
        // from the original adjustment.
        //

        LONG    widthInLongs = widthInBits >> 5;

        do {

            LONG    lLongs = widthInLongs;
            ULONG*  src = (ULONG *) pSrcBase;
            
            *pBuffer++ = ((lLongs - 1) << 16)
                       | __Permedia2TagBitMaskPattern;
            
            if(pBuffer == pReservationEnd)
            {
                InputBufferContinue(ppdev, MAX_INPUT_BUFFER_RESERVATION,
                                  &pBuffer, &pBufferEnd, &pReservationEnd);
            }
            
            do
            {
                LSWAP_BYTES(bits, src);
                *pBuffer++ = bits;
                if(pBuffer == pReservationEnd)
                {
                    InputBufferContinue(ppdev, MAX_INPUT_BUFFER_RESERVATION,
                                      &pBuffer, &pBufferEnd, &pReservationEnd);
                }
                src++;
            } while( --lLongs > 0);
            
            pSrcBase += lSrcDelta;

        } while(--nScanLines > 0);

        InputBufferCommit(ppdev, pBuffer);
        
        return;

    }

    //
    // Some common values at the start of each scanline:
    // bitWord: collect bits in this ulong and write out when full
    // unused: number of bits left to fill in bitWord
    // nStart = number of valid bits in the first longword
    // nRemainder = number of bits on scanline minus nStart
    //
    bitWord = 0;
    unused = 32;
    nStart = 32 - xOffset;
    nRemainder = widthInBits - nStart;

    //
    // We special case where the complete set of bits on a scanline
    // is contained in the first ulong.
    //
//@@BEGIN_DDKSPLIT
    //TODO: We should be able to clean this up a little.  It would be
    //      nice to be able to calculate the number of bit masks we
    //      will be sending enabling us to use the dma hold method
    //      for all cases.
//@@END_DDKSPLIT

    if ( nRemainder <= 0 )
    {
        nBits = -nRemainder;              // number of invalid bits on right
        bitMask = (1 << widthInBits) - 1; // widthInBits == 32 is handled above
        pSrc = (ULONG *)pSrcBase;
        
        while ( TRUE )
        {
            LSWAP_BYTES(bits, pSrc);
            bits = (bits >> nBits) & bitMask;
            unused -= widthInBits;
            if ( unused > 0 )
            {
                bitWord |= bits << unused;
            }
            else
            {
                bitWord |= bits >> -unused;
                
                InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd, &pReservationEnd);
                pBuffer[0] = __Permedia2TagBitMaskPattern;
                pBuffer[1] = bitWord;
                pBuffer += 2;
                
                unused += 32;
                bitWord = SHIFT_LEFT(bits, unused);
            }

            //
            // Break will generate an extra jump
            //
            if ( --nScanLines == 0 )
            {
                goto completeDownload;
            }

            pSrc = (ULONG *) (((UCHAR *)pSrc) + lSrcDelta);
        }
    }// if ( nRemainder <= 0 )
    else
    {
        //
        // Use bitMask to zero left edge bits in first long
        //
        bitMask = SHIFT_LEFT(1, nStart) - 1;
        while ( TRUE )
        {
            //
            // Read the first word from this scanline of the bitmap
            // and mask out the lefthand offset bits if any.
            //
            nBits = nRemainder;
            pSrc = (ULONG *)pSrcBase;

            LSWAP_BYTES(bits, pSrc);
            bits &= bitMask;

            //
            // Handle the left hand edge
            //
            unused -= nStart;
            if ( unused > 0 )
            {
                bitWord |= bits << unused;
            }
            else
            {
                bitWord |= bits >> -unused;
                
                InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd, &pReservationEnd);
                pBuffer[0] = __Permedia2TagBitMaskPattern;
                pBuffer[1] = bitWord;
                pBuffer += 2;
                
                unused += 32;
                bitWord = SHIFT_LEFT(bits, unused);
            }

            //
            // Handle all the full longs in the middle, if any
            //
            while ( nBits >= 32 )
            {
                ++pSrc;
                LSWAP_BYTES(bits, pSrc);
                bitWord |= bits >> (32 - unused);
                
                InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd, &pReservationEnd);
                pBuffer[0] = __Permedia2TagBitMaskPattern;
                pBuffer[1] = bitWord;
                pBuffer += 2;
                
                bitWord = SHIFT_LEFT(bits, unused);
                nBits -= 32;
            }

            //
            // Handle the right hand edge, if any
            //
            if ( nBits > 0 )
            {
                ++pSrc;
                LSWAP_BYTES(bits, pSrc);
                bits >>= (32 - nBits);
                unused -= nBits;
                if ( unused > 0 )
                {
                    bitWord |= bits << unused;
                }
                else
                {
                    bitWord |= bits >> -unused;

                    InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd, &pReservationEnd);
                    pBuffer[0] = __Permedia2TagBitMaskPattern;
                    pBuffer[1] = bitWord;
                    pBuffer += 2;

                    unused += 32;
                    bitWord = SHIFT_LEFT(bits, unused);
                }
            }

            if ( --nScanLines == 0 )
            {
                goto completeDownload;
            }

            //
            // go onto next scanline
            //
            pSrcBase += lSrcDelta;
        }
    }

completeDownload:
    
    //
    // Write out final, partial bitWord if any
    //
    if ( unused < 32 )
    {
        InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd, &pReservationEnd);
        pBuffer[0] = __Permedia2TagBitMaskPattern;
        pBuffer[1] = bitWord;
        pBuffer += 2;
    }

    InputBufferCommit(ppdev, pBuffer);

}// vDoMonoBitsDownload()

//-----------------------------------------------------------------------------
//
// void vMonoDownload(GFNPB * ppb)
//
// Dowload the monochrome source from system memory to video memory using
// provided source to destination rop2.
//
// Argumentes needed from function block (GFNPB)
//
//  ppdev-------PPDev
//  psoSrc------Source SURFOBJ
//  psurfDst----Destination Surf
//  lNumRects---Number of rectangles to fill
//  pptlSrc-----Source point
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  pxlo--------XLATEOBJ
//  usRop4------Rop to be performed
//
//-----------------------------------------------------------------------------

VOID
vMonoDownload(GFNPB * ppb)
{
    PDev*       ppdev = ppb->ppdev;
    RECTL*      prcl = ppb->pRects;
    LONG        count = ppb->lNumRects;
    SURFOBJ*    psoSrc = ppb->psoSrc;
    POINTL*     pptlSrc = ppb->pptlSrc;
    RECTL*      prclDst = ppb->prclDst;
    XLATEOBJ *  pxlo = ppb->pxlo;
    ULONG       logicop = ulRop2ToLogicop((unsigned char)(ppb->ulRop4 & 0xf));
    DWORD       dwBitMask;

    PERMEDIA_DECL_VARS;
    PERMEDIA_DECL_INIT;

    ASSERTDD(count > 0, "Can't handle zero rectangles");

    if ( ppb->ulRop4 == 0xB8B8 )
    {
        dwBitMask = permediaInfo->RasterizerMode
                  | INVERT_BITMASK_BITS;
        logicop = K_LOGICOP_COPY;
    }
    else if ( ppb->ulRop4 == 0xE2E2 )
    {
        dwBitMask = permediaInfo->RasterizerMode;
        logicop = K_LOGICOP_COPY;
    }
    else
    {
        dwBitMask = permediaInfo->RasterizerMode | FORCE_BACKGROUND_COLOR;
    }

    ULONG*          pBuffer;

    InputBufferReserve(ppdev, 14, &pBuffer);

    pBuffer[0] = __Permedia2TagFBReadMode;
    pBuffer[1] = PM_FBREADMODE_PARTIAL(ppb->psurfDst->ulPackedPP)
               | LogicopReadDest[logicop];
    pBuffer[2] = __Permedia2TagLogicalOpMode;
    pBuffer[3] = P2_ENABLED_LOGICALOP(logicop);
    pBuffer[4] = __Permedia2TagColorDDAMode;
    pBuffer[5] = __COLOR_DDA_FLAT_SHADE;
    pBuffer[6] = __Permedia2TagConstantColor;
    pBuffer[7] = pxlo->pulXlate[1];  
    pBuffer[8] = __Permedia2TagTexel0;
    pBuffer[9] = pxlo->pulXlate[0];  
    pBuffer[10] = __Permedia2TagFBWindowBase;
    pBuffer[11] = ppb->psurfDst->ulPixOffset;
    pBuffer[12] = __Permedia2TagRasterizerMode;
    pBuffer[13] = dwBitMask;

    pBuffer += 14;

    InputBufferCommit(ppdev, pBuffer);

    while (count--) {
        LONG    xOffset;
        BYTE*   pjSrc;

        // calc x pixel offset from origin
        xOffset = pptlSrc->x + (prcl->left - prclDst->left);
        
        // pjSrc is first dword containing a bit to download
        pjSrc = (BYTE*)((INT_PTR)((PUCHAR) psoSrc->pvScan0
              + ((pptlSrc->y  + (prcl->top - prclDst->top)) * psoSrc->lDelta)
              + ((xOffset >> 3) & ~3)));

        // pjSrc gets us to the first DWORD. Convert xOffset to be the offset
        // to the first pixel in the first DWORD
        xOffset &= 0x1f;

        InputBufferReserve(ppdev, 10, &pBuffer);
        
        // set up the destination rectangle
        pBuffer[0] = __Permedia2TagStartXDom;
        pBuffer[1] = INTtoFIXED(prcl->left);
        pBuffer[2] = __Permedia2TagStartXSub;
        pBuffer[3] = INTtoFIXED(prcl->right);
        pBuffer[4] = __Permedia2TagStartY;
        pBuffer[5] = INTtoFIXED(prcl->top);
        pBuffer[6] = __Permedia2TagCount;
        pBuffer[7] = prcl->bottom - prcl->top;
        pBuffer[8] = __Permedia2TagRender;
        pBuffer[9] = __RENDER_TRAPEZOID_PRIMITIVE 
                   | __RENDER_SYNC_ON_BIT_MASK;

        pBuffer += 10;

        InputBufferCommit(ppdev, pBuffer);

        vMonoBitsDownload(
            ppdev, pjSrc, psoSrc->lDelta, xOffset, 
            prcl->right - prcl->left, prcl->bottom - prcl->top);

        prcl++;

    }

    InputBufferReserve(ppdev, 4, &pBuffer);
    
    pBuffer[0] = __Permedia2TagColorDDAMode;
    pBuffer[1] = __PERMEDIA_DISABLE;
    pBuffer[2] = __Permedia2TagRasterizerMode;
    pBuffer[3] = permediaInfo->RasterizerMode;

    pBuffer += 4;

    InputBufferCommit(ppdev, pBuffer);
}

//-----------------------------------------------------------------------------
//
// void vGradientFillRect(GFNPB * ppb)
//
// Shades the specified primitives.
//
// Argumentes needed from function block (GFNPB)
//
//  ppdev-------PPDev
//  psurfDst----Destination surface
//  lNumRects---Number of rectangles to fill
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  ulMode------Specifies the current drawing mode and how to interpret the
//              array to which pMesh points
//  ptvrt-------Points to an array of TRIVERTEX structures, with each entry
//              containing position and color information.
//  ulNumTvrt---Specifies the number of TRIVERTEX structures in the array to
//              which pVertex points
//  pvMesh------Points to an array of structures that define the connectivity
//              of the TRIVERTEX elements to which ptvrt points
//  ulNumMesh---Specifies the number of elements in the array to which pvMesh
//              points
//
//-----------------------------------------------------------------------------
VOID
vGradientFillRect(GFNPB * ppb)
{
    Surf *          psurfDst = ppb->psurfDst;
    RECTL*          prcl = ppb->pRects;
    LONG            c = ppb->lNumRects;
    PPDev           ppdev = psurfDst->ppdev;
    DWORD           windowBase = psurfDst->ulPixOffset;
    TRIVERTEX       *ptvrt = ppb->ptvrt;
    GRADIENT_RECT   *pgr;
    GRADIENT_RECT   *pgrSentinel = ((GRADIENT_RECT *) ppb->pvMesh)
                                 + ppb->ulNumMesh;
    LONG            xShift;
    LONG            yShift;
    ULONG*          pBuffer;

    DBG_GDI((10, "vGradientFillRect"));


    // setup loop invariant state

    InputBufferReserve(ppdev, 14, &pBuffer);


    pBuffer[0] = __Permedia2TagLogicalOpMode;
    pBuffer[1] = __PERMEDIA_DISABLE;
    pBuffer[2] = __Permedia2TagDitherMode;
    pBuffer[3] = (COLOR_MODE << PM_DITHERMODE_COLORORDER) | 
                 (ppdev->ulPermFormat << PM_DITHERMODE_COLORFORMAT) |
                 (ppdev->ulPermFormatEx << PM_DITHERMODE_COLORFORMATEXTENSION) |
                 (1 << PM_DITHERMODE_ENABLE) |
                 (1 << PM_DITHERMODE_DITHERENABLE);
    pBuffer[4] = __Permedia2TagFBReadMode;
    pBuffer[5] = PM_FBREADMODE_PARTIAL(ppb->psurfDst->ulPackedPP) |
                 PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE);
    pBuffer[6] = __Permedia2TagFBWindowBase;
    pBuffer[7] =  windowBase;
    pBuffer[8] = __Permedia2TagLogicalOpMode;
    pBuffer[9] = __PERMEDIA_DISABLE;
    pBuffer[10] = __Permedia2TagColorDDAMode;
    pBuffer[11] = 3;
    pBuffer[12] = __Permedia2TagdY;
    pBuffer[13] = 1 << 16;

    pBuffer += 14;
//@@BEGIN_DDKSPLIT
    // TODO: This code can be cleaned up a little
    //       1. the delta values should not change with each rectangle
    //       2. we can use the render rectangle primitive
//@@END_DDKSPLIT    
    InputBufferCommit(ppdev, pBuffer);

    while(c--)
    {
        
        pgr = (GRADIENT_RECT *) ppb->pvMesh;

        while(pgr < pgrSentinel)
        {
            TRIVERTEX   *ptrvtLr = ptvrt + pgr->LowerRight;
            TRIVERTEX   *ptrvtUl = ptvrt + pgr->UpperLeft;
            LONG        rd;
            LONG        gd;
            LONG        bd;
            LONG        dx;
            LONG        dy;
            RECTL       rect;
            LONG        rdx;
            LONG        rdy;
            LONG        gdx;
            LONG        gdy;
            LONG        bdx;
            LONG        bdy;
            LONG        rs;
            LONG        gs;
            LONG        bs;
            LONG        lTemp;
            BOOL        bReverseH = FALSE;
            BOOL        bReverseV = FALSE;

            rect.left = ptrvtUl->x;
            rect.right = ptrvtLr->x;
            rect.top = ptrvtUl->y;
            rect.bottom = ptrvtLr->y;
            
            if ( rect.left > rect.right )
            {
                //
                // The fill is from right to left. So we need to swap
                // the rectangle coordinates
                //
                lTemp = rect.left;
                rect.left = rect.right;
                rect.right = lTemp;

                bReverseH = TRUE;
            }

            if ( rect.top > rect.bottom )
            {
                //
                // The coordinate is from bottom to top. So we need to swap
                // the rectangle coordinates
                //
                lTemp = rect.top;
                rect.top = rect.bottom;
                rect.bottom = lTemp;

                bReverseV = TRUE;
            }

            //
            // We need to set start color and color delta according to the
            // rectangle drawing direction
            //
            if( (ppb->ulMode == GRADIENT_FILL_RECT_H) && (bReverseH == TRUE)
              ||(ppb->ulMode == GRADIENT_FILL_RECT_V) && (bReverseV == TRUE) )
            {
                rd = (ptrvtUl->Red - ptrvtLr->Red) << 7;
                gd = (ptrvtUl->Green - ptrvtLr->Green) << 7;
                bd = (ptrvtUl->Blue - ptrvtLr->Blue) << 7;

                rs = ptrvtLr->Red << 7;
                gs = ptrvtLr->Green << 7;
                bs = ptrvtLr->Blue << 7;
            }
            else
            {
                rd = (ptrvtLr->Red - ptrvtUl->Red) << 7;
                gd = (ptrvtLr->Green - ptrvtUl->Green) << 7;
                bd = (ptrvtLr->Blue - ptrvtUl->Blue) << 7;

                rs = ptrvtUl->Red << 7;
                gs = ptrvtUl->Green << 7;
                bs = ptrvtUl->Blue << 7;
            }
            
            // quick clipping reject
            if(prcl->left >= rect.right ||
               prcl->right <= rect.left ||
               prcl->top >= rect.bottom ||
               prcl->bottom <= rect.top)
                goto nextPgr;

            dx = rect.right - rect.left;
            dy = rect.bottom - rect.top;

            if(ppb->ulMode == GRADIENT_FILL_RECT_H)
            {
                rdx = rd / dx;
                gdx = gd / dx;
                bdx = bd / dx;

                rdy = 0;
                gdy = 0;
                bdy = 0;
            }
            else
            {
                rdy = rd / dy;
                gdy = gd / dy;
                bdy = bd / dy;

                rdx = 0;
                gdx = 0;
                bdx = 0;
            }

            //
            // Convert from 9.15 to 9.11 format. The Permedia2
            // dRdx, dGdx etc. registers using 9.11 fixed format. The bottom 4
            // bits are not used.
            //
            rdx &= ~0xf;
            gdx &= ~0xf;
            bdx &= ~0xf;
            rdy &= ~0xf;
            gdy &= ~0xf;
            bdy &= ~0xf;

            // now perform some clipping adjusting start values as necessary
            xShift = prcl->left - rect.left;
            if(xShift > 0)
            {
                rs = rs + (rdx * xShift);
                gs = gs + (gdx * xShift);
                bs = bs + (bdx * xShift);
                rect.left = prcl->left;                
            }

            yShift = prcl->top - rect.top;
            if(yShift > 0)
            {
                rs = rs + (rdy * yShift);
                gs = gs + (gdy * yShift);
                bs = bs + (bdy * yShift);
                rect.top = prcl->top;
            }

            // just move up the bottom right as necessary
            if(prcl->right < rect.right)
                rect.right = prcl->right;

            if(prcl->bottom < rect.bottom)
                rect.bottom = prcl->bottom;
            
            InputBufferReserve(ppdev, 28, &pBuffer);
            
            pBuffer[0] = __Permedia2TagRStart;
            pBuffer[1] = rs;
            pBuffer[2] = __Permedia2TagGStart;
            pBuffer[3] = gs;
            pBuffer[4] = __Permedia2TagBStart;
            pBuffer[5] = bs;

            pBuffer[6] = __Permedia2TagdRdx;
            pBuffer[7] = rdx;
            pBuffer[8] = __Permedia2TagdRdyDom;
            pBuffer[9] = rdy;
            pBuffer[10] = __Permedia2TagdGdx;
            pBuffer[11] = gdx;
            pBuffer[12] = __Permedia2TagdGdyDom;
            pBuffer[13] = gdy;
            pBuffer[14] = __Permedia2TagdBdx;
            pBuffer[15] = bdx;
            pBuffer[16] = __Permedia2TagdBdyDom;
            pBuffer[17] = bdy;

            // NOTE: alpha is always constant


            // Render the rectangle

            pBuffer[18] = __Permedia2TagStartXDom;
            pBuffer[19] = rect.left << 16;
            pBuffer[20] = __Permedia2TagStartXSub;
            pBuffer[21] = rect.right << 16;
            pBuffer[22] = __Permedia2TagStartY;
            pBuffer[23] = rect.top << 16;
            pBuffer[24] = __Permedia2TagCount;
            pBuffer[25] = rect.bottom - rect.top;

            pBuffer[26] = __Permedia2TagRender;
            pBuffer[27] = __RENDER_TRAPEZOID_PRIMITIVE;


            pBuffer += 28;

            InputBufferCommit(ppdev, pBuffer);

        nextPgr:

            pgr++;
    
        }

        prcl++;

    }

    InputBufferReserve(ppdev, 6, &pBuffer);
    
    pBuffer[0] = __Permedia2TagdY;
    pBuffer[1] = INTtoFIXED(1);
    pBuffer[2] = __Permedia2TagDitherMode;
    pBuffer[3] = 0;
    pBuffer[4] = __Permedia2TagColorDDAMode;
    pBuffer[5] = 0;
    
    pBuffer += 6;

    InputBufferCommit(ppdev, pBuffer);

}// vGradientFillRect()

//-----------------------------------------------------------------------------
//
// void vTransparentBlt(GFNPB * ppb)
//
// Provides bit-block transfer capabilities with transparency.
//
// Argumentes needed from function block (GFNPB)
//
//  ppdev-------PPDev
//  psurfSrc----Source surface
//  psurfDst----Destination surface
//  lNumRects---Number of rectangles to fill
//  prclSrc-----Points to a RECTL structure that defines the rectangular area
//              to be copied
//  prclDst-----Points to a RECTL structure that defines the rectangular area
//              to be modified
//  colorKey----Specifies the transparent color in the source surface format.
//              It is a color index value that has been translated to the
//              source surface's palette.
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//
//-----------------------------------------------------------------------------
VOID
vTransparentBlt(GFNPB * ppb)
{
    Surf * psurfDst = ppb->psurfDst;
    Surf * psurfSrc = ppb->psurfSrc;
    RECTL*  prcl = ppb->pRects;
    LONG    c = ppb->lNumRects;
    RECTL*  prclSrc = ppb->prclSrc;
    RECTL*  prclDst = ppb->prclDst;
    DWORD   colorKey = ppb->colorKey;
    PPDev   ppdev = psurfDst->ppdev;
    DWORD   windowBase = psurfDst->ulPixOffset;
    LONG    sourceOffset = psurfSrc->ulPixOffset;
    DWORD   dwRenderDirection;
    DWORD   format = ppdev->ulPermFormat;
    DWORD   extension = ppdev->ulPermFormatEx;
    DWORD   dwLowerBound;
    DWORD   dwUpperBound;
    ULONG*  pBuffer;

    DBG_GDI((6, "vTransparentBlt"));

    ASSERTDD(prclSrc->right - prclSrc->left == (prclDst->right - prclDst->left),
                "vTransparentBlt: expect one-to-one blts only");
    
    ASSERTDD(prclSrc->bottom - prclSrc->top == (prclDst->bottom - prclDst->top),
                "vTransparentBlt: expect one-to-one blts only");
//@@BEGIN_DDKSPLIT
    // TODO: should call utility function to format color key
//@@END_DDKSPLIT
    if (format == PERMEDIA_8BIT_PALETTEINDEX)
    {
        colorKey = FORMAT_PALETTE_32BIT(colorKey);
        dwLowerBound = CHROMA_LOWER_ALPHA(colorKey);
        dwUpperBound = CHROMA_UPPER_ALPHA(colorKey);
    }
    else if(ppdev->ulPermFormat == PERMEDIA_565_RGB)
    {
        colorKey = FORMAT_565_32BIT_BGR(colorKey);
        dwLowerBound = CHROMA_LOWER_ALPHA(colorKey);
        dwUpperBound = CHROMA_UPPER_ALPHA(colorKey);
        dwLowerBound = dwLowerBound & 0xF8F8FCF8;
        dwUpperBound = dwUpperBound | 0x07070307;
    }
    else
    {
        colorKey = FORMAT_8888_32BIT_BGR(colorKey);
        dwLowerBound = CHROMA_LOWER_ALPHA(colorKey);
        dwUpperBound = CHROMA_UPPER_ALPHA(colorKey);
    }
    
    // setup loop invariant state

    InputBufferReserve(ppdev, 24, &pBuffer);
    
    // Reject range
    pBuffer[0] = __Permedia2TagYUVMode;
    pBuffer[1] = 0x2 << 1;
    pBuffer[2] = __Permedia2TagFBWindowBase;
    pBuffer[3] = windowBase;

    // set no read of source.
    // add read src/dest enable
    pBuffer[4] = __Permedia2TagFBReadMode;
    pBuffer[5] = psurfDst->ulPackedPP;
    pBuffer[6] = __Permedia2TagLogicalOpMode;
    pBuffer[7] = __PERMEDIA_DISABLE;

     // set base of source
    pBuffer[8] = __Permedia2TagTextureBaseAddress;
    pBuffer[9] = sourceOffset;
    pBuffer[10] = __Permedia2TagTextureAddressMode;
    pBuffer[11] = 1 << PM_TEXADDRESSMODE_ENABLE;
    //
    // modulate & ramp??
    pBuffer[12] = __Permedia2TagTextureColorMode;
    pBuffer[13] = (1 << PM_TEXCOLORMODE_ENABLE) |
                  (_P2_TEXTURE_COPY << PM_TEXCOLORMODE_APPLICATION);

    pBuffer[14] = __Permedia2TagTextureReadMode;
    pBuffer[15] = PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE) |
                  PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE) |
                  PM_TEXREADMODE_WIDTH(11) |
                  PM_TEXREADMODE_HEIGHT(11);

    pBuffer[16] = __Permedia2TagTextureDataFormat;
    pBuffer[17] = (format << PM_TEXDATAFORMAT_FORMAT) |
                  (extension << PM_TEXDATAFORMAT_FORMATEXTENSION) |
                  (COLOR_MODE << PM_TEXDATAFORMAT_COLORORDER);

    pBuffer[18] = __Permedia2TagTextureMapFormat;
    pBuffer[19] = (psurfSrc->ulPackedPP) | 
                  (ppdev->cPelSize << PM_TEXMAPFORMAT_TEXELSIZE);


    pBuffer[20] = __Permedia2TagChromaLowerBound;
    pBuffer[21] = dwLowerBound;
    pBuffer[22] = __Permedia2TagChromaUpperBound;
    pBuffer[23] = dwUpperBound;
    
    pBuffer += 24;

    InputBufferCommit(ppdev, pBuffer);
    
    if (format != PERMEDIA_8BIT_PALETTEINDEX)
    {

        InputBufferReserve(ppdev, 2, &pBuffer);

        // Reject range
        pBuffer[0] = __Permedia2TagDitherMode;
        pBuffer[1] = (COLOR_MODE << PM_DITHERMODE_COLORORDER) | 
                     (format << PM_DITHERMODE_COLORFORMAT) |
                     (extension << PM_DITHERMODE_COLORFORMATEXTENSION) |
                     (1 << PM_DITHERMODE_ENABLE);

        pBuffer += 2;

        InputBufferCommit(ppdev, pBuffer);

    }

    while(c--) {

        RECTL   rDest;
        RECTL   rSrc;

        rDest = *prcl;
        
        rSrc.left = prclSrc->left + (rDest.left - prclDst->left);
        rSrc.top = prclSrc->top + (rDest.top - prclDst->top);
        rSrc.right = rSrc.left + (rDest.right - rDest.left);
        rSrc.bottom = rSrc.top + (rDest.bottom - rDest.top);

        if (rSrc.top < 0) {
            rDest.top -= rSrc.top;
            rSrc.top = 0;
        }
        
        if (rSrc.left < 0) {
            rDest.left -= rSrc.left;
            rSrc.left = 0;
        }

        if ((psurfSrc->ulPixOffset) != (psurfDst->ulPixOffset))
        {
            dwRenderDirection = 1;
        }
        else
        {
            if(rSrc.top < rDest.top)
            {
                dwRenderDirection = 0;
            }
            else if(rSrc.top > rDest.top)
            {
                dwRenderDirection = 1;
            }
            else if(rSrc.left < rDest.left)
            {
                dwRenderDirection = 0;
            }
            else dwRenderDirection = 1;
        }
    
        InputBufferReserve(ppdev, 24, &pBuffer);

        
        // Left -> right, top->bottom
        if (dwRenderDirection)
        {
            // set offset of source
            pBuffer[0] = __Permedia2TagSStart;
            pBuffer[1] = rSrc.left << 20;
            pBuffer[2] = __Permedia2TagTStart;
            pBuffer[3] = rSrc.top << 20;
            pBuffer[4] = __Permedia2TagdSdx;
            pBuffer[5] = 1 << 20;
            pBuffer[6] = __Permedia2TagdSdyDom;
            pBuffer[7] = 0;
            pBuffer[8] = __Permedia2TagdTdx;
            pBuffer[9] = 0;
            pBuffer[10] = __Permedia2TagdTdyDom;
            pBuffer[11] = 1 << 20;
    
            pBuffer[12] = __Permedia2TagStartXDom;
            pBuffer[13] = rDest.left << 16;
            pBuffer[14] = __Permedia2TagStartXSub;
            pBuffer[15] = rDest.right << 16;
            pBuffer[16] = __Permedia2TagStartY;
            pBuffer[17] = rDest.top << 16;
            pBuffer[18] = __Permedia2TagdY;
            pBuffer[19] = 1 << 16;
            pBuffer[20] = __Permedia2TagCount;
            pBuffer[21] = rDest.bottom - rDest.top;
            pBuffer[22] = __Permedia2TagRender;
            pBuffer[23] = __RENDER_TRAPEZOID_PRIMITIVE |
                          __RENDER_TEXTURED_PRIMITIVE;
        }
        else
        // right->left, bottom->top
        {
            // set offset of source
            pBuffer[0] = __Permedia2TagSStart;
            pBuffer[1] = rSrc.right << 20;
            pBuffer[2] = __Permedia2TagTStart;
            pBuffer[3] = (rSrc.bottom - 1) << 20;
            pBuffer[4] = __Permedia2TagdSdx;
            pBuffer[5] = (DWORD) (-1 << 20);
            pBuffer[6] = __Permedia2TagdSdyDom;
            pBuffer[7] = 0;
            pBuffer[8] = __Permedia2TagdTdx;
            pBuffer[9] = 0;
            pBuffer[10] = __Permedia2TagdTdyDom;
            pBuffer[11] = (DWORD)(-1 << 20);
    
            // Render right to left, bottom to top
            pBuffer[12] = __Permedia2TagStartXDom;
            pBuffer[13] = rDest.right << 16;
            pBuffer[14] = __Permedia2TagStartXSub;
            pBuffer[15] = rDest.left << 16;
            pBuffer[16] = __Permedia2TagStartY;
            pBuffer[17] = (rDest.bottom - 1) << 16;
            pBuffer[18] = __Permedia2TagdY;
            pBuffer[19] = (DWORD)(-1 << 16);
            pBuffer[20] = __Permedia2TagCount;
            pBuffer[21] = rDest.bottom - rDest.top;
            pBuffer[22] = __Permedia2TagRender;
            pBuffer[23] = __RENDER_TRAPEZOID_PRIMITIVE |
                          __RENDER_TEXTURED_PRIMITIVE;
        }

        pBuffer += 24;
    
        InputBufferCommit(ppdev, pBuffer);

        prcl++;
    }

    // restore default state

    InputBufferReserve(ppdev, 12, &pBuffer);
    
    pBuffer[0] = __Permedia2TagdY;
    pBuffer[1] =  INTtoFIXED(1);
    pBuffer[2] = __Permedia2TagDitherMode;
    pBuffer[3] = 0;
    pBuffer[4] = __Permedia2TagYUVMode;
    pBuffer[5] = 0x0;
    pBuffer[6] = __Permedia2TagTextureAddressMode;
    pBuffer[7] = __PERMEDIA_DISABLE;
    pBuffer[8] = __Permedia2TagTextureColorMode;
    pBuffer[9] = __PERMEDIA_DISABLE;
    pBuffer[10] = __Permedia2TagTextureReadMode;
    pBuffer[11] = __PERMEDIA_DISABLE;

    pBuffer += 12;

    InputBufferCommit(ppdev,pBuffer);

}// vTransparentBlt()

//-----------------------------------------------------------------------------
//
// void vSolidFill(GFNPB* ppb)
//
// Fill a set of rectangles with a solid color
//
// Argumentes needed from function block (GFNPB)
//
//  ppdev-------PPDev
//  psurfDst----Destination surface
//  lNumRects---Number of rectangles to fill
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  solidColor--Fill color
//
//-----------------------------------------------------------------------------
VOID
vSolidFill(GFNPB * ppb)
{
    PPDev   ppdev = ppb->ppdev;
    ULONG   color = ppb->solidColor;
    RECTL * pRect = ppb->pRects;
    LONG    count = ppb->lNumRects;
    Surf*   psurf = ppb->psurfDst;
//@@BEGIN_DDKSPLIT    
    // TODO should call utility function to setup fill color
//@@END_DDKSPLIT

    //
    // Note: GDI guarantees that the unused bits are set to zero. We have
    // an assert in DrvBitBlt to check the color value for unused high bits
    // to make it sure that they are zero.
    //
    if (ppdev->cPelSize == 1)
    {
        color |= (color << 16);
    }
    else if (ppdev->cPelSize == 0)
    {
        color |= color << 8;
        color |= color << 16;
    }

    //
    // setup loop invariant state
    //
    ULONG*          pBuffer;
    ULONG*          pReservationEnd;
    ULONG*          pBufferEnd;

    InputBufferStart(ppdev, 8, &pBuffer, &pBufferEnd, &pReservationEnd);
    
    pBuffer[0] = __Permedia2TagFBBlockColor;
    pBuffer[1] = color;
    pBuffer[2] = __Permedia2TagFBReadMode;
    pBuffer[3] = PM_FBREADMODE_PARTIAL(psurf->ulPackedPP) |
                 PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE);
    pBuffer[4] = __Permedia2TagLogicalOpMode;
    pBuffer[5] = __PERMEDIA_CONSTANT_FB_WRITE;
    pBuffer[6] = __Permedia2TagFBWindowBase;
    pBuffer[7] = psurf->ulPixOffset;

    while(count--)
    {

        // Render the rectangle

        pBuffer = pReservationEnd;
        
        InputBufferContinue(ppdev, 6, &pBuffer, &pBufferEnd, &pReservationEnd);

        pBuffer[0] = __Permedia2TagRectangleOrigin;
        pBuffer[1] = pRect->top << 16 | pRect->left;
        pBuffer[2] = __Permedia2TagRectangleSize;
        pBuffer[3] = ((pRect->bottom - pRect->top) << 16) |
                     (pRect->right - pRect->left);
        pBuffer[4] = __Permedia2TagRender;
        pBuffer[5] = __RENDER_FAST_FILL_ENABLE | __RENDER_RECTANGLE_PRIMITIVE |
                    __RENDER_INCREASE_X | __RENDER_INCREASE_Y;

        pRect++;

    }

    pBuffer = pReservationEnd;

    InputBufferCommit(ppdev, pBuffer);

}// vSolidFill()

//-----------------------------------------------------------------------------
//
// VOID vInvert
//
// Fill a set of rectangles with a solid color 
//
// Argumentes needed from function block (GFNPB)
//
//  ppdev-------PPDev
//  psurfDst----Pointer to device surface
//  lNumRects---Number of clipping rectangles
//  pRect-------Array of clipping rectangles
//
//-----------------------------------------------------------------------------
VOID
vInvert(GFNPB * ppb)
{
    PPDev   ppdev = ppb->ppdev;
    RECTL * pRect = ppb->pRects;
    LONG    count = ppb->lNumRects;
    Surf*   psurf = ppb->psurfDst;
    ULONG*  pBuffer;

    // setup loop invariant state

    InputBufferReserve(ppdev, 6, &pBuffer);

    pBuffer[0] = __Permedia2TagFBWindowBase;
    pBuffer[1] = psurf->ulPixOffset;
    
    pBuffer[2] = __Permedia2TagFBReadMode;
    pBuffer[3] = PM_FBREADMODE_PARTIAL(psurf->ulPackedPP) |
                 PM_FBREADMODE_READDEST(__PERMEDIA_ENABLE);

    pBuffer[4] = __Permedia2TagLogicalOpMode;
    pBuffer[5] = P2_ENABLED_LOGICALOP(K_LOGICOP_INVERT);

    pBuffer += 6;

    InputBufferCommit(ppdev, pBuffer);

    while(count--)
    {

        // Render the rectangle
    
        InputBufferReserve(ppdev, 6, &pBuffer);
        
        pBuffer[0] = __Permedia2TagRectangleOrigin;
        pBuffer[1] = (pRect->top << 16) | pRect->left;
        pBuffer[2] = __Permedia2TagRectangleSize;
        pBuffer[3] = ((pRect->bottom - pRect->top) << 16) 
                   | (pRect->right - pRect->left);
        pBuffer[4] = __Permedia2TagRender;
        pBuffer[5] = __RENDER_RECTANGLE_PRIMITIVE
                   | __RENDER_INCREASE_X
                   | __RENDER_INCREASE_Y;
    
        pBuffer += 6;
        
        InputBufferCommit(ppdev, pBuffer);

        pRect++;

    }

}// vInvert()

//-----------------------------------------------------------------------------
//
// void vSolidFillWithRop(GFNPB* ppb)
//
// Fill a set of rectangles with a solid color based on the given lLogicOP.
//
// Argumentes needed from function block (GFNPB)
//
//  ppdev-------PPDev
//  psurfDst----Destination surface
//  lNumRects---Number of rectangles to fill
//  pRects------Pointer to a list of rectangles information which needed to be
//              filled
//  solidColor--Fill color
//  ulRop4------Logic OP for the fill
//
//-----------------------------------------------------------------------------
//@@BEGIN_DDKSPLIT
        // TODO:  Some clean up: Why are we calculating lLeft andn lRight
        // but use pRcl->left and pRcl->right below.
//@@END_DDKSPLIT
VOID
vSolidFillWithRop(GFNPB* ppb)
{
    PPDev   ppdev = ppb->ppdev;
    Surf*   psurfDst = ppb->psurfDst;    
    
    DWORD   dwExtra = 0;
    DWORD   dwRenderBits;    
    DWORD   dwShift = 0;
    DWORD   dwWindowBase = psurfDst->ulPixOffset;
    
    LONG    lLeft;
    LONG    lNumOfRects = ppb->lNumRects;       // Number of rectangles
    LONG    lRight;
    
    RECTL*  pRcl = ppb->pRects;
    ULONG   ulColor = ppb->solidColor;          // Brush solid fill color
    ULONG   ulLogicOP = ulRop3ToLogicop(ppb->ulRop4 & 0xFF);
                                                // Hardware mix mode
                                                // (foreground mix mode if
                                                // the brush has a mask)
    ULONG*  pBuffer;


    DBG_GDI((6,"vSolidFillWithRop: numRects = %ld Rop4 = 0x%x",
            lNumOfRects, ppb->ulRop4));
    
    //
    // Setup logic OP invariant state
    //

    InputBufferReserve(ppdev, 2, &pBuffer);
    
    pBuffer[0] = __Permedia2TagFBWindowBase;
    pBuffer[1] = dwWindowBase;
    pBuffer += 2;
    
    InputBufferCommit(ppdev, pBuffer);
    
     switch ( ulLogicOP )
    {
        case K_LOGICOP_COPY:
            DBG_GDI((6,"vSolidFillWithRop: COPY"));

            //
            // For SRC_COPY, we can use fastfill
            //
            dwRenderBits = __RENDER_FAST_FILL_ENABLE
                         | __RENDER_TRAPEZOID_PRIMITIVE
                         | __RENDER_INCREASE_Y
                         | __RENDER_INCREASE_X;


            //
            // Setup color data based on current color mode we are in
            //
            if ( ppdev->cPelSize == 1 )
            {
                //
                // We are in 16 bit packed mode. So the color data must be
                // repeated in both halves of the FBBlockColor register
                //
                ASSERTDD((ulColor & 0xFFFF0000) == 0,
                          "vSolidFillWithRop: upper bits not zero");
                ulColor |= (ulColor << 16);
            }
            else if ( ppdev->cPelSize == 0 )
            {
                //
                // We are in 8 bit packed mode. So the color data must be
                // repeated in all 4 bytes of the FBBlockColor register
                //
                ASSERTDD((ulColor & 0xFFFFFF00) == 0,
                          "vSolidFillWithRop: upper bits not zero");
                ulColor |= ulColor << 8;
                ulColor |= ulColor << 16;
            }
                    
            //
            // Setup some loop invariant states
            //
            InputBufferReserve(ppdev, 6, &pBuffer);

            pBuffer[0] = __Permedia2TagLogicalOpMode;
            pBuffer[1] = __PERMEDIA_CONSTANT_FB_WRITE;
            pBuffer[2] = __Permedia2TagFBReadMode;
            pBuffer[3] = PM_FBREADMODE_PARTIAL(psurfDst->ulPackedPP)
                       | PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE);
            pBuffer[4] = __Permedia2TagFBBlockColor;
            pBuffer[5] = ulColor;
            pBuffer += 6;

            InputBufferCommit(ppdev, pBuffer);

            break;

        case K_LOGICOP_INVERT:
            DBG_GDI((6,"vSolidFillWithRop: INVERT"));

            dwRenderBits = __RENDER_TRAPEZOID_PRIMITIVE
                         | __RENDER_INCREASE_Y
                         | __RENDER_INCREASE_X;
            
            //
            // When using packed operations we have to convert the left and
            // right X coordinates into 32-bit-based quantities, we do this by
            // shifting. We also have to round up the right X co-ord if the
            // pixels don't fill a DWORD. Not a problem for 32BPP.
            //
            dwShift = 2 - (ppdev->cPelSize);

            if ( dwShift )
            {
                dwExtra = (dwShift << 1) - 1;
            }
            else
            {
                dwExtra = 0;
            }

            //
            // setup some loop invariant states
            //

            InputBufferReserve(ppdev, 6, &pBuffer);

            pBuffer[0] = __Permedia2TagLogicalOpMode;
            pBuffer[1] = __PERMEDIA_DISABLE;
            pBuffer[2] = __Permedia2TagFBReadMode;
            pBuffer[3] = PM_FBREADMODE_PARTIAL(psurfDst->ulPackedPP)
                       | PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE);
            pBuffer[4] = __Permedia2TagConfig;
            pBuffer[5] = __PERMEDIA_CONFIG_LOGICOP(ulLogicOP)
                                     | __PERMEDIA_CONFIG_FBWRITE
                                     | __PERMEDIA_CONFIG_PACKED_DATA
                                     | ConfigReadDest[ulLogicOP];
            pBuffer += 6;

            InputBufferCommit(ppdev, pBuffer);

            break;

        default:

            DBG_GDI((6,"vSolidFillWithRop: numRects %ld, Rop4=0x%x color=0x%lx",
                lNumOfRects, ppb->ulRop4, ulColor));

            dwRenderBits = __RENDER_TRAPEZOID_PRIMITIVE
                         | __RENDER_INCREASE_Y
                         | __RENDER_INCREASE_X;
            
            InputBufferReserve(ppdev, 8, &pBuffer);

            pBuffer[0] = __Permedia2TagLogicalOpMode;
            pBuffer[1] = __PERMEDIA_DISABLE;
            pBuffer[2] = __Permedia2TagFBReadMode;
            pBuffer[3] = PM_FBREADMODE_PARTIAL(psurfDst->ulPackedPP);
            pBuffer[4] = __Permedia2TagConstantColor;
            pBuffer[5] = ulColor;
            pBuffer[6] = __Permedia2TagConfig;
            pBuffer[7] = __PERMEDIA_CONFIG_LOGICOP(ulLogicOP)
                                     | __PERMEDIA_CONFIG_FBWRITE
                                     | __PERMEDIA_CONFIG_COLOR_DDA
                                     | ConfigReadDest[ulLogicOP];
            pBuffer += 8;

            InputBufferCommit(ppdev, pBuffer);

            break;
    }// switch( ulLogicOP )   

    //
    // Loop through all the rectangles and fill them
    //
    for(;;) 
    {
        
        //
        // Calculate the left and right pixels from the rectangle.
        //
        lLeft = pRcl->left;
        lRight = pRcl->right;

        InputBufferReserve(ppdev, 12, &pBuffer);

        //
        // If we need to set up the packed data limits then do it, also convert
        // the left and right X coordinates to DWORD-based numbers, with a bit
        // of rounding
        //
        if ( ulLogicOP == K_LOGICOP_INVERT )
        {
            pBuffer[0] = __Permedia2TagPackedDataLimits;
            pBuffer[1] = (lLeft << 16) | lRight;

            pBuffer += 2;
            
            lLeft >>= dwShift;
            lRight = (lRight + dwExtra) >> dwShift;
        }

        pBuffer[0] = __Permedia2TagStartXDom;
        pBuffer[1] = pRcl->left << 16;
        pBuffer[2] = __Permedia2TagStartXSub;
        pBuffer[3] = pRcl->right << 16;
        pBuffer[4] = __Permedia2TagStartY;
        pBuffer[5] = pRcl->top << 16;
        pBuffer[6] = __Permedia2TagCount;
        pBuffer[7] = pRcl->bottom - pRcl->top;
        pBuffer[8] = __Permedia2TagRender;
        pBuffer[9] = dwRenderBits;

        pBuffer += 10;

        InputBufferCommit(ppdev, pBuffer);
        
        if ( --lNumOfRects == 0 )
        {
            break;
        }

        //
        // Move onto the next rectangle
        //
        ++pRcl;        
    } // for()

    //
    // Restore the DDA mode
    //
    InputBufferReserve(ppdev, 2, &pBuffer);
    
    pBuffer[0] = __Permedia2TagColorDDAMode;
    pBuffer[1] = __PERMEDIA_DISABLE;
    pBuffer += 2;
    
    InputBufferCommit(ppdev, pBuffer);
    
}// vSolidFillWithRop()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\stretch.c ===
/******************************Module*Header***********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: stretch.c
 *
 * Contains all the stretch blt functions.
 *
 * Copyright (C) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
 ******************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "directx.h"
#include "clip.h"

//
// Maximal clip rectangle for trivial stretch clipping
//
// Note: SCISSOR_MAX is defined as 2047 because this is
// the maximum clip size P2 can handle.
// It is OK to set this maximum clip size since no device
// bitmap will be bigger than 2047. This is the limitation
// of P2 hardware. See DrvCreateDeviceBitmap() for more
// detail
//
RECTL grclStretchClipMax = { 0, 0, SCISSOR_MAX, SCISSOR_MAX };

//-----------------------------------------------------------------------------
//
// DWORD dwGetPixelSize()
//
// This routine converts current bitmap format to Permedia pixel size
//
//-----------------------------------------------------------------------------
DWORD
dwGetPixelSize(ULONG    ulBitmapFormat,
               DWORD*   pdwFormatBits,
               DWORD*   pdwFormatExtention)
{
    DWORD dwPixelSize;

    switch ( ulBitmapFormat )
    {
        case BMF_8BPP:
            dwPixelSize = 0;
            *pdwFormatBits = PERMEDIA_8BIT_PALETTEINDEX;
            *pdwFormatExtention = PERMEDIA_8BIT_PALETTEINDEX_EXTENSION;
            break;

        case BMF_16BPP:
            dwPixelSize = 1;
            *pdwFormatBits = PERMEDIA_565_RGB;
            *pdwFormatExtention = PERMEDIA_565_RGB_EXTENSION;
            break;

        case BMF_32BPP:
            dwPixelSize = 2;
            *pdwFormatBits = PERMEDIA_888_RGB;
            *pdwFormatExtention = PERMEDIA_888_RGB_EXTENSION;
            break;

        default:
            dwPixelSize = -1;
    }

    return dwPixelSize;
}// dwGetPixelSize()

//-----------------------------------------------------------------------------
//
// DWORD bStretchInit()
//
// This routine initializes all the registers needed for doing a stretch blt
//
//-----------------------------------------------------------------------------
BOOL
bStretchInit(SURFOBJ*    psoDst,
             SURFOBJ*    psoSrc)
{
    Surf*   pSurfDst = (Surf*)psoDst->dhsurf;
    Surf*   pSurfSrc = (Surf*)psoSrc->dhsurf;
    DWORD   dwDstPixelSize;
    DWORD   dwDstFormatBits;
    DWORD   dwDstFormatExtention;
    DWORD   dwSrcPixelSize;
    DWORD   dwSrcFormatBits;
    DWORD   dwSrcFormatExtention;
    PDev*   ppdev = (PDev*)psoDst->dhpdev;
    ULONG*  pBuffer;

    DBG_GDI((6, "bStretchInit called"));
    
    ASSERTDD(pSurfSrc, "Not valid private surface in source");
    ASSERTDD(pSurfDst, "Not valid private surface in destination");

    dwDstPixelSize = dwGetPixelSize(psoDst->iBitmapFormat,
                                    &dwDstFormatBits,
                                    &dwDstFormatExtention);

    if ( dwDstPixelSize == -1 )
    {
        DBG_GDI((1, "bStretchBlt return FALSE because of wrong DstPixel Size"));
        //
        // Unsupported bitmap format, return false
        //
        return FALSE;
    }
    
    InputBufferReserve(ppdev, 26, &pBuffer);

    if ( dwDstPixelSize != __PERMEDIA_8BITPIXEL)
    {
        pBuffer[0] = __Permedia2TagDitherMode;
        pBuffer[1] = (COLOR_MODE << PM_DITHERMODE_COLORORDER) // RGB color order
                   |(dwDstFormatBits << PM_DITHERMODE_COLORFORMAT)
                   |(dwDstFormatExtention << PM_DITHERMODE_COLORFORMATEXTENSION)
                   |(1 << PM_DITHERMODE_ENABLE);
    }
    else
    {
        pBuffer[0] = __Permedia2TagDitherMode;
        pBuffer[1] = __PERMEDIA_DISABLE;
    }

    pBuffer[2] = __Permedia2TagFBWindowBase;
    pBuffer[3] = pSurfDst->ulPixOffset;

    //
    // Set no read of source.
    //
    pBuffer[4]  = __Permedia2TagFBReadMode;
    pBuffer[5]  = PM_FBREADMODE_PARTIAL(pSurfDst->ulPackedPP);
    pBuffer[6]  = __Permedia2TagLogicalOpMode;
    pBuffer[7]  = __PERMEDIA_DISABLE;
    pBuffer[8]  = __Permedia2TagTextureBaseAddress;
    pBuffer[9]  = pSurfSrc->ulPixOffset;
    pBuffer[10] = __Permedia2TagTextureAddressMode;
    pBuffer[11] = 1 << PM_TEXADDRESSMODE_ENABLE;
    pBuffer[12] = __Permedia2TagTextureColorMode;
    pBuffer[13] = (1 << PM_TEXCOLORMODE_ENABLE)
                | (0 << 4)                                           // RGB  
                | (_P2_TEXTURE_COPY << PM_TEXCOLORMODE_APPLICATION);

    //
    // Note: we have to turn off BiLinear filtering here, even for stretch
    // because GDI doesn't do it. Otherwise, we will fail during the
    // comparison
    //
    pBuffer[14] = __Permedia2TagTextureReadMode;
    pBuffer[15] = PM_TEXREADMODE_ENABLE(__PERMEDIA_ENABLE)
                | PM_TEXREADMODE_FILTER(__PERMEDIA_DISABLE)
                | PM_TEXREADMODE_WIDTH(11)
                | PM_TEXREADMODE_HEIGHT(11);

    dwSrcPixelSize = dwGetPixelSize(psoSrc->iBitmapFormat,
                                    &dwSrcFormatBits,
                                    &dwSrcFormatExtention);

    if ( dwSrcPixelSize == -1 )
    {
        DBG_GDI((1, "bStretchBlt return FALSE because of wrong SrcPixel Size"));
        //
        // Unsupported bitmap format, return false
        //
        return FALSE;
    }
    
    pBuffer[16] = __Permedia2TagTextureDataFormat;
    pBuffer[17] = (dwSrcFormatBits << PM_TEXDATAFORMAT_FORMAT)
                | (dwSrcFormatExtention << PM_TEXDATAFORMAT_FORMATEXTENSION)
                | (COLOR_MODE << PM_TEXDATAFORMAT_COLORORDER);
    pBuffer[18] = __Permedia2TagTextureMapFormat;
    pBuffer[19] = pSurfSrc->ulPackedPP
                |(dwSrcPixelSize << PM_TEXMAPFORMAT_TEXELSIZE);
    pBuffer[20] = __Permedia2TagScissorMode;
    pBuffer[21] = SCREEN_SCISSOR_DEFAULT
                | USER_SCISSOR_ENABLE;
    
    pBuffer[22] = __Permedia2TagdSdyDom;
    pBuffer[23] = 0;
    pBuffer[24] = __Permedia2TagdTdx;
    pBuffer[25] = 0;

    pBuffer += 26;
    InputBufferCommit(ppdev, pBuffer);

    DBG_GDI((6, "bStretchInit return TRUE"));
    return TRUE;
}// bStretchInit()

//-----------------------------------------------------------------------------
//
// DWORD bStretchReset()
//
// This routine resets all the registers changed during stretch blt
//
//-----------------------------------------------------------------------------
void
vStretchReset(PDev* ppdev)
{
    ULONG*  pBuffer;
    
    DBG_GDI((6, "vStretchReset called"));
    
    InputBufferReserve(ppdev, 12, &pBuffer);
    
    //
    // Restore the default settings
    //
    pBuffer[0] = __Permedia2TagScissorMode;
    pBuffer[1] = SCREEN_SCISSOR_DEFAULT;
    pBuffer[2] = __Permedia2TagDitherMode;
    pBuffer[3] = __PERMEDIA_DISABLE;
    pBuffer[4] = __Permedia2TagTextureAddressMode;
    pBuffer[5] = __PERMEDIA_DISABLE;
    pBuffer[6] = __Permedia2TagTextureColorMode;
    pBuffer[7] = __PERMEDIA_DISABLE;
    pBuffer[8] = __Permedia2TagTextureReadMode;
    pBuffer[9] = __PERMEDIA_DISABLE;
    pBuffer[10] = __Permedia2TagdY;
    pBuffer[11] = INTtoFIXED(1);

    pBuffer += 12;
    InputBufferCommit(ppdev, pBuffer);

    DBG_GDI((6, "vStretchReset done"));
    return;
}// vStretchReset()

//-----------------------------------------------------------------------------
//
// VOID vStretchBlt()
//
// This routine does the stretch blt work through the texture engine
//
//-----------------------------------------------------------------------------
VOID
vStretchBlt(SURFOBJ*    psoDst,
            SURFOBJ*    psoSrc,
            RECTL*      rDest,
            RECTL*      rSrc,
            RECTL*      prclClip)
{
    Surf*   pSurfDst = (Surf*)psoDst->dhsurf;
    Surf*   pSurfSrc = (Surf*)psoSrc->dhsurf;
    LONG    lXScale;
    LONG    lYScale;
    DWORD   dwDestWidth = rDest->right - rDest->left;
    DWORD   dwDestHeight = rDest->bottom - rDest->top;
    DWORD   dwSourceWidth = rSrc->right - rSrc->left;
    DWORD   dwSourceHeight = rSrc->bottom - rSrc->top;
    DWORD   dwRenderDirection;
    DWORD   dwDstPixelSize;
    DWORD   dwDstFormatBits;
    DWORD   dwDstFormatExtention;
    DWORD   dwSrcPixelSize;
    DWORD   dwSrcFormatBits;
    DWORD   dwSrcFormatExtention;
    ULONG*  pBuffer;
    PDev*   ppdev = (PDev*)psoDst->dhpdev;

    DBG_GDI((6, "vStretchBlt called"));
    DBG_GDI((6, "prclClip (left, right, top, bottom)=(%d, %d, %d,%d)",
             prclClip->left, prclClip->right, prclClip->top, prclClip->bottom));
    DBG_GDI((6, "rSrc (left, right, top, bottom=(%d, %d, %d,%d)",rSrc->left,
             rSrc->right, rSrc->top, rSrc->bottom));
    DBG_GDI((6, "rDest (left, right, top, bottom)=(%d, %d, %d,%d)",rDest->left,
             rDest->right, rDest->top, rDest->bottom));
    
    ASSERTDD(prclClip != NULL, "Wrong clippng rectangle");

    //
    // Note: the scale factor register value: dsDx, dTdyDom's interger part
    // starts at bit 20. So we need to "<< 20" here
    //
    lXScale = (dwSourceWidth << 20) / dwDestWidth;
    lYScale = (dwSourceHeight << 20) / dwDestHeight;
//    lXScale = (((dwSourceWidth << 18) - 1) / dwDestWidth) << 2;
//    lYScale = (((dwSourceHeight << 18) - 1) / dwDestHeight) << 2;
    DBG_GDI((6, "lXScale=0x%x, lYScale=0x%x", lXScale, lYScale));
    DBG_GDI((6, "dwSourceWidth=%d, dwDestWidth=%d",
             dwSourceWidth, dwDestWidth));
    DBG_GDI((6, "dwSourceHeight=%d, dwDestHeight=%d",
             dwSourceHeight, dwDestHeight));
    
    InputBufferReserve(ppdev, 24, &pBuffer);

    pBuffer[0] = __Permedia2TagScissorMinXY;
    pBuffer[1] = ((prclClip->left)<< SCISSOR_XOFFSET)
                |((prclClip->top)<< SCISSOR_YOFFSET);
    pBuffer[2] = __Permedia2TagScissorMaxXY;
    pBuffer[3] = ((prclClip->right)<< SCISSOR_XOFFSET)
                |((prclClip->bottom)<< SCISSOR_YOFFSET);

    //
    // We need to be carefull with overlapping rectangles
    //
    if ( (pSurfSrc->ulPixOffset) != (pSurfDst->ulPixOffset) )
    {
        //
        // Src and dst are differnt surface
        //
        dwRenderDirection = 1;
    }
    else
    {
        //
        // Src and dst are the same surface
        // We will set dwRenderDirection=1 if the src is lower or righter
        // than the dst, that is, if it is bottom-up or right-left, we set
        // dwRenderDirection=1, otherwise it = 0
        //
        if ( rSrc->top < rDest->top )
        {
            dwRenderDirection = 0;
        }
        else if ( rSrc->top > rDest->top )
        {
            dwRenderDirection = 1;
        }
        else if ( rSrc->left < rDest->left )
        {
            dwRenderDirection = 0;
        }
        else
        {
            dwRenderDirection = 1;
        }
    }// src and dst are different

    DBG_GDI((6, "dwRenderDirection=%d", dwRenderDirection));

    //
    // Render the rectangle
    //
    if ( dwRenderDirection )
    {
        pBuffer[4] = __Permedia2TagSStart;
        pBuffer[5] = (rSrc->left << 20) + ((lXScale >> 1) & 0xfffffffc);
        pBuffer[6] = __Permedia2TagTStart;
        pBuffer[7] = (rSrc->top << 20) + ((lYScale >> 1) & 0xfffffffc);
        pBuffer[8] = __Permedia2TagdSdx;
        pBuffer[9] = lXScale;
        pBuffer[10] = __Permedia2TagdTdyDom;
        pBuffer[11] = lYScale;
        pBuffer[12] = __Permedia2TagStartXDom;
        pBuffer[13] = INTtoFIXED(rDest->left);
        pBuffer[14] = __Permedia2TagStartXSub;
        pBuffer[15] = INTtoFIXED(rDest->right);
        pBuffer[16] = __Permedia2TagStartY;
        pBuffer[17] = INTtoFIXED(rDest->top);
        pBuffer[18] = __Permedia2TagdY;
        pBuffer[19] = INTtoFIXED(1);
        pBuffer[20] = __Permedia2TagCount;
        pBuffer[21] = rDest->bottom - rDest->top;
        pBuffer[22] = __Permedia2TagRender;
        pBuffer[23] = __RENDER_TRAPEZOID_PRIMITIVE
                    | __RENDER_TEXTURED_PRIMITIVE;
    }
    else
    {
        //
        // Render right to left, bottom to top
        //
        pBuffer[4] = __Permedia2TagSStart;
        pBuffer[5] = (rSrc->right << 20) + ((lXScale >> 1)& 0xfffffffc);
        pBuffer[6] = __Permedia2TagTStart;
        pBuffer[7] = (rSrc->bottom << 20) - ((lYScale >> 1)& 0xfffffffc);
        
        lXScale = -lXScale;
        lYScale = -lYScale;

        pBuffer[8] = __Permedia2TagdSdx;
        pBuffer[9] = lXScale;
        pBuffer[10] = __Permedia2TagdTdyDom;
        pBuffer[11] = lYScale;
        pBuffer[12] = __Permedia2TagStartXDom;
        pBuffer[13] = INTtoFIXED(rDest->right);
        pBuffer[14] = __Permedia2TagStartXSub;
        pBuffer[15] = INTtoFIXED(rDest->left);
        pBuffer[16] = __Permedia2TagStartY;
        pBuffer[17] = INTtoFIXED(rDest->bottom - 1);
        pBuffer[18] = __Permedia2TagdY;
        pBuffer[19] = (DWORD)INTtoFIXED(-1);
        pBuffer[20] = __Permedia2TagCount;
        pBuffer[21] = rDest->bottom - rDest->top;
        pBuffer[22] = __Permedia2TagRender;    
        pBuffer[23] = __RENDER_TRAPEZOID_PRIMITIVE
                    | __RENDER_TEXTURED_PRIMITIVE;
    }

    pBuffer += 24;
    InputBufferCommit(ppdev, pBuffer);
    
    DBG_GDI((6, "vStretchBlt done"));
    return;
}// vStretchBlt()

//-----------------------------Public*Routine----------------------------------
//
// BOOL DrvStretchBlt
//
// DrvStretchBlt provides stretching bit-block transfer capabilities between any
// combination of device-managed and GDI-managed surfaces. This function enables
// the device driver to write to GDI bitmaps, especially when the driver can do
// halftoning. This function allows the same halftoning algorithm to be applied
// to GDI bitmaps and device surfaces.
//
// Parameters
//  psoDest-----Points to a SURFOBJ that identifies the surface on which to draw
//  psoSrc------Points to a SURFOBJ that defines the source for the bit-block
//              transfer operation. 
//  psoMask-----This optional parameter points to a surface that provides a mask
//              for the source. The mask is defined by a logic map, which is a
//              bitmap with 1 bit per pixel. 
//              The mask limits the area of the source that is copied. If this
//              parameter is specified, it has an implicit rop4 of 0xCCAA,
//              meaning the source should be copied wherever the mask is one,
//              but the destination should be left alone wherever the mask is
//              zero. 
//
//              When this parameter is null there is an implicit rop4 of 0xCCCC,
//              which means that the source should be copied everywhere in the
//              source rectangle. 
//
//              The mask will always be large enough to contain the relevant
//              source; tiling is unnecessary. 
//  pco---------Points to a CLIPOBJ that limits the area to be modified in the
//              destination. GDI services are provided to enumerate the clip
//              region as a set of rectangles. 
//              Whenever possible, GDI simplifies the clipping involved.
//              However, unlike DrvBitBlt, DrvStretchBlt can be called with a
//              single clipping rectangle. This prevents rounding errors in
//              clipping the output.
//  pxlo--------Points to a XLATEOBJ that specifies how color indices are to be
//              translated between the source and target surfaces. 
//              The XLATEOBJ can also be queried to find the RGB color for any
//              source index. A high quality stretching bit-block transfer will
//              need to interpolate colors in some cases. 
//  pca---------Points to a COLORADJUSTMENT structure that defines the color
//              adjustment values to be applied to the source bitmap before
//              stretching the bits. (See the Platform SDK.) 
//  pptlHTOrg---Specifies the origin of the halftone brush. Device drivers that
//              use halftone brushes should align the upper left pixel of the
//              brush's pattern with this point on the device surface. 
//  prclDest----Points to a RECTL structure that defines the area to be modified
//              in the coordinate system of the destination surface. This
//              rectangle is defined by two points that are not necessarily well
//              ordered, meaning the coordinates of the second point are not
//              necessarily larger than those of the first point. The rectangle
//              they describe does not include the lower and right edges. This
//              function is never called with an empty destination rectangle.
//
//              DrvStretchBlt can do inversions of x and y when the destination
//              rectangle is not well ordered. 
//  prclSrc-----Points to a RECTL that defines the area that will be copied in
//              the coordinate system of the source surface. The rectangle is
//              defined by two points, and will map onto the rectangle defined
//              by prclDest. The points of the source rectangle are well ordered
//              This function is never given an empty source rectangle.
//
//              The mapping is defined by prclSrc and prclDest. The points
//              specified in prclDest and prclSrc lie on integer coordinates,
//              which correspond to pixel centers. A rectangle defined by two
//              such points is considered to be a geometric rectangle with two
//              vertices whose coordinates are the given points, but with 0.5
//              subtracted from each coordinate. (POINTL structures should be
//              considered a shorthand notation for specifying these fractional
//              coordinate vertices.) 
//
//              The edges of any rectangle never intersect a pixel, but go
//              around a set of pixels. The pixels inside the rectangle are
//              those expected for a "bottom-right exclusive" rectangle.
//              DrvStretchBlt will map the geometric source rectangle exactly
//              onto the geometric destination rectangle. 
//  pptlMask----Points to a POINTL structure that specifies which pixel in the
//              given mask corresponds to the upper left pixel in the source
//              rectangle. Ignore this parameter if no mask is specified. 
//  iMode-------Specifies how source pixels are combined to get output pixels.
//              The HALFTONE mode is slower than the other modes, but produces
//              higher quality images.
//                      Value               Meaning 
//                  WHITEONBLACK    On a shrinking bit-block transfer, pixels
//                                  should be combined with a Boolean OR
//                                  operation. On a stretching bit-block
//                                  transfer, pixels should be replicated. 
//                  BLACKONWHITE    On a shrinking bit-block transfer, pixels
//                                  should be combined with a Boolean AND
//                                  operation. On a stretching bit-block
//                                  transfer, pixels should be replicated.
//                  COLORONCOLOR    On a shrinking bit-block transfer, enough
//                                  pixels should be ignored so that pixels
//                                  don't need to be combined. On a stretching
//                                  bit-block transfer, pixels should be
//                                  replicated. 
//                  HALFTONE        The driver can use groups of pixels in the
//                                  output surface to best approximate the color
//                                  or gray level of the input.
//
// Return Value
//  The return value is TRUE if the function is successful. Otherwise, it is
//  FALSE, and an error code is logged.
//
// Comments
//  This function can be provided to handle only certain forms of stretching,
//  such as by integer multiples. If the driver has hooked the call and is asked
//  to perform an operation it does not support, the driver should forward the
//  data to EngStretchBlt for GDI to handle.
//
//  If the driver wants GDI to handle halftoning, and wants to ensure the proper
//  iMode value, the driver can hook DrvStretchBlt, set iMode to HALFTONE, and
//  call back to GDI with EngStretchBlt with the set iMode value.
//
//  DrvStretchBlt is optional for display drivers.
//
//-----------------------------------------------------------------------------
BOOL
DrvStretchBlt(SURFOBJ*            psoDst,
              SURFOBJ*            psoSrc,
              SURFOBJ*            psoMsk,
              CLIPOBJ*            pco,
              XLATEOBJ*           pxlo,
              COLORADJUSTMENT*    pca,
              POINTL*             pptlHTOrg,
              RECTL*              prclDst,
              RECTL*              prclSrc,
              POINTL*             pptlMsk,
              ULONG               iMode)
{
    Surf*       pSurfSrc = (Surf*)psoSrc->dhsurf;
    Surf*       pSurfDst = (Surf*)psoDst->dhsurf;
    PDev*       ppdev = (PDev*)psoDst->dhpdev;
    BYTE	iDComplexity;
    RECTL*      prclClip;
    ULONG       cxDst;
    ULONG       cyDst;
    ULONG       cxSrc;
    ULONG       cySrc;
    BOOL        bMore;
    ClipEnum    ceInfo;
    LONG        lNumOfIntersections;
    LONG        i;

    DBG_GDI((6, "DrvStretchBlt called with iMode = %d", iMode));
    
    if (iMode != COLORONCOLOR)
    {
        DBG_GDI((6, "Punt because iMode != COLORONCOLOR"));
        goto Punt_It;
    }

    vCheckGdiContext(ppdev);
    
    //
    // GDI guarantees us that for a StretchBlt the destination surface
    // will always be in video memory, not in system memory
    //
    ASSERTDD(pSurfDst->flags & SF_VM, "Dest surface is not in video memory");

    //
    // If the source is not a driver created surface or currently not sit
    // in the video memory, we just punt it back because GDI doing it will
    // be faster
    //
    if ( (!pSurfSrc) || (pSurfSrc->flags & SF_SM) )
    {
        DBG_GDI((6, "Punt because source = 0x%x or in sys memory", pSurfSrc));
        goto Punt_It;
    }

    //
    // We don't do the stretch blt if the mask is not NULL or the translate is
    // not trivial. We also don't do it if the source and current screen has
    // different color depth
    //
    if ( (psoMsk == NULL)
       &&((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
       &&((psoSrc->iBitmapFormat == ppdev->iBitmapFormat)) )
    {
        cxDst = prclDst->right - prclDst->left;
        cyDst = prclDst->bottom - prclDst->top;
        cxSrc = prclSrc->right - prclSrc->left;
        cySrc = prclSrc->bottom - prclSrc->top;

        //
        // Our 'vStretchDIB' routine requires that the stretch be
        // non-inverting, within a certain size, to have no source
        // clipping, and to have no empty rectangles (the latter is the
        // reason for the '- 1' on the unsigned compare here):
        //
        if ( ((cxSrc - 1) < STRETCH_MAX_EXTENT)
           &&((cySrc - 1) < STRETCH_MAX_EXTENT)
           &&((cxDst - 1) < STRETCH_MAX_EXTENT)
           &&((cyDst - 1) < STRETCH_MAX_EXTENT)
           &&(prclSrc->left   >= 0)
           &&(prclSrc->top    >= 0)
           &&(prclSrc->right  <= psoSrc->sizlBitmap.cx)
           &&(prclSrc->bottom <= psoSrc->sizlBitmap.cy))
        {
            if ( !bStretchInit(psoDst, psoSrc) )
            {
                goto Punt_It;
            }

	    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

            if ( (iDComplexity == DC_TRIVIAL) || (iDComplexity == DC_RECT) )
            {
                if (iDComplexity == DC_TRIVIAL) {
		    DBG_GDI((7, "Trivial clipping"));

		    // If there is no clipping, we just set the clipping area
		    // as the maximum
		    prclClip = &grclStretchClipMax;

		    ASSERTDD(((prclClip->right >= prclDst->right) &&
			      (prclClip->bottom >= prclDst->bottom)), "Dest surface is larger than P2 can handle");
		}
		else
		{
		    DBG_GDI((7, "DC_RECT clipping"));
		    prclClip = &pco->rclBounds;
		}

                vStretchBlt(psoDst,
                            psoSrc,
                            prclDst,
                            prclSrc,
                            prclClip);

            }
            else
            {
                DBG_GDI((7, "Complex clipping"));
                CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

                //
                // Enumerate all the clip rectangles
                //
                do
                {
                    //
                    // Get one clip rectangle
                    //
                    bMore = CLIPOBJ_bEnum(pco, sizeof(ceInfo),
                                          (ULONG*)&ceInfo);

                    //
                    // Get the intersect region with the dest rectangle
                    //
                    lNumOfIntersections = cIntersect(prclDst, ceInfo.arcl,
                                                     ceInfo.c);

                    //
                    // If there is clipping, then we do stretch region
                    // by region
                    //
                    if ( lNumOfIntersections != 0 )
                    {
                        for ( i = 0; i < lNumOfIntersections; ++i )
                        {
                            vStretchBlt(psoDst,
                                        psoSrc,
                                        prclDst,
                                        prclSrc,
                                        &ceInfo.arcl[i]);
                        }
                    }
                } while (bMore);

            }// Non-DC rect clipping

            DBG_GDI((6, "DrvStretchBlt return TRUE"));
            
            // Cleanup stretch settings
            vStretchReset(ppdev);
            InputBufferFlush(ppdev);
            
            return TRUE;
        
        }// source/dest withnin range
    }// No mask, trivial xlate, same BMP format

Punt_It:
    DBG_GDI((6, "DrvStretchBlt punt"));
    return(EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca,
                         pptlHTOrg, prclDst, prclSrc, pptlMsk, iMode));
}// DrvStretchBlt()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\strips.c ===
/**********************************Module*Header*******************************\
*  Module Name: Strips.c
* 
*  Hardware line drawing support routines
* 
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\******************************************************************************/
#include "precomp.h"
#include "gdi.h"

#define STRIP_LOG_LEVEL 6

//-----------------------------------------------------------------------------
//
//  BOOL bInitializeStrips
// 
//  Setup hardware for sucessive calls to strips functions.
// 
//-----------------------------------------------------------------------------
BOOL
bInitializeStrips(PDev*       ppdev,
                  ULONG       ulSolidColor, // Solid color fill
                  DWORD       dwLogicOp,    // Logical Operation to perform
                  RECTL*      prclClip)     // Clip region (Or NULL if no clip)
{
    DWORD       dwColorReg;
    BOOL        bRC = FALSE;
    Surf*       psurfDst = ppdev->psurf;
    ULONG*      pBuffer;

    PERMEDIA_DECL;

    DBG_GDI((STRIP_LOG_LEVEL + 1, "bInitializeStrips"));
    
    InputBufferReserve(ppdev, 16, &pBuffer);

    pBuffer[0] = __Permedia2TagFBWindowBase;
    pBuffer[1] =  psurfDst->ulPixOffset;

    pBuffer += 2;

    if ( dwLogicOp == K_LOGICOP_COPY )
    {
        dwColorReg = __Permedia2TagFBWriteData;

        pBuffer[0] = __Permedia2TagLogicalOpMode;
        pBuffer[1] =  __PERMEDIA_CONSTANT_FB_WRITE;
        pBuffer[2] = __Permedia2TagFBReadMode;
        pBuffer[3] =  PM_FBREADMODE_PARTIAL(psurfDst->ulPackedPP)
                   | PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE);

        pBuffer += 4;
    }
    else
    {
        DWORD   dwReadMode;
//@@BEGIN_DDKSPLIT
        //
        // TODO: look into what the heck is going on here
        //       for now, I'll remove the code because it is not clear to
        //       me that it will work
//@@END_DDKSPLIT
        // Special case for 3DS Max when page flipping. Max uses an XOR'ed GDI
        // line within the 3d window. When pageflipping we double write GDI and
        // so always write to buffer 0. We need to make sure the frame buffer
        // read happens from the currently displayed buffer.
        //
        dwColorReg = __Permedia2TagConstantColor;
        dwReadMode = psurfDst->ulPackedPP | LogicopReadDest[dwLogicOp];

        pBuffer[0] = __Permedia2TagColorDDAMode;
        pBuffer[1] =  __COLOR_DDA_FLAT_SHADE;
        pBuffer[2] = __Permedia2TagLogicalOpMode;
        pBuffer[3] =  P2_ENABLED_LOGICALOP(dwLogicOp);
        pBuffer[4] = __Permedia2TagFBReadMode;
        pBuffer[5] =  dwReadMode;

        pBuffer += 6;

        //
        // We have changed the DDA Mode setting so we must return TRUE so we can
        // re-set it later.
        //
        bRC = TRUE;
    }

    pBuffer[0] = dwColorReg;
    pBuffer[1] = ulSolidColor;

    pBuffer += 2;

    if ( prclClip )
    {
        pBuffer[0] = __Permedia2TagScissorMode;
        pBuffer[1] = SCREEN_SCISSOR_DEFAULT | USER_SCISSOR_ENABLE;
        pBuffer[2] =__Permedia2TagScissorMinXY;
        pBuffer[3] = ((prclClip->left) << SCISSOR_XOFFSET)
                   | ((prclClip->top) << SCISSOR_YOFFSET);
        pBuffer[4] =__Permedia2TagScissorMaxXY;
        pBuffer[5] = ((prclClip->right) << SCISSOR_XOFFSET)
                   | ((prclClip->bottom) << SCISSOR_YOFFSET);

        pBuffer += 6;
        //
        // Need to reset scissor mode
        //
        bRC = TRUE;
    }
                     
    InputBufferCommit(ppdev, pBuffer);

    DBG_GDI((STRIP_LOG_LEVEL + 1, "bInitializeStrips done return %d", bRC));

    return(bRC);
}// bInitializeStrips()

//-----------------------------------------------------------------------------
//
//  VOID vResetStrips
// 
//  Resets the hardware to its default state
// 
//-----------------------------------------------------------------------------
VOID
vResetStrips(PDev* ppdev)
{
    ULONG*      pBuffer;

    DBG_GDI((STRIP_LOG_LEVEL + 1, "vResetStrips"));
    
    //
    // Reset hardware to default state
    //
    InputBufferReserve(ppdev, 4 , &pBuffer);

    pBuffer[0] = __Permedia2TagScissorMode;
    pBuffer[1] =  SCREEN_SCISSOR_DEFAULT;
    pBuffer[2] = __Permedia2TagColorDDAMode;
    pBuffer[3] =  __PERMEDIA_DISABLE;

    pBuffer += 4;

    InputBufferCommit(ppdev, pBuffer);

}// vResetStrips()

//-----------------------------------------------------------------------------
//
//  BOOL bFastIntegerLine
// 
//  Integer line drawing.
// 
//  Returns FALSE if the line can not be drawn due to hardware limitations
// 
//  NOTE: This algorithm is not completely compliant. Lines > 190 pixels long
//  may get some incorrect pixels plotted somewhere along the length.
//  If we detect these long lines then we fail the call.
//  NOTE: GLICAP_NT_CONFORMANT_LINES will always be set.
// 
//-----------------------------------------------------------------------------
BOOL
bFastIntegerLine(PDev*   ppdev,
                 LONG    X1,
                 LONG    Y1,
                 LONG    X2,
                 LONG    Y2)
{
    LONG dx, dy, adx, ady;
    LONG gdx, gdy, count;
    ULONG*      pBuffer;
    
    PERMEDIA_DECL;
    
    DBG_GDI((STRIP_LOG_LEVEL, "bFastIntegerLine"));

    //
    // Convert points to INT format
    //
    X1 >>= 4;
    Y1 >>= 4;
    X2 >>= 4;
    Y2 >>= 4;

    //
    // Get deltas and absolute deltas
    //
    if ( (adx = dx = X2 - X1) < 0 )
    {
        adx = -adx;
    }

    if ( (ady = dy = Y2 - Y1) < 0 )
    {
        ady = -ady;
    }

    if ( adx > ady )
    {
        //
        // X Major line
        //
        gdx  = (dx > 0) ? INTtoFIXED(1) : INTtoFIXED(-1);

        if ( ady == 0 )
        {
            //
            // Horizontal lines
            //
            gdy = 0;
        }// if (ady == 0)
        else
        {
            //
            // We dont necessarily want to push any lines through Permedia2 that
            // might not be conformant
            //
            if ( (adx > MAX_LENGTH_CONFORMANT_INTEGER_LINES)
               &&(permediaInfo->flags & GLICAP_NT_CONFORMANT_LINES) )
            {
                return(FALSE);
            }

            gdy = INTtoFIXED(dy); 

            //
            // Need to explicitly round delta down for -ve deltas.
            //
            if ( dy < 0 )
            {
                gdy -= adx - 1;
            }

            gdy /= adx;
        }// if (ady != 0)
        count = adx;
    }// if ( adx > ady )
    else if ( adx < ady )
    {
        //
        // Y Major line
        //
        gdy  = (dy > 0) ? INTtoFIXED(1) : INTtoFIXED(-1);

        if ( adx == 0 )
        {
            //
            // Vertical lines
            //
            gdx = 0;
        }
        else
        {
            //
            // We dont necessarily want to push any lines through Permedia2 that
            // might not be conformant
            //
            if ( (ady > MAX_LENGTH_CONFORMANT_INTEGER_LINES)
               &&(permediaInfo->flags & GLICAP_NT_CONFORMANT_LINES) )
            {
                return(FALSE);
            }

            gdx = INTtoFIXED(dx); 

            //
            // Need to explicitly round delta down for -ve deltas.
            //
            if ( dx < 0 )
            {
                gdx -= ady - 1;
            }

            gdx /= ady; 
        }
        count = ady;
    }// if ( adx < ady )
    else
    {
        //
        // Special case for 45 degree lines. These are always conformant.
        //
        gdx  = (dx > 0) ? INTtoFIXED(1) : INTtoFIXED(-1);
        gdy  = (dy > 0) ? INTtoFIXED(1) : INTtoFIXED(-1);
        count = adx;        
    }

    InputBufferReserve(ppdev, 16, &pBuffer);

    //
    // Set up the start point
    //
    pBuffer[0] = __Permedia2TagStartXDom;
    pBuffer[1] =  INTtoFIXED(X1) + NEARLY_HALF;
    pBuffer[2] = __Permedia2TagStartY;
    pBuffer[3] =  INTtoFIXED(Y1) + NEARLY_HALF;
    pBuffer[4] = __Permedia2TagdXDom;
    pBuffer[5] =  gdx;
    pBuffer[6] = __Permedia2TagdY;
    pBuffer[7] =  gdy;
    pBuffer[8] = __Permedia2TagCount;
    pBuffer[9] =  count;
    pBuffer[10] = __Permedia2TagRender;
    pBuffer[11] =  __RENDER_LINE_PRIMITIVE;
    
    pBuffer[12] = __Permedia2TagdXDom;
    pBuffer[13] =  0;
    pBuffer[14] = __Permedia2TagdY;
    pBuffer[15] =  INTtoFIXED(1);

    pBuffer += 16;

    InputBufferCommit(ppdev, pBuffer);

    DBG_GDI((STRIP_LOG_LEVEL + 1, "bFastIntegerLine Done"));

    return(TRUE);
}// bFastIntegerLine()

//-----------------------------------------------------------------------------
//
//  BOOL bFastIntegerContinueLine
// 
//  Integer line drawing through Permedia2.
// 
//  Returns FALSE if the line can not be drawn due to hardware limitations.
// 
//  NOTE: This algorithm is not completely compliant. Lines > 190 pixels long
//  may get some incorrect pixels plotted somewhere along the length.
//  If we detect these long lines then we fail the call.
//  NOTE: GLICAP_NT_CONFORMANT_LINES will always be set.
// 
//-----------------------------------------------------------------------------
BOOL
bFastIntegerContinueLine(PDev*   ppdev,
                         LONG    X1,
                         LONG    Y1,
                         LONG    X2,
                         LONG    Y2)
{
    LONG dx, dy, adx, ady;
    LONG gdx, gdy, count;
    ULONG*      pBuffer;
    
    PERMEDIA_DECL;
    
    DBG_GDI((STRIP_LOG_LEVEL + 1, "bFastIntegerContinueLine"));

    //
    // This assumes that the end point of the previous line is correct.
    // The Fraction adjust should be set to nearly a half to remove any
    // error from the end point of the previous line.
    // Get deltas and absolute deltas from 28.4 format
    //
    if ( (adx = dx = (X2 - X1) >> 4) < 0 )
    {
        adx = -adx;
    }
    if ( (ady = dy = (Y2 - Y1) >> 4) < 0 )
    {
        ady = -ady;
    }

    if ( adx > ady )
    {
        //
        // X Major line
        //
        gdx  = (dx > 0) ? INTtoFIXED(1) : INTtoFIXED(-1);

        if (ady == 0)
        {
            //
            // Horizontal lines
            //
            gdy = 0;
        }
        else
        {
            //
            // We dont necessarily want to push any lines through Permedia2 that
            // might not be conformant
            //
            if ( (adx > MAX_LENGTH_CONFORMANT_INTEGER_LINES)
               &&(permediaInfo->flags & GLICAP_NT_CONFORMANT_LINES) )
            {
                return(FALSE);
            }
            gdy = INTtoFIXED(dy); 

            //
            // Need to explicitly round delta down for -ve deltas.
            //
            if ( dy < 0 )
            {
                gdy -= adx - 1;
            }

            gdy /= adx;
        }
        count = adx;
    }// if ( adx > ady )
    else if (adx < ady)
    {
        //
        // Y Major line
        //
        gdy = (dy > 0) ? INTtoFIXED(1) : INTtoFIXED(-1);

        if ( adx == 0 )
        {
            //
            // Vertical lines
            //
            gdx = 0;
        }
        else
        {
            //
            // We dont necessarily want to push any lines through Permedia2 that
            // might not be conformant
            //
            if ( (ady > MAX_LENGTH_CONFORMANT_INTEGER_LINES)
               &&(permediaInfo->flags & GLICAP_NT_CONFORMANT_LINES) )
            {
                return(FALSE);
            }

            gdx = INTtoFIXED(dx); 

            //
            // Need to explicitly round delta down for -ve deltas.
            //
            if ( dx < 0 )
            {
                gdx -= ady - 1;
            }

            gdx /= ady; 
        }
        count = ady;
    }
    else
    {
        //
        // Special case for 45 degree lines. These are always conformant.
        //
        if ( ady == 0 )
        {
            return(TRUE); // adx == ady == 0! Nothing to draw.
        }

        gdx  = (dx > 0) ? INTtoFIXED(1) : INTtoFIXED(-1);
        gdy  = (dy > 0) ? INTtoFIXED(1) : INTtoFIXED(-1);
        count = adx;        
    }

    InputBufferReserve(ppdev, 10 , &pBuffer);
    
    //
    // Set up the start point
    //
    DBG_GDI((7, "Loading dXDom 0x%x, dY 0x%x, count 0x%x", gdx, gdy, count));
    
    pBuffer[0] = __Permedia2TagdXDom;
    pBuffer[1] =  gdx;
    pBuffer[2] = __Permedia2TagdY;
    pBuffer[3] =  gdy;
    pBuffer[4] = __Permedia2TagContinueNewLine;
    pBuffer[5] =  count;

    //
    // Restore dXDom and dY to their defaults
    //
    pBuffer[6] = __Permedia2TagdXDom;
    pBuffer[7] =  0;
    pBuffer[8] = __Permedia2TagdY;
    pBuffer[9] =  INTtoFIXED(1);

    pBuffer += 10;

    InputBufferCommit(ppdev, pBuffer);

    DBG_GDI((STRIP_LOG_LEVEL + 1, "bFastIntegerContinueLine Done"));

    return(TRUE);
}// bFastIntegerContinueLine()

//-----------------------------------------------------------------------------
//
//  VOID vSolidHorizontal
// 
//  Draws left-to-right x-major near-horizontal lines using short-stroke
//  vectors.  
// 
//-----------------------------------------------------------------------------
VOID
vSolidHorizontalLine(PDev*       ppdev,
                     STRIP*      pStrip,
                     LINESTATE*  pLineState)
{
    LONG    cStrips;
    PLONG   pStrips;
    LONG    iCurrent;
    ULONG*      pBuffer;
    
    PERMEDIA_DECL;
    
    DBG_GDI((STRIP_LOG_LEVEL, "vSolidHorizontalLine"));

    cStrips = pStrip->cStrips;

    InputBufferReserve(ppdev, 16, &pBuffer);

    //
    // Set up the start point
    //
    pBuffer[0] = __Permedia2TagStartXDom;
    pBuffer[1] =  INTtoFIXED(pStrip->ptlStart.x);
    pBuffer[2] = __Permedia2TagStartY;
    pBuffer[3] =  INTtoFIXED(pStrip->ptlStart.y);

    //
    // Set up the deltas for rectangle drawing. Also set Y return value.
    //
    if ( !(pStrip->flFlips & FL_FLIP_V) )
    {

        pBuffer[4] = __Permedia2TagdXDom;
        pBuffer[5] =  INTtoFIXED(0);
        pBuffer[6] = __Permedia2TagdXSub;
        pBuffer[7] =  INTtoFIXED(0);
        pBuffer[8] = __Permedia2TagdY;
        pBuffer[9] =  INTtoFIXED(1);

        pStrip->ptlStart.y += cStrips;
    }
    else
    {
        pBuffer[4] = __Permedia2TagdXDom;
        pBuffer[5] =  INTtoFIXED(0);
        pBuffer[6] = __Permedia2TagdXSub;
        pBuffer[7] =  INTtoFIXED(0);
        pBuffer[8] = __Permedia2TagdY;
        pBuffer[9] =  INTtoFIXED(-1);

        pStrip->ptlStart.y -= cStrips;
    }

    pStrips = pStrip->alStrips;

    //
    // We have to do first strip manually, as we have to use RENDER
    // for the first strip, and CONTINUENEW... for the following strips
    //
    iCurrent = pStrip->ptlStart.x + *pStrips++;     // Xsub, Start of next strip
    
    pBuffer[10] = __Permedia2TagStartXSub;
    pBuffer[11] =  INTtoFIXED(iCurrent);
    pBuffer[12] = __Permedia2TagCount;
    pBuffer[13] =  1;                   // Rectangle 1 scanline high
    pBuffer[14] = __Permedia2TagRender;
    pBuffer[15] =  __RENDER_TRAPEZOID_PRIMITIVE;

    pBuffer += 16;

    InputBufferCommit(ppdev, pBuffer);

    if ( --cStrips )
    {
        while ( cStrips > 1 )
        {
            //
            // First strip of each pair to fill. XSub is valid. Need new Xdom
            //
            iCurrent += *pStrips++;
            
            InputBufferReserve(ppdev, 8, &pBuffer);
            pBuffer[0] = __Permedia2TagStartXDom;
            pBuffer[1] =  INTtoFIXED(iCurrent);
            pBuffer[2] = __Permedia2TagContinueNewDom;
            pBuffer[3] =  1;

            //
            // Second strip of each pair to fill. XDom is valid. Need new XSub
            //
            iCurrent += *pStrips++;
            pBuffer[4] = __Permedia2TagStartXSub;
            pBuffer[5] =  INTtoFIXED(iCurrent);
            pBuffer[6] = __Permedia2TagContinueNewSub;
            pBuffer[7] =  1;

            pBuffer += 8;

            InputBufferCommit(ppdev, pBuffer);

            cStrips -=2;
        }// while ( cStrips > 1 )

        //
        // We may have one last line to draw. Xsub will be valid.
        //
        if ( cStrips )
        {
            iCurrent += *pStrips++;

            InputBufferReserve(ppdev, 4, &pBuffer);

            pBuffer[0] = __Permedia2TagStartXDom;
            pBuffer[1] =  INTtoFIXED(iCurrent);
            pBuffer[2] = __Permedia2TagContinueNewDom;
            pBuffer[3] =  1;

            pBuffer += 4;

            InputBufferCommit(ppdev, pBuffer);

        }
    }// if ( --cStrips )

    //
    // Return last point. Y already calculated when we knew the direction.
    //
    pStrip->ptlStart.x = iCurrent;

    if ( pStrip->flFlips & FL_FLIP_V )
    {
        //
        // Restore hardware to default state
        //
        InputBufferReserve(ppdev, 2, &pBuffer);

        pBuffer[0] = __Permedia2TagdY;
        pBuffer[1] =  INTtoFIXED(1);

        pBuffer += 2;

        InputBufferCommit(ppdev, pBuffer);
    }

}// vSolidHorizontalLine()

//-----------------------------------------------------------------------------
//
//  VOID vSolidVertical
// 
//  Draws left-to-right y-major near-vertical lines using short-stroke
//  vectors.  
// 
//-----------------------------------------------------------------------------
VOID
vSolidVerticalLine(PDev*       ppdev,
                   STRIP*      pStrip,
                   LINESTATE*  pLineState)
{
    LONG    cStrips, yDir;
    PLONG   pStrips;
    LONG    iCurrent, iLen, iLenSum;
    ULONG*      pBuffer;
    
    PERMEDIA_DECL;
    
    DBG_GDI((STRIP_LOG_LEVEL, "vSolidVerticalLine"));

    cStrips = pStrip->cStrips;

    InputBufferReserve(ppdev, 16, &pBuffer);
    
    //
    // Set up the start point
    //
    pBuffer[0] = __Permedia2TagStartXDom;
    pBuffer[1] =  INTtoFIXED(pStrip->ptlStart.x);
    pBuffer[2] = __Permedia2TagStartY;
    pBuffer[3] =  INTtoFIXED(pStrip->ptlStart.y);
    pBuffer[4] = __Permedia2TagdXDom;
    pBuffer[5] =  INTtoFIXED(0);
    pBuffer[6] = __Permedia2TagdXSub;
    pBuffer[7] =  INTtoFIXED(0);

    //
    // Set up the deltas for rectangle drawing.
    // dxDom, dXSub and dY all are to 0, 0, and 1 by default 
    //
    if ( !(pStrip->flFlips & FL_FLIP_V) )
    {
        yDir = 1;
    }
    else
    {
        yDir = -1;
    }
    pBuffer[8] = __Permedia2TagdY;
    pBuffer[9] =  INTtoFIXED(yDir);

    pStrips = pStrip->alStrips;

    //
    // We have to do first strip manually, as we have to use RENDER
    // for the first strip, and CONTINUENEW... for the following strips
    //
    iCurrent = pStrip->ptlStart.x + 1;          // Xsub, Start of next strip
    iLenSum = (iLen = *pStrips++);
    pBuffer[10] = __Permedia2TagStartXSub;
    pBuffer[11] =  INTtoFIXED(iCurrent);
    pBuffer[12] = __Permedia2TagCount;
    pBuffer[13] =  iLen;           // Rectangle 1 scanline high
    pBuffer[14] = __Permedia2TagRender;
    pBuffer[15] =  __RENDER_TRAPEZOID_PRIMITIVE;

    pBuffer += 16;

    InputBufferCommit(ppdev, pBuffer);

    if ( --cStrips )
    {
        while ( cStrips > 1 )
        {
            //
            // First strip of each pair to fill. XSub is valid. Need new Xdom
            //
            iCurrent++;

            InputBufferReserve(ppdev, 8, &pBuffer);
            
            pBuffer[0] = __Permedia2TagStartXDom;
            pBuffer[1] =  INTtoFIXED(iCurrent);

            iLenSum += (iLen = *pStrips++);
            pBuffer[2] = __Permedia2TagContinueNewDom;
            pBuffer[3] =  iLen;

            //
            // Second strip of each pair to fill. XDom is valid. Need new XSub
            //
            iCurrent ++;
            pBuffer[4] = __Permedia2TagStartXSub;
            pBuffer[5] =  INTtoFIXED(iCurrent);
            iLenSum += (iLen = *pStrips++);
            pBuffer[6] = __Permedia2TagContinueNewSub;
            pBuffer[7] =  iLen;

            pBuffer += 8;

            InputBufferCommit(ppdev, pBuffer);

            cStrips -=2;
        }// while ( cStrips > 1 )

        //
        // We may have one last line to draw. Xsub will be valid.
        //
        if ( cStrips )
        {
            iCurrent ++;
            InputBufferReserve(ppdev, 4, &pBuffer);

            pBuffer[0] = __Permedia2TagStartXDom;
            pBuffer[1] =  INTtoFIXED(iCurrent);
            
            iLenSum += (iLen = *pStrips++);
            pBuffer[2] = __Permedia2TagContinueNewDom;
            pBuffer[3] =  iLen;

            pBuffer += 4;

            InputBufferCommit(ppdev, pBuffer);
        }
    }// if ( --cStrips )

    //
    // Restore hardware to default
    //
    InputBufferReserve(ppdev, 2, &pBuffer);
    
    pBuffer[0] = __Permedia2TagdY;
    pBuffer[1] =  INTtoFIXED(1);
    
    pBuffer += 2;
    
    InputBufferCommit(ppdev, pBuffer);


    //
    // Return last point. 
    //
    pStrip->ptlStart.x = iCurrent;
    pStrip->ptlStart.y += iLenSum * yDir;
    
    DBG_GDI((STRIP_LOG_LEVEL + 1, "vSolidVerticalLine done"));

}// vSolidVerticalLine()

//-----------------------------------------------------------------------------
//
//  VOID vSolidDiagonalVertical
// 
//  Draws left-to-right y-major near-diagonal lines using short-stroke
//  vectors.  
// 
//-----------------------------------------------------------------------------
VOID
vSolidDiagonalVerticalLine(PDev*       ppdev,
                           STRIP*      pStrip,
                           LINESTATE*  pLineState)
{
    LONG    cStrips, yDir;
    PLONG   pStrips;
    LONG    iCurrent, iLen, iLenSum;
    ULONG*  pBuffer;
    
    PERMEDIA_DECL;
    
    DBG_GDI((STRIP_LOG_LEVEL, "vSolidDiagonalVerticalLine"));

    cStrips = pStrip->cStrips;

    if ( !(pStrip->flFlips & FL_FLIP_V) )
    {
        yDir = 1;
    }
    else
    {
        yDir = -1;
    }

    InputBufferReserve(ppdev, 16, &pBuffer);

    //
    // Set up the deltas for rectangle drawing.
    //
    pBuffer[0] = __Permedia2TagdXDom;
    pBuffer[1] =  INTtoFIXED(1);
    pBuffer[2] = __Permedia2TagdXSub;
    pBuffer[3] =  INTtoFIXED(1);
    pBuffer[4] = __Permedia2TagdY;
    pBuffer[5] =  INTtoFIXED(yDir);

    pStrips = pStrip->alStrips;

    //
    // We have to do first strip manually, as we have to use RENDER
    // for the first strip, and CONTINUENEW... for the following strips
    //
    pBuffer[6] = __Permedia2TagStartY;
    pBuffer[7] =  INTtoFIXED(pStrip->ptlStart.y);
    pBuffer[8] = __Permedia2TagStartXDom;
    pBuffer[9] =  INTtoFIXED(pStrip->ptlStart.x + 1);
    pBuffer[10] = __Permedia2TagStartXSub;
    pBuffer[11] =  INTtoFIXED(pStrip->ptlStart.x);

    iLenSum = (iLen = *pStrips++);
    iCurrent = pStrip->ptlStart.x + iLen - 1;// Start of next strip

    pBuffer[12] = __Permedia2TagCount;
    pBuffer[13] =  iLen;           // Trap iLen scanline high
    pBuffer[14] = __Permedia2TagRender;
    pBuffer[15] =  __RENDER_TRAPEZOID_PRIMITIVE;

    pBuffer += 16;

    InputBufferCommit(ppdev, pBuffer);

    if ( --cStrips )
    {
        while ( cStrips > 1 )
        {
            //
            // First strip of each pair to fill. XSub is valid. Need new Xdom
            //
            InputBufferReserve(ppdev, 8, &pBuffer);

            pBuffer[0] = __Permedia2TagStartXDom;
            pBuffer[1] =  INTtoFIXED(iCurrent);
            iLenSum += (iLen = *pStrips++);
            iCurrent += iLen - 1;
            pBuffer[2] = __Permedia2TagContinueNewDom;
            pBuffer[3] =  iLen;

            //
            // Second strip of each pair to fill. XDom is valid. Need new XSub
            //
            pBuffer[4] = __Permedia2TagStartXSub;
            pBuffer[5] =  INTtoFIXED(iCurrent);
            iLenSum += (iLen = *pStrips++);
            iCurrent += iLen - 1;
            pBuffer[6] = __Permedia2TagContinueNewSub;
            pBuffer[7] =  iLen;

            pBuffer += 8;

            InputBufferCommit(ppdev, pBuffer);

            cStrips -=2;
        }// while ( cStrips > 1 )

        //
        // We may have one last line to draw. Xsub will be valid.
        //
        if ( cStrips )
        {
            InputBufferReserve(ppdev, 4, &pBuffer);
            pBuffer[0] = __Permedia2TagStartXDom;
            pBuffer[1] =  INTtoFIXED(iCurrent);
            iLenSum += (iLen = *pStrips++);
            iCurrent += iLen - 1;
            pBuffer[2] = __Permedia2TagContinueNewDom;
            pBuffer[3] =  iLen;

            pBuffer += 4;

            InputBufferCommit(ppdev, pBuffer);
        }
    }// if ( --cStrips )

    InputBufferReserve(ppdev, 6, &pBuffer);

    pBuffer[0] = __Permedia2TagdXDom;
    pBuffer[1] =  0;
    pBuffer[2] = __Permedia2TagdXSub;
    pBuffer[3] =  0;
    pBuffer[4] = __Permedia2TagdY;
    pBuffer[5] =  INTtoFIXED(1);

    pBuffer += 6;

    InputBufferCommit(ppdev, pBuffer);

    //
    // Return last point. 
    //
    pStrip->ptlStart.x = iCurrent;
    pStrip->ptlStart.y += iLenSum * yDir;
    
    DBG_GDI((STRIP_LOG_LEVEL + 1, "vSolidDiagonalVerticalLine done"));

}// vSolidDiagonalVerticalLine()

//-----------------------------------------------------------------------------
//
//  VOID vSolidDiagonalHorizontalLine
// 
//  Draws left-to-right x-major near-diagonal lines using short-stroke
//  vectors.  
// 
//-----------------------------------------------------------------------------
VOID
vSolidDiagonalHorizontalLine(PDev*       ppdev,
                             STRIP*      pStrip,
                             LINESTATE*  pLineState)
{
    LONG    cStrips, yDir, xCurrent, yCurrent, iLen;
    PLONG   pStrips;
    ULONG*      pBuffer;
    
    PERMEDIA_DECL;
    
    DBG_GDI((STRIP_LOG_LEVEL, "vSolidDiagonalHorizontalLine"));

    // This routine has to be implemented in a different way to the other 3
    // solid line drawing functions because the rasterizer unit will not 
    // produce 2 pixels on the same scanline without a lot of effort in 
    // producing delta values. In this case, we have to draw a complete new
    // primitive for each strip. Therefore, we have to use lines rather than
    // trapezoids to generate the required strips. With lines we use 4 messages
    // per strip, where trapezoids would use 5.

    cStrips = pStrip->cStrips;

    if ( !(pStrip->flFlips & FL_FLIP_V) )
    {
        yDir = 1;
    }
    else
    {
        yDir = -1;
    }

    pStrips = pStrip->alStrips;

    xCurrent = pStrip->ptlStart.x;
    yCurrent = pStrip->ptlStart.y;


    InputBufferReserve(ppdev, 6, &pBuffer);
    
    //
    // Set up the deltas for rectangle drawing.
    //
    pBuffer[0] = __Permedia2TagdXDom;
    pBuffer[1] =  INTtoFIXED(1);
    pBuffer[2] = __Permedia2TagdXSub;
    pBuffer[3] =  INTtoFIXED(1);
    pBuffer[4] = __Permedia2TagdY;
    pBuffer[5] =  INTtoFIXED(yDir);

    pBuffer += 6;

    InputBufferCommit(ppdev, pBuffer);

    while ( TRUE )
    {
        //
        // Set up the start point
        //
        InputBufferReserve(ppdev, 8, &pBuffer);

        pBuffer[0] = __Permedia2TagStartXDom;
        pBuffer[1] =  INTtoFIXED(xCurrent);
        pBuffer[2] = __Permedia2TagStartY;
        pBuffer[3] =  INTtoFIXED(yCurrent);

        iLen = *pStrips++;
        pBuffer[4] = __Permedia2TagCount;
        pBuffer[5] =  iLen;
        pBuffer[6] = __Permedia2TagRender;
        pBuffer[7] =  __RENDER_LINE_PRIMITIVE;

        pBuffer += 8;

        InputBufferCommit(ppdev, pBuffer);

        xCurrent += iLen;
        if ( yDir > 0 )
        {
            yCurrent += iLen - 1;
        }
        else
        {
            yCurrent -= iLen - 1;
        }

        if ( !(--cStrips) )
        {
            break;
        }
    }// while ( TRUE )

    InputBufferReserve(ppdev, 6, &pBuffer);
    pBuffer[0] = __Permedia2TagdXDom;
    pBuffer[1] =  0;
    pBuffer[2] = __Permedia2TagdXSub;
    pBuffer[3] =  0;
    pBuffer[4] = __Permedia2TagdY;
    pBuffer[5] =  INTtoFIXED(1);

    pBuffer += 6;

    InputBufferCommit(ppdev, pBuffer);

    //
    // Return last point. 
    //
    pStrip->ptlStart.x = xCurrent;
    pStrip->ptlStart.y = yCurrent;
    
    DBG_GDI((STRIP_LOG_LEVEL + 1, "vSolidDiagonalHorizontalLine done"));

}// vSolidDiagonalHorizontalLine()

//-----------------------------------------------------------------------------
//
// VOID vStyledHorizontalLine()
// 
// Takes the list of strips that define the pixels that would be lit for
// a solid line, and breaks them into styling chunks according to the
// styling information that is passed in.
// 
// This particular routine handles x-major lines that run left-to-right,
// and are comprised of horizontal strips.  It draws the dashes using
// short-stroke vectors.
// 
// The performance of this routine could be improved significantly.
//
// Parameters
//  ppdev-------PDEV pointer
//  pStrip------Strip info. Note: the data in the strip are already in normal
//              integer format, not 28.4 format
//  pLineState--Line state info
//
//-----------------------------------------------------------------------------
VOID
vStyledHorizontalLine(PDev*       ppdev,
                      STRIP*      pStrip,
                      LINESTATE*  pLineState)
{
    LONG    x;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    ULONG*      pBuffer;
    
    LONG    lStripLength;
    LONG    lTotalNumOfStrips;
    
    LONG    lNumPixelRemain;
    LONG    lCurrentLength;
    ULONG   bIsGap;
    
    PERMEDIA_DECL;

    DBG_GDI((STRIP_LOG_LEVEL, "vStyledHorizontalLine"));

    if ( pStrip->flFlips & FL_FLIP_V )
    {
        dy = -1;
    }
    else
    {
        dy = 1;
    }

    lTotalNumOfStrips = pStrip->cStrips;// Total number of strips we'll do
    plStrip = pStrip->alStrips;         // Points to current strip
    x = pStrip->ptlStart.x;             // x position of start of first strip
    y = pStrip->ptlStart.y;             // y position of start of first strip

    //
    // Set up the deltas for horizontal line drawing.
    //
    InputBufferReserve(ppdev, 4, &pBuffer);

    pBuffer[0] = __Permedia2TagdXDom;
    pBuffer[1] =  INTtoFIXED(1);
    pBuffer[2] = __Permedia2TagdY;
    pBuffer[3] =  0;
    
    pBuffer += 4;

    InputBufferCommit(ppdev, pBuffer);

    lStripLength = *plStrip;            // Number of pixels in first strip

    //
    // Number of pixels in first strip
    //
    lNumPixelRemain = pLineState->spRemaining;

    //
    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':
    //
    bIsGap = pLineState->ulStyleMask;
    if ( bIsGap )
    {
        //
        // A gap
        //
        goto SkipAGap;
    }
    else
    {
        //
        // A dash
        //
        goto OutputADash;
    }

PrepareToSkipAGap:

    //
    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:
    //
    bIsGap = ~bIsGap;
    pLineState->psp++;
    
    if ( pLineState->psp > pLineState->pspEnd )
    {
        pLineState->psp = pLineState->pspStart;
    }

    lNumPixelRemain = *pLineState->psp;

    //
    // If 'lStripLength' is zero, we also need a new strip:
    //
    if ( lStripLength != 0 )
    {
        goto SkipAGap;
    }

    //
    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':
    //
    while ( TRUE )
    {
        //
        // Each time we loop, we move to a new scan and need a new strip
        //
        y += dy;

        plStrip++;
        lTotalNumOfStrips--;
        
        if ( lTotalNumOfStrips == 0 )
        {
            goto AllDone;
        }

        lStripLength = *plStrip;

SkipAGap:

        lCurrentLength = min(lStripLength, lNumPixelRemain);
        lNumPixelRemain -= lCurrentLength;
        lStripLength -= lCurrentLength;

        x += lCurrentLength;

        if ( lNumPixelRemain == 0 )
        {
            goto PrepareToOutputADash;
        }
    }// while (TRUE)

PrepareToOutputADash:

    //
    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:
    //
    bIsGap = ~bIsGap;
    pLineState->psp++;
    
    if ( pLineState->psp > pLineState->pspEnd )
    {
        pLineState->psp = pLineState->pspStart;
    }

    lNumPixelRemain = *pLineState->psp;

    //
    // If 'lStripLength' is zero, we also need a new strip.
    //
    if ( lStripLength != 0 )
    {
        //
        // There's more to be done in the current strip, so set 'y'
        // to be the current scan:
        //
        goto OutputADash;
    }

    while ( TRUE )
    {
        //
        // Each time we loop, we move to a new scan and need a new strip:
        //
        y += dy;

        plStrip++;
        lTotalNumOfStrips--;
        
        if ( lTotalNumOfStrips == 0 )
        {
            goto AllDone;
        }

        lStripLength = *plStrip;

OutputADash:

        lCurrentLength   = min(lStripLength, lNumPixelRemain);
        lNumPixelRemain -= lCurrentLength;
        lStripLength -= lCurrentLength;

        //
        // With Permedia2 we just download the lines to draw
        //
        InputBufferReserve(ppdev, 8, &pBuffer);

        pBuffer[0] = __Permedia2TagStartXDom;
        pBuffer[1] =  INTtoFIXED(x);
        pBuffer[2] = __Permedia2TagStartY;
        pBuffer[3] =  INTtoFIXED(y);
        pBuffer[4] = __Permedia2TagCount;
        pBuffer[5] =  lCurrentLength;
        pBuffer[6] = __Permedia2TagRender;
        pBuffer[7] =  __PERMEDIA_LINE_PRIMITIVE;

        pBuffer += 8;

        InputBufferCommit(ppdev, pBuffer);

        x += lCurrentLength;

        if ( lNumPixelRemain == 0 )
        {
            goto PrepareToSkipAGap;
        }
    }// while ( TRUE )

AllDone:

    //
    // Restore default state
    //
    InputBufferReserve(ppdev, 4, &pBuffer);

    pBuffer[0] = __Permedia2TagdXDom;
    pBuffer[1] =  0;
    pBuffer[2] = __Permedia2TagdY;
    pBuffer[3] =  INTtoFIXED(1);

    pBuffer += 4;

    InputBufferCommit(ppdev, pBuffer);

    //
    // Update our state variables so that the next line can continue
    // where we left off:
    //
    pLineState->spRemaining   = lNumPixelRemain;
    pLineState->ulStyleMask   = bIsGap;
    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;
    
    DBG_GDI((STRIP_LOG_LEVEL + 1, "vStyledHorizontalLine done"));

}// vStyledHorizontalLine()

//-----------------------------------------------------------------------------
//
//  VOID vStripStyledVertical
// 
//  Takes the list of strips that define the pixels that would be lit for
//  a solid line, and breaks them into styling chunks according to the
//  styling information that is passed in.
// 
//  This particular routine handles y-major lines that run left-to-right,
//  and are comprised of vertical strips.  It draws the dashes using
//  short-stroke vectors.
// 
//  The performance of this routine could be improved significantly.
// 
//-----------------------------------------------------------------------------
VOID
vStyledVerticalLine(PDev*       ppdev,
                    STRIP*      pStrip,
                    LINESTATE*  pLineState)
{
    LONG    x;
    LONG    y;
    LONG    dy;
    LONG*   plStrip;
    LONG    cStrips;
    LONG    cStyle;
    LONG    cStrip;
    LONG    cThis;
    ULONG   bIsGap;
    ULONG*      pBuffer;
    
    PERMEDIA_DECL;
    
    DBG_GDI((STRIP_LOG_LEVEL, "vStyledVerticalLine"));
//@@BEGIN_DDKSPLIT
    //
    // TODO: improve the performance of this routine
    //
//@@END_DDKSPLIT
    if ( pStrip->flFlips & FL_FLIP_V )
    {
        dy = -1;
    }
    else
    {
        dy = 1;
    }

    cStrips = pStrip->cStrips;      // Total number of strips we'll do
    plStrip = pStrip->alStrips;     // Points to current strip
    x       = pStrip->ptlStart.x;   // x position of start of first strip
    y       = pStrip->ptlStart.y;   // y position of start of first strip

    //
    // Set up the deltas for vertical line drawing.
    //
    InputBufferReserve(ppdev, 6, &pBuffer);
    
    pBuffer[0] = __Permedia2TagdXDom;
    pBuffer[1] =  INTtoFIXED(0);
    pBuffer[2] = __Permedia2TagdXSub;
    pBuffer[3] =  INTtoFIXED(0);
    pBuffer[4] = __Permedia2TagdY;
    pBuffer[5] =  INTtoFIXED(dy);

    pBuffer += 6;

    InputBufferCommit(ppdev, pBuffer);

    cStrip = *plStrip;              // Number of pels in first strip

    cStyle = pLineState->spRemaining;      // Number of pels in first 'gap' or 'dash'
    bIsGap = pLineState->ulStyleMask;      // Tells whether in a 'gap' or a 'dash'

    // ulStyleMask is non-zero if we're in the middle of a 'gap',
    // and zero if we're in the middle of a 'dash':

    if ( bIsGap )
    {
        goto SkipAGap;
    }
    else
    {
        goto OutputADash;
    }

PrepareToSkipAGap:

    //
    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:
    //
    bIsGap = ~bIsGap;
    pLineState->psp++;
    
    if ( pLineState->psp > pLineState->pspEnd )
    {
        pLineState->psp = pLineState->pspStart;
    }

    cStyle = *pLineState->psp;

    //
    // If 'cStrip' is zero, we also need a new strip:
    //
    if ( cStrip != 0 )
    {
        goto SkipAGap;
    }

    //
    // Here, we're in the middle of a 'gap' where we don't have to
    // display anything.  We simply cycle through all the strips
    // we can, keeping track of the current position, until we run
    // out of 'gap':
    //
    while ( TRUE )
    {
        //
        // Each time we loop, we move to a new column and need a new strip:
        //
        x++;

        plStrip++;
        cStrips--;
        
        if ( cStrips == 0 )
        {
            goto AllDone;
        }

        cStrip = *plStrip;

SkipAGap:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        y += (dy > 0) ? cThis : -cThis;

        if ( cStyle == 0 )
        {
            goto PrepareToOutputADash;
        }
    }

PrepareToOutputADash:

    //
    // Advance in the style-state array, so that we can find the next
    // 'dot' that we'll have to display:
    //
    bIsGap = ~bIsGap;
    pLineState->psp++;
    
    if ( pLineState->psp > pLineState->pspEnd )
    {
        pLineState->psp = pLineState->pspStart;
    }

    cStyle = *pLineState->psp;

    //
    // If 'cStrip' is zero, we also need a new strip.
    //
    if ( cStrip != 0 )
    {
        goto OutputADash;
    }

    while ( TRUE )
    {
        //
        // Each time we loop, we move to a new column and need a new strip:
        //
        x++;

        plStrip++;
        cStrips--;
        
        if ( cStrips == 0 )
        {
            goto AllDone;
        }

        cStrip = *plStrip;

OutputADash:

        cThis   = min(cStrip, cStyle);
        cStyle -= cThis;
        cStrip -= cThis;

        //
        // With Permedia2 we just download the lines to draw
        //
        InputBufferReserve(ppdev, 8, &pBuffer);

        pBuffer[0] = __Permedia2TagStartXDom;
        pBuffer[1] =  INTtoFIXED(x);
        pBuffer[2] = __Permedia2TagStartY;
        pBuffer[3] =  INTtoFIXED(y);
        pBuffer[4] = __Permedia2TagCount;
        pBuffer[5] =  cThis;
        pBuffer[6] = __Permedia2TagRender;
        pBuffer[7] =  __PERMEDIA_LINE_PRIMITIVE;

        pBuffer += 8;

        InputBufferCommit(ppdev, pBuffer);

        y += (dy > 0) ? cThis : -cThis;

        if ( cStyle == 0 )
        {
            goto PrepareToSkipAGap;
        }
    }// while ( TRUE )

AllDone:
    //
    // Restore hardware to default state
    //
    InputBufferReserve(ppdev, 2, &pBuffer);
    
    pBuffer[0] = __Permedia2TagdY;
    pBuffer[1] =  INTtoFIXED(1);
    
    pBuffer += 2;

    InputBufferCommit(ppdev, pBuffer);

    //
    // Update our state variables so that the next line can continue
    // where we left off:
    //
    pLineState->spRemaining   = cStyle;
    pLineState->ulStyleMask   = bIsGap;
    pStrip->ptlStart.x = x;
    pStrip->ptlStart.y = y;

}// vStyledVerticalLine()

//
// For a given sub-pixel coordinate (x.m, y.n) in 28.4 fixed point
// format this array is indexed by (m,n) and indicates whether the
// given sub-pixel is within a GIQ diamond. m coordinates run left
// to right; n coordinates ru top to bottom so index the array with
// ((n<<4)+m). The array as seen here really contains 4 quarter
// diamonds.
//
static unsigned char    in_diamond[] =
{
/*          0 1 2 3 4 5 6 7 8 9 a b c d e f          */

/* 0 */     1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,    /* 0 */
/* 1 */     1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,    /* 1 */
/* 2 */     1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,    /* 2 */
/* 3 */     1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,    /* 3 */
/* 4 */     1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,    /* 4 */
/* 5 */     1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,    /* 5 */
/* 6 */     1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,    /* 6 */
/* 7 */     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,    /* 7 */
/* 8 */     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,    /* 8 */
/* 9 */     1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,    /* 9 */
/* a */     1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,1,    /* a */
/* b */     1,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,    /* b */
/* c */     1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,    /* c */
/* d */     1,1,1,1,1,0,0,0,0,0,0,0,1,1,1,1,    /* d */
/* e */     1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,    /* e */
/* f */     1,1,1,1,1,1,1,0,0,0,1,1,1,1,1,1,    /* f */

/*      0 1 2 3 4 5 6 7 8 9 a b c d e f          */
};

//
// For lines with abs(slope) != 1 use IN_DIAMOND to determine if an
// end point is in a diamond. For lines of slope = 1 use IN_S1DIAMOND.
// For lines of slope = -1 use IN_SM1DIAMOND. The last two are a bit
// strange. The documentation leaves us with a problem for slope 1
// lines which run exactly betwen the diamonds. According to the docs
// such a line can enter a diamond, leave it and enter again. This is
// plainly rubbish so along the appropriate edge of the diamond we
// consider a slope 1 line to be inside the diamond. This is the
// bottom right edge for lines of slope -1 and the bottom left edge for
// lines of slope 1.
//
#define IN_DIAMOND(m, n)    (in_diamond[((m) << 4) + (n)])
#define IN_S1DIAMOND(m, n)  ((in_diamond[((m) << 4) + (n)]) || \
                        ((m) - (n) == 8))
#define IN_SM1DIAMOND(m, n) ((in_diamond[((m) << 4) + (n)]) || \
                        ((m) + (n) == 8))

BOOL
bFastLine(PPDev     ppdev,
          LONG      fx1,
          LONG      fy1,
          LONG      fx2,
          LONG      fy2)

{
    register LONG   adx, ady, tmp;
    FIX         m1, n1, m2, n2;
    LONG    dx, dy;
    LONG    dX, dY;
    LONG    count, startX, startY;
    ULONG*      pBuffer;
    
    PERMEDIA_DECL;
    
    DBG_GDI((STRIP_LOG_LEVEL, "bFastLine"));

    //
    // This function is only called if we have a line with non integer end points
    // and the unsigned coordinates are no greater than 15.4. 
    //
    // We can only guarantee to do lines whose coords need <= 12 bits
    // of integer. This is because to get the delta we must shift
    // by 16 bits. This includes 4 bits of fraction which means if
    // we have more than 12 bits of integer we get overrun on the
    // shift. We could use floating point to give us a better 16
    // bits of integer but this requires an extra set of multiplies
    // and divides in order to convert from 28.4 to fp. In any case
    // we have to have a test to reject coords needing > 16 bits
    // of integer.
    // Actually, we can deal with 16.4 coordinates provided dx and dy
    // never require more than 12 bits of integer.
    // So optimise for the common case where the line is completely
    // on the screen (actually 0 to 2047.f). Since the coords have
    // 4 bits of fraction we note that a 32 bit signed number
    // outside the range 0 to 2047.f will have one of its top 17
    // bits set. So logical or all the coords and test against
    // 0xffff8000. This is about as quick a test as we can get for
    // both ends of the line being on the screen. If this test fails
    // then we can check everything else at a leisurely pace.
    //

    //
    // Get signed and absolute deltas
    //
    if ((adx = dx = fx2 - fx1) < 0)
    {
        adx = -adx;
    }
    if ((ady = dy = fy2 - fy1) < 0)
    {
        ady = -ady;
    }

    //
    // Refuse to draw any lines whose delta is out of range.
    // We have to shift the delta by 16, so we dont want to loose any precision
    //
    if ( (adx | ady) & 0xffff8000 )
    {
        return(FALSE);
    }

    //
    // Fractional bits are used to check if point is in a diamond
    //
    m1 = fx1 & 0xf;
    n1 = fy1 & 0xf;
    m2 = fx2 & 0xf;
    n2 = fy2 & 0xf;

    //
    // The rest of the code is a series of cases. Each one is "called" by a
    // goto. This is simply to keep the nesting down. Main cases are: lines
    // with absolute slope == 1; x-major lines; and y-major lines. We draw
    // lines as they are given rather than always drawing in one direction.
    // This adds extra code but saves the time required to swap the points
    // and adjust for not drawing the end point.
    //
    startX = fx1 << 12;
    startY = fy1 << 12;

    DBG_GDI((7, "GDI Line %x, %x  deltas %x, %x", startX, startY, dx, dy));

    if ( adx < ady )
    {
        goto y_major;
    }

    if ( adx > ady )
    {
        goto x_major;
    }

    //
    // All slope 1 lines are sampled in X. i.e. we move the start coord to
    // an integer x and let Permedia2 truncate in y. This is because all GIQ
    // lines are rounded down in y for values exactly half way between two
    // pixels. If we sampled in y then we would have to round up in x for
    // lines of slope 1 and round down in x for other lines. Sampling in x
    // allows us to use the same Permedia2 bias in all cases (0x7fff). We do
    // the x round up or down when we move the start point.
    //
    if ( dx != dy )
    {
        goto slope_minus_1;
    }
    if ( dx < 0 )
    {
        goto slope1_reverse;
    }

    dX = 1 << 16;
    dY = 1 << 16;

    if ( IN_S1DIAMOND(m1, n1) )
    {
        tmp = (startX + 0x8000) & ~0xffff;
    }
    else
    {
        tmp = (startX + 0xffff) & ~0xffff;
    }
    startY += tmp - startX;
    startX = tmp;
    
    if ( IN_S1DIAMOND(m2, n2) )
    {
        fx2 = (fx2 + 0x8) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 = (fx2 + 0xf) & ~0xf;   // next integer
    }
    count = (fx2 >> 4) - (startX >> 16);

    goto Draw_Line;

    slope1_reverse:
    dX = -1 << 16;
    dY = -1 << 16;

    if ( IN_S1DIAMOND(m1, n1) )
    {
        tmp = (startX + 0x8000) & ~0xffff;
    }
    else
    {
        tmp = startX & ~0xffff;
    }
    startY += tmp - startX;
    startX = tmp;
    
    if ( IN_S1DIAMOND(m2, n2) )
    {
        fx2 = (fx2 + 0x8) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 &= ~0xf;                // previous integer
    }

    count = (startX >> 16) - (fx2 >> 4);

    goto Draw_Line;

    slope_minus_1:
    
    if ( dx < 0 )
    {
        goto slope_minus_dx;
    }

    //
    // dx > 0, dy < 0
    //
    dX = 1 << 16;
    dY = -1 << 16;
    
    if (IN_SM1DIAMOND(m1, n1))
    {
        tmp = (startX + 0x7fff) & ~0xffff;
    }
    else
    {
        tmp = (startX + 0xffff) & ~0xffff;
    }
    
    startY += startX - tmp;
    startX = tmp;
    
    if (IN_SM1DIAMOND(m2, n2))
    {
        fx2 = (fx2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 = (fx2 + 0xf) & ~0xf;   // next integer
    }
    count = (fx2 >> 4) - (startX >> 16);

    goto Draw_Line;

    slope_minus_dx:
    dX = -1 << 16;
    dY = 1 << 16;
    
    if ( IN_SM1DIAMOND(m1, n1) )
    {
        tmp = (startX + 0x7fff) & ~0xffff;
    }
    else
    {
        tmp = startX & ~0xffff;
    }
    startY += startX - tmp;
    startX = tmp;
    
    if ( IN_SM1DIAMOND(m2, n2) )
    {
        fx2 = (fx2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 &= ~0xf;                // previous integer
    }
    count = (startX >> 16) - (fx2 >> 4);

    goto Draw_Line;

    x_major:
    
    //
    // Dont necessarily render through Permedia2 if we are worried about
    // conformance.
    //
    if ( (adx > (MAX_LENGTH_CONFORMANT_NONINTEGER_LINES << 4))
       &&(permediaInfo->flags & GLICAP_NT_CONFORMANT_LINES)
       &&(ady != 0) )
    {
        return(FALSE);
    }

    if ( dx < 0 )
    {
        goto right_to_left_x;
    }

    //
    // Line goes left to right. Round up the start x to an integer
    // coordinate. This is the coord of the first diamond that the
    // line crosses. Adjust start y to match this point on the line.
    //
    dX = 1 << 16;
    if ( IN_DIAMOND(m1, n1) )
    {
        tmp = (startX + 0x7fff) & ~0xffff;  // nearest integer
    }
    else
    {
        tmp = (startX + 0xffff) & ~0xffff;  // next integer
    }

    //
    // We can optimise for horizontal lines
    //
    if ( dy != 0 )
    {
        dY = dy << 16;

        //
        // Need to explicitly round delta down for -ve deltas.
        //
        if ( dy < 0 )
        {
            dY -= adx - 1;
        }

        dY /= adx;
        startY += (((tmp - startX) >> 12) * dY) >> 4;
    }
    else
    {
        dY = 0;
    }
    startX = tmp;

    if ( IN_DIAMOND(m2, n2) )
    {
        fx2 = (fx2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 = (fx2 + 0xf) & ~0xf;   // next integer
    }

    count = (fx2 >> 4) - (startX >> 16);

    goto Draw_Line;

    right_to_left_x:

    dX = -1 << 16;
    if ( IN_DIAMOND(m1, n1) )
    {
        tmp = (startX + 0x7fff) & ~0xffff;  // nearest integer
    }
    else
    {
        tmp = startX & ~0xffff;             // previous integer
    }

    //
    // We can optimise for horizontal lines
    //
    if (dy != 0)
    {
        dY = dy << 16;

        //
        // Need to explicitly round delta down for -ve deltas.
        //
        if ( dy < 0 )
        {
            dY -= adx - 1;
        }

        dY /= adx;
        startY += (((startX - tmp) >> 12) * dY) >> 4;
    }
    else
    {
        dY = 0;
    }
    startX = tmp;

    if ( IN_DIAMOND(m2, n2) )
    {
        fx2 = (fx2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fx2 &= ~0xf;                // previous integer
    }
    count = (startX >> 16) - (fx2 >> 4);

    goto Draw_Line;

y_major:
    //
    // Dont necessarily render through Permedia2 if we are worried
    // about conformance.
    //
    if ( (ady > (MAX_LENGTH_CONFORMANT_NONINTEGER_LINES << 4))
       &&(permediaInfo->flags & GLICAP_NT_CONFORMANT_LINES)
       &&(adx != 0) )
    {
        return(FALSE);
    }

    if ( dy < 0 )
    {
        goto high_to_low_y;
    }
    
    dY = 1 << 16;
    if ( IN_DIAMOND(m1, n1) )
    {
        tmp = (startY + 0x7fff) & ~0xffff;      // nearest integer
    }
    else
    {
        tmp = (startY + 0xffff) & ~0xffff;      // next integer
    }

    //
    // We can optimise for vertical lines
    //
    if ( dx != 0 )
    {
        dX = dx << 16;

        //
        // Need to explicitly round delta down for -ve deltas.
        //
        if ( dx < 0 )
        {
            dX -= ady - 1;
        }

        dX /= ady;
        startX += (((tmp - startY) >> 12) * dX) >> 4;
    }
    else
    {
        dX = 0;
    }
    startY = tmp;

    if ( IN_DIAMOND(m2, n2) )
    {
        fy2 = (fy2 + 0x7) & ~0xf;   // nearest integer
    }
    else
    {
        fy2 = (fy2 + 0xf) & ~0xf;   // next integer
    }
    count = (fy2 >> 4) - (startY >> 16);

    goto Draw_Line;

    high_to_low_y:

    dY = -1 << 16;
    if ( IN_DIAMOND(m1, n1) )
    {
        tmp = (startY + 0x7fff) & ~0xffff;  // nearest integer
    }
    else
    {
        tmp = startY & ~0xffff;             // previous integer
    }

    //
    // We can optimise for horizontal lines
    //
    if ( dx != 0 )
    {
        dX = dx << 16;

        //
        // Need to explicitly round delta down for -ve deltas.
        //
        if ( dx < 0 )
        {
            dX -= ady - 1;
        }

        dX /= ady;
        startX += (((startY - tmp) >> 12) * dX) >> 4;
    }
    else
    {
        dX = 0;
    }
    startY = tmp;

    if ( IN_DIAMOND(m2, n2) )
    {
        fy2 = (fy2 + 0x7) & ~0xf;       // nearest integer
    }
    else
    {
        fy2 &= ~0xf;                    // previous integer
    }
    count = (startY >> 16) - (fy2 >> 4);

Draw_Line:
    //
    // We need 6 fifo entries to draw a line
    //
    InputBufferReserve(ppdev, 16, &pBuffer);

    DBG_GDI((7, "Line %x, %x  deltas %x, %x  Count %x",
             startX + 0x7fff, startY + 0x7fff, dX, dY, count));

    pBuffer[0] = __Permedia2TagStartXDom;
    pBuffer[1] =   startX + 0x7fff;
    pBuffer[2] = __Permedia2TagStartY;
    pBuffer[3] =      startY + 0x7fff;
    pBuffer[4] = __Permedia2TagdXDom;
    pBuffer[5] =       dX;
    pBuffer[6] = __Permedia2TagdY;
    pBuffer[7] =          dY;
    pBuffer[8] = __Permedia2TagCount;
    pBuffer[9] =       count;
    pBuffer[10] = __Permedia2TagRender;
    pBuffer[11] =      __RENDER_LINE_PRIMITIVE;

    //
    // Restore default state
    //
    pBuffer[12] = __Permedia2TagdXDom;
    pBuffer[13] =       0;
    pBuffer[14] = __Permedia2TagdY;
    pBuffer[15] =          INTtoFIXED(1);

    pBuffer += 16;

    InputBufferCommit(ppdev, pBuffer);

    return(TRUE);
}// bFastLine()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\stroke.c ===
/******************************Module*Header***********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: Stroke.c
 *
 * Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
 ******************************************************************************/
#include "precomp.h"
#include "gdi.h"
#include "log.h"

PFNSTRIP gapfnStrip[] =
{
    vSolidHorizontalLine,
    vSolidVerticalLine,
    vSolidDiagonalHorizontalLine,
    vSolidDiagonalVerticalLine,

    // Should be NUM_STRIP_DRAW_DIRECTIONS = 4 strip drawers in every group

    vSolidHorizontalLine,
    vSolidVerticalLine,
    vSolidDiagonalHorizontalLine,
    vSolidDiagonalVerticalLine,

    // Should be NUM_STRIP_DRAW_STYLES = 8 strip drawers in total for doing
    // solid lines, and the same number for non-solid lines:

    vStyledHorizontalLine,
    vStyledVerticalLine,
    vStyledVerticalLine,  // Diagonal goes here
    vStyledVerticalLine,  // Diagonal goes here

    vStyledHorizontalLine,
    vStyledVerticalLine,
    vStyledVerticalLine,  // Diagonal goes here
    vStyledVerticalLine,  // Diagonal goes here
};

// Style array for alternate style (alternates one pixel on, one pixel off):

STYLEPOS gaspAlternateStyle[] = { 1 };

//-----------------------------------------------------------------------------
// BOOL DrvStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix)
//
// DrvStrokePath strokes a path when called by GDI. If the driver has hooked the
// function, and if the appropriate GCAPs are set, GDI calls DrvStrokePath when
// GDI draws a line or curve with any set of attributes.
//
// Parameters
// pso----------Identifies the surface on which to draw. 
// ppo----------Points to a PATHOBJ structure. GDI PATHOBJ_Xxx service routines
//              are provided to enumerate the lines, Bezier curves, and other
//              data that make up the path. This indicates what is to be drawn. 
// pco----------Points to a CLIPOBJ structure. GDI CLIPOBJ_Xxx service routines
//              are provided to enumerate the clip region as a set of
//              rectangles. Optionally, all the lines in the path may be
//              enumerated preclipped by CLIPOBJ. This means that drivers can
//              have all their line clipping calculations done for them. 
// pxo----------Points to a XFORMOBJ. This is only needed when a geometric wide
//              line is to be drawn. It specifies the transform that maps world
//              coordinates to device coordinates. This is needed because the
//              path is provided in device coordinates but a geometric wide line
//              is actually widened in world coordinates. 
//              The XFORMOBJ can be queried to find the transform. 
// pbo----------Specifies the brush to be used when drawing the path. 
// pptlBrushOrg-Points to the brush origin used to align the brush pattern on
//              the device. 
// pLineAttrs---Points to a LINEATTRS structure. Note that the elStyleState
//              member must be updated as part of this function if the line is
//              styled. Also note that the ptlLastPel member must be updated if
//              a single pixel width cosmetic line is being drawn. 
// mix----------Specifies how to combine the brush with the destination. 
//
// Return Value
//  The return value is TRUE if the driver is able to stroke the path. If GDI
//  should stroke the path, the return value is FALSE, and an error code is not
//  logged. If the driver encounters an error, the return value is DDI_ERROR,
//  and an error code is reported.
//
// Comments
//  If a driver supports this entry point, it should also support the drawing of
//  cosmetic wide lines with arbitrary clipping. Using the provided GDI
//  functions, the call can be broken down into a set of single-pixel-width
//  lines with precomputed clipping.
//
//  This function is required if any drawing is to be done on a device-managed
//  surface.
//
//  Drivers for advanced devices can optionally receive this call to draw paths
//  containing Bezier curves and geometric wide lines. GDI will test the
//  GCAPS_BEZIERS and GCAPS_GEOMETRICWIDE flags of the flGraphicsCaps member of
//  the DEVINFO structure to decide whether it should call. (The four
//  combinations of the bits determine the four levels of functionality for
//  this call.) If the driver gets an advanced call containing Bezier curves or
//  geometric wide lines, it can decide not to handle the call, returning FALSE.
//  This might happen if the path or clipping is too complex for the device to
//  process. If the call does return FALSE, GDI breaks the call down into
//  simpler calls that can be handled easily.
//
//  For device-managed surfaces, the function must minimally support
//  single-pixel-wide solid and styled cosmetic lines using a solid-colored
//  brush. The device can return FALSE if the line is geometric and the engine
//  will convert those calls to DrvFillPath or DrvPaint calls.
//
//  The mix mode defines how the incoming pattern should be mixed with the data
//  already on the device surface. The MIX data type consists of two ROP2 values
//  packed into a single ULONG. The low-order byte defines the foreground raster
//  operation; the next byte defines the background raster operation. For more
//  information about raster operation codes, see the Platform SDK.
//
//-----------------------------------------------------------------------------
BOOL
DrvStrokePath(SURFOBJ*   pso,
              PATHOBJ*   ppo,
              CLIPOBJ*   pco,
              XFORMOBJ*  pxo,
              BRUSHOBJ*  pbo,
              POINTL*    pptlBrush,
              LINEATTRS* pLineAttrs,
              MIX        mix)
{
    STYLEPOS  aspLtoR[STYLE_MAX_COUNT];
    STYLEPOS  aspRtoL[STYLE_MAX_COUNT];
    LINESTATE lineState;
    PFNSTRIP* apfn;
    FLONG     fl;
    PDev*     ppdev;
    Surf*     psurfDst;
    RECTL     arclClip[4];                  // For rectangular clipping
    BOOL      bResetHW;
    BOOL      bRet;
    DWORD     logicOp;

    DBG_GDI((6, "DrvStrokePath called with mix =%x", mix));

    psurfDst = (Surf*)pso->dhsurf;

    //
    // Punt to engine if surface to draw is not in video memory
    //
    if ( psurfDst->flags & SF_SM )
    {
        goto puntIt;
    }

    ppdev = (PDev*)pso->dhpdev;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvStrokePath: re-entered! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT
    
    vCheckGdiContext(ppdev);

    ppdev->psurf = psurfDst;

    fl = 0;

    //
    // Look after styling initialization:
    //
    if ( pLineAttrs->fl & LA_ALTERNATE )
    {
        //
        // LA_ALTERNATE: A special cosmetic line style; every other pixel is on
        //
        lineState.cStyle      = 1;
        lineState.spTotal     = 1;
        lineState.spTotal2    = 2;
        lineState.spRemaining = 1;
        lineState.aspRtoL     = &gaspAlternateStyle[0];
        lineState.aspLtoR     = &gaspAlternateStyle[0];
        lineState.spNext      = HIWORD(pLineAttrs->elStyleState.l);
        lineState.xyDensity   = 1;
        lineState.ulStartMask = 0L;
        fl                   |= FL_ARBITRARYSTYLED;
    }// Cosmetic line
    else if ( pLineAttrs->pstyle != (FLOAT_LONG*)NULL )
    {
        //
        // "pLineAttrs->pstyle" points to the style array. If this member is
        // null, the line style is solid
        //
        PFLOAT_LONG pStyle;
        STYLEPOS*   pspDown;
        STYLEPOS*   pspUp;

        //
        // "pLineAttrs->cstyle" specifies the number of entries in the style
        // array. So here we get the address of the last array first
        //
        pStyle = &pLineAttrs->pstyle[pLineAttrs->cstyle];

        lineState.xyDensity = STYLE_DENSITY;
        lineState.spTotal   = 0;

        //
        // Loop through all the data array backworfds to get the sum of style
        // array
        //
        while ( pStyle-- > pLineAttrs->pstyle )
        {
            lineState.spTotal += pStyle->l;
        }

        lineState.spTotal *= STYLE_DENSITY;
        lineState.spTotal2 = 2 * lineState.spTotal;

        //
        // Compute starting style position (this is guaranteed not to overflow)
        // Note: "pLineAttrs->elStyleState" is a pair of 16-bit values supplied
        // by GDI whenever the driver calls PATHOBJ_bEnumClipLines. These two
        // values, packed into a LONG, specify where in the styling array
        // (at which pixel) to start the first subpath. This value must be
        // updated as part of the output routine if the line is not solid.
        // This member applies to cosmetic lines only.
        //
        lineState.spNext = HIWORD(pLineAttrs->elStyleState.l) * STYLE_DENSITY
                         + LOWORD(pLineAttrs->elStyleState.l);

        fl |= FL_ARBITRARYSTYLED;
        lineState.cStyle  = pLineAttrs->cstyle;
        lineState.aspRtoL = aspRtoL;
        lineState.aspLtoR = aspLtoR;

        if ( pLineAttrs->fl & LA_STARTGAP )
        {
            //
            // The first entry in the style array specifies the length of the
            // first gap. set "ulStartMask" to mark it as a GAP
            //
            lineState.ulStartMask = 0xffffffffL;
        }
        else
        {
            //
            // It must be LA_GEOMETRIC which specifies a geometric wide line. Mark
            // it as not a GAP
            //
            lineState.ulStartMask = 0L;
        }

        //
        // Let "pStyle" points to the 1st style array, "pspDown" ponits to the
        // "cStyle"th array in aspRtoL and "pspUp" points to the 1st array in
        // aspLtoR
        //
        pStyle  = pLineAttrs->pstyle;
        pspDown = &lineState.aspRtoL[lineState.cStyle - 1];
        pspUp   = &lineState.aspLtoR[0];

        //
        // Move backwards to assign all the style data
        //
        while ( pspDown >= &lineState.aspRtoL[0] )
        {
            //
            // Let the last style data in "pspDown" = the 1st in "pspUp", 2 to
            // last in "pspDown" = 2nd in "pspUp".....
            // pspDown [n][n-1]...[2][1]
            // pspUp [1][2]...[n-1][n]
            //
            *pspDown = pStyle->l * STYLE_DENSITY;
            *pspUp   = *pspDown;

            pspUp++;
            pspDown--;
            
            pStyle++;
        }
    }// Non-solid line

    bRet = TRUE;
    apfn = &gapfnStrip[NUM_STRIP_DRAW_STYLES *
                       ((fl & FL_STYLE_MASK) >> FL_STYLE_SHIFT)];

    //
    // Set up to enumerate the path:
    //
    if ( pco->iDComplexity != DC_COMPLEX )
    {
        PATHDATA  pd;
        RECTL*    prclClip = (RECTL*)NULL;
        BOOL      bMore;
        ULONG     lPtFix;
        POINTFIX  ptfxStartFigure;
        POINTFIX  ptfxLast;
        POINTFIX* pptfxFirst;
        POINTFIX* pptfxBuf;

        if ( pco->iDComplexity == DC_RECT )
        {
            fl |= FL_SIMPLE_CLIP;

            //
            // This is the only clip region of importance to Permedia2
            //
            arclClip[0]        =  pco->rclBounds;

            //
            // FL_FLIP_D:
            //
            arclClip[1].top    =  pco->rclBounds.left;
            arclClip[1].left   =  pco->rclBounds.top;
            arclClip[1].bottom =  pco->rclBounds.right;
            arclClip[1].right  =  pco->rclBounds.bottom;

            //
            // FL_FLIP_V:
            //
            arclClip[2].top    = -pco->rclBounds.bottom + 1;
            arclClip[2].left   =  pco->rclBounds.left;
            arclClip[2].bottom = -pco->rclBounds.top + 1;
            arclClip[2].right  =  pco->rclBounds.right;

            //
            // FL_FLIP_V | FL_FLIP_D:
            //
            arclClip[3].top    =  pco->rclBounds.left;
            arclClip[3].left   = -pco->rclBounds.bottom + 1;
            arclClip[3].bottom =  pco->rclBounds.right;
            arclClip[3].right  = -pco->rclBounds.top + 1;

            prclClip = arclClip;
        }// if ( pco->iDComplexity == DC_RECT )

        pd.flags = 0;

        //
        // Get the logic op and set up the flag to indicate reads from the frame
        // buffer will occur.
        //
        logicOp = ulRop3ToLogicop(gaMix[mix & 0xff]);
        DBG_GDI((7, "logicop is %d", logicOp));

        if ( LogicopReadDest[logicOp] )
        {
            fl |= FL_READ;
        }

        //
        // Need to set up Permedia2 modes and colors appropriately for the lines
        //
        bResetHW = bInitializeStrips(ppdev, pbo->iSolidColor,
                                     logicOp, prclClip);

        PATHOBJ_vEnumStart(ppo);

        do
        {
            bMore = PATHOBJ_bEnum(ppo, &pd);

            lPtFix = pd.count;
            if ( lPtFix == 0 )
            {
                //
                // If the pathdata contains no data, finish
                //
                break;
            }

            if ( pd.flags & PD_BEGINSUBPATH )
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                lPtFix--;
            }
            else
            {
                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;
            }

            if ( pd.flags & PD_RESETSTYLE )
            {
                lineState.spNext = 0;
            }

            if ( lPtFix > 0 )
            {
                if ( !bLines(ppdev,
                             pptfxFirst,
                             pptfxBuf,
                             (RUN*)NULL,
                             lPtFix,
                             &lineState,
                             prclClip,
                             apfn,
                             fl) )
                {
                    bRet = FALSE;
                    goto ResetReturn;
                }
            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if ( pd.flags & PD_CLOSEFIGURE )
            {
                if ( !bLines(ppdev,
                             &ptfxLast,
                             &ptfxStartFigure,
                             (RUN*)NULL,
                             1,
                             &lineState,
                             prclClip,
                             apfn,
                             fl) )
                {
                    bRet = FALSE;
                    goto ResetReturn;
                }
            }
        } while ( bMore );

        if ( fl & FL_STYLED )
        {
            //
            // Save the style state
            //
            ULONG ulHigh;
            ULONG ulLow;

            //
            // Masked styles don't normalize the style state.  It's a good thing
            // to do, so let's do it now
            //
            if ( (ULONG)lineState.spNext >= (ULONG)lineState.spTotal2 )
            {
                lineState.spNext = (ULONG)lineState.spNext
                                 % (ULONG)lineState.spTotal2;
            }

            ulHigh = lineState.spNext / lineState.xyDensity;
            ulLow  = lineState.spNext % lineState.xyDensity;

            pLineAttrs->elStyleState.l = MAKELONG(ulLow, ulHigh);
        }
    }
    else
    {
        //
        // Local state for path enumeration
        //
        BOOL bMore;

        union
        {
            BYTE     aj[offsetof(CLIPLINE, arun) + RUN_MAX * sizeof(RUN)];
            CLIPLINE cl;
        } cl;

        fl |= FL_COMPLEX_CLIP;

        //
        // Need to set up hardware modes and colors appropriately for the lines.
        // NOTE, with a complex clip,we can not yet use permedia2 for fast lines
        //
        bResetHW = bInitializeStrips(ppdev, pbo->iSolidColor,
                                     ulRop3ToLogicop(gaMix[mix&0xff]),
                                     NULL);

        //
        // We use the clip object when non-simple clipping is involved:
        //
        PATHOBJ_vEnumStartClipLines(ppo, pco, pso, pLineAttrs);

        do
        {
            bMore = PATHOBJ_bEnumClipLines(ppo, sizeof(cl), &cl.cl);
            if ( cl.cl.c != 0 )
            {
                if ( fl & FL_STYLED )
                {
                    lineState.spComplex = HIWORD(cl.cl.lStyleState)
                                        * lineState.xyDensity
                                        + LOWORD(cl.cl.lStyleState);
                }
                if ( !bLines(ppdev,
                             &cl.cl.ptfxA,
                             &cl.cl.ptfxB,
                             &cl.cl.arun[0],
                             cl.cl.c,
                             &lineState,
                             (RECTL*) NULL,
                             apfn,
                             fl) )
                {
                    bRet = FALSE;
                    goto ResetReturn;
                }
            }
        } while ( bMore );
    }

ResetReturn:

    if ( bResetHW )
    {
        vResetStrips(ppdev);
    }

    DBG_GDI((6, "DrvStrokePath done it"));

    InputBufferFlush(ppdev);
    
//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return (bRet);

puntIt:
//@@BEGIN_DDKSPLIT
#if GDI_TEST    
    ULONG   flags = vPuntBefore(NULL, pso);
#endif
//@@END_DDKSPLIT

    bRet = EngStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush,
                         pLineAttrs, mix);

//@@BEGIN_DDKSPLIT
#if GDI_TEST
    vPuntAfter(flags, NULL, pso);

    vLogPunt();
#endif
//@@END_DDKSPLIT

    DBG_GDI((6, "DrvStrokePath punt it"));
    return bRet;
}// DrvStrokePath()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\text.h ===
/******************************Module*Header***********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: text.h
*
* Text rendering support routines.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
*
\******************************************************************************/

#ifndef __TEXT__
#define __TEXT__

extern BOOL bEnableText(PDev*);
extern VOID vDisableText(PDev*);
extern VOID vAssertModeText(PDev*, BOOL);

extern BOOL bProportionalText(
    PDev* ppdev,
    GLYPHPOS* pgp,
    LONG cGlyph);

extern BOOL bFixedText(
    PDev* ppdev,
    GLYPHPOS* pgp,
    LONG cGlyph,
   ULONG ulCharInc);

extern BOOL  bClippedText(
    PDev* ppdev,
    GLYPHPOS* pgp,
    LONG cGlyph,
    ULONG ulCharInc,
    CLIPOBJ* pco);

extern BOOL  bClippedAAText(
    PDev* ppdev,
    GLYPHPOS* pgp,
    LONG cGlyph,
    ULONG ulCharInc,
    CLIPOBJ* pco);
#endif // __TEXT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\text.c ===
/******************************Module*Header***********************************\
* Module Name: text.c
*
* Non-cached glyph rendering functions.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
*
\******************************************************************************/
#include "precomp.h"
#include "gdi.h"

// The shift equations are a nuisance. We want x<<32 to be
// zero but some processors only use the bottom 5 bits
// of the shift value. So if we want to shift by n bits
// where we know that n may be 32, we do it in two parts.
// It turns out that in the algorithms below we get either
// (32 <= n < 0) or (32 < n <= 0). We use the macro for
// the first one and a normal shift for the second.
//
#define SHIFT_LEFT(src, n)  (((src) << ((n)-1)) << 1)


//------------------------------------------------------------------------------
// FUNC: bClippedText
//
// Renders an array of proportional or monospaced glyphs within a non-trivial
// clip region
//
// ppdev------pointer to physical device object
// pgp--------array of glyphs to render (all members of the pcf font)
// cGlyph-----number of glyphs to render
// ulCharInc--fixed character spacing increment (0 if proportional font)
// pco--------pointer to the clip region object
//
// Returns TRUE if string object rendered
//------------------------------------------------------------------------------
BOOL
bClippedText(PDev*      ppdev,
             GLYPHPOS*  pgp,
             LONG       cGlyph, 
             ULONG      ulCharInc,
             CLIPOBJ*   pco)
{
    LONG    cGlyphOriginal;
    GLYPHPOS    *pgpOriginal;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    ClipEnum    ce;
    RECTL*      prclClip;
    LONG        cxGlyph;
    LONG        cyGlyph;
    BYTE*       pjGlyph;
    LONG        x;
    DWORD       renderBits;
    LONG        unused;
    LONG        rShift;
    ULONG       bits;
    ULONG       bitWord;
    ULONG*      pBuffer;
    ULONG*      pBufferEnd;
    ULONG*      pReservationEnd;

    PERMEDIA_DECL;
    
    DBG_GDI((7, "bClippedText: entered for %d glyphs", cGlyph));

    ASSERTDD(pco != NULL, "Don't expect NULL clip objects here");

    //we'll go through the glyph list for each of the clipping rectangles
    cGlyphOriginal = cGlyph;
    pgpOriginal = pgp;

    renderBits = __RENDER_TRAPEZOID_PRIMITIVE | __RENDER_SYNC_ON_BIT_MASK;

    // since we are clipping, assume that we will need the scissor clip. So
    // enable user level scissoring here. We disable it just before returning.
    //
    
    InputBufferReserve(ppdev, 2, &pBuffer);

    pBuffer[0] = __Permedia2TagScissorMode;
    pBuffer[1] = USER_SCISSOR_ENABLE | SCREEN_SCISSOR_DEFAULT;

    pBuffer += 2;

    InputBufferCommit(ppdev, pBuffer);

    if (pco->iDComplexity != DC_COMPLEX)
    {
        // We could call 'cEnumStart' and 'bEnum' when the clipping is
        // DC_RECT, but the last time I checked, those two calls took
        // more than 150 instructions to go through GDI.  Since
        // 'rclBounds' already contains the DC_RECT clip rectangle,
        // and since it's such a common case, we'll special case it:
        DBG_GDI((7, "bClippedText: Enumerating rectangular clip region"));
        bMore    = FALSE;
        prclClip = &pco->rclBounds;
        ce.c     = 1;

        goto SingleRectangle;
    }

    DBG_GDI((7, "bClippedText: Enumerating complex clip region"));
    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

    do 
    {
      bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

      for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
      {
        cGlyph = cGlyphOriginal;
        pgp = pgpOriginal;

      SingleRectangle:
        pgb = pgp->pgdf->pgb;

        ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
        ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;

        // load Permedia2 scissor clip to trap partially clipped glyphs. We still
        // check whether a glyph is completely clipped out as an optimisation.
        // I suppose that since we construct the bits to download to Permedia2, with
        // a bit more work I could do the clipping while downloading the bits.
        // But, in the future we will probably cache the packed bits anyway so
        // use the scissor. Wait for the first 5 FIFO entries here as well.
        //
        DBG_GDI((7, "bClippedText: loading scissor clip (%d,%d):(%d,%d)",
                    prclClip->left, prclClip->top,
                    prclClip->right, prclClip->bottom));

        InputBufferReserve(ppdev, 4, &pBuffer);

        pBuffer[0] = __Permedia2TagScissorMinXY;
        pBuffer[1] = (prclClip->top << 16) | (prclClip->left);
        pBuffer[2] = __Permedia2TagScissorMaxXY;
        pBuffer[3] = (prclClip->bottom << 16) | (prclClip->right);

        pBuffer += 4;

        InputBufferCommit(ppdev, pBuffer);

        // Loop through all the glyphs for this rectangle:
        for(;;)
        {
          cxGlyph = pgb->sizlBitmap.cx;
          cyGlyph = pgb->sizlBitmap.cy;

          // reject completely clipped out glyphs
          if ((prclClip->right  <= ptlOrigin.x) || 
              (prclClip->bottom <= ptlOrigin.y) ||
              (prclClip->left   >= ptlOrigin.x + cxGlyph) || 
              (prclClip->top    >= ptlOrigin.y + cyGlyph))
          {
                  DBG_GDI((7, "bClippedText: glyph clipped at (%d,%d):(%d,%d)",
                            ptlOrigin.x, ptlOrigin.y,
                            ptlOrigin.x + cxGlyph, ptlOrigin.y + cyGlyph));
                goto ContinueGlyphs;
          }

          pjGlyph = pgb->aj;
          cyGlyph = pgb->sizlBitmap.cy;
          x = ptlOrigin.x;

          unused = 32;
          bitWord = 0;

          DBG_GDI((7, "bClippedText: glyph clipped at (%d,%d):(%d,%d)",
                      x, ptlOrigin.y, x + cxGlyph, ptlOrigin.y + cyGlyph));

          InputBufferReserve(ppdev, 10, &pBuffer);

          pBuffer[0] = __Permedia2TagStartXDom;
          pBuffer[1] =  INTtoFIXED(x);

          pBuffer[2] = __Permedia2TagStartXSub;
          pBuffer[3] = INTtoFIXED(x + cxGlyph);
          pBuffer[4] = __Permedia2TagStartY;
          pBuffer[5] = INTtoFIXED(ptlOrigin.y);
          pBuffer[6] = __Permedia2TagCount;
          pBuffer[7] = cyGlyph;
          pBuffer[8] = __Permedia2TagRender;
          pBuffer[9] = renderBits;

          pBuffer += 10;

          InputBufferCommit(ppdev, pBuffer);

          DBG_GDI((7, "bClippedText: downloading %d pel wide glyph",
                     cxGlyph));

          InputBufferStart(ppdev, 100, &pBuffer, &pBufferEnd, &pReservationEnd);

          if (cxGlyph <= 8)
          {
                //-----------------------------------------------------
                // 1 to 8 pels in width

                BYTE    *pSrcB;

                pSrcB = pjGlyph;
                rShift = 8 - cxGlyph;
                for(;;)	
                {
                    bits = *pSrcB >> rShift;
                    unused -= cxGlyph;
                    if (unused > 0)
                        bitWord |= bits << unused;
                    else 
                    {
                        bitWord |= bits >> -unused;
                        
                        InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd,
                                                            &pReservationEnd);
                        
                        pBuffer[0] = __Permedia2TagBitMaskPattern;
                        pBuffer[1] = bitWord;
                        
                        pBuffer += 2;
                        
                        unused += 32;
                        bitWord = SHIFT_LEFT(bits, unused);
                    }
                    if (--cyGlyph == 0)
                        break;
                    ++pSrcB;
                }
            }
            else if (cxGlyph <= 16)
            {
              //-----------------------------------------------------
              // 9 to 16 pels in width

                USHORT  *pSrcW;

                pSrcW = (USHORT *)pjGlyph;
                rShift = 32 - cxGlyph;
                for(;;) 
                {
                    bits = *pSrcW;
                    bits = ((bits << 24) | (bits << 8)) >> rShift;
                    unused -= cxGlyph;
                    if (unused > 0)
                        bitWord |= bits << unused;
                    else 
                    {
                        bitWord |= bits >> -unused;
                        
                        InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd,
                                                            &pReservationEnd);
                        
                        pBuffer[0] = __Permedia2TagBitMaskPattern;
                        pBuffer[1] = bitWord;
                        
                        pBuffer += 2;
                        
                        unused += 32;
                        bitWord = SHIFT_LEFT(bits, unused);
                    }
                    if (--cyGlyph == 0)
                        break;
                    ++pSrcW;
                }
            }
            else
            {
              //-----------------------------------------------------
              // More than 16 pels in width

                ULONG *pSrcL;
                LONG    nRight;
                LONG    nRemainder;
                LONG    lDelta;

                lDelta = (cxGlyph + 7) >> 3;
                for(;;) 
                {
                    pSrcL = (ULONG*)((INT_PTR)pjGlyph & ~3);
                    nRight=(LONG)(32-(((INT_PTR)pjGlyph-(INT_PTR)pSrcL) << 3));
                    LSWAP_BYTES(bits, pSrcL);
                    bits &= SHIFT_LEFT(1, nRight) - 1;
                    nRemainder = cxGlyph - nRight;
                    if (nRemainder < 0) 
                    {
                        bits >>= -nRemainder;
                        nRight = cxGlyph;
                        nRemainder = 0;
                    }
                    unused -= nRight;
                    if (unused > 0)
                        bitWord |= bits << unused;
                    else 
                    {
                        bitWord |= bits >> -unused;
                        
                        InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd,
                                                            &pReservationEnd);
                        
                        pBuffer[0] = __Permedia2TagBitMaskPattern;
                        pBuffer[1] = bitWord;
                        
                        pBuffer += 2;
                        
                        unused += 32;
                        bitWord = SHIFT_LEFT(bits, unused);
                    }

                    while (nRemainder >= 32) 
                    {
                        ++pSrcL;
                        LSWAP_BYTES(bits, pSrcL);
                        bitWord |= bits >> (32 - unused);
                        
                        InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd,
                                                            &pReservationEnd);
                        
                        pBuffer[0] = __Permedia2TagBitMaskPattern;
                        pBuffer[1] = bitWord;
                        
                        pBuffer += 2;
                        
                        bitWord = SHIFT_LEFT(bits, unused);
                        nRemainder -= 32;
                    }

                    if (nRemainder > 0) 
                    {
                        ++pSrcL;
                        LSWAP_BYTES(bits, pSrcL);
                        bits >>= (32 - nRemainder);
                        unused -= nRemainder;
                        if (unused > 0)
                            bitWord |= bits << unused;
                        else 
                        {
                            bitWord |= bits >> -unused;

                            InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd,
                                                                &pReservationEnd);

                            pBuffer[0] = __Permedia2TagBitMaskPattern;
                            pBuffer[1] = bitWord;

                            pBuffer += 2;

                            unused += 32;
                            bitWord = SHIFT_LEFT(bits, unused);
                        }
                    }

                    if (--cyGlyph == 0)
                        break;

                    /* go onto next scanline */
                    pjGlyph += lDelta;
                }
            }
            
            // complete the bit download
            if (unused < 32) 
            {
                InputBufferContinue(ppdev, 2, &pBuffer, &pBufferEnd,
                                                    &pReservationEnd);

                pBuffer[0] = __Permedia2TagBitMaskPattern;
                pBuffer[1] = bitWord;

                pBuffer += 2;
            }

            InputBufferCommit(ppdev, pBuffer);

            DBG_GDI((7, "bClippedText: download completed"));

ContinueGlyphs:
            if (--cGlyph == 0)
              break;

            DBG_GDI((7, "bClippedText: %d still to render", cGlyph));

            // Get ready for next glyph:
            pgp++;
            pgb = pgp->pgdf->pgb;

            if (ulCharInc == 0)
            {
              ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
              ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
            }
            else
            {
              ptlOrigin.x += ulCharInc;
            }

          }
        }

    } while (bMore);

    // reset the scissor. default is the whole of VRAM.
    DBG_GDI((20, "bClippedText: resetting scissor clip"));
    
    InputBufferReserve(ppdev, 2, &pBuffer);

    pBuffer[0] = __Permedia2TagScissorMode;
    pBuffer[1] = SCREEN_SCISSOR_DEFAULT;

    pBuffer += 2;

    InputBufferCommit(ppdev, pBuffer);

    DBG_GDI((7, "bClippedText: exited"));

    return(TRUE);
}

//------------------------------------------------------------------------------
// FUNC: bClippedAAText
//
// Renders an array of proportional or monospaced anti-aliassed glyphs within
// a non-trivial clip region
//
// ppdev------pointer to physical device object
// pgp--------array of glyphs to render (all members of the pcf font)
// cGlyph-----number of glyphs to render
// ulCharInc--fixed character spacing increment (0 if proportional font)
// pco--------pointer to the clip region object
//
// Returns TRUE if string object rendered
//------------------------------------------------------------------------------
BOOL
bClippedAAText(PDev*      ppdev,
             GLYPHPOS*  pgp,
             LONG       cGlyph, 
             ULONG      ulCharInc,
             CLIPOBJ*   pco)
{
    LONG    cGlyphOriginal;
    GLYPHPOS    *pgpOriginal;
    GLYPHBITS*  pgb;
    POINTL      ptlOrigin;
    BOOL        bMore;
    ClipEnum    ce;
    RECTL*      prclClip;
    LONG        cxGlyph;
    LONG        cyGlyph;
    BYTE*       pjGlyph;
    LONG        x;
    DWORD       renderBits;
    LONG        unused;
    LONG        rShift;
    ULONG       bits;
    ULONG       bitWord;
    ULONG*      pBuffer;
    ULONG*      pBufferEnd;
    ULONG*      pReservationEnd;

    PERMEDIA_DECL;
    
    DBG_GDI((7, "bClippedAAText: entered for %d glyphs", cGlyph));

    ASSERTDD(pco != NULL, "Don't expect NULL clip objects here");

    //we'll go through the glyph list for each of the clipping rectangles

    cGlyphOriginal = cGlyph;
    pgpOriginal = pgp;

    renderBits = __RENDER_TRAPEZOID_PRIMITIVE |
                 __RENDER_TEXTURED_PRIMITIVE |
                 __RENDER_SYNC_ON_HOST_DATA;

    // since we are clipping, assume that we will need the scissor clip. So
    // enable user level scissoring here. We disable it just before returning.
    //
    
    InputBufferReserve(ppdev, 14, &pBuffer);

    pBuffer[0] = __Permedia2TagScissorMode;
    pBuffer[1] = USER_SCISSOR_ENABLE | SCREEN_SCISSOR_DEFAULT;

    pBuffer[2] = __Permedia2TagDitherMode;
    pBuffer[3] = (COLOR_MODE << PM_DITHERMODE_COLORORDER) | 
                 (ppdev->ulPermFormat << PM_DITHERMODE_COLORFORMAT) |
                 (ppdev->ulPermFormatEx << PM_DITHERMODE_COLORFORMATEXTENSION) |
                 (1 << PM_DITHERMODE_ENABLE);
    
    pBuffer[4] = __Permedia2TagAlphaBlendMode;
    pBuffer[5] = (0 << PM_ALPHABLENDMODE_BLENDTYPE) |  // RGB
                 (1 << PM_ALPHABLENDMODE_COLORORDER) | // RGB
                 (1 << PM_ALPHABLENDMODE_ENABLE) | 
                 (1 << PM_ALPHABLENDMODE_ENABLE) | 
                 (84 << PM_ALPHABLENDMODE_OPERATION) | // PreMult
                 (ppdev->ulPermFormat << PM_ALPHABLENDMODE_COLORFORMAT) |
                 (ppdev->ulPermFormatEx << PM_ALPHABLENDMODE_COLORFORMATEXTENSION);
    
    pBuffer[6] = __Permedia2TagLogicalOpMode;
    pBuffer[7] =  __PERMEDIA_DISABLE;
    
    pBuffer[8] = __Permedia2TagTextureColorMode;
    pBuffer[9] = (1 << PM_TEXCOLORMODE_ENABLE) |
                 (0 << 4) |  // RGB
                 (0 << 1);  // Modulate
    
    pBuffer[10] = __Permedia2TagTextureDataFormat;
    pBuffer[11] = (ppdev->ulPermFormat << PM_TEXDATAFORMAT_FORMAT) |
                  (ppdev->ulPermFormatEx << PM_TEXDATAFORMAT_FORMATEXTENSION) |
                  (COLOR_MODE << PM_TEXDATAFORMAT_COLORORDER);
    
    pBuffer[12] = __Permedia2TagColorDDAMode;
    pBuffer[13] = 1;
    
    pBuffer += 14;

    InputBufferCommit(ppdev, pBuffer);

    if (pco->iDComplexity != DC_COMPLEX)
    {
        // We could call 'cEnumStart' and 'bEnum' when the clipping is
        // DC_RECT, but the last time I checked, those two calls took
        // more than 150 instructions to go through GDI.  Since
        // 'rclBounds' already contains the DC_RECT clip rectangle,
        // and since it's such a common case, we'll special case it:
        DBG_GDI((7, "bClippedText: Enumerating rectangular clip region"));
        bMore    = FALSE;
        prclClip = &pco->rclBounds;
        ce.c     = 1;
        
        goto SingleRectangle;
    }

    DBG_GDI((7, "bClippedAAText: Enumerating complex clip region"));
    CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

    do 
    {
        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);
        
        for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
        {
            cGlyph = cGlyphOriginal;
            pgp = pgpOriginal;
            
        SingleRectangle:

            pgb = pgp->pgdf->pgb;
            
            ptlOrigin.x = pgb->ptlOrigin.x + pgp->ptl.x;
            ptlOrigin.y = pgb->ptlOrigin.y + pgp->ptl.y;
            
            // load Permedia2 scissor clip to trap partially clipped glyphs. We still
            // check whether a glyph is completely clipped out as an optimisation.
            // I suppose that since we construct the bits to download to Permedia2, with
            // a bit more work I could do the clipping while downloading the bits.
            // But, in the future we will probably cache the packed bits anyway so
            // use the scissor. Wait for the first 5 FIFO entries here as well.
            //
            DBG_GDI((7, "bClippedAAText: loading scissor clip (%d,%d):(%d,%d)",
                    prclClip->left, prclClip->top,
                    prclClip->right, prclClip->bottom));
            
            InputBufferReserve(ppdev, 4, &pBuffer);
            
            pBuffer[0] = __Permedia2TagScissorMinXY;
            pBuffer[1] = (prclClip->top << 16) | (prclClip->left);
            pBuffer[2] = __Permedia2TagScissorMaxXY;
            pBuffer[3] = (prclClip->bottom << 16) | (prclClip->right);
            
            pBuffer += 4;
            
            InputBufferCommit(ppdev, pBuffer);
            
            // Loop through all the glyphs for this rectangle:
            for(;;)
            {
                cxGlyph = pgb->sizlBitmap.cx;
                cyGlyph = pgb->sizlBitmap.cy;
                
                // reject completely clipped out glyphs
                if ((prclClip->right  <= ptlOrigin.x) || 
                  (prclClip->bottom <= ptlOrigin.y) ||
                  (prclClip->left   >= ptlOrigin.x + cxGlyph) || 
                  (prclClip->top    >= ptlOrigin.y + cyGlyph))
                {
                    DBG_GDI((7, "bClippedAAText: glyph clipped at (%d,%d):(%d,%d)",
                            ptlOrigin.x, ptlOrigin.y,
                            ptlOrigin.x + cxGlyph, ptlOrigin.y + cyGlyph));
                    goto ContinueGlyphs;
                }
                
                pjGlyph = pgb->aj;
                cyGlyph = pgb->sizlBitmap.cy;
                x = ptlOrigin.x;
                
                unused = 32;
                bitWord = 0;
                
                DBG_GDI((7, "bClippedAAText: glyph clipped at (%d,%d):(%d,%d)",
                          x, ptlOrigin.y, x + cxGlyph, ptlOrigin.y + cyGlyph));
                
                InputBufferReserve(ppdev, 12, &pBuffer);
                
                pBuffer[0] = __Permedia2TagStartXDom;
                pBuffer[1] =  INTtoFIXED(x);
                
                pBuffer[2] = __Permedia2TagStartXSub;
                pBuffer[3] = INTtoFIXED(x + cxGlyph);
                pBuffer[4] = __Permedia2TagStartY;
                pBuffer[5] = INTtoFIXED(ptlOrigin.y);
                pBuffer[6] = __Permedia2TagdY;
                pBuffer[7] =  1 << 16;
                pBuffer[8] = __Permedia2TagCount;
                pBuffer[9] = cyGlyph;
                pBuffer[10] = __Permedia2TagRender;
                pBuffer[11] = renderBits;
                
                pBuffer += 12;
                
                InputBufferCommit(ppdev, pBuffer);
                
                DBG_GDI((7, "bClippedAAText: downloading %d pel wide glyph",
                         cxGlyph));
                
                while(cyGlyph--)
                
                {
                
                    InputBufferReserve(ppdev, cxGlyph + 1, &pBuffer);
                    
                    *pBuffer++ = ((cxGlyph - 1) << 16) | __Permedia2TagTexel0;
                    
                    x = 0;
                    
                    while (x++ < cxGlyph)
                    {
                        ULONG   pixels = *pjGlyph++;
                        ULONG   alpha = pixels & 0xf0;
                        
                        alpha |= alpha >> 4;
                        
                        ULONG   pixel;

                        pixel = (alpha << 24) | 0xffffff;

                        *pBuffer++ = pixel;
                        
                        if(x++ < cxGlyph)
                        {
                            alpha = pixels & 0xf;
                            alpha |= alpha << 4;
                            
                            pixel = (alpha << 24) | 0xffffff;
                            
                            *pBuffer++ = pixel;
                            
                        }
                        
                    }
                    
                    InputBufferCommit(ppdev, pBuffer);
                    
                }
                
                DBG_GDI((7, "bClippedAAText: download completed"));
                
            ContinueGlyphs:
    
                if (--cGlyph == 0)
                    break;
                
                DBG_GDI((7, "bClippedAAText: %d still to render", cGlyph));
                
                // Get ready for next glyph:
                pgp++;
                pgb = pgp->pgdf->pgb;
                
                if (ulCharInc == 0)
                {
                    ptlOrigin.x = pgp->ptl.x + pgb->ptlOrigin.x;
                    ptlOrigin.y = pgp->ptl.y + pgb->ptlOrigin.y;
                }
                else
                {
                    ptlOrigin.x += ulCharInc;
                }
            
            }
        }
        
    } while (bMore);

    // reset the scissor. default is the whole of VRAM.

    DBG_GDI((20, "bClippedAAText: resetting scissor clip"));
    
    InputBufferReserve(ppdev, 10, &pBuffer);

    pBuffer[0] = __Permedia2TagScissorMode;
    pBuffer[1] = SCREEN_SCISSOR_DEFAULT;
    pBuffer[2] = __Permedia2TagDitherMode;
    pBuffer[3] = __PERMEDIA_DISABLE;
    pBuffer[4] = __Permedia2TagAlphaBlendMode;
    pBuffer[5] = __PERMEDIA_DISABLE;
    pBuffer[6] = __Permedia2TagTextureColorMode;
    pBuffer[7] = __PERMEDIA_DISABLE;
    pBuffer[8] = __Permedia2TagColorDDAMode;
    pBuffer[9] = __PERMEDIA_DISABLE;

    pBuffer += 10;

    InputBufferCommit(ppdev, pBuffer);

    DBG_GDI((7, "bClippedText: exited"));

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\sync.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: sync.c
*
* Surface synchronization support.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "precomp.h"
#include "gdi.h"

//-----------------------------Public*Routine----------------------------------
//
// VOID DrvSynchronizeSurface(pso, prcl, fl)
//
// DrvSynchronizeSurface allows drawing operations performed on the specified
// surface by a device's coprocessor to be coordinated with GDI.
//
// Parameters
//  pso---------Points to a SURFOBJ that identifies the surface on which the
//              drawing synchronization is to occur. 
//  prcl--------Specifies a rectangle on the surface that GDI will draw into, or
//              NULL. If this does not collide with the drawing operation in
//              progress, the driver can elect to let GDI draw without waiting
//              for the coprocessor to complete. 
//  fl----------Flag 
//
// Comments
//  DrvSynchronize can be optionally implemented in graphics drivers. It is
//  intended to support devices that use a coprocessor for drawing. Such a
//  device can start a long drawing operation and return to GDI while the
//  operation continues. If the device driver does not perform all drawing
//  operations to the surface, it is possible that a subsequent drawing
//  operation will be handled by GDI. In this case, it is necessary for GDI
//  to wait for the coprocessor to complete its work before drawing on the
//  surface. DrvSynchronize is not an output function.
//
//  This function is only called if it is hooked by EngAssociateSurface.
//  GDI will call DrvSynchronizeSurface()
//   1. before rendering to any device managed surface
//   2. when at timer event occurs and GCAPS2_SYNCTIMER was specified passing
//      the desktop surface and specifying DSS_TIMER_EVENT
//   3. when a flush evern occurs and GCAPS2_SYNCFLUSH was specified passing
//      the desktip surface and specifying DSS_FLUSH_EVENT
//
//  The function should return when it is safe for GDI to draw on the surface.
//
//  Per surface synchronization enables hardware which uses a graphics
//  acceleration queue model to flush the acceleration queue only to the extent
//  that is neccessary.  That is, it only has to flush up to the last
//  queue entry that references the given surface.
//
//  GDI will call DrvSynchronizeSurface instead of DrvSynchronize in drivers
//  that implement both of these functions. DrvSynchronize is called (and
//  shouuld be provided) only if DrvSyncrhoizeSurface is not provided.
//
//-----------------------------------------------------------------------------
VOID
DrvSynchronizeSurface(SURFOBJ*  pso,
                      RECTL*    prcl,
                      FLONG     fl)
{
    Surf  *psurf;
    PDev   *ppdev = (PDev *) pso->dhpdev;
    
    ASSERTDD(pso->dhsurf != NULL,
                "DrvSynchronizeSurface: called with GDI managed surface");

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvSynchronizeSurface: re-entered! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;

#endif
//@@END_DDKSPLIT
    
    psurf = (Surf *) pso->dhsurf;

    if ( fl & (DSS_FLUSH_EVENT | DSS_TIMER_EVENT) )
    {
        if(ppdev->bGdiContext && ppdev->bNeedSync)
        {
            if(ppdev->bForceSwap)
            {
                ppdev->bForceSwap = FALSE;
                InputBufferSwap(ppdev);
            }
            else
                InputBufferFlush(ppdev);
        }
        goto done;
    }
    else if ( psurf->flags & SF_VM )
    {
        // If we only had a hardware acceleration queue with per surface
        // reference counting perhaps we could sync to this passed in surface

        // for now just fall through to below
    }

    // we don't have per surface synchronization ... always sync the entire
    // dma buffer

    if(ppdev->bGdiContext)
    {
        InputBufferSync(ppdev);
    }
    else
    {
//@@BEGIN_DDKSPLIT
#if MULTITHREADED && DBG
        ppdev->pP2dma->ppdev = ppdev;
#endif
//@@END_DDKSPLIT
        vSyncWithPermedia(ppdev->pP2dma);
    }

done:

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\thunks.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: thunks.c
*
* This module contains the routines for dynamically loading the newly 
* added GDI exported APIs in the NT5.0 environment. By dynamic loading
* we enable the usage of the same binary on NT4.0.
*
* All the functions in this module should only be called on NT5.0. If called
* on NT4.0 in debug builds they will bugcheck.
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
*
\*****************************************************************************/

#include "precomp.h"
#include "gdi.h"
#include "directx.h"
#include "log.h"
#include "heap.h"

typedef BOOL
(*_EngAlphaBlend)(IN SURFOBJ *psoDest,
                  IN SURFOBJ *psoSrc,
                  IN CLIPOBJ *pco,
                  IN XLATEOBJ *pxlo,
                  IN RECTL *prclDest,
                  IN RECTL *prclSrc,
                  IN BLENDOBJ *pBlendObj);

typedef BOOL
(*_EngGradientFill)(IN SURFOBJ *psoDest,
                    IN CLIPOBJ *pco,
                    IN XLATEOBJ *pxlo,
                    IN TRIVERTEX *pVertex,
                    IN ULONG nVertex,
                    IN PVOID pMesh,
                    IN ULONG nMesh,
                    IN RECTL *prclExtents,
                    IN POINTL *pptlDitherOrg,
                    IN ULONG ulMode);

typedef BOOL
(*_EngTransparentBlt)(IN SURFOBJ *psoDst,
                      IN SURFOBJ *psoSrc,
                      IN CLIPOBJ *pco,
                      IN XLATEOBJ *pxlo,
                      IN RECTL *prclDst,
                      IN RECTL *prclSrc,
                      IN ULONG iTransparentColor,
                      IN ULONG ulReserved);

typedef PVOID
(*_EngMapFile)(IN LPWSTR pwsz,
               IN ULONG cjSize,
               IN ULONG_PTR *piFile);

typedef BOOL
(*_EngUnmapFile)(IN ULONG_PTR iFile);

typedef BOOL
(*_EngQuerySystemAttribute)(ENG_SYSTEM_ATTRIBUTE CapNum,
                            PDWORD pCapability);

typedef ULONG
(*_EngDitherColor)(HDEV hDev,
                   ULONG iMode,
                   ULONG rgb,
                   ULONG *pul);

typedef BOOL
(*_EngModifySurface)(HSURF hsurf,
                     HDEV hdev,
                     FLONG flHooks,
                     FLONG flSurface,
                     DHSURF dhSurf,
                     VOID* pvScan0,
                     LONG lDelta,
                     VOID* pvReserved);

typedef BOOL
(*_EngQueryDeviceAttribute)(HDEV hdev,
                            ENG_DEVICE_ATTRIBUTE devAttr,
                            VOID *pvIn,
                            ULONG ulInSize,
                            VOID *pvOut,
                            ULONG ulOutSize);

typedef FLATPTR
(*_HeapVidMemAllocAligned)(LPVIDMEM lpVidMem,
                           DWORD dwWidth,
                           DWORD dwHeight,
                           LPSURFACEALIGNMENT lpAlignment,
                           LPLONG lpNewPitch);

typedef void
(*_VidMemFree)(LPVMEMHEAP pvmh, FLATPTR ptr);

typedef ULONG
(*_EngHangNotification)(HDEV hdev,
                        PVOID Reserved);

static _EngAlphaBlend               pfnEngAlphaBlend = 0;
static _EngGradientFill             pfnEngGradientFill = 0;
static _EngTransparentBlt           pfnEngTransparentBlt = 0;
static _EngMapFile                  pfnEngMapFile = 0;
static _EngUnmapFile                pfnEngUnmapFile = 0;
static _EngQuerySystemAttribute     pfnEngQuerySystemAttribute = 0;
static _EngDitherColor              pfnEngDitherColor = 0;
static _EngModifySurface            pfnEngModifySurface = 0;
static _EngQueryDeviceAttribute     pfnEngQueryDeviceAttribute = 0;
static _HeapVidMemAllocAligned      pfnHeapVidMemAllocAligned = 0;
static _VidMemFree                  pfnVidMemFree = 0;
static _EngHangNotification         pfnEngHangNotification = 0;

#define LOADTHUNKFUNC(x)\
    pfn##x = (_##x)EngFindImageProcAddress(0,#x);\
    ASSERTDD(pfn##x != 0, #x"thunk NULL");\
    if(pfn##x == 0)\
        return FALSE;

//-----------------------------------------------------------------------------
//
// void bEnableThunks
//
//-----------------------------------------------------------------------------
BOOL
bEnableThunks()
{
    ASSERTDD(g_bOnNT40 == FALSE, "bEnableThunks: called on NT4.0");

    LOADTHUNKFUNC(EngAlphaBlend);
    LOADTHUNKFUNC(EngGradientFill);
    LOADTHUNKFUNC(EngTransparentBlt);
    LOADTHUNKFUNC(EngMapFile);
    LOADTHUNKFUNC(EngUnmapFile);
    LOADTHUNKFUNC(EngQuerySystemAttribute);
    LOADTHUNKFUNC(EngDitherColor);
    LOADTHUNKFUNC(EngModifySurface);
    LOADTHUNKFUNC(EngQueryDeviceAttribute);
    LOADTHUNKFUNC(HeapVidMemAllocAligned);
    LOADTHUNKFUNC(VidMemFree);
    
    pfnEngHangNotification = 
        (_EngHangNotification)EngFindImageProcAddress(0,"EngHangNotification");

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// BOOL THUNK_EngAlphaBlend
//
//-----------------------------------------------------------------------------
BOOL
THUNK_EngAlphaBlend(IN SURFOBJ *psoDest,
                    IN SURFOBJ *psoSrc,
                    IN CLIPOBJ *pco,
                    IN XLATEOBJ *pxlo,
                    IN RECTL *prclDest,
                    IN RECTL *prclSrc,
                    IN BLENDOBJ *pBlendObj)
{
    ASSERTDD(g_bOnNT40 == FALSE, "EngAlphaBlend called on NT4.0");

    return (*pfnEngAlphaBlend)(psoDest,
                               psoSrc,
                               pco,
                               pxlo,
                               prclDest,
                               prclSrc,
                               pBlendObj);
}

//-----------------------------------------------------------------------------
//
// BOOL THUNK_EngGradientFill
//
//-----------------------------------------------------------------------------
BOOL
THUNK_EngGradientFill(IN SURFOBJ *psoDest,
                      IN CLIPOBJ *pco,
                      IN XLATEOBJ *pxlo,
                      IN TRIVERTEX *pVertex,
                      IN ULONG nVertex,
                      IN PVOID pMesh,
                      IN ULONG nMesh,
                      IN RECTL *prclExtents,
                      IN POINTL *pptlDitherOrg,
                      IN ULONG ulMode)
{
    ASSERTDD(g_bOnNT40 == FALSE, "EngGradientFill called on NT4.0");

    return (*pfnEngGradientFill)(psoDest,
                                 pco,
                                 pxlo,
                                 pVertex,
                                 nVertex,
                                 pMesh,
                                 nMesh,
                                 prclExtents,
                                 pptlDitherOrg,
                                 ulMode);
}

//-----------------------------------------------------------------------------
//
// BOOL THUNK_EngTransparentBlt
//
//-----------------------------------------------------------------------------
BOOL
THUNK_EngTransparentBlt(IN SURFOBJ *psoDst,
                        IN SURFOBJ *psoSrc,
                        IN CLIPOBJ *pco,
                        IN XLATEOBJ *pxlo,
                        IN RECTL *prclDst,
                        IN RECTL *prclSrc,
                        IN ULONG iTransparentColor,
                        IN ULONG ulReserved)
{
    ASSERTDD(g_bOnNT40 == FALSE, "EngTransparentBlt called on NT4.0");

    return (*pfnEngTransparentBlt)(psoDst,
                                   psoSrc,
                                   pco,
                                   pxlo,
                                   prclDst,
                                   prclSrc,
                                   iTransparentColor,
                                   ulReserved);
}

//-----------------------------------------------------------------------------
//
// PVOID THUNK_EngMapFile
//
//-----------------------------------------------------------------------------
PVOID
THUNK_EngMapFile(IN LPWSTR pwsz,
                 IN ULONG cjSize,
                 IN ULONG_PTR *piFile)
{
    ASSERTDD(g_bOnNT40 == FALSE, "EngMapFile called on NT4.0");
    return (*pfnEngMapFile)(pwsz,cjSize,piFile);
}

//-----------------------------------------------------------------------------
//
// BOOL THUNK_EngUnmapFile
//
//-----------------------------------------------------------------------------
BOOL
THUNK_EngUnmapFile(IN ULONG_PTR iFile)
{
    ASSERTDD(g_bOnNT40 == FALSE, "EngUnmapFile called on NT4.0");
    return (*pfnEngUnmapFile)(iFile);
}

//-----------------------------------------------------------------------------
//
// BOOL THUNK_EngQuerySystemAttribute
//
//-----------------------------------------------------------------------------
BOOL
THUNK_EngQuerySystemAttribute(ENG_SYSTEM_ATTRIBUTE CapNum,
                              PDWORD pCapability)
{
    ASSERTDD(g_bOnNT40 == 0, "EngQuerySystemAttribute called on NT4.0");
    return (*pfnEngQuerySystemAttribute)(CapNum,pCapability);
}

//-----------------------------------------------------------------------------
//
// ULONG THUNK_EngDitherColor
//
//-----------------------------------------------------------------------------
ULONG
THUNK_EngDitherColor(HDEV hDev,
                     ULONG iMode,
                     ULONG rgb,
                     ULONG *pul)
{
    ASSERTDD(g_bOnNT40 == FALSE, "EngDitherColor called on NT4.0");
    return (*pfnEngDitherColor)(hDev,
                                iMode,
                                rgb,
                                pul);
}

//-----------------------------------------------------------------------------
//
// BOOL THUNK_EngModifySurface
//
//-----------------------------------------------------------------------------
BOOL
THUNK_EngModifySurface(HSURF hsurf,
                       HDEV hdev,
                       FLONG flHooks,
                       FLONG flSurface,
                       DHSURF dhSurf,
                       VOID* pvScan0,
                       LONG lDelta,
                       VOID* pvReserved)
{
    ASSERTDD(g_bOnNT40 == FALSE, "EngModifySurface called on NT4.0");
    return (*pfnEngModifySurface)(hsurf,
                                  hdev,
                                  flHooks,
                                  flSurface,
                                  dhSurf,
                                  pvScan0,
                                  lDelta,
                                  pvReserved);
}

//-----------------------------------------------------------------------------
//
// BOOL THUNK_EngQueryDeviceAttribute
//
//-----------------------------------------------------------------------------
BOOL
THUNK_EngQueryDeviceAttribute(HDEV hdev,
                              ENG_DEVICE_ATTRIBUTE devAttr,
                              VOID *pvIn,
                              ULONG ulInSize,
                              VOID *pvOut,
                              ULONG ulOutSize)
{
    ASSERTDD(g_bOnNT40 == FALSE, "EngQueryDeviceAttribute called on NT4.0");
    return (*pfnEngQueryDeviceAttribute)(hdev,
                                         devAttr,
                                         pvIn,
                                         ulInSize,
                                         pvOut,
                                         ulOutSize);
}

//-----------------------------------------------------------------------------
//
// FLATPTR THUNK_HeapVidMemAllocAligned 
//
//-----------------------------------------------------------------------------
FLATPTR
THUNK_HeapVidMemAllocAligned(LPVIDMEM lpVidMem,
                             DWORD dwWidth,
                             DWORD dwHeight,
                             LPSURFACEALIGNMENT lpAlignment,
                             LPLONG lpNewPitch)
{
    ASSERTDD(g_bOnNT40 == FALSE, "HeapVidMemAllocAligned called on NT4.0");
    return (*pfnHeapVidMemAllocAligned)(lpVidMem,
                                        dwWidth,
                                        dwHeight,
                                        lpAlignment,
                                        lpNewPitch);
}

//-----------------------------------------------------------------------------
//
// void THUNK_VidMemFree
//
//-----------------------------------------------------------------------------
void
THUNK_VidMemFree(LPVMEMHEAP pvmh,
                 FLATPTR ptr)
{
    ASSERTDD(g_bOnNT40 == FALSE, "VidMemFree called on NT4.0");
    (*pfnVidMemFree)(pvmh,ptr);
}

//-----------------------------------------------------------------------------
//
// ULONG THUNK_EngHangNotifiation
//
//-----------------------------------------------------------------------------
ULONG
THUNK_EngHangNotification(HDEV hdev,
                          PVOID Reserved)
{
    return (pfnEngHangNotification != NULL) ?
            (*pfnEngHangNotification)(hdev,
                                     Reserved) :
            EHN_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\textout.c ===
/**********************************Module*Header********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: textout.c
 *
 * Text rendering module.
 *
 * Uses glyph expansion method.
 *
 * There are three basic methods for drawing text with hardware
 * acceleration:
 *
 * 1) Glyph caching -- Glyph bitmaps are cached by the accelerator
 *       (probably in off-screen memory), and text is drawn by
 *       referring the hardware to the cached glyph locations.
 * 
 * 2) Glyph expansion -- Each individual glyph is colour-expanded
 *       directly to the screen from the monochrome glyph bitmap
 *       supplied by GDI.
 * 
 * 3) Buffer expansion -- The CPU is used to draw all the glyphs into
 *       a 1bpp monochrome bitmap, and the hardware is then used
 *       to colour-expand the result.
 * 
 * The fastest method depends on a number of variables, such as the
 * colour expansion speed, bus speed, CPU speed, average glyph size,
 * and average string length.
 * 
 * Currently we are using glyph expansion.  We will revisit this in the
 * next several months measuring the performance of text on the latest
 * hardware and the latest benchmarks.
 *
 * Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
 ******************************************************************************/
 
#include "precomp.h"
#include "gdi.h"

#include "clip.h"
#include "text.h"
#include "log.h"
#define ALLOC_TAG ALLOC_TAG_XT2P

#define GLYPH_CACHE_HEIGHT  48  // Number of scans to allocate for glyph cache,
                                //   divided by pel size

#define GLYPH_CACHE_CX      64  // Maximal width of glyphs that we'll consider
                                //   caching

#define GLYPH_CACHE_CY      64  // Maximum height of glyphs that we'll consider
                                //   caching

#define MAX_GLYPH_SIZE      ((GLYPH_CACHE_CX * GLYPH_CACHE_CY + 31) / 8)
                                // Maximum amount of off-screen memory required
                                //   to cache a glyph, in bytes

#define GLYPH_ALLOC_SIZE    8100
                                // Do all cached glyph memory allocations
                                //   in 8k chunks

#define HGLYPH_SENTINEL     ((ULONG) -1)
                                // GDI will never give us a glyph with a
                                //   handle value of 0xffffffff, so we can
                                //   use this as a sentinel for the end of
                                //   our linked lists

#define GLYPH_HASH_SIZE     256

#define GLYPH_HASH_FUNC(x)  ((x) & (GLYPH_HASH_SIZE - 1))

typedef struct _CACHEDGLYPH CACHEDGLYPH;
typedef struct _CACHEDGLYPH
{
    CACHEDGLYPH*    pcgNext;    // Points to next glyph that was assigned
                                //   to the same hash table bucket
    HGLYPH          hg;         // Handles in the bucket-list are kept in
                                //   increasing order
    POINTL          ptlOrigin;  // Origin of glyph bits

    // Device specific fields below here:

    LONG            cx;         // Glyph width 
    LONG            cy;         // Glyph height 
    LONG            cd;         // Number of dwords to be transferred
    ULONG           cycx;
    ULONG           tag;
    ULONG           ad[1];      // Start of glyph bits
} CACHEDGLYPH;  /* cg, pcg */

typedef struct _GLYPHALLOC GLYPHALLOC;
typedef struct _GLYPHALLOC
{
    GLYPHALLOC*     pgaNext;    // Points to next glyph structure that
                                //   was allocated for this font
    CACHEDGLYPH     acg[1];     // This array is a bit misleading, because
                                //   the CACHEDGLYPH structures are actually
                                //   variable sized
} GLYPHAALLOC;  /* ga, pga */

typedef struct _CACHEDFONT CACHEDFONT;
typedef struct _CACHEDFONT
{
    CACHEDFONT*     pcfNext;    // Points to next entry in CACHEDFONT list
    CACHEDFONT*     pcfPrev;    // Points to previous entry in CACHEDFONT list
    GLYPHALLOC*     pgaChain;   // Points to start of allocated memory list
    CACHEDGLYPH*    pcgNew;     // Points to where in the current glyph
                                //   allocation structure a new glyph should
                                //   be placed
    LONG            cjAlloc;    // Bytes remaining in current glyph allocation
                                //   structure
    CACHEDGLYPH     cgSentinel; // Sentinel entry of the end of our bucket
                                //   lists, with a handle of HGLYPH_SENTINEL
    CACHEDGLYPH*    apcg[GLYPH_HASH_SIZE];
                                // Hash table for glyphs

} CACHEDFONT;   /* cf, pcf */

RECTL grclMax = { 0, 0, 0x8000, 0x8000 };
                                // Maximal clip rectangle for trivial clipping

BYTE gajBit[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };
                                // Converts bit index to set bit

//-----------------------------Private-Routine----------------------------------
// pcfAllocateCachedFont
//     ppdev (I) - PDev pointer
//
// Initializes our font data structure.
//
//------------------------------------------------------------------------------

CACHEDFONT* pcfAllocateCachedFont(
PDev* ppdev)
{
    CACHEDFONT*     pcf;
    CACHEDGLYPH**   ppcg;
    LONG            i;

    pcf = (CACHEDFONT*) ENGALLOCMEM(FL_ZERO_MEMORY, sizeof(CACHEDFONT), ALLOC_TAG);

    if (pcf != NULL)
    {
        //
        // Note that we rely on FL_ZERO_MEMORY to zero 'pgaChain' and
        // 'cjAlloc':
        //
        pcf->cgSentinel.hg = HGLYPH_SENTINEL;

        //
        // Initialize the hash table entries to all point to our sentinel:
        //
        for (ppcg = &pcf->apcg[0], i = GLYPH_HASH_SIZE; i != 0; i--, ppcg++)
        {
            *ppcg = &pcf->cgSentinel;
        }
    }

    return(pcf);
}

//-----------------------------Private-Routine----------------------------------
// vTrimAndBitpackGlyph
//     pjBuf (I) - where to stick the trimmed and bit-packed glyph
//     pjGlyph (I) - points to the glyphs bits as given by GDI
//     pcxGlyph (O) - returns the trimmed width of the glyph
//     pcyGlyph (O) - returns the trimmed height of the glyph
//     pptlOrigin (O) - returns the trimmed origin of the glyph
//     pcj (O) - returns the number of bytes in the trimmed glyph
//
// This routine takes a GDI byte-aligned glyphbits definition, trims off
// any unused pixels on the sides, and creates a bit-packed result that
// is a natural for the S3's monochrome expansion capabilities.  
// "Bit-packed" is where a small monochrome bitmap is packed with no 
// unused bits between strides.  So if GDI gives us a 16x16 bitmap to 
// represent '.' that really only has a 2x2 array of lit pixels, we would
// trim the result to give a single byte value of 0xf0.
//
// Use this routine if your monochrome expansion hardware can do bit-packed
// expansion (this is the fastest method).  If your hardware requires byte-,
// word-, or dword-alignment on monochrome expansions, use 
// vTrimAndPackGlyph().
//
//------------------------------------------------------------------------------

VOID vTrimAndBitpackGlyph(
BYTE*   pjBuf,          // Note: Routine may touch preceding byte!
BYTE*   pjGlyph,
LONG*   pcxGlyph,
LONG*   pcyGlyph,
POINTL* pptlOrigin,
LONG*   pcj)            // For returning the count of bytes of the result
{
    LONG    cxGlyph;
    LONG    cyGlyph;
    POINTL  ptlOrigin;
    LONG    cAlign;
    LONG    lDelta;
    BYTE*   pj;
    BYTE    jBit;
    LONG    cjSrcWidth;
    LONG    lSrcSkip;
    LONG    lDstSkip;
    LONG    cRem;
    BYTE*   pjSrc;
    BYTE*   pjDst;
    LONG    i;
    LONG    j;
    BYTE    jSrc;
    LONG    cj;

    ///////////////////////////////////////////////////////////////
    // Trim the glyph

    cyGlyph   = *pcyGlyph;
    cxGlyph   = *pcxGlyph;
    ptlOrigin = *pptlOrigin;
    cAlign    = 0;

    lDelta = (cxGlyph + 7) >> 3;

    //
    // Trim off any zero rows at the bottom of the glyph:
    //
    pj = pjGlyph + cyGlyph * lDelta;    // One past last byte in glyph
    while (cyGlyph > 0)
    {
        i = lDelta;
        do {
            if (*(--pj) != 0)
                goto Done_Bottom_Trim;
        } while (--i != 0);

        // The entire last row has no lit pixels, so simply skip it:

        cyGlyph--;
    }

    ASSERTDD(cyGlyph == 0, "cyGlyph should only be zero here");

    //
    // We found a space character.  Set both dimensions to zero, so
    // that it's easy to special-case later:
    //
    cxGlyph = 0;

Done_Bottom_Trim:

    //
    // If cxGlyph != 0, we know that the glyph has at least one non-zero
    // row and column.  By exploiting this knowledge, we can simplify our
    // end-of-loop tests, because we don't have to check to see if we've
    // decremented either 'cyGlyph' or 'cxGlyph' to zero:
    //
    if (cxGlyph != 0)
    {
        //
        // Trim off any zero rows at the top of the glyph:
        //

        pj = pjGlyph;                       // First byte in glyph
        while (TRUE)
        {
            i = lDelta;
            do {
                if (*(pj++) != 0)
                    goto Done_Top_Trim;
            } while (--i != 0);

            //
            // The entire first row has no lit pixels, so simply skip it:
            //

            cyGlyph--;
            ptlOrigin.y++;
            pjGlyph = pj;
        }

Done_Top_Trim:

        //
        // Trim off any zero columns at the right edge of the glyph:
        //

        while (TRUE)
        {
            j    = cxGlyph - 1;

            pj   = pjGlyph + (j >> 3);      // Last byte in first row of glyph
            jBit = gajBit[j & 0x7];
            i    = cyGlyph;

            do {
                if ((*pj & jBit) != 0)
                    goto Done_Right_Trim;

                pj += lDelta;
            } while (--i != 0);

            //
            // The entire last column has no lit pixels, so simply skip it:
            //

            cxGlyph--;
        }

Done_Right_Trim:

        //
        // Trim off any zero columns at the left edge of the glyph:
        //

        while (TRUE)
        {
            pj   = pjGlyph;                 // First byte in first row of glyph
            jBit = gajBit[cAlign];
            i    = cyGlyph;

            do {
                if ((*pj & jBit) != 0)
                    goto Done_Left_Trim;

                pj += lDelta;
            } while (--i != 0);

            //
            // The entire first column has no lit pixels, so simply skip it:
            //

            ptlOrigin.x++;
            cxGlyph--;
            cAlign++;
            if (cAlign >= 8)
            {
                cAlign = 0;
                pjGlyph++;
            }
        }
    }

Done_Left_Trim:

    ///////////////////////////////////////////////////////////////
    // Pack the glyph

    cjSrcWidth  = (cxGlyph + cAlign + 7) >> 3;
    lSrcSkip    = lDelta - cjSrcWidth;
    lDstSkip    = ((cxGlyph + 7) >> 3) - cjSrcWidth - 1;
    cRem        = ((cxGlyph - 1) & 7) + 1;   // 0 -> 8

    pjSrc       = pjGlyph;
    pjDst       = pjBuf;

    //
    // Zero the buffer, because we're going to 'or' stuff into it:
    //

    memset(pjBuf, 0, (cxGlyph * cyGlyph + 7) >> 3);

    //
    // cAlign used to indicate which bit in the first byte of the unpacked
    // glyph was the first non-zero pixel column.  Now, we flip it to
    // indicate which bit in the packed byte will receive the next non-zero
    // glyph bit:
    //

    cAlign = (-cAlign) & 0x7;
    if (cAlign > 0)
    {
        //
        // It would be bad if our trimming calculations were wrong, because
        // we assume any bits to the left of the 'cAlign' bit will be zero.
        // As a result of this decrement, we will 'or' those zero bits into
        // whatever byte precedes the glyph bits array:
        //

        pjDst--;

        ASSERTDD((*pjSrc >> cAlign) == 0, "Trimmed off too many bits");
    }

    for (i = cyGlyph; i != 0; i--)
    {
        for (j = cjSrcWidth; j != 0; j--)
        {
            //
            // Note that we may modify a byte past the end of our
            // destination buffer, which is why we reserved an
            // extra byte:
            //

            jSrc = *pjSrc;
            *(pjDst)     |= (jSrc >> (cAlign));
            *(pjDst + 1) |= (jSrc << (8 - cAlign));
            pjSrc++;
            pjDst++;
        }

        pjSrc  += lSrcSkip;
        pjDst  += lDstSkip;
        cAlign += cRem;

        if (cAlign >= 8)
        {
            cAlign -= 8;
            pjDst++;
        }
    }

    cj = ((cxGlyph * cyGlyph) + 7) >> 3;

    ///////////////////////////////////////////////////////////////
    // Post-process the packed results to account for the Permedia's
    // preference for big-endian data on dword transfers.  If your
    // hardware doesn't need big-endian data, remove this step.

    for (pjSrc = pjBuf, i = (cj + 3) >> 2; i != 0; pjSrc += 4, i--)
    {
        jSrc = *(pjSrc);
        *(pjSrc) = *(pjSrc + 3);
        *(pjSrc + 3) = jSrc;

        jSrc = *(pjSrc + 1);
        *(pjSrc + 1) = *(pjSrc + 2);
        *(pjSrc + 2) = jSrc;
    }

    ///////////////////////////////////////////////////////////////
    // Return results

    *pcxGlyph   = cxGlyph;
    *pcyGlyph   = cyGlyph;
    *pptlOrigin = ptlOrigin;
    *pcj        = cj;
}

//-----------------------------Private-Routine----------------------------------
// cjPutGlyphInCache
//     ppdev (I) - pointer to physical device object
//     pcg (I) - our cache structure for this glyph
//     pgb (I) - GDI's glyph bits
//
// Figures out where to stick a glyph in the cache, copies it
// there, and fills in any other data we'll need to display the glyph.
//
// This routine is rather device-specific, and will have to be extensively
// modified for other display adapters.
//
// Returns the number of bytes taken by the cached glyph bits.
//
//------------------------------------------------------------------------------

LONG cjPutGlyphInCache(
PDev*           ppdev,
CACHEDGLYPH*    pcg,
GLYPHBITS*      pgb)
{
    BYTE*   pjGlyph;
    LONG    cxGlyph;
    LONG    cyGlyph;
    POINTL  ptlOrigin;
    BYTE*   pjSrc;
    ULONG*  pulDst;
    LONG    i;
    LONG    cPels;
    ULONG   ulGlyphThis;
    ULONG   ulGlyphNext;
    ULONG   ul;
    ULONG   ulStart;
    LONG    cj;

    pjGlyph   = pgb->aj;
    cyGlyph   = pgb->sizlBitmap.cy;
    cxGlyph   = pgb->sizlBitmap.cx;
    ptlOrigin = pgb->ptlOrigin;

    vTrimAndBitpackGlyph((BYTE*) &pcg->ad, pjGlyph, &cxGlyph, &cyGlyph,
                         &ptlOrigin, &cj);

    ///////////////////////////////////////////////////////////////
    // Initialize the glyph fields

    pcg->cd          = (cj + 3) >> 2;
    
    // We send an extra long to reset the BitMaskPattern register if we
    // have any unused bits in the last long.

    if(((cxGlyph * cyGlyph) & 0x1f) != 0)
        pcg->cd++;

    pcg->ptlOrigin   = ptlOrigin;
    pcg->cx          = cxGlyph;
    pcg->cy          = cyGlyph;
    pcg->cycx        = (cyGlyph << 16) | cxGlyph;
    pcg->tag         = ((pcg->cd - 1) << 16) | __Permedia2TagBitMaskPattern;

    return(cj);
}

//-----------------------------Private-Routine----------------------------------
// pcgNew
//     ppdev (I) - pointer to physical device object
//     pcf (I) - our cache structure for this font
//     pgp (I) - GDI's glyph position
//
// Creates a new CACHEDGLYPH structure for keeping track of the glyph in
// off-screen memory.  bPutGlyphInCache is called to actually put the glyph
// in off-screen memory.
//
// This routine should be reasonably device-independent, as bPutGlyphInCache
// will contain most of the code that will have to be modified for other
// display adapters.
//
//------------------------------------------------------------------------------

CACHEDGLYPH* pcgNew(
PDev*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgp)
{
    GLYPHBITS*      pgb;
    GLYPHALLOC*     pga;
    CACHEDGLYPH*    pcg;
    LONG            cjCachedGlyph;
    HGLYPH          hg;
    LONG            iHash;
    CACHEDGLYPH*    pcgFind;
    LONG            cjGlyphRow;
    LONG            cj;

    //
    // First, calculate the amount of storage we'll need for this glyph:
    //

    pgb = pgp->pgdf->pgb;

    //
    // The glyphs are 'word-packed':
    //

    cjGlyphRow    = ((pgb->sizlBitmap.cx + 15) & ~15) >> 3;
    cjCachedGlyph = sizeof(CACHEDGLYPH) + (pgb->sizlBitmap.cy * cjGlyphRow);

    //
    // Reserve an extra byte at the end for temporary usage by our pack
    // routine:
    //

    cjCachedGlyph++;

    if (cjCachedGlyph > pcf->cjAlloc)
    {
        //
        // Have to allocate a new glyph allocation structure:
        //

        pga = (GLYPHALLOC*) ENGALLOCMEM(FL_ZERO_MEMORY, GLYPH_ALLOC_SIZE, ALLOC_TAG);
        if (pga == NULL)
        {
            //
            // It's safe to return at this time because we haven't
            // fatally altered any of our data structures:
            //

            return(NULL);
        }

        //
        // Add this allocation to the front of the allocation linked list,
        // so that we can free it later:
        //

        pga->pgaNext  = pcf->pgaChain;
        pcf->pgaChain = pga;

        //
        // Now we've got a chunk of memory where we can store our cached
        // glyphs:
        //

        pcf->pcgNew  = &pga->acg[0];
        pcf->cjAlloc = GLYPH_ALLOC_SIZE - (sizeof(*pga) - sizeof(pga->acg[0]));

        // Hack: we want to be able to safely read past the glyph data by
        //       one DWORD.  We ensure we can do this by not allocating
        //       the last DWORD out of the glyph cache block.  This is needed
        //       by glyphs which have unused bits in the last DWORD causing
        //       us to have to send an extra DWORD to reset the mask register.

        pcf->cjAlloc -= sizeof(DWORD);

        //
        // It would be bad if we let in any glyphs that would be bigger
        // than our basic allocation size:
        //

        ASSERTDD(cjCachedGlyph <= GLYPH_ALLOC_SIZE, "Woah, this is one big glyph!");
    }

    pcg = pcf->pcgNew;

    ///////////////////////////////////////////////////////////////
    // Insert the glyph, in-order, into the list hanging off our hash
    // bucket:

    hg = pgp->hg;

    pcg->hg = hg;
    iHash   = GLYPH_HASH_FUNC(hg);
    pcgFind = pcf->apcg[iHash];

    if (pcgFind->hg > hg)
    {
        pcf->apcg[iHash] = pcg;
        pcg->pcgNext     = pcgFind;
    }
    else
    {
        //
        // The sentinel will ensure that we never fall off the end of
        // this list:
        //

        while (pcgFind->pcgNext->hg < hg)
            pcgFind = pcgFind->pcgNext;

        //
        // 'pcgFind' now points to the entry to the entry after which
        // we want to insert our new node:
        //

        pcg->pcgNext     = pcgFind->pcgNext;
        pcgFind->pcgNext = pcg;
    }

    cj = cjPutGlyphInCache(ppdev, pcg, pgp->pgdf->pgb);

    ///////////////////////////////////////////////////////////////
    // We now know the size taken up by the packed and trimmed glyph;
    // adjust the pointer to the next glyph accordingly.  We only need
    // to ensure 'dword' alignment:

    cjCachedGlyph = sizeof(CACHEDGLYPH) + ((cj + 7) & ~7);

    pcf->pcgNew   = (CACHEDGLYPH*) ((BYTE*) pcg + cjCachedGlyph);
    pcf->cjAlloc -= cjCachedGlyph;

    return(pcg);
}


//------------------------------------------------------------------------------
// bCachedProportionalText
//
// Renders an array of proportional glyphs using the glyph cache
//
// ppdev-----pointer to physical device object
// pgp-------array of glyphs to render (all members of the pcf font)
// cGlyph----number of glyphs to render
//
// Returns TRUE if the glyphs were rendered
//------------------------------------------------------------------------------

BOOL bCachedProportionalText(
    PDev*       ppdev,
    CACHEDFONT* pcf,
    GLYPHPOS*   pgp,
    LONG        cGlyph)
{
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    LONG            x;
    LONG            cy;
    ULONG           i;
    ULONG*          pd;
    ULONG*          pBuffer;
    ULONG*          pReservationEnd;
    ULONG*          pBufferEnd;
    BOOL            bRet = TRUE;        // assume success
    
    InputBufferStart(ppdev, 2, &pBuffer, &pBufferEnd, &pReservationEnd);

    // Reset BitMaskPattern in case there are some unused bits from
    // a previous command.
//@@BEGIN_DDKSPLIT
    // TODO: fix all other uses of SYNC_ON_BIT_MASK so that we don't
    // need to always do this here
//@@END_DDKSPLIT
    pBuffer[0] = __Permedia2TagBitMaskPattern;
//@@BEGIN_DDKSPLIT
    // TODO: remove the setting of pBuffer[1] (it can be garbage) when
    //       we implement the scratch buffer for handling the non-DMA
    //       case.
//@@END_DDKSPLIT    
    pBuffer[1] = 0;
    pBuffer = pReservationEnd;

    do {
        //
        // First lookup the glyph in our cache
        //
        hg  = pgp->hg;
        pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

        while (pcg->hg < hg)
            pcg = pcg->pcgNext; // Traverse collision list, if any

        if (pcg->hg > hg)
        {
            //
            // This will hopefully not be the common case (that is,
            // we will have a high cache hit rate), so if I were
            // writing this in Asm I would have this out-of-line
            // to avoid the jump around for the common case.
            // But the Pentium has branch prediction, so what the
            // heck.
            //
            pcg = pcgNew(ppdev, pcf, pgp);
            if (pcg == NULL)
            {
                bRet= FALSE;
                goto done;
            }
        }

        //
        // Space glyphs are trimmed to a height of zero, and we don't
        // even have to touch the hardware for them:
        //
        cy = pcg->cy;

        if (cy > 0)
        {
            ASSERTDD((pcg->cd <= (MAX_P2_FIFO_ENTRIES - 5)) &&
                     (MAX_GLYPH_SIZE / 4) <= (MAX_P2_FIFO_ENTRIES - 5),
                "Ack, glyph too large for FIFO!");

            //
            // NOTE: We send an extra bit mask pattern to reset the register.
            //       If we don't do this then a subsequent SYNC_ON_BIT_MASK
            //       will use these unused bits.
            //
//@@BEGIN_DDKSPLIT
            // TODO: We could further optimize this by noting that we only
            //       have to send the extra bit mask pattern DWORD if there
            //       are unused bits.  We could also play with the height
            //       width to make it so that this case becomes more common
            //
//@@END_DDKSPLIT
            ULONG   ulLongs = 7 + pcg->cd;

            InputBufferContinue(ppdev, ulLongs, &pBuffer, &pBufferEnd, &pReservationEnd);
            
            pBuffer[0] = __Permedia2TagRectangleOrigin;
            pBuffer[1] = ((pgp->ptl.y + pcg->ptlOrigin.y) << 16) |
                      (pgp->ptl.x + pcg->ptlOrigin.x);
            pBuffer[2] = __Permedia2TagRectangleSize;
            pBuffer[3] = pcg->cycx;
            pBuffer[4] = __Permedia2TagRender;
            pBuffer[5] = __RENDER_RECTANGLE_PRIMITIVE | __RENDER_SYNC_ON_BIT_MASK
                    | __RENDER_INCREASE_X | __RENDER_INCREASE_Y;
            pBuffer[6] = pcg->tag;

            pBuffer += 7;

            pd = &pcg->ad[0];

            do
            {
                *pBuffer++ = *pd++;
            } while(pBuffer < pReservationEnd);

        }

        pgp++;

    } while (--cGlyph != 0);

done:
    
    InputBufferCommit(ppdev, pBuffer);

    return(bRet);
}

//------------------------------------------------------------------------------
// bCachedProportionalText
//
// Renders an array of clipped glyphs using the glyph cache
//
// ppdev----------pointer to physical device object
// pcf------------pointer to cached font structure
// pgpOriginal----array of glyphs to render (all members of the pcf font)
// cGlyphOriginal-number of glyphs to render
// ulCharInc------increment for fixed space fonts
// pco------------clip object
//
// Returns TRUE if the glyphs were rendered
//------------------------------------------------------------------------------

BOOL bCachedClippedText(
PDev*       ppdev,
CACHEDFONT* pcf,
GLYPHPOS*   pgpOriginal,
LONG        cGlyphOriginal,
ULONG       ulCharInc,
CLIPOBJ*    pco)
{
    BOOL            bRet;
    BYTE*           pjMmBase;
    BOOL            bClippingSet;
    LONG            cGlyph;
    GLYPHPOS*       pgp;
    LONG            xGlyph;
    LONG            yGlyph;
    LONG            x;
    LONG            y;
    LONG            xRight;
    LONG            cy;
    BOOL            bMore;
    ClipEnum        ce;
    RECTL*          prclClip;
    HGLYPH          hg;
    CACHEDGLYPH*    pcg;
    BYTE            iDComplexity;
    ULONG           i;
    ULONG*          pd;
    ULONG*          pBuffer;

    PERMEDIA_DECL;      // Declare and initialize local variables like 
                        //  'permediaInfo' and 'pPermedia'
    bRet      = TRUE;

    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;

    if (cGlyphOriginal > 0)
    {
      if (iDComplexity != DC_COMPLEX)
      {
        //
        // We could call 'cEnumStart' and 'bEnum' when the clipping is
        // DC_RECT, but the last time I checked, those two calls took
        // more than 150 instructions to go through GDI.  Since
        // 'rclBounds' already contains the DC_RECT clip rectangle,
        // and since it's such a common case, we'll special case it:
        //
        bMore = FALSE;
        ce.c  = 1;

        if (iDComplexity == DC_TRIVIAL)
            prclClip = &grclMax;
        else
            prclClip = &pco->rclBounds;

        goto SingleRectangle;
      }

      CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_ANY, 0);

      do {
        bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG*) &ce);

        for (prclClip = &ce.arcl[0]; ce.c != 0; ce.c--, prclClip++)
        {

        SingleRectangle:
          //
          // We don't always simply set the clipping rectangle here
          // because it may actually end up that no text intersects
          // this clip rectangle, so it would be for naught.  This
          // actually happens a lot when there is complex clipping.
          //
          bClippingSet = FALSE;

          pgp    = pgpOriginal;
          cGlyph = cGlyphOriginal;

          xGlyph = pgp->ptl.x;
          yGlyph = pgp->ptl.y;

          //
          // Loop through all the glyphs for this rectangle:
          //
          while (TRUE)
          {
            hg  = pgp->hg;
            pcg = pcf->apcg[GLYPH_HASH_FUNC(hg)];

            while (pcg->hg < hg)
              pcg = pcg->pcgNext;

            if (pcg->hg > hg)
            {
              //
              // This will hopefully not be the common case (that is,
              // we will have a high cache hit rate), so if I were
              // writing this in Asm I would have this out-of-line
              // to avoid the jump around for the common case.
              // But the Pentium has branch prediction, so what the
              // heck.
              //
              pcg = pcgNew(ppdev, pcf, pgp);
              if (pcg == NULL)
              {
                bRet = FALSE;
                goto AllDone;
              }
            }

            //
            // Space glyphs are trimmed to a height of zero, and we don't
            // even have to touch the hardware for them:
            //
            cy = pcg->cy;
            if (cy > 0)
            {
              y      = pcg->ptlOrigin.y + yGlyph;
              x      = pcg->ptlOrigin.x + xGlyph;
              xRight = pcg->cx + x;

              //
              // Do trivial rejection:
              //
              if ((prclClip->right  > x) &&
                  (prclClip->bottom > y) &&
                  (prclClip->left   < xRight) &&
                  (prclClip->top    < y + cy))
              {
                //
                // Lazily set the hardware clipping:
                //
                if ((iDComplexity != DC_TRIVIAL) && (!bClippingSet))
                {
                  bClippingSet = TRUE;

                  InputBufferReserve(ppdev, 6, &pBuffer);

                  pBuffer[0] = __Permedia2TagScissorMode;
                  pBuffer[1] =  USER_SCISSOR_ENABLE |
                                SCREEN_SCISSOR_DEFAULT;
                  pBuffer[2] = __Permedia2TagScissorMinXY;
                  pBuffer[3] =  (prclClip->top << 16) | prclClip->left;
                  pBuffer[4] = __Permedia2TagScissorMaxXY;
                  pBuffer[5] =  (prclClip->bottom << 16) | prclClip->right;

                  pBuffer += 6;

                  InputBufferCommit(ppdev, pBuffer);
                }
                
                InputBufferReserve(ppdev, 10, &pBuffer);

                pBuffer[0] = __Permedia2TagCount;
                pBuffer[1] =  cy;
                pBuffer[2] = __Permedia2TagStartY;
                pBuffer[3] =  INTtoFIXED(y);
                pBuffer[4] = __Permedia2TagStartXDom;
                pBuffer[5] =  INTtoFIXED(x);
                pBuffer[6] = __Permedia2TagStartXSub;
                pBuffer[7] =  INTtoFIXED(xRight);

                pBuffer[8] = __Permedia2TagRender;
                pBuffer[9] = __RENDER_TRAPEZOID_PRIMITIVE 
                           | __RENDER_SYNC_ON_BIT_MASK;

                pBuffer += 10;
    
                InputBufferCommit(ppdev, pBuffer);

                InputBufferReserve(ppdev, pcg->cd + 1, &pBuffer);
                
                *pBuffer++ = (pcg->cd - 1) << 16 | __Permedia2TagBitMaskPattern;
                
                pd = &pcg->ad[0];
                i = pcg->cd;

                do {
                  *pBuffer++ =  *pd;  
                  pd++;
    
                } while (--i != 0);
    
                InputBufferCommit(ppdev, pBuffer);

              }
            }

            if (--cGlyph == 0)
              break;

            //
            // Get ready for next glyph:
            //
            pgp++;

            if (ulCharInc == 0)
            {
              xGlyph = pgp->ptl.x;
              yGlyph = pgp->ptl.y;
            }
            else
            {
              xGlyph += ulCharInc;
            }
          }
        }
      } while (bMore);
    }

AllDone:

    if (iDComplexity != DC_TRIVIAL)
    {
        //
        // Reset the clipping.
        //
        InputBufferReserve(ppdev, 2, &pBuffer);

        pBuffer[0] = __Permedia2TagScissorMode;
        pBuffer[1] =  SCREEN_SCISSOR_DEFAULT;

        pBuffer += 2;

        InputBufferCommit(ppdev, pBuffer);
    }

    return(bRet);
}

//-----------------------------Private-Routine----------------------------------
// vClipSolid
//     ppdev (I) - pointer to physical device object
//     prcl (I) - number of rectangles
//     prcl (I) - array of rectangles
//     iColor (I) - the solid fill color
//     pco (I) - pointer to the clip region object
//
// Fill a series of opaquing rectangles clipped by pco with the given solid
// color.   This function should only be called when the clipping operation
// is non-trivial.
//
//------------------------------------------------------------------------------

VOID vClipSolid(
    PDev*           ppdev,
    Surf *          psurf,
    LONG            crcl,
    RECTL*          prcl,
    ULONG           iColor,
    CLIPOBJ*        pco)
{
    BOOL            bMore;
    ClipEnum        ce;
    ULONG           i;
    ULONG           j;
    RECTL           arclTmp[4];
    ULONG           crclTmp;
    RECTL*          prclTmp;
    RECTL*          prclClipTmp;
    LONG            iLastBottom;
    RECTL*          prclClip;
    RBrushColor    rbc;
    GFNPB           pb;

    ASSERTDD((crcl > 0) && (crcl <= 4),
                "vClipSolid: expected 1 to 4 rectangles");

    ASSERTDD((pco != NULL) && (pco->iDComplexity != DC_TRIVIAL),
                "vClipColid: expected a non-null clip object");

    pb.ppdev = ppdev;
    pb.psurfDst = psurf;
    pb.solidColor = iColor;

    if (pco->iDComplexity == DC_RECT)
    {
        crcl = cIntersect(&pco->rclBounds, prcl, crcl);
        if (crcl != 0)
        {
            pb.lNumRects = crcl;
            pb.pRects = prcl;

            ppdev->pgfnSolidFill(&pb);
            
        }
    }
    else // iDComplexity == DC_COMPLEX
    {
        // Bottom of last rectangle to fill
        iLastBottom = prcl[crcl - 1].bottom;

        // Initialize the clip rectangle enumeration to right-down so we can
        // take advantage of the rectangle list being right-down:
        CLIPOBJ_cEnumStart(pco, FALSE, CT_RECTANGLES, CD_RIGHTDOWN, 0);

        // Scan through all the clip rectangles, looking for intersects
        // of fill areas with region rectangles:
        do 
        {
            // Get a batch of region rectangles:
            bMore = CLIPOBJ_bEnum(pco, sizeof(ce), (ULONG *)&ce);

            // Clip the rect list to each region rect:
            for (j = ce.c, prclClip = ce.arcl; j-- > 0; prclClip++)
            {
                // Since the rectangles and the region enumeration are both
                // right-down, we can zip through the region until we reach
                // the first fill rect, and are done when we've passed the
                // last fill rect.
                if (prclClip->top >= iLastBottom)
                {
                    // Past last fill rectangle; nothing left to do:
                    return;
                }

                // Do intersection tests only if we've reached the top of
                // the first rectangle to fill:
                if (prclClip->bottom > prcl->top)
                {
                    // We've reached the top Y scan of the first rect, so
                    // it's worth bothering checking for intersection.

                    // Generate a list of the rects clipped to this region
                    // rect:
                    prclTmp     = prcl;
                    prclClipTmp = arclTmp;

                    for (i = crcl, crclTmp = 0; i-- != 0; prclTmp++)
                    {
                        // Intersect fill and clip rectangles
                        if (bIntersect(prclTmp, prclClip, prclClipTmp))
                        {
                            // Add to list if anything's left to draw:
                            crclTmp++;
                            prclClipTmp++;
                        }
                    }

                    // Draw the clipped rects
                    if (crclTmp != 0)
                    {
                        pb.lNumRects = crclTmp;
                        pb.pRects = &arclTmp[0];

                        ppdev->pgfnSolidFill(&pb);
                    }
                }
            }
        } 
        while (bMore);
    }
}// vClipSolid()

//-----------------------------Public-Routine-----------------------------------
// DrvTextOut
//       pso (I) - pointer to surface object to render to
//       pstro (I) - pointer to the string object to be rendered
//       pfo (I) - pointer to the font object
//       pco (I) - pointer to the clip region object
//       prclExtra (I) - If we had set GCAPS_HORIZSTRIKE, we would have to 
//                       fill these extra rectangles (it is used  largely 
//                       for underlines). It's not a big performance win
//                       (GDI will call our DrvBitBlt to draw these).
//       prclOpaque (I) - pointer to the opaque background rectangle
//       pboFore (I) - pointer to the foreground brush object
//       pboOpaque (I) - ptr to the brush for the opaque background rectangle
//       pptlBrush (I) - pointer to the brush origin, Always unused, unless 
//                       GCAPS_ARBRUSHOPAQUE set
//       mix (I) - should always be a COPY operation
// 
// Returns TRUE if the text has been rendered
//
//------------------------------------------------------------------------------

BOOL
DrvTextOut(SURFOBJ*     pso,
           STROBJ*      pstro,
           FONTOBJ*     pfo,
           CLIPOBJ*     pco,
           RECTL*       prclExtra,
           RECTL*       prclOpaque,
           BRUSHOBJ*    pboFore,
           BRUSHOBJ*    pboOpaque,
           POINTL*      pptlBrush, 
           MIX          mix)
{
    PDev*           ppdev;
    Surf*           psurf;
    ULONG           cGlyph;
    BOOL            bMoreGlyphs;
    GLYPHPOS*       pgp;
    BYTE            iDComplexity;
    RECTL           rclOpaque;
    BOOL            bRet = TRUE;
    CACHEDFONT*     pcf;
    PULONG          pBuffer;
    ULONG           ulColor;

    psurf = (Surf*)pso->dhsurf;
    ppdev  = (PDev*)pso->dhpdev;

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    if(ppdev->ulLockCount)
    {
         DBG_GDI((MT_LOG_LEVEL, "DrvTextOut: re-entry! %d", ppdev->ulLockCount));
    }
    EngAcquireSemaphore(ppdev->hsemLock);
    ppdev->ulLockCount++;
#endif
//@@END_DDKSPLIT
    
    vCheckGdiContext(ppdev);
    
    //
    // The DDI spec says we'll only ever get foreground and background mixes
    // of R2_COPYPEN:
    //
    ASSERTDD(mix == 0x0d0d, "GDI should only give us a copy mix");
    ASSERTDD(pco != NULL, "Expect non-null pco");
    ASSERTDD(psurf->flags & SF_VM, "expected video memory destination");

    iDComplexity = pco->iDComplexity;

    //
    //glyph rendering initialisation
    //

    InputBufferReserve(ppdev, 16, &pBuffer);

    pBuffer[0] = __Permedia2TagFBReadMode;
    pBuffer[1] = PM_FBREADMODE_PARTIAL(psurf->ulPackedPP) |
                 PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE);

    if(pfo->flFontType & FO_GRAY16)
        pBuffer[1] |= PM_FBREADMODE_READDEST( __PERMEDIA_ENABLE);

    pBuffer[2] = __Permedia2TagLogicalOpMode;
    pBuffer[3] = __PERMEDIA_CONSTANT_FB_WRITE;

    pBuffer[4] = __Permedia2TagFBWindowBase;
    pBuffer[5] = psurf->ulPixOffset;

    pBuffer += 6;

    if ( prclOpaque != NULL )
    {
        //
        // Opaque Initialization
        //
        if ( iDComplexity == DC_TRIVIAL )
        {

        DrawOpaqueRect:

//@@BEGIN_DDKSPLIT
            // TODO: use color expansion macro
//@@END_DDKSPLIT

            ulColor = pboOpaque->iSolidColor;

            if ( ppdev->cPelSize < 2 )
            {
                ulColor |= ulColor << 16;
                if ( ppdev->cPelSize == 0 )
                {
                    ulColor |= ulColor << 8;
                }
            }

            //
            // Check the block colour
            //
            pBuffer[0] = __Permedia2TagFBBlockColor;
            pBuffer[1] = ulColor;
            pBuffer[2] = __Permedia2TagRectangleOrigin;
            pBuffer[3] = RECTORIGIN_YX(prclOpaque->top,prclOpaque->left);
            pBuffer[4] = __Permedia2TagRectangleSize;
            pBuffer[5] = ((prclOpaque->bottom - prclOpaque->top) << 16) |
                         (prclOpaque->right - prclOpaque->left);
            pBuffer[6] = __Permedia2TagRender;
            pBuffer[7] = __RENDER_FAST_FILL_ENABLE
                       | __RENDER_RECTANGLE_PRIMITIVE
                       | __RENDER_INCREASE_X
                       | __RENDER_INCREASE_Y;


            pBuffer += 8;

        }
        else if ( iDComplexity == DC_RECT )
        {
            if ( bIntersect(prclOpaque, &pco->rclBounds, &rclOpaque) )
            {
                prclOpaque = &rclOpaque;
                goto DrawOpaqueRect;
            }
        }
        else
        {
            //
            // vClipSolid modifies the rect list we pass in but prclOpaque
            // is probably a GDI structure so don't change it. This is also
            // necessary for multi-headed drivers.
            //
            RECTL   tmpOpaque = *prclOpaque;

            InputBufferCommit(ppdev, pBuffer);

            vClipSolid(ppdev, psurf, 1, &tmpOpaque,
                       pboOpaque->iSolidColor, pco);
            
            // restore logicalOpMode
//@@BEGIN_DDKSPLIT
            // TODO: This is a hack, we can only assume that the state
            //       setup above is still valid except for logical op mode
            //       and the FBReadMode for the FO_GRAY16 case only.
            //
            //       We should rethink how to deal with the Permedia2
            //       state throughout the code.
//@@END_DDKSPLIT
            if(pfo->flFontType & FO_GRAY16)
            {
                InputBufferReserve(ppdev, 2, &pBuffer);
                pBuffer[0] = __Permedia2TagFBReadMode;
                pBuffer[1] = PM_FBREADMODE_PARTIAL(psurf->ulPackedPP) |
                             PM_FBREADMODE_PACKEDDATA(__PERMEDIA_DISABLE) |
                             PM_FBREADMODE_READDEST(__PERMEDIA_ENABLE);
                pBuffer += 2;
                InputBufferCommit(ppdev, pBuffer);
            }
            InputBufferReserve(ppdev, 4, &pBuffer);
            pBuffer[0] = __Permedia2TagLogicalOpMode;
            pBuffer[1] = __PERMEDIA_CONSTANT_FB_WRITE;
            pBuffer += 2;
        }
    }
    // if ( prclOpaque != NULL )

    //
    // Transparent Initialization
    //
        

    if(pfo->flFontType & FO_GRAY16)
    {
        ASSERTDD(ppdev->cPelSize != 0, 
                 "DrvTextOut: unexpected aatext when in 8bpp");

        ulColor = pboFore->iSolidColor;

        if(ppdev->cPelSize == 1)
        {
            ULONG   blue = (ulColor & 0x1f);
            ULONG   green = (ulColor >> 5) & 0x3f;
            ULONG   red = (ulColor >> 11) & 0x1f;

            blue = (blue << 3) | (blue >> 2);
            green = (green << 2) | (green >> 4);
            red = (red << 3) | (red >> 2);

            ulColor = (blue << 16) | (green << 8) | red;
        }
        else
        {
            ulColor = SWAP_BR(ulColor);
        }

        pBuffer[0] = __Permedia2TagConstantColor;
        pBuffer[1] =  0xff000000 | ulColor;

        pBuffer += 2;
    }
    else
    {
        //
        // glyph foreground will be rendered using bitmask downloads
        //
        pBuffer[0] = __Permedia2TagFBWriteData;
        pBuffer[1] = pboFore->iSolidColor;

        pBuffer += 2;
    
    }

    InputBufferCommit(ppdev, pBuffer);

    STROBJ_vEnumStart(pstro);

    do 
    {
        if ( pstro->pgp != NULL )
        {
            //
            // There's only the one batch of glyphs, so save ourselves a
            // call
            //
            pgp         = pstro->pgp;
            cGlyph      = pstro->cGlyphs;
            bMoreGlyphs = FALSE;
        }
        else
        {
            bMoreGlyphs = STROBJ_bEnum(pstro, &cGlyph, &pgp);
        }

        if ( cGlyph > 0 )
        {
            //
            // We only cache reasonable-sized glyphs:
            //
            if ( pfo->flFontType & FO_GRAY16)
            {
                bRet = bClippedAAText(ppdev, pgp, cGlyph, 
                                    pstro->ulCharInc, pco);
            }
            else if ( ( pfo->cxMax <= GLYPH_CACHE_CX ) &&
                 ( pstro->rclBkGround.bottom - pstro->rclBkGround.top 
                    <= GLYPH_CACHE_CY ) )
            {
                pcf = (CACHEDFONT*) pfo->pvConsumer;
          
                if (pcf == NULL)
                {
                    pcf = pcfAllocateCachedFont(ppdev);
                    if (pcf == NULL)
                    {
                        DBG_GDI((0, "failing to allocate cached font"));
                        InputBufferFlush(ppdev);

//@@BEGIN_DDKSPLIT
                        #if MULTITHREADED
                            ppdev->ulLockCount--;
                            EngReleaseSemaphore(ppdev->hsemLock);
                        #endif
//@@END_DDKSPLIT

                        return(FALSE);
                    }
          
                    pfo->pvConsumer = pcf;
                }

                //
                // We special case trivially clipped proportional text because
                // that happens so frequently, and route everything else 
                // the generic clipped routine.  I used to also special case
                // trivially clipped, fixed text, but it happens so 
                // infrequently there's no point.
                //
                if ( (iDComplexity == DC_TRIVIAL ) && ( pstro->ulCharInc == 0 ) )
                {
                    bRet = bCachedProportionalText(ppdev, pcf, pgp, cGlyph);
                }
                else
                {
                    bRet = bCachedClippedText(ppdev, pcf, pgp, cGlyph, 
                                              pstro->ulCharInc, pco);
                }
            }
            else
            {
                bRet = bClippedText(ppdev, pgp, cGlyph, 
                                    pstro->ulCharInc, pco);
            }
        }
    } while ( bMoreGlyphs && bRet );

    InputBufferFlush(ppdev);

//@@BEGIN_DDKSPLIT
#if MULTITHREADED
    ppdev->ulLockCount--;
    EngReleaseSemaphore(ppdev->hsemLock);
#endif
//@@END_DDKSPLIT
    
    return (bRet);

}// DrvTextOut()


//-----------------------------Public-Routine-----------------------------------
// bEnableText
//     ppdev (I) - pointer to physical device object
//
// Always true for success.
//
// Peform any necessary initialization of PPDEV state or hardware state
// to enable accelerated text.
//
// If we were using a glyph cache, we would initialize the necessary data
// structures here.
//
//------------------------------------------------------------------------------
BOOL
bEnableText(PDev* ppdev)
{
    DBG_GDI((6, "bEnableText"));

    return (TRUE);
}// bEnableText()

//-----------------------------Public-Routine-----------------------------------
// vDisableText
//     ppdev (I) - pointer to physical device object
//
//
// Disable hardware text accelerations.  This may require changes to hardware
// state.  We should also free any resources allocated in bEnableText and
// make the neccesary changes to the PPDEV state to reflect that text
// accelerations have been disabled.
//
//------------------------------------------------------------------------------
VOID
vDisableText(PDev* ppdev)
{
    DBG_GDI((6, "vDisableText"));
}// vDisableText()

//-----------------------------Public*Routine-----------------------------------
// vAssertModeText
//     ppdev (I) - pointer to physical device object
//     bEnable (I) - TRUE to enable accelerated text, FALSE to disable
//                   accelerated test.
//
// Called when going to/from full screen mode.
//
//@@BEGIN_DDKSPLIT
// TODO: check to see if this is also called when setting modes.
//@@END_DDKSPLIT
//
//------------------------------------------------------------------------------

VOID vAssertModeText(PDev* ppdev, BOOL bEnable)
{

    DBG_GDI((5, "vAssertModeText"));
    
    if (!bEnable)
        vDisableText(ppdev);
    else
    {
        bEnableText(ppdev);
    }
}// vAssertModeText()

//-----------------------------Public-Routine-----------------------------------
// DrvDestroyFont
//       pfo (I) - pointer to the font object
//       pco (I) - pointer to the clip region object
//       prclExtra (I) - If we had set GCAPS_HORIZSTRIKE, we would have to 
//                       fill these extra rectangles (it is used  largely 
//                       for underlines). It's not a big performance win
//                       (GDI will call our DrvBitBlt to draw these).
//       prclOpaque (I) - pointer to the opaque background rectangle
//       pboFore (I) - pointer to the foreground brush object
//       pboOpaque (I) - ptr to the brush for the opaque background rectangle
//       pptlBrush (I) - pointer to the brush origin, Always unused, unless 
//                       GCAPS_ARBRUSHOPAQUE set
//       mix (I) - should always be a COPY operation
// 
// Frees any cached information we've stored with the font.  This routine
// is relevant only when caching glyphs.
//
// We're being notified that the given font is being deallocated; clean up
// anything we've stashed in the 'pvConsumer' field of the 'pfo'.
//
// Note: Don't forget to export this call in 'enable.c', otherwise you'll
//      get some pretty big memory leaks!
//
//------------------------------------------------------------------------------

VOID DrvDestroyFont(FONTOBJ* pfo)
{
    CACHEDFONT* pcf;

    pcf = (CACHEDFONT*) pfo->pvConsumer;
    if (pcf != NULL)
    {
        GLYPHALLOC* pga;
        GLYPHALLOC* pgaNext;
    
        pga = pcf->pgaChain;
        while (pga != NULL)
        {
            pgaNext = pga->pgaNext;
            ENGFREEMEM(pga);
            pga = pgaNext;
        }
    
        ENGFREEMEM(pcf);

        pfo->pvConsumer = NULL;
    }
}// DrvDestroyFont()

// Work in progress

VOID
vCheckGdiContext(PPDev ppdev)
{
    HwDataPtr   permediaInfo = ppdev->permediaInfo;

    ASSERTDD(ppdev->bEnabled, 
             "vCheckContext(): expect the device to be enabled");

    if(permediaInfo->pCurrentCtxt != permediaInfo->pGDICtxt)
    {
        P2SwitchContext(ppdev, permediaInfo->pGDICtxt);
    }

}

void FASTCALL InputBufferSwap(PPDev ppdev)
{
    ASSERTDD(ppdev->bGdiContext, "InputBufferSwap: not in gdi context");
    
//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, InputBufferSwap);
//@@END_DDKSPLIT
    
    if(ppdev->dmaBufferVirtualAddress != NULL)
    {
        LONG    lUsed = (LONG)(ppdev->pulInFifoPtr - ppdev->pulInFifoStart);

        while(READ_REGISTER_ULONG(ppdev->pulInputDmaCount) != 0) 
        {
            // do nothing
        }
    
        LONG offset = (LONG)((LONG_PTR)ppdev->pulInFifoStart  - (LONG_PTR)ppdev->dmaBufferVirtualAddress);
        LONG address =  ppdev->dmaBufferPhysicalAddress.LowPart + offset;
       
        WRITE_REGISTER_ULONG(ppdev->pulInputDmaAddress, address);
        MEMORY_BARRIER();
        WRITE_REGISTER_ULONG(ppdev->pulInputDmaCount,lUsed);
        MEMORY_BARRIER();
    
        if(ppdev->pulInFifoStart == ppdev->dmaBufferVirtualAddress)
            ppdev->pulInFifoStart += (INPUT_BUFFER_SIZE>>3);
        else
            ppdev->pulInFifoStart = ppdev->dmaBufferVirtualAddress;

        ppdev->pulInFifoEnd = ppdev->pulInFifoStart + (INPUT_BUFFER_SIZE>>3);
        ppdev->pulInFifoPtr = ppdev->pulInFifoStart;

    }
    else
    {
        ULONG*  pul = ppdev->pulInFifoStart;
        ULONG   available = 0;
        
        while(pul < ppdev->pulInFifoPtr)
        {
            while(available == 0)
            {
                available = READ_REGISTER_ULONG(ppdev->pulInputFifoCount);
                
                if(available == 0)
                {
                    StallExecution(ppdev->hDriver, 1);

                }

            }

            WRITE_REGISTER_ULONG(ppdev->pulFifo, *pul++);
            MEMORY_BARRIER();
            available--;
        }

        ppdev->pulInFifoPtr = ppdev->pulInFifoStart;
    }

}

void FASTCALL InputBufferFlush(PPDev ppdev)
{
    ASSERTDD(ppdev->bGdiContext, "InputBufferFlush: not in gdi context");
    
//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, InputBufferFlush);
//@@END_DDKSPLIT
    
    ppdev->bNeedSync = TRUE;
    
    if(ppdev->dmaBufferVirtualAddress != NULL)
    {
        if(READ_REGISTER_ULONG(ppdev->pulInputDmaCount) == 0)
            InputBufferSwap(ppdev);
    }
    else
    {
        InputBufferSwap(ppdev);
    }
}

//
// Used for debugging purposes to record whether the driver had to
// bail out of the while loop inside InputBufferSync
//

ULONG gSyncInfiniteLoopCount = 0;

VOID
InputBufferSync(PPDev ppdev)
{
    ASSERTDD(ppdev->bGdiContext, "InputBufferSync: not in gdi context");
    
//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, InputBufferSync);
//@@END_DDKSPLIT
    
    ULONG * pBuffer;

    if(ppdev->bNeedSync)
    {

        DBG_GDI((6, "InputBufferSync()"));

        InputBufferReserve(ppdev, 6, &pBuffer);
    
        pBuffer[0] = __Permedia2TagFilterMode;
        pBuffer[1] =  0x400;
        pBuffer[2] = __Permedia2TagSync;
        pBuffer[3] =  0L; 
        pBuffer[4] =__Permedia2TagFilterMode;
        pBuffer[5] = 0x0;
        pBuffer += 6;
    
        InputBufferCommit(ppdev, pBuffer);
    
        InputBufferSwap(ppdev);
    
        if(ppdev->dmaBufferVirtualAddress != NULL)
        {
            while(READ_REGISTER_ULONG(ppdev->pulInputDmaCount) != 0) 
            {
                StallExecution(ppdev->hDriver, 1);
            }
        }
    
        while(1)
        {
            ULONG   ulStallCount = 0;

            while(READ_REGISTER_ULONG(ppdev->pulOutputFifoCount) == 0)
            {
                StallExecution(ppdev->hDriver, 1);

                // If we are stuck here for one seconds then break
                // out of the loop.  We have noticed that we will
                // occasionally hit this case and are able to
                // continue without futher problems.  This really
                // should never happen but we have been unable to
                // find the cause of these occasional problems.

                if(++ulStallCount == 1000000)
                {
                    DBG_GDI((6, "InputBufferSync(): infinite loop detected"));
                    gSyncInfiniteLoopCount++;
                    goto bail;
                }
            }
        
            ULONG data = READ_REGISTER_ULONG(ppdev->pulFifo);
    
            if(data != __Permedia2TagSync)
            {
                DBG_GDI((0, "Data other then sync found at output fifo"));
            }
            else
            {
                break;
            }
        }

bail:

        ppdev->bNeedSync = FALSE;
    }
}

#if DBG
void InputBufferStart(
    PPDev   ppdev,
    ULONG   ulLongs,
    PULONG* ppulBuffer,
    PULONG* ppulBufferEnd,
    PULONG* ppulReservationEnd)
{
    ASSERTDD(ppdev->bGdiContext, "InputBufferStart: not in gdi context");
    ASSERTDD(ppdev->ulReserved == 0, 
                "InputBufferStart: called with outstanding reservation");
    
//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, InputBufferStart);
//@@END_DDKSPLIT
    
    *(ppulBuffer) = ppdev->pulInFifoPtr;
    *(ppulReservationEnd) =  *(ppulBuffer) + ulLongs;
    *(ppulBufferEnd) = ppdev->pulInFifoEnd;
    if(*(ppulReservationEnd) > *(ppulBufferEnd))
    {
        InputBufferSwap(ppdev);
        *(ppulBuffer) = ppdev->pulInFifoPtr;
        *(ppulReservationEnd) =  *(ppulBuffer) + ulLongs;
        *(ppulBufferEnd) = ppdev->pulInFifoEnd;
    }

    for(int index = 0; index < (int) ulLongs; index++)
        ppdev->pulInFifoPtr[index] = 0xDEADBEEF;

    ppdev->ulReserved = ulLongs;
}

void InputBufferContinue(
    PPDev   ppdev,
    ULONG   ulLongs,
    PULONG* ppulBuffer,
    PULONG* ppulBufferEnd,
    PULONG* ppulReservationEnd)
{
    ASSERTDD(ppdev->bGdiContext, "InputBufferContinue: not in gdi context");
    
//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, InputBufferContinue);
//@@END_DDKSPLIT
    
    LONG    lUsed = (LONG)(*(ppulBuffer) - ppdev->pulInFifoPtr);
    
    if(lUsed > (LONG) ppdev->ulReserved)
    {
        DebugPrint(0, "InputBuffeContinue: exceeded reservation %d (%d)",
                        ppdev->ulReserved, lUsed);
        EngDebugBreak();
    }

    for(int index = 0; index < lUsed; index++)
        if(ppdev->pulInFifoPtr[index] == 0xDEADBEEF)
        {
            DebugPrint(0, "InputBufferContinue: buffer entry %d not set", index);
            EngDebugBreak();
        }

    ppdev->pulInFifoPtr = *(ppulBuffer);
    *(ppulReservationEnd) = *(ppulBuffer) + ulLongs;
    if(*(ppulReservationEnd) > *(ppulBufferEnd))
    {
        InputBufferSwap(ppdev);
        *(ppulBuffer) = ppdev->pulInFifoPtr;
        *(ppulReservationEnd) = *(ppulBuffer) + ulLongs;
        *(ppulBufferEnd) = ppdev->pulInFifoEnd;
    }

    for(index = 0; index < (int) ulLongs; index++)
        ppdev->pulInFifoPtr[index] = 0xDEADBEEF;

    ppdev->ulReserved = ulLongs;
}

void InputBufferReserve(
    PPDev   ppdev,
    ULONG   ulLongs,
    PULONG* ppulBuffer)
{
    ASSERTDD(ppdev->bGdiContext, "InputBufferReserve: not in gdi context");
    ASSERTDD(ppdev->ulReserved == 0, 
                    "InputBufferReserve: called with outstanding reservation");
    
//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, InputBufferReserve);
//@@END_DDKSPLIT
    
    if(ppdev->pulInFifoPtr + ulLongs > ppdev->pulInFifoEnd)
    {
        InputBufferSwap(ppdev);
    }
    *(ppulBuffer) = ppdev->pulInFifoPtr;

    for(int index = 0; index < (int) ulLongs; index++)
        ppdev->pulInFifoPtr[index] = 0xDEADBEEF;

    ppdev->ulReserved = ulLongs;

}

void InputBufferCommit(
    PPDev   ppdev,
    PULONG  pulBuffer)
{
    ASSERTDD(ppdev->bGdiContext, "InputBufferCommit: not in gdi context");
    
//@@BEGIN_DDKSPLIT
    ASSERTLOCK(ppdev, InputBufferCommit);
//@@END_DDKSPLIT
    
    LONG    lUsed = (LONG)(pulBuffer - ppdev->pulInFifoPtr);

    if(lUsed > (LONG) ppdev->ulReserved)
    {
        DebugPrint(0, "InputBuffeCommit: exceeded reservation %d (%d)",
                        ppdev->ulReserved, lUsed);
        EngDebugBreak();
    }
    ppdev->ulReserved = 0;

    for(int index = 0; index < lUsed; index++)
        if(ppdev->pulInFifoPtr[index] == 0xDEADBEEF)
        {
            DebugPrint(0, "InputBuffer Commit: buffer entry %d not set", index);
            EngDebugBreak();
        }

    ppdev->pulInFifoPtr = pulBuffer;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\i386\fasttext.asm ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\i386\hw.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\i386\strucs.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\dbgext\drvext.cxx ===
/******************************Module*Header***********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: drvexts.cxx
 *
 * Contains all the driver debugger extension functions
 *
 * Copyright (C) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
 ******************************************************************************/
#include "dbgext.hxx"
#include "gdi.h"

#define TMP_BUFSIZE 512

/**********************************Public*Routine******************************\
 *
 * Dump Permedia 2 display driver's Surf obj
 *
 ******************************************************************************/
DECLARE_API(surf)
{
    Surf        tempSurf;
    FLAGDEF*    pfd;
    
    //
    // Check if there is a "-?" in the command. If yes, show the help
    //
    PARSE_POINTER(surf_help);

    move(tempSurf, (Surf*)arg);

    dprintf("----Permedia2 Surf Structure-------------\n");
    dprintf("SurfFlags      flags           0x%x\n", tempSurf.flags);

    //
    // Print the detail info of the Surface info
    //
    for ( pfd = afdSURF; pfd->psz; ++pfd )
    {
        if ( tempSurf.flags & pfd->fl )
        {
            dprintf("\t\t\t%s\n", pfd->psz);
        }
    }
    
    dprintf("PDev*          ppdev           0x%x\n", tempSurf.ppdev);
    dprintf("struct _Surf*  psurfNext       0x%x\n", tempSurf.psurfNext);
    dprintf("struct _Surf*  psurfPrev       0x%x\n", tempSurf.psurfPrev);
    dprintf("ULONG          cBlt            %ld\n", tempSurf.cBlt);
    dprintf("ULONG          iUniq           %ld\n", tempSurf.iUniq);
    dprintf("LONG           cx(Surf Width)  %ld pixels\n", tempSurf.cx);
    dprintf("LONG           cy(Surf Height) %ld pixels\n", tempSurf.cy);

    if ( tempSurf.flags & SF_VM )
    {
        dprintf("ULONG          ulByteOffset    %ld\n", tempSurf.ulByteOffset);
    }
    else
    {
        dprintf("VOID*      pvScan0         0x%x\n", tempSurf.pvScan0);
    }

    dprintf("LONG           lDelta          0x%x\n", tempSurf.lDelta);
    dprintf("VIDEOMEMORY*   pvmHeap         0x%x\n", tempSurf.pvmHeap);
    dprintf("HSURF          hsurf           0x%x\n", tempSurf.hsurf);
    dprintf("ULONG          ulPackedPP      0x%x\n", tempSurf.ulPackedPP);
    dprintf("ULONG          ulPixOffset     0x%x\n", tempSurf.ulPixOffset);
    dprintf("ULONG          ulPixDelta      0x%x\n", tempSurf.ulPixDelta);
    dprintf("ULONG          ulChecksum      0x%x\n", tempSurf.ulChecksum);
    
    return;
    
surf_help:
    dprintf("Usage: surf [-?] SURF_PTR\n");
}// surf

/**********************************Public*Routine******************************\
 *
 * Dump Permedia 2 display driver's PDev obj
 *
 ******************************************************************************/
DECLARE_API(pdev)
{
    PDev        tempPDev;
    char        tempStr[TMP_BUFSIZE];
    FLAGDEF*    pfd;

    BOOL bAll = FALSE;
    BOOL bGeneral = FALSE;
    BOOL bHeap = FALSE;
    BOOL bBase = FALSE;
    BOOL bGDI = FALSE;
    BOOL bPalette = FALSE;
    BOOL bCursor = FALSE;
    BOOL bBrush = FALSE;
    BOOL bDDraw = FALSE;

    //
    // Check if there is a "-?" in the command. If yes, show the help
    //
    PARSE_POINTER(pdev_help);

    move(tempPDev, (PDev*)arg);

    if( iParseiFindSwitch(tokens, ntok, 'a')!= -1 )
    {
        bAll = TRUE;
        goto Start_Dump;
    }

    if( iParseiFindSwitch(tokens, ntok, 'g') != -1 )
    {
        bGeneral = TRUE;
    }

    if( iParseiFindSwitch(tokens, ntok, 'h')!= -1 )
    {
        bHeap = TRUE;
    }
    
    if( iParseiFindSwitch(tokens, ntok, 'b')!= -1 )
    {
        bBase = TRUE;
    }
    
    if( iParseiFindSwitch(tokens, ntok, 'i')!= -1 )
    {
        bGDI = TRUE;
    }
    
    if( iParseiFindSwitch(tokens, ntok, 'p')!= -1 )
    {
        bPalette = TRUE;
    }
    
    if( iParseiFindSwitch(tokens, ntok, 'c')!= -1 )
    {
        bCursor = TRUE;
    }
    
    if( iParseiFindSwitch(tokens, ntok, 'r')!= -1 )
    {
        bBrush = TRUE;
    }
    
    if( iParseiFindSwitch(tokens, ntok, 'd')!= -1 )
    {
        bDDraw = TRUE;
    }

    if( !(bGeneral || bHeap || bBase || bGDI || bPalette ||  bCursor || bBrush
        ||bBrush || bDDraw ) )
    {
        bAll = TRUE;
    }

Start_Dump:

    dprintf("----------------PDev Structure----------------\n");
    
    if ( bAll || bGeneral )
    {
        dprintf("*************General Information**************\n");
        dprintf("BOOL        bEnabled        %ld %s\n",tempPDev.bEnabled,
                tempPDev.bEnabled? "(Graphics Mode)":"(Full Screen Mode)");
        dprintf("DWORD       dwAccelLevel    %ld\n",  tempPDev.dwAccelLevel);
        switch ( tempPDev.dwAccelLevel )
        {
            case 0:
                dprintf("%s\n","\t\t\tAll HW accelerations are enabled");

                break;

            case 1:
                dprintf("%s\n", "\t\t\tDrvMovePointer,");
                dprintf("%s\n", "\t\t\tDrvCreateDeviceBitmap");
                dprintf("%s\n", "are disabled");

                break;

            case 2:
                dprintf("%s\n", "\t\t\tDrvAlphaBlend,");
                dprintf("%s\n", "\t\t\tDrvCreateDeviceBitmap,");
                dprintf("%s\n", "\t\t\tDrvFillPath,");
                dprintf("%s\n", "\t\t\tDrvGradientFill,");
                dprintf("%s\n", "\t\t\tDrvLineTo,");
                dprintf("%s\n", "\t\t\tDrvMovePointer,");
                dprintf("%s\n", "\t\t\tDrvPlgBlt,");
                dprintf("%s\n", "\t\t\tDrvStretchBlt,");
                dprintf("%s\n", "\t\t\tDrvStretchBltROP,");
                dprintf("%s\n", "\t\t\tDrvStrokeAndFillPath,");
                dprintf("%s\n", "\t\t\tDrvTransparentBlt");
                dprintf("%s\n", "are disabled");

                break;

            case 3:
                dprintf("%s\n", "\t\t\tDrvAlphaBlend,");
                dprintf("%s\n", "\t\t\tDrvCreateDeviceBitmap,");
                dprintf("%s\n", "\t\t\tDrvFillPath,");
                dprintf("%s\n", "\t\t\tDrvGradientFill,");
                dprintf("%s\n", "\t\t\tDrvLineTo,");
                dprintf("%s\n", "\t\t\tDrvMovePointer,");
                dprintf("%s\n", "\t\t\tDrvPlgBlt,");
                dprintf("%s\n", "\t\t\tDrvStretchBlt,");
                dprintf("%s\n", "\t\t\tDrvStretchBltROP,");
                dprintf("%s\n", "\t\t\tDrvStrokeAndFillPath,");
                dprintf("%s\n", "\t\t\tDrvTransparentBlt");
                dprintf("%s\n", "\t\t\tAnd all DDraw and D3D accelerations");
                dprintf("%s\n", "are disabled");

                break;

            case 4:
                dprintf("%s\n", "\t\t\tOnly following HW accelerated functions");
                dprintf(" are enabled");
                dprintf("%s\n", "\t\t\tDrvBitBlt,");
                dprintf("%s\n", "\t\t\tDrvCopyBits,");
                dprintf("%s\n", "\t\t\tDrvStrokePath,");
                dprintf("%s\n", "\t\t\tDrvTextOut");

                break;

            case 5:
                dprintf("%s\n","\t\t\tAll HW accelerations are disabled");

                break;

            default:
                dprintf("%s\n", "\t\t\tUNKNOWN HW accelerations level");
                
                break;
        }

        dprintf("ULONG       iBitmapFormat   %ld\n",  tempPDev.iBitmapFormat);

        switch ( tempPDev.iBitmapFormat )
        {
            case BMF_32BPP:
                strcpy(tempStr, "\t\t\tBMF_32BPP");
                
                break;

            case BMF_16BPP:
                strcpy(tempStr, "\t\t\tBMF_16BPP");
                
                break;

            case BMF_8BPP:
                strcpy(tempStr, "\t\t\tBMF_8BPP");
                
                break;

            default:
                strcpy(tempStr, "\t\t\tUNKNOWN BMP format");
            
                break;
        }
        dprintf("%s\n", tempStr);

        dprintf("LONG        cjPelSize       %ld\n",  tempPDev.cjPelSize);
        switch ( tempPDev.cjPelSize )
        {
            case 4:
                strcpy(tempStr, "\t\t\t32BPP Mode");
                
                break;

            case 2:
                strcpy(tempStr, "\t\t\t16BPP Mode");
                
                break;

            case 1:
                strcpy(tempStr, "\t\t\t8BPP Mode");
                
                break;

            default:
                strcpy(tempStr, "\t\t\tUNKNOWN color depth");
            
                break;
        }
        dprintf("%s\n", tempStr);

        dprintf("LONG        cPelSize        %ld\n",  tempPDev.cPelSize);
        dprintf("LONG        cBitsPerPel     %ld\n",  tempPDev.cBitsPerPel);
        dprintf("DWORD       bPixShift       %ld\n",  tempPDev.bPixShift);
        dprintf("DWORD       bBppShift       %ld\n",  tempPDev.bBppShift);
        dprintf("DWORD       dwBppMask       %ld\n",  tempPDev.dwBppMask);

        dprintf("CAPS        flCaps          0x%x\n",  tempPDev.flCaps);

        //
        // Print the detail info of the CAPS
        //
        for ( pfd = afdCAPS; pfd->psz; ++pfd )
        {
            if ( tempPDev.flCaps & pfd->fl )
            {
                dprintf("\t\t\t%s\n", pfd->psz);
            }
        }

        dprintf("Status      flStatus        0x%x\n",  tempPDev.flStatus);

        //
        // Print the detail info of the STATUS
        //
        for ( pfd = afdSTATUS; pfd->psz; ++pfd )
        {
            if ( tempPDev.flStatus & pfd->fl )
            {
                dprintf("\t\t\t%s\n", pfd->psz);
            }
        }

        dprintf("FLONG       flHooks         0x%x\n", tempPDev.flHooks);

        //
        // Print the detail info of the HOOKS
        //
        for ( pfd = afdHOOK; pfd->psz; ++pfd )
        {
            if ( tempPDev.flHooks & pfd->fl )
            {
                dprintf("\t\t\t%s\n", pfd->psz);
            }
        }

        dprintf("Surf*       pdsurfScreen    0x%x\n", tempPDev.pdsurfScreen);
        dprintf("Surf*       pdsurfOffScreen 0x%x\n", tempPDev.pdsurfOffScreen);
        dprintf("LONG        cxScreen        %-6ld (Screen Width)\n",
                tempPDev.cxScreen);
        dprintf("LONG        cyScreen        %-6ld (Screen Height)\n",
                tempPDev.cyScreen);
        dprintf("ULONG       ulPermFormat    %ld\n",  tempPDev.ulPermFormat);
        dprintf("ULONG       ulPermFormatEx  %ld\n",  tempPDev.ulPermFormatEx);

        dprintf("POINTL      ptlOrigin       (%ld, %ld)\n",
                tempPDev.ptlOrigin.x, tempPDev.ptlOrigin.y);
    }// General Info

    if ( bAll || bHeap )
    {
        dprintf("\n*************Heap Manager Information*********\n");
        dprintf("VIDEOMEMORY* pvmList        0x%x\n", tempPDev.pvmList);
        dprintf("ULONG       cHeaps;         %ld\n",  tempPDev.cHeaps);
        dprintf("LONG        cxMemory        %-6ld (Video RAM Width)\n",
                tempPDev.cxMemory);
        dprintf("LONG        cyMemory        %-6ld (Video RAM Height)\n",
                tempPDev.cyMemory);
        dprintf("LONG        lDelta          %ld\n",  tempPDev.lDelta);
        dprintf("Surf*       psurfListHead   0x%x\n", tempPDev.psurfListHead);
        dprintf("Surf*       psurfListTail   0x%x\n", tempPDev.psurfListTail);
    }// Heap Info

    if ( bAll || bBase )
    {
        dprintf("\n*************Base Information*****************\n");
        dprintf("BYTE*       pjScreen        0x%x\n", tempPDev.pjScreen);
        dprintf("ULONG       ulMode          %ld\n",  tempPDev.ulMode);
        dprintf("ULONG*      pulCtrlBase[2]  0x%x, 0x%x\n",
                tempPDev.pulCtrlBase[0], tempPDev.pulCtrlBase[1]);
        dprintf("ULONG*      pulDenseCtrlBase 0x%x\n",
                tempPDev.pulDenseCtrlBase);
        dprintf("ULONG*      pulRamdacBase   0x%x\n", tempPDev.pulRamdacBase);
        dprintf("VOID*       pvTmpBuffer     0x%x\n", tempPDev.pvTmpBuffer);
        dprintf("LONG        lVidMemHeight   %ld\n",  tempPDev.lVidMemHeight);
        dprintf("LONG        lVidMemWidth    %ld\n",  tempPDev.lVidMemWidth);
        dprintf("UCHAR*      pjIoBase        %ld\n",  tempPDev.pjIoBase);
        dprintf("HwDataPtr   permediaInfo    0x%x\n", tempPDev.permediaInfo);
        dprintf("LONG        FrameBufferLength %ld\n",
                tempPDev.FrameBufferLength);
        dprintf("UINT_PTR    dwScreenStart   %ld\n",  tempPDev.dwScreenStart);
        dprintf("P2DMA*      pP2dma          0x%x\n", tempPDev.pP2dma);
        dprintf("DDPIXELFORMAT   ddpfDisplay %ld\n",  tempPDev.ddpfDisplay);
        dprintf("DWORD       dwChipConfig    %ld\n",  tempPDev.dwChipConfig);
        dprintf("ULONG*      pCtrlBase       0x%x\n", tempPDev.pCtrlBase);
        dprintf("ULONG*      pCoreBase       0x%x\n", tempPDev.pCoreBase);
        dprintf("ULONG*      pGPFifo         0x%x\n", tempPDev.pGPFifo);
        dprintf("PULONG      pulInFifoPtr    0x%x\n", tempPDev.pulInFifoPtr);
        dprintf("PULONG      pulInFifoStart  0x%x\n", tempPDev.pulInFifoStart);
        dprintf("PULONG      pulInFifoEnd    0x%x\n", tempPDev.pulInFifoEnd);
        dprintf("ULONG*      dmaBufferVirtualAddress 0x%x\n",
                tempPDev.dmaBufferVirtualAddress);
        dprintf("LARGE_INTEGER dmaBufferPhysicalAddress 0x%x\n",
                tempPDev.dmaBufferPhysicalAddress);
        dprintf("ULONG       dmaCurrentBufferOffset 0x%x\n",
                tempPDev.dmaCurrentBufferOffset);
        dprintf("ULONG       dmaActiveBufferOffset %ld\n",
                tempPDev.dmaActiveBufferOffset);
        dprintf("ULONG*      pulInputDmaCount 0x%x\n",
                tempPDev.pulInputDmaCount);
        dprintf("ULONG*      pulInputDmaAddress  0x%x\n",
                tempPDev.pulInputDmaAddress);
        dprintf("ULONG*      pulFifo         0x%x\n", tempPDev.pulFifo);
        dprintf("ULONG*      pulOutputFifoCount 0x%x\n",
                tempPDev.pulOutputFifoCount);
        dprintf("ULONG*      pulInputFifoCount 0x%x\n",
                tempPDev.pulInputFifoCount);
        dprintf("BOOL        bGdiContext     %ld\n",  tempPDev.bGdiContext);
        dprintf("BOOL        bNeedSync       %ld\n",  tempPDev.bNeedSync);
        dprintf("BOOL        bForceSwap      %ld\n",  tempPDev.bForceSwap);
        dprintf("SURFOBJ*    psoScreen       0x%x\n", tempPDev.psoScreen);
    }// Base Info

    if ( bAll || bGDI )
    {
        dprintf("\n*************GDI Runtime Information**********\n");
        dprintf("HANDLE      hDriver         0x%x\n", tempPDev.hDriver);
        dprintf("HDEV        hdevEng         0x%x\n", tempPDev.hdevEng);
        dprintf("HSURF       hsurfScreen     0x%x\n", tempPDev.hsurfScreen);
        dprintf("ULONG       iHeapUniq       %ld\n",  tempPDev.iHeapUniq);
    }// GDI Runtime Info

    if ( bAll || bPalette )
    {
        dprintf("\n*************Palette Information**************\n");
        dprintf("ULONG       ulWhite;        0x%x\n", tempPDev.ulWhite);
        dprintf("PALETTEENTRY* pPal          0x%x\n", tempPDev.pPal);
        dprintf("HPALETTE    hpalDefault     0x%x\n",  tempPDev.hpalDefault);
        dprintf("FLONG       flRed           0x%x\n",  tempPDev.flRed);
        dprintf("FLONG       flGreen         0x%x\n",  tempPDev.flGreen);
        dprintf("FLONG       flBlue          0x%x\n",  tempPDev.flBlue);
    }// Palette Info

    if ( bAll || bCursor )
    {
        dprintf("\n*************Cursor Information***************\n");
        dprintf("LONG        xPointerHot     %ld\n", tempPDev.xPointerHot);
        dprintf("LONG        yPointerHot     %ld\n", tempPDev.yPointerHot);
        dprintf("ULONG       ulHwGraphicsCursorModeRegister_45   %ld\n",
                tempPDev.ulHwGraphicsCursorModeRegister_45);
        dprintf("PtrFlags    flPointer       %ld %s\n",  tempPDev.flPointer,
                (tempPDev.flPointer == PTR_HW_ACTIVE)? "(HW Pointer)":"(SW Pointer)");
        dprintf("VOID*       pvPointerData   0x%x\n",  tempPDev.pvPointerData);
        dprintf("BYTE        ajPointerData   0x%x\n", tempPDev.ajPointerData);
        dprintf("BOOL        bPointerInitialized %ld\n",
                tempPDev.bPointerInitialized);
        dprintf("HWPointerCache  HWPtrCache  %ld\n",  tempPDev.HWPtrCache);
        dprintf("LONG        HWPtrLastCursor %ld\n",  tempPDev.HWPtrLastCursor);
        dprintf("LONG        HWPtrPos_X      %ld\n",  tempPDev.HWPtrPos_X);
        dprintf("LONG        HWPtrPos_Y      %ld\n",  tempPDev.HWPtrPos_Y);
    }// Cursor Info

    if ( bAll || bBrush )
    {
        dprintf("\n*************Brush Information****************\n");    
        dprintf("BOOL        bRealizeTransparent %ld\n",
                tempPDev.bRealizeTransparent);
        dprintf("LONG        cPatterns       %ld\n",  tempPDev.cPatterns);
        dprintf("LONG        lNextCachedBrush %ld\n",
                tempPDev.lNextCachedBrush);
        dprintf("LONG        cBrushCache     %ld\n",  tempPDev.cBrushCache);
        dprintf("BrushEntry  abeMono         0x%x, %ld\n",
                tempPDev.abeMono.prbVerify,
                tempPDev.abeMono.ulPixelOffset);
        dprintf("BrushEntry  abe[%d]         0x%x\n", TOTAL_BRUSH_COUNT,
                tempPDev.abe);
        dprintf("HBITMAP     ahbmPat[%d]      0x%x\n",
                HS_DDI_MAX, tempPDev.ahbmPat);
        dprintf("ULONG       ulBrushPackedPP 0x%x\n",
                tempPDev.ulBrushPackedPP);
        dprintf("VIDEOMEMORY* pvmBrushHeap   0x%x\n", tempPDev.pvmBrushHeap);
        dprintf("ULONG       ulBrushVidMem   0x%x\n", tempPDev.ulBrushVidMem);
    }// Brush Info

    if ( bAll || bDDraw )
    {
        dprintf("\n*************DDRAW/D3D Information************\n");

        dprintf("P2CtxtPtr   pDDContext      0x%x\n", tempPDev.pDDContext);
        dprintf("DDHAL_DDCALLBACKS DDHALCallbacks 0x%x\n",
                tempPDev.DDHALCallbacks);
        dprintf("DDHAL_DDSURFACECALLBACKS    DDSurfCallbacks 0x%x\n",
                tempPDev.DDSurfCallbacks);
        dprintf("DWORD       dwNewDDSurfaceOffset %ld\n",
                tempPDev.dwNewDDSurfaceOffset);
        dprintf("BOOL        bDdExclusiveMode %ld\n",
                tempPDev.bDdExclusiveMode);
        dprintf("BOOL        bDdStereoMode   %ld\n",  tempPDev.bDdStereoMode);
        dprintf("BOOL        bCanDoStereo    %ld\n",  tempPDev.bCanDoStereo);
        dprintf("UINT_PTR    pD3DDriverData32 0x%x\n",
                tempPDev.pD3DDriverData32);
        dprintf("UINT_PTR    pD3DHALCallbacks32 0x%x\n",
                tempPDev.pD3DHALCallbacks32);
        dprintf("UINT_PTR    dwGARTLin       %ld\n",  tempPDev.dwGARTLin);
        dprintf("UINT_PTR    dwGARTDev       %ld\n",  tempPDev.dwGARTDev);
        dprintf("UINT_PTR    dwGARTLinBase   %ld\n",  tempPDev.dwGARTLinBase);
        dprintf("UINT_PTR    dwGARTDevBase   %ld\n",  tempPDev.dwGARTDevBase);
        dprintf("DDHALINFO   ddhi32          0x%x\n", tempPDev.ddhi32);
        dprintf("PFND3DPARSEUNKNOWNCOMMAND pD3DParseUnknownCommand 0x%x\n",
                tempPDev.pD3DParseUnknownCommand);
    }// DDRAW/D3D Info

    return;
    
pdev_help:
    dprintf("Usage: pdev [-?] [-a] [-g] [-h] [-b] [-i] [-p] [-c] [-r]");
    dprintf(" [-d] PDEV_PTR\n");
    dprintf("-a     dump the whole PDev info\n");
    dprintf("-g     dump General info from the PDev\n");
    dprintf("-h     dump Heap Manager info from the PDev\n");
    dprintf("-b     dump Base info from the PDev\n");
    dprintf("-i     dump GDI Runtime info from the PDev\n");
    dprintf("-p     dump Palette info from the PDev\n");
    dprintf("-c     dump Cursor info from the PDev\n");
    dprintf("-r     dump Brush info from the PDev\n");
    dprintf("-d     dump DDRAW/D3D info from the PDev\n");
    
    return;
}// pdev

/**********************************Public*Routine******************************\
 *
 * Dump Permedia 2 display driver's function block
 *
 ******************************************************************************/
DECLARE_API(fb)
{
    GFNPB       tempFB;
    FLAGDEF*    pfd;
    
    //
    // Check if there is a "-?" in the command. If yes, show the help
    //
    PARSE_POINTER(fb_help);

    move(tempFB, (GFNPB*)arg);

    dprintf("----Permedia2 GFNPB Structure-------------\n");
    dprintf("VOID (*pgfn)(struct _GFNPB*)   0x%x\n", tempFB.pgfn);
    dprintf("PDev*          ppdev           0x%x\n", tempFB.ppdev);
    dprintf("Surf*          psurfDst        0x%x\n", tempFB.psurfDst);
    dprintf("RECTL*         prclDst         0x%x\n", tempFB.prclDst);
    dprintf("Surf*          psurfSrc        0x%x\n", tempFB.psurfSrc);
    dprintf("RECTL*         prclSrc         0x%x\n", tempFB.prclSrc);
    dprintf("POINTL*        pptlSrc         0x%x\n", tempFB.pptlSrc);
    dprintf("LONG           lNumRects       %ld\n",  tempFB.lNumRects);
    dprintf("RECTL*         pRects          0x%x\n", tempFB.pRects);
    dprintf("ULONG          colorKey        0x%x\n", tempFB.colorKey);
    dprintf("ULONG          solidColor      0x%x\n", tempFB.solidColor);
    dprintf("RBrush*        prbrush         0x%x\n", tempFB.prbrush);
    dprintf("POINTL*        pptlBrush       0x%x\n", tempFB.pptlBrush);
    dprintf("CLIPOBJ*       pco             0x%x\n", tempFB.pco);
    dprintf("XLATEOBJ*      pxlo            0x%x\n", tempFB.pxlo);
    dprintf("POINTL*        pptlMask        0x%x\n", tempFB.pptlMask);
    dprintf("ULONG          ulRop4          0x%x\n", tempFB.ulRop4);
    dprintf("UCHAR          ucAlpha         0x%x\n", tempFB.ucAlpha);
    dprintf("TRIVERTEX*     ptvrt           0x%x\n", tempFB.ptvrt);
    dprintf("ULONG          ulNumTvrt       %ld\n",  tempFB.ulNumTvrt);
    dprintf("PVOID          pvMesh          0x%x\n", tempFB.pvMesh);
    dprintf("ULONG          ulNumMesh       %ld\n",  tempFB.ulNumMesh);
    dprintf("ULONG          ulMode          0x%x\n", tempFB.ulMode);
    dprintf("SURFOBJ*       psoSrc          0x%x\n", tempFB.psoSrc);
    dprintf("SURFOBJ*       psoDst          0x%x\n", tempFB.psoDst);
    
    return;
    
fb_help:
    dprintf("Usage: fb [-?] GFNPB_PTR\n");
}// fb
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\tvp4020.h ===
/******************************Module*Header**********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: tvp4020.h
 *
 * This module contains the hardware pointer support for the display driver.
 * We also have support for color space double buffering using the RAMDAC pixel
 * read mask.
 *
 * Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
 *
\*****************************************************************************/
#define ADbgpf

//
// TI TVP4020 RAMDAC definitions
// This set of registers resides at &(pCtrlRegs->ExternalVideo)
//
typedef struct _tvp4020_regs
{
    //
    // register addresses
    //
    RAMDAC_REG  pciAddrWr;      // 0x00 - palette/cursor RAM write address,
                                // Index Register
    RAMDAC_REG  palData;        // 0x01 - palette RAM data
    RAMDAC_REG  pixelMask;      // 0x02 - pixel read mask
    RAMDAC_REG  pciAddrRd;      // 0x03 - palette/cursor RAM read address

    RAMDAC_REG  curColAddr;     // 0x04 - cursor color address
    RAMDAC_REG  curColData;     // 0x05 - cursor color data
    RAMDAC_REG  Reserved1;      // 0x06 - reserved
    RAMDAC_REG  Reserved2;      // 0x07 - reserved

    RAMDAC_REG  Reserved3;      // 0x08 - reserved
    RAMDAC_REG  Reserved4;      // 0x09 - reserved
    RAMDAC_REG  indexData;      // 0x0A - indexed data
    RAMDAC_REG  curRAMData;     // 0x0B - cursor RAM data

    RAMDAC_REG  cursorXLow;     // 0x0C - cursor position X low byte 
    RAMDAC_REG  cursorXHigh;    // 0x0D - cursor position X high byte 
    RAMDAC_REG  cursorYLow;     // 0x0E - cursor position Y low byte 
    RAMDAC_REG  cursorYHigh;    // 0x0F - cursor position Y high byte 
} TVP4020RAMDAC, *pTVP4020RAMDAC;

//
// structure containing the mapped addresses for each of the TVP4020 registers.
// We need this since some chips like the Alpha cannot be accessed by simply
// writing to the memory mapped register. So instead we set up the following
// struct of memory addresses at init time and use these instead. All these
// addresses must be passed to WRITE/READ_FAST_ULONG.
// We also keep software copies of various registers in here so we can turn
// on and off individual bits more easily.
//
typedef struct _tvp4020_data
{
    //
    // Register addresses
    //
    UINT_PTR    pciAddrRd;      // loads internal register for palette reads
    UINT_PTR    palData;        // read/write to get/set palette data
    UINT_PTR    pixelMask;      // mask to AND with input pixel data
    UINT_PTR    pciAddrWr;      // Palettte/Index/Cursor Write address register
    UINT_PTR    curRAMData;     // read/write to get/set cursor shape data

    UINT_PTR    indexData;      // read/write to get/set control/cursor data

    UINT_PTR    curAddrRd;      // loads internal register for cursor reads
    UINT_PTR    curAddrWr;      // loads internal register for cursor writes
    UINT_PTR    curData;        // read/write to get/set cursor color data
    UINT_PTR    curColAddr;     // cursor color address
    UINT_PTR    curColData;     // cursor color data

    UINT_PTR    cursorXLow;     // Cursor's X position low byte 
    UINT_PTR    cursorXHigh;    // Cursor's X position high byte 
    UINT_PTR    cursorYLow;     // Cursor's Y position low byte 
    UINT_PTR    cursorYHigh;    // Cursor's Y position high byte 

    // RAMDAC state info
    ULONG       cursorControlOff;
                                // cursor disabled
    ULONG       cursorControlCurrent;
                                // disabled 32/64 mode cursor 
} TVP4020Data, *pTVP4020Data;

//
// Macro declared by any function wishing to use the P2 internal RAMDAC . MUST
// be declared after PERMEDIA_DECL.
//
#define TVP4020_DECL_VARS pTVP4020Data pTVP4020info
#define TVP4020_DECL_INIT pTVP4020info = (pTVP4020Data)ppdev->pvPointerData

#define TVP4020_DECL \
            TVP4020_DECL_VARS; \
            TVP4020_DECL_INIT

//
// Use the following macros as the address to pass to the WRITE_4020REG_ULONG
// function
//
//  Palette Access
//
#define __TVP4020_PAL_WR_ADDR               (pTVP4020info->pciAddrWr)
#define __TVP4020_PAL_RD_ADDR               (pTVP4020info->pciAddrRd)
#define __TVP4020_PAL_DATA                  (pTVP4020info->palData)

//
// Pixel mask
//
#define __TVP4020_PIXEL_MASK                (pTVP4020info->pixelMask)

//
// Access to the indexed registers
//
#define __TVP4020_INDEX_ADDR                (pTVP4020info->pciAddrWr)
#define __TVP4020_INDEX_DATA                (pTVP4020info->indexData)

//
// Access to the Cursor
//
#define __TVP4020_CUR_RAM_WR_ADDR           (pTVP4020info->pciAddrWr)
#define __TVP4020_CUR_RAM_RD_ADDR           (pTVP4020info->pciAddrRd)
#define __TVP4020_CUR_RAM_DATA              (pTVP4020info->curRAMData)

#define __TVP4020_CUR_COL_ADDR              (pTVP4020info->curColAddr)
#define __TVP4020_CUR_COL_DATA              (pTVP4020info->curColData)

//
// Cursor position control
//
#define __TVP4020_CUR_X_LSB                 (pTVP4020info->cursorXLow)
#define __TVP4020_CUR_X_MSB                 (pTVP4020info->cursorXHigh)
#define __TVP4020_CUR_Y_LSB                 (pTVP4020info->cursorYLow)
#define __TVP4020_CUR_Y_MSB                 (pTVP4020info->cursorYHigh)

//
//----------------------Values for some direct registers---------------------
//

/*****************************************************************************/
/*              DIRECT REGISTER - CURSOR POSITION CONTROL                    */
/*****************************************************************************/
//  ** TVP4020_CUR_X_LSB 
//  ** TVP4020_CUR_X_MSB 
//  ** TVP4020_CUR_Y_LSB 
//  ** TVP4020_CUR_Y_MSB 
//      Default - undefined
// Values written into those registers represent the BOTTOM-RIGHT corner
// of the cursor. If 0 is in X or Y position - the cursor is off the screen
// Only 12 bits are used, giving the range from 0 to 4095 ( 0x0000 - 0x0FFF)
// The size of the cursor is (64,64) (0x40, 0x40)
//
#define TVP4020_CURSOR_OFFSCREEN            0x00    // Cursor offscreen

/*****************************************************************************/
/*              DIRECT REGISTER - CURSOR COLORS                              */
/*****************************************************************************/

#define TVP4020_CURSOR_COLOR0               0x01
#define TVP4020_CURSOR_COLOR1               0x02
#define TVP4020_CURSOR_COLOR2               0x03

/*****************************************************************************/
/*              INDIRECT REGISTER - CURSOR CONTROL                           */
/*****************************************************************************/
#define __TVP4020_CURSOR_CONTROL            0x06    // Indirect cursor control - 
//      Default - 0x00

#define TVP4020_CURSOR_SIZE_32              (0 << 6)// 32x32 cursor
#define TVP4020_CURSOR_SIZE_MASK            (1 << 6)// Mask

#define TVP4020_CURSOR_32_SEL(i)            ((i) << 4)// one of 4 32x32 cursors
                                                      // changed to << 4
#define TVP4020_CURSOR_32_MASK              (0x03 << 4) // Mask

#define TVP4020_CURSOR_RAM_ADDRESS(x)       (((x) & 0x03) << 2)
                                                    // High bits of cursor RAM
                                                    // address
#define TVP4020_CURSOR_RAM_MASK             ((0x03) << 2)
                                                    // Mask for high bits of
                                                    // cursor RAM address

// Added constants for cursor mode
#define TVP4020_CURSOR_OFF                  0x00    // Cursor off
#define TVP4020_CURSOR_COLOR                0x01    // 2-bits select color
#define TVP4020_CURSOR_XGA                  0x02    // 2-bits select XOR
#define TVP4020_CURSOR_XWIN                 0x03    // 2-bits select transparency/color
#define TVP4020_CURSOR_MASK                 0x03    // Mask

/*****************************************************************************/
/*              INDIRECT REGISTER - COLOR MODE REGISTER                      */
/*****************************************************************************/
#define __TVP4020_COLOR_MODE                0x18    //  Color Mode Register
//      Default - 0x00

#define TVP4020_TRUE_COLOR_ENABLE           (1 << 7)// True Color data accesses LUT
#define TVP4020_TRUE_COLOR_DISABLE          (0 << 7)// Non true color accesses LUT

#define TVP4020_RGB_MODE                    (1 << 5)// RGB mode Swapped 0/1 (0=BGR, 1=RGB)
#define TVP4020_BGR_MODE                    (0 << 5)// BGR mode

#define TVP4020_VGA_SELECT                  (0 << 4)// select VGA mode
#define TVP4020_GRAPHICS_SELECT             (1 << 4)// select graphics modes

#define TVP4020_PIXEL_MODE_CI8              (0 << 0)// pseudo color or VGA mode
#define TVP4020_PIXEL_MODE_332              (1 << 0)// 332 true color
#define TVP4020_PIXEL_MODE_2320             (2 << 0)// 232 off
#define TVP4020_PIXEL_MODE_2321             (3 << 0)//
#define TVP4020_PIXEL_MODE_5551             (4 << 0)// 
#define TVP4020_PIXEL_MODE_4444             (5 << 0)// 
#define TVP4020_PIXEL_MODE_565              (6 << 0)// 
#define TVP4020_PIXEL_MODE_8888             (8 << 0)// 
#define TVP4020_PIXEL_MODE_PACKED           (9 << 0)// 24 bit packed

/********************************************************************************/
/*              INDIRECT REGISTER - MODE CONTROL REGISTER                       */
/********************************************************************************/
#define __TVP4020_MODE_CONTROL              0x19    //  Mode control
//      Default - 0x00

#define TVP4020_PRIMARY_INPUT               (0 << 4)// Primary input throuh palette
#define TVP4020_SECONDARY_INPUT             (1 << 4)// Secondary input throuh palette

#define TVP4020_5551_DBL_BUFFER             (1 << 2)// Enable 5551 dbl buffer
#define TVP4020_5551_PACKED                 (0 << 2)// Packed 555 mode

#define TVP4020_ENABLE_STATIC_DBL_BUFFER    (1 << 1)// Static dbl buffer enabled
#define TVP4020_DISABLE_STATIC_DBL_BUFFER   (1 << 1)// Static dbl buffer disabled

#define TVP4020_SELECT_FRONT_MODE           (0 << 0)// Front mode
#define TVP4020_SELECT_BACK_MODE            (1 << 0)// Back mode

/*****************************************************************************/
/*              INDIRECT REGISTER - PALETTE PAGE                             */
/*****************************************************************************/
#define __TVP4020_PALETTE_PAGE              0x1C    //  
//      Default - 0x00

/*****************************************************************************/
/*              INDIRECT REGISTER - MISC CONTROL                             */
/*****************************************************************************/
#define __TVP4020_MISC_CONTROL              0x1E    //  
//      Default - 0x00
#define TVP4020_SYNC_ENABLE                 (1 << 5)// Output SYNC info onto IOG
#define TVP4020_SYNC_DISABLE                (0 << 5)// No SYNC IOG output

#define TVP4020_PEDESTAL_0                  (0 << 4)// 0 IRE blanking pedestal
#define TVP4020_PEDESTAL_75                 (1 << 4)// 7.5 IRE blanking pedestal

#define TVP4020_VSYNC_INVERT                (1 << 3)// invert VSYNC output polarity
#define TVP4020_VSYNC_NORMAL                (0 << 3)// normal VSYNC output polarity

#define TVP4020_HSYNC_INVERT                (1 << 2)// invert HSYNC output polarity
#define TVP4020_HSYNC_NORMAL                (0 << 3)// normal HSYNC output polarity

#define TVP4020_DAC_8BIT                    (1 << 1)// DAC is in 8-bit mode
#define TVP4020_DAC_6BIT                    (0 << 1)// DAC is in 6-bit mode

#define TVP4020_DAC_POWER_ON                (0 << 0)// Turn DAC Power on 
#define TVP4020_DAC_POWER_OFF               (1 << 0)// Turn DAC Power off 

/*****************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY CONTROL                        */
/*****************************************************************************/
#define __TVP4020_CK_CONTROL                0x40    //  
//      Default - 0x00

/*****************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY OVERLAY                        */
/*****************************************************************************/
#define __TVP4020_CK_OVR_REG                0x41    //  
//      Default - 0x00

/*****************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY RED                            */
/*****************************************************************************/
#define __TVP4020_CK_RED_REG                0x42    //  
//      Default - 0x00

/*****************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY GREEN                          */
/*****************************************************************************/
#define __TVP4020_CK_GREEN_REG              0x43    //  
//      Default - 0x00

/*****************************************************************************/
/*              INDIRECT REGISTER - COLOR KEY BLUE                           */
/*****************************************************************************/
#define __TVP4020_CK_BLUE_REG               0x44    //  
//      Default - 0x00

/*****************************************************************************/
/*              INDIRECT REGISTER - PIXEL CLOCK PLL                          */
/*****************************************************************************/

#define __TVP4020_PIXCLK_REG_A1             0x20
#define __TVP4020_PIXCLK_REG_A2             0x21
#define __TVP4020_PIXCLK_REG_A3             0x22
#define __TVP4020_PIXCLK_REG_B1             0x23
#define __TVP4020_PIXCLK_REG_B2             0x24
#define __TVP4020_PIXCLK_REG_B3             0x25
#define __TVP4020_PIXCLK_REG_C1             0x26
#define __TVP4020_PIXCLK_REG_C2             0x27
#define __TVP4020_PIXCLK_REG_C3             0x28

#define __TVP4020_PIXCLK_STATUS             0x29

/*****************************************************************************/
/*              INDIRECT REGISTER - MEMORU CLOCK PLL                         */
/*****************************************************************************/

#define __TVP4020_MEMCLK_REG_1              0x30
#define __TVP4020_MEMCLK_REG_2              0x31
#define __TVP4020_MEMCLK_REG_3              0x32

#define __TVP4020_MEMCLK_STATUS             0x33

//
// generic read/write routines for 3026 registers
//
#define WRITE_4020REG_ULONG(r, d) \
{ \
    WRITE_REGISTER_ULONG((PULONG)(r), (d)); \
    MEMORY_BARRIER(); \
}

#define READ_4020REG_ULONG(r)    READ_REGISTER_ULONG((PULONG)(r))

// macro to load a given data value into an internal TVP4020 register.
//
#define TVP4020_SET_INDEX_REG(index) \
{ \
    ADbgpf(("*(0x%X) <-- 0x%X\n", __TVP4020_INDEX_ADDR, (index) & 0xff)); \
    WRITE_4020REG_ULONG(__TVP4020_INDEX_ADDR, (ULONG)((index) & 0xff)); \
}

#define TVP4020_WRITE_INDEX_REG(index, data) \
{ \
    TVP4020_SET_INDEX_REG(index);                            \
    ADbgpf(("*(0x%X) <-- 0x%X\n", __TVP4020_INDEX_DATA, (data) & 0xff)); \
    WRITE_4020REG_ULONG(__TVP4020_INDEX_DATA, (ULONG)((data) & 0xff)); \
}

#define TVP4020_READ_INDEX_REG(index, data) \
{ \
    TVP4020_SET_INDEX_REG(index); \
    data = READ_4020REG_ULONG(__TVP4020_INDEX_DATA) & 0xff;   \
    ADbgpf(("0x%X <-- *(0x%X)\n", data, __TVP4020_INDEX_DATA)); \
}

//
// For compatibility with TVP3026
//
//#define TVP4020_LOAD_CURSOR_CTRL(data) \
//{ \
//    volatile LONG   __temp;                                    \
//    TVP4020_READ_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp);  \
//    __temp &= ~(0x03) ;                                        \
//    __temp |= ((data) & 0x03) ;                                \
//    TVP4020_WRITE_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp); \
//}

//
// Macros to write a given RGB triplet into cursors 0, 1 and 2
//
#define TVP4020_SET_CURSOR_COLOR0(red, green, blue) \
{ \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_ADDR,   (ULONG)(TVP4020_CURSOR_COLOR0));    \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_DATA,   (ULONG)(red));    \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_DATA,   (ULONG)(green));  \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_DATA,   (ULONG)(blue));   \
}

#define TVP4020_SET_CURSOR_COLOR1(red, green, blue) \
{ \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_ADDR,   (ULONG)(TVP4020_CURSOR_COLOR1));    \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_DATA,   (ULONG)(red));    \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_DATA,   (ULONG)(green));  \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_DATA,   (ULONG)(blue));   \
}

#define TVP4020_SET_CURSOR_COLOR2(red, green, blue) \
{ \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_ADDR,   (ULONG)(TVP4020_CURSOR_COLOR2));    \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_DATA,   (ULONG)(red));    \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_DATA,   (ULONG)(green));  \
    WRITE_4020REG_ULONG(__TVP4020_CUR_COL_DATA,   (ULONG)(blue));   \
}

//
// Macros to load a given RGB triple into the TVP4020 palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use TVP4020_PALETTE_START and multiple TVP4020_LOAD_PALETTE calls to load
// a contiguous set of entries. Use TVP4020_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//
#define TVP4020_PALETTE_START_WR(index) \
{ \
    WRITE_4020REG_ULONG(__TVP4020_PAL_WR_ADDR,     (ULONG)(index));    \
}

#define TVP4020_PALETTE_START_RD(index) \
{ \
    WRITE_4020REG_ULONG(__TVP4020_PAL_RD_ADDR,     (ULONG)(index));    \
}

#define TVP4020_LOAD_PALETTE(red, green, blue) \
{ \
    WRITE_4020REG_ULONG(__TVP4020_PAL_DATA,    (ULONG)(red));      \
    WRITE_4020REG_ULONG(__TVP4020_PAL_DATA,    (ULONG)(green));    \
    WRITE_4020REG_ULONG(__TVP4020_PAL_DATA,    (ULONG)(blue));     \
}

#define TVP4020_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    WRITE_4020REG_ULONG(__TVP4020_PAL_WR_ADDR, (ULONG)(index));    \
    WRITE_4020REG_ULONG(__TVP4020_PAL_DATA,    (ULONG)(red));      \
    WRITE_4020REG_ULONG(__TVP4020_PAL_DATA,    (ULONG)(green));    \
    WRITE_4020REG_ULONG(__TVP4020_PAL_DATA,    (ULONG)(blue));     \
}

//
// Macro to read back a given RGB triple from the TVP4020 palette. Use after
// a call to TVP4020_PALETTE_START_RD
//
#define TVP4020_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR)(READ_4020_ULONG(__TVP4020_PAL_DATA) & 0xff);        \
    green = (UCHAR)(READ_4020_ULONG(__TVP4020_PAL_DATA) & 0xff);        \
    blue  = (UCHAR)(READ_4020_ULONG(__TVP4020_PAL_DATA) & 0xff);        \
}

//
// Macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//
#define TVP4020_SET_PIXEL_READMASK(mask) \
{ \
    WRITE_4020REG_ULONG(__TVP4020_PIXEL_MASK,  (ULONG)(mask)); \
}

#define TVP4020_READ_PIXEL_READMASK(mask) \
{ \
    mask = READ_4020_ULONG(__TVP4020_PIXEL_MASK) & 0xff; \
}

//
// Macros to load values into the cursor array
//
#define CURSOR_PLANE0_OFFSET 0
#define CURSOR_PLANE1_OFFSET 0x200

#define TVP4020_CURSOR_ARRAY_START(offset) \
{ \
    volatile LONG   __temp;                                     \
    TVP4020_READ_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp);   \
    __temp &= ~TVP4020_CURSOR_RAM_MASK ;                        \
    __temp |= TVP4020_CURSOR_RAM_ADDRESS((offset)>> 8) ;        \
    TVP4020_WRITE_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp);  \
    WRITE_4020REG_ULONG(__TVP4020_CUR_RAM_WR_ADDR,   (ULONG)((offset)& 0xff));   \
}

//
// Changed to __TVP4020_CUR_RAM_DATA
//
#define TVP4020_LOAD_CURSOR_ARRAY(data) \
{ \
    WRITE_4020REG_ULONG(__TVP4020_CUR_RAM_DATA, (ULONG)(data)); \
}

//
// Changed to __TVP4020_CUR_RAM_DATA
//
#define TVP4020_READ_CURSOR_ARRAY(data) \
{ \
    data = READ_4020REG_ULONG(__TVP4020_CUR_RAM_DATA) & 0xff; \
}

//
// Macro to move the cursor
//
#define TVP4020_MOVE_CURSOR(x, y) \
{ \
    WRITE_4020REG_ULONG(__TVP4020_CUR_X_LSB,    (ULONG)((x) & 0xff));   \
    WRITE_4020REG_ULONG(__TVP4020_CUR_X_MSB,    (ULONG)((x) >> 8));     \
    WRITE_4020REG_ULONG(__TVP4020_CUR_Y_LSB,    (ULONG)((y) & 0xff));   \
    WRITE_4020REG_ULONG(__TVP4020_CUR_Y_MSB,    (ULONG)((y) >> 8));     \
}

//
// Exported functions from pointer.c. Anything which is TVP4020 specific goes
// in this file as well as real pointer stuff.
//
extern BOOL  bTVP4020CheckCSBuffering(PPDev);
extern BOOL  bTVP4020SwapCSBuffers(PPDev, LONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\dbgext\kdexts.cxx ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: kdexts.cxx
*
* Contains all the kernel debugger extension necessary routines
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "dbgext.hxx"
#include <ntverp.h>

//
// globals
//
EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;


DllInit(HANDLE hModule,
        DWORD  dwReason,
        DWORD  dwReserved)
{
    switch ( dwReason )
    {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}// DllInit()

VOID
WinDbgExtensionDllInit(PWINDBG_EXTENSION_APIS   lpExtensionApis,
                       USHORT                   MajorVersion,
                       USHORT                   MinorVersion)
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}// WinDbgExtensionDllInit()

DECLARE_API(version)
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf("%s Extension dll for Build %d debugging %s kernel for Build %d\n",
            DebuggerType,
            VER_PRODUCTBUILD,
            SavedMajorVersion == 0x0c ? "Checked" : "Free",
            SavedMinorVersion);
}// version

VOID
CheckVersion(VOID)
{
#if DBG
    if ( (SavedMajorVersion != 0x0c)
       ||(SavedMinorVersion != VER_PRODUCTBUILD) )
    {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion,
                (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ( (SavedMajorVersion != 0x0f)
       ||(SavedMinorVersion != VER_PRODUCTBUILD) )
    {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}// CheckVersion()

LPEXT_API_VERSION
ExtensionApiVersion(VOID)
{
    return &ApiVersion;
}// ExtensionApiVersion()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\dbgext\flags.cxx ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * GDI SAMPLE CODE *
*                           *******************
*
* Module Name: flags.cxx
*
* Contains all the flags stuff
*
* Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-1999 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "dbgext.hxx"
#include "gdi.h"

//
// The following define expans 'FLAG(x)' to '"x", x':
//
#define FLAG(x) { #x, x }

#define END_FLAG { 0, 0 }

FLAGDEF afdSURF[] =
{
    { "Surface is in Video Memory          ", SF_VM         },
    { "Surface is in System Memory         ", SF_SM         },
    { "Surface is in AGP Memory            ", SF_AGP        },
    { "Surface is kept in surface list     ", SF_LIST       },
    { "Surface was allocated by the driver ", SF_ALLOCATED  },
    { "Surface is a DDRAW wrap surface     ", SF_DIRECTDRAW },
    { NULL                                  , 0             }
};

FLAGDEF afdCAPS[] =
{
    { "CAPS_ZOOM_X_BY2      ", CAPS_ZOOM_X_BY2      },
    { "CAPS_ZOOM_Y_BY2      ", CAPS_ZOOM_Y_BY2      },
    { "CAPS_SPARSE_SPACE    ", CAPS_SPARSE_SPACE    },
    { "CAPS_SW_POINTER      ", CAPS_SW_POINTER      },
    { "CAPS_TVP4020_POINTER ", CAPS_TVP4020_POINTER },
    { "CAPS_P2RD_POINTER    ", CAPS_P2RD_POINTER    },
    { NULL                   , 0                    }
};

FLAGDEF afdSTATUS[] =
{
    { "STAT_BRUSH_CACHE     ", STAT_BRUSH_CACHE     },
    { "STAT_DEV_BITMAPS     ", STAT_DEV_BITMAPS     },
    { "ENABLE_BRUSH_CACHE   ", ENABLE_BRUSH_CACHE   },
    { "ENABLE_DEV_BITMAPS   ", ENABLE_DEV_BITMAPS   },
    { NULL                   , 0                    }
};

FLAGDEF afdHOOK[] = {
    { "HOOK_ALPHABLEND        ", HOOK_ALPHABLEND        },
    { "HOOK_BITBLT            ", HOOK_BITBLT            },
    { "HOOK_COPYBITS          ", HOOK_COPYBITS          },
    { "HOOK_FILLPATH          ", HOOK_FILLPATH          },
    { "HOOK_GRADIENTFILL      ", HOOK_GRADIENTFILL      },
    { "HOOK_LINETO            ", HOOK_LINETO            },
    { "HOOK_PAINT             ", HOOK_PAINT             },
    { "HOOK_PLGBLT            ", HOOK_PLGBLT            },
    { "HOOK_STRETCHBLT        ", HOOK_STRETCHBLT        },
    { "HOOK_STRETCHBLTROP     ", HOOK_STRETCHBLTROP     },
    { "HOOK_STROKEANDFILLPATH ", HOOK_STROKEANDFILLPATH },
    { "HOOK_STROKEPATH        ", HOOK_STROKEPATH        },
    { "HOOK_SYNCHRONIZE       ", HOOK_SYNCHRONIZE       },
    { "HOOK_TEXTOUT           ", HOOK_TEXTOUT           },
    { "HOOK_TRANSPARENTBLT    ", HOOK_TRANSPARENTBLT    },
    { NULL                     , 0                      }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\dbgext\extparse.h ===
/******************************Module*Header***********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: extparse.h
 *
 * Header fiel for all the token parser functions
 *
 * Copyright (C) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
 ******************************************************************************/
#ifndef __EXTPARSE__H__
#define __EXTPARSE__H__

int iParseTokenizer(char* pcCmdStr, char** ppcTok);
int iParseFindNonSwitch(char** ppcTok, int iTok, int iStart = 0);

int iParseIsToken(char **ppcTok, int iTokPos, char* pcChk);
int iParseiIsToken(char **ppcTok, int iTokPos, char* pcChk);

int iParseFindToken(char** ppcTok, int iTok, char* pcSrchTok);
int iParseiFindToken(char** ppcTok, int iTok, char* pcSrchTok);

int iParseIsSwitch(char**   ppcTok, int iTokPos, char cSwitch);
int iParseiIsSwitch(char**  ppcTok, int iTokPos, char cSwitch);
int iParseFindSwitch(char** ppcTok, int iTok, char cSwitch);
int iParseiFindSwitch(char**    ppcTok, int iTok, char cSwitch);

/**********************************Public*Routine******************************\
 *
 * Parse the arguments passed to the extension
 * Automatically handle the -? option
 *
 ******************************************************************************/
#define PARSE_ARGUMENTS(ext_label)               \
  char tmp_args[200];                            \
  char *tokens[40];                              \
  int ntok, tok_pos;                             \
  strcpy(tmp_args, args);                        \
  ntok = iParseTokenizer(tmp_args, tokens);      \
  if(ntok>0) {                                   \
    tok_pos=iParseFindSwitch(tokens, ntok, '?'); \
    if(tok_pos>=0) {                             \
      goto ext_label;                            \
    }                                            \
  }                                              \
  tok_pos=0

/**********************************Public*Routine******************************\
 *
 * Parse the arguments assuming a required parameter
 * which is a pointer to be parsed with the expression
 * handler.
 *
 ******************************************************************************/
#define PARSE_POINTER(ext_label)                 \
  UINT_PTR arg;                                     \
  PARSE_ARGUMENTS(ext_label);                    \
  if(ntok<1) {goto ext_label;}                   \
  tok_pos = iParseFindNonSwitch(tokens, ntok);   \
  if(tok_pos==-1) {goto ext_label;}              \
  arg = (UINT_PTR)GetExpression(tokens[tok_pos])

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\dbgext\extparse.cxx ===
/******************************Module*Header***********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: extparse.cxx
 *
 * Contains all the token parser functions
 *
 * Copyright (C) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
 ******************************************************************************/
#include "dbgext.hxx"

/**********************************Public*Routine******************************\
 *
 * Command line parsing routines
 *
 * This routine should return an array of char* 's in the idx parameter with the
 * beginning of each token in the array.
 * It also returns the number of tokens found. 
 *
 ******************************************************************************/
int
iParseTokenizer(char*   pcCmdStr,
                char**  ppcTok)
{
    char*   pcSeps = " \t\n";                  // white space separators
    char*   pcToken = strtok(pcCmdStr, pcSeps);  // get the first token
    int     iTokCount = 0;                 // the token count
    
    while ( pcToken )
    {
        ppcTok[iTokCount++] = pcToken;
        pcToken = strtok(NULL, pcSeps);
    }

    return iTokCount;
}// iParseTokenizer()

/**********************************Public*Routine******************************\
 *
 * This routine finds the token specified in srchtok 
 * and returns the index into tok.
 * A return value of -1 is used if the token is not found.
 *
 * Generally we use the case insensitive version (iParseiFindToken) 
 * but occasionally we need the case sensitive version (iParseFindToken).
 *
 ******************************************************************************/
int
iParseFindToken(char**  ppcTok,
                int     iTok,
                char*   pcSrchTok)
{
    for ( int iTemp = 0; iTemp < iTok; ++iTemp )
    {
        if ( strcmp(ppcTok[iTemp], pcSrchTok) == 0 )
        {
            break;
        }
    }
    if ( iTemp >= iTok )
    {
        return -1;
    }

    return iTemp;
}// iParseFindToken()

/**********************************Public*Routine******************************\
 *
 * Case insensitive version of iParseFindToken
 *
 ******************************************************************************/
int
iParseiFindToken(char** ppcTok,
                 int    iTok,
                 char*  pcSrchTok)
{
    for ( int iTemp = 0; iTemp < iTok; ++iTemp )
    {
        if ( _strnicmp(ppcTok[iTemp], pcSrchTok, strlen(pcSrchTok)) == 0 )
        {
            break;
        }
    }

    if ( iTemp >= iTok )
    {
        return -1;
    }

    return iTemp;
}// iParseiFindToken()

/**********************************Public*Routine******************************\
 *
 * Verifies that the given token at tok[iTokPos] is a switch
 * and contains the switch value cSwitch.
 *
 * Both case sensitive and insensitive versions.
 *
 ******************************************************************************/
int
iParseiIsSwitch(char**  ppcTok,
                int     iTokPos,
                char    cSwitch)
{
    if ( iTokPos < 0 )
    {
        return 0;
    }

    char*   pcTemp = ppcTok[iTokPos];

    if ( (pcTemp[0] == '-' ) || ( pcTemp[0] == '/' ) )
    {
        //
        // Is a switch.
        //
        for ( pcTemp++; *pcTemp; pcTemp++ )
        {
            if ( toupper(*pcTemp) == toupper(cSwitch) )
            {
                return 1;
            }
        }
    }

    return 0;
}// iParseiIsSwitch()

int
iParseIsSwitch(char**   ppcTok,
               int      iTokPos,
               char     cSwitch)
{
    if ( iTokPos < 0 )
    {
        return 0;
    }

    char*   pcTemp = ppcTok[iTokPos];

    if ( (pcTemp[0] == '-') || (pcTemp[0] == '/') )
    {
        //
        // Is a switch.
        //
        for ( pcTemp++; *pcTemp; pcTemp++ )
        {
            if ( *pcTemp == cSwitch )
            {
                return 1;
            }// search each char
        }
    }

    return 0;
}// iParseIsSwitch()

/**********************************Public*Routine******************************\
 *
 * Finds a switch in a given list of tokens.
 * of the form -xxx(cSwitch)xxx or /xxx(cSwitch)xxx
 * example:
 * searching for 'a' in -jklabw returns true.
 *
 * Again both case sensitive and insensitive versions are needed.
 *
 ******************************************************************************/
int
iParseFindSwitch(char** ppcTok,
                 int    iTok,
                 char   cSwitch)
{
    //
    // Search each token
    //
    for ( int iTemp = 0; iTemp < iTok; ++iTemp )
    {
        if ( iParseIsSwitch(ppcTok, iTemp, cSwitch) )
        {
            return iTemp;
        }// found it? return position.
    }

    return -1;
}// iParseIsSwitch()

int
iParseiFindSwitch(char**    ppcTok,
                  int       iTok,
                  char      cSwitch)
{
    for ( int iTemp = 0; iTemp < iTok; ++iTemp )
    {
        if ( iParseIsSwitch(ppcTok, iTemp, cSwitch) )
        {
            return iTemp;
        }//found it? return position.
    }

    return -1;
}// iParseIsSwitch()

/**********************************Public*Routine******************************\
 *
 * Find the first non-switch token starting from position start
 * Will find token at position start
 *
 ******************************************************************************/
int
iParseFindNonSwitch(char**  ppcTok,
                    int     iTok,
                    int     iStart)
{
    for (int iTemp = iStart; iTemp < iTok; ++iTemp )
    {
        if ( (ppcTok[iTemp][0]!='-')&&(ppcTok[iTemp][0]!='/') )
        {
            break;
        }
    }

    if ( iTemp >= iTok )
    {
        return -1;
    }

    return iTemp;
}// iParseFindNonSwitch()

/**********************************Public*Routine******************************\
 *
 * Case insensitive token comparer.
 * returns 1 if pcChk == ppcTok[iTokPos] otherwise returns 0
 *
 * Pay careful attention to the length specifier in the _strnicmp
 *
 ******************************************************************************/
int
iParseiIsToken(char**   ppcTok,
               int      iTokPos,
               char*    pcChk)
{
    if ( iTokPos < 0 )
    {
        return 0;
    }

    return(_strnicmp(ppcTok[iTokPos], pcChk, strlen(pcChk)) == 0);
}// iParseiIsToken()

int
iParseIsToken(char**    ppcTok,
              int       iTokPos,
              char*     pcChk)
{
    if ( iTokPos < 0 )
    {
        return 0;
    }
    return(strcmp(ppcTok[iTokPos], pcChk) == 0);
}// iParseIsToken()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\disp\dbgext\help.cxx ===
/******************************Module*Header***********************************\
 *
 *                           *******************
 *                           * GDI SAMPLE CODE *
 *                           *******************
 *
 * Module Name: help.cxx
 *
 * Display the help information for p2kdx debug extension
 *
 * Copyright (C) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
 * Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
 ******************************************************************************/
#include "dbgext.hxx"

/**********************************Public*Routine******************************\
 *
 * help
 *
 * Prints a simple help summary of the debugging extentions.
 *
 *
 * Note: If you add any debugger extentions, please add a brief description here
 *      then your new extention will be showed when the user types:
 *      !p2kdx.help
 *
 ******************************************************************************/
char*   gaszHelp[] =
{
 "=======================================================================\n"
,"Permedia 2 debugger extentions:\n"
,"-----------------------------------------------------------------------\n"
,"\n"
,"help\n"
,"Displays this help page.\n"
,"All of the debugger extensions support a -? option for extension specific " 
,"help.\n"
,"All of the debugger extensions that expect a pointer (or handle) can\n"
,"parse expressions. Such as: ebp+8\n"
,"\n"
,"Switches are case insensitive and can be reordered unless otherwise\n"
,"specified in the extension help\n"
,"\n"
,"  - general extensions -\n"
,"\n"
,"surf [Surf Pointer]                             -- dump permedia surf info\n"
,"pdev [PDev Pointer] [-?aghbipcrd]               -- dump permedia PDev info\n"
,"fb   [FunctionBlock Pointer]                    -- dump blt function block\n"
,"\n"
,"=======================================================================\n"
,NULL
};

DECLARE_API(help)
{
    for (char **ppsz = gaszHelp; *ppsz; ppsz++)
    {
        dprintf("%s",*ppsz);
    }
};// help()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\mini\p2rd.h ===
//***************************************************************************
//
// Module Name:
// 
// 	p2rd.h
// 
// Abstract:
// 
//      This module contains the definitions for the 3Dlabs P2ST RAMDAC
// 
// Environment:
// 
//     Kernel mode
//
//
// Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.            
// Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//***************************************************************************


//
// structure with all the direct access registers
//
    
typedef struct _p2rd_regs
{
    RAMDAC_REG    RDPaletteWriteAddress;
    RAMDAC_REG    RDPaletteData;
    RAMDAC_REG    RDPixelMask;
    RAMDAC_REG    RDPaletteAddressRead;
    RAMDAC_REG    RDIndexLow;
    RAMDAC_REG    RDIndexHigh;
    RAMDAC_REG    RDIndexedData;
    RAMDAC_REG    RDIndexControl;
}
P2RDRAMDAC;

//
// macro declared by any function wishing to use the RGB525 RAMDAC. MUST be declared
// after P2_DECL.
//
    
#define P2RD_DECL \
    P2RDRAMDAC *pP2RDRegs = (P2RDRAMDAC *)hwDeviceExtension->pRamdac

//
// use the following macros as the address to pass to the
// VideoPortWriteRegisterUlong function
//
    
#define P2RD_PAL_WR_ADDR              ((PULONG)&(pP2RDRegs->RDPaletteWriteAddress.reg))
#define P2RD_PAL_RD_ADDR              ((PULONG)&(pP2RDRegs->RDPaletteAddressRead.reg))
#define P2RD_PAL_DATA                 ((PULONG)&(pP2RDRegs->RDPaletteData.reg))
#define P2RD_PIXEL_MASK               ((PULONG)&(pP2RDRegs->RDPixelMask.reg))
#define P2RD_INDEX_ADDR_LO            ((PULONG)&(pP2RDRegs->RDIndexLow.reg))
#define P2RD_INDEX_ADDR_HI            ((PULONG)&(pP2RDRegs->RDIndexHigh.reg))
#define P2RD_INDEX_DATA               ((PULONG)&(pP2RDRegs->RDIndexedData.reg))
#define P2RD_INDEX_CONTROL            ((PULONG)&(pP2RDRegs->RDIndexControl.reg))

//
// bit field definitions for the direct access registers
//
    
#define P2RD_IDX_CTL_AUTOINCREMENT_ENABLED  0x01

//
// indexed register definitions accessed via P2RD_LOAD_INDEX_REG() and P2RD_READ_INDEX_REG()
//
    
#define P2RD_MISC_CONTROL             0x0000
#define P2RD_SYNC_CONTROL             0x0001
#define P2RD_DAC_CONTROL              0x0002
#define P2RD_PIXEL_SIZE               0x0003
#define P2RD_COLOR_FORMAT             0x0004
#define P2RD_CURSOR_MODE              0x0005
#define P2RD_CURSOR_CONTROL           0x0006
#define P2RD_CURSOR_X_LOW             0x0007
#define P2RD_CURSOR_X_HIGH            0x0008
#define P2RD_CURSOR_Y_LOW             0x0009
#define P2RD_CURSOR_Y_HIGH            0x000a
#define P2RD_CURSOR_HOTSPOT_X         0x000b
#define P2RD_CURSOR_HOTSPOT_Y         0x000c
#define P2RD_OVERLAY_KEY              0x000d
#define P2RD_PAN                      0x000e
#define P2RD_SENSE                    0x000f
#define P2RD_CHECK_CONTROL            0x0018
#define P2RD_CHECK_PIXEL_RED          0x0019
#define P2RD_CHECK_PIXEL_GREEN        0x001a
#define P2RD_CHECK_PIXEL_BLUE         0x001b
#define P2RD_CHECK_LUT_RED            0x001c
#define P2RD_CHECK_LUT_GREEN          0x001d
#define P2RD_CHECK_LUT_BLUE           0x001e
#define P2RD_DCLK_SETUP_1             0x01f0
#define P2RD_DCLK_SETUP_2             0x01f1
#define P2RD_MCLK_SETUP_1             0x01f2
#define P2RD_MCLK_SETUP_2             0x01f3
#define P2RD_DCLK_CONTROL             0x0200
#define P2RD_DCLK0_PRE_SCALE          0x0201
#define P2RD_DCLK0_FEEDBACK_SCALE     0x0202
#define P2RD_DCLK0_POST_SCALE         0x0203
#define P2RD_DCLK1_PRE_SCALE          0x0204
#define P2RD_DCLK1_FEEDBACK_SCALE     0x0205
#define P2RD_DCLK1_POST_SCALE         0x0206
#define P2RD_DCLK2_PRE_SCALE          0x0207
#define P2RD_DCLK2_FEEDBACK_SCALE     0x0208
#define P2RD_DCLK2_POST_SCALE         0x0209
#define P2RD_DCLK3_PRE_SCALE          0x020a
#define P2RD_DCLK3_FEEDBACK_SCALE     0x020b
#define P2RD_DCLK3_POST_SCALE         0x020c
#define P2RD_MCLK_CONTROL             0x020d
#define P2RD_MCLK_PRE_SCALE           0x020e
#define P2RD_MCLK_FEEDBACK_SCALE      0x020f
#define P2RD_MCLK_POST_SCALE          0x0210
#define P2RD_CURSOR_PALETTE_START     0x0303        // 303..32f
#define P2RD_CURSOR_PATTERN_START     0x0400        // 400..7ff

//
// bit field definitions for the indexed registers
//
    
#define P2RD_MISC_CONTROL_OVERLAYS_ENABLED        0x10
#define P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED    0x08
#define P2RD_MISC_CONTROL_PIXEL_DOUBLE            0x02
#define P2RD_MISC_CONTROL_HIGHCOLORRES            0x01

#define P2RD_SYNC_CONTROL_VSYNC_ACTIVE_LOW        0x00
#define P2RD_SYNC_CONTROL_VSYNC_ACTIVE_HIGH       0x08
#define P2RD_SYNC_CONTROL_VSYNC_INACTIVE          0x20
#define P2RD_SYNC_CONTROL_HSYNC_ACTIVE_LOW        0x00
#define P2RD_SYNC_CONTROL_HSYNC_ACTIVE_HIGH       0x01
#define P2RD_SYNC_CONTROL_HSYNC_INACTIVE          0x04

#define P2RD_DAC_CONTROL_BLANK_PEDESTAL_ENABLED   0x80

#define P2RD_PIXEL_SIZE_8BPP                      0x00
#define P2RD_PIXEL_SIZE_16BPP                     0x01
#define P2RD_PIXEL_SIZE_24_BPP                    0x04
#define P2RD_PIXEL_SIZE_32BPP                     0x02

#define P2RD_COLOR_FORMAT_CI8                     0x0e
#define P2RD_COLOR_FORMAT_8BPP                    0x05
#define P2RD_COLOR_FORMAT_15BPP                   0x01
#define P2RD_COLOR_FORMAT_16BPP                   0x10
#define P2RD_COLOR_FORMAT_32BPP                   0x00
#define P2RD_COLOR_FORMAT_LINEAR_EXT              0x40
#define P2RD_COLOR_FORMAT_RGB                     0x20

#define P2RD_CURSOR_MODE_REVERSE                  0x40
#define P2RD_CURSOR_MODE_WINDOWS                  0x00
#define P2RD_CURSOR_MODE_X                        0x10
#define P2RD_CURSOR_MODE_3COLOR                   0x20
#define P2RD_CURSOR_MODE_15COLOR                  0x30
#define P2RD_CURSOR_MODE_64x64                    0x00
#define P2RD_CURSOR_MODE_P0_32x32x2               0x02
#define P2RD_CURSOR_MODE_P1_32x32x2               0x04
#define P2RD_CURSOR_MODE_P2_32x32x2               0x06
#define P2RD_CURSOR_MODE_P3_32x32x2               0x08
#define P2RD_CURSOR_MODE_P01_32x32x4              0x0a
#define P2RD_CURSOR_MODE_P23_32x32x4              0x0c
#define P2RD_CURSOR_MODE_ENABLED                  0x01

#define P2RD_CURSOR_CONTROL_RPOS_ENABLED          0x04
#define P2RD_CURSOR_CONTROL_DOUBLE_Y              0x02
#define P2RD_CURSOR_CONTROL_DOUBLE_X              0x01

#define P2RD_DCLK_CONTROL_LOCKED                  0x02    // read-only
#define P2RD_DCLK_CONTROL_ENABLED                 0x01
#define P2RD_DCLK_CONTROL_RUN                     0x08

#define P2RD_MCLK_CONTROL_LOCKED                  0x02    // read-only
#define P2RD_MCLK_CONTROL_ENABLED                 0x01
#define P2RD_MCLK_CONTROL_RUN                     0x08

#define P2RD_CURSOR_PALETTE_CURSOR_RGB(RGBIndex, Red, Green, Blue) \
{ \
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_PALETTE_START+3*(int)RGBIndex+0, Red); \
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_PALETTE_START+3*(int)RGBIndex+1, Green); \
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_PALETTE_START+3*(int)RGBIndex+2, Blue); \
}


#if 0

//
// need a delay between each write to the P2RD. The only way to guarantee
// that the write has completed is to read from a Permedia 2 control register.
// Reading forces any posted writes to be flushed out. 
//

#define P2RD_DELAY \
{ \
    volatile LONG __junk; \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
}
#else

#define P2RD_DELAY

#endif

//
// macro to load a given data value into an internal P2RD register. The
// second macro loads an internal index register assuming that we have
// already zeroed the high address register.
//
    
#define P2RD_INDEX_REG(index) \
{ \
    DEBUG_PRINT((3, "*(0x%x) <-- 0x%x\n", P2RD_INDEX_ADDR_LO, (index) & 0xff)); \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_LO, (ULONG)((index) & 0xff)); \
    P2RD_DELAY; \
    DEBUG_PRINT((3, "*(0x%x) <-- 0x%x\n", P2RD_INDEX_ADDR_HI, (index) >> 8)); \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_HI, (ULONG)((index) >> 8)); \
    P2RD_DELAY; \
}

#define P2RD_LOAD_DATA(data) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
    P2RD_DELAY; \
}

#define P2RD_LOAD_INDEX_REG(index, data) \
{ \
    P2RD_INDEX_REG(index);                            \
    DEBUG_PRINT((3, "*(0x%x) <-- 0x%x\n", P2RD_INDEX_DATA, (data) & 0xff)); \
    VideoPortWriteRegisterUlong(P2RD_INDEX_DATA, (ULONG)((data) & 0xff)); \
    P2RD_DELAY; \
}

#define P2RD_READ_INDEX_REG(index, data) \
{ \
    P2RD_INDEX_REG(index);                            \
    data = VideoPortReadRegisterUlong(P2RD_INDEX_DATA) & 0xff;   \
    P2RD_DELAY; \
    DEBUG_PRINT((3, "0x%x <-- *(0x%x)\n", data, P2RD_INDEX_DATA)); \
}

#define P2RD_LOAD_INDEX_REG_LO(index, data) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_LO, (ULONG)(index));  \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_INDEX_DATA,    (ULONG)(data));   \
    P2RD_DELAY; \
}

//
// macros to load a given RGB triple into the P2RD palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use P2RD_PALETTE_START and multiple P2RD_LOAD_PALETTE calls to load
// a contiguous set of entries. Use P2RD_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//
    
#define P2RD_PALETTE_START_WR(index) \
{ \
    VideoPortWriteRegisterUlong(P2RD_PAL_WR_ADDR,     (ULONG)(index));    \
    P2RD_DELAY; \
}

#define P2RD_PALETTE_START_RD(index) \
{ \
    VideoPortWriteRegisterUlong(P2RD_PAL_RD_ADDR,     (ULONG)(index));    \
    P2RD_DELAY; \
}

#define P2RD_LOAD_PALETTE(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(red));      \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(green));    \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(blue));     \
    P2RD_DELAY; \
}

#define P2RD_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(P2RD_PAL_WR_ADDR, (ULONG)(index));    \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(red));      \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(green));    \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_PAL_DATA,    (ULONG)(blue));     \
    P2RD_DELAY; \
}

//
// macro to read back a given RGB triple from the P2RD palette. Use after
// a call to P2RD_PALETTE_START_RD
//
    
#define P2RD_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR)(VideoPortReadRegisterUlong(P2RD_PAL_DATA) & 0xff);        \
    P2RD_DELAY; \
    green = (UCHAR)(VideoPortReadRegisterUlong(P2RD_PAL_DATA) & 0xff);        \
    P2RD_DELAY; \
    blue  = (UCHAR)(VideoPortReadRegisterUlong(P2RD_PAL_DATA) & 0xff);        \
    P2RD_DELAY; \
}

//
// macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//
    
#define P2RD_SET_PIXEL_READMASK(mask) \
{ \
    VideoPortWriteRegisterUlong(P2RD_PIXEL_MASK,  (ULONG)(mask)); \
    P2RD_DELAY; \
}

#define P2RD_READ_PIXEL_READMASK(mask) \
{ \
    mask = VideoPortReadRegisterUlong(P2RD_PIXEL_MASK) & 0xff; \
}

//
// macros to load values into the cursor array usage is P2RD_CURSOR_ARRAR_START() followed by 
// n iterations of P2RD_LOAD_CURSOR_ARRAY() or P2RD_READ_CURSOR_ARRAY()
//
    
#define P2RD_CURSOR_ARRAY_START(offset) \
{ \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_LO,   (ULONG)(((offset)+P2RD_CURSOR_PATTERN_START) & 0xff));  \
    P2RD_DELAY; \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_HI,   (ULONG)(((offset)+P2RD_CURSOR_PATTERN_START) >> 8));    \
    P2RD_DELAY; \
}

#define P2RD_LOAD_CURSOR_ARRAY(data) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_DATA, (ULONG)(data)); \
    P2RD_DELAY; \
}

#define P2RD_READ_CURSOR_ARRAY(data) \
{ \
    data = VideoPortReadRegisterUlong(P2RD_INDEX_DATA) & 0xff; \
    P2RD_DELAY; \
}

//
// macro to move the cursor
//
    
#define P2RD_MOVE_CURSOR(x, y) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_HI, (ULONG)0);              \
    P2RD_DELAY; \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_X_LOW,       (ULONG)((x) & 0xff));   \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_X_HIGH,      (ULONG)((x) >> 8));     \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_Y_LOW,       (ULONG)((y) & 0xff));   \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_Y_HIGH,      (ULONG)((y) >> 8));     \
}

//
// macro to change the cursor hotspot
//
    
#define P2RD_CURSOR_HOTSPOT(x, y) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_HI,   (ULONG)(0)); \
    P2RD_DELAY; \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_HOTSPOT_X,  (ULONG)(x));    \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_HOTSPOT_Y,  (ULONG)(y));    \
}
    
//
// macro to change the cursor color
//
    
#define P2RD_CURSOR_COLOR(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(P2RD_INDEX_ADDR_HI,   (ULONG)(0)); \
    P2RD_DELAY; \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_HOTSPOT_X,  (ULONG)(x));    \
    P2RD_LOAD_INDEX_REG_LO(P2RD_CURSOR_HOTSPOT_Y,  (ULONG)(y));    \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\mini\interupt.c ===
//***************************************************************************
//
// Module Name:
//
//   interupt.c
//
// Abstract:
//
//    This module contains code to control interrupts for Permedia2. The
//    interrupt handler performs operations required by the display driver.
//    To communicate between the two we set up a piece of non-paged shared
//    memory to contain synchronization information and a queue for DMA
//    buffers.
//
// Environment:
//
//   Kernel mode
//
//
// Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.
// Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//***************************************************************************


#include "permedia.h"

#pragma alloc_text(PAGE,Permedia2InitializeInterruptBlock)
#pragma optimize("x",on)

//
// *** THIS ROUTINE CANNOT BE PAGED ***
//

BOOLEAN
Permedia2VidInterrupt(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    Interrupts are enabled by the DD as and when they are needed. The miniport
    simply indicates via the Capabilities flags whether interrupts are
    available.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PINTERRUPT_CONTROL_BLOCK pBlock;
    ULONG intrFlags;
    ULONG enableFlags;

    P2_DECL;

    if(hwDeviceExtension->PreviousPowerState != VideoPowerOn) 
    {

        //
        // We reach here because we are sharing IRQ with other devices
        // and another device on the chain is in D0 and functioning
        //

        return FALSE;
    }

    intrFlags   = VideoPortReadRegisterUlong(INT_FLAGS);
    enableFlags = VideoPortReadRegisterUlong(INT_ENABLE);

    //
    // if this a SVGA interrupt, some one must have enabled SVGA interrupt 
    // by accident. We should first disable interrupt from SVGA unit and
    // then dismiss then current interupt
    //

    if(intrFlags & INTR_SVGA_SET) {

        USHORT usData;
        UCHAR  OldIndex;

        //
        // Disable interrupt from SVGA unit
        //

        OldIndex = VideoPortReadRegisterUchar(PERMEDIA_MMVGA_INDEX_REG);

        VideoPortWriteRegisterUchar(PERMEDIA_MMVGA_INDEX_REG, 
                                    PERMEDIA_VGA_CTRL_INDEX);

        usData = (USHORT)VideoPortReadRegisterUchar(PERMEDIA_MMVGA_DATA_REG);
        usData &= ~PERMEDIA_VGA_INTERRUPT_ENABLE;
 
        usData = (usData << 8) | PERMEDIA_VGA_CTRL_INDEX;
        VideoPortWriteRegisterUshort(PERMEDIA_MMVGA_INDEX_REG, usData);

        VideoPortWriteRegisterUchar(PERMEDIA_MMVGA_INDEX_REG, 
                                    OldIndex);

        //
        // Dismiss current SVGA interrupt
        //

        OldIndex = VideoPortReadRegisterUchar(PERMEDIA_MMVGA_CRTC_INDEX_REG);

        VideoPortWriteRegisterUchar(PERMEDIA_MMVGA_CRTC_INDEX_REG, 
                                    PERMEDIA_VGA_CR11_INDEX);

        usData = (USHORT)VideoPortReadRegisterUchar(PERMEDIA_MMVGA_CRTC_DATA_REG);
        usData &= ~PERMEDIA_VGA_SYNC_INTERRUPT;
 
        usData = (usData << 8) | PERMEDIA_VGA_CR11_INDEX;
        VideoPortWriteRegisterUshort(PERMEDIA_MMVGA_CRTC_INDEX_REG, usData);

        VideoPortWriteRegisterUchar(PERMEDIA_MMVGA_CRTC_INDEX_REG,
                                    OldIndex);

        return TRUE;
    }

    //
    // find out what caused the interrupt. We AND with the enabled interrupts
    // since the flags are set if the event occurred even though no interrupt
    // was enabled. 
    //

    intrFlags &= enableFlags;
    if (intrFlags == 0)
        return FALSE;

    //
    // select the interrupt control block for this board
    //

    pBlock = hwDeviceExtension->InterruptControl.ControlBlock;

    VideoPortWriteRegisterUlong(INT_FLAGS, intrFlags);

    if (pBlock == NULL) return TRUE;


#if DBG

    //
    // if this error handler bugchecks, we have a synchronization problem
    // with the display driver
    //

    if (intrFlags & INTR_ERROR_SET)
    {
        ULONG ulError = VideoPortReadRegisterUlong (ERROR_FLAGS);

        if (ulError & (0xf|0x700))
        {
            pBlock->ulLastErrorFlags=ulError;
            pBlock->ulErrorCounter++;

            DEBUG_PRINT((0, "***Error Interrupt!!!(%lxh)\n", ulError));
        }

        VideoPortWriteRegisterUlong ( ERROR_FLAGS, ulError);
    }

    pBlock->ulIRQCounter++;

    if (intrFlags & INTR_VBLANK_SET)
    {
        pBlock->ulControl |= VBLANK_INTERRUPT_AVAILABLE;
        pBlock->ulVSIRQCounter++;
    }

#endif

    if (intrFlags & INTR_DMA_SET)
    {
        pBlock->ulControl |= DMA_INTERRUPT_AVAILABLE;

        //
        // lock access to shared memory section first
        //

        if (VideoPortInterlockedExchange((LONG*)&pBlock->ulICBLock,TRUE))
        {
            return TRUE;
        }

        if (VideoPortReadRegisterUlong(DMA_COUNT) == 0)
        {

            if (pBlock->pDMAWritePos>pBlock->pDMANextStart)
            {
                VideoPortWriteRegisterUlong(DMA_ADDRESS,
                     (ULONG)(pBlock->liDMAPhysAddress.LowPart +
                     (pBlock->pDMANextStart-
                      pBlock->pDMABufferStart)
                     *sizeof(ULONG)));

                VideoPortWriteRegisterUlong(DMA_COUNT,
                     (ULONG)(pBlock->pDMAWritePos-pBlock->pDMANextStart));

                pBlock->pDMAWriteEnd  = pBlock->pDMABufferEnd;
                pBlock->pDMAPrevStart = pBlock->pDMANextStart;
                pBlock->pDMANextStart = pBlock->pDMAWritePos;

            } else if (pBlock->pDMAWritePos<pBlock->pDMANextStart)
            {
                VideoPortWriteRegisterUlong(DMA_ADDRESS,
                     (ULONG)(pBlock->liDMAPhysAddress.LowPart +
                     (pBlock->pDMANextStart-
                      pBlock->pDMABufferStart)
                     *sizeof(ULONG)));

                VideoPortWriteRegisterUlong(DMA_COUNT,
                         (ULONG)(pBlock->pDMAActualBufferEnd-pBlock->pDMANextStart));

                pBlock->pDMAActualBufferEnd=pBlock->pDMABufferEnd;

                pBlock->pDMAPrevStart=pBlock->pDMANextStart;
                pBlock->pDMAWriteEnd =pBlock->pDMANextStart-1;
                pBlock->pDMANextStart=pBlock->pDMABufferStart;

            } else //if (pBlock->pDMAWritePos==pBlock->pDMANextStart)
            {
                //
                //  turn off IRQ service if we are idle...
                //

                VideoPortWriteRegisterUlong(INT_ENABLE, enableFlags & ~INTR_DMA_SET);
            }
        }


        //
        // release lock, we are done
        //

        VideoPortInterlockedExchange((LONG*)&pBlock->ulICBLock,FALSE);
    }

    return TRUE;
}

#pragma optimize("",on)


BOOLEAN
Permedia2InitializeInterruptBlock(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

/*++

Routine Description:

    Do any initialization needed for interrupts, such as allocating the shared
    memory control block.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

--*/

{
    PINTERRUPT_CONTROL_BLOCK pBlock;
    PVOID virtAddr;
    ULONG size;
    PHYSICAL_ADDRESS phyadd;
    ULONG ActualSize;

    //
    // allocate a page of non-paged memory. This will be used as the shared
    // memory between the display driver and the interrupt handler. Since
    // it's only a page in size the physical addresses are contiguous. So
    // we can use this as a small DMA buffer.
    //

    size = PAGE_SIZE;

    virtAddr = VideoPortGetCommonBuffer( hwDeviceExtension,
                                         size,
                                         PAGE_SIZE,
                                         &phyadd,
                                         &ActualSize,
                                         TRUE );

    hwDeviceExtension->InterruptControl.ControlBlock = virtAddr;
    hwDeviceExtension->InterruptControl.Size         = ActualSize;

    if ( (virtAddr == NULL) || (ActualSize < size) )
    {
        DEBUG_PRINT((1, "ExAllocatePool failed for interrupt control block\n"));
        return(FALSE);
    }

    VideoPortZeroMemory( virtAddr, size);

    //
    // We can't flush the cache from the interrupt handler because we must be
    // running at <= DISPATCH_LEVEL to call KeFlushIoBuffers. So we need a DPC
    // to do the cache flush.
    //

    DEBUG_PRINT((2, "Initialized custom DPC routine for cache flushing\n"));

    P2_ASSERT((sizeof(INTERRUPT_CONTROL_BLOCK) <= size),
                 "InterruptControlBlock is too big. Fix the driver!!\n");

    //
    // set up the control block
    //

    pBlock = virtAddr;
    pBlock->ulMagicNo = P2_ICB_MAGICNUMBER;

    //
    // we rely on the pBlock data being set to zero after allocation!
    //

    return(TRUE);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\mini\interupt.h ===
//***************************************************************************
//
// Module Name:
// 
//     interupt.h
// 
// Abstract:
// 
//    This module contains the definitions for the shared memory used by
//    the interrupt control routines.
// 
// Environment:
// 
//     Kernel mode
//
//
// Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.            
// Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//***************************************************************************


// interrupt status bits
typedef enum {
    DMA_INTERRUPT_AVAILABLE     = 0x01, // can use DMA interrupts
    VBLANK_INTERRUPT_AVAILABLE  = 0x02, // can use VBLANK interrupts
} INTERRUPT_CONTROL;

//
// The display driver will only use the interrupt handler
// if we set this magic number. Increment it if the
// data structure changes
//

#define P2_ICB_MAGICNUMBER 0xbadabe01

//
// This data structure is shared between the Permedia 2 Display
// Driver and the miniport
//
// Do not change the data structures without updating the DD
//

typedef struct INTERRUPT_CONTROL_BLOCK {

    ULONG ulMagicNo;                   // The dd will search for
                                       // this magic number and only
                                       // use the interupt handler
                                       // if the magic no is the same
                                       // as in the display driver

    volatile ULONG  ulControl;         // flags mark DMA/VS IRQs
    volatile ULONG  ulIRQCounter;      // counter for total number of IRQs
    
    LARGE_INTEGER   liDMAPhysAddress;  // physical address of DMA Buffer
    ULONG *         pDMABufferStart;   // virtual address of DMA buffer
    ULONG *         pDMABufferEnd;     // full size in DWORDs of DMA Buffer
    volatile ULONG *pDMAActualBufferEnd;
                                       // size in DWORDs of DMA Buffer

    volatile ULONG *pDMAWriteEnd;      // end of buffer
    volatile ULONG *pDMAPrevStart;     // last start address of a DMA
    volatile ULONG *pDMANextStart;     // next start address of a DMA
    volatile ULONG *pDMAWritePos;      // current write Index pointer

    volatile ULONG  ulICBLock;         // this lock is set by the display driver

    volatile ULONG  ulVSIRQCounter;    // counter for VS IRQs

    volatile ULONG  ulLastErrorFlags;   
    volatile ULONG  ulErrorCounter;

} INTERRUPT_CONTROL_BLOCK, *PINTERRUPT_CONTROL_BLOCK;


//
// structure containing information about the interrupt control block
//
typedef struct _interrupt_control_buffer_ {

    PVOID ControlBlock;
    ULONG Size;

} P2_INTERRUPT_CTRLBUF, *PP2_INTERRUPT_CTRLBUF;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\mini\perm2tag.h ===
//***************************************************************************
//
// Module Name:
// 
//     perm2tag.h
// 
// 
// Environment:
// 
//     Kernel mode
//
//
// Copyright (c) 1994 3Dlabs Inc. Ltd. All Rights Reserved. 
//
//***************************************************************************

/* NOTE:File is machine generated.Do not edit.*/

#ifndef PERM2TAG_H
#define PERM2TAG_H

#define    __P2TagStartXDom                    0x000
#define    __P2TagdXDom                        0x001
#define    __P2TagStartXSub                    0x002
#define    __P2TagdXSub                        0x003
#define    __P2TagStartY                       0x004
#define    __P2TagdY                           0x005
#define    __P2TagCount                        0x006
#define    __P2TagRender                       0x007
#define    __P2TagContinueNewLine              0x008
#define    __P2TagContinueNewDom               0x009
#define    __P2TagContinueNewSub               0x00a
#define    __P2TagContinue                     0x00b
#define    __P2TagFlushSpan                    0x00c
#define    __P2TagBitMaskPattern               0x00d
#define    __P2TagPointTable0                  0x010
#define    __P2TagPointTable1                  0x011
#define    __P2TagPointTable2                  0x012
#define    __P2TagPointTable3                  0x013
#define    __P2TagRasterizerMode               0x014
#define    __P2TagYLimits                      0x015
#define    __P2TagScanlineOwnership            0x016
#define    __P2TagWaitForCompletion            0x017
#define    __P2TagPixelSize                    0x018
#define    __P2TagScissorMode                  0x030
#define    __P2TagScissorMinXY                 0x031
#define    __P2TagScissorMaxXY                 0x032
#define    __P2TagScreenSize                   0x033
#define    __P2TagAreaStippleMode              0x034
#define    __P2TagLineStippleMode              0x035
#define    __P2TagLoadLineStippleCounters      0x036
#define    __P2TagUpdateLineStippleCounters    0x037
#define    __P2TagSaveLineStippleCounters      0x038
#define    __P2TagWindowOrigin                 0x039
#define    __P2TagAreaStipplePattern0          0x040
#define    __P2TagAreaStipplePattern1          0x041
#define    __P2TagAreaStipplePattern2          0x042
#define    __P2TagAreaStipplePattern3          0x043
#define    __P2TagAreaStipplePattern4          0x044
#define    __P2TagAreaStipplePattern5          0x045
#define    __P2TagAreaStipplePattern6          0x046
#define    __P2TagAreaStipplePattern7          0x047
#define    __P2TagAreaStipplePattern8          0x048
#define    __P2TagAreaStipplePattern9          0x049
#define    __P2TagAreaStipplePattern10         0x04a
#define    __P2TagAreaStipplePattern11         0x04b
#define    __P2TagAreaStipplePattern12         0x04c
#define    __P2TagAreaStipplePattern13         0x04d
#define    __P2TagAreaStipplePattern14         0x04e
#define    __P2TagAreaStipplePattern15         0x04f
#define    __P2TagAreaStipplePattern16         0x050
#define    __P2TagAreaStipplePattern17         0x051
#define    __P2TagAreaStipplePattern18         0x052
#define    __P2TagAreaStipplePattern19         0x053
#define    __P2TagAreaStipplePattern20         0x054
#define    __P2TagAreaStipplePattern21         0x055
#define    __P2TagAreaStipplePattern22         0x056
#define    __P2TagAreaStipplePattern23         0x057
#define    __P2TagAreaStipplePattern24         0x058
#define    __P2TagAreaStipplePattern25         0x059
#define    __P2TagAreaStipplePattern26         0x05a
#define    __P2TagAreaStipplePattern27         0x05b
#define    __P2TagAreaStipplePattern28         0x05c
#define    __P2TagAreaStipplePattern29         0x05d
#define    __P2TagAreaStipplePattern30         0x05e
#define    __P2TagAreaStipplePattern31         0x05f
#define    __P2TagTexel0                       0x0c0
#define    __P2TagTexel1                       0x0c1
#define    __P2TagTexel2                       0x0c2
#define    __P2TagTexel3                       0x0c3
#define    __P2TagTexel4                       0x0c4
#define    __P2TagTexel5                       0x0c5
#define    __P2TagTexel6                       0x0c6
#define    __P2TagTexel7                       0x0c7
#define    __P2TagInterp0                      0x0c8
#define    __P2TagInterp1                      0x0c9
#define    __P2TagInterp2                      0x0ca
#define    __P2TagInterp3                      0x0cb
#define    __P2TagInterp4                      0x0cc
#define    __P2TagTextureFilter                0x0cd
#define    __P2TagTextureColorMode             0x0d0
#define    __P2TagTextureEnvColor              0x0d1
#define    __P2TagFogMode                      0x0d2
#define    __P2TagFogColor                     0x0d3
#define    __P2TagFStart                       0x0d4
#define    __P2TagdFdx                         0x0d5
#define    __P2TagdFdyDom                      0x0d6
#define    __P2TagRStart                       0x0f0
#define    __P2TagdRdx                         0x0f1
#define    __P2TagdRdyDom                      0x0f2
#define    __P2TagGStart                       0x0f3
#define    __P2TagdGdx                         0x0f4
#define    __P2TagdGdyDom                      0x0f5
#define    __P2TagBStart                       0x0f6
#define    __P2TagdBdx                         0x0f7
#define    __P2TagdBdyDom                      0x0f8
#define    __P2TagAStart                       0x0f9
#define    __P2TagdAdx                         0x0fa
#define    __P2TagdAdyDom                      0x0fb
#define    __P2TagColorDDAMode                 0x0fc
#define    __P2TagConstantColor                0x0fd
#define    __P2TagColor                        0x0fe
#define    __P2TagAlphaTestMode                0x100
#define    __P2TagAntialiasMode                0x101
#define    __P2TagAlphaBlendMode               0x102
#define    __P2TagDitherMode                   0x103
#define    __P2TagFBSoftwareWriteMask          0x104
#define    __P2TagLogicalOpMode                0x105
#define    __P2TagFBWriteData                  0x106
#define    __P2TagFBCancelWrite                0x107
#define    __P2TagLBReadMode                   0x110
#define    __P2TagLBReadFormat                 0x111
#define    __P2TagLBSourceOffset               0x112
#define    __P2TagLBSourceData                 0x114
#define    __P2TagLBStencil                    0x115
#define    __P2TagLBDepth                      0x116
#define    __P2TagLBWindowBase                 0x117
#define    __P2TagLBWriteMode                  0x118
#define    __P2TagLBWriteFormat                0x119
#define    __P2TagWindow                       0x130
#define    __P2TagStencilMode                  0x131
#define    __P2TagStencilData                  0x132
#define    __P2TagStencil                      0x133
#define    __P2TagDepthMode                    0x134
#define    __P2TagDepth                        0x135
#define    __P2TagZStartU                      0x136
#define    __P2TagZStartL                      0x137
#define    __P2TagdZdxU                        0x138
#define    __P2TagdZdxL                        0x139
#define    __P2TagdZdyDomU                     0x13a
#define    __P2TagdZdyDomL                     0x13b
#define    __P2TagFastClearDepth               0x13c
#define    __P2TagFBReadMode                   0x150
#define    __P2TagFBSourceOffset               0x151
#define    __P2TagFBPixelOffset                0x152
#define    __P2TagFBColor                      0x153
#define    __P2TagFBWindowBase                 0x156
#define    __P2TagFBWriteMode                  0x157
#define    __P2TagFBHardwareWriteMask          0x158
#define    __P2TagFBBlockColor                 0x159
#define    __P2TagFilterMode                   0x180
#define    __P2TagStatisticMode                0x181
#define    __P2TagMinRegion                    0x182
#define    __P2TagMaxRegion                    0x183
#define    __P2TagResetPickResult              0x184
#define    __P2TagMinHitRegion                 0x185
#define    __P2TagMaxHitRegion                 0x186
#define    __P2TagPickResult                   0x187
#define    __P2TagSync                         0x188

#endif // PERM2TAG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\mini\perm2ver.h ===
// UpVer: 0009

#define PERM2_VERSION_STRING    "1.00-0009 (MS)"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\mini\permdata.c ===
//***************************************************************************
//
//  Module Name:
//
//    permdata.c
//
//  Abstract:
//
//    This module contains all the global data used by the Permedia2 driver.
//
//  Environment:
//
//    Kernel mode
//
// Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.            
// Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//***************************************************************************


#include "permedia.h"

/*
 * DATA STRUCTURES
 * ===============
 */

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGED_DATA")
#endif

//
// Permedia2 Legacy Resource List
//
//              RangeStart        RangeLength
//              |                 |      RangeInIoSpace
//              |                 |      |  RangeVisible
//        +-----+-----+           |      |  |  RangeShareable
//        |           |           |      |  |  |  RangePassive
//        v           v           v      v  v  v  v

VIDEO_ACCESS_RANGE P2LegacyResourceList[] = 
{
    {0x000C0000, 0x00000000, 0x00010000, 0, 0, 0, 0}, // ROM location
    {0x000A0000, 0x00000000, 0x00020000, 0, 0, 1, 0}, // Frame buffer
    {0x000003B0, 0x00000000, 0x0000000C, 1, 1, 1, 0}, // VGA regs
    {0x000003C0, 0x00000000, 0x00000020, 1, 1, 1, 0}  // VGA regs
};

ULONG P2LegacyResourceEntries = sizeof P2LegacyResourceList / sizeof P2LegacyResourceList[0];


// Entries for 3 bpp colors
//      Index(0-7) -> Color(0-255)
ULONG   bPal8[] = {
        0x00, 0x24, 0x48, 0x6D,
        0x91, 0xB6, 0xDA, 0xFF
    };

// Entries for 2 bpp colors
//      Index(0-3) -> Color(0-255)
ULONG   bPal4[] = {
        0x00, 0x6D, 0xB6, 0xFF
    };

    

///////////////////////////////////////////////////////////////////////////
// Video mode table - Lists the information about each individual mode.
//
// Note that any new modes should be added here and to the appropriate
// P2_VIDEO_FREQUENCIES tables.
//

P2_VIDEO_MODES P2Modes[] = {
    {                      // 320x200x8bpp

      0,                   // 'Contiguous' Int 10 mode number (for high-colour)
      0,                   // 'Noncontiguous' Int 10 mode number
      320,                 // 'Contiguous' screen stride
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          320,                            // X Resolution, in pixels
          200,                            // Y Resolution, in pixels
          320,                            // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          8,                              // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00000000,                     // Mask for Red Pixels in non-palette modes
          0x00000000,                     // Mask for Green Pixels in non-palette modes
          0x00000000,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
              VIDEO_MODE_MANAGED_PALETTE, // Mode description flags.
          0,                              // Video Memory Bitmap Width (filled
                                          // in later)
          0                               // Video Memory Bitmap Height (filled
                                          // in later)
        },
    },

    {                      // 640x400x8bpp

      0,                       
      0,                       
      640,                     
        {
          sizeof(VIDEO_MODE_INFORMATION), 
          0, 
          640,                            
          400,                            
          640,                            
          1,                              
          8,                              
          1,                              
          320,                            
          240,                            
          8,                              
          8,                              
          8,                              
          0x00000000,                     
          0x00000000,                     
          0x00000000,                     
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
              VIDEO_MODE_MANAGED_PALETTE, 
        }
    },

    {                   // 320x200x16bpp

      0,
      0,
      640,
        {
            sizeof(VIDEO_MODE_INFORMATION),
            0,
            320,
            200,
            640,
            1,
            16,
            1,
            320,
            240,
            8,
            8,
            8,
            0x0000f800,           // BGR 5:6:5
            0x000007e0,
            0x0000001f,
            VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {            // 640x400x16bpp
      0,
      0,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          400,
          1280,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },
         

    {                           // 320x240x8bpp

      0x0201,           
      0x0201,           
      320,              
        {
          sizeof(VIDEO_MODE_INFORMATION), 
          0,                              
          320,                            
          240,                            
          320,                            
          1,                              
          8,                              
          1,                              
          320,                            
          240,                            
          8,                              
          8,                              
          8,                              
          0x00000000,                     
          0x00000000,                     
          0x00000000,                     
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
              VIDEO_MODE_MANAGED_PALETTE, 
        }
    },

    {                           // 512x384x8bpp

      0x0201,           
      0x0201,           
      512,              
        {
          sizeof(VIDEO_MODE_INFORMATION), 
          0,                              
          512,                            
          384,                            
          512,                            
          1,                              
          8,                              
          1,                              
          320,                            
          240,                            
          8,                              
          8,                              
          8,                              
          0x00000000,                     
          0x00000000,                     
          0x00000000,                     
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE, 
        }
    },

    {                           // 640x480x8bpp

      0x0201,           
      0x0201,           
      640,              
        {
          sizeof(VIDEO_MODE_INFORMATION), 
          0,                              
          640,                            
          480,                            
          640,                            
          1,                              
          8,                              
          1,                              
          320,                            
          240,                            
          8,                              
          8,                              
          8,                              
          0x00000000,                     
          0x00000000,                     
          0x00000000,                     
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE, 
        }
    },

    {                           // 800x600x8bpp
      0x0103,
      0x0203,
      800,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          800,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                           // 1024x768x8bpp
      0x0205,
      0x0205,
      1024,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          1024,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                           // 1152x870x8bpp
      0x0207,
      0x0207,
      1152,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          870,
          1152,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                           // 1280x1024x8bpp
      0x0107,
      0x0107,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          1280,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                           // 1600x1200x8bpp
      0x0120,
      0x0120,
      1600,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          1600,
          1,
          8,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00000000,
          0x00000000,
          0x00000000,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS | VIDEO_MODE_PALETTE_DRIVEN |
          VIDEO_MODE_MANAGED_PALETTE,
        }
    },

    {                           // 320x240x16bpp
      0x0111,
      0x0211,
      640,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          320,
          240,
          640,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 512x384x16bpp
      0x0111,
      0x0211,
      1024,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          512,
          384,
          1024,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 640x480x16bpp
      0x0111,
      0x0211,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          480,
          1280,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 800x600x16bpp
      0x0114,
      0x0214,
      1600,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          1600,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1024x768x16bpp
      0x0117,
      0x0117,
      2048,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          2048,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1152x870x16bpp
      0x0118,
      0x0222,
      2304,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          870,
          2304,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1280x1024x16bpp
      0x011A,
      0x021A,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          2560,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1600x1200x16bpp
      0x0121,
      0x0121,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          3200,
          1,
          16,
          1,
          320,
          240,
          8,
          8,
          8,
          0x0000f800,           // BGR 5:6:5
          0x000007e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 320x240x15bpp
      0x0111,
      0x0211,
      640,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          320,
          240,
          640,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 512x384x15bpp
      0x0111,
      0x0211,
      1024,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          512,
          384,
          1024,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 640x480x15bpp
      0x0111,
      0x0211,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          480,
          1280,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 800x600x15bpp
      0x0114,
      0x0214,
      1600,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          1600,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1024x768x15bpp
      0x0117,
      0x0117,
      2048,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          2048,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1152x870x15bpp
      0x0118,
      0x0222,
      2304,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          870,
          2304,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1280x1024x15bpp
      0x011A,
      0x021A,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          2560,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1600x1200x15bpp
      0x0121,
      0x0121,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          3200,
          1,
          15,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00007c00,           // BGR 5:5:5
          0x000003e0,
          0x0000001f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 640x480x12bpp
      0x0112,
      0x0220,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          480,
          2560,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,           // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 800x600x12bpp
      0x0115,
      0x0221,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          3200,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,           // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1024x768x12bpp
      0x0118,
      0x0222,
      4096,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          4096,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,           // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1152x870x12bpp
      0x0118,
      0x0222,
      4608,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          870,
          4608,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,           // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1280x1024x12bpp
      0x011B,
      0x011B,
      5120,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          5120,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,           // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1600x1200x12bpp
      0x0122,
      0x0122,
      6400,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          6400,
          1,
          12,
          1,
          320,
          240,
          8,
          8,
          8,
          0x000f0000,           // BGR 4:4:4
          0x00000f00,
          0x0000000f,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 320x240x32bpp
      0x0112,
      0x0220,
      1280,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          320,
          240,
          1280,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 512x384x32bpp
      0x0112,
      0x0220,
      2048,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          512,
          384,
          2048,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 640x480x32bpp
      0x0112,
      0x0220,
      2560,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          640,
          480,
          2560,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 800x600x32bpp
      0x0115,
      0x0221,
      3200,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          800,
          600,
          3200,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1024x768x32bpp
      0x0118,
      0x0222,
      4096,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1024,
          768,
          4096,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1152x870x32bpp
      0x0118,
      0x0222,
      4608,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1152,
          870,
          4608,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1280x1024x32bpp
      0x011B,
      0x011B,
      5120,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1280,
          1024,
          5120,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                           // 1600x1200x32bpp
      0x0122,
      0x0122,
      6400,
        {
          sizeof(VIDEO_MODE_INFORMATION),
          0,
          1600,
          1200,
          6400,
          1,
          32,
          1,
          320,
          240,
          8,
          8,
          8,
          0x00ff0000,           // BGR 8:8:8
          0x0000ff00,
          0x000000ff,
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS,
        }
    },

    {                                     // 640x480x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      1920,                               // 'Contiguous' screen stride (640 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          640,                            // X Resolution, in pixels
          480,                            // Y Resolution, in pixels
          1920,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },

    {                                     // 800x600x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      2400,                               // 'Contiguous' screen stride (800 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          800,                            // X Resolution, in pixels
          600,                            // Y Resolution, in pixels
          2400,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },

    {                                     // 1024x768x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      3072,                               // 'Contiguous' screen stride (1024 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          1024,                            // X Resolution, in pixels
          768,                            // Y Resolution, in pixels
          3072,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },

    {                                     // 1152x870x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      3456,                               // 'Contiguous' screen stride (1152 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          1152,                           // X Resolution, in pixels
          870,                            // Y Resolution, in pixels
          3072,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },

    {                                     // 1280x1024x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      3840,                               // 'Contiguous' screen stride (1280 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          3840,                           // X Resolution, in pixels
          1280,                            // Y Resolution, in pixels
          1024,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },

    {                                     // 1600x1200x24bpp
      0,                                  // 'Contiguous' Int 10 mode number (for high-colour) (UNUSED)
      0,                                  // 'Noncontiguous' Int 10 mode number (UNUSED)
      4800,                               // 'Contiguous' screen stride (1600 by 3 bytes/pixel)
        {
          sizeof(VIDEO_MODE_INFORMATION), // Size of the mode informtion structure
          0,                              // Mode index used in setting the mode
                                          // (filled in later)
          1600,                           // X Resolution, in pixels
          1280,                            // Y Resolution, in pixels
          4800,                           // 'Noncontiguous' screen stride,
                                          // in bytes (distance between the
                                          // start point of two consecutive
                                          // scan lines, in bytes)
          1,                              // Number of video memory planes
          24,                             // Number of bits per plane
          1,                              // Screen Frequency, in Hertz ('1'
                                          // means use hardware default)
          320,                            // Horizontal size of screen in millimeters
          240,                            // Vertical size of screen in millimeters
          8,                              // Number Red pixels in DAC
          8,                              // Number Green pixels in DAC
          8,                              // Number Blue pixels in DAC
          0x00ff0000,                     // Mask for Red Pixels in non-palette modes
          0x0000ff00,                     // Mask for Green Pixels in non-palette modes
          0x000000ff,                     // Mask for Blue Pixels in non-palette modes
          VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS, // Mode description flags.
        },
    },
};


ULONG NumP2VideoModes = sizeof(P2Modes) / sizeof(P2Modes[0]);


/*****************************************************************************
 * Reference Permedia2 hard-wired mode-sets.
 *
 * The order they appear here is the order they appear in the Display Applet.
 *
 ****************************************************************************/

//
// We can replace the hard coded list of frequencies with a hard-coded list 
// of pixel depths, which is a lot easier to maintain, and takes less memory.
// What we then do is for each 'TIMINGS' registry entry and for each timing 
// entry we create 'P2DepthCnt' frequency table entries, one for each pixel 
// depth. Once we have done that then we validate the entries in the frequency 
// list with the 'P2VideoModes' array.
//

ULONG P2DepthList [] = { 8, 16, 24, 32 };

#define P2DepthCnt (sizeof(P2DepthList) / sizeof(P2DepthList[0]))

//
//  VESA_LIST []
//  ------------
//
//      This is an array of structures containing the VESA definition 
//      for a width, height, frequency combination.
// 
//

typedef struct          // Extended VESA TIMING structure
{
    ULONG Width;
    ULONG Height;
    ULONG Frequency;
    VESA_TIMING_STANDARD VESAInfo;
} VESA_TIMING_STANDARD_EXT;

VESA_TIMING_STANDARD_EXT VESA_LIST [] =
{
    //
    // I have commented out the VESA-compliant 640x480@60 and replaced it 
    // with a VGA-compliant one. This is because some monitors won't SYNC 
    // with the values that we have.
    //

    //640,480,60,   {0x064,0x02,0x08,0x0a,0x00,0x1f1,0x01,0x03,0x0d,0x00 },
    640,480,60,     {0x064,0x02,0x0c,0x06,0x00,0x20d,0x0a,0x02,0x21,0x00 },
    640,480,75,     {0x066,0x03,0x08,0x0b,0x00,0x1f6,0x01,0x03,0x12,0x00 },
    640,480,85,     {0x068,0x04,0x08,0x0c,0x00,0x1f9,0x01,0x03,0x15,0x00 },
    640,480,100,    {0x06a,0x05,0x08,0x0d,0x00,0x1fd,0x01,0x03,0x19,0x00 },

    800,600,60,     {0x084,0x05,0x10,0x0b,0x01,0x274,0x01,0x04,0x17,0x01 },
    800,600,75,     {0x084,0x02,0x0a,0x14,0x01,0x271,0x01,0x03,0x15,0x01 },
    800,600,85,     {0x083,0x04,0x08,0x13,0x01,0x277,0x01,0x03,0x1b,0x01 },
    800,600,100,    {0x086,0x06,0x0b,0x11,0x01,0x27c,0x01,0x03,0x20,0x01 },

    1024,768,60,    {0x0a8,0x03,0x11,0x14,0x01,0x326,0x04,0x06,0x1c,0x01 },
    1024,768,75,    {0x0a4,0x02,0x0c,0x16,0x01,0x320,0x01,0x03,0x1c,0x01 },
    1024,768,85,    {0x0ac,0x06,0x0c,0x1a,0x01,0x328,0x01,0x03,0x24,0x01 },
    1024,768,100,   {0x0ae,0x09,0x0e,0x17,0x01,0x32e,0x01,0x03,0x2a,0x01 },

    1152,870,60,    {0x0c8,0x08,0x10,0x20,0x01,0x38a,0x01,0x03,0x20,0x01 },
    1152,870,75,    {0x0c2,0x09,0x10,0x19,0x01,0x38c,0x01,0x03,0x22,0x01 },
    1152,870,85,    {0x0c5,0x08,0x10,0x1d,0x01,0x391,0x01,0x03,0x27,0x01 },
    1152,870,100,   {0x0c4,0x0a,0x10,0x1a,0x01,0x39a,0x01,0x03,0x30,0x01 },

    1280,1024,60,   {0x0d3,0x06,0x0e,0x1f,0x01,0x42a,0x01,0x03,0x26,0x01 },
    1280,1024,75,   {0x0d3,0x02,0x12,0x1f,0x01,0x42a,0x01,0x03,0x26,0x01 },
    1280,1024,85,   {0x0d8,0x06,0x14,0x1e,0x01,0x430,0x01,0x03,0x2c,0x01 },
    1280,1024,100,  {0x0dc,0x0c,0x12,0x1e,0x01,0x43d,0x01,0x03,0x39,0x01 },

    1600,1200,60,   {0x10e,0x08,0x18,0x26,0x01,0x4e2,0x01,0x03,0x2e,0x01 },
    1600,1200,75,   {0x10e,0x08,0x18,0x26,0x01,0x4e2,0x01,0x03,0x2e,0x01 },
    1600,1200,85,   {0x10e,0x08,0x18,0x26,0x01,0x4e2,0x01,0x03,0x2e,0x01 },
    1600,1200,100,  {0x114,0x10,0x16,0x26,0x01,0x4f7,0x01,0x03,0x43,0x01 },

    //320,240,60,   {0x032,0x01,0x04,0x05,0x00,0x0f9,0x01,0x03,0x05,0x00 },
    320,240,75,     {0x033,0x02,0x04,0x05,0x00,0x0fb,0x01,0x03,0x07,0x00 },
    320,240,85,     {0x034,0x02,0x04,0x06,0x00,0x0fd,0x01,0x03,0x09,0x00 },
    320,240,100,    {0x034,0x02,0x04,0x06,0x00,0x0ff,0x01,0x03,0x0b,0x00 },

    //
    // TMM: 512x384@60Hz seems to work OK, but some older monitors refuse to
    // SYNC, so I have commented it out.
    //
    //512,384,60,   {0x04c,0x00,0x06,0x06,0x00,0x18e,0x01,0x03,0x0a,0x00 },
    512,384,75,     {0x050,0x02,0x06,0x08,0x00,0x192,0x01,0x03,0x0e,0x00 },
    512,384,85,     {0x052,0x02,0x07,0x09,0x00,0x194,0x01,0x03,0x10,0x00 },
    512,384,100,    {0x052,0x02,0x07,0x09,0x00,0x197,0x01,0x03,0x13,0x00 },

    //320,200,60,     {0x02a,0x00,0x03,0x01,0x00,0x0d0,0x01,0x03,0x04,0x00 },
    320,200,75,     {0x02c,0x00,0x04,0x02,0x00,0x0d2,0x01,0x03,0x06,0x00 },
    320,200,85,     {0x02e,0x00,0x04,0x03,0x00,0x0d3,0x01,0x03,0x07,0x00 },
    320,200,100,    {0x030,0x00,0x04,0x04,0x00,0x0d5,0x01,0x03,0x09,0x00 },

    //640,400,60,     {0x062,0x01,0x08,0x09,0x00,0x19f,0x01,0x03,0x0b,0x01 },
    640,400,75,     {0x064,0x02,0x08,0x0a,0x00,0x1a2,0x01,0x03,0x0e,0x01 },
    640,400,85,     {0x066,0x03,0x08,0x0b,0x00,0x1a5,0x01,0x03,0x11,0x01 },
    640,400,100,    {0x068,0x04,0x08,0x0c,0x00,0x1a8,0x01,0x03,0x14,0x01 }

};

#define VESA_CNT (sizeof(VESA_LIST) / sizeof(VESA_LIST [0]))

VESA_TIMING_STANDARD_EXT VESA_LIST_P2S [] =
{
    1280,1024,85,   {0x0c6,0x04,0x0b,0x17,0x01,0x41e,0x01,0x03,0x1a,0x01 },
    1600,1200,60,   {0x106,0x0a,0x15,0x1f,0x01,0x4d4,0x01,0x03,0x20,0x01 }
};

#define VESA_CNT_P2S (sizeof(VESA_LIST_P2S) / sizeof(VESA_LIST_P2S [0]))

P2_VIDEO_FREQUENCIES freqList[VESA_CNT * P2DepthCnt + 1];

#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif


/*
 * THE CODE
 * ========
 */

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,GetVideoTiming)
#pragma alloc_text(PAGE,BuildFrequencyList)
#endif


BOOLEAN 
GetVideoTiming (
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    ULONG xRes, 
    ULONG yRes, 
    ULONG Freq, 
    ULONG Depth,
    VESA_TIMING_STANDARD * VESATimings
    )

/*++

 Routine Description:

     Given a width, height and frequency this function will return a 
     VESA timing information.

     The information is extracted from the timing definitions in the 
     registry, if there aren't any in the registry then it looks up
     the values in the VESA_LIST.

--*/
{
    ULONG i, j, hackCnt;
    BOOLEAN  retVal;
    VESA_TIMING_STANDARD_EXT * hackList = NULL;

    DEBUG_PRINT((2, "GetVideoTiming: xres %d, yres %d, freq %d, Depth\n",
                            xRes, yRes, Freq, Depth));

    //
    // Allow us to put hacks in for chips that can't support the proper 
    // VESA values
    //

    if ((DEVICE_FAMILY_ID(hwDeviceExtension->deviceInfo.DeviceId) == PERMEDIA_P2S_ID ||
        (DEVICE_FAMILY_ID(hwDeviceExtension->deviceInfo.DeviceId) == PERMEDIA_P2_ID && 
        hwDeviceExtension->deviceInfo.RevisionId == PERMEDIA2A_REV_ID)) &&
        Depth > 16)
    {

        //
        // P2S & P2A can't handle VESA versions of 1600x1200 & 1280x1024, 32BPP
        //

        hackList = VESA_LIST_P2S;
        hackCnt  = VESA_CNT_P2S;
    }

    retVal = FALSE;     // Nothing found yet

    //
    // If we have a hack list then search through it
    //

    if (hackList != NULL)
    {
        for (i = 0; !retVal && i < hackCnt; i++)
        {
            //
            // Comparewidth, height and frequency
            //

            if (hackList [i].Width == xRes  &&
                hackList [i].Height == yRes &&
                hackList [i].Frequency == Freq )
            {
                //
                // We got a match
                //

                *VESATimings = hackList [i].VESAInfo;

                retVal = TRUE;

                DEBUG_PRINT((2, "Found value in hack list\n")) ;
            }
        }
    }

    //
    // Loop through the table looking for a match
    //

    for (i = 0; !retVal && i < VESA_CNT; i++)
    {
        //
        // Comparewidth, height and frequency
        //

        if (VESA_LIST [i].Width == xRes  &&
            VESA_LIST [i].Height == yRes &&
            VESA_LIST [i].Frequency == Freq )
        {
            //
            // We got a match
            //

            *VESATimings = VESA_LIST [i].VESAInfo;

            retVal = TRUE;
        }
    }

    return (retVal);
}


LONG
BuildFrequencyList ( 
    PHW_DEVICE_EXTENSION hwDeviceExtension 
    )

/*++

 Routine Description:

     This function creates a table of P2_VIDEO_FREQENCIES entries
     pointedat by hwDeviceExtension->FrequencyTable. 

     The list is created by examining the 'TIMING\xxx,yyy,zzz' registry
     entries, if there aren't any entries then the hard-coded VESA_LIST 
     is used.

--*/
{
    ULONG i, j, k;

    hwDeviceExtension->FrequencyTable = freqList;

    //
    // loop through the list of VESA resolutions
    //

    for (i = 0, k = 0; i < VESA_CNT; i++)
    {
        //
        // For every supported pixel depth, create a frequency entry 
        //

        for (j = 0; j < P2DepthCnt; j++, k++)
        {
            freqList [k].BitsPerPel      = P2DepthList [j];
            freqList [k].ScreenWidth     = VESA_LIST [i].Width;
            freqList [k].ScreenHeight    = VESA_LIST [i].Height;
            freqList [k].ScreenFrequency = VESA_LIST [i].Frequency;
            freqList [k].PixelClock      = 
                                ( (VESA_LIST[i].VESAInfo.HTot * 
                                   VESA_LIST [i].VESAInfo.VTot * 8) / 100 ) * 
                                   VESA_LIST [i].Frequency;
       }
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\mini\permedia.c ===
//***************************************************************************
//
// Module Name:
//
//   permedia.c
//
// Abstract:
//
//   This module contains the code that implements the Permedia2 miniport driver
//
// Environment:
//
//   Kernel mode
//
//
// Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.            
// Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//***************************************************************************

#include "permedia.h"

#include "string.h"

#define USE_SINGLE_CYCLE_BLOCK_WRITES 0

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,Permedia2FindAdapter)
#pragma alloc_text(PAGE,Permedia2RegistryCallback)
#pragma alloc_text(PAGE,Permedia2RetrieveGammaCallback)
#pragma alloc_text(PAGE,InitializeAndSizeRAM)
#pragma alloc_text(PAGE,ConstructValidModesList)
#pragma alloc_text(PAGE,Permedia2Initialize)
#pragma alloc_text(PAGE,Permedia2StartIO)
#pragma alloc_text(PAGE,Permedia2SetColorLookup)
#pragma alloc_text(PAGE,Permedia2GetClockSpeeds)
#pragma alloc_text(PAGE,ZeroMemAndDac)
#endif

//
//  NtVersion:  NT4   - This driver is working on NT4
//              WIN2K - This driver is working on Windows 2000
//

short NtVersion;

ULONG
DriverEntry (
    PVOID Context1,
    PVOID Context2
    )

/*++

Routine Description:

    This routine is the initial entry point to the video miniport driver.

    This routine is called by the I/O subsystem when the video miniport
    is loaded.  The miniport is responsible for initializing a
    VIDEO_HW_INITIALIZATION_DATA structure to register the driver functions
    called by the video port driver in response to requests from the display
    driver, plug and play manager, power management, or other driver
    components.

    The following tasks MUST be completed by the video miniport in the
    context of DriverEntry. Driver writers should consult the documentation
    for full details on the exact initialization process.

    1. Initialize VIDEO_HW_INITIALIZATION_DATA structure with all relevant
       data structures.

    2. Call VideoPortInitialize.

    3. Return appropriate status value to the caller of DriverEntry.

    Drivers can undertake other tasks as required and under the restrictions
    outlined in the documentation.

Arguments:

    Context1 - First context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

    Context2 - Second context value passed by the operating system. This is
        the value with which the miniport driver calls VideoPortInitialize().

Return Value:

    Status from VideoPortInitialize()

--*/

{

    VIDEO_HW_INITIALIZATION_DATA hwInitData;
    VP_STATUS initializationStatus;

    //
    // Zero out structure.
    //

    VideoPortZeroMemory(&hwInitData, sizeof(VIDEO_HW_INITIALIZATION_DATA));

    //
    // Specify sizes of structure and extension.
    //

    hwInitData.HwInitDataSize = sizeof(VIDEO_HW_INITIALIZATION_DATA);

    //
    // Set entry points.
    //

    hwInitData.HwFindAdapter             = Permedia2FindAdapter;
    hwInitData.HwInitialize              = Permedia2Initialize;
    hwInitData.HwStartIO                 = Permedia2StartIO;
    hwInitData.HwResetHw                 = Permedia2ResetHW;
    hwInitData.HwInterrupt               = Permedia2VidInterrupt;
    hwInitData.HwGetPowerState           = Permedia2GetPowerState;
    hwInitData.HwSetPowerState           = Permedia2SetPowerState;
    hwInitData.HwGetVideoChildDescriptor = Permedia2GetChildDescriptor;

    //
    // Declare the legacy resources
    //

    hwInitData.HwLegacyResourceList      = P2LegacyResourceList;
    hwInitData.HwLegacyResourceCount     = P2LegacyResourceEntries;

    //
    // Determine the size we require for the device extension.
    //

    hwInitData.HwDeviceExtensionSize = sizeof(HW_DEVICE_EXTENSION);

    //
    // This device only supports the PCI bus.
    //

    hwInitData.AdapterInterfaceType = PCIBus;

    NtVersion = WIN2K;

    initializationStatus = VideoPortInitialize(Context1,
                                               Context2,
                                               &hwInitData,
                                               NULL);

    if( initializationStatus != NO_ERROR) 
    {
        hwInitData.HwInitDataSize = SIZE_OF_W2K_VIDEO_HW_INITIALIZATION_DATA;
        initializationStatus = VideoPortInitialize(Context1,
                                                   Context2,
                                                   &hwInitData,
                                                   NULL);
    }

    if( initializationStatus != NO_ERROR) 
    {
        NtVersion = NT4;
        hwInitData.HwInterrupt = NULL;

        hwInitData.HwInitDataSize = SIZE_OF_NT4_VIDEO_HW_INITIALIZATION_DATA;
        initializationStatus = VideoPortInitialize(Context1,
                                                   Context2,
                                                   &hwInitData,
                                                   NULL);
    }

    DEBUG_PRINT((2, "PERM2: VideoPortInitialize returned status 0x%x\n", initializationStatus));

    return initializationStatus;

} // end DriverEntry()


VP_STATUS
Permedia2FindAdapter(
    PVOID HwDeviceExtension,
    PVOID pReserved,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
    )

/*++

Routine Description:

 
    This routine gets the access ranges for a device on an enumerable 
    bus and, if necessary, determines the device type

Arguments:

    HwDeviceExtension - 
        System supplied device extension supplied to the miniport for 
        a per-device storage area. 

    pReserved - 
        NULL on Windows 2000 and should be ignored by the miniport.

    ArgumentString - 
        Suuplies a NULL terminated ASCII string. This string originates 
        from the user. This pointer can be NULL. 

    ConfigInfo - 
        Points to a VIDEO_PORT_CONFIG_INFO structure allocated and initialized 
        by the port driver. This structure will contain as much information 
        as could be obtained by the port driver. This routine is responsible 
        for filling in any relevant missing information.

    Again - Is not used on Windows 2000. 
            We set this to FALSE on NT 4, since we only support one adapter on NT4. 

Return Value:

    This routine must return:

    NO_ERROR - 
        Indicates that the routine completed without error.

    ERROR_INVALID_PARAMETER - 
        Indicates that the adapter could not be properly configured or
        information was inconsistent. (NOTE: This does not mean that the
        adapter could not be initialized. Miniports must not attempt to
        initialize the adapter until HwVidInitialize.)

    ERROR_DEV_NOT_EXIST - Indicates no host adapter was found for the
        supplied configuration information.

--*/

{
    PHW_DEVICE_EXTENSION    hwDeviceExtension = HwDeviceExtension;
    P2_DECL_VARS;
    WCHAR                   StringBuffer[60];
    ULONG                   StringLength;
    VP_STATUS               vpStatus;
    ULONG                   UseSoftwareCursor;
    ULONG                   ulValue;
    ULONG                   i;
    VIDEO_ACCESS_RANGE      *pciAccessRange = hwDeviceExtension->PciAccessRange;
    PWSTR                   pwszChip, pwszDAC, pwszAdapterString;
    ULONG                   cbChip, cbDAC, cbAdapterString, cbBiosString;
    ULONG                   pointerCaps;
    USHORT                  usData;

    //
    // 3 (major number) + 1 (dot) + 3 (minor number) + 1 (L'\0') = 8 digtis
    // is enough for bios verions string           
    //

    WCHAR pwszBiosString[8];

    //
    // save current NT version obtained at DriverEntry
    //

    hwDeviceExtension->NtVersion = NtVersion;

    //
    // Make sure the size of the structure is at least as large as what we
    // are expecting (check version of the config info structure).
    //

    if ( (NtVersion == WIN2K) && 
         (ConfigInfo->Length < sizeof(VIDEO_PORT_CONFIG_INFO)) ) 
    {

        DEBUG_PRINT((1, "bad size for VIDEO_PORT_CONFIG_INFO\n"));

        return (ERROR_INVALID_PARAMETER);

    }
    else if ( (NtVersion == NT4) && 
         (ConfigInfo->Length < SIZE_OF_NT4_VIDEO_PORT_CONFIG_INFO) ) 
    {

        DEBUG_PRINT((1, "bad size for VIDEO_PORT_CONFIG_INFO\n"));

        return (ERROR_INVALID_PARAMETER);

    }

    //
    // we must be a PCI device
    //

    if (ConfigInfo->AdapterInterfaceType != PCIBus) 
    {
        DEBUG_PRINT((1,  "not a PCI device\n"));
        return (ERROR_DEV_NOT_EXIST);
    }

    //
    // Retrieve pointers of those new video port functions in Win2k.
    // If you don't want to support NT4, you don't need to do this. You
    // can just call these functions by their name.
    //

    if ( NtVersion == WIN2K )
    {

        if(!(hwDeviceExtension->Win2kVideoPortGetRomImage =  
               ConfigInfo->VideoPortGetProcAddress( hwDeviceExtension, 
                                                    "VideoPortGetRomImage")))
        {
            return (ERROR_DEV_NOT_EXIST);
        }

        if(!(hwDeviceExtension->Win2kVideoPortGetCommonBuffer = 
             ConfigInfo->VideoPortGetProcAddress( hwDeviceExtension, 
                                                 "VideoPortGetCommonBuffer")))
        {
            return (ERROR_DEV_NOT_EXIST);
        }

        if(!(hwDeviceExtension->Win2kVideoPortFreeCommonBuffer =
             ConfigInfo->VideoPortGetProcAddress( hwDeviceExtension, 
                                                 "VideoPortFreeCommonBuffer")))
        {
            return (ERROR_DEV_NOT_EXIST);
        }

        if(!(hwDeviceExtension->Win2kVideoPortDDCMonitorHelper =
             ConfigInfo->VideoPortGetProcAddress( hwDeviceExtension, 
                                                 "VideoPortDDCMonitorHelper")))
        {
            return (ERROR_DEV_NOT_EXIST);
        }

        if(!(hwDeviceExtension->Win2kVideoPortInterlockedExchange =
              ConfigInfo->VideoPortGetProcAddress( hwDeviceExtension, 
                                                  "VideoPortInterlockedExchange")))
        {
            return (ERROR_DEV_NOT_EXIST);
        }

        if(!(hwDeviceExtension->Win2kVideoPortGetVgaStatus =
              ConfigInfo->VideoPortGetProcAddress( hwDeviceExtension, 
                                                  "VideoPortGetVgaStatus")))
        {
            return (ERROR_DEV_NOT_EXIST);
        }

    }
    else
    {

        //
        //  We only support one adapter on NT 4
        //

        Again = FALSE;
    }

    //
    // will be initialized in CopyROMInitializationTable
    //

    hwDeviceExtension->culTableEntries = 0;

    //
    // will be initialized in ConstructValidModesList
    //

    hwDeviceExtension->pFrequencyDefault = NULL;

    //
    // We'll set this TRUE when in InitializeVideo after programming the VTG
    //

    hwDeviceExtension->bVTGRunning = FALSE;
    hwDeviceExtension->bMonitorPoweredOn = TRUE;
    hwDeviceExtension->ChipClockSpeed   = 0;
    hwDeviceExtension->RefClockSpeed    = 0;
    hwDeviceExtension->P28bppRGB        = 0;
    hwDeviceExtension->ExportNon3DModes = 0;
    hwDeviceExtension->PreviousPowerState = VideoPowerOn;

    //
    // pick up capabilities on the way.
    //

    hwDeviceExtension->Capabilities = CAPS_GLYPH_EXPAND;

    //
    // We'll use a software pointer in all modes if the user sets
    // the correct entry in the registry.
    //

    UseSoftwareCursor = 0;

    vpStatus = VideoPortGetRegistryParameters( HwDeviceExtension,
                                               L"UseSoftwareCursor",
                                               FALSE,
                                               Permedia2RegistryCallback,
                                               &UseSoftwareCursor);

    if ( ( vpStatus == NO_ERROR )  && UseSoftwareCursor)
    {
        hwDeviceExtension->Capabilities |= CAPS_SW_POINTER;
    }

    //
    // Query the PCI to see if any of our supported chip devices exist.
    //

    if ( NtVersion == WIN2K )
    {
        if (!Permedia2AssignResources( HwDeviceExtension,
                                       ConfigInfo,
                                       PCI_TYPE0_ADDRESSES + 1,
                                       pciAccessRange ))
        {
            DEBUG_PRINT((1,  "Permedia2AssignResources failed\n"));
            return (ERROR_DEV_NOT_EXIST);
        }

    }
    else
    {
        if (!Permedia2AssignResourcesNT4( HwDeviceExtension,
                                          ConfigInfo,
                                          PCI_TYPE0_ADDRESSES + 1,
                                          pciAccessRange ))
        {
            DEBUG_PRINT((1,  "Permedia2AssignResources failed\n"));
            return (ERROR_DEV_NOT_EXIST);
        }

    }

    //
    // construct the identifier string including the revision id
    //

    StringLength = sizeof(L"3Dlabs PERMEDIA2");

    VideoPortMoveMemory((PVOID)StringBuffer,
                        (PVOID)(L"3Dlabs PERMEDIA2"),
                        StringLength);

    pwszChip = (PWSTR)StringBuffer;
    cbChip   = StringLength;

    //
    // Set the defaults for the board type.
    //

    hwDeviceExtension->deviceInfo.BoardId = PERMEDIA2_BOARD;

    pwszAdapterString = L"Permedia 2";
    cbAdapterString = sizeof(L"Permedia 2");

    //
    // Get the mapped addresses for the control registers and the
    // framebuffer. Must use local variable pCtrlRegs so macro
    // declarations further down will work.
    //

    pCtrlRegs = VideoPortGetDeviceBase(
                     HwDeviceExtension,
                     pciAccessRange[PCI_CTRL_BASE_INDEX].RangeStart,
                     pciAccessRange[PCI_CTRL_BASE_INDEX].RangeLength,
                     pciAccessRange[PCI_CTRL_BASE_INDEX].RangeInIoSpace
                     );

    if (pCtrlRegs == NULL) 
    {
        DEBUG_PRINT((1, "CTRL DeviceBase mapping failed\n"));
        return ERROR_INVALID_PARAMETER;
    }

    hwDeviceExtension->ctrlRegBase = pCtrlRegs;

    //
    // Some boards have a ROM which we can use to identify them.
    //

    CopyROMInitializationTable(hwDeviceExtension);


    if(hwDeviceExtension->culTableEntries == 0)
    {
        //
        // No initialization table, but P2 really needs one in order to come
        // out of sleep mode correctly. Generate initialization table by
        // default values
        //

        GenerateInitializationTable(hwDeviceExtension);
    }


    //
    // Find out what type of RAMDAC we have. 
    //

    vpStatus = NO_ERROR;

    hwDeviceExtension->pRamdac = &(pCtrlRegs->ExternalVideo);

    //
    // some RAMDACs may not support a cursor so a software cursor is the default
    //

    pointerCaps = CAPS_SW_POINTER;

    //
    // Check for a TI TVP4020
    //

    if(DEVICE_FAMILY_ID(hwDeviceExtension->deviceInfo.DeviceId) == PERMEDIA_P2S_ID)
    {
        //
        // P2 with 3Dlabs RAMDAC, check for a rev 2 chip
        //

        i = VideoPortReadRegisterUlong(CHIP_CONFIG);
 
       if(i & 0x40000000)
        {
            DEBUG_PRINT((2, "PERM2: Permedia2 is rev 2\n"));
            hwDeviceExtension->deviceInfo.RevisionId = 2;
        }
        else
        {
            DEBUG_PRINT((2, "PERM2: Permedia2 is rev 1\n"));
        }

        hwDeviceExtension->DacId = P2RD_RAMDAC;
        pointerCaps = (ULONG)CAPS_P2RD_POINTER;

        hwDeviceExtension->deviceInfo.ActualDacId = P2RD_RAMDAC;

        pwszDAC = L"3Dlabs P2RD";
        cbDAC = sizeof(L"3Dlabs P2RD");

        DEBUG_PRINT((1, "PERM2: using P2RD RAMDAC\n"));
    }
    else
    {
        hwDeviceExtension->DacId = TVP4020_RAMDAC;
        pointerCaps = CAPS_TVP4020_POINTER;

        hwDeviceExtension->deviceInfo.ActualDacId = TVP4020_RAMDAC;

        if(hwDeviceExtension->deviceInfo.RevisionId == PERMEDIA2A_REV_ID)
        {
            pwszDAC = L"TI TVP4020A";
            cbDAC = sizeof(L"TI TVP4020A");
            DEBUG_PRINT((1, "PERM2: using TVP4020A RAMDAC\n"));
        }
        else
        {
            pwszDAC = L"TI TVP4020C";
            cbDAC = sizeof(L"TI TVP4020C");
            DEBUG_PRINT((1, "PERM2: using TVP4020C RAMDAC\n"));
        }
    }

    //
    // use the RAMDAC cursor capability only if the user didn't specify 
    // a software cursor
    //
   
    if (!(hwDeviceExtension->Capabilities & CAPS_SW_POINTER))
    {
        hwDeviceExtension->Capabilities |= pointerCaps;
    }

    hwDeviceExtension->PhysicalFrameIoSpace = 
                       pciAccessRange[PCI_FB_BASE_INDEX].RangeInIoSpace | 
                                              VIDEO_MEMORY_SPACE_P6CACHE;

    if ( (hwDeviceExtension->pFramebuffer =
            VideoPortGetDeviceBase(
                           HwDeviceExtension,
                           pciAccessRange[PCI_FB_BASE_INDEX].RangeStart,
                           pciAccessRange[PCI_FB_BASE_INDEX].RangeLength,
                           (UCHAR) hwDeviceExtension->PhysicalFrameIoSpace
                           ) ) == NULL)
    {

        //
        // Some machines have limitations on how much PCI address space they
        // can map in so try again, reducing the amount we map till we succeed
        // or the size gets to zero in which case we really have failed.
        //

        ULONG sz;

        DEBUG_PRINT((1, "PERM2: FB DeviceBase mapping failed\n"));

        for ( sz = pciAccessRange[PCI_FB_BASE_INDEX].RangeLength; 
              sz > 0; 
              sz -= 1024*1024 )
        {

            if ( (hwDeviceExtension->pFramebuffer =
                     VideoPortGetDeviceBase(
                               HwDeviceExtension,
                               pciAccessRange[PCI_FB_BASE_INDEX].RangeStart,
                               sz,
                               (UCHAR) hwDeviceExtension->PhysicalFrameIoSpace
                               ) ) != NULL)
            {

                //
                // store the modified size
                //

                pciAccessRange[PCI_FB_BASE_INDEX].RangeLength = sz;

                break;

            }
        }

        //
        // if sz is zero, well we tried ...
        //

        if (sz == 0)
            return ERROR_INVALID_PARAMETER;
    }

    DEBUG_PRINT((1, "PERM2: FB mapped at 0x%x for length 0x%x (%s)\n",
                    hwDeviceExtension->pFramebuffer,
                    pciAccessRange[PCI_FB_BASE_INDEX].RangeLength,
                    pciAccessRange[PCI_FB_BASE_INDEX].RangeInIoSpace ?
                        "I/O Ports" : "MemMapped"));


    //
    // Initialize the RAM registers and dynamically size the framebuffer 
    //

    if (!InitializeAndSizeRAM(hwDeviceExtension, pciAccessRange))
    {
        DEBUG_PRINT((0, "InitializeAndSizeRAM failed\n"));
        return ERROR_DEV_NOT_EXIST;
    }

    //
    // Record the size of the video memory.
    //

    hwDeviceExtension->AdapterMemorySize = 
                       pciAccessRange[PCI_FB_BASE_INDEX].RangeLength;


#if defined(_ALPHA_)

    //
    // We want to use a dense space mapping of the frame buffer
    // whenever we can on the Alpha.
    //

    hwDeviceExtension->PhysicalFrameIoSpace = 4;

    //
    // The new DeskStation Alpha machines don't always support
    // dense space.  Therefore, we should try to map the memory
    // at this point as a test.  If the mapping succeeds then
    // we can use dense space, otherwise we'll use sparse space.
    //

    {
        PULONG MappedSpace=0;
        VP_STATUS status;

        DEBUG_PRINT((1, "PERM2: Checking to see if we can use dense space...\n"));

        //
        // We want to try to map the dense memory where it will ultimately
        // be mapped anyway.
        //

        MappedSpace = (PULONG)VideoPortGetDeviceBase (
                              hwDeviceExtension,
                              pciAccessRange[PCI_FB_BASE_INDEX].RangeStart,
                              pciAccessRange[PCI_FB_BASE_INDEX].RangeLength,
                              (UCHAR) hwDeviceExtension->PhysicalFrameIoSpace
                              );

        if (MappedSpace == NULL)
        {
            //
            // Well, looks like we can't use dense space to map the
            // range.  Lets use sparse space, and let the display
            // driver know.
            //

            DEBUG_PRINT((1, "PERM2: Can't use dense space!\n"));

            hwDeviceExtension->PhysicalFrameIoSpace = 0;

            hwDeviceExtension->Capabilities |= CAPS_SPARSE_SPACE;
        }
        else
        {
            //
            // The mapping worked.  However, we were only mapping to
            // see if dense space was supported.  Free the memory.
            //

            DEBUG_PRINT((1, "PERM2: We can use dense space.\n"));

            VideoPortFreeDeviceBase(hwDeviceExtension,
                                    MappedSpace);
        }
    }

#endif  //  defined(_ALPHA_)

    //
    // We now have a complete hardware description of the hardware.
    // Save the information to the registry so it can be used by
    // configuration programs - such as the display applet.
    //

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.ChipType",
                                   pwszChip,
                                   cbChip);

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.DacType",
                                   pwszDAC,
                                   cbDAC);

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.MemorySize",
                                   &hwDeviceExtension->AdapterMemorySize,
                                   sizeof(ULONG));

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.AdapterString",
                                   pwszAdapterString,
                                   cbAdapterString);

    cbBiosString = GetBiosVersion(HwDeviceExtension, (PWSTR) pwszBiosString);

    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.BiosString",
                                   pwszBiosString,
                                   cbBiosString);

    ConstructValidModesList(HwDeviceExtension, hwDeviceExtension);

    if (hwDeviceExtension->NumAvailableModes == 0)
    {
        DEBUG_PRINT((1, "No video modes available\n"));
    
        return(ERROR_DEV_NOT_EXIST);
    }

    //
    // Frame buffer information
    //

    hwDeviceExtension->PhysicalFrameAddress = 
            pciAccessRange[PCI_FB_BASE_INDEX].RangeStart;

    hwDeviceExtension->FrameLength = 
            pciAccessRange[PCI_FB_BASE_INDEX].RangeLength;

    //
    // Control Register information
    // Get the base address, starting at zero and map all registers
    //

    hwDeviceExtension->PhysicalRegisterAddress = 
            pciAccessRange[PCI_CTRL_BASE_INDEX].RangeStart;

    hwDeviceExtension->RegisterLength = 
            pciAccessRange[PCI_CTRL_BASE_INDEX].RangeLength;

    hwDeviceExtension->RegisterSpace =  
            pciAccessRange[PCI_CTRL_BASE_INDEX].RangeInIoSpace;

    ConfigInfo->VdmPhysicalVideoMemoryAddress.LowPart  = 0x000A0000;
    ConfigInfo->VdmPhysicalVideoMemoryAddress.HighPart = 0x00000000;
    ConfigInfo->VdmPhysicalVideoMemoryLength           = 0x00020000;


    //
    // Clear out the Emulator entries and the state size since this driver
    // does not support them.
    //

    ConfigInfo->NumEmulatorAccessEntries     = 0;
    ConfigInfo->EmulatorAccessEntries        = NULL;
    ConfigInfo->EmulatorAccessEntriesContext = 0;

    //
    // This driver does not do SAVE/RESTORE of hardware state.
    //

    ConfigInfo->HardwareStateSize = 0;

    //
    // in a multi-adapter system we'll need to disable VGA for the 
    // secondary adapters
    //

    if(!hwDeviceExtension->bVGAEnabled)
    {
        DEBUG_PRINT((1, "PERM2: disabling VGA for the secondary card\n"));

        // 
        // Enable graphics mode, disable VGA
        // 

        VideoPortWriteRegisterUchar(PERMEDIA_MMVGA_INDEX_REG, 
                                    PERMEDIA_VGA_CTRL_INDEX);

        usData = (USHORT)VideoPortReadRegisterUchar(PERMEDIA_MMVGA_DATA_REG);
        usData &= ~PERMEDIA_VGA_ENABLE;
 
        usData = (usData << 8) | PERMEDIA_VGA_CTRL_INDEX;
        VideoPortWriteRegisterUshort(PERMEDIA_MMVGA_INDEX_REG, usData);

        #define INTERNAL_VGA_ENABLE  (1 << 1)
        #define VGA_FIXED_ADD_DECODE (1 << 2)

        ulValue = VideoPortReadRegisterUlong(CHIP_CONFIG);
        ulValue &= ~INTERNAL_VGA_ENABLE;
        ulValue &= ~VGA_FIXED_ADD_DECODE;
        VideoPortWriteRegisterUlong(CHIP_CONFIG, ulValue);

    }

    //
    // Indicate a successful completion status.
    //

    return NO_ERROR;

} // end Permedia2FindAdapter()

VOID
ConstructValidModesList(
    PVOID HwDeviceExtension,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

/*++

 Routine Description:

    Here we prune valid modes, based on rules according to the chip
    capabilities and memory requirements.
    
    We prune modes so that we will not annoy the user by presenting
    modes in the 'Video Applet' which we know the user can't use.
    
    Look up the registry to see if we want to export modes which can only
    be used as single buffered by 3D applications. If we only want double
    buffered modes then, effectively, we have only half the memory in 
    which to display the standard 2D resolution. This is only not true at 12bpp
    where we can double buffer at any resolution.
    
--*/
{
    PP2_VIDEO_FREQUENCIES FrequencyEntry;
    PP2_VIDEO_MODES       ModeEntry;
    LONG    AdapterMemorySize;
    ULONG   ModeIndex;
    ULONG   i;

    hwDeviceExtension->NumAvailableModes = 0;

    //
    // Since there are a number of frequencies possible for each
    // distinct resolution/colour depth, we cycle through the
    // frequency table and find the appropriate mode entry for that
    // frequency entry.
    //

    if (!BuildFrequencyList(hwDeviceExtension))
        return;

    for (FrequencyEntry = hwDeviceExtension->FrequencyTable, ModeIndex = 0;
         FrequencyEntry->BitsPerPel != 0;
         FrequencyEntry++, ModeIndex++) 
    {

        //
        // Find the mode for this entry.  First, assume we won't find one.
        //

        FrequencyEntry->ModeValid = FALSE;
        FrequencyEntry->ModeIndex = ModeIndex;

        for (ModeEntry = P2Modes, i = 0; i < NumP2VideoModes; ModeEntry++, i++)
        {

            if ((FrequencyEntry->BitsPerPel ==
                    ModeEntry->ModeInformation.BitsPerPlane) &&
                (FrequencyEntry->ScreenWidth ==
                    ModeEntry->ModeInformation.VisScreenWidth) &&
                (FrequencyEntry->ScreenHeight ==
                    ModeEntry->ModeInformation.VisScreenHeight))
            {
                AdapterMemorySize = (LONG)hwDeviceExtension->AdapterMemorySize;

                //
                // We've found a mode table entry that matches this frequency
                // table entry.  Now we'll figure out if we can actually do
                // this mode/frequency combination.  For now, assume we'll
                // succeed.
                //

                FrequencyEntry->ModeEntry = ModeEntry;
                FrequencyEntry->ModeValid = TRUE;

                ModeEntry->ModeInformation.ScreenStride = 
                        ModeEntry->ScreenStrideContiguous;

                //
                // Rule: use true color at 8bpp if we've enabled that
                // capability above.
                //

                if ((FrequencyEntry->BitsPerPel == 8) &&
                        (hwDeviceExtension->Capabilities & CAPS_8BPP_RGB))
                {
                    ModeEntry->ModeInformation.AttributeFlags &=
                         ~(VIDEO_MODE_PALETTE_DRIVEN | VIDEO_MODE_MANAGED_PALETTE);

                    //
                    // NB. These must match the way the palette is loaded in
                    // InitializeVideo.
                    //

                    ModeEntry->ModeInformation.RedMask   = 0x07;
                    ModeEntry->ModeInformation.GreenMask = 0x38;
                    ModeEntry->ModeInformation.BlueMask  = 0xc0;
                }

                //
                // Rule: We have to have enough memory to handle the mode.
                //

                if ((LONG)(ModeEntry->ModeInformation.VisScreenHeight *
                           ModeEntry->ModeInformation.ScreenStride) >
                                   AdapterMemorySize)
                {
                    FrequencyEntry->ModeValid = FALSE;
                }

                { 
                    ULONG pixelData;
                    ULONG DacDepth = FrequencyEntry->BitsPerPel;

                    //
                    // We need the proper pixel size to calculate timing values
                    //

                    if (DacDepth == 15)
                    {
                        DacDepth = 16;
                    }
                    else if (DacDepth == 12)
                    {
                        DacDepth = 32;
                    }

                    pixelData = FrequencyEntry->PixelClock * (DacDepth / 8);

                    if (((FrequencyEntry->PixelClock > P2_MAX_PIXELCLOCK ||
                          pixelData > P2_MAX_PIXELDATA)))
                    {
                        FrequencyEntry->ModeValid = FALSE;
                    }
    
                    //
                    // Don't supports 24bpp
                    //

                    if(FrequencyEntry->BitsPerPel == 24)
                    {
                        FrequencyEntry->ModeValid = FALSE;
                    }
                }

                //
                // Don't forget to count it if it's still a valid mode after
                // applying all those rules.
                //

                if (FrequencyEntry->ModeValid)
                {
                    if(hwDeviceExtension->pFrequencyDefault == NULL &&
                       ModeEntry->ModeInformation.BitsPerPlane == 8 &&
                       ModeEntry->ModeInformation.VisScreenWidth == 640 &&
                       ModeEntry->ModeInformation.VisScreenHeight == 480)
                    {
                        hwDeviceExtension->pFrequencyDefault = FrequencyEntry;
                    }

                    hwDeviceExtension->NumAvailableModes++;
                }

                //
                // We've found a mode for this frequency entry, so we
                // can break out of the mode loop:
                //

                break;

            }
        }
    }

    hwDeviceExtension->NumTotalModes = ModeIndex;

    DEBUG_PRINT((2, "PERM2: %d total modes\n", ModeIndex));
    DEBUG_PRINT((2, "PERM2: %d total valid modes\n", hwDeviceExtension->NumAvailableModes));
}


VP_STATUS
Permedia2RegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

/*++

Routine Description:

    This routine is used to read back various registry values.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    Context - Context value passed to the get registry paramters routine. If
    this is not null assume it's a ULONG* and save the data value in it.

    ValueName - Name of the value requested.

    ValueData - Pointer to the requested data.

    ValueLength - Length of the requested data.

Return Value:

    if the variable doesn't exist return an error,
    else if a context is supplied assume it's a PULONG and fill in the value
    and return no error, else if the value is non-zero return an error.

--*/

{

    if (ValueLength) 
    {
        if (Context) 
        {                  
            *(ULONG *)Context = *(PULONG)ValueData;
        }
        else if (*((PULONG)ValueData) != 0)
        {                  
            return ERROR_INVALID_PARAMETER;
        }

        return NO_ERROR;

    } else 
    {
        return ERROR_INVALID_PARAMETER;
    }

} // end Permedia2RegistryCallback()


VP_STATUS
Permedia2RetrieveGammaCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    )

/*++

Routine Description:

    This routine is used to read back the gamma LUT from the registry.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    Context - Context value passed to the get registry paramters routine

    ValueName - Name of the value requested.

    ValueData - Pointer to the requested data.

    ValueLength - Length of the requested data.

Return Value:

    if the variable doesn't exist return an error, else copy the gamma lut 
    into the supplied pointer

--*/

{

    if (ValueLength != MAX_CLUT_SIZE)
    {

        DEBUG_PRINT((1, "Permedia2RetrieveGammaCallback got ValueLength of %d\n", ValueLength));

        return ERROR_INVALID_PARAMETER;

    }

    VideoPortMoveMemory(Context, ValueData, MAX_CLUT_SIZE);

    return NO_ERROR;

} // end Permedia2RetrieveGammaCallback()


BOOLEAN
InitializeAndSizeRAM(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEO_ACCESS_RANGE pciAccessRange
    )

/*++

Routine Description:

    Initialize extra control registers and dynamically size the
    video RAM for the Permedia.

Arguments:

    hwDeviceExtension - Supplies a pointer to the miniport's device extension.
    pciAccessRange    - access range of mapped resources

Return Value:

    FALSE if we find no RAM, TRUE otherwise

--*/

{
    PVOID   HwDeviceExtension = (PVOID)hwDeviceExtension;
    ULONG   fbMappedSize;
    ULONG   i, j;
    P2_DECL;

    PULONG  pV, pVStart, pVEnd;
    ULONG   testPattern;
    ULONG   probeSize;
    ULONG   save0, save1;
    ULONG   temp;
    ULONG   saveVidCtl;		
    USHORT  saveVGA, usData;


    if(hwDeviceExtension->culTableEntries)
    {
        //
        // When vga is enabled, these registers should be set by bios at
        // boot time. But we saw cases when bios failed to do this. We'll
        // set these register when vga is off or when we see values are
        // wrong
        //

        if(!hwDeviceExtension->bVGAEnabled || 
           !VerifyBiosSettings(hwDeviceExtension))
        {
            //
            // save video control and vga register
            //

            saveVidCtl = VideoPortReadRegisterUlong(VIDEO_CONTROL);

            VideoPortWriteRegisterUchar( PERMEDIA_MMVGA_INDEX_REG, 
                                         PERMEDIA_VGA_CTRL_INDEX );

            saveVGA = (USHORT)VideoPortReadRegisterUchar(
                                        PERMEDIA_MMVGA_DATA_REG );

            //
            // Disable Video and VGA
            //

            VideoPortWriteRegisterUlong(VIDEO_CONTROL, 0);	

            usData = saveVGA & (USHORT)(~PERMEDIA_VGA_ENABLE);
            usData = (usData << 8) | PERMEDIA_VGA_CTRL_INDEX;
            VideoPortWriteRegisterUshort(PERMEDIA_MMVGA_INDEX_REG, usData);
 
            ProcessInitializationTable(hwDeviceExtension);

            #if USE_SINGLE_CYCLE_BLOCK_WRITES
            {

                i = VideoPortReadRegisterUlong(MEM_CONFIG);

                VideoPortWriteRegisterUlong(MEM_CONFIG, i | (1 << 21)); // single cycle block writes

            }
            #endif //USE_SINGLE_CYCLE_BLOCK_WRITES

            //
            // Restore VGA and video control
            //

            saveVGA = (saveVGA << 8) | PERMEDIA_VGA_CTRL_INDEX;
            VideoPortWriteRegisterUshort(PERMEDIA_MMVGA_INDEX_REG, saveVGA);

            VideoPortWriteRegisterUlong(VIDEO_CONTROL, saveVidCtl);

        }
    }


    VideoPortWriteRegisterUlong(APERTURE_ONE, 0x0);
    VideoPortWriteRegisterUlong(APERTURE_TWO, 0x0);  

    VideoPortWriteRegisterUlong(BYPASS_WRITE_MASK, 0xFFFFFFFF);

    if (pciAccessRange == NULL)
    {
        return TRUE;
    }

    fbMappedSize = pciAccessRange[PCI_FB_BASE_INDEX].RangeLength;

    i = VideoPortReadRegisterUlong(MEM_CONFIG);

    //
    // MEM_CONFIG doesn't have the number of memory banks defined 
    // at boot-time for P2: set up the board for 8MB. Can't do this 
    // if the VGA is running, but that's OK. The VGA has set this 
    // register to what we want.
    //

    if (!hwDeviceExtension->bVGAEnabled)
    {
        i |= (3 << 29);

        pciAccessRange[PCI_FB_BASE_INDEX].RangeLength = 
                  (((i >> 29) & 0x3) + 1) * (2*1024*1024);

        VideoPortWriteRegisterUlong(MEM_CONFIG, i);
        VideoPortStallExecution(10);
    }

    testPattern = 0x55aa33cc;
    probeSize = (128 * 1024 / sizeof(ULONG));   // In DWords

    //
    // Dynamically size the SGRAM. Sample every 128K. If you happen to
    // have some VERY odd SGRAM size you may need cut this down. After
    // each write to the probe address, write to SGRAM address zero to 
    // clear the PCI data bus. Otherwise, if we read from fresh air the
    // written value may be floating on the bus and the read give it back 
    // to us.
    //
    // Note, if the memory wraps around at the end, then a different 
    // algorithm must be used (which waits for address zero to become 
    // equal to the address being written).
    //
    // Any valid pixel that we probe, we save and restore. This is to
    // avoid dots on the screen if we have booted onto the Permedia2 board.
    //

    pVStart = (PULONG)hwDeviceExtension->pFramebuffer;
    pVEnd   = (PULONG)((ULONG_PTR)pVStart + fbMappedSize);

    //
    // check out address zero
    //

    save0 = VideoPortReadRegisterUlong(pVStart);
    save1 = VideoPortReadRegisterUlong(pVStart+1);

    VideoPortWriteRegisterUlong(pVStart, testPattern);
    VideoPortWriteRegisterUlong(pVStart+1, 0);

    if ((temp = VideoPortReadRegisterUlong(pVStart)) != testPattern)
    {
        DEBUG_PRINT((1, "cannot access SGRAM. Expected 0x%x, got 0x%x\n", 
                                                      testPattern, temp));
        return FALSE;
    }
 
    VideoPortWriteRegisterUlong(pVStart+1, save1);

    for (pV = pVStart + probeSize; pV < pVEnd; pV += probeSize)
    {
        save1 = VideoPortReadRegisterUlong(pV);
        VideoPortWriteRegisterUlong(pV, testPattern);
        VideoPortWriteRegisterUlong(pVStart, 0);

        if ((temp = VideoPortReadRegisterUlong(pV)) != testPattern)
        {

            DEBUG_PRINT((1, "PERM2: FB probe failed at offset 0x%x\n", 
                    (LONG)((LONG_PTR)pV - (LONG_PTR)pVStart)));

            DEBUG_PRINT((1, "PERM2: \tread back 0x%x, wanted 0x%x\n", 
                    temp, testPattern));
            break;
        }

        VideoPortWriteRegisterUlong(pV, save1);

    }

    VideoPortWriteRegisterUlong(pVStart, save0);

    if (pV < pVEnd)
    {
        //
        // I could also set MEM_CONFIG to the correct value here as we 
        // now know the size of SGRAM, but as it's never used again
        // I won't bother
        //

        pciAccessRange[PCI_FB_BASE_INDEX].RangeLength = 
                       (ULONG)((ULONG_PTR)pV - (ULONG_PTR)pVStart);

        DEBUG_PRINT((1, "PERM2: SGRAM dynamically resized to length 0x%x\n",
                        pciAccessRange[PCI_FB_BASE_INDEX].RangeLength));

    }

    if (pciAccessRange[PCI_FB_BASE_INDEX].RangeLength > fbMappedSize)
    {
        pciAccessRange[PCI_FB_BASE_INDEX].RangeLength = fbMappedSize;
    }

    DEBUG_PRINT((2, "PERM2: got a size of 0x%x bytes\n", 
                     pciAccessRange[PCI_FB_BASE_INDEX].RangeLength));

    //
    // finally, if the SGRAM size is actually smaller than the region that
    // we probed, remap to the smaller size to save on page table entries.
    // Not doing this causes some systems to run out of PTEs.
    //

    if (fbMappedSize > pciAccessRange[PCI_FB_BASE_INDEX].RangeLength)
    {
        VideoPortFreeDeviceBase(HwDeviceExtension, 
                                hwDeviceExtension->pFramebuffer);

        if ( (hwDeviceExtension->pFramebuffer =
                VideoPortGetDeviceBase(HwDeviceExtension,
                     pciAccessRange[PCI_FB_BASE_INDEX].RangeStart,
                     pciAccessRange[PCI_FB_BASE_INDEX].RangeLength,
                     (UCHAR) hwDeviceExtension->PhysicalFrameIoSpace)) == NULL)
        {

            //
            // this shouldn't happen but we'd better check
            //

            DEBUG_PRINT((0, "Remap of framebuffer to smaller size failed!!!\n"));
            return FALSE;

        }

        DEBUG_PRINT((1, "PERM2: Remapped framebuffer memory to 0x%x, size 0x%x\n",
                         hwDeviceExtension->pFramebuffer,
                         pciAccessRange[PCI_FB_BASE_INDEX].RangeLength));
    }

    //
    // PERMEDIA2 has no localbuffer
    //

    hwDeviceExtension->deviceInfo.LocalbufferWidth = 0;
    hwDeviceExtension->deviceInfo.LocalbufferLength = 0;

    return TRUE;

}

BOOLEAN
Permedia2Initialize(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    This routine does one time initialization of the device.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

    Returns TRUE when success.

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ulValue;
    P2_DECL;

    //
    // always initialize the IRQ control block...
    // the memory is used to store information which is global to all 
    // driver instances of a display card by the display driver
    //

    if ( hwDeviceExtension->NtVersion == WIN2K)
    {
        if (!Permedia2InitializeInterruptBlock(hwDeviceExtension))
        {

            DEBUG_PRINT((0, "PERM2: failed to initialize the IRQ control block\n"));
            return FALSE;

        }
    }

    //
    // Clear the framebuffer.
    //

    VideoPortZeroDeviceMemory(hwDeviceExtension->pFramebuffer,
                              hwDeviceExtension->AdapterMemorySize);

    return TRUE;

} // end Permedia2Initialize()


BOOLEAN
Permedia2StartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    )

/*++

Routine Description:

    This routine is the main execution routine for the miniport driver. It
    accepts a Video Request Packet, performs the request, and then returns
    with the appropriate status.

Arguments:

    HwDeviceExtension - Supplies a pointer to the miniport's device extension.

    RequestPacket - Pointer to the video request packet. This structure
        contains all the parameters passed to the VideoIoControl function.

Return Value:

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    P2_DECL;
    VP_STATUS status;
    PVIDEO_MODE_INFORMATION modeInformation;
    PVIDEO_MEMORY_INFORMATION memoryInformation;
    PVIDEOPARAMETERS pVideoParams;
    PVIDEO_CLUT clutBuffer;
    ULONG inIoSpace;
    ULONG RequestedMode;
    ULONG modeNumber;
    ULONG ulValue;
    HANDLE ProcessHandle;
    PP2_VIDEO_MODES ModeEntry;
    P2_VIDEO_FREQUENCIES FrequencyEntry, *pFrequencyEntry;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;

    //
    // Switch on the IoContolCode in the RequestPacket. It indicates which
    // function must be performed by the driver.
    //

    switch (RequestPacket->IoControlCode) 
    {

        case IOCTL_VIDEO_QUERY_REGISTRY_DWORD:
        {
            DEBUG_PRINT((2, "PERM2: got IOCTL_VIDEO_QUERY_REGISTRY_DWORD\n"));

            if (RequestPacket->OutputBufferLength <
               (RequestPacket->StatusBlock->Information = sizeof(ULONG)))
            {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }

            if (VideoPortGetRegistryParameters( HwDeviceExtension,
                                                RequestPacket->InputBuffer,
                                                FALSE,
                                                Permedia2RegistryCallback,
                                                &ulValue) != NO_ERROR )
            {
                DEBUG_PRINT((1, "PERM2: IOCTL_VIDEO_QUERY_REGISTRY_DWORD failed\n"));
    
                status = ERROR_INVALID_PARAMETER;
                break;
            }

            *(PULONG)(RequestPacket->OutputBuffer) = ulValue;

            status = NO_ERROR;
            break;
        }

        case IOCTL_VIDEO_REG_SAVE_GAMMA_LUT:
        {
            DEBUG_PRINT((2, "PERM2: got IOCTL_VIDEO_REG_SAVE_GAMMA_LUT\n"));
    
            if (RequestPacket->InputBufferLength <
               (RequestPacket->StatusBlock->Information = MAX_CLUT_SIZE))
            {
  
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
  
            }
  
            status = VideoPortSetRegistryParameters( HwDeviceExtension,
                                                     L"DisplayGammaLUT",
                                                     RequestPacket->InputBuffer,
                                                     MAX_CLUT_SIZE);
            break;
        }
  
        case IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT:
        {
            DEBUG_PRINT((2, "PERM2: got IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT\n"));
  
            if (RequestPacket->OutputBufferLength <
               (RequestPacket->StatusBlock->Information = MAX_CLUT_SIZE))
            {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
  
            status = VideoPortGetRegistryParameters( HwDeviceExtension,
                                                     L"DisplayGammaLUT",
                                                     FALSE,
                                                     Permedia2RetrieveGammaCallback,
                                                     RequestPacket->InputBuffer);
            break;
        }
  
        case IOCTL_VIDEO_QUERY_DEVICE_INFO:
  
            DEBUG_PRINT((1, "PERM2: Permedia2StartIO - QUERY_deviceInfo\n"));
  
            if ( RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information = sizeof(P2_Device_Info))) 
                           
            {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
  
            //
            // Copy our local PCI info to the output buffer
            //
  
            *(P2_Device_Info *)(RequestPacket->OutputBuffer) = 
                               hwDeviceExtension->deviceInfo;

            status = NO_ERROR;
            break;
  
        case IOCTL_VIDEO_MAP_VIDEO_MEMORY:
  
            DEBUG_PRINT((1, "PERM2: Permedia2StartIO - MapVideoMemory\n"));
  
            if ( ( RequestPacket->OutputBufferLength <
                 ( RequestPacket->StatusBlock->Information =
                   sizeof(VIDEO_MEMORY_INFORMATION) ) ) ||
                 ( RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY) ) ) 
            {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
  
            memoryInformation = RequestPacket->OutputBuffer;
  
            memoryInformation->VideoRamBase = ((PVIDEO_MEMORY)
                    (RequestPacket->InputBuffer))->RequestedVirtualAddress;
  
            memoryInformation->VideoRamLength =
                    hwDeviceExtension->FrameLength;
  
            inIoSpace = hwDeviceExtension->PhysicalFrameIoSpace;
  
            //
            // Performance:
            //
            // Enable USWC
            // We only do it for the frame buffer - memory mapped registers can
            // not be mapped USWC because write combining the registers would
            // cause very bad things to happen !
            //
  
            status = VideoPortMapMemory( HwDeviceExtension,
                                         hwDeviceExtension->PhysicalFrameAddress,
                                         &(memoryInformation->VideoRamLength),
                                         &inIoSpace,
                                         &(memoryInformation->VideoRamBase));

            if (status != NO_ERROR) 
            {
                DEBUG_PRINT((1, "PERM2: VideoPortMapMemory failed with error %d\n", status));
                break;
            }
  
            //
            // The frame buffer and virtual memory and equivalent in this
            // case.
            //

            memoryInformation->FrameBufferBase = 
                               memoryInformation->VideoRamBase;
  
            memoryInformation->FrameBufferLength = 
                               memoryInformation->VideoRamLength;
  
            break;
  
  
        case IOCTL_VIDEO_UNMAP_VIDEO_MEMORY:
    
            DEBUG_PRINT((1, "PERM2: Permedia2StartIO - UnMapVideoMemory\n"));
  
            if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) 
            {
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
    
            status = VideoPortUnmapMemory(
                          HwDeviceExtension,
                          ((PVIDEO_MEMORY)(RequestPacket->InputBuffer))->
                                           RequestedVirtualAddress,
                          0 );
  
            break;
  
  
        case IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES:
    
            DEBUG_PRINT((1, "PERM2: Permedia2StartIO - QueryPublicAccessRanges\n"));
    
            {
    
            PVIDEO_PUBLIC_ACCESS_RANGES portAccess;
            ULONG physicalPortLength;
            PVOID VirtualAddress;
            PHYSICAL_ADDRESS PhysicalAddress;
    
            if ( ( RequestPacket->OutputBufferLength <
                 ( RequestPacket->StatusBlock->Information =
                   sizeof(VIDEO_PUBLIC_ACCESS_RANGES))) ||
                 ( RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY) ) )
            {
  
                status = ERROR_INSUFFICIENT_BUFFER;
                break;
            }
  
            ProcessHandle = (HANDLE)(((PVIDEO_MEMORY)
                     (RequestPacket->InputBuffer))->RequestedVirtualAddress);
  
            if (ProcessHandle != (HANDLE)0)
            {
                 //
                 // map 4K area for a process
                 //
          
                 DEBUG_PRINT((2, "PERM2: Mapping in 4K area from Control registers\n"));

                 VirtualAddress  = (PVOID)ProcessHandle;
                 PhysicalAddress = hwDeviceExtension->PhysicalRegisterAddress;
                 PhysicalAddress.LowPart += 0x2000;
                 physicalPortLength = 0x1000;
  
            }
            else
            {
                 DEBUG_PRINT((2, "PERM2: Mapping in all Control registers\n"));
                 VirtualAddress = NULL;
                 PhysicalAddress = hwDeviceExtension->PhysicalRegisterAddress;
                 physicalPortLength = hwDeviceExtension->RegisterLength;
            }

            portAccess = RequestPacket->OutputBuffer;
  
            portAccess->VirtualAddress  = VirtualAddress;
            portAccess->InIoSpace       = hwDeviceExtension->RegisterSpace;
            portAccess->MappedInIoSpace = portAccess->InIoSpace;
  
            status = VideoPortMapMemory( HwDeviceExtension,
                                         PhysicalAddress,
                                         &physicalPortLength,
                                         &(portAccess->MappedInIoSpace),
                                         &(portAccess->VirtualAddress));
  
            if (status == NO_ERROR)
            {
                DEBUG_PRINT((1, "PERM2: mapped PAR[0] at vaddr 0x%x for length 0x%x\n",
                                    portAccess->VirtualAddress,
                                    physicalPortLength));
            }
            else
            {
                DEBUG_PRINT((1, "PERM2: VideoPortMapMemory failed with status 0x%x\n", status));
            }

            if ( (RequestPacket->OutputBufferLength >= 
                                3 * sizeof(VIDEO_PUBLIC_ACCESS_RANGES) ) &&
                 (ProcessHandle == (HANDLE)0) )
            {

                RequestPacket->StatusBlock->Information =
                                3 * sizeof(VIDEO_PUBLIC_ACCESS_RANGES);

                portAccess = RequestPacket->OutputBuffer;
                PhysicalAddress = hwDeviceExtension->PhysicalRegisterAddress;
                physicalPortLength = hwDeviceExtension->RegisterLength;

#if defined(_ALPHA_)

                //
                // for alpha, we want to map in a dense version of the 
                // control registers if we can. If this fails, we null 
                // the virtual address
                //

                portAccess += 2;
                portAccess->VirtualAddress  = NULL;
                portAccess->InIoSpace       = hwDeviceExtension->RegisterSpace;
                portAccess->MappedInIoSpace = 4;

                status = VideoPortMapMemory( HwDeviceExtension,
                                             PhysicalAddress,
                                             &physicalPortLength,
                                             &(portAccess->MappedInIoSpace),
                                             &(portAccess->VirtualAddress));

                if (status == NO_ERROR)
                {
                    DEBUG_PRINT((1, "PERM2: mapped dense PAR[0] at vaddr 0x%x for length 0x%x\n",
                                     portAccess->VirtualAddress,
                                     physicalPortLength));
                }
                else
                {
                    DEBUG_PRINT((1, "PERM2: dense VideoPortMapMemory failed with status 0x%x\n", status));
                }
#else
                //
                // all others, we just copy range[0]
                //

                portAccess[2] = portAccess[0];
#endif
            }
        }

        break;

    case IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES:

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - FreePublicAccessRanges\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) 
        {

            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        status = VideoPortUnmapMemory(
                         HwDeviceExtension,
                         ((PVIDEO_MEMORY)(RequestPacket->InputBuffer))->
                                                 RequestedVirtualAddress,
                         0);

        if (status != NO_ERROR)
        {
            DEBUG_PRINT((1, "PERM2: VideoPortUnmapMemory failed with status 0x%x\n", status));
        }

#if defined(_ALPHA_)

        {
            PVIDEO_MEMORY pVideoMemory;
            PVOID pVirtualAddress;

            if (RequestPacket->InputBufferLength >= 3 * sizeof(VIDEO_MEMORY)) 
            {
                pVideoMemory = (PVIDEO_MEMORY)(RequestPacket->InputBuffer);

                pVirtualAddress = pVideoMemory->RequestedVirtualAddress;

                pVideoMemory += 2;

                if((pVideoMemory->RequestedVirtualAddress) &&
                   (pVideoMemory->RequestedVirtualAddress != pVirtualAddress))
                {
                    status = VideoPortUnmapMemory(
                                  HwDeviceExtension,
                                  pVideoMemory->RequestedVirtualAddress,
                                  0 );
                }

                if (status != NO_ERROR)
                        DEBUG_PRINT((1, "PERM2: VideoPortUnmapMemory failed on Alpha with status 0x%x\n", status));
            
            }
        }

#endif
        break;

    case IOCTL_VIDEO_HANDLE_VIDEOPARAMETERS:

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - HandleVideoParameters\n"));

        //
        // We don't support a tv connector so just return NO_ERROR here
        //

        pVideoParams = (PVIDEOPARAMETERS) (RequestPacket->InputBuffer);

        if (pVideoParams->dwCommand == VP_COMMAND_GET) 
        {
            pVideoParams = (PVIDEOPARAMETERS) (RequestPacket->OutputBuffer);
            pVideoParams->dwFlags = 0;
        }

        RequestPacket->StatusBlock->Information = sizeof(VIDEOPARAMETERS);
        status = NO_ERROR;
        break;

    case IOCTL_VIDEO_QUERY_AVAIL_MODES:

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - QueryAvailableModes\n"));

        if (RequestPacket->OutputBufferLength <
               ( RequestPacket->StatusBlock->Information =
                 hwDeviceExtension->NumAvailableModes * 
                 sizeof(VIDEO_MODE_INFORMATION)) ) 
                 
        {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else 
        {

            modeInformation = RequestPacket->OutputBuffer;

            for (pFrequencyEntry = hwDeviceExtension->FrequencyTable;
                 pFrequencyEntry->BitsPerPel != 0;
                 pFrequencyEntry++) 
            {

                if (pFrequencyEntry->ModeValid) 
                {
                    *modeInformation =
                        pFrequencyEntry->ModeEntry->ModeInformation;

                    modeInformation->Frequency =
                        pFrequencyEntry->ScreenFrequency;

                    modeInformation->ModeIndex =
                        pFrequencyEntry->ModeIndex;

                    modeInformation++;
                }
            }

            status = NO_ERROR;
        }

        break;


     case IOCTL_VIDEO_QUERY_CURRENT_MODE:

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - QueryCurrentModes. current mode is %d\n",
                hwDeviceExtension->ActiveModeEntry->ModeInformation.ModeIndex));

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information =
            sizeof(VIDEO_MODE_INFORMATION)) ) 
        {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else 
        {

            *((PVIDEO_MODE_INFORMATION)RequestPacket->OutputBuffer) =
                    hwDeviceExtension->ActiveModeEntry->ModeInformation;

            ((PVIDEO_MODE_INFORMATION)RequestPacket->OutputBuffer)->Frequency =
                    hwDeviceExtension->ActiveFrequencyEntry.ScreenFrequency;

            status = NO_ERROR;

        }

        break;


    case IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES:

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - QueryNumAvailableModes (= %d)\n",
                     hwDeviceExtension->NumAvailableModes));

        //
        // Find out the size of the data to be put in the the buffer and
        // return that in the status information (whether or not the
        // information is there). If the buffer passed in is not large
        // enough return an appropriate error code.
        //

        if (RequestPacket->OutputBufferLength <
           (RequestPacket->StatusBlock->Information = sizeof(VIDEO_NUM_MODES))) 
        {

            status = ERROR_INSUFFICIENT_BUFFER;

        } else 
        {
            //
            // Configure the valid modes again. This allows non 3D accelerated
            // modes to be added dynamically. BUT, we cannot allow modes to be
            // dynamically removed. If we do we may have nowhere to go after
            // the Test screen (or if we logout). So only reconfigure these
            // modes if the ExportNon3D flag is turned on and it used to be
            // off. If it was already on then there's no need to reconfigure.
            //

            if (!hwDeviceExtension->ExportNon3DModes)
            {
                ULONG ExportNon3DModes = 0;

                status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                                        PERM2_EXPORT_HIRES_REG_STRING,
                                                        FALSE,
                                                        Permedia2RegistryCallback,
                                                        &ExportNon3DModes);

                if (( status == NO_ERROR) && ExportNon3DModes)
                {
                    ConstructValidModesList( HwDeviceExtension, 
                                             hwDeviceExtension );
                }

            }

            ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->NumModes =
                    hwDeviceExtension->NumAvailableModes;

            ((PVIDEO_NUM_MODES)RequestPacket->OutputBuffer)->ModeInformationLength =
                    sizeof(VIDEO_MODE_INFORMATION);

            status = NO_ERROR;
        }

        break;


    case IOCTL_VIDEO_SET_CURRENT_MODE:

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - SetCurrentMode\n"));

        if(!hwDeviceExtension->bVGAEnabled)
        {
            //
            // secondary card: if it's just returned from hibernation 
            // it won't be set-up yet 
            // NB. primary is OK, its BIOS has run
            //

            PCI_COMMON_CONFIG  PciData;

            VideoPortGetBusData(hwDeviceExtension, 
                                PCIConfiguration, 
                                0, 
                                &PciData, 
                                0, 
                                PCI_COMMON_HDR_LENGTH);

            if((PciData.Command & PCI_ENABLE_MEMORY_SPACE) == 0)
            {
                //
                // memory accesses not turned on - this card has just returned 
                // from hibernation and is back in its default state: set it 
                // up once more
                //

                PowerOnReset(hwDeviceExtension);

            }
        }

        //
        // Check if the size of the data in the input buffer is large enough.
        //

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_MODE)) 
        {
            RequestPacket->StatusBlock->Information = sizeof(VIDEO_MODE);
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        //
        // Find the correct entries in the P2_VIDEO_MODES and
        // P2_VIDEO_FREQUENCIES tables that correspond to this
        // mode number.
        //
        // ( Remember that each mode in the P2_VIDEO_MODES table 
        // can have a number of possible frequencies associated with it.)
        //

        RequestedMode = ((PVIDEO_MODE) RequestPacket->InputBuffer)->RequestedMode;

        modeNumber = RequestedMode & ~VIDEO_MODE_NO_ZERO_MEMORY;

        if ((modeNumber >= hwDeviceExtension->NumTotalModes) ||
            !(hwDeviceExtension->FrequencyTable[modeNumber].ModeValid)) 
        {
            RequestPacket->StatusBlock->Information = 
                     hwDeviceExtension->NumTotalModes;

            status = ERROR_INVALID_PARAMETER;
            break;
        }

        //
        // Re-sample the clock speed. This allows us to change the clock speed
        // on the fly using the display applet Test button.
        //

        Permedia2GetClockSpeeds(HwDeviceExtension);

        FrequencyEntry = hwDeviceExtension->FrequencyTable[modeNumber];
        ModeEntry = FrequencyEntry.ModeEntry;

        //
        // At this point, 'ModeEntry' and 'FrequencyEntry' point to the 
        // necessary table entries required for setting the requested mode.
        //
        // Zero the DAC and the Screen buffer memory.
        //

        ZeroMemAndDac(hwDeviceExtension, RequestedMode);

        ModeEntry->ModeInformation.DriverSpecificAttributeFlags = 
                   hwDeviceExtension->Capabilities;

        //
        // For low resolution modes we may have to do various tricks
        // such as line doubling and getting the RAMDAC to zoom.
        // Record any such zoom in the Mode DeviceAttributes field.
        // Primarily this is to allow the display driver to
        // compensate when asked to move the cursor or change its
        // shape.
        //
        // Currently, low res means lower than 512 pixels width.
        //

        if (FrequencyEntry.ScreenWidth < 512)
        {
            // Permedia does line doubling. If using a TVP we must
            // get it to zoom by 2 in X to get the pixel rate up.
            //
            ModeEntry->ModeInformation.DriverSpecificAttributeFlags |= CAPS_ZOOM_Y_BY2;

        }

        if (!InitializeVideo(HwDeviceExtension, &FrequencyEntry))
        {
            DEBUG_PRINT((1, "PERM2: InitializeVideo failed\n"));
            RequestPacket->StatusBlock->Information = modeNumber;
            status = ERROR_INVALID_PARAMETER;
            break;
        }

        //
        // Save the mode since we know the rest will work.
        //

        hwDeviceExtension->ActiveModeEntry = ModeEntry;
        hwDeviceExtension->ActiveFrequencyEntry = FrequencyEntry;

        //
        // Update VIDEO_MODE_INFORMATION fields
        //
        // Now that we've set the mode, we now know the screen stride, and
        // so can update some fields in the VIDEO_MODE_INFORMATION
        // structure for this mode.  The Permedia 2 display driver is expected 
        // to call IOCTL_VIDEO_QUERY_CURRENT_MODE to query these corrected
        // values.
        //
        //
        // Calculate the bitmap width (note the '+ 1' on BitsPerPlane is
        // so that '15bpp' works out right). 12bpp is special in that we
        // support it as sparse nibbles within a 32-bit pixel. ScreenStride
        // is in bytes; VideoMemoryBitmapWidth is measured in pixels;
        //

        if (ModeEntry->ModeInformation.BitsPerPlane != 12)
        {
            ModeEntry->ModeInformation.VideoMemoryBitmapWidth =
                   ModeEntry->ModeInformation.ScreenStride
                   / ((ModeEntry->ModeInformation.BitsPerPlane + 1) >> 3);
        }
        else 
        {
            ModeEntry->ModeInformation.VideoMemoryBitmapWidth =
                   ModeEntry->ModeInformation.ScreenStride >> 2;
        }

        //
        // Calculate the bitmap height. 
        //

        ulValue = hwDeviceExtension->AdapterMemorySize;
        ModeEntry->ModeInformation.VideoMemoryBitmapHeight =
                        ulValue / ModeEntry->ModeInformation.ScreenStride;

        status = NO_ERROR;

        break;

    case IOCTL_VIDEO_SET_COLOR_REGISTERS:

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - SetColorRegs\n"));

        clutBuffer = (PVIDEO_CLUT) RequestPacket->InputBuffer;

        status = Permedia2SetColorLookup(hwDeviceExtension,
                                         clutBuffer,
                                         RequestPacket->InputBufferLength,
                                         FALSE, // update when we need to
                                         TRUE); // Update cache entries as 
                                                // well as RAMDAC
        break;

    case IOCTL_VIDEO_RESET_DEVICE:

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - RESET_DEVICE\n"));

        if(hwDeviceExtension->bVGAEnabled)
        {
            //
            // Do any resets required before getting the BIOS to
            // do an INT 10
            //
            //
            // reset the VGA before rerouting the bypass to display VGA
            //
            // Only reset the device if the monitor is on.  If it is off,
            // then executing the int10 will turn it back on.
            //

            if (hwDeviceExtension->bMonitorPoweredOn) 
            {
                //
                // Do an Int10 to mode 3 will put the VGA to a known state.
                //

                VideoPortZeroMemory(&biosArguments, 
                                    sizeof(VIDEO_X86_BIOS_ARGUMENTS));

                biosArguments.Eax = 0x0003;

                VideoPortInt10(HwDeviceExtension, &biosArguments);
            }
        }

        status = NO_ERROR;
        break;

    case IOCTL_VIDEO_SHARE_VIDEO_MEMORY:
        {

        PVIDEO_SHARE_MEMORY pShareMemory;
        PVIDEO_SHARE_MEMORY_INFORMATION pShareMemoryInformation;
        PHYSICAL_ADDRESS shareAddress;
        PVOID virtualAddress;
        ULONG sharedViewSize;

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - ShareVideoMemory\n"));

        if( (RequestPacket->OutputBufferLength < sizeof(VIDEO_SHARE_MEMORY_INFORMATION)) ||
            (RequestPacket->InputBufferLength < sizeof(VIDEO_MEMORY)) ) 
        {
            DEBUG_PRINT((1, "PERM2: IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INSUFFICIENT_BUFFER\n"));
            status = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        pShareMemory = RequestPacket->InputBuffer;

        if( (pShareMemory->ViewOffset > hwDeviceExtension->AdapterMemorySize) ||
            ((pShareMemory->ViewOffset + pShareMemory->ViewSize) >
                  hwDeviceExtension->AdapterMemorySize) ) 
        {
            DEBUG_PRINT((1, "PERM2: IOCTL_VIDEO_SHARE_VIDEO_MEMORY - ERROR_INVALID_PARAMETER\n"));
            status = ERROR_INVALID_PARAMETER;
            break;
        }

        RequestPacket->StatusBlock->Information =
                                    sizeof(VIDEO_SHARE_MEMORY_INFORMATION);

        //
        // Beware: the input buffer and the output buffer are the same
        // buffer, and therefore data should not be copied from one to the
        // other
        //

        virtualAddress = pShareMemory->ProcessHandle;
        sharedViewSize = pShareMemory->ViewSize;

        inIoSpace = hwDeviceExtension->PhysicalFrameIoSpace;

        //
        // NOTE: we are ignoring ViewOffset
        //

        shareAddress.QuadPart =
                hwDeviceExtension->PhysicalFrameAddress.QuadPart;

        //
        // Unlike the MAP_MEMORY IOCTL, in this case we can not map extra
        // address space since the application could actually use the
        // pointer we return to it to touch locations in the address space
        // that do not have actual video memory in them.
        //
        // An app doing this would cause the machine to crash.
        //

        status = VideoPortMapMemory( hwDeviceExtension,
                                     shareAddress,
                                     &sharedViewSize,
                                     &inIoSpace,
                                     &virtualAddress );
 
        pShareMemoryInformation = RequestPacket->OutputBuffer;

        pShareMemoryInformation->SharedViewOffset = pShareMemory->ViewOffset;
        pShareMemoryInformation->VirtualAddress = virtualAddress;
        pShareMemoryInformation->SharedViewSize = sharedViewSize;

        }
        break;


    case IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY:
        {
        PVIDEO_SHARE_MEMORY pShareMemory;

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - UnshareVideoMemory\n"));

        if (RequestPacket->InputBufferLength < sizeof(VIDEO_SHARE_MEMORY)) 
        {
            status = ERROR_INSUFFICIENT_BUFFER;
            break;

        }

        pShareMemory = RequestPacket->InputBuffer;

        status = VideoPortUnmapMemory(hwDeviceExtension,
                                      pShareMemory->RequestedVirtualAddress,
                                      pShareMemory->ProcessHandle);
        }
        break;


    case IOCTL_VIDEO_QUERY_LINE_DMA_BUFFER:

        //
        // Return the line DMA buffer information. The buffer size and 
        // virtual address will be zero if the buffer couldn't be allocated.
        //
        // output buffer has zero length, so free buffer....
        //

        status = ERROR_INSUFFICIENT_BUFFER;

        if (RequestPacket->OutputBufferLength <
           (RequestPacket->StatusBlock->Information = sizeof(LINE_DMA_BUFFER)))
        {

            //
            // Maybe we should free something
            //

            if ( RequestPacket->InputBufferLength >= sizeof(LINE_DMA_BUFFER))
            {
                if (hwDeviceExtension->ulLineDMABufferUsage > 0)
                {
                    hwDeviceExtension->ulLineDMABufferUsage--;
                    if (hwDeviceExtension->ulLineDMABufferUsage == 0)
                    {
                        VideoPortFreeCommonBuffer(
                                hwDeviceExtension,
                                hwDeviceExtension->LineDMABuffer.size,
                                hwDeviceExtension->LineDMABuffer.virtAddr,
                                hwDeviceExtension->LineDMABuffer.physAddr,
                                hwDeviceExtension->LineDMABuffer.cacheEnabled);

                        memset(&hwDeviceExtension->LineDMABuffer,
                               0,
                               sizeof(LINE_DMA_BUFFER));
                    }
                }
                  status = NO_ERROR;
             } 
        }
        else
        {
            PLINE_DMA_BUFFER pDMAIn, pDMAOut;

            pDMAIn  = (PLINE_DMA_BUFFER)RequestPacket->InputBuffer;
            pDMAOut = (PLINE_DMA_BUFFER)RequestPacket->OutputBuffer;

            if (RequestPacket->InputBufferLength >= sizeof(LINE_DMA_BUFFER))
            {
                if (hwDeviceExtension->ulLineDMABufferUsage == 0)
                {
                    *pDMAOut = *pDMAIn;

                    if( ( pDMAOut->virtAddr = 
                          VideoPortGetCommonBuffer( hwDeviceExtension,
                                                    pDMAIn->size,
                                                    PAGE_SIZE,
                                                    &pDMAOut->physAddr,
                                                    &pDMAOut->size,
                                                    pDMAIn->cacheEnabled ) )
                           != NULL )
                    {
                        hwDeviceExtension->LineDMABuffer=*pDMAOut;
                        hwDeviceExtension->ulLineDMABufferUsage++;
                    }

                } else
                {
                    *pDMAOut = hwDeviceExtension->LineDMABuffer;
                    hwDeviceExtension->ulLineDMABufferUsage++;
                }
                
                status = NO_ERROR;
            } 
        }

        DEBUG_PRINT((1, "PERM2: QUERY LINE DMA BUFFER status %d\n", status));
        break;

    case IOCTL_VIDEO_QUERY_EMULATED_DMA_BUFFER:

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - QUERY EMULATED DMA BUFFER\n"));

        //
        // Allocate/free the emulated DMA buffer. The buffer size and 
        // virtual address will be zero if the buffer couldn't be allocated.
        //
        // output buffer has zero length, so free buffer....
        //

        status = ERROR_INSUFFICIENT_BUFFER;

        if (RequestPacket->InputBufferLength >= sizeof(EMULATED_DMA_BUFFER))
        {
            PEMULATED_DMA_BUFFER pDMAIn, pDMAOut;

            pDMAIn  = (PEMULATED_DMA_BUFFER)RequestPacket->InputBuffer;

            if (RequestPacket->OutputBufferLength <
                (RequestPacket->StatusBlock->Information = sizeof(EMULATED_DMA_BUFFER)))
            {
                VideoPortFreePool(hwDeviceExtension, pDMAIn->virtAddr);
                status = NO_ERROR;
            }
            else
            {
                pDMAOut = (PEMULATED_DMA_BUFFER)RequestPacket->OutputBuffer;

                if ( ( pDMAOut->virtAddr = 
                          VideoPortAllocatePool( hwDeviceExtension,
                                                 VpPagedPool,
                                                 pDMAIn->size,
                                                 pDMAIn->tag ) )
                           != NULL )
                {
                    pDMAOut->size = pDMAIn->size;
                    pDMAOut->tag = pDMAIn->tag;
                }
                
                status = NO_ERROR;
            } 
        }

        DEBUG_PRINT((1, "PERM2: QUERY EMULATED DMA BUFFER status %d\n", status));
        break;

    case IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF:

        DEBUG_PRINT((1, "PERM2: Permedia2StartIO - MapInterruptCmdBuf\n"));

        if (RequestPacket->OutputBufferLength <
            (RequestPacket->StatusBlock->Information =
            sizeof(PVOID)) )
        {
            //
            // They've give us a duff buffer.
            //

            status = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            *((PVOID*)(RequestPacket->OutputBuffer)) = 
                    hwDeviceExtension->InterruptControl.ControlBlock;
            status = NO_ERROR;
        }

        DEBUG_PRINT((1, "PERM2: MapInterruptCmdBuf returns va %x\n",
                        *(PULONG)(RequestPacket->OutputBuffer)));
        break;


#if defined(_X86_)

        case IOCTL_VIDEO_QUERY_INTERLOCKEDEXCHANGE:

            status = ERROR_INSUFFICIENT_BUFFER;

            if ( RequestPacket->OutputBufferLength >=
                 (RequestPacket->StatusBlock->Information = sizeof(PVOID)) )
            {
                PVOID *pIE = (PVOID)RequestPacket->OutputBuffer;
                *pIE       = (PVOID) VideoPortInterlockedExchange;
                status     = NO_ERROR;
            }

         break;
#endif


    case IOCTL_VIDEO_STALL_EXECUTION:
        if (RequestPacket->InputBufferLength >= sizeof(ULONG))
        {   
            ULONG *pMicroseconds = (ULONG *)RequestPacket->InputBuffer;
            VideoPortStallExecution(*pMicroseconds);
            status = NO_ERROR;    
        } else
        {
            status = ERROR_INSUFFICIENT_BUFFER;
        }
        
        break;

    //
    // if we get here, an invalid IoControlCode was specified.
    //

    default:

        DEBUG_PRINT((1, "Fell through Permedia2 startIO routine - invalid command\n"));

        status = ERROR_INVALID_FUNCTION;

        break;

    }


    RequestPacket->StatusBlock->Status = status;

    if( status != NO_ERROR )
        RequestPacket->StatusBlock->Information = 0;

    return TRUE;

} // end Permedia2StartIO()


BOOLEAN
Permedia2ResetHW(
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    )

/*++

Routine Description:

    This routine resets the hardware when a soft reboot is performed. We
    need this to reset the VGA pass through.

    THIS FUNCTION CANNOT BE PAGED.

Arguments:

    hwDeviceExtension - Pointer to the miniport driver's device extension.

    Columns - Specifies the number of columns of the mode to be set up.

    Rows - Specifies the number of rows of the mode to be set up.

Return Value:

    We always return FALSE to force the HAL to do an INT10 reset.

--*/

{

    //
    // return false so the HAL does an INT10 mode 3
    //

    return(FALSE);
}


VP_STATUS
Permedia2SetColorLookup(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize,
    BOOLEAN ForceRAMDACWrite,
    BOOLEAN UpdateCache
    )

/*++

Routine Description:

    This routine sets a specified portion of the color lookup table settings.

Arguments:

    hwDeviceExtension - Pointer to the miniport driver's device extension.

    ClutBufferSize - Length of the input buffer supplied by the user.

    ClutBuffer - Pointer to the structure containing the color lookup table.

Return Value:

    None.

--*/

{
    USHORT i, j;
    TVP4020_DECL;
    P2RD_DECL;
    PVIDEO_CLUT LUTCachePtr = &(hwDeviceExtension->LUTCache.LUTCache);
    P2_DECL;
    ULONG VsEnd;

    //
    // Check if the size of the data in the input buffer is large enough.
    //

    if ( (ClutBufferSize < (sizeof(VIDEO_CLUT) - sizeof(ULONG))) ||
         (ClutBufferSize < (sizeof(VIDEO_CLUT) +
         (sizeof(ULONG) * (ClutBuffer->NumEntries - 1))) ) )
    {

        DEBUG_PRINT((1, "PERM2: Permedia2SetColorLookup: insufficient buffer (was %d, min %d)\n",
                    ClutBufferSize,
                    (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * (ClutBuffer->NumEntries - 1)))));

        return ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // Check to see if the parameters are valid.
    //

    if ( (ClutBuffer->NumEntries == 0) ||
         (ClutBuffer->FirstEntry > VIDEO_MAX_COLOR_REGISTER) ||
         (ClutBuffer->FirstEntry + ClutBuffer->NumEntries >
          VIDEO_MAX_COLOR_REGISTER + 1) )
    {
        DEBUG_PRINT((1, "Permedia2SetColorLookup: invalid parameter\n"));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Set CLUT registers directly on the hardware.
    //

    switch (hwDeviceExtension->DacId)
    {
        case TVP4020_RAMDAC:
        case P2RD_RAMDAC:
            break;

        default:
            return (ERROR_DEV_NOT_EXIST);
    }

    if (hwDeviceExtension->bVTGRunning && 
        hwDeviceExtension->bMonitorPoweredOn)
    {
        // 
        // if VTG has been set-up, we wait for VSync before updating
        // the palette entries (just to avoid possible flickers)
        //

        VsEnd = VideoPortReadRegisterUlong(VS_END);
        while ( VideoPortReadRegisterUlong(LINE_COUNT) > VsEnd ); 
    }

    //
    // RAMDAC Programming phase
    //

    for ( i = 0, j = ClutBuffer->FirstEntry; 
          i < ClutBuffer->NumEntries; 
          i++, j++ )
    {

        //
        // Update the RAMDAC entry if it has changed or if we have 
        // been told to overwrite it.
        //

        if ( ForceRAMDACWrite ||
            ( LUTCachePtr->LookupTable[j].RgbLong != 
              ClutBuffer->LookupTable[i].RgbLong ) )
        {
            switch (hwDeviceExtension->DacId)
            {
                case TVP4020_RAMDAC:
                    TVP4020_LOAD_PALETTE_INDEX (
                         j,
                         ClutBuffer->LookupTable[i].RgbArray.Red,
                         ClutBuffer->LookupTable[i].RgbArray.Green,
                         ClutBuffer->LookupTable[i].RgbArray.Blue);
                break;

                case P2RD_RAMDAC:
                    P2RD_LOAD_PALETTE_INDEX (
                         j,
                         ClutBuffer->LookupTable[i].RgbArray.Red,
                         ClutBuffer->LookupTable[i].RgbArray.Green,
                         ClutBuffer->LookupTable[i].RgbArray.Blue);
                break;
            }

        }


        //
        // Update the cache, if instructed to do so
        //

        if (UpdateCache)
        {
            LUTCachePtr->LookupTable[j].RgbLong = ClutBuffer->LookupTable[i].RgbLong;
        }
    }

    return NO_ERROR;

} // end Permedia2SetColorLookup()



VOID
Permedia2GetClockSpeeds(
    PVOID HwDeviceExtension
    )

/*++

Routine Description:

    Work out the chip clock speed and save in hwDeviceExtension.

Arguments:

    hwDeviceExtension - Supplies a pointer to the miniport's device extension.

Return Value:

    On return the following values will be in hwDeviceExtension:

       - ChipClockSpeed: this is the desired speed for the chip
       - RefClockSpeed:  this is the speed of the oscillator input on the board

Note:

    We use ChipClockSpeed to refer to the speed of the chip. RefClockSpeed 
    is the reference clock speed. 
    
--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ulValue, ulChipClk, ulRefClk;
    VP_STATUS status;
    P2_DECL;

    //
    // inherit the values from board zero or default
    //

    ulChipClk = hwDeviceExtension->ChipClockSpeed;
    ulRefClk  = REF_CLOCK_SPEED;

    //
    // Use the Registry specified clock-speed if supplied
    //

    status = VideoPortGetRegistryParameters( HwDeviceExtension,
                                             L"PermediaClockSpeed",
                                             FALSE,
                                             Permedia2RegistryCallback,
                                             &ulChipClk);

    if ( (status != NO_ERROR) || ulChipClk == 0)
    {

        //
        // The Registry does not specify an override so read the chip clock 
        // speed (in MHz) from the Video ROM BIOS (offset 0xA in the BIOS) 
        // NB. this involves changing the aperture 2 register so aperture 
        //     better be completely idle or we could be in trouble; fortunately 
        //     we only call this function during a mode change and expect 
        //     aperture 2 (the FrameBuffer) to be idle
        //

        ULONG Default = VideoPortReadRegisterUlong(APERTURE_TWO);
        UCHAR *p = (UCHAR *)hwDeviceExtension->pFramebuffer;

        //
        // r/w via aperture 2 actually go to ROM
        //

        VideoPortWriteRegisterUlong(APERTURE_TWO, Default | 0x200); 

        //
        // If we have a valid ROM then read the clock speed
        //

        if (VideoPortReadRegisterUshort ((USHORT *) p) == 0xAA55)
        {
            //
            // Get the clock speed, on some boards (eg Creative), the clock 
            // value at 0x0A is sometimes remains undefined leading to 
            // unpredictable results. The values are validated before this 
            // function returns
            //

            ulChipClk = VideoPortReadRegisterUchar(&(p[0xA]));
    
            DEBUG_PRINT((1, "ROM clk speed value 0x%x\n Mhz", ulChipClk));

        }
        else
        {
            DEBUG_PRINT((1, "Bad BIOS ROM header 0x%x\n", 
                        (ULONG) VideoPortReadRegisterUshort ((USHORT *) p)));         
        
        }

        VideoPortWriteRegisterUlong(APERTURE_TWO, Default);
    }

    //
    // Convert to Hz
    //

    ulChipClk *= 1000000;  

    //
    // Validate the selected clock speed, adjust if it is either too 
    // high or too low.
    //

    if (ulChipClk < MIN_PERMEDIA_CLOCK_SPEED)
    {
        if(ulChipClk == 0x00)
        {
            ulChipClk = PERMEDIA2_DEFAULT_CLOCK_SPEED;
        }
        else
        {
            ulChipClk = MIN_PERMEDIA_CLOCK_SPEED;
        }
    } 
    
    if (ulChipClk > MAX_PERMEDIA_CLOCK_SPEED)
    {
        DEBUG_PRINT((1, "PERM2: Permedia clock speed %d too fast. Limiting to %d\n" ,
                         ulChipClk, MAX_PERMEDIA_CLOCK_SPEED));

        ulChipClk= PERMEDIA2_DEFAULT_CLOCK_SPEED;
 
    }

    DEBUG_PRINT((3, "PERM2: Permedia Clock Speed set to %dHz\n", ulChipClk));

    hwDeviceExtension->ChipClockSpeed = ulChipClk;
    hwDeviceExtension->RefClockSpeed = ulRefClk;
}


VOID
ZeroMemAndDac(
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    ULONG RequestedMode
    )

/*++

Routine Description:

    Initialize the DAC to 0 (black).

Arguments:

    hwDeviceExtension - Supplies a pointer to the miniport's device extension.

    RequestedMode - use the VIDEO_MODE_NO_ZERO_MEMORY bit to determine if the
                    framebuffer should be cleared

Return Value:

    None

--*/

{
    ULONG  i;
    P2_DECL;
    TVP4020_DECL;
    P2RD_DECL;

    //
    // Turn off the screen at the DAC.
    //

    if (hwDeviceExtension->DacId == TVP4020_RAMDAC)
    {
        TVP4020_SET_PIXEL_READMASK (0x0);
        TVP4020_PALETTE_START_WR (0);

        for (i = 0; i <= VIDEO_MAX_COLOR_REGISTER; i++)
        {
            TVP4020_LOAD_PALETTE (0, 0, 0);
        }
    }
    else
    {
        P2RD_SET_PIXEL_READMASK (0x0);
        P2RD_PALETTE_START_WR(0);       

        for (i = 0; i <= VIDEO_MAX_COLOR_REGISTER; i++)
        {
            P2RD_LOAD_PALETTE (0, 0, 0);
        }
    }

    if (!(RequestedMode & VIDEO_MODE_NO_ZERO_MEMORY))
    {
        //
        // Zero the memory. Don't use Permedia 2 as we would have to save and 
        // restore state and that's a pain. This is not time critical.
        //

        VideoPortZeroDeviceMemory(hwDeviceExtension->pFramebuffer,
                                  hwDeviceExtension->FrameLength);

        DEBUG_PRINT((1, "PERM2: framebuffer cleared\n"));
    }

    //
    // Turn on the screen at the DAC
    //

    if (hwDeviceExtension->DacId == TVP4020_RAMDAC) 
    {
        TVP4020_SET_PIXEL_READMASK (0xff);
    }
    else
    {
        P2RD_SET_PIXEL_READMASK (0xff);
    }

    LUT_CACHE_INIT();

    return;
}



#if DBG

VOID
DumpPCIConfigSpace(
    PVOID HwDeviceExtension, 
    ULONG bus, 
    ULONG slot)
{

    PPCI_COMMON_CONFIG  PciData;
    UCHAR buffer[sizeof(PCI_COMMON_CONFIG)];
    ULONG j;

    PciData = (PPCI_COMMON_CONFIG)buffer;

    j = VideoPortGetBusData( HwDeviceExtension,
                             PCIConfiguration,
                             slot,
                             PciData,
                             0,
                             PCI_COMMON_HDR_LENGTH + 4 );

    //
    // don't report junk slots
    //

    if (PciData->VendorID == 0xffff)
        return;

    DEBUG_PRINT((2, "PERM2: DumpPCIConfigSpace: VideoPortGetBusData returned %d PCI_COMMON_HDR_LENGTH = %d\n",
                     j, PCI_COMMON_HDR_LENGTH+4));

    DEBUG_PRINT((2,  "DumpPCIConfigSpace: ------------------------\n"));
    DEBUG_PRINT((2,  "  Bus: %d\n",              bus  ));
    DEBUG_PRINT((2,  "  Slot: %d\n",             slot  ));
    DEBUG_PRINT((2,  "  Vendor Id: 0x%x\n",      PciData->VendorID  ));
    DEBUG_PRINT((2,  "  Device Id: 0x%x\n",      PciData->DeviceID  ));
    DEBUG_PRINT((2,  "  Command: 0x%x\n",        PciData->Command  ));
    DEBUG_PRINT((2,  "  Status: 0x%x\n",         PciData->Status  ));
    DEBUG_PRINT((2,  "  Rev Id: 0x%x\n",         PciData->RevisionID  ));
    DEBUG_PRINT((2,  "  ProgIf: 0x%x\n",         PciData->ProgIf  ));
    DEBUG_PRINT((2,  "  SubClass: 0x%x\n",       PciData->SubClass  ));
    DEBUG_PRINT((2,  "  BaseClass: 0x%x\n",      PciData->BaseClass  ));
    DEBUG_PRINT((2,  "  CacheLine: 0x%x\n",      PciData->CacheLineSize  ));
    DEBUG_PRINT((2,  "  Latency: 0x%x\n",        PciData->LatencyTimer  ));
    DEBUG_PRINT((2,  "  Header Type: 0x%x\n",    PciData->HeaderType  ));
    DEBUG_PRINT((2,  "  BIST: 0x%x\n",           PciData->BIST  ));
    DEBUG_PRINT((2,  "  Base Reg[0]: 0x%x\n",    PciData->u.type0.BaseAddresses[0]  ));
    DEBUG_PRINT((2,  "  Base Reg[1]: 0x%x\n",    PciData->u.type0.BaseAddresses[1]  ));
    DEBUG_PRINT((2,  "  Base Reg[2]: 0x%x\n",    PciData->u.type0.BaseAddresses[2]  ));
    DEBUG_PRINT((2,  "  Base Reg[3]: 0x%x\n",    PciData->u.type0.BaseAddresses[3]  ));
    DEBUG_PRINT((2,  "  Base Reg[4]: 0x%x\n",    PciData->u.type0.BaseAddresses[4]  ));
    DEBUG_PRINT((2,  "  Base Reg[5]: 0x%x\n",    PciData->u.type0.BaseAddresses[5]  ));
    DEBUG_PRINT((2,  "  Rom Base: 0x%x\n",       PciData->u.type0.ROMBaseAddress  ));
    DEBUG_PRINT((2,  "  Interrupt Line: 0x%x\n", PciData->u.type0.InterruptLine  ));
    DEBUG_PRINT((2,  "  Interrupt Pin: 0x%x\n",  PciData->u.type0.InterruptPin  ));
    DEBUG_PRINT((2,  "  Min Grant: 0x%x\n",      PciData->u.type0.MinimumGrant  ));
    DEBUG_PRINT((2,  "  Max Latency: 0x%x\n",    PciData->u.type0.MaximumLatency ));

    DEBUG_PRINT((2,  "  AGP Capability: 0x%x\n", buffer[0x40]));
    DEBUG_PRINT((2,  "  AGP Next Cap:   0x%x\n", buffer[0x41]));
    DEBUG_PRINT((2,  "  AGP Revision:   0x%x\n", buffer[0x42]));
    DEBUG_PRINT((2,  "  AGP Status:     0x%x\n", buffer[0x43]));

}

#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\mini\pciprobe.c ===
//***************************************************************************
//
//  Module Name:
//
//    pciprobe.c
//
//  Abstract:
//
//    Probe PCI and get access range
//
//  Environment:
//
//    Kernel mode
//
//
// Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.            
// Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//***************************************************************************

#include "permedia.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, Permedia2AssignResources)
#pragma alloc_text(PAGE, Permedia2AssignResourcesNT4)
#endif

#define CreativeSubVendorID   0x1102
#define PiccasoSubVendorID    0x148C
#define PiccasoSubSystemID    0x0100
#define SynergyA8SubVendorID  0x1048
#define SynergyA8SubSystemID  0x0A32

BOOLEAN
Permedia2AssignResources(
    PVOID HwDeviceExtension,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    ULONG NumRegions,
    PVIDEO_ACCESS_RANGE AccessRange
    )

/*++

Routine Description:

// 
// Look for a Permedia2 adapter and return the address regions for 
// that adapter. 
//

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PCI_COMMON_CONFIG    PCIFunctionConfig;
    PPCI_COMMON_CONFIG   PciData = &PCIFunctionConfig;
    BOOLEAN              bRet;
    USHORT               VendorID;
    USHORT               DeviceID;
    VP_STATUS            status;
    ULONG                i;
    ULONG                VgaStatus;

    // 
    // assume we fail to catch all errors.
    // 

    bRet = FALSE;

#if DBG

    DEBUG_PRINT((2, "Permedia2AssignResources: read PCI config space (bus %d):-\n",
                (int)ConfigInfo->SystemIoBusNumber));
    DumpPCIConfigSpace(HwDeviceExtension, ConfigInfo->SystemIoBusNumber, 0);

#endif

    VideoPortGetBusData( HwDeviceExtension,
                         PCIConfiguration,
                         0,
                         PciData,
                         0,
                         PCI_COMMON_HDR_LENGTH ); 

    hwDeviceExtension->bDMAEnabled = PciData->Command & PCI_ENABLE_BUS_MASTER;

    if (!hwDeviceExtension->bDMAEnabled) 
    {
        DEBUG_PRINT((1, "PERM2: enabling DMA for VGA card\n"));

        PciData->Command |= PCI_ENABLE_BUS_MASTER;

        VideoPortSetBusData( HwDeviceExtension,
                             PCIConfiguration,
                             0,
                             PciData,
                             0,
                             PCI_COMMON_HDR_LENGTH ); 
    }

    VendorID = PciData->VendorID;
    DeviceID = PciData->DeviceID;

    hwDeviceExtension->deviceInfo.VendorId   = VendorID;
    hwDeviceExtension->deviceInfo.DeviceId   = DeviceID; 
    hwDeviceExtension->deviceInfo.RevisionId = PciData->RevisionID;

    hwDeviceExtension->deviceInfo.SubsystemVendorId = 
            PciData->u.type0.SubVendorID;

    hwDeviceExtension->deviceInfo.SubsystemId = 
            PciData->u.type0.SubSystemID;

    if( ( PciData->u.type0.SubVendorID == PiccasoSubVendorID ) &&
        ( PciData->u.type0.SubSystemID == PiccasoSubSystemID ) )
    {
       return(FALSE);
    } 

    if( ( PciData->u.type0.SubVendorID == SynergyA8SubVendorID ) &&
        ( PciData->u.type0.SubSystemID == SynergyA8SubSystemID ) )
    {
       return(FALSE);
    } 

    //
    // check if SubSystemID/SubVendorID bits are read only
    // 

    if( PciData->u.type0.SubVendorID == CreativeSubVendorID )
    {
        hwDeviceExtension->HardwiredSubSystemId = FALSE;
    } 
    else
    {
        hwDeviceExtension->HardwiredSubSystemId = TRUE;
    }


    hwDeviceExtension->pciBus = ConfigInfo->SystemIoBusNumber;

    hwDeviceExtension->deviceInfo.DeltaRevId = 0;

    // 
    // in multi-adapter systems we need to check if the VGA on this device 
    // is active
    // 

    VideoPortGetVgaStatus( HwDeviceExtension, &VgaStatus );

    hwDeviceExtension->bVGAEnabled = 
                      (VgaStatus & DEVICE_VGA_ENABLED) ? TRUE : FALSE;

    if(!hwDeviceExtension->bVGAEnabled)
    {

        // 
        // in a multi-adapter system we'll need to turn on the memory 
        // space for the secondary adapters
        // 

        DEBUG_PRINT((1, "PERM2: enabling memory space access for the secondary card\n"));

        PciData->Command |= PCI_ENABLE_MEMORY_SPACE;

        VideoPortSetBusData( HwDeviceExtension, 
                             PCIConfiguration, 
                             0, 
                             PciData, 
                             0, 
                             PCI_COMMON_HDR_LENGTH );
    }

    hwDeviceExtension->PciSpeed = 
                     (PciData->Status & PCI_STATUS_66MHZ_CAPABLE) ? 66 : 33;

    DEBUG_PRINT((2, "VGAEnabled = %d. Pci Speed = %d\n",
                     hwDeviceExtension->bVGAEnabled, 
                     hwDeviceExtension->PciSpeed));

    VideoPortZeroMemory((PVOID)AccessRange, 
                         NumRegions * sizeof(VIDEO_ACCESS_RANGE));

    // 
    // these should be zero but just in case
    // 

    ConfigInfo->BusInterruptLevel  = 0;
    ConfigInfo->BusInterruptVector = 0;

    i = 0;
    status = VideoPortGetAccessRanges(HwDeviceExtension,
                                      0,
                                      NULL,
                                      NumRegions,
                                      AccessRange,
                                      &VendorID,
                                      &DeviceID,
                                      &i);
    if (status == NO_ERROR)
    {
        DEBUG_PRINT((2, "VideoPortGetAccessRanges succeeded\n"));
    }
    else
    {
        DEBUG_PRINT((2, "VideoPortGetAccessRanges failed. error 0x%x\n", status));
        goto ReturnValue;
    }

    // 
    // get an updated copy of the config space
    // 

    VideoPortGetBusData(HwDeviceExtension,
                        PCIConfiguration,
                        0,
                        PciData,
                        0,
                        PCI_COMMON_HDR_LENGTH);

#if DBG

    DEBUG_PRINT((2, "Final set of base addresses\n"));
 
    for (i = 0; i < NumRegions; ++i)
    {
        if (AccessRange[i].RangeLength == 0)
            break;

        DEBUG_PRINT((2, "%d: Addr 0x%x.0x%08x, Length 0x%08x, InIo %d, visible %d, share %d\n", i,
                     AccessRange[i].RangeStart.HighPart,
                     AccessRange[i].RangeStart.LowPart,
                     AccessRange[i].RangeLength,
                     AccessRange[i].RangeInIoSpace,
                     AccessRange[i].RangeVisible,
                     AccessRange[i].RangeShareable));
    }

#endif

    // 
    // try to enable for DMA transfers
    // 

    ConfigInfo->Master=1;
    bRet = TRUE;

ReturnValue:

    return(bRet);
}

BOOLEAN
Permedia2AssignResourcesNT4(
    PVOID HwDeviceExtension,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    ULONG NumRegions,
    PVIDEO_ACCESS_RANGE AccessRange
    )

/*++

Routine Description:

// 
// Look for a Permedia2 adapter and return the address regions for 
// that adapter. 
//

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    BOOLEAN              bRet;
    USHORT               VendorID, DeviceID;
    USHORT               *pVenID, *pDevID;
    VP_STATUS            status;
    ULONG                i;

    USHORT VenID[] = { VENDOR_ID_3DLABS, 
                       VENDOR_ID_TI,
                       0 };
                
    USHORT DevID[] = { PERMEDIA2_ID, 
                       PERMEDIA_P2_ID, 
                       PERMEDIA_P2S_ID, 
                       0 };

    if( hwDeviceExtension->NtVersion != NT4)
    {

        DEBUG_PRINT((0, "Permedia2AssignResourcesNT4: This function can only be called on NT 4\n"));
        return (FALSE);
    
    }
    else
    {

        bRet = FALSE;

        // 
        // Since we do not support multi-mon on NT 4, we
        // assume this is the only video card in the system.
        //

        hwDeviceExtension->bVGAEnabled = 1;
 
        VideoPortZeroMemory((PVOID)AccessRange, 
                             NumRegions * sizeof(VIDEO_ACCESS_RANGE));

        for( pVenID = &(VenID[0]); *pVenID != 0; pVenID++)
        {
             for( pDevID = &(DevID[0]); *pDevID != 0; pDevID++)
             {   

                 i = 0;

                 status = VideoPortGetAccessRanges(HwDeviceExtension,
                                                   0,
                                                   NULL,
                                                   NumRegions,
                                                   (PVIDEO_ACCESS_RANGE) AccessRange,
                                                   pVenID,
                                                   pDevID,
                                                   &i);

                 if (status == NO_ERROR)
                 {

                     DEBUG_PRINT((2, "VideoPortGetAccessRanges succeeded\n"));

                     bRet = TRUE;

                     return(bRet);
                 }
            }
        }

        return(bRet);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\mini\tvp4020.h ===
//***************************************************************************
//
// Module Name:
// 
//     TVP4020.h
// 
// Abstract:
// 
//     This module contains the definitions for the P2 internal RAMDAC.
// 
// Environment:
// 
//     Kernel mode
//
//
// Copyright (c) 1995  AccelGraphics, Inc.
//
//***************************************************************************

//
// TI TVP4020 RAMDAC definitions
// This set of registers resides at &(pCtrlRegs->ExternalVideo)
//

typedef struct _tvp4020_regs {
    RAMDAC_REG  pciAddrWr;      // 0x00 - palette/cursor RAM write address, Index Register
    RAMDAC_REG  palData;        // 0x01 - palette RAM data
    RAMDAC_REG  pixelMask;      // 0x02 - pixel read mask
    RAMDAC_REG  pciAddrRd;         // 0x03 - palette/cursor RAM read address
    
    RAMDAC_REG  curColAddr;     // 0x04 - cursor color address
    RAMDAC_REG  curColData;     // 0x05 - cursor color data
    RAMDAC_REG  Reserved1;      // 0x06 - reserved
    RAMDAC_REG  Reserved2;      // 0x07 - reserved

    RAMDAC_REG  Reserved3;      // 0x08 - reserved
    RAMDAC_REG  Reserved4;      // 0x09 - reserved
    RAMDAC_REG  indexData;      // 0x0A - indexed data
    RAMDAC_REG  curRAMData;     // 0x0B - cursor RAM data
    
    RAMDAC_REG  cursorXLow;     // 0x0C - cursor position X low byte 
    RAMDAC_REG  cursorXHigh;    // 0x0D - cursor position X high byte 
    RAMDAC_REG  cursorYLow;     // 0x0E - cursor position Y low byte 
    RAMDAC_REG  cursorYHigh;    // 0x0F - cursor position Y high byte 
} TVP4020RAMDAC, *pTVP4020RAMDAC;

//
// macro declared by any function wishing to use the P2 internal RAMDAC . MUST be declared
// after P2_DECL.
//

#define TVP4020_DECL \
    pTVP4020RAMDAC   pTVP4020Regs = (pTVP4020RAMDAC)(hwDeviceExtension->pRamdac)

//
// use the following macros as the address to pass to the
// VideoPortWriteRegisterUlong function
//
//  Palette Access

#define __TVP4020_PAL_WR_ADDR       ((PULONG)&(pTVP4020Regs->pciAddrWr.reg))
#define __TVP4020_PAL_RD_ADDR       ((PULONG)&(pTVP4020Regs->pciAddrRd.reg))
#define __TVP4020_PAL_DATA          ((PULONG)&(pTVP4020Regs->palData.reg))

//
// Pixel mask
//

#define __TVP4020_PIXEL_MASK        ((PULONG)&(pTVP4020Regs->pixelMask.reg))

//
// Access to the indexed registers
//

#define __TVP4020_INDEX_ADDR        ((PULONG)&(pTVP4020Regs->pciAddrWr.reg))
#define __TVP4020_INDEX_DATA        ((PULONG)&(pTVP4020Regs->indexData.reg))

//
// Access to the Cursor
//

#define __TVP4020_CUR_RAM_WR_ADDR   ((PULONG)&(pTVP4020Regs->pciAddrWr.reg))
#define __TVP4020_CUR_RAM_RD_ADDR   ((PULONG)&(pTVP4020Regs->palAddrRd.reg))
#define __TVP4020_CUR_RAM_DATA      ((PULONG)&(pTVP4020Regs->curRAMData.reg))

#define __TVP4020_CUR_COL_ADDR      ((PULONG)&(pTVP4020Regs->curColAddr.reg))
#define __TVP4020_CUR_COL_DATA      ((PULONG)&(pTVP4020Regs->curColData.reg))

//
// Cursor position control
//

#define __TVP4020_CURSOR_X_LSB      ((PULONG)&(pTVP4020Regs->cursorXLow.reg))
#define __TVP4020_CURSOR_X_MSB      ((PULONG)&(pTVP4020Regs->cursorXHigh.reg))
#define __TVP4020_CURSOR_Y_LSB      ((PULONG)&(pTVP4020Regs->cursorYLow.reg))
#define __TVP4020_CURSOR_Y_MSB      ((PULONG)&(pTVP4020Regs->cursorYHigh.reg))



// ----------------------Values for some direct registers-----------------------

/********************************************************************************/
/*                DIRECT REGISTER - CURSOR POSITION CONTROL                        */
/********************************************************************************/
//
//  ** TVP4020_CUR_X_LSB 
//  ** TVP4020_CUR_X_MSB 
//  ** TVP4020_CUR_Y_LSB 
//  ** TVP4020_CUR_Y_MSB 
//        Default - undefined
// Values written into those registers represent the BOTTOM-RIGHT corner
// of the cursor. If 0 is in X or Y position - the cursor is off the screen
// Only 12 bits are used, giving the range from 0 to 4095 ( 0x0000 - 0x0FFF)
// The size of the cursor is (64,64) (0x40, 0x40)
//

#define TVP4020_CURSOR_OFFSCREEN                0x00    // Cursor offscreen

/********************************************************************************/
/*                DIRECT REGISTER - CURSOR COLORS                                 */
/********************************************************************************/

#define TVP4020_CURSOR_COLOR0                   0x01
#define TVP4020_CURSOR_COLOR1                   0x02
#define TVP4020_CURSOR_COLOR2                   0x03

/********************************************************************************/
/*                INDIRECT REGISTER - CURSOR CONTROL                                */
/********************************************************************************/
#define __TVP4020_CURSOR_CONTROL                0x06    // Indirect cursor control - 

//        Default - 0x00

#define TVP4020_CURSOR_SIZE_32                  (0 << 6)// 32x32 cursor
#define TVP4020_CURSOR_SIZE_64                  (1 << 6)// 32x32 cursor

#define TVP4020_CURSOR_32_SEL(i)   ((i) << 4)// one of 4 32x32 cursors  DABO: changed to << 4

#define TVP4020_CURSOR_RAM_ADDRESS(x)    (((x) & 0x03) << 2)// High bits of cursor RAM address
#define TVP4020_CURSOR_RAM_MASK          ((0x03) << 2)       // Mask for high bits of cursor RAM address

// DABO: Added constants for cursor mode
#define TVP4020_CURSOR_OFF               0x00    // Cursor off
#define TVP4020_CURSOR_COLOR             0x01    // 2-bits select color
#define TVP4020_CURSOR_XGA               0x02    // 2-bits select XOR
#define TVP4020_CURSOR_XWIN              0x03    // 2-bits select transparency/color



/********************************************************************************/
/*                INDIRECT REGISTER - COLOR MODE REGISTER                            */
/********************************************************************************/
#define __TVP4020_COLOR_MODE                    0x18    //  Color Mode Register
//        Default - 0x00

#define TVP4020_TRUE_COLOR_ENABLE               (1 << 7)// True Color data accesses LUT
#define TVP4020_TRUE_COLOR_DISABLE              (0 << 7)// Non true color accesses LUT

#define TVP4020_RGB_MODE                        (1 << 5)// RGB mode  DABO: Swapped 0/1 (0=BGR, 1=RGB)
#define TVP4020_BGR_MODE                        (0 << 5)// BGR mode

#define TVP4020_VGA_SELECT                      (0 << 4)// select VGA mode
#define TVP4020_GRAPHICS_SELECT                 (1 << 4)// select graphics modes

#define TVP4020_PIXEL_MODE_CI8                  (0 << 0)// pseudo color or VGA mode
#define TVP4020_PIXEL_MODE_332                  (1 << 0)// 332 true color
#define TVP4020_PIXEL_MODE_2320                 (2 << 0)// 232 off
#define TVP4020_PIXEL_MODE_2321                 (3 << 0)//
#define TVP4020_PIXEL_MODE_5551                 (4 << 0)// 
#define TVP4020_PIXEL_MODE_4444                 (5 << 0)// 
#define TVP4020_PIXEL_MODE_565                  (6 << 0)// 
#define TVP4020_PIXEL_MODE_8888                 (8 << 0)// 
#define TVP4020_PIXEL_MODE_PACKED               (9 << 0)// 24 bit packed

/********************************************************************************/
/*                INDIRECT REGISTER - MODE CONTROL REGISTER                        */
/********************************************************************************/
#define __TVP4020_MODE_CONTROL              0x19    //  Mode control
//        Default - 0x00

#define TVP4020_PRIMARY_INPUT               (0 << 4)// Primary input throuh palette
#define TVP4020_SECONDARY_INPUT             (1 << 4)// Secondary input throuh palette

#define TVP4020_5551_DBL_BUFFER             (1 << 2)// Enable 5551 dbl buffer
#define TVP4020_5551_PACKED                 (0 << 2)// Packed 555 mode

#define TVP4020_ENABLE_STATIC_DBL_BUFFER    (1 << 1)// Static dbl buffer enabled
#define TVP4020_DISABLE_STATIC_DBL_BUFFER   (1 << 1)// Static dbl buffer disabled

#define TVP4020_SELECT_FRONT_MODE           (0 << 0)// Front mode
#define TVP4020_SELECT_BACK_MODE            (1 << 0)// Back mode

/********************************************************************************/
/*                INDIRECT REGISTER - PALETTE PAGE                                */
/********************************************************************************/
#define __TVP4020_PALETTE_PAGE                    0x1C    //  
//        Default - 0x00

/********************************************************************************/
/*                INDIRECT REGISTER - MISC CONTROL                                */
/********************************************************************************/
#define __TVP4020_MISC_CONTROL            0x1E    //  
//        Default - 0x00

#define TVP4020_SYNC_ENABLE               (1 << 5)// Output SYNC info onto IOG
#define TVP4020_SYNC_DISABLE              (0 << 5)// No SYNC IOG output

#define TVP4020_PEDESTAL_0                (0 << 4)// 0 IRE blanking pedestal
#define TVP4020_PEDESTAL_75               (1 << 4)// 7.5 IRE blanking pedestal

#define TVP4020_VSYNC_INVERT              (1 << 3)// invert VSYNC output polarity
#define TVP4020_VSYNC_NORMAL              (0 << 3)// normal VSYNC output polarity

#define TVP4020_HSYNC_INVERT              (1 << 2)// invert HSYNC output polarity
#define TVP4020_HSYNC_NORMAL              (0 << 3)// normal HSYNC output polarity

#define TVP4020_DAC_8BIT                  (1 << 1)// DAC is in 8-bit mode
#define TVP4020_DAC_6BIT                  (0 << 1)// DAC is in 6-bit mode

#define TVP4020_DAC_POWER_ON              (0 << 0)// Turn DAC Power on 
#define TVP4020_DAC_POWER_OFF             (1 << 0)// Turn DAC Power off 

/********************************************************************************/
/*                INDIRECT REGISTER - COLOR KEY CONTROL                            */
/********************************************************************************/
#define __TVP4020_CK_CONTROL              0x40    //  
//        Default - 0x00

/********************************************************************************/
/*                INDIRECT REGISTER - COLOR KEY OVERLAY                           */
/********************************************************************************/
#define __TVP4020_CK_OVR_REG              0x41    //  
//        Default - 0x00

/********************************************************************************/
/*                INDIRECT REGISTER - COLOR KEY RED                               */
/********************************************************************************/
#define __TVP4020_CK_RED_REG              0x42    //  
//        Default - 0x00

/********************************************************************************/
/*                INDIRECT REGISTER - COLOR KEY GREEN                             */
/********************************************************************************/
#define __TVP4020_CK_GREEN_REG            0x43    //  
//        Default - 0x00

/********************************************************************************/
/*                INDIRECT REGISTER - COLOR KEY BLUE                              */
/********************************************************************************/
#define __TVP4020_CK_BLUE_REG             0x44    //  
//        Default - 0x00

/********************************************************************************/
/*                INDIRECT REGISTER - PIXEL CLOCK PLL                            */
/********************************************************************************/

#define __TVP4020_PIXCLK_REG_A1                0x20
#define __TVP4020_PIXCLK_REG_A2                0x21
#define __TVP4020_PIXCLK_REG_A3                0x22
#define __TVP4020_PIXCLK_REG_B1                0x23
#define __TVP4020_PIXCLK_REG_B2                0x24
#define __TVP4020_PIXCLK_REG_B3                0x25
#define __TVP4020_PIXCLK_REG_C1                0x26
#define __TVP4020_PIXCLK_REG_C2                0x27
#define __TVP4020_PIXCLK_REG_C3                0x28

#define __TVP4020_PIXCLK_STATUS                0x29

/********************************************************************************/
/*                INDIRECT REGISTER - MEMORU CLOCK PLL                            */
/********************************************************************************/

#define __TVP4020_MEMCLK_REG_1                 0x30
#define __TVP4020_MEMCLK_REG_2                 0x31
#define __TVP4020_MEMCLK_REG_3                 0x32

#define __TVP4020_MEMCLK_STATUS                0x33


#if 0
// need a delay between each write to the 4020. The only way to guarantee
// that the write has completed is to read from a Permedia2 control register.
// Reading forces any posted writes to be flushed out. 

#define TVP4020_DELAY \
{ \
    volatile LONG __junk; \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
    __junk = VideoPortReadRegisterUlong (FB_MODE_SEL); \
}

#else
#define TVP4020_DELAY
#endif

// macro to load a given data value into an internal TVP4020 register.
//

#define TVP4020_SET_INDEX_REG(index) \
{ \
    DEBUG_PRINT((3, "*(0x%X) <-- 0x%X\n", __TVP4020_INDEX_ADDR, (index) & 0xff)); \
    VideoPortWriteRegisterUlong(__TVP4020_INDEX_ADDR, (ULONG)((index) & 0xff)); \
    TVP4020_DELAY; \
}

#define TVP4020_WRITE_INDEX_REG(index, data) \
{ \
    TVP4020_SET_INDEX_REG(index);                            \
    DEBUG_PRINT((3, "*(0x%X) <-- 0x%X\n", __TVP4020_INDEX_DATA, (data) & 0xff)); \
    VideoPortWriteRegisterUlong(__TVP4020_INDEX_DATA, (ULONG)((data) & 0xff)); \
    TVP4020_DELAY; \
}

#define TVP4020_READ_INDEX_REG(index, data) \
{ \
    TVP4020_SET_INDEX_REG(index); \
    data = VideoPortReadRegisterUlong(__TVP4020_INDEX_DATA) & 0xff;   \
    TVP4020_DELAY; \
    DEBUG_PRINT((3, "0x%X <-- *(0x%X)\n", data, __TVP4020_INDEX_DATA)); \
}

// DABO: For compatibility with TVP3026
#define TVP4020_LOAD_CURSOR_CTRL(data) \
{ \
    volatile LONG   __temp;                                    \
    TVP4020_READ_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp);  \
    __temp &= ~(0x03) ;                                        \
    __temp |= ((data) & 0x03) ;                                \
    TVP4020_WRITE_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp); \
}

//
// macros to write a given RGB triplet into cursors 0, 1 and 2
//

#define TVP4020_SET_CURSOR_COLOR0(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_ADDR, (ULONG)(TVP4020_CURSOR_COLOR0));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA, (ULONG)(red));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA, (ULONG)(green));  \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA, (ULONG)(blue));   \
    TVP4020_DELAY; \
}

#define TVP4020_SET_CURSOR_COLOR1(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_ADDR, (ULONG)(TVP4020_CURSOR_COLOR1));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA, (ULONG)(red));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA, (ULONG)(green));  \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA, (ULONG)(blue));   \
    TVP4020_DELAY; \
}

#define TVP4020_SET_CURSOR_COLOR2(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_ADDR, (ULONG)(TVP4020_CURSOR_COLOR2));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA, (ULONG)(red));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA, (ULONG)(green));  \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_COL_DATA, (ULONG)(blue));   \
    TVP4020_DELAY; \
}



//
// macros to load a given RGB triple into the TVP4020 palette. Send the starting
// index and then send RGB triples. Auto-increment is turned on.
// Use TVP4020_PALETTE_START and multiple TVP4020_LOAD_PALETTE calls to load
// a contiguous set of entries. Use TVP4020_LOAD_PALETTE_INDEX to load a set
// of sparse entries.
//

#define TVP4020_PALETTE_START_WR(index) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_WR_ADDR,  (ULONG)(index));    \
    TVP4020_DELAY; \
}

#define TVP4020_PALETTE_START_RD(index) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_RD_ADDR,  (ULONG)(index));    \
    TVP4020_DELAY; \
}

#define TVP4020_LOAD_PALETTE(red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(red));      \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(green));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(blue));     \
    TVP4020_DELAY; \
}

#define TVP4020_LOAD_PALETTE_INDEX(index, red, green, blue) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_WR_ADDR, (ULONG)(index));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(red));      \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(green));    \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_PAL_DATA,    (ULONG)(blue));     \
    TVP4020_DELAY; \
}

//
// macro to read back a given RGB triple from the TVP4020 palette. Use after
// a call to TVP4020_PALETTE_START_RD
//

#define TVP4020_READ_PALETTE(red, green, blue) \
{ \
    red   = (UCHAR)(VideoPortReadRegisterUlong(__TVP4020_PAL_DATA) & 0xff);        \
    TVP4020_DELAY; \
    green = (UCHAR)(VideoPortReadRegisterUlong(__TVP4020_PAL_DATA) & 0xff);        \
    TVP4020_DELAY; \
    blue  = (UCHAR)(VideoPortReadRegisterUlong(__TVP4020_PAL_DATA) & 0xff);        \
    TVP4020_DELAY; \
}

//
// macros to set/get the pixel read mask. The mask is 8 bits wide and gets
// replicated across all bytes that make up a pixel.
//

#define TVP4020_SET_PIXEL_READMASK(mask) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_PIXEL_MASK,  (ULONG)(mask)); \
    TVP4020_DELAY; \
}

#define TVP4020_READ_PIXEL_READMASK(mask) \
{ \
    mask = VideoPortReadRegisterUlong(__TVP4020_PIXEL_MASK) & 0xff; \
}

//
// macros to load values into the cursor array
//

#define TVP4020_CURSOR_ARRAY_START(offset) \
{ \
    volatile LONG   __temp;                                     \
    TVP4020_READ_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp);   \
    __temp &= ~TVP4020_CURSOR_RAM_MASK ;                        \
    __temp |= TVP4020_CURSOR_RAM_ADDRESS((offset)>> 8) ;        \
    TVP4020_WRITE_INDEX_REG(__TVP4020_CURSOR_CONTROL, __temp);  \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_RAM_WR_ADDR,   (ULONG)((offset)& 0xff));   \
    TVP4020_DELAY; \
}

//
// DABO: Need a similar macro to set the read address for cursor RAM?
// DABO: changed to __TVP4020_CUR_RAM_DATA
//

#define TVP4020_LOAD_CURSOR_ARRAY(data) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_CUR_RAM_DATA, (ULONG)(data)); \
    TVP4020_DELAY; \
}

//
// DABO: changed to __TVP4020_CUR_RAM_DATA
//

#define TVP4020_READ_CURSOR_ARRAY(data) \
{ \
    data = VideoPortReadRegisterUlong(__TVP4020_CUR_RAM_DATA) & 0xff; \
    TVP4020_DELAY; \
}

//
// macro to move the cursor
//

#define TVP4020_MOVE_CURSOR(x, y) \
{ \
    VideoPortWriteRegisterUlong(__TVP4020_CURSOR_X_LSB,     (ULONG)((x) & 0xff));   \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CURSOR_X_MSB,     (ULONG)((x) >> 8));     \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CURSOR_Y_LSB,     (ULONG)((y) & 0xff));   \
    TVP4020_DELAY; \
    VideoPortWriteRegisterUlong(__TVP4020_CURSOR_Y_MSB,     (ULONG)((y) >> 8));     \
    TVP4020_DELAY; \
}

//
// macro to change the cursor hotspot
//

#define TVP4020_CURSOR_HOTSPOT(x, y) \
{ \
    TVP4020_DELAY; \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\mini\video.c ===
//***************************************************************************
//
// Module Name:
//
//   video.c
//
// Abstract:
//
//   This module contains the code to setup the timing values for chips
//   and RAMDACs
//
// Environment:
//
//   Kernel mode
//
//
// Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.            
// Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//***************************************************************************

#include "permedia.h"

VOID CheckRGBClockInteraction(PULONG PixelClock, PULONG SystemClock);

ULONG TVP4020_CalculateMNPForClock(PVOID HwDeviceExtension, 
                                   ULONG RefClock, 
                                   ULONG ReqClock, 
                                   BOOLEAN IsPixClock, 
                                   ULONG MinClock, 
                                   ULONG MaxClock, 
                                   ULONG *rM, 
                                   ULONG *rN, 
                                   ULONG *rP);

ULONG Dac_SeparateClocks(ULONG PixelClock, ULONG SystemClock);   

BOOLEAN InitializeVideo(PHW_DEVICE_EXTENSION HwDeviceExtension, 
                        PP2_VIDEO_FREQUENCIES VideoMode);

ULONG P2RD_CalculateMNPForClock(PVOID HwDeviceExtension, 
                                ULONG RefClock, 
                                ULONG ReqClock, 
                                ULONG *rM, 
                                ULONG *rN, 
                                ULONG *rP);

BOOLEAN Program_P2RD(PHW_DEVICE_EXTENSION HwDeviceExtension, 
                     PP2_VIDEO_FREQUENCIES VideoMode,  
                     ULONG Hsp, 
                     ULONG Vsp,
                     ULONG RefClkSpeed, 
                     PULONG pSystemClock, 
                     PULONG pPixelClock);

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,CheckRGBClockInteraction)
#pragma alloc_text(PAGE,TVP4020_CalculateMNPForClock)
#pragma alloc_text(PAGE,Dac_SeparateClocks)
#pragma alloc_text(PAGE,InitializeVideo)
#pragma alloc_text(PAGE,P2RD_CalculateMNPForClock)
#pragma alloc_text(PAGE,Program_P2RD)
#endif

VOID
CheckRGBClockInteraction(
    PULONG PixelClock,
    PULONG SystemClock
    )
/*++

Routine Description:

    Ensure the output frequencies do not interract. The following must be true
        fHigher != n*fLower +/- 3MHz,   for all N >= 1
    3MHz is the safe limit. 2MHz is sufficient.

Arguments:

    PixelClock - Pointer to the clock rate for pixel output.

    SystemClock - Pointer to the clock rate driving the Permedia2.

Return Value:

    If the clocks interact then they are adjusted and returned in the pointer
    values.

--*/

{
    PLONG fLower, fHigher;
    LONG nfLower;

    if (*PixelClock < *SystemClock)
    {
        fLower  = PixelClock;
        fHigher = SystemClock;
    }
    else
    {
        fLower  = SystemClock;
        fHigher = PixelClock;
    }

    while (TRUE)
    {
        nfLower = *fLower;

        while (nfLower - 20000 <= *fHigher)
        {
            if (*fHigher <= (nfLower + 20000))
            {
                //
                // 100KHz adjustments
                //

                if (*fHigher > nfLower)
                {
                    *fLower  -= 1000;
                    *fHigher += 1000;
                }
                else
                {
                    *fLower  += 1000;
                    *fHigher -= 1000;
                }
                break;
            }
            nfLower += *fLower;
        }
        if ((nfLower - 20000) > *fHigher)
            break;
    }
}


#define INITIALFREQERR 100000

ULONG
TVP4020_CalculateMNPForClock(
    PVOID HwDeviceExtension,
    ULONG RefClock,     // In 100Hz units
    ULONG ReqClock,     // In 100Hz units
    BOOLEAN IsPixClock, // is this the pixel or the sys clock
    ULONG MinClock,     // Min VCO rating
    ULONG MaxClock,     // Max VCO rating
    ULONG *rM,          // M Out
    ULONG *rN,          // N Out
    ULONG *rP           // P Out
    )
{
    ULONG   M, N, P;
    ULONG   VCO, Clock;
    LONG    freqErr, lowestFreqErr = INITIALFREQERR;
    ULONG   ActualClock = 0;

    for (N = 2; N <= 14; N++) 
    {
        for (M = 2; M <= 255; M++) 
        {
            VCO = ((RefClock * M) / N);

            if ((VCO < MinClock) || (VCO > MaxClock))
                continue;

            for (P = 0; P <= 4; P++) 
            {
                Clock = VCO >> P;

                freqErr = (Clock - ReqClock);

                if (freqErr < 0)
                {
                    //   
                    // PixelClock gets rounded up always so monitor reports
                    // correct frequency. 
                    // TMM: I have changed this because it causes our refresh
                    // rate to be incorrect and some DirectDraw waitForVBlank 
                    // tests fail.
                    // if (IsPixClock)
                    //      continue;
                    //

                    freqErr = -freqErr;
                }

                if (freqErr < lowestFreqErr) 
                { 
                    // 
                    // Only replace if error is less; keep N small!
                    // 

                    *rM = M;
                    *rN = N;
                    *rP = P;

                    ActualClock   = Clock;
                    lowestFreqErr = freqErr;

                    // 
                    // Return if we found an exact match
                    // 

                    if (freqErr == 0)
                        return(ActualClock);
                }
            }
        }
    }

    return(ActualClock);
}


ULONG Dac_SeparateClocks(ULONG PixelClock, ULONG SystemClock)
{
    ULONG   M, N, P;

    //
    // Ensure frequencies do not interract
    //

    P = 1;

    do 
    {
        M = P * SystemClock;
        if ((M > PixelClock - 10000) && (M < PixelClock + 10000)) 
        {
            //
            // Frequencies do interract. We can either change the
            // PixelClock or change the System clock to avoid it.
            //

            SystemClock = (PixelClock - 10000) / P;

        }

        N = P * PixelClock;

        if ((N > SystemClock - 10000) && (N < SystemClock + 10000)) 
        {
            //
            // Frequencies do interract. We can either change the
            // PixelClock or change the System clock to avoid it.
            //

            SystemClock = N - 10000;

        }

        P++;

    } while ((M < PixelClock + 30000) || (N < SystemClock + 30000));

    return (SystemClock);
}

BOOLEAN
InitializeVideo(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PP2_VIDEO_FREQUENCIES VideoMode
    )
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PVIDEO_MODE_INFORMATION VideoModeInfo = &VideoMode->ModeEntry->ModeInformation;
    ULONG   index;
    ULONG   color;
    ULONG   ulValue;
    ULONG   ulValue1;
    UCHAR   pixelCtrl;
    UCHAR   pixelFormat;
    ULONG   dShift;
    VESA_TIMING_STANDARD    VESATimings;
    ULONG   Htot, Hss, Hse, Hbe, Hsp;
    ULONG   Vtot, Vss, Vse, Vbe, Vsp;
    ULONG   PixelClock, Freq;
    ULONG   VCO;
    ULONG   RefClkSpeed, SystemClock;   // Speed of clocks in 100Hz units
    ULONG   VTGPolarity;
    ULONG   M, N, P, C, Q;
    LONG    gateAdjust;
    BOOLEAN SecondTry;
    USHORT  usData;
    ULONG   DacDepth, depth, xRes, yRes;
    ULONG   xStride;
    ULONG   ClrComp5, ClrComp6;
    ULONG   pixelData;

    P2_DECL;
    TVP4020_DECL;

    depth   = VideoMode->BitsPerPel;
    xRes    = VideoMode->ScreenWidth;
    yRes    = VideoMode->ScreenHeight;
    Freq    = VideoMode->ScreenFrequency;

    //
    // For timing calculations need full depth in bits
    //

    if ((DacDepth = depth) == 15)
    {
        DacDepth = 16;
    }
    else if (depth == 12)  
    {
        DacDepth = 32;
    }

    //
    // convert screen stride from bytes to pixels
    //

    xStride = (8 * VideoModeInfo->ScreenStride) / DacDepth;

    //
    // Ensure minimum frequency of 60 Hz
    //

    if (Freq < 60)
    {
        DEBUG_PRINT((2, "Frequency raised to minimum of 60Hz\n"));
        Freq = 60;
    }

    DEBUG_PRINT((2, "depth %d, xres %d, yres %d, freq %d\n",
                            depth, xRes, yRes, Freq));

    //
    // Get the video timing, from the registry, if an entry exists, or from
    // the list of defaults, if it doesn't.
    //

    if (!GetVideoTiming ( HwDeviceExtension, 
                          xRes, 
                          yRes,  
                          Freq, 
                          depth, 
                          &VESATimings ))
    {
        DEBUG_PRINT((1, "GetVideoTiming failed."));
        return (FALSE);
    }

    //
    // We have got a valid set of VESA timigs
    //

    Htot =  VESATimings.HTot;
    Hss  =  VESATimings.HFP ;
    Hse  =  Hss + VESATimings.HST;
    Hbe  =  Hse + VESATimings.HBP;
    Hsp  =  VESATimings.HSP;
    Vtot =  VESATimings.VTot;
    Vss  =  VESATimings.VFP ;
    Vse  =  Vss + VESATimings.VST;
    Vbe  =  Vse + VESATimings.VBP;
    Vsp  =  VESATimings.VSP;

    //
    // if we're zooming by 2 in Y then double the vertical timing values.
    //

    if (VideoModeInfo->DriverSpecificAttributeFlags & CAPS_ZOOM_Y_BY2)
    {
        Vtot *= 2;
        Vss  *= 2;
        Vse  *= 2;
        Vbe  *= 2;
    }

    //
    // Calculate Pixel Clock in 100 Hz units
    //

    PixelClock = (Htot * Vtot * Freq * 8) / 100;
    pixelData = PixelClock * (DacDepth / 8);

    if (pixelData > P2_MAX_PIXELDATA)
    {
        //
        // Failed pixelData validation
        //

        return (FALSE);

    }

    RefClkSpeed = hwDeviceExtension->RefClockSpeed  / 100;   // 100Hz units
    SystemClock = hwDeviceExtension->ChipClockSpeed / 100;   // 100Hz units

    //
    // We do some basic initialization before setting up MCLK.
    //

    //
    // disable the video control register
    //

    hwDeviceExtension->bVTGRunning = FALSE;
    hwDeviceExtension->VideoControl = 0;
    VideoPortWriteRegisterUlong( VIDEO_CONTROL, 
                                 hwDeviceExtension->VideoControl );

    //
    // Enable graphics mode, disable VGA
    //

    VideoPortWriteRegisterUchar( PERMEDIA_MMVGA_INDEX_REG, 
                                 PERMEDIA_VGA_CTRL_INDEX);

    usData = (USHORT)VideoPortReadRegisterUchar(PERMEDIA_MMVGA_DATA_REG);

    usData &= ~PERMEDIA_VGA_ENABLE;
    usData = (usData << 8) | PERMEDIA_VGA_CTRL_INDEX;

    VideoPortWriteRegisterUshort(PERMEDIA_MMVGA_INDEX_REG, usData);

    //
    // Setup Ramdac.
    //

    if (hwDeviceExtension->DacId == TVP4020_RAMDAC)
    {
        //
        // No separate S/W reset for P2 pixel unit
        //

        //
        // 1x64x64, cursor 1, ADDR[9:8] = 00, cursor off
        //

        TVP4020_WRITE_INDEX_REG(__TVP4020_CURSOR_CONTROL, 0x40);

        //
        // Redundant here; we just cleared the CCR above
        //

        TVP4020_LOAD_CURSOR_CTRL(TVP4020_CURSOR_OFF);   

        TVP4020_SET_CURSOR_COLOR0(0, 0, 0);
        TVP4020_SET_CURSOR_COLOR1(0xFF, 0xFF, 0xFF);

        //
        // P2 sets the sync polarity in the RAMDAC rather than VideoControl
        // 7.5 IRE, 8-bit data
        //

        ulValue = ((Hsp ? 0x0 : 0x1) << 2) | ((Vsp ? 0x0 : 0x1) << 3) | 0x12;

        TVP4020_WRITE_INDEX_REG(__TVP4020_MISC_CONTROL, ulValue);
        TVP4020_WRITE_INDEX_REG(__TVP4020_MODE_CONTROL, 0x00);  // Mode Control
        TVP4020_WRITE_INDEX_REG(__TVP4020_CK_CONTROL,   0x00);  // Color-Key Control
        TVP4020_WRITE_INDEX_REG(__TVP4020_PALETTE_PAGE, 0x00);  // Palette page

        //
        // No zoom on P2 pixel unit
        //
        // No separate multiplex control on P2 pixel unit
        //
        // Start TI TVP4020 programming
        //

        switch (depth)
        {
            case 8:

                //
                // RGB, graphics, Color Index 8
                //

                TVP4020_WRITE_INDEX_REG(__TVP4020_COLOR_MODE, 0x30);  

                if( hwDeviceExtension->Capabilities & CAPS_8BPP_RGB )
                {
                    ULONG   Red, Green, Blue ;

                    //
                    // load BGR 2:3:3 ramp into LUT
                    //

                    for (index = 0; index <= 0xff; ++index)
                    {
                        Red   = bPal8[index & 0x07];
                        Green = bPal8[(index >> 3 ) &0x07];
                        Blue  = bPal4[(index >> 6 ) &0x03];

                        // 
                        // EXTRA!! EXTRA!! EXTRA!!!
                        //  After more research on more pleasing appearance
                        //  we now added more grays, now we look not only for 
                        //  EXACT match of RED and GREEN, we consider it gray 
                        //  even when they differ by 1.
                        //  Added  15-Jan-1996  -by-  [olegsher]
                        // 
                        // Maybe it's a special case of gray ?
                        // 

                        if (abs((index & 0x07) - ((index >> 3 ) &0x07)) <= 1)
                        {
                            //
                            // This is a tricky part:
                            //  the Blue field in BGR 2:3:3 color goes thru 
                            //  steps 00, 01, 10, 11 (Binary)
                            //  
                            //  the Red and Green go thru 000, 001, 010, 011, 
                            //  100, 101, 110, 111 (Binary)
                            //  
                            //  We load the special gray values ONLY when Blue 
                            //  color is close in intensity to both Green and Red, 
                            //  i.e.    Blue = 01, Green = 010 or 011,
                            //          Blue = 10, Green = 100 or 101,
                            //  
    
                            if ((((index >> 1) & 0x03) == ((index >> 6 ) & 0x03 )) ||
                                 (((index >> 4) & 0x03) == ((index >> 6 ) & 0x03 )) ||
                                 ((Green == Red) && ( abs((index & 0x07) - ((index >> 5) & 0x06)) <= 1 )))
                            {
                                if( Blue || (Green == Red)) // Don't mess with dark colors
                                {
                                    color = (Red * 2 + Green * 3 + Blue) / 6;
                                    Red = Green = Blue = color;
                                }
                            }
                        }
                    
                        LUT_CACHE_SETRGB (index, Red, Green, Blue);
                    }
                }
                else
                {
                    for (index = 0; index <= 0xff; ++index)
                        LUT_CACHE_SETRGB (index, index, index, index);
                }
                break;

            case 15:
            case 16:

                //       
                // True color w/gamma, RGB, graphics, 5:5:5:1
                //       

                pixelCtrl = 0xB4; 

                //       
                // True-color w/gamma, RGB, graphics, 5:6:5
                //       

                if (depth == 16)
                    pixelCtrl |= 0x02;

                TVP4020_WRITE_INDEX_REG(__TVP4020_COLOR_MODE, pixelCtrl);

                //       
                // load linear ramp into LUT
                //       

                for (index = 0; index <= 0xff; ++index)
                {
                    ClrComp5 = (index & 0xF8) | (index >> 5);
                    ClrComp6 = (index & 0xFC) | (index >> 6);

                    LUT_CACHE_SETRGB (index, 
                                      ClrComp5, 
                                      depth == 16 ? ClrComp6 : ClrComp5, ClrComp5);
                }
                break;

            case 24: 
            case 32:

                //
                // True color w/gamma, RGB, graphics, 8:8:8:8
                //

                pixelCtrl = 0xB8; 

                //
                // True color w/gamma, RGB, graphics, packed-24
                //

                if (depth == 24)
                    pixelCtrl |= 0x01;

                TVP4020_WRITE_INDEX_REG(__TVP4020_COLOR_MODE, pixelCtrl);

                //
                // load linear ramp into LUT
                // standard 888 ramps
                //

                for (index = 0; index <= 0xff; ++index)
                    LUT_CACHE_SETRGB (index, index, index, index);
                break;

            default:

                DEBUG_PRINT((2, "Cannot set RAMDAC for bad depth %d\n", depth));
                break;

        }

        //
        // if the clocks are in danger of interacting adjust the system clock
        //

        SystemClock = Dac_SeparateClocks(PixelClock, SystemClock);

        //
        // Program system clock. This controls the speed of the Permedia 2.
        //

        SystemClock = TVP4020_CalculateMNPForClock(
                                          HwDeviceExtension,
                                          RefClkSpeed,  // In 100Hz units
                                          SystemClock,  // In 100Hz units
                                          FALSE,        // SysClock
                                          1500000,      // Min VCO rating
                                          3000000,      // Max VCO rating
                                          &M,           // M Out
                                          &N,           // N Out
                                          &P);          // P Out

        if (SystemClock == 0)
        {
            DEBUG_PRINT((1, "TVP4020_CalculateMNPForClock failed\n"));
            return(FALSE);
        }

        //
        // Can change P2 MCLK directly without switching to PCLK
        //
        // Program the Mclk PLL
        //
        // test mode: forces MCLK to constant high
        //

        TVP4020_WRITE_INDEX_REG(__TVP4020_MEMCLK_REG_3, 0x06); 

        TVP4020_WRITE_INDEX_REG(__TVP4020_MEMCLK_REG_2, N);       // N
        TVP4020_WRITE_INDEX_REG(__TVP4020_MEMCLK_REG_1, M);       // M
        TVP4020_WRITE_INDEX_REG(__TVP4020_MEMCLK_REG_3, P | 0x08);// P / Enable

        C = 1000000;

        do 
        {
            TVP4020_READ_INDEX_REG(__TVP4020_MEMCLK_STATUS, ulValue); // Status

        } while ((!(ulValue & (1 << 4))) && (--C));

        //
        // No zoom on P2 pixel unit
        //
        // Program Pixel Clock to the correct value for the required resolution
        //

        PixelClock = TVP4020_CalculateMNPForClock( 
                                           HwDeviceExtension,
                                           RefClkSpeed,  // In 100Hz units
                                           PixelClock,   // In 100Hz units
                                           TRUE,         // Pixel Clock
                                           1500000,      // Min VCO rating
                                           3000000,      // Max VCO rating
                                           &M,           // M Out
                                           &N,           // N Out
                                           &P);          // P Out

        if (PixelClock == 0)
        {
            DEBUG_PRINT((1, "TVP4020_CalculateMNPForClock failed\n"));
            return(FALSE);
        }

        // 
        // Pixel Clock
        // 

        TVP4020_WRITE_INDEX_REG(__TVP4020_PIXCLK_REG_C3, 0x06);    // RESET PCLK PLL
        TVP4020_WRITE_INDEX_REG(__TVP4020_PIXCLK_REG_C2, N );      // N
        TVP4020_WRITE_INDEX_REG(__TVP4020_PIXCLK_REG_C1, M);       // M
        TVP4020_WRITE_INDEX_REG(__TVP4020_PIXCLK_REG_C3, P | 0x08);// Enable PCLK

        M = 1000000;

        do 
        {
            TVP4020_READ_INDEX_REG(__TVP4020_PIXCLK_STATUS, ulValue); 

        } while ((!(ulValue & (1 << 4))) && (--M));

        //
        // No Loop Clock on P2
        //

        TVP4020_SET_PIXEL_READMASK (0xff); 

        //
        // TMM: there is a rule that says if you muck about with the
        // MCLK then you must set up the MEM_CONFIG register again.
        //
    }
    else if (hwDeviceExtension->DacId == P2RD_RAMDAC)
    {
        if( !Program_P2RD( HwDeviceExtension, 
                           VideoMode, 
                           Hsp, 
                           Vsp, 
                           RefClkSpeed, 
                           &SystemClock, 
                           &PixelClock))
            return(FALSE);
    }

    //
    // Set the LUT cache size and set the first entry to zero, then
    // write the LUT cache to the LUT
    //

    LUT_CACHE_SETSIZE (256);
    LUT_CACHE_SETFIRST (0);

    (void) Permedia2SetColorLookup ( hwDeviceExtension,
                                     &(hwDeviceExtension->LUTCache.LUTCache),
                                     sizeof (hwDeviceExtension->LUTCache),
                                     TRUE,    // Always update RAMDAC 
                                     FALSE ); // Don't Update cache entries

    //
    // Setup VTG
    //

    ulValue = 3;    // RAMDAC pll pins for VClkCtl

    if ((hwDeviceExtension->DacId == P2RD_RAMDAC) ||
        (hwDeviceExtension->DacId == TVP4020_RAMDAC))
    {
        ULONG PCIDelay;

        //
        // TMM: The algorithm we used to calculate PCIDelay for P1 doesn't 
        // work for P2, frequent mode changes might cause hangups. 
        // So I took the value used by the BIOS for AGP and PCI systems 
        // and used that one. It works fine on PCI and VGA PCs.
        //

        PCIDelay = 32;

        ulValue |= (PCIDelay << 2);
    }
    else
    {
        DEBUG_PRINT((1, "Invalid RAMDAC type! \n"));
    }

    //
    // dShift is now used as a multiplier, instead of a shift count.
    // This is to support P2 packed-24 mode where the VESA horizontal 
    // timing values need to be multiplied by a non-power-of-two multiplier.
    //

    if ((hwDeviceExtension->DacId == TVP4020_RAMDAC && DacDepth > 8) || 
         hwDeviceExtension->DacId == P2RD_RAMDAC)
    {
        dShift = DacDepth >> 3;  // 64-bit pixel bus
    }
    else
    {
        dShift = DacDepth >> 2;  // 32-bit pixel bus
    }

    //
    // must load HgEnd before ScreenBase
    //

    VideoPortWriteRegisterUlong(HG_END, Hbe * dShift);

    //
    // Need to set up RAMDAC pll pins
    //

    VideoPortWriteRegisterUlong(V_CLK_CTL, ulValue); 

    VideoPortWriteRegisterUlong(SCREEN_BASE,   0);
    VideoPortWriteRegisterUlong(SCREEN_STRIDE, (xStride >> 3) * (DacDepth >> 3)); // 64-bit units
    VideoPortWriteRegisterUlong(H_TOTAL,       (Htot * dShift) - 1);
    VideoPortWriteRegisterUlong(HS_START,      Hss * dShift);
    VideoPortWriteRegisterUlong(HS_END,        Hse * dShift);
    VideoPortWriteRegisterUlong(HB_END,        Hbe * dShift);

    VideoPortWriteRegisterUlong(V_TOTAL,       Vtot - 1);
    VideoPortWriteRegisterUlong(VS_START,      Vss - 1);
    VideoPortWriteRegisterUlong(VS_END,        Vse - 1);
    VideoPortWriteRegisterUlong(VB_END,        Vbe);

    {
        ULONG highWater, newChipConfig, oldChipConfig;

        #define videoFIFOSize       32
        #define videoFIFOLoWater     8
        #define videoFIFOLatency    26

        //
        // Calculate the high-water, by taking into account
        // the pixel clock, the pxiel size, add 1 for luck
        //

        highWater = (((videoFIFOLatency * PixelClock * DacDepth) / 
                      (64 * SystemClock )) + 1);

        //
        // Trim the highwater, make sure it's not bigger than the FIFO size
        //

        if (highWater > videoFIFOSize)
            highWater = videoFIFOSize;

        highWater = videoFIFOSize - highWater;

        //
        // Make sure the highwater is greater than the low water mark.
        //

        if (highWater <= videoFIFOLoWater)
            highWater = videoFIFOLoWater + 1;

        ulValue = (highWater << 8) | videoFIFOLoWater;
            
        VideoPortWriteRegisterUlong(VIDEO_FIFO_CTL, ulValue);

        //
        // select the appropriate Delta clock source
        //

        #define SCLK_SEL_PCI        (0x0 << 10)   // Delta Clk == PCI Clk
        #define SCLK_SEL_PCIHALF    (0x1 << 10)   // Delta Clk == 1/2 PCI Clk
        #define SCLK_SEL_MCLK       (0x2 << 10)   // Delta Clk == MClk
        #define SCLK_SEL_MCLKHALF   (0x3 << 10)   // Delta Clk == 1/2 MClk
        #define SCLK_SEL_MASK       (0x3 << 10)

        if (VideoPortGetRegistryParameters(HwDeviceExtension,
                                           L"P2DeltaClockMode",
                                           FALSE,
                                           Permedia2RegistryCallback,
                                           &ulValue) == NO_ERROR)
        {
            ulValue <<= 10;
            ulValue &= SCLK_SEL_MASK;
        }
        else
        {
            if((hwDeviceExtension->deviceInfo.RevisionId == PERMEDIA2A_REV_ID) &&
               (hwDeviceExtension->PciSpeed == 66))
            {
                ulValue = SCLK_SEL_PCI;
            }
            else
            {
                //
                // This is the default value
                //

                ulValue = SCLK_SEL_MCLKHALF;

            }
        }

        newChipConfig = oldChipConfig = VideoPortReadRegisterUlong(CHIP_CONFIG);
        newChipConfig &= ~SCLK_SEL_MASK; 
        newChipConfig |= ulValue; 
        
        VideoPortWriteRegisterUlong(CHIP_CONFIG, newChipConfig);
    }

    //
    // Enable video out and set sync polaritys to active high.
    // P2 uses 64-bit pixel bus for modes > 8BPP
    //

    VTGPolarity = (1 << 5) | (1 << 3) | 1;

    if (hwDeviceExtension->DacId == P2RD_RAMDAC || DacDepth > 8)
    {
        //
        // P2ST always uses 64-bit pixel bus
        // P2 uses 64-bit pixel bus for modes > 8BPP
        //

        VTGPolarity |= (1 << 16);
    }

    if (VideoModeInfo->DriverSpecificAttributeFlags & CAPS_ZOOM_Y_BY2)
        VTGPolarity |= (1 << 2);

    hwDeviceExtension->VideoControl = VTGPolarity;
    VideoPortWriteRegisterUlong(VIDEO_CONTROL, hwDeviceExtension->VideoControl); 

    DEBUG_PRINT((2, "Loaded Permedia timing registers:\n"));
    DEBUG_PRINT((2, "\tVClkCtl: 0x%x\n", 3));
    DEBUG_PRINT((2, "\tScreenBase: 0x%x\n", 0));
    DEBUG_PRINT((2, "\tScreenStride: 0x%x\n", xStride >> (3 - (DacDepth >> 4))));
    DEBUG_PRINT((2, "\tHTotal: 0x%x\n", (Htot << dShift) - 1));
    DEBUG_PRINT((2, "\tHsStart: 0x%x\n", Hss << dShift));
    DEBUG_PRINT((2, "\tHsEnd: 0x%x\n", Hse << dShift));
    DEBUG_PRINT((2, "\tHbEnd: 0x%x\n", Hbe << dShift));
    DEBUG_PRINT((2, "\tHgEnd: 0x%x\n", Hbe << dShift));
    DEBUG_PRINT((2, "\tVTotal: 0x%x\n", Vtot - 1));
    DEBUG_PRINT((2, "\tVsStart: 0x%x\n", Vss - 1));
    DEBUG_PRINT((2, "\tVsEnd: 0x%x\n", Vse - 1));
    DEBUG_PRINT((2, "\tVbEnd: 0x%x\n", Vbe));
    DEBUG_PRINT((2, "\tVideoControl: 0x%x\n", VTGPolarity));

    //
    // record the final chip clock in the registry
    //

    SystemClock *= 100;
    VideoPortSetRegistryParameters(HwDeviceExtension,
                                   L"HardwareInformation.CurrentChipClockSpeed",
                                   &SystemClock,
                                   sizeof(ULONG));

    hwDeviceExtension->bVTGRunning = TRUE;
    DEBUG_PRINT((2, "InitializeVideo Finished\n"));
    return(TRUE);
}


ULONG P2RD_CalculateMNPForClock(
    PVOID HwDeviceExtension,
    ULONG RefClock,     // In 100Hz units
    ULONG ReqClock,     // In 100Hz units
    ULONG *rM,          // M Out (feedback scaler)
    ULONG *rN,          // N Out (prescaler)
    ULONG *rP           // P Out (postscaler)
    )

/*++

Routine Description:

   Calculates prescaler, feedback scaler and postscaler values for the
   STMACRO PLL61-1M used by P2RD.

--*/

{
    const ULONG fMinVCO    = 1280000;  // min fVCO is 128MHz (in 100Hz units)
    const ULONG fMaxVCO    = 2560000;  // max fVCO is 256MHz (in 100Hz units)
    const ULONG fMinINTREF = 10000;    // min fINTREF is 1MHz (in 100Hz units)
    const ULONG fMaxINTREF = 20000;    // max fINTREF is 2MHz (in 100Hz units)

    ULONG   M, N, P;
    ULONG   fINTREF;
    ULONG   fVCO;
    ULONG   ActualClock;
    int     Error;
    int     LowestError = INITIALFREQERR;
    BOOLEAN bFoundFreq = FALSE;
    int     LoopCount;

    for(P = 0; P <= 4; ++P)
    {
        ULONG fVCOLowest, fVCOHighest;

        //
        // it's pointless going through the main loop if all values of N 
        // produce an fVCO outside the acceptable range
        //

        N = 1;
        M = (N * (1 << P) * ReqClock) / RefClock;

        fVCOLowest = (RefClock * M) / N;

        N = 255;
        M = (N * (1 << P) * ReqClock) / RefClock;

        fVCOHighest = (RefClock * M) / N;

        if(fVCOHighest < fMinVCO || fVCOLowest > fMaxVCO)
            continue;

        for(N = 1; N <= 255; ++N)
        {
            fINTREF = RefClock / N;
            if(fINTREF < fMinINTREF || fINTREF > fMaxINTREF)
            {
                if(fINTREF > fMaxINTREF)
                {
                    //
                    // hopefully we'll get into range as the prescale 
                    // value increases
                    //

                    continue;
                }
                else
                {
                    //
                    // already below minimum and it'll only get worse: 
                    // move to the next postscale value
                    //

                    break;
                }
            }

            M = (N * (1 << P) * ReqClock) / RefClock;
            if(M > 255)
            {
                //
                // M, N & P registers are only 8 bits wide
                //

                break;

            }

            //
            // we can expect rounding errors in calculating M, which will 
            // always be rounded down.  So we'll checkout our calculated 
            // value of M along with (M+1)
            //

            for(LoopCount = (M == 255) ? 1 : 2; --LoopCount >= 0; ++M)
            {
                fVCO = (RefClock * M) / N;

                if(fVCO >= fMinVCO && fVCO <= fMaxVCO)
                {
                    ActualClock = fVCO / (1 << P);

                    Error = ActualClock - ReqClock;
                    if(Error < 0)
                        Error = -Error;

                    if(Error < LowestError)
                    {
                        bFoundFreq = TRUE;
                        LowestError = Error;
                        *rM = M;
                        *rN = N;
                        *rP = P;
                        if(Error == 0)
                            goto Done;
                    }
                }
            }
        }
    }

Done:

    if(bFoundFreq)
        ActualClock = (RefClock * *rM) / (*rN * (1 << *rP));
    else
        ActualClock = 0;

    return(ActualClock);
}


BOOLEAN Program_P2RD(PHW_DEVICE_EXTENSION HwDeviceExtension, 
                     PP2_VIDEO_FREQUENCIES VideoMode, 
                     ULONG Hsp, 
                     ULONG Vsp,
                     ULONG RefClkSpeed, 
                     PULONG pSystemClock, 
                     PULONG pPixelClock )

/*++

Routine Description:

    initializes the P2RD registers and programs the DClk (pixel clock)
    and MClk (system clock) PLLs. After programming the MClk, the
    contents of all registers in the graphics core, the memory controller
    and the video control should be assumed to be undefined

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PVIDEO_MODE_INFORMATION VideoModeInfo = &VideoMode->ModeEntry->ModeInformation;
    ULONG   DacDepth, depth;
    LONG    mpxAdjust;
    ULONG   index;
    ULONG   color;
    ULONG   ulValue;
    UCHAR   pixelCtrl;
    ULONG   M, N, P;
    P2_DECL;
    P2RD_DECL;

    depth = VideoMode->BitsPerPel;

    //
    // For timing calculations need full depth in bits
    //

    if ((DacDepth = depth) == 15)
        DacDepth = 16;
    else if (depth == 12)
        DacDepth = 32;

    VideoPortWriteRegisterUlong(P2RD_INDEX_CONTROL,   
                                P2RD_IDX_CTL_AUTOINCREMENT_ENABLED);

    ulValue = (Hsp ? P2RD_SYNC_CONTROL_HSYNC_ACTIVE_HIGH : P2RD_SYNC_CONTROL_HSYNC_ACTIVE_LOW) |
              (Vsp ? P2RD_SYNC_CONTROL_VSYNC_ACTIVE_HIGH : P2RD_SYNC_CONTROL_VSYNC_ACTIVE_LOW);

    if (VideoModeInfo->DriverSpecificAttributeFlags & CAPS_ZOOM_X_BY2)
    {
        //
        // it's a really low resolution (e.g. 320x200) so enable pixel 
        // doubling in the RAMDAC (we'll enable line doubling in the
        // pixel unit too)
        //

        P2RD_LOAD_INDEX_REG(P2RD_MISC_CONTROL, 
                            P2RD_MISC_CONTROL_HIGHCOLORRES | 
                            P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED |
                            P2RD_MISC_CONTROL_PIXEL_DOUBLE);
    }
    else
    {
        P2RD_LOAD_INDEX_REG(P2RD_MISC_CONTROL, 
                            P2RD_MISC_CONTROL_HIGHCOLORRES | 
                            P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED);
    }

    P2RD_LOAD_INDEX_REG(P2RD_SYNC_CONTROL, ulValue);
    P2RD_LOAD_INDEX_REG(P2RD_DAC_CONTROL,  
                        P2RD_DAC_CONTROL_BLANK_PEDESTAL_ENABLED);

    ulValue = 0;

    if (VideoModeInfo->DriverSpecificAttributeFlags & CAPS_ZOOM_X_BY2)
    {
        ulValue |= P2RD_CURSOR_CONTROL_DOUBLE_X;
    }

    if (VideoModeInfo->DriverSpecificAttributeFlags & CAPS_ZOOM_Y_BY2)
    {
        ulValue |= P2RD_CURSOR_CONTROL_DOUBLE_Y;
    }

    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_CONTROL,   ulValue);

    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_MODE,      0);
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_X_LOW,     0);
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_X_HIGH,    0);
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_Y_LOW,     0);
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_Y_HIGH,    0xff);
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_HOTSPOT_X, 0);
    P2RD_LOAD_INDEX_REG(P2RD_CURSOR_HOTSPOT_Y, 0);
    P2RD_LOAD_INDEX_REG(P2RD_PAN, 0);

    //
    // the first 3-color cursor is the mini cursor which is always 
    // black & white. Set it up here
    //

    P2RD_CURSOR_PALETTE_CURSOR_RGB(0, 0x00,0x00,0x00);
    P2RD_CURSOR_PALETTE_CURSOR_RGB(1, 0xff,0xff,0xff);

    //
    // stop dot and memory clocks
    //

    P2RD_LOAD_INDEX_REG(P2RD_DCLK_CONTROL, 0);
    P2RD_LOAD_INDEX_REG(P2RD_MCLK_CONTROL, 0);

    if (VideoModeInfo->DriverSpecificAttributeFlags & CAPS_ZOOM_X_BY2)
    {
        // 
        // we're doubling each pixel so we double the pixel clock too
        // NB. the PixelDouble field of RDMiscControl needs to be set also)
        // 

        *pPixelClock *= 2;
    }

    *pPixelClock = P2RD_CalculateMNPForClock( HwDeviceExtension, 
                                              RefClkSpeed, 
                                              *pPixelClock, 
                                              &M, 
                                              &N, 
                                              &P );

    if(*pPixelClock == 0)
    {
        DEBUG_PRINT((1, "P2RD_CalculateMNPForClock(PixelClock) failed\n"));
        return(FALSE);
    }

    //
    // load both copies of the dot clock with our times (DCLK0 & DCLK1 
    // reserved for VGA only)
    //

    P2RD_LOAD_INDEX_REG(P2RD_DCLK2_PRE_SCALE,      N);
    P2RD_LOAD_INDEX_REG(P2RD_DCLK2_FEEDBACK_SCALE, M);
    P2RD_LOAD_INDEX_REG(P2RD_DCLK2_POST_SCALE,     P);

    P2RD_LOAD_INDEX_REG(P2RD_DCLK3_PRE_SCALE,      N);
    P2RD_LOAD_INDEX_REG(P2RD_DCLK3_FEEDBACK_SCALE, M);
    P2RD_LOAD_INDEX_REG(P2RD_DCLK3_POST_SCALE,     P);

    *pSystemClock = P2RD_CalculateMNPForClock( HwDeviceExtension, 
                                               RefClkSpeed, 
                                               *pSystemClock, 
                                               &M, 
                                               &N, 
                                               &P );

    if(*pSystemClock == 0)
    {
        DEBUG_PRINT((1, "P2RD_CalculateMNPForClock(SystemClock) failed\n"));
        return(FALSE);
    }

    //
    // load the system clock
    //

    P2RD_LOAD_INDEX_REG(P2RD_MCLK_PRE_SCALE,      N);
    P2RD_LOAD_INDEX_REG(P2RD_MCLK_FEEDBACK_SCALE, M);
    P2RD_LOAD_INDEX_REG(P2RD_MCLK_POST_SCALE,     P);

    //
    // enable the dot clock
    //

    P2RD_LOAD_INDEX_REG(P2RD_DCLK_CONTROL, 
                        P2RD_DCLK_CONTROL_ENABLED | P2RD_DCLK_CONTROL_RUN);


    M = 0x100000;

    do
    {
        P2RD_READ_INDEX_REG(P2RD_DCLK_CONTROL, ulValue);
    }
    while((ulValue & P2RD_DCLK_CONTROL_LOCKED) == FALSE && --M);

    if((ulValue & P2RD_DCLK_CONTROL_LOCKED) == FALSE)
    {
        DEBUG_PRINT((1, "Program_P2RD: PixelClock failed to lock\n"));
        return(FALSE);
    }

    //
    // enable the system clock
    //

    P2RD_LOAD_INDEX_REG(P2RD_MCLK_CONTROL, 
                        P2RD_MCLK_CONTROL_ENABLED | P2RD_MCLK_CONTROL_RUN);


    M = 0x100000;

    do
    {
        P2RD_READ_INDEX_REG(P2RD_MCLK_CONTROL, ulValue);
    }
    while((ulValue & P2RD_MCLK_CONTROL_LOCKED) == FALSE && --M);

    if((ulValue & P2RD_MCLK_CONTROL_LOCKED) == FALSE)
    {
        DEBUG_PRINT((1, "Program_P2RD: SystemClock failed to lock\n"));
        return(FALSE);
    }

    switch (depth) 
    {
        case 8:

            P2RD_READ_INDEX_REG(P2RD_MISC_CONTROL, ulValue);

            ulValue &= ~P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;

            P2RD_LOAD_INDEX_REG(P2RD_MISC_CONTROL, ulValue);
            P2RD_LOAD_INDEX_REG(P2RD_PIXEL_SIZE, P2RD_PIXEL_SIZE_8BPP);

            if (hwDeviceExtension->Capabilities & CAPS_8BPP_RGB)
            {
                ULONG   Red, Green, Blue ;
    
                P2RD_LOAD_INDEX_REG(P2RD_COLOR_FORMAT, 
                                    P2RD_COLOR_FORMAT_8BPP | P2RD_COLOR_FORMAT_RGB);

                for (index = 0; index <= 0xff; ++index)
                {
                    Red     = bPal8[index & 0x07];
                    Green   = bPal8[(index >> 3 ) & 0x07];
                    Blue    = bPal4[(index >> 6 ) & 0x03];

                    if( Red == Green)   // Maybe it's a special case of gray ?
                    {
                        //  
                        // This is a tricky part:
                        // the Blue field in BGR 2:3:3 color goes thru 
                        // steps 00, 01, 10, 11 (Binary)
                        // the Red and Green go thru 000, 001, 010, 011, 
                        // 100, 101, 110, 111 (Binary)
                        // We load the special gray values ONLY when Blue 
                        // color is close in intensity to both Green and Red, 
                        // i.e. Blue = 01, Green = 010 or 011,
                        //      Blue = 10, Green = 100 or 101,
                        //  

                        if ( ((index >> 1) & 0x03) == ((index >> 6 ) & 0x03 ) )
                        { 
                            Blue = Red;
                        }
                    }
                    LUT_CACHE_SETRGB (index, Red, Green, Blue);
                }
            }
            else
            {
                //
                // Color indexed mode
                //

                P2RD_LOAD_INDEX_REG(P2RD_COLOR_FORMAT, 
                                    P2RD_COLOR_FORMAT_CI8 | P2RD_COLOR_FORMAT_RGB);

            }

            break;

        case 15:
        case 16:

            P2RD_LOAD_INDEX_REG(P2RD_PIXEL_SIZE, P2RD_PIXEL_SIZE_16BPP);

#if  GAMMA_CORRECTION

            P2RD_READ_INDEX_REG(P2RD_MISC_CONTROL, ulValue);
            ulValue &= ~P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
            P2RD_LOAD_INDEX_REG(P2RD_MISC_CONTROL, ulValue);

            //
            // load linear ramp into LUT as default
            //

            for (index = 0; index <= 0xff; ++index)
                LUT_CACHE_SETRGB (index, index, index, index);

            pixelCtrl = 0;

#else
            P2RD_READ_INDEX_REG(P2RD_MISC_CONTROL, ulValue);
            ulValue |= P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
            P2RD_LOAD_INDEX_REG(P2RD_MISC_CONTROL, ulValue);
            pixelCtrl = P2RD_COLOR_FORMAT_LINEAR_EXT;

#endif

            pixelCtrl |= 
                 (depth == 16) ? P2RD_COLOR_FORMAT_16BPP : P2RD_COLOR_FORMAT_15BPP;

            pixelCtrl |= P2RD_COLOR_FORMAT_RGB;

            P2RD_LOAD_INDEX_REG(P2RD_COLOR_FORMAT, pixelCtrl);

            break;

        case 12:
        case 24:
        case 32:

            P2RD_LOAD_INDEX_REG(P2RD_PIXEL_SIZE, P2RD_PIXEL_SIZE_32BPP);
            P2RD_LOAD_INDEX_REG(P2RD_COLOR_FORMAT, 
                                P2RD_COLOR_FORMAT_32BPP | P2RD_COLOR_FORMAT_RGB);

            if (depth == 12) 
            {
                USHORT cacheIndex;

                P2RD_READ_INDEX_REG(P2RD_MISC_CONTROL, ulValue);
                ulValue &= ~P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
                P2RD_LOAD_INDEX_REG(P2RD_MISC_CONTROL, ulValue);

                //
                // use auto-increment to load a ramp into entries 0 to 15
                //

                for (index = 0, cacheIndex = 0; 
                     index <= 0xff; 
                     index += 0x11, cacheIndex++)
                {
                    LUT_CACHE_SETRGB (index, index, index, index);
                }

                //
                // load ramp in every 16th entry from 16 to 240
                //

                color = 0x11;
                for (index = 0x10; index <= 0xf0; index += 0x10, color += 0x11) 
                    LUT_CACHE_SETRGB (index, color, color, color);

                P2RD_SET_PIXEL_READMASK(0x0f);
            }
            else
            {

#if  GAMMA_CORRECTION

                P2RD_READ_INDEX_REG(P2RD_MISC_CONTROL, ulValue);
                ulValue &= ~P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
                P2RD_LOAD_INDEX_REG(P2RD_MISC_CONTROL, ulValue);

                //
                // load linear ramp into LUT as default
                //

                for (index = 0; index <= 0xff; ++index)
                    LUT_CACHE_SETRGB (index, index, index, index);

#else
                P2RD_READ_INDEX_REG(P2RD_MISC_CONTROL, ulValue);
                ulValue |= P2RD_MISC_CONTROL_DIRECT_COLOR_ENABLED;
                P2RD_LOAD_INDEX_REG(P2RD_MISC_CONTROL, ulValue);

#endif  // GAMMA_CORRECTION

            }

            break;

        default:

            DEBUG_PRINT((1, "bad depth %d passed to Program_P2RD\n", depth));

            return(FALSE);

    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\mini\permedia.h ===
//***************************************************************************
//
// Module Name:
//
//   permedia.h
//
// Abstract:
//
//   This module contains the definitions for the Permedia2 miniport driver
//
// Environment:
//
//   Kernel mode
//
// Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.            
// Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//***************************************************************************


#include "winerror.h"
#include "devioctl.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "interupt.h"
#include "perm2tag.h"

//
// define an assert macro for debugging
//

#if DBG
#define RIP(x)  { VideoDebugPrint((0, x)); ASSERT(FALSE); }
#define P2_ASSERT(x, y) if (!(x)) RIP(y)
#else
#define P2_ASSERT(x, y)
#endif


#if DBG
#define DEBUG_PRINT(arg) VideoDebugPrint(arg)
#else
#define DEBUG_PRINT(arg)
#endif


//
// RAMDAC registers live on 64 bit boundaries. Leave it up to individual
// RAMDAC definitions to determine what registers are available and how
// many bits wide the registers really are.
//

typedef struct {

    volatile ULONG   reg;
    volatile ULONG   pad;

} RAMDAC_REG;

//
// include definitions for all supported RAMDACS
//

#include "tvp4020.h"
#include "p2rd.h"

#define PAGE_SIZE  0x1000

//
// default clock speed in Hz for the reference board. The actual speed
// is looked up in the registry. Use this if no registry entry is found
// or the registry entry is zero.
//

#define PERMEDIA_DEFAULT_CLOCK_SPEED        ( 60 * (1000*1000))
#define PERMEDIA_4MB_DEFAULT_CLOCK_SPEED    ( 70 * (1000*1000))
#define PERMEDIA_8MB_DEFAULT_CLOCK_SPEED    ( 60 * (1000*1000))
#define PERMEDIA_LC_DEFAULT_CLOCK_SPEED     ( 83 * (1000*1000))
#define MAX_PERMEDIA_CLOCK_SPEED            (100 * (1000*1000))
#define MIN_PERMEDIA_CLOCK_SPEED            ( 50 * (1000*1000))
#define REF_CLOCK_SPEED                     14318200
#define PERMEDIA2_DEFAULT_CLOCK_SPEED       ( 70 * (1000*1000))

//
// Maximum pixelclock values that the RAMDAC can handle (in 100's hz).
//

#define P2_MAX_PIXELCLOCK 2200000    // RAMDAC rated at 220 Mhz

//
// Maximum amount of video data per second, that the rasterizer
// chip can send to the RAMDAC (limited by SDRAM/SGRAM throuput).
//

#define P2_MAX_PIXELDATA  5000000    // 500 million bytes/sec (in 100's bytes)

//
// Base address numbers for the Permedia2 PCI regions in which we're interested.
// These are indexes into the AccessRanges array we get from probing the
// device. 
//

#define PCI_CTRL_BASE_INDEX         0
#define PCI_LB_BASE_INDEX           1
#define PCI_FB_BASE_INDEX           2

#define VENDOR_ID_3DLABS        0x3D3D
#define VENDOR_ID_TI            0x104C

#define PERMEDIA2_ID            0x0007     // 3Dlabs Permedia 2 (TI4020 RAMDAC)
#define PERMEDIA_P2_ID          0x3D07     // TI Permedia 2 (TI4020 RAMDAC)
#define PERMEDIA_P2S_ID         0x0009     // 3Dlabs Permedia 2 (P2RD RAMDAC)
#define DEVICE_FAMILY_ID(id)    ((id) & 0xff)

#define PERMEDIA_REV_1          0x0001
#define PERMEDIA2A_REV_ID       0x0011

//
// Capabilities flags
//
// These are private flags passed to the Permedia2 display driver. They're
// put in the high word of the 'AttributeFlags' field of the
// 'VIDEO_MODE_INFORMATION' structure (found in 'ntddvdeo.h') passed
// to the display driver via an 'VIDEO_QUERY_AVAIL_MODES' or
// 'VIDEO_QUERY_CURRENT_MODE' IOCTL.
//
// NOTE: These definitions must match those in the Permedia2 display driver's
//       'driver.h'!
//

typedef enum {
    CAPS_ZOOM_X_BY2         = 0x00000001,   // Hardware has zoomed by 2 in X
    CAPS_ZOOM_Y_BY2         = 0x00000002,   // Hardware has zoomed by 2 in Y
    CAPS_SPARSE_SPACE       = 0x00000004,   // Framebuffer is sparsely mapped
                                            // (don't allow direct access). The machine
                                            // is probably an Alpha.
    CAPS_SW_POINTER         = 0x00010000,   // No hardware pointer; use software
                                            //  simulation
    CAPS_GLYPH_EXPAND       = 0x00020000,   // Use glyph-expand method to draw
                                            //  text.
    CAPS_RGB525_POINTER     = 0x00040000,   // Use IBM RGB525 cursor
    CAPS_FAST_FILL_BUG      = 0x00080000,   // chip fast fill bug exists
//  CAPS_INTERRUPTS         = 0x00100000,   // interrupts supported
//  CAPS_DMA_AVAILABLE      = 0x00200000,   // DMA is supported
    CAPS_TVP3026_POINTER    = 0x00400000,   // Use TI TVP3026 pointer
    CAPS_8BPP_RGB           = 0x00800000,   // Use RGB in 8bpp mode
    CAPS_RGB640_POINTER     = 0x01000000,   // Use IBM RGB640 cursor
    CAPS_DUAL_GLINT         = 0x02000000,   // Dual-TX board
    CAPS_GLINT2_RAMDAC      = 0x04000000,   // Second TX/MX attached to the RAMDAC
    CAPS_ENHANCED_TX        = 0x08000000,   // TX is in enhanced mode
    CAPS_ACCEL_HW_PRESENT   = 0x10000000,   // Accel Graphics Hardware
    CAPS_TVP4020_POINTER    = 0x20000000,   // Use TI TVP3026 pointer
    CAPS_P2RD_POINTER       = 0x80000000    // Use the 3Dlabs P2RD RAMDAC
} CAPS;


//
// Supported board definitions.
//

typedef enum _PERM2_BOARDS {
    PERMEDIA2_BOARD = 1,
} PERM2_BOARDS;

//
// Supported RAMDAC definitions.
//

typedef enum _PERM2_RAMDACS {
    TVP4020_RAMDAC = 1,
    P2RD_RAMDAC,
} PERM2_RAMDACS;

//
// macros to add padding words to the structures. For the core registers we use
// the tag ids when specifying the pad. So we must multiply by 8 to get a byte
// pad. We need to add an id to make each pad field in the struct unique. The id
// is irrelevant as long as it's different from every other id used in the same
// struct. It's a pity pad##__LINE__ doesn't work.
//

#define PAD(id, n)              UCHAR   pad##id[n]
#define PADRANGE(id, n)         PAD(id, (n)-sizeof(P2_REG))
#define PADCORERANGE(id, n)     PADRANGE(id, (n)<<3)

//
// Permedia2 registers are 32 bits wide and live on 64-bit boundaries.
//

typedef struct {
    ULONG   reg;
    ULONG   pad;
} P2_REG;


//
// Permedia2 PCI Region 0 Address MAP:
//
// All registers are on 64-bit boundaries so we have to define a number of
// padding words. The number given in the comments are offsets from the start
// of the PCI region.
//

typedef struct _p2_region0_map {

    // Control Status Registers:
    P2_REG       ResetStatus;                // 0000h
    P2_REG       IntEnable;                  // 0008h
    P2_REG       IntFlags;                   // 0010h
    P2_REG       InFIFOSpace;                // 0018h
    P2_REG       OutFIFOWords;               // 0020h
    P2_REG       DMAAddress;                 // 0028h
    P2_REG       DMACount;                   // 0030h
    P2_REG       ErrorFlags;                 // 0038h
    P2_REG       VClkCtl;                    // 0040h
    P2_REG       TestRegister;               // 0048h
    union a0 {
        // GLINT
        struct b0 {
            P2_REG       Aperture0;          // 0050h
            P2_REG       Aperture1;          // 0058h
        };
        // PERMEDIA
        struct b1 {
            P2_REG       ApertureOne;        // 0050h
            P2_REG       ApertureTwo;        // 0058h
        };
    };
    P2_REG       DMAControl;                 // 0060h
    P2_REG       DisconnectControl;          // 0068h

    // PERMEDIA only
    P2_REG       ChipConfig;                 // 0070h
    PADRANGE(1, 0x80-0x70);
    P2_REG       OutDMAAddress;              // 0080h
    P2_REG       OutDMACount;                // 0088h
    PADRANGE(1a, 0x800-0x88);

    // GLINTdelta registers. Registers with the same functionality as on GLINT
    // are at the same offset. XXX are not real registers.
    //
    P2_REG       DeltaReset;                 // 0800h
    P2_REG       DeltaIntEnable;             // 0808h
    P2_REG       DeltaIntFlags;              // 0810h
    P2_REG       DeltaInFIFOSpaceXXX;        // 0818h
    P2_REG       DeltaOutFIFOWordsXXX;       // 0820h
    P2_REG       DeltaDMAAddressXXX;         // 0828h
    P2_REG       DeltaDMACountXXX;           // 0830h
    P2_REG       DeltaErrorFlags;            // 0838h
    P2_REG       DeltaVClkCtlXXX;            // 0840h
    P2_REG       DeltaTestRegister;          // 0848h
    P2_REG       DeltaAperture0XXX;          // 0850h
    P2_REG       DeltaAperture1XXX;          // 0858h
    P2_REG       DeltaDMAControlXXX;         // 0860h
    P2_REG       DeltaDisconnectControl;     // 0868h
    PADRANGE(2, 0x1000-0x868);

    // Localbuffer Registers
    union x0 {                               // 1000h
        P2_REG   LBMemoryCtl;                // GLINT
        P2_REG   Reboot;                     // PERMEDIA
    };
    P2_REG       LBMemoryEDO;                // 1008h
    PADRANGE(3, 0x1040-0x1008);

    // PERMEDIA only
    P2_REG       RomControl;                 // 1040h
    PADRANGE(4, 0x1080-0x1040);
    P2_REG       BootAddress;                // 1080h
    PADRANGE(5, 0x10C0-0x1080);
    P2_REG       MemConfig;                  // 10C0h
    PADRANGE(6, 0x1100-0x10C0);
    P2_REG       BypassWriteMask;            // 1100h
    PADRANGE(7, 0x1140-0x1100);
    P2_REG       FramebufferWriteMask;       // 1140h
    PADRANGE(8, 0x1180-0x1140);
    P2_REG       Count;                      // 1180h
    PADRANGE(9, 0x1800-0x1180);

    // Framebuffer Registers
    P2_REG       FBMemoryCtl;                // 1800h
    P2_REG       FBModeSel;                  // 1808h
    P2_REG       FBGCWrMask;                 // 1810h
    P2_REG       FBGCColorMask;              // 1818h
    P2_REG       FBTXMemCtl;                 // 1820h
    PADRANGE(10, 0x2000-0x1820);

    // Graphics Core FIFO Interface
    P2_REG       FIFOInterface;              // 2000h
    PADRANGE(11, 0x3000-0x2000);

    // Internal Video Registers
    union x1 {
        // GLINT
        struct s1 {
            P2_REG   VTGHLimit;              // 3000h
            P2_REG   VTGHSyncStart;          // 3008h
            P2_REG   VTGHSyncEnd;            // 3010h
            P2_REG   VTGHBlankEnd;           // 3018h
            P2_REG   VTGVLimit;              // 3020h
            P2_REG   VTGVSyncStart;          // 3028h
            P2_REG   VTGVSyncEnd;            // 3030h
            P2_REG   VTGVBlankEnd;           // 3038h
            P2_REG   VTGHGateStart;          // 3040h
            P2_REG   VTGHGateEnd;            // 3048h
            P2_REG   VTGVGateStart;          // 3050h
            P2_REG   VTGVGateEnd;            // 3058h
            P2_REG   VTGPolarity;            // 3060h
            P2_REG   VTGFrameRowAddr;        // 3068h
            P2_REG   VTGVLineNumber;         // 3070h
            P2_REG   VTGSerialClk;           // 3078h
        };
        // PERMEDIA
        struct s2 {
            P2_REG   ScreenBase;             // 3000h
            P2_REG   ScreenStride;           // 3008h
            P2_REG   HTotal;                 // 3010h
            P2_REG   HgEnd;                  // 3018h
            P2_REG   HbEnd;                  // 3020h
            P2_REG   HsStart;                // 3028h
            P2_REG   HsEnd;                  // 3030h
            P2_REG   VTotal;                 // 3038h
            P2_REG   VbEnd;                  // 3040h
            P2_REG   VsStart;                // 3048h
            P2_REG   VsEnd;                  // 3050h
            P2_REG   VideoControl;           // 3058h
            P2_REG   InterruptLine;          // 3060h
            P2_REG   DDCData;                // 3068h
            P2_REG   LineCount;              // 3070h
            P2_REG   VFifoCtl;               // 3078h
        };
    };

    P2_REG       VTGModeCtl;                 // 3080h
    PADRANGE(12, 0x4000-0x3080);

    // External Video Control Registers
    // Need to cast this to a struct for a particular video generator
    P2_REG       ExternalVideo;              // 4000h
    PADRANGE(13, 0x4080-0x4000);

    // Mentor Dual-TX clock chip registers
    P2_REG       MentorICDControl;           // 4080h
    // for future: MentorDoubleWrite is at 40C0: 0 = single write, 1 = double
    //             NB must have 2-way interleaved memory
    PADRANGE(14, 0x5800-0x4080);

    // P2 video streams registers
    P2_REG       VSConfiguration;            // 5800h
    PADRANGE(15, 0x6000-0x5800);

    union x2 {
        struct s3 {
            P2_REG   RacerDoubleWrite;       // 6000h
            P2_REG   RacerBankSelect;        // 6008h
            P2_REG   DualTxVgaSwitch;        // 6010h
            P2_REG   DDC1ReadAddress;        // 6018h
        };
        struct s4 {
            // the following array is actually 1024 bytes long
            UCHAR       PermediaVgaCtrl[4*sizeof(P2_REG)];
        };
    };

} P2ControlRegMap, *pP2ControlRegMap;

//
// Permedia2 Interrupt Control Bits
//

//
// InterruptEnable register
//

#define INTR_DISABLE_ALL                0x00
#define INTR_ENABLE_DMA                 0x01
#define INTR_ENABLE_SYNC                0x02
#define INTR_ENABLE_EXTERNAL            0x04
#define INTR_ENABLE_ERROR               0x08
#define INTR_ENABLE_VBLANK              0x10

//
// InterruptFlags register
//

#define INTR_DMA_SET                    0x01
#define INTR_SYNC_SET                   0x02
#define INTR_EXTERNAL_SET               0x04
#define INTR_ERROR_SET                  0x08
#define INTR_VBLANK_SET                 0x10
#define INTR_SVGA_SET                   0X80000000

#define INTR_CLEAR_ALL                  0x1f
#define INTR_CLEAR_DMA                  0x01
#define INTR_CLEAR_SYNC                 0x02
#define INTR_CLEAR_EXTERNAL             0x04
#define INTR_CLEAR_ERROR                0x08
#define INTR_CLEAR_VBLANK               0x10

//
// Macro to declare local variables at the start of any function that wants to
// load Permedia2 registers. Assumes PHW_DEVICE_EXTENSION *hwDeviceExtension 
// has already been declared.
//

#define P2_DECL_VARS \
    pP2ControlRegMap pCtrlRegs

#define P2_DECL \
    pP2ControlRegMap pCtrlRegs = hwDeviceExtension->ctrlRegBase

//
// generic RAMDAC declaration. Used when we have table driven I/O. Must be
// declared after P2_DECL
//

#define RAMDAC_DECL \
    P2_REG *pRAMDAC = &(pCtrlRegs->ExternalVideo)

//
// macros which takes a Permedia2 tag name or control register name and translates
// it to a register address. Data must be written to these addresses using
// VideoPortWriteRegisterUlong and read using VideoPortReadRegisterUlong.
// e.g. dma_count = VideoPortReadRegisterUlong(DMA_COUNT);
//

#define CTRL_REG_ADDR(reg)      ((PULONG)&(pCtrlRegs->reg))

#define CTRL_REG_OFFSET(regAddr)    ((ULONG)(((ULONG_PTR)regAddr) - ((ULONG_PTR)pCtrlRegs)))

//
// defines for the different control registers needed by Permedia2. These macros
// can be used as the address part.
//

#define RESET_STATUS            CTRL_REG_ADDR(ResetStatus)
#define INT_ENABLE              CTRL_REG_ADDR(IntEnable)
#define INT_FLAGS               CTRL_REG_ADDR(IntFlags)
#define IN_FIFO_SPACE           CTRL_REG_ADDR(InFIFOSpace)
#define OUT_FIFO_WORDS          CTRL_REG_ADDR(OutFIFOWords)
#define DMA_ADDRESS             CTRL_REG_ADDR(DMAAddress)
#define DMA_COUNT               CTRL_REG_ADDR(DMACount)
#define DMA_OUT_ADDRESS         CTRL_REG_ADDR(OutDMAAddress)        // P2 only
#define DMA_OUT_COUNT           CTRL_REG_ADDR(OutDMACount)          // P2 only
#define ERROR_FLAGS             CTRL_REG_ADDR(ErrorFlags)
#define V_CLK_CTL               CTRL_REG_ADDR(VClkCtl)
#define TEST_REGISTER           CTRL_REG_ADDR(TestRegister)
#define APERTURE_0              CTRL_REG_ADDR(Aperture0)
#define APERTURE_1              CTRL_REG_ADDR(Aperture1)
#define DMA_CONTROL             CTRL_REG_ADDR(DMAControl)
#define LB_MEMORY_CTL           CTRL_REG_ADDR(LBMemoryCtl)
#define LB_MEMORY_EDO           CTRL_REG_ADDR(LBMemoryEDO)
#define FB_MEMORY_CTL           CTRL_REG_ADDR(FBMemoryCtl)
#define FB_MODE_SEL             CTRL_REG_ADDR(FBModeSel)
#define FB_GC_WRITEMASK         CTRL_REG_ADDR(FBGCWrMask)
#define FB_GC_COLORMASK         CTRL_REG_ADDR(FBGCColorMask)
#define FB_TX_MEM_CTL           CTRL_REG_ADDR(FBTXMemCtl)
#define FIFO_INTERFACE          CTRL_REG_ADDR(FIFOInterface)
#define DISCONNECT_CONTROL      CTRL_REG_ADDR(DisconnectControl)

//
// internal timing registers
//

#define VTG_HLIMIT              CTRL_REG_ADDR(VTGHLimit)
#define VTG_HSYNC_START         CTRL_REG_ADDR(VTGHSyncStart)
#define VTG_HSYNC_END           CTRL_REG_ADDR(VTGHSyncEnd)
#define VTG_HBLANK_END          CTRL_REG_ADDR(VTGHBlankEnd)
#define VTG_VLIMIT              CTRL_REG_ADDR(VTGVLimit)
#define VTG_VSYNC_START         CTRL_REG_ADDR(VTGVSyncStart)
#define VTG_VSYNC_END           CTRL_REG_ADDR(VTGVSyncEnd)
#define VTG_VBLANK_END          CTRL_REG_ADDR(VTGVBlankEnd)
#define VTG_HGATE_START         CTRL_REG_ADDR(VTGHGateStart)
#define VTG_HGATE_END           CTRL_REG_ADDR(VTGHGateEnd)
#define VTG_VGATE_START         CTRL_REG_ADDR(VTGVGateStart)
#define VTG_VGATE_END           CTRL_REG_ADDR(VTGVGateEnd)
#define VTG_POLARITY            CTRL_REG_ADDR(VTGPolarity)
#define VTG_FRAME_ROW_ADDR      CTRL_REG_ADDR(VTGFrameRowAddr)
#define VTG_VLINE_NUMBER        CTRL_REG_ADDR(VTGVLineNumber)
#define VTG_SERIAL_CLK          CTRL_REG_ADDR(VTGSerialClk)
#define VTG_MODE_CTL            CTRL_REG_ADDR(VTGModeCtl)

#define SUSPEND_UNTIL_FRAME_BLANK   (1 << 2)
#define TX_ENHANCED_ENABLE          (1 << 1)

//
// Permedia registers
//

#define APERTURE_ONE            CTRL_REG_ADDR(ApertureOne)
#define APERTURE_TWO            CTRL_REG_ADDR(ApertureTwo)
#define BYPASS_WRITE_MASK       CTRL_REG_ADDR(BypassWriteMask)
#define ROM_CONTROL             CTRL_REG_ADDR(RomControl)
#define BOOT_ADDRESS            CTRL_REG_ADDR(BootAddress)
#define MEM_CONFIG              CTRL_REG_ADDR(MemConfig)
#define CHIP_CONFIG             CTRL_REG_ADDR(ChipConfig)
#define SGRAM_REBOOT            CTRL_REG_ADDR(Reboot)
#define SCREEN_BASE             CTRL_REG_ADDR(ScreenBase)
#define SCREEN_STRIDE           CTRL_REG_ADDR(ScreenStride)
#define H_TOTAL                 CTRL_REG_ADDR(HTotal)
#define HG_END                  CTRL_REG_ADDR(HgEnd)
#define HB_END                  CTRL_REG_ADDR(HbEnd)
#define HS_START                CTRL_REG_ADDR(HsStart)
#define HS_END                  CTRL_REG_ADDR(HsEnd)
#define V_TOTAL                 CTRL_REG_ADDR(VTotal)
#define VB_END                  CTRL_REG_ADDR(VbEnd)
#define VS_START                CTRL_REG_ADDR(VsStart)
#define VS_END                  CTRL_REG_ADDR(VsEnd)
#define VIDEO_CONTROL           CTRL_REG_ADDR(VideoControl)
#define INTERRUPT_LINE          CTRL_REG_ADDR(InterruptLine)
#define DDC_DATA                CTRL_REG_ADDR(DDCData)
#define LINE_COUNT              CTRL_REG_ADDR(LineCount)
#define VIDEO_FIFO_CTL          CTRL_REG_ADDR(VFifoCtl)

//
// Permedia 2 Video Streams registers
//

#define VSTREAM_CONFIG          CTRL_REG_ADDR(VSConfiguration)

// PERMEDIA memory mapped VGA access
#define PERMEDIA_MMVGA_INDEX_REG       ((PVOID)(&(pCtrlRegs->PermediaVgaCtrl[0x3C4])))
#define PERMEDIA_MMVGA_DATA_REG        (&(pCtrlRegs->PermediaVgaCtrl[0x3C5]))
#define PERMEDIA_MMVGA_CRTC_INDEX_REG  ((PVOID)(&(pCtrlRegs->PermediaVgaCtrl[0x3D4])))
#define PERMEDIA_MMVGA_CRTC_DATA_REG   (&(pCtrlRegs->PermediaVgaCtrl[0x3D5]))
#define PERMEDIA_MMVGA_STAT_REG        (&(pCtrlRegs->PermediaVgaCtrl[0x3DA]))

#define PERMEDIA_VGA_CTRL_INDEX       5
#define PERMEDIA_VGA_CR11_INDEX       0x11
#define PERMEDIA_VGA_ENABLE           (1 << 3)
#define PERMEDIA_VGA_INTERRUPT_ENABLE (1 << 2)
#define PERMEDIA_VGA_STAT_VSYNC       (1 << 3)
#define PERMEDIA_VGA_SYNC_INTERRUPT   (1 << 4)

//
// magic bits in the FBMemoryCtl and LBMemoryCtl registers
//

#define LBCTL_RAS_CAS_LOW_MASK      (3 << 3)
#define LBCTL_RAS_CAS_LOW_2_CLK     (0 << 3)
#define LBCTL_RAS_CAS_LOW_3_CLK     (1 << 3)
#define LBCTL_RAS_CAS_LOW_4_CLK     (2 << 3)
#define LBCTL_RAS_CAS_LOW_5_CLK     (3 << 3)

#define LBCTL_RAS_PRECHARGE_MASK    (3 << 5)
#define LBCTL_RAS_PRECHARGE_2_CLK   (0 << 5)
#define LBCTL_RAS_PRECHARGE_3_CLK   (1 << 5)
#define LBCTL_RAS_PRECHARGE_4_CLK   (2 << 5)
#define LBCTL_RAS_PRECHARGE_5_CLK   (3 << 5)

#define LBCTL_CAS_LOW_MASK          (3 << 7)
#define LBCTL_CAS_LOW_1_CLK         (0 << 7)
#define LBCTL_CAS_LOW_2_CLK         (1 << 7)
#define LBCTL_CAS_LOW_3_CLK         (2 << 7)
#define LBCTL_CAS_LOW_4_CLK         (3 << 7)

#define FBCTL_RAS_CAS_LOW_MASK      (3 << 0)
#define FBCTL_RAS_CAS_LOW_2_CLK     (0 << 0)
#define FBCTL_RAS_CAS_LOW_3_CLK     (1 << 0)
#define FBCTL_RAS_CAS_LOW_4_CLK     (2 << 0)
#define FBCTL_RAS_CAS_LOW_5_CLK     (3 << 0)

#define FBCTL_RAS_PRECHARGE_MASK    (3 << 2)
#define FBCTL_RAS_PRECHARGE_2_CLK   (0 << 2)
#define FBCTL_RAS_PRECHARGE_3_CLK   (1 << 2)
#define FBCTL_RAS_PRECHARGE_4_CLK   (2 << 2)
#define FBCTL_RAS_PRECHARGE_5_CLK   (3 << 2)

#define FBCTL_CAS_LOW_MASK          (3 << 4)
#define FBCTL_CAS_LOW_1_CLK         (0 << 4)
#define FBCTL_CAS_LOW_2_CLK         (1 << 4)
#define FBCTL_CAS_LOW_3_CLK         (2 << 4)
#define FBCTL_CAS_LOW_4_CLK         (3 << 4)

//
// DisconnectControl bits
//

#define DISCONNECT_INPUT_FIFO_ENABLE    0x1
#define DISCONNECT_OUTPUT_FIFO_ENABLE   0x2
#define DISCONNECT_INOUT_ENABLE         (DISCONNECT_INPUT_FIFO_ENABLE | \
                                         DISCONNECT_OUTPUT_FIFO_ENABLE)
//
// structure of timing data contained in the registry
//
typedef struct {
    USHORT  HTot;   // Hor Total Time
    UCHAR   HFP;    // Hor Front Porch
    UCHAR   HST;    // Hor Sync Time
    UCHAR   HBP;    // Hor Back Porch
    UCHAR   HSP;    // Hor Sync Polarity
    USHORT  VTot;   // Ver Total Time
    UCHAR   VFP;    // Ver Front Porch
    UCHAR   VST;    // Ver Sync Time
    UCHAR   VBP;    // Ver Back Porch
    UCHAR   VSP;    // Ver Sync Polarity
} VESA_TIMING_STANDARD;

//
// Characteristics of each mode
//

typedef struct _P2_VIDEO_MODES {

    // Leave INT10 fields in for later chips which have VGA
    USHORT Int10ModeNumberContiguous;
    USHORT Int10ModeNumberNoncontiguous;
    ULONG ScreenStrideContiguous;
    VIDEO_MODE_INFORMATION ModeInformation;

} P2_VIDEO_MODES, *PP2_VIDEO_MODES;


//
// Mode-set specific information.
//

//
// for a given (frequency x resolution x depth) combination we have:
// frequency x resolution only dependent initialization
// frequency x resolution x depth dependent initialization
// We split these into 2 tables to save space in the driver.
//

typedef struct _frd_tables {
    PULONG FRTable;
    PULONG FRDTable;
} FRDTable;

typedef struct _P2_VIDEO_FREQUENCIES {

    ULONG BitsPerPel;
    ULONG ScreenWidth;
    ULONG ScreenHeight;
    ULONG ScreenFrequency;

    PP2_VIDEO_MODES ModeEntry;
    ULONG ModeIndex;
    UCHAR ModeValid;

    ULONG PixelClock;

} P2_VIDEO_FREQUENCIES, *PP2_VIDEO_FREQUENCIES;

//
// PCI device information. Used in an IOCTL return. Ensure this is the same
// as in the display drivers
//

typedef struct _P2_Device_Info {
    ULONG SubsystemId;
    ULONG SubsystemVendorId;
    ULONG VendorId;
    ULONG DeviceId;
    ULONG RevisionId;
    ULONG DeltaRevId;
    ULONG GammaRevId;
    ULONG BoardId;
    ULONG LocalbufferLength;
    ULONG LocalbufferWidth;
    ULONG ActualDacId;
} P2_Device_Info;

//
// Definition of the IOCTL_VIDEO_QUERY_LINE_DMA_BUFFER
//

typedef struct _LINE_DMA_BUFFER {

    PHYSICAL_ADDRESS    physAddr;       // physical address of DMA buffer
    PVOID               virtAddr;       // mapped virtual address
    ULONG               size;           // size in bytes
    BOOLEAN             cacheEnabled;   // Whether buffer is cached

} LINE_DMA_BUFFER, *PLINE_DMA_BUFFER;

//
// Definition of the IOCTL_VIDEO_QUERY_EMULATED_DMA_BUFFER
//

typedef struct _EMULATED_DMA_BUFFER {

    PVOID               virtAddr;           // virtual address
    ULONG               size;               // size in bytes
    ULONG               tag;                // allocation tag

} EMULATED_DMA_BUFFER, *PEMULATED_DMA_BUFFER;

//
// The following are the definition for the LUT cache. The aim of the LUT cache
// is to stop sparkling from occurring, bu only writing those LUT entries that
// have changed to the chip, we can only do this by remembering what is already
// down there. The 'mystify' screen saver on P2 demonstrates the problem.
//

#define LUT_CACHE_INIT()        {VideoPortZeroMemory (&(hwDeviceExtension->LUTCache), sizeof (hwDeviceExtension->LUTCache));}
#define LUT_CACHE_SETSIZE(sz)   {hwDeviceExtension->LUTCache.LUTCache.NumEntries = (sz);}
#define LUT_CACHE_SETFIRST(frst){hwDeviceExtension->LUTCache.LUTCache.FirstEntry = (frst);}

#define LUT_CACHE_SETRGB(idx,zr,zg,zb) {    \
    hwDeviceExtension->LUTCache.LUTCache.LookupTable [idx].RgbArray.Red   = (UCHAR) (zr); \
    hwDeviceExtension->LUTCache.LUTCache.LookupTable [idx].RgbArray.Green = (UCHAR) (zg); \
    hwDeviceExtension->LUTCache.LUTCache.LookupTable [idx].RgbArray.Blue  = (UCHAR) (zb); \
}

//
// The LUT cache
//

typedef struct {

    VIDEO_CLUT     LUTCache;        // Header  plus 1 LUT entry
    VIDEO_CLUTDATA LUTData [255];   // the other 255 LUT entries

} LUT_CACHE;

#define MAX_REGISTER_INITIALIZATION_TABLE_ENTRIES 10
#define MAX_REGISTER_INITIALIZATION_TABLE_ULONGS (2 * MAX_REGISTER_INITIALIZATION_TABLE_ENTRIES)

//
// Define device extension structure. This is device dependent/private
// information.
//

typedef struct _HW_DEVICE_EXTENSION {

    pP2ControlRegMap ctrlRegBase;
    PVOID pFramebuffer;
    PVOID pRamdac;
    PHYSICAL_ADDRESS PhysicalFrameAddress;
    ULONG FrameLength;
    PHYSICAL_ADDRESS PhysicalRegisterAddress;
    ULONG RegisterLength;
    UCHAR RegisterSpace;

    PP2_VIDEO_MODES ActiveModeEntry;
    P2_VIDEO_FREQUENCIES ActiveFrequencyEntry;
    PP2_VIDEO_FREQUENCIES FrequencyTable;

    PCI_SLOT_NUMBER pciSlot;
    ULONG pciBus;
    ULONG BoardNumber;
    ULONG DacId;
    ULONG ChipClockSpeed;
    ULONG RefClockSpeed;
    ULONG Capabilities;
    ULONG NumAvailableModes;
    ULONG NumTotalModes;
    ULONG AdapterMemorySize;
    ULONG PhysicalFrameIoSpace;

    P2_Device_Info deviceInfo;

    //
    // Shared memory for communications with the display driver
    //

    P2_INTERRUPT_CTRLBUF InterruptControl;

    //
    // defaults for registry variable values
    //

    ULONG UseSoftwareCursor;
    ULONG P28bppRGB;
    ULONG ExportNon3DModes;
    
    //
    // DMA Buffer definition
    // allocate only one copy of DMA buffer at start of day
    // and keep it until system is shut down or display drivers say goodbye
    //

    ULONG ulLineDMABufferUsage;
    LINE_DMA_BUFFER LineDMABuffer;

    //
    // PCI Config Information
    //

    ULONG bVGAEnabled;
    ULONG bDMAEnabled;
    ULONG PciSpeed;
    VIDEO_ACCESS_RANGE    PciAccessRange[PCI_TYPE0_ADDRESSES+1];

    //
    // Initialisation table
    //

    ULONG aulInitializationTable[MAX_REGISTER_INITIALIZATION_TABLE_ULONGS];
    ULONG culTableEntries;

    //
    // LUT cache
    //

    LUT_CACHE LUTCache;

    BOOLEAN bVTGRunning;
    PP2_VIDEO_FREQUENCIES pFrequencyDefault;

    //
    // state save variables (for during power-saving)
    //

    ULONG VideoControl;
    ULONG IntEnable;       
    ULONG PreviousPowerState;

    BOOLEAN bMonitorPoweredOn;

    //
    // current NT version 
    //

    USHORT NtVersion;
  
    //
    // pointers of VideoPort function that not available on NT4
    //

    PVOID     (*Win2kVideoPortGetRomImage)();
    PVOID     (*Win2kVideoPortGetCommonBuffer)();
    PVOID     (*Win2kVideoPortFreeCommonBuffer)();
    BOOLEAN   (*Win2kVideoPortDDCMonitorHelper)();
    LONG      (FASTCALL *Win2kVideoPortInterlockedExchange)();
    VP_STATUS (*Win2kVideoPortGetVgaStatus)();

    //
    // if the SubSystemId/SubVendorId in PCI config space are read only
    //
    
    BOOLEAN HardwiredSubSystemId;

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

//
// definitions for the purpose of binary level compatable with NT4 
//

#define NT4    400
#define WIN2K  500

#define VideoPortGetRomImage \
        hwDeviceExtension->Win2kVideoPortGetRomImage

#define VideoPortGetCommonBuffer \
        hwDeviceExtension->Win2kVideoPortGetCommonBuffer

#define VideoPortFreeCommonBuffer \
        hwDeviceExtension->Win2kVideoPortFreeCommonBuffer

#define VideoPortDDCMonitorHelper \
        hwDeviceExtension->Win2kVideoPortDDCMonitorHelper

#define VideoPortInterlockedExchange \
        hwDeviceExtension->Win2kVideoPortInterlockedExchange

#define VideoPortGetVgaStatus \
        hwDeviceExtension->Win2kVideoPortGetVgaStatus

//
// Highest valid DAC color register index.
//

#define VIDEO_MAX_COLOR_REGISTER  0xFF
#define MAX_CLUT_SIZE (sizeof(VIDEO_CLUT) + (sizeof(ULONG) * (VIDEO_MAX_COLOR_REGISTER+1)))


//
// Data
//

extern ULONG  bPal8[];
extern ULONG  bPal4[];

extern P2_VIDEO_MODES P2Modes[];
extern ULONG NumP2VideoModes;

//
// Permedia2 Legacy Resources
//
extern VIDEO_ACCESS_RANGE P2LegacyResourceList[];
extern ULONG P2LegacyResourceEntries;

//
// Function prototypes
//

//
// permedia.c
//

BOOLEAN
InitializeVideo(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PP2_VIDEO_FREQUENCIES VideoMode
    );

BOOLEAN
Permedia2AssignResources(
    PVOID HwDeviceExtension,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    ULONG NumRegions,
    PVIDEO_ACCESS_RANGE AccessRange
    );

BOOLEAN
Permedia2AssignResourcesNT4(
    PVOID HwDeviceExtension,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    ULONG NumRegions,
    PVIDEO_ACCESS_RANGE AccessRange
    );

ULONG
DriverEntry (
    PVOID Context1,
    PVOID Context2
    );

VP_STATUS
Permedia2FindAdapter(
    PVOID HwDeviceExtension,
    PVOID HwContext,
    PWSTR ArgumentString,
    PVIDEO_PORT_CONFIG_INFO ConfigInfo,
    PUCHAR Again
     );

BOOLEAN
InitializeAndSizeRAM(
    PVOID HwDeviceExtension,
    PVIDEO_ACCESS_RANGE AccessRange
    );

VOID
ConstructValidModesList(
    PVOID HwDeviceExtension,
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

BOOLEAN
Permedia2Initialize(
    PVOID HwDeviceExtension
    );

BOOLEAN
Permedia2StartIO(
    PVOID HwDeviceExtension,
    PVIDEO_REQUEST_PACKET RequestPacket
    );

BOOLEAN
Permedia2ResetHW(
    PVOID HwDeviceExtension,
    ULONG Columns,
    ULONG Rows
    );

VP_STATUS
Permedia2GetPowerState(
    PVOID HwDeviceExtension,
    ULONG HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

VP_STATUS
Permedia2SetPowerState(
    PVOID HwDeviceExtension,
    ULONG HwId,
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    );

ULONG
Permedia2GetChildDescriptor (
    IN  PVOID HwDeviceExtension,
    IN  PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    OUT PVIDEO_CHILD_TYPE pChildType,
    OUT PVOID  pChildDescriptor,
    OUT PULONG pUId,
    OUT PULONG pUnused
    );

BOOLEAN
PowerOnReset(
            PHW_DEVICE_EXTENSION hwDeviceExtension
            );

VP_STATUS
Permedia2SetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize,
    BOOLEAN ForceRAMDACWrite,
    BOOLEAN UpdateCache
    );

VP_STATUS
Permedia2RegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VP_STATUS
Permedia2RetrieveGammaCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

VOID
Permedia2GetClockSpeeds(
    PVOID HwDeviceExtension
    );

VOID
ZeroMemAndDac(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG RequestedMode
    );

BOOLEAN
Permedia2InitializeInterruptBlock(
    PVOID   HwDeviceExtension
    );

BOOLEAN
Permedia2VidInterrupt(
    PVOID HwDeviceExtension
    );

BOOLEAN
Permedia2InitializeDMABuffers(
    PVOID   HwDeviceExtension
    );

BOOLEAN 
DMAExecute(PVOID Context);

#if DBG
VOID
DumpPCIConfigSpace(
    PVOID HwDeviceExtension,
    ULONG bus,
    ULONG slot
    );
#endif

VOID 
CopyROMInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

VOID 
GenerateInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

VOID 
ProcessInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

BOOLEAN
VerifyBiosSettings(
    PHW_DEVICE_EXTENSION hwDeviceExtension 
    );

LONG 
IntergerToUnicode(
    IN ULONG number,
    OUT PWSTR string
    );

LONG
GetBiosVersion (
     PHW_DEVICE_EXTENSION hwDeviceExtension,
     OUT PWSTR BiosVersion
     );

#if defined(_ALPHA_)
#define abs(a) ( ((LONG)(a)) > 0 ? ((LONG)(a)) : -((LONG)(a)) )
#endif


BOOLEAN 
GetVideoTiming (
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    ULONG xRes, 
    ULONG yRes, 
    ULONG Freq, 
    ULONG Depth,
    VESA_TIMING_STANDARD * VESATimings
    );

LONG BuildFrequencyList (
    PHW_DEVICE_EXTENSION hwDeviceExtension
    );

//
// Registry Strings
//

#define PERM2_EXPORT_HIRES_REG_STRING   L"ExportSingleBufferedModes"

#define IOCTL_VIDEO_MAP_CPERMEDIA \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD0, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_DEVICE_INFO \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD2, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_INTERRUPT_CMD_BUF \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD3, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_STALL_EXECUTION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD4, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_REGISTRY_DWORD \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD5, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_REG_SAVE_GAMMA_LUT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD7, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_REG_RETRIEVE_GAMMA_LUT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD8, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_LINE_DMA_BUFFER \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD9, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_COLOR_REGISTERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DDB, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SLEEP \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DDF, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_INTERLOCKEDEXCHANGE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DD6, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_EMULATED_DMA_BUFFER \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x3DDE, METHOD_BUFFERED, FILE_ANY_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\mini\permmem.c ===
//***************************************************************************
//
//  Module Name:
//
//    permmem.c
//
//  Abstract:
//
//    This module contains code to generate initialize table form ROM
//
//  Environment:
//
//    Kernel mode
//
//
// Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.            
// Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//***************************************************************************

#include "permedia.h"

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,CopyROMInitializationTable)
#pragma alloc_text(PAGE,GenerateInitializationTable)
#pragma alloc_text(PAGE,ProcessInitializationTable)
#pragma alloc_text(PAGE,IntergerToUnicode)
#pragma alloc_text(PAGE,GetBiosVersion)
#endif

VOID 
CopyROMInitializationTable (
    PHW_DEVICE_EXTENSION hwDeviceExtension 
    )

/*++

 Routine Description:
       this function should be called for devices that have an expansion ROM
       which contains a register initialization table. The function assumes
       the ROM is present and enabled.

 Arguments:
     hwDeviceExtension - 
           the device extension of the device whose ROM is to be read
     pvROMAddress - 
           base address of the expansion ROM. This function assumes that 
           the offset to the initialization table is defined at 0x1c from
           the beginning of ROM

 Return: 
     void

--*/
{
    PULONG    pulROMTable;
    PVOID     pvROMAddress;
    ULONG     ulTableOffset;
    ULONG     cEntries;
    PULONG    pul;
    ULONG     ul;


    hwDeviceExtension->culTableEntries = 0;

    //
    // just use default values on NT4
    //

    if(hwDeviceExtension->NtVersion == NT4)
    return;

    //
    // the 2-byte offset to the initialization table is given at 0x1c 
    // from the start of ROM
    //

    pvROMAddress = VideoPortGetRomImage( hwDeviceExtension,
                                         NULL,
                                         0,
                                         0x1c + 2 );

    if(pvROMAddress == NULL)
    {

        DEBUG_PRINT((1, "CopyROMinitializationTable: Can not access ROM\n"));
        return;

    }
    else if ( *(USHORT *)pvROMAddress != 0xAA55)
    {

        DEBUG_PRINT((1, "CopyROMinitializationTable: ROM Signature 0x%x is invalid\n", 
                     *(USHORT *)pvROMAddress ));
        return;

    }

    ulTableOffset = *((PUSHORT)(0x1c + (PCHAR)pvROMAddress));

    //
    // read the table header (32 bits)
    //

    pvROMAddress = VideoPortGetRomImage( hwDeviceExtension,
                                         NULL,
                                         0,
                                         ulTableOffset + 4 );

    if(pvROMAddress == NULL)
    {

        DEBUG_PRINT((1, "CopyROMinitializationTable: Can not access ROM\n"));
        return;
    }


    pulROMTable = (PULONG)(ulTableOffset + (PCHAR)pvROMAddress);

    //
    // the table header (32 bits) has an identification code and a count 
    // of the number of entries in the table
    //

    if((*pulROMTable >> 16) != 0x3d3d)
    {
        DEBUG_PRINT((1, "CopyROMinitializationTable: invalid initialization table header\n"));
        return;
    }

    //
    // number of register address & data pairs
    //

    cEntries = *pulROMTable & 0xffff; 

    if(cEntries == 0)
    {
        DEBUG_PRINT((1, "CopyROMinitializationTable: empty initialization table\n"));
        return;
    }

    //
    // this assert, and the one after the copy should ensure we don't write 
    // past the end of the table
    //

    P2_ASSERT(cEntries * sizeof(ULONG) * 2 <= sizeof(hwDeviceExtension->aulInitializationTable),
              "ERROR: too many initialization entries\n");


    pvROMAddress = VideoPortGetRomImage( hwDeviceExtension,
                                         NULL,
                                         0,
                                         ulTableOffset + 4 + cEntries * sizeof(ULONG) * 2 );

    if(pvROMAddress == NULL)
    {
        DEBUG_PRINT((1, "CopyROMinitializationTable: Can not access ROM\n"));
        return;
    }

    //
    // each entry contains two 32-bit words
    //

    pul = hwDeviceExtension->aulInitializationTable;

    //
    // skip the 4 bype table header
    //

    pulROMTable = (PULONG)(ulTableOffset + 4 + (PCHAR)pvROMAddress);

    ul  = cEntries << 1;

    while(ul--)
    {
        *pul++ = *pulROMTable;
        ++pulROMTable;
    }

    hwDeviceExtension->culTableEntries = 
            (ULONG)(pul - (ULONG *)hwDeviceExtension->aulInitializationTable) >> 1;

    P2_ASSERT(cEntries == hwDeviceExtension->culTableEntries,
                 "ERROR: generated different size init table to that expected\n");

#if DBG

    //
    // output the initialization table
    //

    pul = hwDeviceExtension->aulInitializationTable;
    ul  = hwDeviceExtension->culTableEntries;

    while(ul--)
    {
        ULONG ulReg;
        ULONG ulRegData;

        ulReg = *pul++;
        ulRegData = *pul++;
        DEBUG_PRINT((2, "CopyROMInitializationTable: initializing register %08.8Xh with %08.8Xh\n",
                         ulReg, ulRegData));
    }

#endif //DBG

}

VOID 
GenerateInitializationTable (
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

/*++

 Routine Description:
     creates a register initialization table (called if we can't read one
     from ROM). If VGA is enabled the registers are already initialized so
     we just read them back, otherwise we have to use default values

 Arguments:
     hwDeviceExtension - the device for which we are creating the table

 Return: 
     void

--*/
{
    ULONG    cEntries;
    PULONG   pul;
    ULONG    ul;
    int      i, j;
    P2_DECL;

    hwDeviceExtension->culTableEntries = 0;

    cEntries = 6;

    //
    // this assert, and the one after the copy should ensure we don't 
    // write past the end of the table
    //

    P2_ASSERT(cEntries * sizeof(ULONG) * 2 <= sizeof(hwDeviceExtension->aulInitializationTable),
                 "ERROR: to many initialization entries\n");

    //
    // each entry contains two 32-bit words
    //

    pul = hwDeviceExtension->aulInitializationTable;

    if(hwDeviceExtension->bVGAEnabled)
    {
        //
        // OK: no initialization table but VGA is running so our key 
        // registers have been initialized to sensible values
        //

        DEBUG_PRINT((1, "GenerateinitializationTable: VGA enabled: reading registers\n"));

        //
        // key entries are: ROM control, Boot Address, Memory Config and 
        // VStream Config
        //

        *pul++ = CTRL_REG_OFFSET(ROM_CONTROL);
        *pul++ = VideoPortReadRegisterUlong(ROM_CONTROL);

        *pul++ = CTRL_REG_OFFSET(BOOT_ADDRESS);
        *pul++ = VideoPortReadRegisterUlong(BOOT_ADDRESS);

        *pul++ = CTRL_REG_OFFSET(MEM_CONFIG);
        *pul++ = VideoPortReadRegisterUlong(MEM_CONFIG);

        *pul++ = CTRL_REG_OFFSET(VSTREAM_CONFIG);
        *pul++ = VideoPortReadRegisterUlong(VSTREAM_CONFIG);

        *pul++ = CTRL_REG_OFFSET(VIDEO_FIFO_CTL);
        *pul++ = VideoPortReadRegisterUlong(VIDEO_FIFO_CTL);

        *pul++ = CTRL_REG_OFFSET(V_CLK_CTL);
        *pul++ = VideoPortReadRegisterUlong(V_CLK_CTL);
    }
    else
    {
        //
        // no initialization table and no VGA. Use default values.
        //

        DEBUG_PRINT((2, "PERM2: GenerateInitializationTable() VGA disabled - using default values\n"));

        *pul++ = CTRL_REG_OFFSET(ROM_CONTROL);
        *pul++ = 0;

        *pul++ = CTRL_REG_OFFSET(BOOT_ADDRESS);
        *pul++ = 0x20;

        *pul++ = CTRL_REG_OFFSET(MEM_CONFIG);
        *pul++ = 0xe6002021;

        *pul++ = CTRL_REG_OFFSET(VSTREAM_CONFIG);
        *pul++ = 0x1f0;

        *pul++ = CTRL_REG_OFFSET(VIDEO_FIFO_CTL);
        *pul++ = 0x11008;

        *pul++ = CTRL_REG_OFFSET(V_CLK_CTL);

        if( DEVICE_FAMILY_ID(hwDeviceExtension->deviceInfo.DeviceId )
                                                 == PERMEDIA_P2S_ID )
        {
            *pul++ = 0x80;
        }
        else
        {
            *pul++ = 0x40;
        }
    }

    hwDeviceExtension->culTableEntries = 
         (ULONG)(pul - (ULONG *)hwDeviceExtension->aulInitializationTable) >> 1;

    P2_ASSERT(cEntries == hwDeviceExtension->culTableEntries,
          "ERROR: generated different size init table to that expected\n");

#if DBG

    //
    // output the initialization table
    //

    pul = hwDeviceExtension->aulInitializationTable;
    ul = hwDeviceExtension->culTableEntries;

    while(ul--)
    {
        ULONG ulReg;
        ULONG ulRegData;

        ulReg = *pul++;
        ulRegData = *pul++;
        DEBUG_PRINT((2, "GenerateInitializationTable: initializing register %08.8Xh with %08.8Xh\n",
                         ulReg, ulRegData));
    }

#endif //DBG

}

VOID 
ProcessInitializationTable(
    PHW_DEVICE_EXTENSION hwDeviceExtension 
    )

/*++

 Routine Description:
     this function processes the register initialization table

 Arguments:
     hwDeviceExtension - a pointer to the device extension.

 Return: 
     void

--*/

{
    PULONG   pul;
    ULONG    cul;
    ULONG    ulRegAddr, ulRegData;
    PULONG   pulReg;
    ULONG    BaseAddrSelect;
    P2_DECL;

    pul = (PULONG)hwDeviceExtension->aulInitializationTable;
    cul = hwDeviceExtension->culTableEntries;

    while(cul--)
    {
        ulRegAddr = *pul++;
        ulRegData = *pul++;

        BaseAddrSelect = ulRegAddr >> 29;

        if(BaseAddrSelect == 0)
        {
            //
            // the offset is from the start of the control registers
            //

            pulReg = (PULONG)((ULONG_PTR)pCtrlRegs + (ulRegAddr & 0x3FFFFF));
        }
        else
        {
            DEBUG_PRINT((2, "ProcessInitializationTable: Invalid base address select %d regAddr = %d regData = %d\n",
                             BaseAddrSelect, ulRegAddr, ulRegData));
            continue;
        }

        DEBUG_PRINT((2, "ProcessInitializationTable: initializing (region %d) register %08.8Xh with %08.8Xh\n",
                         BaseAddrSelect, pulReg, ulRegData));

        VideoPortWriteRegisterUlong(pulReg, ulRegData);
    }

    //
    // We need a small delay after initializing the above registers
    //

    VideoPortStallExecution(5);
}

BOOLEAN
VerifyBiosSettings(
    PHW_DEVICE_EXTENSION hwDeviceExtension 
    )

/*++

 Routine Description:
     This function validate a few register values set by bios at boot time

 Arguments:
     hwDeviceExtension - a pointer to the device extension.

 Return: 
     TRUE  - if the everything is all right
     FALSE - if some of the values don't match those in initialization table

--*/

{
    PULONG   pul;
    ULONG    cul;
    ULONG    ulRegAddr, ulRegData;
    PULONG   pulReg;
    ULONG    BaseAddrSelect;
    P2_DECL;

    pul = (PULONG)hwDeviceExtension->aulInitializationTable;
    cul = hwDeviceExtension->culTableEntries;

    while(cul--)
    {
        ulRegAddr = *pul++;
        ulRegData = *pul++;

        BaseAddrSelect = ulRegAddr >> 29;

        if(BaseAddrSelect == 0)
        {
            //
            // the offset is from the start of the control registers
            //

            pulReg = (PULONG)((ULONG_PTR)pCtrlRegs + (ulRegAddr & 0x3FFFFF));           

            //
            // we only care above these registers
            //

            if ( ( pulReg != BOOT_ADDRESS ) && (pulReg != MEM_CONFIG) )
            {
                continue;
            }
        
        }
        else
        {
            DEBUG_PRINT((2, "VerifyBiosSettings: Invalid base address select %d regAddr = %d regData = %d\n",
                             BaseAddrSelect, ulRegAddr, ulRegData));
            continue;
        }

        if( ulRegData != VideoPortReadRegisterUlong(pulReg) )
        {

            DEBUG_PRINT((1, "VerifyBiosSettings: Bios failed to set some registers correctly. \n"));
            return (FALSE);
        }
    }

    return (TRUE);
}


LONG 
GetBiosVersion (
    PHW_DEVICE_EXTENSION hwDeviceExtension, 
    OUT PWSTR BiosVersionString
    )

/*++

 Routine Description:

     this function get the bios version and convert it to a unicode string

 Return: 

     lenth of bios version string in bytes

--*/

{

    PVOID     pvROMAddress;
    ULONG     len, ulVersion;
    PCHAR     pByte;


    BiosVersionString[0] = L'\0' ; 

    //
    // just return on NT4
    //

    if( hwDeviceExtension->NtVersion == NT4 )
    {
        return 0;
    }

    //
    // bios version is stored at offset 7 and 8 
    //

    pvROMAddress = VideoPortGetRomImage( hwDeviceExtension,
                                         NULL,
                                         0,
                                         7 + 2 );

    if( pvROMAddress == NULL )
    {

        DEBUG_PRINT((1, "GetBiosVersion: Can not access ROM\n"));
        return 0;
    }
    else if ( *(USHORT *)pvROMAddress != 0xAA55)
    {

        DEBUG_PRINT(( 2, "GetBiosVersion: ROM Signature 0x%x is invalid\n", 
                     *(USHORT *)pvROMAddress ));
        return 0;
    }

    pByte = ( PCHAR ) pvROMAddress;

    //
    // get major version number at offset 7
    //

    ulVersion = (ULONG) pByte[7];

    len = IntergerToUnicode( ulVersion, (PWSTR) (&BiosVersionString[0]));

    //
    // a dot between major and minor version number
    //

    BiosVersionString[len] =  L'.' ; 

    len++;
    
    //
    // get minor version number at offset 8
    //

    ulVersion = (ULONG) pByte[8];

    len = len + IntergerToUnicode( ulVersion, (PWSTR) (&BiosVersionString[len]) );

    //
    // len is the number of unicodes in string, we need to return 
    // the string size in bytes
    //

    return (len * sizeof(WCHAR) );

}

LONG 
IntergerToUnicode(
    IN  ULONG Number,
    OUT PWSTR UnicodeString
    )

/*++

 Routine Description:

     this function convert an unsigned long to a unicode string

 Return: 

     the number of the unicodes in UnicodeString


--*/

{
    const WCHAR digits[] = L"0123456789";

    LONG i, len;

    //
    // a ULONG decimal integer will not exceed 10 digits
    //

    WCHAR tmpString[10];

    i = 10;
    len = 0;

    do
    {
        tmpString[--i] = digits[ Number % 10 ];

        Number /= 10;
        len++;

    } while ( Number );

    VideoPortMoveMemory(UnicodeString, &tmpString[i], sizeof(WCHAR) * len  );

    UnicodeString[len] = L'\0' ; 

    return( len );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm2\mini\power.c ===
//***************************************************************************
//
// Module Name:
//
//   power.c
//
// Abstract:
//   This module contains the code that implements the Plug & Play and 
//   power management features
//
// Environment:
//
//   Kernel mode
//
//
// Copyright (c) 1994-1998 3Dlabs Inc. Ltd. All rights reserved.            
// Copyright (c) 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
//***************************************************************************

#include "permedia.h"

#define VESA_POWER_FUNCTION   0x4f10
#define VESA_POWER_ON         0x0000
#define VESA_POWER_STANDBY    0x0100
#define VESA_POWER_SUSPEND    0x0200
#define VESA_POWER_OFF        0x0400
#define VESA_GET_POWER_FUNC   0x0000
#define VESA_SET_POWER_FUNC   0x0001
#define VESA_STATUS_SUCCESS   0x004f

//
// all our IDs begin with 0x1357bd so they are readily identifiable as our own
//

#define P2_DDC_MONITOR        (0x1357bd00)
#define P2_NONDDC_MONITOR     (0x1357bd01)

BOOLEAN PowerOnReset( PHW_DEVICE_EXTENSION hwDeviceExtension );
VOID    SaveDeviceState( PHW_DEVICE_EXTENSION hwDeviceExtension );
VOID    RestoreDeviceState( PHW_DEVICE_EXTENSION hwDeviceExtension );

VOID    I2CWriteClock(PVOID HwDeviceExtension, UCHAR data);
VOID    I2CWriteData(PVOID HwDeviceExtension, UCHAR data);
BOOLEAN I2CReadClock(PVOID HwDeviceExtension);
BOOLEAN I2CReadData(PVOID HwDeviceExtension);
VOID    I2CWaitVSync(PVOID HwDeviceExtension);

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE, PowerOnReset)
#pragma alloc_text(PAGE, SaveDeviceState)
#pragma alloc_text(PAGE, RestoreDeviceState)
#pragma alloc_text(PAGE, Permedia2GetPowerState)
#pragma alloc_text(PAGE, Permedia2SetPowerState)
#pragma alloc_text(PAGE, Permedia2GetChildDescriptor)
#pragma alloc_text(PAGE, I2CWriteClock) 
#pragma alloc_text(PAGE, I2CWriteData) 
#pragma alloc_text(PAGE, I2CReadClock) 
#pragma alloc_text(PAGE, I2CReadData)  
#pragma alloc_text(PAGE, I2CWaitVSync)
#endif


I2C_FNC_TABLE I2CFunctionTable = 
{
    sizeof(I2C_FNC_TABLE), 
    I2CWriteClock, 
    I2CWriteData, 
    I2CReadClock, 
    I2CReadData,  
    I2CWaitVSync, 
    NULL
};


VP_STATUS Permedia2GetPowerState (
    PVOID HwDeviceExtension, 
    ULONG HwId, 
    PVIDEO_POWER_MANAGEMENT VideoPowerControl 
    )

/*++

Routine Description:

    Returns power state information.

Arguments:

    HwDeviceExtension    - Pointer to our hardware device extension structure.

    HwId                 - Private unique 32 bit ID identifing the device.

    VideoPowerControl    - Points to a VIDEO_POWER_MANAGEMENT structure that 
                           specifies the power state for which support is 
                           being queried. 

Return Value:

    VP_STATUS value (NO_ERROR or error value)

--*/

{
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    VP_STATUS status;
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    DEBUG_PRINT((2, "Permedia2GetPowerState: hwId(%xh) state = %d\n", 
                     (int)HwId, (int)VideoPowerControl->PowerState));

    switch((int)HwId)
    {
        case P2_DDC_MONITOR:
        case P2_NONDDC_MONITOR:

            switch (VideoPowerControl->PowerState)
            {

                case VideoPowerOn:
                case VideoPowerStandBy:
                case VideoPowerSuspend:
                case VideoPowerOff:
                case VideoPowerHibernate:
                case VideoPowerShutdown:

                    status = NO_ERROR;
                    break;

                default:

                    DEBUG_PRINT((2, "Permedia2GetPowerState: Unknown monitor PowerState(%xh)\n", 
                                    (int)VideoPowerControl->PowerState));

                    ASSERT(FALSE);
                    status = ERROR_INVALID_PARAMETER;
            }
            break;

        case DISPLAY_ADAPTER_HW_ID:

            //
            // only support ON at the moment
            //

            switch (VideoPowerControl->PowerState)
            {
                case VideoPowerOn:
                case VideoPowerStandBy:
                case VideoPowerSuspend:
                case VideoPowerHibernate:
                case VideoPowerShutdown:
                    status = NO_ERROR;
                    break;

                case VideoPowerOff:

                    if( hwDeviceExtension->HardwiredSubSystemId )
                    {
                        status = NO_ERROR;
                    } 
                    else
                    {
                        //
                        // If SubSystemId is not hardwired in a read-only way, 
                        // it is possible we'll see a different value when 
                        // system comes back form S3 mode. This will cause 
                        // problem since os will assume this is a different 
                        // device 
                        //

                        DEBUG_PRINT((2, "Permedia2GetPowerState: VideoPowerOff is not suported by this card!\n"));
 
                        status = ERROR_INVALID_FUNCTION;
                    }

                    break;
 

                default:

                    DEBUG_PRINT((2, "Permedia2GetPowerState: Unknown adapter PowerState(%xh)\n", 
                                 (int)VideoPowerControl->PowerState));

                    ASSERT(FALSE);

                    status = ERROR_INVALID_PARAMETER;

            }
            break;

        default:

            DEBUG_PRINT((1, "Permedia2GetPowerState: Unknown hwId(%xh)", 
                            (int)HwId));
            ASSERT(FALSE);

            status = ERROR_INVALID_PARAMETER;
    }

    DEBUG_PRINT((2, "Permedia2GetPowerState: returning %xh\n", status));

    return(status);
}

VP_STATUS Permedia2SetPowerState ( 
    PVOID HwDeviceExtension, 
    ULONG HwId, 
    PVIDEO_POWER_MANAGEMENT VideoPowerControl
    )

/*++

Routine Description:

    Set the power state for a given device.

Arguments:

    HwDeviceExtension - Pointer to our hardware device extension structure.

    HwId              - Private unique 32 bit ID identifing the device.

    VideoPowerControl - Points to a VIDEO_POWER_MANAGEMENT structure that 
                        specifies the power state to be set. 

Return Value:

    VP_STATUS value (NO_ERROR, if all's well)

--*/

{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG Polarity;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    VP_STATUS status;
    P2_DECL;

    DEBUG_PRINT((2, "Permedia2SetPowerState: hwId(%xh) state = %d\n", 
                     (int)HwId, (int)VideoPowerControl->PowerState));

    switch((int)HwId)
    {

        case P2_DDC_MONITOR:
        case P2_NONDDC_MONITOR:

            Polarity = VideoPortReadRegisterUlong(VIDEO_CONTROL);

            Polarity &= ~((1 << 5) | (1 << 3) | 1);

            switch (VideoPowerControl->PowerState)
            {

                case VideoPowerHibernate:
                case VideoPowerShutdown:

                    //
                    // Do nothing for hibernate as the monitor must stay on.
                    //

                    status = NO_ERROR;
                    break;

                case VideoPowerOn:

                    RestoreDeviceState(hwDeviceExtension);
                    status = NO_ERROR;
                    break;

                case VideoPowerStandBy:

                    //
                    // hsync low, vsync active high, video disabled
                    //

                    SaveDeviceState(hwDeviceExtension);
                    VideoPortWriteRegisterUlong(VIDEO_CONTROL, 
                                                Polarity | (1 << 5) | (2 << 3) | 0);

                    status = NO_ERROR;
                    break;

                case VideoPowerSuspend:

                    //
                    // vsync low, hsync active high, video disabled
                    //

                    VideoPortWriteRegisterUlong(VIDEO_CONTROL, 
                                                Polarity | (2 << 5) | (1 << 3) | 0);

                    status = NO_ERROR;
                    break;

                case VideoPowerOff:

                    //
                    // vsync low, hsync low, video disabled
                    //

                    VideoPortWriteRegisterUlong(VIDEO_CONTROL, 
                                                Polarity | (2 << 5) | (2 << 3) | 0);

                    status = NO_ERROR;
                    break;

                default:

                    DEBUG_PRINT((2, "Permedia2GetPowerState: Unknown monitor PowerState(%xh)\n", 
                                     (int)VideoPowerControl->PowerState));

                    ASSERT(FALSE);
                    status = ERROR_INVALID_PARAMETER;
            }

            //
            // Track the current monitor power state
            //

            hwDeviceExtension->bMonitorPoweredOn =
                (VideoPowerControl->PowerState == VideoPowerOn) ||
                (VideoPowerControl->PowerState == VideoPowerHibernate);

            Polarity = VideoPortReadRegisterUlong(VIDEO_CONTROL);

            break;

        case DISPLAY_ADAPTER_HW_ID:

            switch (VideoPowerControl->PowerState)
            {
                case VideoPowerHibernate:
                    status = NO_ERROR;
                    break;

                case VideoPowerShutdown:

                    //
                    // We need to make sure no interrupts will be generated
                    // after the device being powered down
                    //

                    VideoPortWriteRegisterUlong(INT_ENABLE, 0);

                    status = NO_ERROR;
                    break;

                case VideoPowerOn:

                    if ((hwDeviceExtension->PreviousPowerState == VideoPowerOff) ||
                        (hwDeviceExtension->PreviousPowerState == VideoPowerSuspend) ||
                        (hwDeviceExtension->PreviousPowerState == VideoPowerHibernate))
                    {
                        PowerOnReset(hwDeviceExtension);
                    }

                    status = NO_ERROR;
                    break;

                case VideoPowerStandBy:

                    status = NO_ERROR;
                    break;

                case VideoPowerSuspend:

                    status = NO_ERROR;
                    break;
    
                case VideoPowerOff:

                    status = NO_ERROR;
                    break;

                default:

                    DEBUG_PRINT((2, "Permedia2GetPowerState: Unknown adapter PowerState(%xh)\n", 
                                     (int)VideoPowerControl->PowerState));

                    ASSERT(FALSE);
                    status = ERROR_INVALID_PARAMETER;
            }

            hwDeviceExtension->PreviousPowerState = 
                    VideoPowerControl->PowerState;

            break;
    
        default:

            DEBUG_PRINT((1, "Permedia2SetPowerState: Unknown hwId(%xh)\n", 
                             (int)HwId));

            ASSERT(FALSE);
            status = ERROR_INVALID_PARAMETER;
    }

    return(status);

}


BOOLEAN PowerOnReset(
    PHW_DEVICE_EXTENSION hwDeviceExtension
    )

/*++

Routine Description:

   Called when the adapter is powered on 

--*/

{
    int      i;
    ULONG    ulValue;
    BOOLEAN  bOK;
    P2_DECL;

    if(!hwDeviceExtension->bVGAEnabled ||
       !hwDeviceExtension->bDMAEnabled)
    {
        PCI_COMMON_CONFIG  PciData;

        //
        // in a multi-adapter system we'll need to turn on the DMA and 
        // memory space for the secondary adapters
        //

        DEBUG_PRINT((1, "PowerOnReset() enabling memory space access for the secondary card\n"));

        VideoPortGetBusData( hwDeviceExtension, 
                             PCIConfiguration, 
                             0, 
                             &PciData, 
                             0, 
                             PCI_COMMON_HDR_LENGTH);

        PciData.Command |= PCI_ENABLE_MEMORY_SPACE;
        PciData.Command |= PCI_ENABLE_BUS_MASTER; 

        VideoPortSetBusData( hwDeviceExtension, 
                             PCIConfiguration, 
                             0, 
                             &PciData, 
                             0, 
                             PCI_COMMON_HDR_LENGTH );

#if DBG
        DumpPCIConfigSpace(hwDeviceExtension, hwDeviceExtension->pciBus, 
                            (ULONG)hwDeviceExtension->pciSlot.u.AsULONG);
#endif

    }

    //
    // While waking up from hibernation, we usually don't need
    // to reset perm2 and call ProcessInitializationTable()
    // for the primary card since video bios will get posted. 
    // We do so here because we saw cases that the perm2 bios 
    // failed to worked correctly on some machines. 
    //

    //
    // reset the device
    //

    VideoPortWriteRegisterUlong(RESET_STATUS, 0);

    for(i = 0; i < 100000; ++i)
    {
        ulValue = VideoPortReadRegisterUlong(RESET_STATUS);

        if (ulValue == 0)
            break;
    }

    if(ulValue)
    {
        DEBUG_PRINT((1, "PowerOnReset() Read RESET_STATUS(%xh) - failed to reset\n", 
                         ulValue));

        ASSERT(FALSE);
        bOK = FALSE;
    }
    else
    {
        //
        // reload registers given in ROM
        //

        if(hwDeviceExtension->culTableEntries)
        {
            ProcessInitializationTable(hwDeviceExtension);
        }

        //
        // set-up other registers not set in InitializeVideo
        //

        VideoPortWriteRegisterUlong(BYPASS_WRITE_MASK, 0xFFFFFFFF);
        VideoPortWriteRegisterUlong(APERTURE_ONE, 0x0);
        VideoPortWriteRegisterUlong(APERTURE_TWO, 0x0);    

        bOK = TRUE;

    }

    return(bOK);

}


VOID SaveDeviceState(PHW_DEVICE_EXTENSION hwDeviceExtension)

/*++

Routine Description:

    Save any registers that will be destroyed when we power down the monitor

--*/

{
    P2_DECL;

    DEBUG_PRINT((2, "SaveDeviceState() called\n"));
    
    //
    // hwDeviceExtension->VideoControl should be set in InitializeVideo,
    // just in case we get here before InitializeVideo
    //

    if( !(hwDeviceExtension->VideoControl) )
    {
        hwDeviceExtension->VideoControl = 
               VideoPortReadRegisterUlong(VIDEO_CONTROL);
    }

    hwDeviceExtension->IntEnable = VideoPortReadRegisterUlong(INT_ENABLE);

}


VOID RestoreDeviceState(PHW_DEVICE_EXTENSION hwDeviceExtension)

/*++

Routine Description:

    Restore registers saved before monitor power down

--*/

{
    P2_DECL;

    DEBUG_PRINT((2, "RestoreDeviceState() called\n"));
    VideoPortWriteRegisterUlong(VIDEO_CONTROL, hwDeviceExtension->VideoControl);
    VideoPortWriteRegisterUlong(INT_ENABLE, hwDeviceExtension->IntEnable);

}


ULONG
Permedia2GetChildDescriptor( 
    PVOID HwDeviceExtension,
    PVIDEO_CHILD_ENUM_INFO ChildEnumInfo,
    PVIDEO_CHILD_TYPE pChildType,  
    PVOID pChildDescriptor, 
    PULONG pUId, 
    PULONG pUnused )


/*++

Routine Description:

    Enumerate all child devices controlled by the Permedia 2 chip.

    This includes DDC monitors attached to the board, as well as other devices
    which may be connected to a proprietary bus.

Arguments:

    HwDeviceExtension -
        Pointer to our hardware device extension structure.

    ChildEnumInfo - 
        Information about the device that should be enumerated.

    pChildType -
        Type of child we are enumerating - monitor, I2C ...

    pChildDescriptor -
        Identification structure of the device (EDID, string)

    pUId -
        Private unique 32 bit ID to passed back to the miniport

    pUnused -
        Do not use

Return Value:

    ERROR_NO_MORE_DEVICES -
        if no more child devices exist.

    ERROR_INVALID_NAME -
        The miniport could not enumerate the child device identified in 
        ChildEnumInfo but does have more devices to be enumerated. 

    ERROR_MORE_DATA - 
        There are more devices to be enumerated. 

Note:

    In the event of a failure return, none of the fields are valid except for
    the return value and the pMoreChildren field.

--*/


{

    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    DEBUG_PRINT((2, "Permedia2GetChildDescriptor called\n"));

    switch (ChildEnumInfo->ChildIndex) 
    {
        case 0:

            //
            // Case 0 is used to enumerate devices found by the ACPI firmware.
            // We do not currently support ACPI devices
            //

            return ERROR_NO_MORE_DEVICES;

        case 1:

            //
            // Treat index 1 as the monitor
            //

            *pChildType = Monitor;

            //
            // if it's a DDC monitor we return its EDID in pjBuffer
            // (always 128 bytes)
            //

            if(VideoPortDDCMonitorHelper(HwDeviceExtension,
                                         &I2CFunctionTable,
                                         pChildDescriptor,
                                         ChildEnumInfo->ChildDescriptorSize))
            {
                //
                // found a DDC monitor
                //

                DEBUG_PRINT((2, "Permedia2GetChildDescriptor: found a DDC monitor\n"));

                *pUId = P2_DDC_MONITOR;
            }
            else
            {
                //
                // failed: assume non-DDC monitor
                //

                DEBUG_PRINT((2, "Permedia2GetChildDescriptor: found a non-DDC monitor\n"));

                *pUId = P2_NONDDC_MONITOR;

            }

            return ERROR_MORE_DATA;

        default:

            return ERROR_NO_MORE_DEVICES;
    }
}


VOID I2CWriteClock(PVOID HwDeviceExtension, UCHAR data)
{
    const ULONG nbitClock = 3;
    const ULONG Clock = 1 << nbitClock;

    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ul;
    P2_DECL;

    ul = VideoPortReadRegisterUlong(DDC_DATA);
    ul &= ~Clock;
    ul |= (data & 1) << nbitClock;
    VideoPortWriteRegisterUlong(DDC_DATA, ul);
}

VOID I2CWriteData(PVOID HwDeviceExtension, UCHAR data)
{
    const ULONG nbitData = 2;
    const ULONG Data = 1 << nbitData;

    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ul;
    P2_DECL;

    ul = VideoPortReadRegisterUlong(DDC_DATA);
    ul &= ~Data;
    ul |= ((data & 1) << nbitData);
    VideoPortWriteRegisterUlong(DDC_DATA, ul);
}

BOOLEAN I2CReadClock(PVOID HwDeviceExtension)
{
    const ULONG nbitClock = 1;
    const ULONG Clock = 1 << nbitClock;
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ul;
    P2_DECL;

    ul = VideoPortReadRegisterUlong(DDC_DATA);
    ul &= Clock;
    ul >>= nbitClock;

    return((BOOLEAN)ul);
}

BOOLEAN I2CReadData(PVOID HwDeviceExtension)
{
    const ULONG nbitData = 0;
    const ULONG Data = 1 << nbitData;
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    ULONG ul;
    P2_DECL;

    ul = VideoPortReadRegisterUlong(DDC_DATA);
    ul &= Data;
    ul >>= nbitData;
    return((BOOLEAN)ul);
}

VOID I2CWaitVSync(PVOID HwDeviceExtension)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    UCHAR jIndexSaved, jStatus;
    P2_DECL;
    
    if(hwDeviceExtension->bVGAEnabled)
    {

        //
        // VGA run on this board, is it currently in VGA or VTG mode?
        //

        jIndexSaved = VideoPortReadRegisterUchar(PERMEDIA_MMVGA_INDEX_REG);

        VideoPortWriteRegisterUchar(PERMEDIA_MMVGA_INDEX_REG, 
                                    PERMEDIA_VGA_CTRL_INDEX);

        jStatus = VideoPortReadRegisterUchar(PERMEDIA_MMVGA_DATA_REG);

        VideoPortWriteRegisterUchar(PERMEDIA_MMVGA_INDEX_REG, jIndexSaved);

    }
    else
    {
        //
        // VGA not run
        //

        jStatus = 0;

    }

    
    if(jStatus & PERMEDIA_VGA_ENABLE)
    {
        //
        // in VGA, so check VSync via the VGA registers
        // 1. if we're in VSync, wait for it to end
        //

        while( (VideoPortReadRegisterUchar(PERMEDIA_MMVGA_STAT_REG) & 
                PERMEDIA_VGA_STAT_VSYNC) == 1); 

        //
        // 2. wait for the start of VSync
        //

        while( (VideoPortReadRegisterUchar(PERMEDIA_MMVGA_STAT_REG) & 
                PERMEDIA_VGA_STAT_VSYNC) == 0); 
    }
    else
    {
        if(!hwDeviceExtension->bVTGRunning)
        {

            //
            // time to set-up the VTG - we'll need a valid mode to do this, 
            // so we;ll choose 640x480x8 we get here (at boot-up only) if 
            // the secondary card has VGA disabled: GetChildDescriptor is 
            // called before InitializeVideo so that the VTG hasn't been 
            // programmed yet
            //

            DEBUG_PRINT((2, "I2CWaitVSync() - VGA nor VTG running: attempting to setup VTG\n"));

            if(hwDeviceExtension->pFrequencyDefault == NULL)
            {
                DEBUG_PRINT((1, "I2CWaitVSync() - no valid modes to use: can't set-up VTG\n"));
                return;
            }

            Permedia2GetClockSpeeds(HwDeviceExtension);
            ZeroMemAndDac(hwDeviceExtension, 0);

            if (!InitializeVideo( HwDeviceExtension, 
                                  hwDeviceExtension->pFrequencyDefault) )
            {
                DEBUG_PRINT((1, "I2CWaitVSync() - InitializeVideo failed\n"));
                return;
            }        
        }

        //
        // VTG has been set-up: check via the control registers
        //

        VideoPortWriteRegisterUlong ( INT_FLAGS, 
                                      INTR_VBLANK_SET );

        while (( (VideoPortReadRegisterUlong (INT_FLAGS) ) & 
                 INTR_VBLANK_SET ) == 0 ); 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\chroma.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * DX  SAMPLE CODE *
*                           *******************
*
* Module Name: chroma.h
*
* Content: Chromakeying definitions and inline functions
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifdef __CHROMA
#pragma message ("FILE : "__FILE__" : Multiple inclusion")
#endif

#define __CHROMA


//-----------------------------------------------------------------------------
//
// In this module we define the 
//
//                 Get8888ScaledChroma 
//                 Get8888ZeroExtendedChroma 

// inline functions used to do texture chroma keying correctly.
//
// All other macros defined in this module are for internal module consumption
// only.
//
//-----------------------------------------------------------------------------

// Get the components for each of the colors
// Put the value into the top bits of a byte.
#define GET_RED_332(a)    (((a) & 0xE0))
#define GET_GREEN_332(a)  (((a) & 0x1C) << 3)
#define GET_BLUE_332(a)   (((a) & 0x03) << 6)

#define GET_ALPHA_2321(a) (((a) & 0x80))
#define GET_RED_2321(a)   (((a) & 0x60) << 1)
#define GET_GREEN_2321(a) (((a) & 0x1C) << 3)
#define GET_BLUE_2321(a)  (((a) & 0x03) << 6)

#define GET_ALPHA_5551(a) (((a) & 0x8000) >> 8)
#define GET_RED_5551(a)   (((a) & 0x7C00) >> 7)
#define GET_GREEN_5551(a) (((a) & 0x03E0) >> 2)
#define GET_BLUE_5551(a)  (((a) & 0x001F) << 3)

#define GET_RED_565(a)    (((a) & 0xF800) >> 8)
#define GET_GREEN_565(a)  (((a) & 0x07E0) >> 3)
#define GET_BLUE_565(a)   (((a) & 0x001F) << 3)

#define GET_ALPHA_4444(a) (((a) & 0xF000) >> 8)
#define GET_RED_4444(a)   (((a) & 0x0F00) >> 4)
#define GET_GREEN_4444(a) (((a) & 0x00F0))
#define GET_BLUE_4444(a)  (((a) & 0x000F) << 4)

#define GET_ALPHA_8888(a) (((a) & 0xFF000000) >> 24)
#define GET_RED_8888(a)   (((a) & 0x00FF0000) >> 16)
#define GET_GREEN_8888(a) (((a) & 0x0000FF00) >> 8)
#define GET_BLUE_8888(a)  (((a) & 0x000000FF))

// These macros assume that the passed value (a) contains no more than the
// designated number of bits set i.e. 11111000 not 1111101 for a 5 bit color
// The macro scales the number to match the internal color conversion of 
// Permedia3.

#define P3SCALE_1_BIT(a) (((a) & 0x80) ? 0xFF : 0x0)
#define P3SCALE_2_BIT(a) ((a) | (((a) & 0xC0) >> 2) \
                              | (((a) & 0xC0) >> 4) \
                              | (((a) & 0xC0) >> 6))
#define P3SCALE_3_BIT(a) ((a) | (((a) & 0xE0) >> 3) | (((a) & 0xC0) >> 6))
#define P3SCALE_4_BIT(a) ((a) | (((a) & 0xF0) >> 4))
#define P3SCALE_5_BIT(a) ((a) | (((a) & 0xE0) >> 5))
#define P3SCALE_6_BIT(a) ((a) | (((a) & 0xC0) >> 6))
#define P3SCALE_7_BIT(a) ((a) | (((a) & 0x80) >> 7))
#define P3SCALE_8_BIT(a) ((a))

#define P3REG_PLACE_RED(a) ((a))
#define P3REG_PLACE_GREEN(a) ((a) << 8)
#define P3REG_PLACE_BLUE(a) ((a) << 16)
#define P3REG_PLACE_ALPHA(a) ((a) << 24)

// The scaling versions.
#define GEN_332_KEY(a)  (P3REG_PLACE_RED  (P3SCALE_3_BIT(GET_RED_332  (a))) |  \
                         P3REG_PLACE_GREEN(P3SCALE_3_BIT(GET_GREEN_332(a))) |  \
                         P3REG_PLACE_BLUE (P3SCALE_2_BIT(GET_BLUE_332 (a))))

#define GEN_2321_KEY(a) (P3REG_PLACE_ALPHA(P3SCALE_1_BIT(GET_ALPHA_2321(a))) | \
                         P3REG_PLACE_RED  (P3SCALE_2_BIT(GET_RED_2321  (a))) | \
                         P3REG_PLACE_GREEN(P3SCALE_3_BIT(GET_GREEN_2321(a))) | \
                         P3REG_PLACE_BLUE (P3SCALE_2_BIT(GET_BLUE_2321 (a))))

#define GEN_5551_KEY(a) (P3REG_PLACE_ALPHA(P3SCALE_1_BIT(GET_ALPHA_5551(a))) | \
                         P3REG_PLACE_RED  (P3SCALE_5_BIT(GET_RED_5551  (a))) | \
                         P3REG_PLACE_GREEN(P3SCALE_5_BIT(GET_GREEN_5551(a))) | \
                         P3REG_PLACE_BLUE (P3SCALE_5_BIT(GET_BLUE_5551 (a))))

#define GEN_565_KEY(a)  (P3REG_PLACE_RED  (P3SCALE_5_BIT(GET_RED_565  (a))) | \
                         P3REG_PLACE_GREEN(P3SCALE_6_BIT(GET_GREEN_565(a))) | \
                         P3REG_PLACE_BLUE (P3SCALE_5_BIT(GET_BLUE_565 (a))))

#define GEN_4444_KEY(a) (P3REG_PLACE_ALPHA(P3SCALE_4_BIT(GET_ALPHA_4444(a))) | \
                         P3REG_PLACE_RED  (P3SCALE_4_BIT(GET_RED_4444  (a))) | \
                         P3REG_PLACE_GREEN(P3SCALE_4_BIT(GET_GREEN_4444(a))) | \
                         P3REG_PLACE_BLUE (P3SCALE_4_BIT(GET_BLUE_4444 (a))))

#define GEN_8888_KEY(a) (P3REG_PLACE_ALPHA(P3SCALE_8_BIT(GET_ALPHA_8888(a))) | \
                         P3REG_PLACE_RED  (P3SCALE_8_BIT(GET_RED_8888  (a))) | \
                         P3REG_PLACE_GREEN(P3SCALE_8_BIT(GET_GREEN_8888(a))) | \
                         P3REG_PLACE_BLUE (P3SCALE_8_BIT(GET_BLUE_8888 (a))))

// The shifting versions.
#define GEN_332_SKEY(a)  (P3REG_PLACE_RED  (GET_RED_332  (a)) |  \
                          P3REG_PLACE_GREEN(GET_GREEN_332(a)) |  \
                          P3REG_PLACE_BLUE (GET_BLUE_332 (a)))

#define GEN_2321_SKEY(a) (P3REG_PLACE_ALPHA(GET_ALPHA_2321(a)) | \
                          P3REG_PLACE_RED  (GET_RED_2321  (a)) | \
                          P3REG_PLACE_GREEN(GET_GREEN_2321(a)) | \
                          P3REG_PLACE_BLUE (GET_BLUE_2321 (a)))

#define GEN_5551_SKEY(a) (P3REG_PLACE_ALPHA(GET_ALPHA_5551(a)) | \
                          P3REG_PLACE_RED  (GET_RED_5551  (a)) | \
                          P3REG_PLACE_GREEN(GET_GREEN_5551(a)) | \
                          P3REG_PLACE_BLUE (GET_BLUE_5551 (a)))

#define GEN_565_SKEY(a)  (P3REG_PLACE_RED  (GET_RED_565  (a)) |  \
                          P3REG_PLACE_GREEN(GET_GREEN_565(a)) |  \
                          P3REG_PLACE_BLUE (GET_BLUE_565 (a)))

#define GEN_4444_SKEY(a) (P3REG_PLACE_ALPHA(GET_ALPHA_4444(a)) | \
                          P3REG_PLACE_RED  (GET_RED_4444  (a)) | \
                          P3REG_PLACE_GREEN(GET_GREEN_4444(a)) | \
                          P3REG_PLACE_BLUE (GET_BLUE_4444 (a)))

// The luminance versions
#define GEN_L8_KEY(a)    (P3REG_PLACE_ALPHA(0xFF) | \
                          P3REG_PLACE_RED  (GET_BLUE_8888 (a)) | \
                          P3REG_PLACE_GREEN(GET_BLUE_8888 (a)) | \
                          P3REG_PLACE_BLUE (GET_BLUE_8888 (a)))

#define GEN_A8L8_KEY(a)  (P3REG_PLACE_ALPHA(GET_GREEN_8888 (a)) | \
                          P3REG_PLACE_RED  (GET_BLUE_8888 (a)) | \
                          P3REG_PLACE_GREEN(GET_BLUE_8888 (a)) | \
                          P3REG_PLACE_BLUE (GET_BLUE_8888 (a)))
                          
#define GEN_A4L4_KEY(a)  (P3REG_PLACE_ALPHA(P3SCALE_4_BIT(GET_GREEN_4444 (a))) | \
                          P3REG_PLACE_RED  (P3SCALE_4_BIT(GET_BLUE_4444 (a))) | \
                          P3REG_PLACE_GREEN(P3SCALE_4_BIT(GET_BLUE_4444 (a))) | \
                          P3REG_PLACE_BLUE (P3SCALE_4_BIT(GET_BLUE_4444 (a))))

//Note: No GEN_8888_SKEY - no difference in functionality.

//-----------------------------------------------------------------------------
//
// __inline Get8888ScaledChroma
//
// Convert a FB Format color to a colorkey value.  The value produced exactly 
// matches the value that the chip will read in from the Framebuffer (it will 
// scale the color into it's internal 8888 format). Non-null pPalEntries  
// indicates that color index should be converted to RGB{A} value. bUsePalAlpha
// indicates whether Alpha channel of the palette should be used. bShift makes
// the conversion use a shift instead of a scale, to match the shift option in
// the P3.
//
//-----------------------------------------------------------------------------
static __inline 
void 
Get8888ScaledChroma(
    P3_THUNKEDDATA* pThisDisplay, 
    DWORD dwSurfFlags,
    DDPIXELFORMAT* pSurfPixFormat,
    DWORD InLowerBound, 
    DWORD InUpperBound, 
    DWORD* OutLowerBound, 
    DWORD* OutUpperBound, 
    DWORD* pPalEntries,
    BOOL bUsePalAlpha, 
    BOOL bShift)
{
    DDPIXELFORMAT* pPixFormat;
    
    DISPDBG((DBGLVL, "InLowerBound  = 0x%08X", InLowerBound));
    DISPDBG((DBGLVL, "InUpperBound = 0x%08X", InUpperBound));

    // Get a pointer to the pixelformat data (not guaranteed to exist.
    // If it doesn't, we use the same format as the display.
    if (DDSurf_HasPixelFormat(dwSurfFlags))
    {
        pPixFormat = pSurfPixFormat;
    }
    else
    {
        pPixFormat = &pThisDisplay->ddpfDisplay;
    }   

    // Is the texture palette indexed?
    if (pPixFormat->dwFlags & DDPF_PALETTEINDEXED4 || 
        pPixFormat->dwFlags & DDPF_PALETTEINDEXED8)
    {
        // Are we doing a lookup through the LUT?  We won't be during a blit
        if (! pPalEntries)
        {
            *OutLowerBound = 
                    CHROMA_LOWER_ALPHA(FORMAT_PALETTE_32BIT(InLowerBound));
            *OutUpperBound = 
                    CHROMA_UPPER_ALPHA(FORMAT_PALETTE_32BIT(InUpperBound));
            DISPDBG((DBGLVL,"Keying of index: %d", InLowerBound));
        }
        else
        {
            DWORD dwTrueColor;

            // ChromaKeying for paletted textures is done on the looked up 
            // color, not the index. This means using a range is meaningless
            // and we have to lookup the color from the palette.  Make sure 
            // the user doesn't force us to access invalid memory. 
                
            dwTrueColor = pPalEntries[(InLowerBound & 0xFF)];

            DISPDBG((DBGLVL,
                    "Texture lookup index: %d, ChromaColor: 0x%x", 
                    InLowerBound, dwTrueColor));
            
            if (bUsePalAlpha)
            {
                *OutLowerBound = dwTrueColor;
                *OutUpperBound = dwTrueColor;
            }
            else
            {
                // Alpha channel of LUT will be set to FF 
                
                *OutLowerBound = CHROMA_LOWER_ALPHA(dwTrueColor);
                *OutUpperBound = CHROMA_UPPER_ALPHA(dwTrueColor);
            }
        }

        return;
    } 

    // Texture is RGB format
    if (pPixFormat->dwFlags & DDPF_RGB)
    {
        DWORD RedMask = pPixFormat->dwRBitMask;
        DWORD AlphaMask = pPixFormat->dwRGBAlphaBitMask;
        switch (pPixFormat->dwRGBBitCount) 
        {
        // 8 Bit RGB Textures
        case 8:
            if (RedMask == 0xE0) 
            {
                DISPDBG((DBGLVL,"  3:3:2"));

                // Never any alpha
                if ( bShift )
                {
                    *OutLowerBound = 
                                CHROMA_LOWER_ALPHA(GEN_332_SKEY(InLowerBound));
                    *OutUpperBound = 
                                CHROMA_UPPER_ALPHA(GEN_332_SKEY(InUpperBound));
                }
                else
                {
                    *OutLowerBound = 
                                CHROMA_LOWER_ALPHA(GEN_332_KEY(InLowerBound));
                    *OutUpperBound = 
                                CHROMA_UPPER_ALPHA(GEN_332_KEY(InUpperBound));
                }
            }
            else 
            {
                DISPDBG((DBGLVL,"  1:2:3:2"));

                if ( bShift )
                {
                    *OutLowerBound = GEN_2321_SKEY(InLowerBound);
                    *OutUpperBound = GEN_2321_SKEY(InUpperBound);
                }
                else
                {
                    *OutLowerBound = GEN_2321_KEY(InLowerBound);
                    *OutUpperBound = GEN_2321_KEY(InUpperBound);
                }

                if (!AlphaMask) 
                {
                    *OutLowerBound = CHROMA_LOWER_ALPHA(*OutLowerBound);
                    *OutUpperBound = CHROMA_UPPER_ALPHA(*OutUpperBound);
                }
            }
            break;
            
        // 16 Bit RGB Textures
        case 16:
            switch (RedMask)
            {
            case 0xf00:
                DISPDBG((DBGLVL,"  4:4:4:4"));

                if ( bShift )
                {
                    *OutLowerBound = GEN_4444_SKEY(InLowerBound);
                    *OutUpperBound = GEN_4444_SKEY(InUpperBound);
                }
                else
                {
                    *OutLowerBound = GEN_4444_KEY(InLowerBound);
                    *OutUpperBound = GEN_4444_KEY(InUpperBound);
                }
                break;
            case 0x7c00:
                DISPDBG((DBGLVL,"  1:5:5:5"));

                if ( bShift )
                {
                    *OutLowerBound = GEN_5551_SKEY(InLowerBound);
                    *OutUpperBound = GEN_5551_SKEY(InUpperBound);
                }
                else
                {
                    *OutLowerBound = GEN_5551_KEY(InLowerBound);
                    *OutUpperBound = GEN_5551_KEY(InUpperBound);
                }

                if (!AlphaMask)
                {
                    *OutLowerBound = CHROMA_LOWER_ALPHA(*OutLowerBound);
                    *OutUpperBound = CHROMA_UPPER_ALPHA(*OutUpperBound);
                }
                break;
                
            default:
                // Always supply full range of alpha values to ensure test 
                // is done
                DISPDBG((DBGLVL,"  5:6:5"));

                if ( bShift )
                {
                    *OutLowerBound = 
                                CHROMA_LOWER_ALPHA(GEN_565_SKEY(InLowerBound));
                    *OutUpperBound = 
                                CHROMA_UPPER_ALPHA(GEN_565_SKEY(InUpperBound));
                }
                else
                {
                    *OutLowerBound = 
                                CHROMA_LOWER_ALPHA(GEN_565_KEY(InLowerBound));
                    *OutUpperBound = 
                                CHROMA_UPPER_ALPHA(GEN_565_KEY(InUpperBound));
                }
                break;
                
            } // switch (RedMask)
            break;
            
        // 32/24 Bit RGB Textures
        case 24:
        case 32:
            DISPDBG((DBGLVL,"  8:8:8:8"));
            // If the surface isn't alpha'd then set a valid
            // range of alpha to catch all cases.
            // No change in behavior for shifting or scaling.
            if (!AlphaMask)
            {
                *OutLowerBound = CHROMA_LOWER_ALPHA(GEN_8888_KEY(InLowerBound));
                *OutUpperBound = CHROMA_UPPER_ALPHA(GEN_8888_KEY(InUpperBound));
            }
            else
            {
                *OutLowerBound = GEN_8888_KEY(InLowerBound);
                *OutUpperBound = GEN_8888_KEY(InUpperBound);
            }                               
            break;
            
        } //   switch (pPixFormat->dwRGBBitCount) 
        
        DISPDBG((DBGLVL, "OutLowerBound = 0x%08X", *OutLowerBound));
        DISPDBG((DBGLVL, "OutUpperBound = 0x%08X", *OutUpperBound));
    }
    // luminance formats
    else if (pPixFormat->dwFlags & DDPF_LUMINANCE)
    {
        if (pPixFormat->dwFlags & DDPF_ALPHAPIXELS)
        {
            if (pPixFormat->dwLuminanceBitCount == 16)
            {
                // 16 bit A8L8
                *OutLowerBound = GEN_A8L8_KEY(InLowerBound);
                *OutUpperBound = GEN_A8L8_KEY(InUpperBound);                  
            }
            else
            {
                // 8 Bit A4L4              
                *OutLowerBound = GEN_A4L4_KEY(InLowerBound);
                *OutUpperBound = GEN_A4L4_KEY(InUpperBound);                
            }
        }
        else
        {
            // 8 Bit L8           
            *OutLowerBound = GEN_L8_KEY(InLowerBound);
            *OutUpperBound = GEN_L8_KEY(InUpperBound);
        }
    }

//@@BEGIN_DDKSPLIT
//AZN - just keep in case we find an app requiring this (Legoland???)
#if 0
    if ( TEST_BUGFIX_FLAG ( IGNORE_CK_ALPHA ) )
    {
        // Fix it up for games that don't realise that they
        // need to set up the alpha-channel of the chromakey
        // values appropriately.
        *OutLowerBound = CHROMA_LOWER_ALPHA(*OutLowerBound);
        *OutUpperBound = CHROMA_UPPER_ALPHA(*OutUpperBound);
    }
#endif
//@@END_DDKSPLIT


} // Get8888ScaledChroma

//-----------------------------------------------------------------------------
//
// __inline Get8888ZeroExtendedChroma
//
//-----------------------------------------------------------------------------
__inline void 
Get8888ZeroExtendedChroma(
    P3_THUNKEDDATA* pThisDisplay, 
    DWORD dwSurfFlags,
    DDPIXELFORMAT* pSurfPixFormat,    
    DWORD LowerBound, 
    DWORD UpperBound, 
    DWORD* OutLowerBound, 
    DWORD* OutUpperBound)
{
    DDPIXELFORMAT* pPixFormat;
    DWORD InLowerBound = LowerBound;
    DWORD InUpperBound = UpperBound;

    DISPDBG((DBGLVL, "InLowerBound  = 0x%08X", InLowerBound));
    DISPDBG((DBGLVL, "InUpperBound = 0x%08X", InUpperBound));

    // Get a pointer to the pixelformat data (not guaranteed to exist.
    // If it doesn't, we use the same format as the display.
    if (DDSurf_HasPixelFormat(dwSurfFlags))
    {
        pPixFormat = pSurfPixFormat;
    }
    else
    {
        pPixFormat = &pThisDisplay->ddpfDisplay;
    }

    {
        DWORD RedMask = pPixFormat->dwRBitMask;
        DWORD AlphaMask = pPixFormat->dwRGBAlphaBitMask;
        switch (pPixFormat->dwRGBBitCount) 
        {
        // 8 Bit RGB Textures
        case 8:
            if (RedMask == 0xE0) 
            {
                // Never any alpha
                *OutLowerBound = 
                    CHROMA_LOWER_ALPHA(FORMAT_332_32BIT_ZEROEXTEND(InLowerBound));
                *OutUpperBound = 
                    CHROMA_UPPER_ALPHA(FORMAT_332_32BIT_ZEROEXTEND(InUpperBound));
            }
            else 
            {
                *OutLowerBound = FORMAT_2321_32BIT_ZEROEXTEND(InLowerBound);
                *OutUpperBound = FORMAT_2321_32BIT_ZEROEXTEND(InUpperBound);
                if (!AlphaMask) 
                {
                    *OutLowerBound = CHROMA_LOWER_ALPHA(*OutLowerBound);
                    *OutUpperBound = CHROMA_UPPER_ALPHA(*OutUpperBound);
                }
            }
            break;
            
        // 16 Bit RGB Textures
        case 16:
            switch (RedMask)
            {
            case 0xf00:
                *OutLowerBound = (FORMAT_4444_32BIT_ZEROEXTEND(InLowerBound));
                *OutUpperBound = (FORMAT_4444_32BIT_ZEROEXTEND(InUpperBound));
                break;
                
            case 0x7c00:
                *OutLowerBound = FORMAT_5551_32BIT_ZEROEXTEND(InLowerBound);
                *OutUpperBound = FORMAT_5551_32BIT_ZEROEXTEND(InUpperBound);
                if (!AlphaMask) 
                {
                    *OutLowerBound = CHROMA_LOWER_ALPHA(*OutLowerBound);
                    *OutUpperBound = CHROMA_UPPER_ALPHA(*OutUpperBound);
                }
                break;
                
            default:
                // Always supply full range of alpha values to ensure test 
                // is done
                *OutLowerBound =
                    CHROMA_LOWER_ALPHA(FORMAT_565_32BIT_ZEROEXTEND(InLowerBound));
                *OutUpperBound = 
                    CHROMA_UPPER_ALPHA(FORMAT_565_32BIT_ZEROEXTEND(InUpperBound));
                break;
            }
            break;
            
        // 32/24 Bit RGB Textures
        case 24:
        case 32:
            // If the surface isn't alpha'd then set a valid
            // range of alpha to catch all cases.
            if (!AlphaMask)
            {
                *OutLowerBound = 
                    CHROMA_LOWER_ALPHA(FORMAT_8888_32BIT_BGR(InLowerBound));
                *OutUpperBound = 
                    CHROMA_UPPER_ALPHA(FORMAT_8888_32BIT_BGR(InUpperBound));
            }
            else
            {
                *OutLowerBound = FORMAT_8888_32BIT_BGR(InLowerBound);
                *OutUpperBound = FORMAT_8888_32BIT_BGR(InUpperBound);
            }                               
            break;
            
        } // switch (pPixFormat->dwRGBBitCount)
        
        DISPDBG((DBGLVL, "OutLowerBound = 0x%08X", *OutLowerBound));
        DISPDBG((DBGLVL, "OutUpperBound = 0x%08X", *OutUpperBound));
    }

//@@BEGIN_DDKSPLIT
//AZN - just keep in case we find an app requiring this (Legoland???)
#if 0
    if ( TEST_BUGFIX_FLAG ( IGNORE_CK_ALPHA ) )
    {
        // Fix it up for games that don't realise that they
        // need to set up the alpha-channel of the chromakey
        // values appropriately.
        *OutLowerBound = CHROMA_LOWER_ALPHA(*OutLowerBound);
        *OutUpperBound = CHROMA_UPPER_ALPHA(*OutUpperBound);
    }
#endif
//@@END_DDKSPLIT

} // Get8888ZeroExtendedChroma
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3d.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3d.c
*
* Content: Main D3D capabilites and callback tables
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

//-----------------------------------------------------------------------------
//
// Certain conventions are followed in this sample driver in order to ease 
// the code reading process:
//
// - All driver function callbacks are prefixed with either D3D or DD. No other
//   functions start with such a prefix
//
// - Helper (or secondary) functions which are called from other places INSIDE
//   the driver (in different files) are prefixed with either _D3D or _DD
//
// - Helper functions called from within the same file are prefixed with __
//   (but not with __D3D or __DD !) so names as __CTX_CleanDirect3DContext arise
//
// - Data structures declared and used only be the driver are prefixed with P3
//
// - Very minor hungarian notation is used, basically in the form of prefixes 
//   for DWORDs (dw), pointers (p), handles (h), and counters (i).
//
// - Global data items are prefixed with g_
//
// - This driver is intended to be source code compatible between the NT and 
//   Win9x kernel display driver models. As such, most kernel structures retain
//   their Win9x name ( The DX8 d3dnthal.h shares the same names as the Win9x
//   d3dhal.h and for DX7 dx95type.h in the Win2K DDK will perform the 
//   required level of translation). Major differences however are observed 
//   using preprocessor #if statements.
//
//-----------------------------------------------------------------------------

#include "glint.h"

//-----------------------------------------------------------------------------
// in-the-file nonexported forward declarations
//-----------------------------------------------------------------------------
void __D3D_BuildTextureFormatsP3(P3_THUNKEDDATA *pThisDisplay, 
                             DDSURFACEDESC TexFmt[MAX_TEXTURE_FORMAT],
                             DWORD *pNumTextures);
#if DX8_DDI
void __D3D_Fill_DX8Caps(D3DCAPS8 *pd3d8caps,
                        D3DDEVICEDESC_V1 *pDeviceDesc,
                        D3DHAL_D3DEXTENDEDCAPS *pD3DEC,
                        DDHALINFO *pDDHALInfo);
#endif // DX8_DDI                        
//-----------------------------------------------------------------------------
// This structure contains all the the primitive capabilities (D3DPRIMCAPS)
// this driver supports for triangles and lines. All of the information in this 
// table will be implementation specific according to the specifications of 
// the hardware.
//-----------------------------------------------------------------------------

#define P3RXTriCaps {                                                    \
    sizeof(D3DPRIMCAPS),                                                 \
    D3DPMISCCAPS_CULLCCW        |              /* MiscCaps */            \
        D3DPMISCCAPS_CULLCW     |                                        \
        D3DPMISCCAPS_CULLNONE   |                                        \
        D3DPMISCCAPS_MASKZ      |                                        \
        D3DPMISCCAPS_LINEPATTERNREP,                                     \
    D3DPRASTERCAPS_DITHER            |         /* RasterCaps */          \
        D3DPRASTERCAPS_PAT           |                                   \
        D3DPRASTERCAPS_SUBPIXEL      |                                   \
        D3DPRASTERCAPS_ZTEST         |                                   \
        D3DPRASTERCAPS_FOGVERTEX     |                                   \
        D3DPRASTERCAPS_FOGTABLE      |                                   \
        D3DPRASTERCAPS_ZFOG          |                                   \
        D3DPRASTERCAPS_STIPPLE       |                                   \
        D3DPRASTERCAPS_MIPMAPLODBIAS,                                    \
    D3DPCMPCAPS_NEVER            |             /* ZCmpCaps */            \
        D3DPCMPCAPS_LESS         |                                       \
        D3DPCMPCAPS_EQUAL        |                                       \
        D3DPCMPCAPS_LESSEQUAL    |                                       \
        D3DPCMPCAPS_GREATER      |                                       \
        D3DPCMPCAPS_NOTEQUAL     |                                       \
        D3DPCMPCAPS_GREATEREQUAL |                                       \
        D3DPCMPCAPS_ALWAYS       |                                       \
        D3DPCMPCAPS_LESSEQUAL,                                           \
    D3DPBLENDCAPS_ZERO             |           /* SourceBlendCaps */     \
        D3DPBLENDCAPS_ONE          |                                     \
        D3DPBLENDCAPS_SRCALPHA     |                                     \
        D3DPBLENDCAPS_INVSRCALPHA  |                                     \
        D3DPBLENDCAPS_DESTALPHA    |                                     \
        D3DPBLENDCAPS_INVDESTALPHA |                                     \
        D3DPBLENDCAPS_DESTCOLOR    |                                     \
        D3DPBLENDCAPS_INVDESTCOLOR |                                     \
        D3DPBLENDCAPS_SRCALPHASAT  |                                     \
        D3DPBLENDCAPS_BOTHSRCALPHA |                                     \
        D3DPBLENDCAPS_BOTHINVSRCALPHA,                                   \
    D3DPBLENDCAPS_ZERO            |            /* DestBlendCaps */       \
        D3DPBLENDCAPS_ONE         |                                      \
        D3DPBLENDCAPS_SRCCOLOR    |                                      \
        D3DPBLENDCAPS_INVSRCCOLOR |                                      \
        D3DPBLENDCAPS_SRCALPHA    |                                      \
        D3DPBLENDCAPS_INVSRCALPHA |                                      \
        D3DPBLENDCAPS_DESTALPHA   |                                      \
        D3DPBLENDCAPS_INVDESTALPHA,                                      \
    D3DPCMPCAPS_NEVER            |             /* Alphatest caps */      \
        D3DPCMPCAPS_LESS         |                                       \
        D3DPCMPCAPS_EQUAL        |                                       \
        D3DPCMPCAPS_LESSEQUAL    |                                       \
        D3DPCMPCAPS_GREATER      |                                       \
        D3DPCMPCAPS_NOTEQUAL     |                                       \
        D3DPCMPCAPS_GREATEREQUAL |                                       \
        D3DPCMPCAPS_ALWAYS,                                              \
    D3DPSHADECAPS_COLORFLATRGB              |  /* ShadeCaps */           \
        D3DPSHADECAPS_COLORGOURAUDRGB       |                            \
        D3DPSHADECAPS_SPECULARFLATRGB       |                            \
        D3DPSHADECAPS_SPECULARGOURAUDRGB    |                            \
        D3DPSHADECAPS_FOGFLAT               |                            \
        D3DPSHADECAPS_FOGGOURAUD            |                            \
        D3DPSHADECAPS_ALPHAFLATBLEND        |                            \
        D3DPSHADECAPS_ALPHAGOURAUDBLEND     |                            \
        D3DPSHADECAPS_ALPHAFLATSTIPPLED,                                 \
    D3DPTEXTURECAPS_PERSPECTIVE         |      /* TextureCaps */         \
        D3DPTEXTURECAPS_ALPHA           |                                \
        D3DPTEXTURECAPS_POW2            |                                \
        D3DPTEXTURECAPS_ALPHAPALETTE    |                                \
        D3DPTEXTURECAPS_TRANSPARENCY,                                    \
    D3DPTFILTERCAPS_NEAREST              |     /* TextureFilterCaps*/    \
        D3DPTFILTERCAPS_LINEAR           |                               \
        D3DPTFILTERCAPS_MIPNEAREST       |                               \
        D3DPTFILTERCAPS_MIPLINEAR        |                               \
        D3DPTFILTERCAPS_LINEARMIPNEAREST |                               \
        D3DPTFILTERCAPS_LINEARMIPLINEAR  |                               \
        D3DPTFILTERCAPS_MIPFPOINT        |                               \
        D3DPTFILTERCAPS_MIPFLINEAR       |                               \
        D3DPTFILTERCAPS_MAGFPOINT        |                               \
        D3DPTFILTERCAPS_MAGFLINEAR       |                               \
        D3DPTFILTERCAPS_MINFPOINT        |                               \
        D3DPTFILTERCAPS_MINFLINEAR,                                      \
    D3DPTBLENDCAPS_DECAL             |        /* TextureBlendCaps */     \
        D3DPTBLENDCAPS_DECALALPHA    |                                   \
        D3DPTBLENDCAPS_MODULATE      |                                   \
        D3DPTBLENDCAPS_MODULATEALPHA |                                   \
        D3DPTBLENDCAPS_ADD           |                                   \
        D3DPTBLENDCAPS_COPY,                                             \
    D3DPTADDRESSCAPS_WRAP       |              /* TextureAddressCaps */  \
        D3DPTADDRESSCAPS_MIRROR |                                        \
        D3DPTADDRESSCAPS_CLAMP  |                                        \
        D3DPTADDRESSCAPS_INDEPENDENTUV,                                  \
    8,                                         /* StippleWidth */        \
    8                                          /* StippleHeight */       \
}    

static D3DDEVICEDESC_V1 g_P3RXCaps = {
    sizeof(D3DDEVICEDESC_V1),                 // dwSize 
    D3DDD_COLORMODEL               |          // dwFlags 
        D3DDD_DEVCAPS              |
        D3DDD_TRICAPS              |
        D3DDD_LINECAPS             |
        D3DDD_DEVICERENDERBITDEPTH |
        D3DDD_DEVICEZBUFFERBITDEPTH,
    D3DCOLOR_RGB ,                            // dcmColorModel
    D3DDEVCAPS_CANRENDERAFTERFLIP       |     // devCaps 
        D3DDEVCAPS_FLOATTLVERTEX        |
        D3DDEVCAPS_SORTINCREASINGZ      |
        D3DDEVCAPS_SORTEXACT            |
        D3DDEVCAPS_TLVERTEXSYSTEMMEMORY |
        D3DDEVCAPS_EXECUTESYSTEMMEMORY  |
        D3DDEVCAPS_TEXTUREVIDEOMEMORY   |
        D3DDEVCAPS_DRAWPRIMTLVERTEX     |
        D3DDEVCAPS_DRAWPRIMITIVES2      |       
#if DX7_VERTEXBUFFERS
        D3DDEVCAPS_HWVERTEXBUFFER       |
#endif        
        D3DDEVCAPS_HWRASTERIZATION      |
        D3DDEVCAPS_DRAWPRIMITIVES2EX,
    { sizeof(D3DTRANSFORMCAPS), 0 },            // transformCaps 
    FALSE,                                      // bClipping 
    { sizeof(D3DLIGHTINGCAPS), 0 },             // lightingCaps 
    P3RXTriCaps,                                // lineCaps 
    P3RXTriCaps,                                // triCaps 
        DDBD_16 | DDBD_32,                      // dwDeviceRenderBitDepth 
        DDBD_16 | DDBD_32,                      // Z Bit depths 
        0,                                      // dwMaxBufferSize 
    0                                           // dwMaxVertexCount 
};

D3DHAL_D3DEXTENDEDCAPS gc_D3DEC = {
    sizeof(D3DHAL_D3DEXTENDEDCAPS),       // dwSize                   // DX5
    1,                                    // dwMinTextureWidth
    2048,                                 // dwMaxTextureWidth
    1,                                    // dwMinTextureHeight
    2048,                                 // dwMaxTextureHeight
    32,                                   // dwMinStippleWidth
    32,                                   // dwMaxStippleWidth
    32,                                   // dwMinStippleHeight
    32,                                   // dwMaxStippleHeight

    0,  /*azn*/                           // dwMaxTextureRepeat       //DX6
    0,                                    // dwMaxTextureAspectRatio (no limit)
    0,                                    // dwMaxAnisotropy
    -4096.0f,                             // dvGuardBandLeft
    -4096.0f,                             // dvGuardBandTop
    4096.0f,                              // dvGuardBandRight
    4096.0f,                              // dvGuardBandBottom
    0.0f,                                 // dvExtentsAdjust                           
    D3DSTENCILCAPS_KEEP    |              // dwStencilCaps
       D3DSTENCILCAPS_ZERO    |
       D3DSTENCILCAPS_REPLACE |
       D3DSTENCILCAPS_INCRSAT |
       D3DSTENCILCAPS_DECRSAT |
       D3DSTENCILCAPS_INVERT  |
       D3DSTENCILCAPS_INCR    |
       D3DSTENCILCAPS_DECR,                                        
    8,                                          // dwFVFCaps                  
    D3DTEXOPCAPS_DISABLE                      | // dwTextureOpCaps
       D3DTEXOPCAPS_SELECTARG1                | 
       D3DTEXOPCAPS_SELECTARG2                |
       D3DTEXOPCAPS_MODULATE                  |
       D3DTEXOPCAPS_MODULATE2X                |
       D3DTEXOPCAPS_MODULATE4X                |
       D3DTEXOPCAPS_ADD                       |
       D3DTEXOPCAPS_ADDSIGNED                 |
       D3DTEXOPCAPS_ADDSIGNED2X               |
       D3DTEXOPCAPS_SUBTRACT                  |
       D3DTEXOPCAPS_ADDSMOOTH                 |
       D3DTEXOPCAPS_BLENDDIFFUSEALPHA         |
       D3DTEXOPCAPS_BLENDTEXTUREALPHA         |
       D3DTEXOPCAPS_BLENDFACTORALPHA          |
//@@BEGIN_DDKSPLIT
#if 0
 // Fix texturestage DCT - seems we can't do this reliably
       D3DTEXOPCAPS_BLENDTEXTUREALPHAPM       |
       D3DTEXOPCAPS_PREMODULATE               |   
       D3DTEXOPCAPS_BLENDCURRENTALPHA         |       
#endif
//@@END_DDKSPLIT
       D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR    |
       D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA    |
       D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR |
       D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA |
       D3DTEXOPCAPS_DOTPRODUCT3,                                      
    2,                                    // wMaxTextureBlendStages
    2,                                    // wMaxSimultaneousTextures

    0,                                    // dwMaxActiveLights        // DX7
    0.0f,                                 // dvMaxVertexW
    0,                                    // wMaxUserClipPlanes
    0                                     // wMaxVertexBlendMatrices
};

#if DX8_DDI
static D3DCAPS8 g_P3RX_D3DCaps8;
#endif // DX8_DDI

//--------------------------------------------------------
// Supported ZBuffer/Stencil Formats by this hardware
//--------------------------------------------------------

#define P3RX_Z_FORMATS 4

typedef struct 
{
    DWORD dwStructSize;

    DDPIXELFORMAT Format[P3RX_Z_FORMATS];
} ZFormats;

ZFormats P3RXZFormats = 
{
    P3RX_Z_FORMATS,
    {
        // Format 1 - 16 Bit Z Buffer, no stencil
        {
            sizeof(DDPIXELFORMAT),        
            DDPF_ZBUFFER,                     
            0,                            
            16,                     // Total bits in buffer
            0,                      // Stencil bits
            0xFFFF,                 // Z mask
            0,                      // Stencil mask
            0
        },
        // Format 2 - 24 bit Z Buffer, 8 bit stencil
        {
            sizeof(DDPIXELFORMAT),
            DDPF_ZBUFFER | DDPF_STENCILBUFFER,
            0,
            32,                     // Total bits in buffer
            8,                      // Stencil bits
            0x00FFFFFF,             // Z Mask
            0xFF000000,             // Stencil Mask
            0
        },
        // Format 3 - 15 bit Z Buffer, 1 bit stencil
        {
            sizeof(DDPIXELFORMAT),
            DDPF_ZBUFFER | DDPF_STENCILBUFFER,             
            0,                    
            16,                     // Total bits in buffer
            1,                      // Stencil bits
            0x7FFF,                 // Z Mask
            0x8000,                 // Stencil mask
            0
        },
        // Format 4 - 32 bit Z Buffer, no stencil
        {
            sizeof(DDPIXELFORMAT),
            DDPF_ZBUFFER,
            0,
            32,                     // Total bits in buffer
            0,                      // Stencil bits
            0xFFFFFFFF,             // Z Mask
            0,                      // Stencil Mask
            0
        }
    }
};

#if DX8_DDI
//----------------------------------------------------------------------------
// Supported DX8 RenderTarget/Texture/ZBuffer/Stencil Formats by this hardware
//----------------------------------------------------------------------------

#if DX8_MULTISAMPLING
// Note: For multisampling we need to setup appropriately both the rendertarget
// and the depth buffer format's multisampling fields.
#define D3DMULTISAMPLE_NUM_SAMPLES (1 << (D3DMULTISAMPLE_4_SAMPLES - 1))
#else
#define D3DMULTISAMPLE_NUM_SAMPLES D3DMULTISAMPLE_NONE
#endif // DX8_MULTISAMPLING

#define DX8_FORMAT(FourCC, Ops, dwMSFlipTypes)                              \
    { sizeof(DDPIXELFORMAT), DDPF_D3DFORMAT, (FourCC), 0, (Ops),            \
        ((dwMSFlipTypes) & 0xFFFF ) << 16 | ((dwMSFlipTypes) & 0xFFFF), 0, 0 }

DDPIXELFORMAT DX8FormatTable[] =
{
    DX8_FORMAT(D3DFMT_X1R5G5B5,        D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE | 
                                         D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET, 
                                          D3DMULTISAMPLE_NUM_SAMPLES ),
    DX8_FORMAT(D3DFMT_R5G6B5,          D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE | 
                                         D3DFORMAT_OP_DISPLAYMODE |
                                          D3DFORMAT_OP_3DACCELERATION |
                                           D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET, 
                                            D3DMULTISAMPLE_NUM_SAMPLES ),
    DX8_FORMAT(D3DFMT_X8R8G8B8,        D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE | 
                                         D3DFORMAT_OP_DISPLAYMODE | 
                                          D3DFORMAT_OP_3DACCELERATION |
                                           D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET,   0), 
#ifdef DX7_PALETTETEXTURE
    DX8_FORMAT(D3DFMT_P8,              D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE,                 0),
#endif

    DX8_FORMAT(D3DFMT_A1R5G5B5,        D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE,                 0),
    DX8_FORMAT(D3DFMT_A4R4G4B4,        D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE,                 0),
    DX8_FORMAT(D3DFMT_A8R8G8B8,        D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE,                 0),
    DX8_FORMAT(D3DFMT_A4L4,            D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE,                 0),
    DX8_FORMAT(D3DFMT_A8L8,            D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE,                 0),
//@@BEGIN_DDKSPLIT 
// We are turning D3DFMT_A8 support OFF because the default color for
// this format has been changed from white to black. The P3 has white
// hardwired so there is no simple solution for this.
#if 0                                        
    DX8_FORMAT(D3DFMT_A8,              D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE,                 0),
#endif                                        
//@@END_DDKSPLIT
    DX8_FORMAT(D3DFMT_L8,              D3DFORMAT_OP_TEXTURE | 
                                        D3DFORMAT_OP_VOLUMETEXTURE,                 0),
    DX8_FORMAT(D3DFMT_D16_LOCKABLE,    D3DFORMAT_OP_ZSTENCIL |
                                       D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH , 
                                            D3DMULTISAMPLE_NUM_SAMPLES ),
    DX8_FORMAT(D3DFMT_D32,             D3DFORMAT_OP_ZSTENCIL |
                                       D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH , 
                                            D3DMULTISAMPLE_NUM_SAMPLES ),
    DX8_FORMAT(D3DFMT_S8D24,           D3DFORMAT_OP_ZSTENCIL |
                                       D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH , 
                                            D3DMULTISAMPLE_NUM_SAMPLES ),
    DX8_FORMAT(D3DFMT_S1D15,           D3DFORMAT_OP_ZSTENCIL |
                                       D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH , 
                                            D3DMULTISAMPLE_NUM_SAMPLES )
};
#define DX8_FORMAT_COUNT (sizeof(DX8FormatTable) / sizeof(DX8FormatTable[0]))
#endif // DX8_DDI

#ifdef W95_DDRAW
#define DDHAL_D3DBUFCALLBACKS DDHAL_DDEXEBUFCALLBACKS 
#endif

//-----------------------------------------------------------------------------
//
// void _D3DHALCreateDriver
//
// _D3DHALCreateDriver is a helper function, not a callback.
//
// Its main purpouse is to centralize the first part of D3D initialization 
// (the second part is handled by _D3DGetDriverInfo) . _D3DHALCreateDriver:
//      Clears contexts
//      Fills entry points to D3D driver.
//      Generates and passes back texture formats.
//
// If the structures are succesfully created the internal pointers 
// (lpD3DGlobalDriverData, lpD3DHALCallbacks and (maybe) lpD3DBufCallbacks)
// are updated to point to valid data structures.
//
//-----------------------------------------------------------------------------
void  
_D3DHALCreateDriver(P3_THUNKEDDATA *pThisDisplay)
{
    BOOL bRet;
    ULONG Result;
    D3DHAL_GLOBALDRIVERDATA* pD3DDriverData = NULL;
    D3DHAL_CALLBACKS* pD3DHALCallbacks = NULL;
    DDHAL_D3DBUFCALLBACKS* pD3DBufCallbacks = NULL;

    DBG_ENTRY(_D3DHALCreateDriver);

    // Verify if we have already created the necessary data. If so, don't go
    // again through this process.
    if ((pThisDisplay->lpD3DGlobalDriverData != 0) &&
        (pThisDisplay->lpD3DHALCallbacks != 0))
    {
        DISPDBG((WRNLVL,"D3D Data already created for this PDEV, "
                        "not doing it again."));

        // we keep the same structure pointers to previously 
        // created and stored in pThisDisplay                 
        
        DBG_EXIT(_D3DHALCreateDriver, 0); 
        return;
    }
    else
    {
        DISPDBG((WRNLVL,"Creating D3D caps/callbacks for the "
                        "first time on this PDEV"));
    }

    // We set the structure pointers to NULL in case an error happens and 
    // we're forced to disable D3D support
    pThisDisplay->lpD3DGlobalDriverData = 0;
    pThisDisplay->lpD3DHALCallbacks = 0;
    pThisDisplay->lpD3DBufCallbacks = 0;       

    // Initialize the context handle data structures (array) . We are careful
    // not to initialize the data structures twice (as between mode changes,
    // for example) as this info needs to be persistent between such events.
    _D3D_CTX_HandleInitialization();

    //-----------------------------------
    // Allocate necessary data structures
    //-----------------------------------

    // Initialize our pointers to global driver 
    // data and to HAL callbacks to NULL
    pThisDisplay->pD3DDriverData16 = 0;
    pThisDisplay->pD3DDriverData32 = 0;

    pThisDisplay->pD3DHALCallbacks16 = 0;
    pThisDisplay->pD3DHALCallbacks32 = 0;

    pThisDisplay->pD3DHALExecuteCallbacks16 = 0;
    pThisDisplay->pD3DHALExecuteCallbacks32 = 0;       

    // Allocate memory for the global driver data structure.
    SHARED_HEAP_ALLOC(&pThisDisplay->pD3DDriverData16, 
                      &pThisDisplay->pD3DDriverData32, 
                      sizeof(D3DHAL_GLOBALDRIVERDATA));
             
    if (pThisDisplay->pD3DDriverData32 == 0)
    {
        DISPDBG((ERRLVL, "ERROR: _D3DHALCreateDriver: "
                         "Failed to allocate driverdata memory"));
        
        DBG_EXIT(_D3DHALCreateDriver,0);         
        return;
    }
    
    DISPDBG((DBGLVL,"Allocated D3DDriverData Memory: p16:0x%x, p32:0x%x", 
                     pThisDisplay->pD3DDriverData16, 
                     pThisDisplay->pD3DDriverData32));

    // Allocate memory for the global HAL callback data structure.
    SHARED_HEAP_ALLOC(&pThisDisplay->pD3DHALCallbacks16, 
                      &pThisDisplay->pD3DHALCallbacks32, 
                      sizeof(D3DHAL_CALLBACKS));
             
    if (pThisDisplay->pD3DHALCallbacks32 == 0)
    {
        DISPDBG((ERRLVL, "ERROR: _D3DHALCreateDriver: "
                         "Failed to allocate callback memory"));

        SHARED_HEAP_FREE(&pThisDisplay->pD3DDriverData16, 
                         &pThisDisplay->pD3DDriverData32,
                         TRUE);
                
        DBG_EXIT(_D3DHALCreateDriver, 0); 
        return;
    }

    DISPDBG((DBGLVL,"Allocated HAL Callbacks Memory: p16:0x%x, p32:0x%x", 
                    pThisDisplay->pD3DHALCallbacks16, 
                    pThisDisplay->pD3DHALCallbacks32));

    // Allocate memory for the global Vertex Buffer callback data structure.
    SHARED_HEAP_ALLOC(&pThisDisplay->pD3DHALExecuteCallbacks16, 
                      &pThisDisplay->pD3DHALExecuteCallbacks32, 
                      sizeof(DDHAL_D3DBUFCALLBACKS));
             
    if (pThisDisplay->pD3DHALExecuteCallbacks32 == 0)
    {       
        DISPDBG((ERRLVL, "ERROR: _D3DHALCreateDriver: "
                         "Failed to allocate callback memory"));

        SHARED_HEAP_FREE(&pThisDisplay->pD3DDriverData16, 
                         &pThisDisplay->pD3DDriverData32,
                         TRUE);
        SHARED_HEAP_FREE(&pThisDisplay->pD3DHALCallbacks16, 
                         &pThisDisplay->pD3DHALCallbacks32,
                         TRUE);                          
                
        DBG_EXIT(_D3DHALCreateDriver, 0); 
        return;
    }

    DISPDBG((DBGLVL,"Allocated Vertex Buffer Callbacks Memory: "
                    "p16:0x%x, p32:0x%x", 
                    pThisDisplay->pD3DHALExecuteCallbacks16, 
                    pThisDisplay->pD3DHALExecuteCallbacks32));
               
    //------------------------------------------------------
    // Fill in the data structures the driver has to provide
    //------------------------------------------------------
    
    // Get the Pointers
    pD3DDriverData = (D3DHAL_GLOBALDRIVERDATA*)pThisDisplay->pD3DDriverData32;
    pD3DHALCallbacks = (D3DHAL_CALLBACKS*)pThisDisplay->pD3DHALCallbacks32;
    pD3DBufCallbacks = 
                (DDHAL_D3DBUFCALLBACKS *)pThisDisplay->pD3DHALExecuteCallbacks32;

    // Clear the global data
    memset(pD3DDriverData, 0, sizeof(D3DHAL_GLOBALDRIVERDATA));
    pD3DDriverData->dwSize = sizeof(D3DHAL_GLOBALDRIVERDATA);
    
    // Clear the HAL callbacks
    memset(pD3DHALCallbacks, 0, sizeof(D3DHAL_CALLBACKS));
    pD3DHALCallbacks->dwSize = sizeof(D3DHAL_CALLBACKS);

    // Clear the Vertex Buffer callbacks
    memset(pD3DBufCallbacks, 0, sizeof(DDHAL_D3DBUFCALLBACKS));
    pD3DBufCallbacks->dwSize = sizeof(DDHAL_D3DBUFCALLBACKS);
                          
    // Report that we can texture from nonlocal vidmem only if the 
    // card is an AGP one and AGP is enabed.
    if (pThisDisplay->bCanAGP)
    {
        g_P3RXCaps.dwDevCaps |= D3DDEVCAPS_TEXTURENONLOCALVIDMEM;
    }

#if DX7_ANTIALIAS
    // Report we support fullscreen antialiasing
    g_P3RXCaps.dpcTriCaps.dwRasterCaps |= 
#if DX8_DDI    
                                D3DPRASTERCAPS_STRETCHBLTMULTISAMPLE  |
#endif                                
                                D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT;
#endif // DX7_ANTIALIAS
               
#if DX8_3DTEXTURES
    // Report we support 3D textures
    g_P3RXCaps.dpcTriCaps.dwTextureCaps |= D3DPTEXTURECAPS_VOLUMEMAP |
                                           D3DPTEXTURECAPS_VOLUMEMAP_POW2;
#endif // DX8_3DTEXTURES

//@@BEGIN_DDKSPLIT
#if DX7_WBUFFER
    g_P3RXCaps.dpcTriCaps.dwRasterCaps |= D3DPRASTERCAPS_WBUFFER;
#endif // DX7_WBUFFER
//@@END_DDKSPLIT

#if DX8_DDI    
    if (TLCHIP_GAMMA)
    {
        // Enable handling of the new D3DRS_COLORWRITEENABLE
        // but only for GVX1 since VX1 has trouble with this at 16bpp
        g_P3RXCaps.dpcTriCaps.dwMiscCaps |= D3DPMISCCAPS_COLORWRITEENABLE;
        g_P3RXCaps.dpcLineCaps.dwMiscCaps |= D3DPMISCCAPS_COLORWRITEENABLE;
    }

    // Enable new cap for mipmap support
    g_P3RXCaps.dpcTriCaps.dwTextureCaps |= D3DPTEXTURECAPS_MIPMAP;
    g_P3RXCaps.dpcLineCaps.dwTextureCaps |= D3DPTEXTURECAPS_MIPMAP; 

#endif // DX8_DDI  

    //---------------------------
    // Fill in global driver data
    //---------------------------

    // Hardware caps supoorted
    pD3DDriverData->dwNumVertices = 0;       
    pD3DDriverData->dwNumClipVertices = 0;
    pD3DDriverData->hwCaps = g_P3RXCaps;

    // Build a table with the texture formats supported. Store in pThisDisplay
    // as we will need this also for DdCanCreateSurface. ( Notice that since 
    // _D3DHALCreateDriver will be called in every driver load or mode change,
    // we will have valid TextureFormats in pThisDisplay whenever 
    // DdCanCreateSurface is called )
    __D3D_BuildTextureFormatsP3(pThisDisplay, 
                            &pThisDisplay->TextureFormats[0],
                            &pThisDisplay->dwNumTextureFormats);

    pD3DDriverData->dwNumTextureFormats = pThisDisplay->dwNumTextureFormats;                                              
    pD3DDriverData->lpTextureFormats = pThisDisplay->TextureFormats;

    //---------------------------------------
    // Fill in context handling HAL callbacks
    //---------------------------------------
    pD3DHALCallbacks->ContextCreate  = D3DContextCreate;
    pD3DHALCallbacks->ContextDestroy = D3DContextDestroy;


    //---------------------------------------------------
    // Fill in Vertex Buffer callbacks pointers and flags
    //---------------------------------------------------

#if !DX7_VERTEXBUFFERS   
    // We won't use this structure at all so delete it
    SHARED_HEAP_FREE(&pThisDisplay->pD3DHALExecuteCallbacks16, 
                     &pThisDisplay->pD3DHALExecuteCallbacks32,
                     TRUE);       
    pD3DBufCallbacks = NULL;
//@@BEGIN_DDKSPLIT
#else    
    pD3DBufCallbacks->dwSize = sizeof(DDHAL_D3DBUFCALLBACKS);
    pD3DBufCallbacks->dwFlags =  DDHAL_EXEBUFCB32_CANCREATEEXEBUF |
                                 DDHAL_EXEBUFCB32_CREATEEXEBUF    |
                                 DDHAL_EXEBUFCB32_DESTROYEXEBUF   |
                                 DDHAL_EXEBUFCB32_LOCKEXEBUF      |
                                 DDHAL_EXEBUFCB32_UNLOCKEXEBUF;
#if WNT_DDRAW
    // Execute buffer callbacks for WinNT
    pD3DBufCallbacks->CanCreateD3DBuffer = D3DCanCreateD3DBuffer;
    pD3DBufCallbacks->CreateD3DBuffer = D3DCreateD3DBuffer;
    pD3DBufCallbacks->DestroyD3DBuffer = D3DDestroyD3DBuffer;
    pD3DBufCallbacks->LockD3DBuffer = D3DLockD3DBuffer;
    pD3DBufCallbacks->UnlockD3DBuffer = D3DUnlockD3DBuffer;                                 
#else 

    // Execute buffer callbacks for Win9x
    pD3DBufCallbacks->CanCreateExecuteBuffer = D3DCanCreateD3DBuffer;
    pD3DBufCallbacks->CreateExecuteBuffer = D3DCreateD3DBuffer;
    pD3DBufCallbacks->DestroyExecuteBuffer = D3DDestroyD3DBuffer;
    pD3DBufCallbacks->LockExecuteBuffer = D3DLockD3DBuffer;
    pD3DBufCallbacks->UnlockExecuteBuffer = D3DUnlockD3DBuffer;

#endif // WNT_DDRAW
//@@END_DDKSPLIT

#endif // DX7_VERTEXBUFFERS         

    //---------------------------------------------------------
    // We return with updated pThisDisplay internal pointers to 
    // the driver data, HAL and Vertex Buffer structures.
    //---------------------------------------------------------
    pThisDisplay->lpD3DGlobalDriverData = (ULONG_PTR)pD3DDriverData;
    pThisDisplay->lpD3DHALCallbacks = (ULONG_PTR)pD3DHALCallbacks;
    pThisDisplay->lpD3DBufCallbacks = (ULONG_PTR)pD3DBufCallbacks;    

#ifndef WNT_DDRAW

    //
    // Set up the same information in DDHALINFO
    //

//@@BEGIN_DDKSPLIT
#ifdef W95_DDRAW
    
    //
    // Our {in|ex}ternal header files are not completely consistent regarding
    // these 2 callback functions, internally they are typed function pointers,
    // externally they are just DWORDs.
    //

    pThisDisplay->ddhi32.lpD3DGlobalDriverData = pD3DDriverData;
    pThisDisplay->ddhi32.lpD3DHALCallbacks     = pD3DHALCallbacks;
#else
//@@END_DDKSPLIT
    pThisDisplay->ddhi32.lpD3DGlobalDriverData = (ULONG_PTR)pD3DDriverData;
    pThisDisplay->ddhi32.lpD3DHALCallbacks     = (ULONG_PTR)pD3DHALCallbacks;
//@@BEGIN_DDKSPLIT
#endif
//@@END_DDKSPLIT
    pThisDisplay->ddhi32.lpDDExeBufCallbacks   = pD3DBufCallbacks;

#endif

    DBG_EXIT(_D3DHALCreateDriver,0); 
    return;
} // _D3DHALCreateDriver


//-----------------------------------------------------------------------------
//
// void _D3DGetDriverInfo
//
// _D3DGetDriverInfo is a helper function called by DdGetDriverInfo , not a 
// callback. Its main purpouse is to centralize the second part of D3D 
// initialization (the first part is handled by _D3DHALCreateDriver) . 
//
// _D3DGetDriverInfo handles the 
//
//           GUID_D3DExtendedCaps
//           GUID_D3DParseUnknownCommandCallback         
//           GUID_D3DCallbacks3
//           GUID_ZPixelFormats
//           GUID_Miscellaneous2Callbacks
//
// GUIDs and fills all the relevant information associated to them. 
// GUID_D3DCallbacks2 is not handled at all because it is a legacy GUID.
//
//-----------------------------------------------------------------------------
void 
_D3DGetDriverInfo(
    LPDDHAL_GETDRIVERINFODATA lpData)
{
    DWORD dwSize;
    P3_THUNKEDDATA *pThisDisplay;

    DBG_ENTRY(_D3DGetDriverInfo);

    // Get a pointer to the chip we are on.
    
#if WNT_DDRAW
    pThisDisplay = (P3_THUNKEDDATA*)(((PPDEV)(lpData->dhpdev))->thunkData);
#else    
    pThisDisplay = (P3_THUNKEDDATA*)lpData->dwContext;
    if (! pThisDisplay) 
    {
        pThisDisplay = g_pDriverData;
    }    
#endif

    // Fill in required Miscellaneous2 callbacks
    if ( MATCH_GUID(lpData->guidInfo, GUID_Miscellaneous2Callbacks))
    {
        DDHAL_DDMISCELLANEOUS2CALLBACKS DDMisc2;

        DISPDBG((DBGLVL, "  GUID_Miscellaneous2Callbacks"));

        memset(&DDMisc2, 0, sizeof(DDMisc2));

        dwSize = min(lpData->dwExpectedSize, 
                     sizeof(DDHAL_DDMISCELLANEOUS2CALLBACKS));
        lpData->dwActualSize = sizeof(DDHAL_DDMISCELLANEOUS2CALLBACKS);

        ASSERTDD((lpData->dwExpectedSize == 
                    sizeof(DDHAL_DDMISCELLANEOUS2CALLBACKS)), 
                  "ERROR: Callbacks 2 size incorrect!");

        DDMisc2.dwSize = dwSize;
        DDMisc2.dwFlags = DDHAL_MISC2CB32_GETDRIVERSTATE | 
                          DDHAL_MISC2CB32_CREATESURFACEEX | 
                          DDHAL_MISC2CB32_DESTROYDDLOCAL;
                          
        DDMisc2.GetDriverState = D3DGetDriverState;
        DDMisc2.CreateSurfaceEx = D3DCreateSurfaceEx;
        DDMisc2.DestroyDDLocal = D3DDestroyDDLocal;

        memcpy(lpData->lpvData, &DDMisc2, dwSize);
        lpData->ddRVal = DD_OK;
    }

    // Fill in the extended caps 
    if (MATCH_GUID((lpData->guidInfo), GUID_D3DExtendedCaps) )
    {
        DISPDBG((DBGLVL, "  GUID_D3DExtendedCaps"));
        dwSize = min(lpData->dwExpectedSize, sizeof(D3DHAL_D3DEXTENDEDCAPS));

        lpData->dwActualSize = sizeof(D3DHAL_D3DEXTENDEDCAPS);
 
        memcpy(lpData->lpvData, &gc_D3DEC, sizeof(gc_D3DEC) );
        lpData->ddRVal = DD_OK;
    }

    // Grab the pointer to the ParseUnknownCommand OS callback 
    if ( MATCH_GUID(lpData->guidInfo, GUID_D3DParseUnknownCommandCallback) )
    {
        DISPDBG((DBGLVL, "Get D3DParseUnknownCommandCallback"));

        *(ULONG_PTR *)(&pThisDisplay->pD3DParseUnknownCommand) = 
                                                    (ULONG_PTR)lpData->lpvData;

        ASSERTDD((pThisDisplay->pD3DParseUnknownCommand),
                 "D3D ParseUnknownCommand callback == NULL");
                 
        lpData->ddRVal = DD_OK;
    }

    // Fill in ZBuffer/Stencil formats supported. If you don't respond to
    // this GUID, ZBuffer formats will be inferred from the D3DDEVICEDESC 
    // copied in _D3DHALCreateDriver
    if ( MATCH_GUID(lpData->guidInfo, GUID_ZPixelFormats))
    {
        DISPDBG((DBGLVL, "  GUID_ZPixelFormats"));

        dwSize = min(lpData->dwExpectedSize, sizeof(P3RXZFormats));
        lpData->dwActualSize = sizeof(P3RXZFormats);
        memcpy(lpData->lpvData, &P3RXZFormats, dwSize);

        lpData->ddRVal = DD_OK;
    }

    // Fill in required D3DCallbacks3 callbacks
    if ( MATCH_GUID(lpData->guidInfo, GUID_D3DCallbacks3) )
    {
        D3DHAL_CALLBACKS3 D3DCallbacks3;
        memset(&D3DCallbacks3, 0, sizeof(D3DCallbacks3));

        DISPDBG((DBGLVL, "  GUID_D3DCallbacks3"));
        dwSize = min(lpData->dwExpectedSize, sizeof(D3DHAL_CALLBACKS3));
        lpData->dwActualSize = sizeof(D3DHAL_CALLBACKS3);
        
        ASSERTDD((lpData->dwExpectedSize == sizeof(D3DHAL_CALLBACKS3)), 
                  "ERROR: Callbacks 3 size incorrect!");

        D3DCallbacks3.dwSize = dwSize;
        D3DCallbacks3.dwFlags = D3DHAL3_CB32_VALIDATETEXTURESTAGESTATE  |
                                D3DHAL3_CB32_DRAWPRIMITIVES2;

        D3DCallbacks3.DrawPrimitives2 = D3DDrawPrimitives2_P3;      
        D3DCallbacks3.ValidateTextureStageState = D3DValidateDeviceP3;

        memcpy(lpData->lpvData, &D3DCallbacks3, dwSize);
        lpData->ddRVal = DD_OK;
    }

    // Check for calls to GetDriverInfo2
    // Notice : GUID_GetDriverInfo2 has the same value as GUID_DDStereoMode
#if DX8_DDI
    if ( MATCH_GUID(lpData->guidInfo, GUID_GetDriverInfo2) )
#else
    if ( MATCH_GUID(lpData->guidInfo, GUID_DDStereoMode) )
#endif
    {
#if DX8_DDI
        // Make sure this is actually a call to GetDriverInfo2 
        // ( and not a call to DDStereoMode!)
        if (D3DGDI_IS_GDI2(lpData))
        {
            // Yes, its a call to GetDriverInfo2, fetch the
            // DD_GETDRIVERINFO2DATA data structure.
            DD_GETDRIVERINFO2DATA* pgdi2 = D3DGDI_GET_GDI2_DATA(lpData);
            DD_GETFORMATCOUNTDATA* pgfcd;
            DD_GETFORMATDATA*      pgfd;
            DD_DXVERSION*          pdxv;

            // What type of request is this?
            switch (pgdi2->dwType)
            {
            case D3DGDI2_TYPE_DXVERSION:
                // This is a way for a driver on NT to find out the DX-Runtime 
                // version. This information is provided to a new driver (i.e. 
                // one that  exposes GETDRIVERINFO2) for DX7 applications and 
                // DX8 applications. And you should get x0000800 for 
                // dwDXVersion; or more accurately, you should get
                // DD_RUNTIME_VERSION which is defined in ddrawi.h.
                pdxv = (DD_DXVERSION*)pgdi2;  
                pThisDisplay->dwDXVersion = pdxv->dwDXVersion;
                lpData->dwActualSize = sizeof(DD_DXVERSION);
                lpData->ddRVal       = DD_OK;                
                break;
                
            case D3DGDI2_TYPE_GETFORMATCOUNT:
                {
                    // Its a request for the number of texture formats
                    // we support. Get the extended data structure so
                    // we can fill in the format count field.
                    pgfcd = (DD_GETFORMATCOUNTDATA*)pgdi2;
                    pgfcd->dwFormatCount = DX8_FORMAT_COUNT;
                    lpData->dwActualSize = sizeof(DD_GETFORMATCOUNTDATA);
                    lpData->ddRVal       = DD_OK;
                }
                break;

            case D3DGDI2_TYPE_GETFORMAT:
                {
                    // Its a request for a particular format we support.
                    // Get the extended data structure so we can fill in
                    // the format field.
                    pgfd = (DD_GETFORMATDATA*)pgdi2;
                    
                    // Initialize the surface description and copy over
                    // the pixel format from out pixel format table.
                    memcpy(&pgfd->format, 
                           &DX8FormatTable[pgfd->dwFormatIndex], 
                           sizeof(pgfd->format));
                    lpData->dwActualSize = sizeof(DD_GETFORMATDATA);
                    lpData->ddRVal       = DD_OK;
                }
                break;

            case D3DGDI2_TYPE_GETD3DCAPS8:
                {
                    // The runtime is requesting the DX8 D3D caps 

                    int    i;
                    size_t copySize;                   
                    
                    // We will populate this caps as much as we can
                    // from the DX7 caps structure(s). ( We need anyway
                    // to be able to report DX7 caps for DX7 apps )
                    __D3D_Fill_DX8Caps(&g_P3RX_D3DCaps8,
                                       &g_P3RXCaps,
                                       &gc_D3DEC,
                                       &pThisDisplay->ddhi32);

                    // And now we fill anything that might not be there
                    // These fields are new and absent from any  other legacy 
                    // structure

                    g_P3RX_D3DCaps8.DeviceType = D3DDEVTYPE_HAL;   // Device Info 
                    g_P3RX_D3DCaps8.AdapterOrdinal = 0;

#if DX_NOT_SUPPORTED_FEATURE
                    // NOTE: In some beta releases of this sample driver we 
                    //       used to setup bit caps for using it as a pure 
                    //       device (D3DDEVCAPS_PUREDEVICE). On the final 
                    //       DX8 release pure devices are not allowed on 
                    //       non-TnL/non hwvp parts as they don't give any 
                    //       real advantage over non-pure ones. 
                    
                    g_P3RX_D3DCaps8.DevCaps |= D3DDEVCAPS_PUREDEVICE;
#endif                    

#if DX8_3DTEXTURES
                    // On Windows XP the ability to lock just a subvolume of a 
                    // volume texture has been introduced in DX8.1 (Windows 2000 
                    // will ignore it)
                    g_P3RX_D3DCaps8.DevCaps |= D3DDEVCAPS_SUBVOLUMELOCK;
#endif // DX8_3DTEXTURES                    
                    
                    // Indicating that the GDI part of the driver can change
                    // gamma ramp while running in full-screen mode.
                    g_P3RX_D3DCaps8.Caps2 |= D3DCAPS2_FULLSCREENGAMMA;

                    // The following field can/should be left as 0 as the
                    // runtime will field them by itself.
                    g_P3RX_D3DCaps8.Caps3 = 0;                
                    g_P3RX_D3DCaps8.PresentationIntervals = 0;

#if DX_NOT_SUPPORTED_FEATURE
                    // If your hw/driver supports colored cursor without
                    // limitations then set these caps as below. We don't
                    // do this in our driver because we have a hw limitation
                    // of 16 colors on the cursor. WHQL tests therefore
                    // fail because of this limitation
                    g_P3RX_D3DCaps8.CursorCaps = D3DCURSORCAPS_COLOR;   
                    
                    // Signal that the driver does support hw cursors
                    // both for hi resolution modes ( height >= 400) and
                    // for low resolution modes as well.
                    g_P3RX_D3DCaps8.CursorCaps |= D3DCURSORCAPS_LOWRES;
#else
                    // We have some limitations (read above) in the Perm3 
                    // hardware so we're not supporting these caps here
                    g_P3RX_D3DCaps8.CursorCaps = 0;                    
#endif                                        
                    // Miscellanneous settings new DX8 features as
                    // pointsprites, multistreaming, 3D textures, 
                    // pixelshaders and vertex shaders
                    g_P3RX_D3DCaps8.MaxVertexIndex = 0x000FFFFF;
                    
#if DX8_POINTSPRITES                      
                    // Notify we can handle pointsprite size
                    g_P3RX_D3DCaps8.FVFCaps |= D3DFVFCAPS_PSIZE;
                    // Notice that the MaxPointSize has to be at least 16
                    // per the DX8 specification for pointsprites.
                    g_P3RX_D3DCaps8.MaxPointSize = P3_MAX_POINTSPRITE_SIZE;
#endif                    

                    // Any DX8 driver must declare it suppports 
                    // AT LEAST 1 stream. Otherwise its used as a DX7 driver.
                    g_P3RX_D3DCaps8.MaxStreams = 1;
                    
                    g_P3RX_D3DCaps8.MaxVertexBlendMatrixIndex = 0; 
                    
                    // NOTE: It is essential that the macros D3DVS_VERSION
                    // and D3DPS_VERSION be used to intialize the vertex
                    // and pixel shader version respecitively. The format
                    // of the version DWORD is complex so please don't try
                    // and build the version DWORD manually.
                    g_P3RX_D3DCaps8.VertexShaderVersion = D3DVS_VERSION(0, 0);
                    g_P3RX_D3DCaps8.PixelShaderVersion  = D3DPS_VERSION(0, 0);

#if DX8_3DTEXTURES                     
                    g_P3RX_D3DCaps8.MaxVolumeExtent = 2048;
#endif                    
        
                    // D3DPTFILTERCAPS for IDirect3DCubeTexture8's                    
                    g_P3RX_D3DCaps8.CubeTextureFilterCaps = 0;      

                    // D3DLINECAPS
                    g_P3RX_D3DCaps8.LineCaps = D3DLINECAPS_TEXTURE  |
                                               D3DLINECAPS_ZTEST    |
                                               D3DLINECAPS_BLEND    |
                                               D3DLINECAPS_ALPHACMP |
                                               D3DLINECAPS_FOG;
                                               
                    // max number of primitives per DrawPrimitive call
                    g_P3RX_D3DCaps8.MaxPrimitiveCount = 0x000FFFFF;         
                     // max value of pixel shade
                    g_P3RX_D3DCaps8.MaxPixelShaderValue = 0;       
                    // max stride for SetStreamSource
                    // we will use this defualt value for now
                    g_P3RX_D3DCaps8.MaxStreamStride = 256;    
                    // number of vertex shader constant 
                    g_P3RX_D3DCaps8.MaxVertexShaderConst = 0;       

#if DX8_3DTEXTURES 
                    g_P3RX_D3DCaps8.VolumeTextureFilterCaps = 
                                           D3DPTFILTERCAPS_MINFPOINT |
                                           D3DPTFILTERCAPS_MAGFPOINT;
                                           
                    g_P3RX_D3DCaps8.VolumeTextureAddressCaps =     
                                           D3DPTADDRESSCAPS_WRAP     |
                                           D3DPTADDRESSCAPS_MIRROR   |                                           
                                           D3DPTADDRESSCAPS_CLAMP;
#endif // DX8_3DTEXTURES

                    // It should be noted that the dwExpectedSize field
                    // of DD_GETDRIVERINFODATA is not used for
                    // GetDriverInfo2 calls and should be ignored.                   
                    copySize = min(sizeof(g_P3RX_D3DCaps8), 
                                   pgdi2->dwExpectedSize);
                    memcpy(lpData->lpvData, &g_P3RX_D3DCaps8, copySize);
                    lpData->dwActualSize = copySize;
                    lpData->ddRVal       = DD_OK;
                }
            default:
                // Default behavior for any other type.
                break;
            }
        }
        else
#endif // DX8_DDI
        {
#if WNT_DDRAW
#if DX7_STEREO
            PDD_STEREOMODE pDDStereoMode;

            // Permedia3 supports all modes as stereo modes.
            // for test purposes, we restrict them to something
            // larger than 320x240

            //
            // note: this GUID_DDStereoMode is only used on NT to
            // report stereo modes. There is no need to implement
            // it in win9x drivers. Win9x drivers report stereo
            // modes by setting the DDMODEINFO_STEREO bit in the
            // dwFlags member of the DDHALMODEINFO structure.
            // It is also recommended to report DDMODEINFO_MAXREFRESH
            // for stereo modes when running under a runtime >= DX7 to
            // allow applications to select higher refresh rates for
            // stereo modes.
            //

            if (lpData->dwExpectedSize >= sizeof(PDD_STEREOMODE))
            {
                pDDStereoMode = (PDD_STEREOMODE)lpData->lpvData;

                pDDStereoMode->bSupported =
                    _DD_bIsStereoMode(pThisDisplay,
                                      pDDStereoMode->dwWidth,
                                      pDDStereoMode->dwHeight,
                                      pDDStereoMode->dwBpp);

                DISPDBG((DBGLVL,"  GUID_DDStereoMode(%d,%d,%d,%d=%d)",
                    pDDStereoMode->dwWidth,
                    pDDStereoMode->dwHeight,
                    pDDStereoMode->dwBpp,
                    pDDStereoMode->dwRefreshRate,
                    pDDStereoMode->bSupported));

                lpData->dwActualSize = sizeof(DD_STEREOMODE);
                lpData->ddRVal = DD_OK;        
            }
#endif // DX7_STEREO
#endif // WNT_DDRAW
        }
    }

    DBG_EXIT(_D3DGetDriverInfo, 0);
    
} // _D3DGetDriverInfo

//-----------------------------------------------------------------------------
//
// __D3D_BuildTextureFormatsP3
//
// Fills a list of texture formats in.  
// Returns the number of formats specified.  
//
//-----------------------------------------------------------------------------
void 
__D3D_BuildTextureFormatsP3(
    P3_THUNKEDDATA *pThisDisplay, 
    DDSURFACEDESC TexFmt[MAX_TEXTURE_FORMAT],
    DWORD *pNumTextures)
{
    int i;

    // Initialise the defaults
    for (i = 0; i < MAX_TEXTURE_FORMAT; i++)
    {
        TexFmt[i].dwSize = sizeof(DDSURFACEDESC);
        TexFmt[i].dwFlags = DDSD_CAPS | DDSD_PIXELFORMAT;
        TexFmt[i].dwHeight = 0;
        TexFmt[i].dwWidth = 0;
        TexFmt[i].lPitch = 0;
        TexFmt[i].dwBackBufferCount = 0;
        TexFmt[i].dwZBufferBitDepth = 0;
        TexFmt[i].dwReserved = 0;
        TexFmt[i].lpSurface = 0;

        TexFmt[i].ddckCKDestOverlay.dwColorSpaceLowValue = 0;
        TexFmt[i].ddckCKDestOverlay.dwColorSpaceHighValue = 0;
        
        TexFmt[i].ddckCKDestBlt.dwColorSpaceLowValue = 0;
        TexFmt[i].ddckCKDestBlt.dwColorSpaceHighValue = 0;

        TexFmt[i].ddckCKSrcOverlay.dwColorSpaceLowValue = 0;
        TexFmt[i].ddckCKSrcOverlay.dwColorSpaceHighValue = 0;

        TexFmt[i].ddckCKSrcBlt.dwColorSpaceLowValue = 0;
        TexFmt[i].ddckCKSrcBlt.dwColorSpaceHighValue = 0;
        TexFmt[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    }
    i = 0;

    // 5:5:5 RGB
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    TexFmt[i].ddpfPixelFormat.dwRGBBitCount = 16;
    TexFmt[i].ddpfPixelFormat.dwRBitMask = 0x7C00;
    TexFmt[i].ddpfPixelFormat.dwGBitMask = 0x03E0;
    TexFmt[i].ddpfPixelFormat.dwBBitMask = 0x001F;
    TexFmt[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0;
    i++;

    // 8:8:8 RGB
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    TexFmt[i].ddpfPixelFormat.dwRGBBitCount = 32;
    TexFmt[i].ddpfPixelFormat.dwRBitMask = 0xff0000;
    TexFmt[i].ddpfPixelFormat.dwGBitMask = 0xff00;
    TexFmt[i].ddpfPixelFormat.dwBBitMask = 0xff;
    TexFmt[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0;
    i++;

    // 1:5:5:5 ARGB 
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
    TexFmt[i].ddpfPixelFormat.dwRGBBitCount = 16;
    TexFmt[i].ddpfPixelFormat.dwRBitMask = 0x7C00;
    TexFmt[i].ddpfPixelFormat.dwGBitMask = 0x03E0;
    TexFmt[i].ddpfPixelFormat.dwBBitMask = 0x001F;
    TexFmt[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0x8000;
    i++;        
    
    // 4:4:4:4 ARGB
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
    TexFmt[i].ddpfPixelFormat.dwRGBBitCount = 16;
    TexFmt[i].ddpfPixelFormat.dwRBitMask = 0xf00;
    TexFmt[i].ddpfPixelFormat.dwGBitMask = 0xf0;
    TexFmt[i].ddpfPixelFormat.dwBBitMask = 0xf;
    TexFmt[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xf000;
    i++;
    
    // 8:8:8:8 ARGB 
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_ALPHAPIXELS;
    TexFmt[i].ddpfPixelFormat.dwRGBBitCount = 32;
    TexFmt[i].ddpfPixelFormat.dwRBitMask = 0xff0000;
    TexFmt[i].ddpfPixelFormat.dwGBitMask = 0xff00;
    TexFmt[i].ddpfPixelFormat.dwBBitMask = 0xff;
    TexFmt[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xff000000;
    i++;

    // 5:6:5
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    TexFmt[i].ddpfPixelFormat.dwRGBBitCount = 16;
    TexFmt[i].ddpfPixelFormat.dwRBitMask = 0xF800;
    TexFmt[i].ddpfPixelFormat.dwGBitMask = 0x07E0;
    TexFmt[i].ddpfPixelFormat.dwBBitMask = 0x001F;
    TexFmt[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0;
    i++;

    // A4L4
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_LUMINANCE | DDPF_ALPHAPIXELS;
    TexFmt[i].ddpfPixelFormat.dwLuminanceBitCount = 8;
    TexFmt[i].ddpfPixelFormat.dwLuminanceBitMask = 0x0F;
    TexFmt[i].ddpfPixelFormat.dwLuminanceAlphaBitMask = 0xF0;
    i++;

    // A8L8
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_LUMINANCE | DDPF_ALPHAPIXELS;
    TexFmt[i].ddpfPixelFormat.dwLuminanceBitCount = 16;
    TexFmt[i].ddpfPixelFormat.dwLuminanceBitMask = 0x00FF;
    TexFmt[i].ddpfPixelFormat.dwLuminanceAlphaBitMask = 0xFF00;
    i++;
    
//@@BEGIN_DDKSPLIT 
#if 0
    // A8
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_ALPHA;
    TexFmt[i].ddpfPixelFormat.dwAlphaBitDepth = 8;
    TexFmt[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0xFF;
    i++;
#endif    
//@@END_DDKSPLIT

    // L8 
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_LUMINANCE;
    TexFmt[i].ddpfPixelFormat.dwLuminanceBitCount = 8;
    TexFmt[i].ddpfPixelFormat.dwLuminanceBitMask = 0xFF;
    TexFmt[i].ddpfPixelFormat.dwLuminanceAlphaBitMask = 0;
    i++;

#if DX7_PALETTETEXTURE
    // P8 
    ZeroMemory(&TexFmt[i].ddpfPixelFormat, sizeof(DDPIXELFORMAT));
    TexFmt[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    TexFmt[i].ddpfPixelFormat.dwFourCC = 0;
    TexFmt[i].ddpfPixelFormat.dwFlags = DDPF_RGB | DDPF_PALETTEINDEXED8;
    TexFmt[i].ddpfPixelFormat.dwRGBBitCount = 8;
    TexFmt[i].ddpfPixelFormat.dwRBitMask = 0x00000000;
    TexFmt[i].ddpfPixelFormat.dwGBitMask = 0x00000000;
    TexFmt[i].ddpfPixelFormat.dwBBitMask = 0x00000000;
    TexFmt[i].ddpfPixelFormat.dwRGBAlphaBitMask = 0x00000000;

    // Notice we aren't incrementing i for this format. This will effectively
    // cause us to not report the palettized texture format in our DX7 caps
    // list. This is intentional, and driver writers may choose to follow or
    // not this approach. For our DX8 caps list we DO list paletted texture
    // formats as supported. __SUR_bCheckTextureFormat is written to make
    // sure we can create a paletted texture when asked for it.

    // The whole reason behind this approach is because in legacy DX interfaces
    // the TextureSwap method causes the surface and palette handle association 
    // to be lost. While there are some ugly and tricky ways around this (as in 
    // the Permedia2 sample driver), and there is no rational way to fix the 
    // problem. 
    
#endif
    
    // Return the number of texture formats to use
    *pNumTextures = i;
    
} // __D3D_BuildTextureFormatsP3

#if DX8_DDI
//-----------------------------------------------------------------------------
//
// __D3D_Fill_DX8Caps
//
// Fills the D3DCAPS8 structure of a DX8 driver from legacy caps structures.
//
//-----------------------------------------------------------------------------
void 
__D3D_Fill_DX8Caps(
    D3DCAPS8 *pd3d8caps,
    D3DDEVICEDESC_V1 *pDeviceDesc,
    D3DHAL_D3DEXTENDEDCAPS *pD3DEC,
    DDHALINFO *pDDHALInfo)
{

    pd3d8caps->Caps  = pDDHALInfo->ddCaps.dwCaps;
    pd3d8caps->Caps2 = pDDHALInfo->ddCaps.dwCaps2;  

    pd3d8caps->DevCaps           = pDeviceDesc->dwDevCaps;

    pd3d8caps->PrimitiveMiscCaps = pDeviceDesc->dpcTriCaps.dwMiscCaps;
    pd3d8caps->RasterCaps        = pDeviceDesc->dpcTriCaps.dwRasterCaps;
    pd3d8caps->ZCmpCaps          = pDeviceDesc->dpcTriCaps.dwZCmpCaps;
    pd3d8caps->SrcBlendCaps      = pDeviceDesc->dpcTriCaps.dwSrcBlendCaps;
    pd3d8caps->DestBlendCaps     = pDeviceDesc->dpcTriCaps.dwDestBlendCaps;
    pd3d8caps->AlphaCmpCaps      = pDeviceDesc->dpcTriCaps.dwAlphaCmpCaps;
    pd3d8caps->ShadeCaps         = pDeviceDesc->dpcTriCaps.dwShadeCaps;
    pd3d8caps->TextureCaps       = pDeviceDesc->dpcTriCaps.dwTextureCaps;
    pd3d8caps->TextureFilterCaps = pDeviceDesc->dpcTriCaps.dwTextureFilterCaps;      
    pd3d8caps->TextureAddressCaps= pDeviceDesc->dpcTriCaps.dwTextureAddressCaps;

    pd3d8caps->MaxTextureWidth   = pD3DEC->dwMaxTextureWidth;
    pd3d8caps->MaxTextureHeight  = pD3DEC->dwMaxTextureHeight;
    
    pd3d8caps->MaxTextureRepeat  = pD3DEC->dwMaxTextureRepeat;
    pd3d8caps->MaxTextureAspectRatio = pD3DEC->dwMaxTextureAspectRatio;
    pd3d8caps->MaxAnisotropy     = pD3DEC->dwMaxAnisotropy;
    pd3d8caps->MaxVertexW        = pD3DEC->dvMaxVertexW;

    pd3d8caps->GuardBandLeft     = pD3DEC->dvGuardBandLeft;
    pd3d8caps->GuardBandTop      = pD3DEC->dvGuardBandTop;
    pd3d8caps->GuardBandRight    = pD3DEC->dvGuardBandRight;
    pd3d8caps->GuardBandBottom   = pD3DEC->dvGuardBandBottom;

    pd3d8caps->ExtentsAdjust     = pD3DEC->dvExtentsAdjust;
    pd3d8caps->StencilCaps       = pD3DEC->dwStencilCaps;

    pd3d8caps->FVFCaps           = pD3DEC->dwFVFCaps;
    pd3d8caps->TextureOpCaps     = pD3DEC->dwTextureOpCaps;
    pd3d8caps->MaxTextureBlendStages     = pD3DEC->wMaxTextureBlendStages;
    pd3d8caps->MaxSimultaneousTextures   = pD3DEC->wMaxSimultaneousTextures;

    pd3d8caps->VertexProcessingCaps      = pD3DEC->dwVertexProcessingCaps;
    pd3d8caps->MaxActiveLights           = pD3DEC->dwMaxActiveLights;
    pd3d8caps->MaxUserClipPlanes         = pD3DEC->wMaxUserClipPlanes;
    pd3d8caps->MaxVertexBlendMatrices    = pD3DEC->wMaxVertexBlendMatrices;

} // __D3D_Fill_DX8Caps
#endif // DX8_DDI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dbuff.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dbuff.c
*
//@@BEGIN_DDKSPLIT
* Content: Main context callbacks for D3D videomemory buffers
//@@END_DDKSPLIT
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "dma.h"
#include "tag.h"

//@@BEGIN_DDKSPLIT
#if DX7_VERTEXBUFFERS

#define _32_KBYTES ( 32 * 1024 )

//-----------------------------------------------------------------------------
// in-the-file nonexported forward declarations
//-----------------------------------------------------------------------------
                                  
BOOL __EB_RemoveFromBufferQueue(P3_THUNKEDDATA* pThisDisplay, 
                                   P3_VERTEXBUFFERINFO* pVictim);
void __EB_Wait(P3_THUNKEDDATA* pThisDisplay, P3_VERTEXBUFFERINFO* pBuffer);

#if DBG 
//-----------------------------------------------------------------------------
//
// __EB_DisplayHeapInfo
//
// A debug function.  Displays the current buffer queue
//
//-----------------------------------------------------------------------------
void 
__EB_DisplayHeapInfo(
    int DebugLevel, 
    P3_THUNKEDDATA* pThisDisplay)
{
    DWORD dwSequenceID = 0xFFFFFFFF;
   
    if (DebugLevel <= P3R3DX_DebugLevel)
    {
        P3_VERTEXBUFFERINFO* pCurrentCommandBuffer = 
                                        pThisDisplay->pRootCommandBuffer;
        P3_VERTEXBUFFERINFO* pCurrentVertexBuffer = 
                                        pThisDisplay->pRootVertexBuffer;
        int count = 0;

        DISPDBG((DebugLevel,"Command buffer heap"));
        
        dwSequenceID = 0xFFFFFFFF;
        if (pCurrentCommandBuffer) 
        {           
            do
            {
                // A debug check to ensure that the sequence ID's go backwards
                ASSERTDD((dwSequenceID >= pCurrentCommandBuffer->dwSequenceID),
                          "ERROR: Sequence ID's broken!");
                          
                DISPDBG((DebugLevel,"Buffer %d,SequenceID:0x%x Pointer: 0x%x",
                                    count++, 
                                    pCurrentCommandBuffer->dwSequenceID, 
                                    pCurrentCommandBuffer));
                DISPDBG((DebugLevel,"  pPrev: 0x%x, pNext: 0x%x", 
                                    pCurrentCommandBuffer->pPrev, 
                                    pCurrentCommandBuffer->pNext));
                DISPDBG((DebugLevel,"  bInUse: %d", 
                                    pCurrentCommandBuffer->bInUse));
                                    
                dwSequenceID = pCurrentCommandBuffer->dwSequenceID;
                pCurrentCommandBuffer = pCurrentCommandBuffer->pNext;
                
            } while (pCurrentCommandBuffer != pThisDisplay->pRootCommandBuffer);
        }

        DISPDBG((DebugLevel,"Vertex buffer heap"));

        dwSequenceID = 0xFFFFFFFF;
        if (pCurrentVertexBuffer) 
        {           
            do
            {
                // A debug check to ensure that the sequence ID's go backwards
                ASSERTDD((dwSequenceID >= pCurrentVertexBuffer->dwSequenceID),
                          "ERROR: Sequence ID's broken!");

                DISPDBG((DebugLevel,"Buffer %d,SequenceID:0x%x Pointer: 0x%x",
                                    count++, 
                                    pCurrentVertexBuffer->dwSequenceID, 
                                    pCurrentVertexBuffer));
                DISPDBG((DebugLevel,"  pPrev: 0x%x, pNext: 0x%x", 
                                    pCurrentVertexBuffer->pPrev, 
                                    pCurrentVertexBuffer->pNext));
                DISPDBG((DebugLevel,"  bInUse: %d", 
                                    pCurrentVertexBuffer->bInUse));
                                    
                dwSequenceID = pCurrentVertexBuffer->dwSequenceID;
                pCurrentVertexBuffer = pCurrentVertexBuffer->pNext;
            } while (pCurrentVertexBuffer != pThisDisplay->pRootVertexBuffer);
        }

    }
    
} // __EB_DisplayHeapInfo

#endif // DBG



//-----------------------------------------------------------------------------
//
// __EB_FreeCachedBuffer
//
// Frees a buffer associated with this directdraw surface.  This is called
// in response to a destroyexecutebuffer call
//
//-----------------------------------------------------------------------------
void 
__EB_FreeCachedBuffer(
    P3_THUNKEDDATA* pThisDisplay, 
    LPDDRAWI_DDRAWSURFACE_LCL pSurf)
{
    P3_VERTEXBUFFERINFO* pVictim = 
                        (P3_VERTEXBUFFERINFO*)pSurf->lpGbl->dwReserved1;

    if (pVictim != NULL)
    {
        DISPDBG((DBGLVL,"Buffer is one of ours - destroying it"));

        // Wait for the buffer to be consumed
        __EB_Wait(pThisDisplay, pVictim);

        // Set the inuse flag off so the buffer will be freed.
        pVictim->bInUse = FALSE;

        // Remove the buffer from the pending list
        // The memory won't be freed if the buffer isn't in the list
        if (!__EB_RemoveFromBufferQueue(pThisDisplay, pVictim))
        {
            // Free the memory
            switch (pVictim->BufferType)
            {
            case COMMAND_BUFFER:
                _DX_LIN_FreeLinearMemory(&pThisDisplay->CachedCommandHeapInfo, 
                                         PtrToUlong(pVictim));
                break;
                
            case VERTEX_BUFFER:
                _DX_LIN_FreeLinearMemory(&pThisDisplay->CachedVertexHeapInfo, 
                                         PtrToUlong(pVictim));
                break;
            }
        }

        // Reset the buffer pointers
        pSurf->lpGbl->dwReserved1 = 0;
        pSurf->lpGbl->fpVidMem = 0;
    }

} // __EB_FreeCachedBuffer

//-----------------------------------------------------------------------------
//
// __EB_GetSequenceID
//
// Each vertex buffer and command buffer is "stamped" with a sequence ID which
// can be queried in order to find out if a given buffer was already consumed
// by the hardware. __EB_GetSequenceID returns us the sequence ID of the last
// processed buffer.
//
//-----------------------------------------------------------------------------
const DWORD 
__EB_GetSequenceID(
    P3_THUNKEDDATA* pThisDisplay)
{
    DWORD dwSequenceID;

    dwSequenceID = READ_GLINT_CTRL_REG(HostInID);

    DISPDBG((DBGLVL,"HostIn ID: 0x%x", dwSequenceID));

    return dwSequenceID;
    
} // __EB_GetSequenceID

//-----------------------------------------------------------------------------
//
// __EB_GetNewSequenceID
//
// A driver routine to increment the sequence ID and return it.  This 
// routine handles the case where the buffer is wrapped beyond the maximum
// number that it can hold.  In such case all buffers are flushed
// 
//-----------------------------------------------------------------------------
const DWORD 
__EB_GetNewSequenceID(
     P3_THUNKEDDATA* pThisDisplay)
{
    DWORD dwWrapMask;
    
    DBG_ENTRY(__EB_GetNewSequenceID);

#if DBG
    dwWrapMask = 0x1F;
#else
    dwWrapMask = 0xFFFFFFFF;
#endif

    if( pThisDisplay->dwCurrentSequenceID >= dwWrapMask )
    {
        // We have wrapped, so flush all the buffers 
        // but wait for them to be consumed (bWait == TRUE)
        _D3D_EB_FlushAllBuffers(pThisDisplay , TRUE);

        // This SYNC is needed for unknown reasons - further investigation
        // required. //azn???

        SYNC_WITH_GLINT;

        // Reset the sequence ID numbering
        pThisDisplay->dwCurrentSequenceID = 0;
    }
    else
    {
        pThisDisplay->dwCurrentSequenceID++;
    }

    DISPDBG((DBGLVL, "Returning Sequence ID: 0x%x", 
                     pThisDisplay->dwCurrentSequenceID));

    DBG_EXIT(__EB_GetNewSequenceID,pThisDisplay->dwCurrentSequenceID);
    return pThisDisplay->dwCurrentSequenceID;
    
} // __EB_GetNewSequenceID



//-----------------------------------------------------------------------------
//
// __EB_Wait
//
// If the current buffer is in the queue, wait for it to pass through
// the chip.
//
//-----------------------------------------------------------------------------
void 
__EB_Wait(
    P3_THUNKEDDATA* pThisDisplay, 
    P3_VERTEXBUFFERINFO* pBuffer)
{   
    DBG_ENTRY(__EB_Wait);

    ASSERTDD(pBuffer, "ERROR: Buffer passed to __EB_Wait is null!");

    // Don't wait for the buffer, if it has not been added to the queue
    if (pBuffer->pNext != NULL)
    {
        // Flush to ensure that the hostin ID has been sent to the chip
        P3_DMA_DEFS();
        P3_DMA_GET_BUFFER();
        P3_DMA_FLUSH_BUFFER();

        DISPDBG((DBGLVL, "*** In __EB_Wait: Buffer Sequence ID: 0x%x", 
                         pBuffer->dwSequenceID));

        while (__EB_GetSequenceID(pThisDisplay) < pBuffer->dwSequenceID)
        {
            static int blockCount;
            
            // This buffer is in the chain of buffers that are being used
            // by the host-in unit.  We must wait for it to be consumed
            // before freeing it.

            blockCount = 100;
            while( blockCount-- )
                NULL;
        }
    }

    DBG_EXIT(__EB_Wait,0);
} // __EB_Wait

//-----------------------------------------------------------------------------
//
// __EB_RemoveFromBufferQueue
//
// Removes a buffer from the queue. Will also free the associated memory
// if it is no longer in use
//
//-----------------------------------------------------------------------------
BOOL 
__EB_RemoveFromBufferQueue(
    P3_THUNKEDDATA* pThisDisplay, 
    P3_VERTEXBUFFERINFO* pVictim)
{
    ASSERTDD(pVictim != NULL, 
             "ERROR: NULL buffer passed to EB_RemoveFromList");

    DBG_ENTRY(__EB_RemoveFromBufferQueue);

    // Don't remove a buffer that isn't already in the queue
    if (pVictim->pNext == NULL)
    {    
        DBG_EXIT(__EB_RemoveFromBufferQueue,FALSE);
        return FALSE;
    }

    DISPDBG((DBGLVL,"Removing buffer for queue, ID: 0x%x", 
                    pVictim->dwSequenceID));

    // Remove this entry from the list
    pVictim->pPrev->pNext = pVictim->pNext;
    pVictim->pNext->pPrev = pVictim->pPrev;
    
    switch (pVictim->BufferType)
    {
    case COMMAND_BUFFER:
        // Replace the root node if necessary       
        if (pVictim == pThisDisplay->pRootCommandBuffer)
        {
            if (pVictim->pNext != pThisDisplay->pRootCommandBuffer)
            {
                pThisDisplay->pRootCommandBuffer = pVictim->pNext;
            }
            else
            {
                pThisDisplay->pRootCommandBuffer = NULL;
            }
        }
        break;

    case VERTEX_BUFFER:
        // Replace the root node if necessary       
        if (pVictim == pThisDisplay->pRootVertexBuffer)
        {
            if (pVictim->pNext != pThisDisplay->pRootVertexBuffer)
            {
                pThisDisplay->pRootVertexBuffer = pVictim->pNext;
            }
            else
            {
                pThisDisplay->pRootVertexBuffer = NULL;
            }
        }
        break;
    
    } // switch (pVictim->BufferType)

    // Buffer is no longer in the list
    pVictim->pPrev = NULL;
    pVictim->pNext = NULL;

    // Free the memory we found if it isn't reserved as a real buffer.
    if (!pVictim->bInUse)
    {
        DISPDBG((DBGLVL,"  Buffer is old - freeing the memory"));

        switch (pVictim->BufferType)
        {
        case COMMAND_BUFFER:
            _DX_LIN_FreeLinearMemory(&pThisDisplay->CachedCommandHeapInfo, 
                                     PtrToUlong(pVictim));
            break;
            
        case VERTEX_BUFFER:
            _DX_LIN_FreeLinearMemory(&pThisDisplay->CachedVertexHeapInfo, 
                                     PtrToUlong(pVictim));
            break;
        }
        
        DBG_EXIT(__EB_RemoveFromBufferQueue,TRUE);
        return TRUE;
    }

    DBG_EXIT(__EB_RemoveFromBufferQueue,FALSE);
    return FALSE;
    
} // __EB_RemoveFromBufferQueue

//-----------------------------------------------------------------------------
//
// __EB_AddToBufferQueue
//
// Adds a buffer to the queue.  Note that buffers are always added
// at the start to maintain a temporal ordering of the buffers.
//
//-----------------------------------------------------------------------------
void 
__EB_AddToBufferQueue(
    P3_THUNKEDDATA* pThisDisplay, 
    P3_VERTEXBUFFERINFO* pNewBuffer)
{
    DBG_ENTRY(__EB_AddToBufferQueue);

    ASSERTDD(pNewBuffer != NULL, 
             "ERROR: NULL buffer passed to EB_AddToList");
    ASSERTDD(pNewBuffer->pNext == NULL, 
             "ERROR: Buffer already in queue (pNext!NULL)");
    ASSERTDD(pNewBuffer->pPrev == NULL, 
             "ERROR: Buffer already in queue (pPrev!NULL)");

    switch(pNewBuffer->BufferType)
    {
    case COMMAND_BUFFER:
        // Add the buffer to the queue
        // Check that the queue isn't empty.
        // If it is start a new list
        if (pThisDisplay->pRootCommandBuffer == NULL)
        {
            DISPDBG((DBGLVL,"Command Buffer queue is empty."
                            "  Starting a new one"));

            // Sew in the buffer
            pThisDisplay->pRootCommandBuffer = pNewBuffer;
            pNewBuffer->pNext = pNewBuffer;
            pNewBuffer->pPrev = pNewBuffer;
        }
        else
        {
            DISPDBG((DBGLVL,"Adding command buffer to the list"));

            // Always put new buffers at the root.
            pNewBuffer->pNext = pThisDisplay->pRootCommandBuffer;
            pNewBuffer->pPrev = pThisDisplay->pRootCommandBuffer->pPrev;
            pThisDisplay->pRootCommandBuffer->pPrev->pNext = pNewBuffer;
            pThisDisplay->pRootCommandBuffer->pPrev = pNewBuffer;
            pThisDisplay->pRootCommandBuffer = pNewBuffer;
        }
        break;

    case VERTEX_BUFFER:
        // Add the buffer to the queue
        // Check that the queue isn't empty.  If it is start a new list
        if (pThisDisplay->pRootVertexBuffer == NULL)
        {
            DISPDBG((DBGLVL,"Vertex Buffer queue is empty.  Starting a new one"));

            // Sew in the buffer
            pThisDisplay->pRootVertexBuffer = pNewBuffer;
            pNewBuffer->pNext = pNewBuffer;
            pNewBuffer->pPrev = pNewBuffer;
        }
        else
        {
            DISPDBG((DBGLVL,"Adding vertex buffer to the list"));

            // Always put new buffers at the root.
            pNewBuffer->pNext = pThisDisplay->pRootVertexBuffer;
            pNewBuffer->pPrev = pThisDisplay->pRootVertexBuffer->pPrev;
            pThisDisplay->pRootVertexBuffer->pPrev->pNext = pNewBuffer;
            pThisDisplay->pRootVertexBuffer->pPrev = pNewBuffer;
            pThisDisplay->pRootVertexBuffer = pNewBuffer;
        }
        break;
    } // switch(pNewBuffer->BufferType)


    DISPDBG((DBGLVL, "Added buffer to queue, ID: 0x%x", pNewBuffer->dwSequenceID));
    DBG_EXIT(__EB_AddToBufferQueue,pNewBuffer->dwSequenceID);
    
} // __EB_AddToBufferQueue        

//-----------------------------------------------------------------------------
//
// __EB_AllocateCachedBuffer
//
// Allocates a cached buffer and stores it in the surface structure.
// First this function will try to allocate out of the linear heap.
// If this fails, it will keep walking the buffer queue until there 
// are no more buffers left that are pending and aren't in use.
// If all else fails this driver will return FALSE indicating that
// it couldn't allocate the memory due to lack of space
//
//-----------------------------------------------------------------------------
BOOL 
__EB_AllocateCachedBuffer(
    P3_THUNKEDDATA* pThisDisplay, 
    DWORD dwBytes, 
    LPDDRAWI_DDRAWSURFACE_LCL pSurf)
{
    P3_MEMREQUEST mmrq;
    DWORD dwResult;
    P3_VERTEXBUFFERINFO* pCurrentBuffer;
    P3_VERTEXBUFFERINFO** ppRootBuffer;
    BOOL bFound;
    eBufferType BufferType;
    pLinearAllocatorInfo pAllocHeap;
    static int blockCount;

    DBG_ENTRY(__EB_AllocateCachedBuffer);

#if WNT_DDRAW
    pAllocHeap = &pThisDisplay->CachedVertexHeapInfo;
    BufferType = VERTEX_BUFFER;
    ppRootBuffer = &pThisDisplay->pRootVertexBuffer;
#else
    // Decide on which heap this surface should come out of.
    if (pSurf->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_COMMANDBUFFER)
    {
        pAllocHeap = &pThisDisplay->CachedCommandHeapInfo;
        BufferType = COMMAND_BUFFER;
        ppRootBuffer = &pThisDisplay->pRootCommandBuffer;

        DISPDBG((DBGLVL,"Buffer is COMMAND_BUFFER"));
    }
    else
    {
        pAllocHeap = &pThisDisplay->CachedVertexHeapInfo;
        BufferType = VERTEX_BUFFER;
        ppRootBuffer = &pThisDisplay->pRootVertexBuffer;

        DISPDBG((DBGLVL,"Buffer is VERTEX_BUFFER"));
    }
#endif // WNT_DDRAW

#if DBG
    // Dump the memory and the pending buffer heaps.
    __EB_DisplayHeapInfo(DBGLVL, pThisDisplay);
#endif //DBG

    // Do a quick check to see if the buffer at the back is free.
    if ((*ppRootBuffer) != NULL)
    {
        pCurrentBuffer = (*ppRootBuffer)->pPrev;
        // If the buffer is big enough, and it's completed, and 
        // it isn't in use, then free it.
        if ( ((dwBytes + sizeof(P3_VERTEXBUFFERINFO)) <= pCurrentBuffer->dwSize) &&
             (!pCurrentBuffer->bInUse) &&
             (__EB_GetSequenceID(pThisDisplay) >= pCurrentBuffer->dwSequenceID) )
        {
            // Mark this buffer as in use, so that it doesn't get freed
            pCurrentBuffer->bInUse = TRUE;

            // It isn't pending any more, so remove it from the queue
            // Note that the memory won't be deallocated because we have explicity
            // marked it as in use.
            __EB_RemoveFromBufferQueue(pThisDisplay, pCurrentBuffer);
            
            // Pass back a pointer to the memory
            pSurf->lpGbl->fpVidMem = (FLATPTR)((BYTE *)pCurrentBuffer) + 
                                                    sizeof(P3_VERTEXBUFFERINFO);

            // Store a pointer to the info block at the start of the memory
            pSurf->lpGbl->dwReserved1 = (ULONG_PTR)pCurrentBuffer;
#if W95_DDRAW
            // Setup the caps
            pSurf->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_SYSMEMEXECUTEBUFFER;
#endif      
            // If you set these you don't see any locks....
            pSurf->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;

            // Remember the new size
            pSurf->lpGbl->dwLinearSize = dwBytes;

            // Mark the buffer as in use and return it
            pCurrentBuffer->dwSequenceID = 0;
            pCurrentBuffer->bInUse = TRUE;
            pCurrentBuffer->pNext = NULL;
            pCurrentBuffer->pPrev = NULL;
            pCurrentBuffer->BufferType = BufferType;
            pCurrentBuffer->dwSize = dwBytes + sizeof(P3_VERTEXBUFFERINFO);    

            DISPDBG((DBGLVL,"Found a re-useable buffer "
                            "- didn't need to reallocate memory"));

            DBG_EXIT(__EB_AllocateCachedBuffer,TRUE);
            return TRUE;
        }
    }

    // do things the longer way...
    // Try to allocate the requested memory
    do
    {
        ZeroMemory(&mmrq, sizeof(P3_MEMREQUEST));
        mmrq.dwSize = sizeof(P3_MEMREQUEST);
        mmrq.dwAlign = 4;   
        mmrq.dwBytes = dwBytes + sizeof(P3_VERTEXBUFFERINFO);
        mmrq.dwFlags = MEM3DL_FIRST_FIT | MEM3DL_FRONT;
        dwResult = _DX_LIN_AllocateLinearMemory(pAllocHeap, &mmrq);
        if (dwResult == GLDD_SUCCESS)
        {
            DISPDBG((DBGLVL,"Allocated a cached buffer"));

            // Pass back a pointer to the memory
            pSurf->lpGbl->fpVidMem = mmrq.pMem + sizeof(P3_VERTEXBUFFERINFO);

            // Store a pointer to the info block at the start of the memory
            pSurf->lpGbl->dwReserved1 = mmrq.pMem;
#if W95_DDRAW
            // Setup the caps
            pSurf->lpGbl->dwGlobalFlags |= DDRAWISURFGBL_SYSMEMEXECUTEBUFFER;
#endif
            // If you set these you don't see any locks....
            pSurf->ddsCaps.dwCaps |= DDSCAPS_VIDEOMEMORY;

            // Remember the new size
            pSurf->lpGbl->dwLinearSize = dwBytes;

            // Mark the buffer as in use and return it
            pCurrentBuffer = (P3_VERTEXBUFFERINFO*)(ULONG_PTR)mmrq.pMem;
            pCurrentBuffer->dwSequenceID = 0;
            pCurrentBuffer->bInUse = TRUE;
            pCurrentBuffer->pNext = NULL;
            pCurrentBuffer->pPrev = NULL;
            pCurrentBuffer->BufferType = BufferType;
            pCurrentBuffer->dwSize = dwBytes + sizeof(P3_VERTEXBUFFERINFO);
            
            DBG_EXIT(__EB_AllocateCachedBuffer,TRUE);
            return TRUE;
        }
        else
        {
            DISPDBG((DBGLVL,"Failed to allocate cached buffer"));

            // Remember that we haven't found any memory yet.
            // and that there isn't any memory to use.
            bFound = FALSE;
            
            // There are no buffers currently available.  
            // Wait for a new one to be free from the
            // ones that are available and in the queue

            // None at all?  No chance of any memory being free
            // Return FALSE to indicate this.
            if ((*ppRootBuffer) == NULL)
            {
                DISPDBG((DBGLVL,"No buffers in the list!"));
                
                DBG_EXIT(__EB_AllocateCachedBuffer,FALSE);
                return FALSE;
            }

            // Start at the back of the queue, as these are 
            // the least recently used buffers
            pCurrentBuffer = (*ppRootBuffer)->pPrev;
            do
            {
                P3_DMA_DEFS();

                // Ensure that all DMA is completed so that the HostIn
                // ID is up to date
                P3_DMA_GET_BUFFER();
                P3_DMA_FLUSH_BUFFER();

                DISPDBG((DBGLVL,"Searching for old buffers..."));

                // Check to see if this buffer is available to be freed
                // It may not be if it is a buffer that hasn't been swapped out,
                // such as a vertex buffer.

                DISPDBG((DBGLVL,"This buffer ID: 0x%x", 
                                pCurrentBuffer->dwSequenceID));

                if( __EB_GetSequenceID(pThisDisplay) >= 
                            pCurrentBuffer->dwSequenceID )
                {
                    DISPDBG((DBGLVL,"Found a buffer that can be "
                                    "removed from the list"));

                    // It isn't pending any more, so remove it from the queue
                    if (__EB_RemoveFromBufferQueue(pThisDisplay, pCurrentBuffer))
                    {
                        bFound = TRUE;
                        break;
                    }

                    // If the queue is gone, exit (bFound hasn't been
                    // setup because we didn't find any memory in the queue)
                    if ((*ppRootBuffer) == NULL)
                    {
                        break;
                    }

                    // Reset to the last buffer in the chain.  This ensures that
                    // we always look at the least recent buffer
                    pCurrentBuffer = (*ppRootBuffer)->pPrev;
                }
                else
                {
                    // BLOCK!
                    // The buffer we are looking at hasn't become available yet.
                    // We should back off here until it does.

                    blockCount = 100;
                    while( blockCount-- )
                        NULL;

                    DISPDBG((DBGLVL,"Blocked waiting for buffer to be free"));
                }
            } while (pCurrentBuffer != NULL);
        }
        // Loop until we haven't found any more space to allocate buffers into
    } while (bFound);

    DISPDBG((WRNLVL,"!! No available new buffers pending to be freed!!"));
    
    DBG_EXIT(__EB_AllocateCachedBuffer,FALSE);
    return FALSE;
    
} // __EB_AllocateCachedBuffer



//-----------------------------------------------------------------------------
//
// _D3D_EB_FlushAllBuffers
//
// Empties the queue.  Note that this will cause any allocated buffer
// memory to be freed along the way.  This version doesn't wait for the
// buffer to be consumed.  It is used when a context switch has
// occured and we know it is safe to do
//
//-----------------------------------------------------------------------------
void 
_D3D_EB_FlushAllBuffers(
    P3_THUNKEDDATA* pThisDisplay,
    BOOL bWait)
{
    P3_VERTEXBUFFERINFO* pCurrentBuffer;

    DBG_ENTRY(_D3D_EB_FlushAllBuffers);

    // Walk the list of buffers, flushing them from the queue
    while (pThisDisplay->pRootVertexBuffer != NULL)
    {
        pCurrentBuffer = pThisDisplay->pRootVertexBuffer;

        if(bWait)
        {
            // Wait for the buffer to be consumed
            __EB_Wait(pThisDisplay, pCurrentBuffer);
        }
        
        // Remove the buffer from the queue
        __EB_RemoveFromBufferQueue(pThisDisplay, pCurrentBuffer);
    }

    while (pThisDisplay->pRootCommandBuffer != NULL)
    {
        pCurrentBuffer = pThisDisplay->pRootCommandBuffer;

        if(bWait)
        {
            // Wait for the buffer to be consumed
            __EB_Wait(pThisDisplay, pCurrentBuffer);
        }
        
        // Remove the buffer from the queue
        __EB_RemoveFromBufferQueue(pThisDisplay, pCurrentBuffer);
    }

    DBG_EXIT(_D3D_EB_FlushAllBuffers,0);

} // _D3D_EB_FlushAllBuffers

 
//-----------------------------------------------------------------------------
//
// _D3D_EB_GetAndWaitForBuffers
//
//-----------------------------------------------------------------------------
void
_D3D_EB_GetAndWaitForBuffers(
    P3_THUNKEDDATA* pThisDisplay,
    LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d ,
    P3_VERTEXBUFFERINFO** ppVertexBufferInfo,
    P3_VERTEXBUFFERINFO** ppCommandBufferInfo)
{
    P3_VERTEXBUFFERINFO* pVertexBufferInfo;
    P3_VERTEXBUFFERINFO* pCommandBufferInfo;
    
    pCommandBufferInfo = 
            (P3_VERTEXBUFFERINFO*)pdp2d->lpDDCommands->lpGbl->dwReserved1;

    // Check if vertex buffer resides in user memory or in a DDraw surface
    if (pdp2d->dwFlags & D3DHALDP2_USERMEMVERTICES)
    {
        pVertexBufferInfo = NULL;
    } 
    else
    {
        // This pointer may be NULL, indicating a buffer passed that isn't 
        // one of ours. That doesn't mean to say that we can't swap in one 
        // of our buffers if there is one available.
        pVertexBufferInfo = 
                (P3_VERTEXBUFFERINFO*)pdp2d->lpDDVertex->lpGbl->dwReserved1;
    }

    // If the vertex buffer is in the queue, wait for it.
    if (pVertexBufferInfo && pVertexBufferInfo->pPrev)
    { 
        // Wait for this buffer if we need to
        __EB_Wait(pThisDisplay, pVertexBufferInfo);

        // Remove this buffer from the queue
        if (__EB_RemoveFromBufferQueue(pThisDisplay, pVertexBufferInfo))
        {
            DISPDBG((ERRLVL,"ERROR: This buffer should not have been freed "
                        "(is in use!)"));
        }
    }
    
    // If the command buffer is in the queue, wait for it.
    if (pCommandBufferInfo && pCommandBufferInfo->pPrev)
    {
        // Wait for this buffer if we need to
        __EB_Wait(pThisDisplay, pCommandBufferInfo);

        // Remove this buffer from the queue
        if (__EB_RemoveFromBufferQueue(pThisDisplay, pCommandBufferInfo))
        {   
            DISPDBG((ERRLVL,"ERROR: This buffer should not have been freed"
                        " (is in use!)"));
        }
    }

    // Return current values of pointers to EB buffers
    *ppCommandBufferInfo = pCommandBufferInfo;
    *ppVertexBufferInfo = pVertexBufferInfo;
} // _D3D_EB_GetAndWaitForBuffers

//-----------------------------------------------------------------------------
//
// _D3D_EB_UpdateSwapBuffers
//
//-----------------------------------------------------------------------------
void
_D3D_EB_UpdateSwapBuffers(
    P3_THUNKEDDATA* pThisDisplay,
    LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d ,
    P3_VERTEXBUFFERINFO* pVertexBufferInfo,
    P3_VERTEXBUFFERINFO* pCommandBufferInfo)
{
    // Add the buffers to the pending queue.
    // Only do this if the buffers actually belong to us.
    
    // If either of the buffers was sent, update the HOSTIN ID.
    // We need to make the new sequence ID and the update of the hostin
    // 'atomic', or the wraparound will cause a lockup

    if (pVertexBufferInfo)
    {
        P3_DMA_DEFS();

        pVertexBufferInfo->dwSequenceID = 
                            __EB_GetNewSequenceID(pThisDisplay);
                            
        __EB_AddToBufferQueue(pThisDisplay, pVertexBufferInfo);

        P3_DMA_GET_BUFFER_ENTRIES( 2 );

        SEND_P3_DATA(HostInID, pVertexBufferInfo->dwSequenceID);

        P3_DMA_COMMIT_BUFFER();
    }

    if (pCommandBufferInfo)
    {
        P3_DMA_DEFS();

        pCommandBufferInfo->dwSequenceID = 
                            __EB_GetNewSequenceID(pThisDisplay);
                            
        __EB_AddToBufferQueue(pThisDisplay, pCommandBufferInfo);

        P3_DMA_GET_BUFFER_ENTRIES( 2 );

        SEND_P3_DATA(HostInID, pCommandBufferInfo->dwSequenceID);

        P3_DMA_COMMIT_BUFFER();
    }

    if (D3DHALDP2_SWAPVERTEXBUFFER & pdp2d->dwFlags)
    { 
        DWORD dwNewSize = pdp2d->lpDDVertex->lpGbl->dwLinearSize;

        DISPDBG((DBGLVL,"D3DHALDP2_SWAPVERTEXBUFFER..."));
        if (D3DHALDP2_REQVERTEXBUFSIZE & pdp2d->dwFlags)
        {
            DISPDBG((DBGLVL,"D3DHALDP2_REQVERTEXBUFSIZE - %d", 
                       pdp2d->dwReqVertexBufSize));
            if (dwNewSize < pdp2d->dwReqVertexBufSize)
            {
                dwNewSize = pdp2d->dwReqVertexBufSize;
            }
        }

        DISPDBG((DBGLVL,"Current vertex buffer size: %d, "
                        "New size will be: %d",
                        pdp2d->lpDDVertex->lpGbl->dwLinearSize, 
                        dwNewSize));

        // The vertex buffer we just sent off is fixed in place until we 
        // mark it as not in use, which we will after allocating a new 
        // buffer. The following call will try to get a new buffer and 
        // update the surface structure appropriately. Note that it won't 
        // trash the current surface unless the allocation succeeds.
        if (__EB_AllocateCachedBuffer(pThisDisplay, 
                                         dwNewSize, 
                                         pdp2d->lpDDVertex))
        {
            DISPDBG((DBGLVL,"Got a new swap vertex buffer"));

#define STAMP_BUFFER 0
#if STAMP_BUFFER
            {
                DWORD i, *pv;

                pv = (DWORD * ) pdp2d->lpDDVertex->lpGbl->fpVidMem;

                for( i = 0; i < ( dwNewSize / 4 ); i++ )
                {
                    *pv++ = 0x44000000;
                }
            }
#endif

            // Fix up the discarded buffer if required
            if (pVertexBufferInfo)
            {
                // Mark the current buffer as not in use, meaning it can 
                // be freed once it has cleared P3. This might occur the 
                // next time we are here.
                pVertexBufferInfo->bInUse = FALSE;

                // A gotcha!  The buffer we just launched was consumed so 
                // fast that it was freed from the pending list to make 
                // room for it's replacement. This is normally OK, but in 
                // this case the buffer we freed isn't being put back 
                // anywhere - i.e. no surface now owns it, and the memory 
                // associated with it wasn't freed because as far as the 
                // driver is concerned it is still in use until it is 
                // replaced due to the above succesfull call. The 
                // 'solution' is to add it back into the queue if it is 
                // not in it, and make sure that it is marked as not in 
                // use and at a 0 hostin ID.
                if (!pVertexBufferInfo->pPrev)
                {
                    pVertexBufferInfo->dwSequenceID = 0;
                    __EB_AddToBufferQueue(pThisDisplay, 
                                             pVertexBufferInfo);
                }
            }
        }
        else
        {
            // Couldn't swap this buffer, so we have to wait

            DISPDBG((DBGLVL,"Not swapping vertex buffer "
                            "due to lack of space!"));

            __EB_Wait(pThisDisplay, pVertexBufferInfo);
        }
    }
    else
    {
        DISPDBG((DBGLVL,"No vertex buffer swapping..."));
    }

    if (D3DHALDP2_SWAPCOMMANDBUFFER & pdp2d->dwFlags)
    {   
        DWORD dwNewSize = pdp2d->lpDDCommands->lpGbl->dwLinearSize;

        DISPDBG((DBGLVL,"D3DHALDP2_SWAPCOMMANDBUFFER..."));

        if (D3DHALDP2_REQCOMMANDBUFSIZE & pdp2d->dwFlags)
        {
            DISPDBG((DBGLVL,"D3DHALDP2_REQCOMMANDBUFSIZE - %d", 
                       pdp2d->dwReqCommandBufSize));
                       
            if (dwNewSize < pdp2d->dwReqCommandBufSize)
            {
                dwNewSize = pdp2d->dwReqCommandBufSize;
            }
        }

        DISPDBG((DBGLVL,"Current command buffer size: "
                        "%d, New size will be: %d",
                        pdp2d->lpDDCommands->lpGbl->dwLinearSize, 
                        dwNewSize));

        // The command buffer we just sent off is fixed in place until we 
        // mark it as not in use, which we will after allocating a new 
        // buffer. The following call will try to get a new buffer and 
        // update the surface structure appropriately. Note that it won't 
        // trash the current surface unless the allocation succeeds
        if (__EB_AllocateCachedBuffer(pThisDisplay, 
                                         dwNewSize, 
                                         pdp2d->lpDDCommands))
        {
            DISPDBG((DBGLVL,"Got a new swap command buffer"));

            // Fix up the previous command buffer if required.
            if (pCommandBufferInfo)
            {
                // Mark the current buffer as not in use, meaning it can 
                // be freed once it has cleared P3. This might occur the 
                // next time we are here.
                pCommandBufferInfo->bInUse = FALSE;

                // A gotcha!  The buffer we just launched was consumed so 
                // fast that it was freed from the pending list to make 
                // room for it's replacement. This is normally OK, but in 
                // this case the buffer we freed isn't being put back 
                // anywhere - i.e. no surface now owns it, and the memory 
                // associated with it wasn't freed because as far as the 
                // driver is concerned it is still in use until it is 
                // replaced due to the above succesfull call. The 
                // 'solution' is to add it back into the queue if it is 
                // not in it, and make sure that it is marked as not in 
                // use and at a 0 hostin ID.
                if (!pCommandBufferInfo->pPrev)
                {
                    pCommandBufferInfo->dwSequenceID = 0;
                    __EB_AddToBufferQueue(pThisDisplay, 
                                             pCommandBufferInfo);
                }
            }
        }
        else
        {
            // Couldn't swap this buffer, so we have to wait

            DISPDBG((DBGLVL,"Not swapping command buffer "
                            "due to lack of space!"));

            __EB_Wait(pThisDisplay, pCommandBufferInfo);
        }
    }
    else
    {
        DISPDBG((DBGLVL,"No Command buffer swapping..."));
    }
} // _D3D_EB_UpdateSwapBuffers

//-----------------------------Public Routine----------------------------------
//
// D3DCanCreateD3DBuffer
//
// Called by the runtime to ask if a type of vertex/command buffer can
// be created by the driver.  We don't do anything here at present
// 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DCanCreateD3DBuffer(
    LPDDHAL_CANCREATESURFACEDATA pccsd)
{
    P3_THUNKEDDATA* pThisDisplay;

    DBG_CB_ENTRY(D3DCanCreateD3DBuffer);
    
    GET_THUNKEDDATA(pThisDisplay, pccsd->lpDD);

    VALIDATE_MODE_AND_STATE(pThisDisplay);

    DBGDUMP_DDSURFACEDESC(DBGLVL, pccsd->lpDDSurfaceDesc);

    pccsd->ddRVal = DD_OK;
    
    DBG_CB_EXIT(D3DCanCreateD3DBuffer,pccsd->ddRVal);
    return DDHAL_DRIVER_HANDLED;
    
} // D3DCanCreateD3DBuffer

//-----------------------------Public Routine----------------------------------
//
// D3DCreateD3DBuffer
//
// Called by the runtime to create a vertex buffer.  We try to allocate
// from our cached heap here.
// 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DCreateD3DBuffer(
    LPDDHAL_CREATESURFACEDATA pcsd)
{
    P3_THUNKEDDATA* pThisDisplay;
    LPDDRAWI_DDRAWSURFACE_LCL pSurf;
    LPDDRAWI_DDRAWSURFACE_LCL FAR* ppSList;
    BOOL bHandled = FALSE;
    DWORD i;

    DBG_CB_ENTRY(D3DCreateD3DBuffer);

    GET_THUNKEDDATA(pThisDisplay, pcsd->lpDD);

    VALIDATE_MODE_AND_STATE(pThisDisplay);

    STOP_SOFTWARE_CURSOR(pThisDisplay);
    DDRAW_OPERATION(pContext, pThisDisplay);

    ppSList = pcsd->lplpSList;
    
    for (i = 0; i < pcsd->dwSCnt; i++)
    {       
        pSurf = ppSList[i];

        // Allocate the size we want
        DISPDBG((DBGLVL,"Surface %d requested is 0x%x big",
                        i, pSurf->lpGbl->dwLinearSize));
        
        DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pSurf);

        pSurf->lpGbl->dwReserved1 = 0;

        // A 32 kB command buffer gives a high probability of being allowed
        // to swap the associated vertex buffer

        if( pSurf->lpGbl->dwLinearSize < _32_KBYTES )
        {
            pSurf->lpGbl->dwLinearSize = _32_KBYTES;
        }

        if (__EB_AllocateCachedBuffer(pThisDisplay, 
                                         pSurf->lpGbl->dwLinearSize, 
                                         pSurf))
        {
            DISPDBG((DBGLVL,"Allocated a new cached buffer for use by D3D"));
            bHandled = TRUE;
        }
        else
        {
            // If we can't find a buffer, the best thing to do is to 
            // punt to D3D and always copy the data into a DMA buffer
            // (because it won't be contiguous). The DP2 call should 
            // check the reserved field before using the HostIn unit
            DISPDBG((ERRLVL,"WARNING: Couldn't find any vertex memory"
                            " in the heap or in the sent list!"));
                            
            pSurf->lpGbl->dwReserved1 = 0;

            bHandled = FALSE;
        }
    }

    START_SOFTWARE_CURSOR(pThisDisplay);

    pcsd->ddRVal = DD_OK;
    
    if (bHandled)
    {
        DBG_EXIT(D3DCreateD3DBuffer,DDHAL_DRIVER_HANDLED);
        return DDHAL_DRIVER_HANDLED;
    } 
    else
    {    
        DBG_CB_EXIT(D3DCreateD3DBuffer,DDHAL_DRIVER_NOTHANDLED);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    
} // D3DCreateD3DBuffer

//-----------------------------Public Routine----------------------------------
//
// D3DDestroyD3DBuffer
//
// Called by the runtime to destroy a vertex buffer.  We free the buffer
// from our memory heap and the current queue.
// 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DDestroyD3DBuffer(
    LPDDHAL_DESTROYSURFACEDATA pdd)
{
    P3_THUNKEDDATA* pThisDisplay;

    DBG_CB_ENTRY(D3DDestroyD3DBuffer);

    GET_THUNKEDDATA(pThisDisplay, pdd->lpDD);

    VALIDATE_MODE_AND_STATE(pThisDisplay);

    STOP_SOFTWARE_CURSOR(pThisDisplay);
    DDRAW_OPERATION(pContext, pThisDisplay);

    // Debug data
    DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pdd->lpDDSurface);

    // Free the D3D buffer. If its in use, we will wait for it to be ready.
    __EB_FreeCachedBuffer(pThisDisplay, pdd->lpDDSurface);

#ifdef CHECK_BUFFERS_ARENT_LEFT_AFTER_APPLICATION_SHUTDOWN
    // Flush all the buffers
    // This checks that the queue is OK.  If you don't do this
    // you may see the linear allocator on the 16 bit side complain 
    // that there is freeable memory there.  This is quite alright.
    _D3D_EB_FlushAllBuffers(pThisDisplay , TRUE);
#endif

    START_SOFTWARE_CURSOR(pThisDisplay);

    // We don't handle the call because DDRAW has allocated out of AGP memory
    pdd->ddRVal = DD_OK;

    DBG_CB_EXIT(D3DDestroyD3DBuffer,DDHAL_DRIVER_HANDLED);
    return DDHAL_DRIVER_HANDLED;
    
} // D3DDestroyD3DBuffer

//-----------------------------Public Routine----------------------------------
//
// D3DLockD3DBuffer
//
// Called by the runtime to lock a vertex buffer.  We make sure
// it has been consumed by the queue, then we continue.
// 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DLockD3DBuffer(
    LPDDHAL_LOCKDATA pld)
{
    P3_THUNKEDDATA* pThisDisplay;
    P3_VERTEXBUFFERINFO* pCurrentBuffer;

    DBG_CB_ENTRY(D3DLockD3DBuffer);
    
    GET_THUNKEDDATA(pThisDisplay, pld->lpDD); 

    VALIDATE_MODE_AND_STATE(pThisDisplay);

    DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pld->lpDDSurface);
    
    STOP_SOFTWARE_CURSOR(pThisDisplay);
    DDRAW_OPERATION(pContext, pThisDisplay);

    if (pld->bHasRect)
    {
        DISPDBG((ERRLVL,"Trying to lock a rect in a D3D buffer (error):"));
        DISPDBG((ERRLVL,"left:%d, top:%d, right:%d, bottom:%d",
                        pld->rArea.left, pld->rArea.top,
                        pld->rArea.right, pld->rArea.bottom));
        // This is just a debugging aid
        // We will ignore any rects requested and lock the whole buffer
    }

    // If the buffer has a next pointer then it is in the circular list
    // and we need to wait for the chip to finish consuming it.
    pCurrentBuffer = (P3_VERTEXBUFFERINFO*)pld->lpDDSurface->lpGbl->dwReserved1;
    if (pCurrentBuffer)
    {
        // Wait for the buffer to be consumed
        __EB_Wait(pThisDisplay, pCurrentBuffer);

        // Remove it from the queue
        if (__EB_RemoveFromBufferQueue(pThisDisplay, pCurrentBuffer))
        {
            // There was an error removing it from the queue
            DISPDBG((ERRLVL,"ERROR: This buffer should not have been freed"
                        "(its in use!)"));
        }
    }
    else
    {
        DISPDBG((WRNLVL,"Buffer was not allocated by the driver"));
    }

    START_SOFTWARE_CURSOR(pThisDisplay);

    // Return the pointer
    pld->lpSurfData = (LPVOID)pld->lpDDSurface->lpGbl->fpVidMem;

    DISPDBG((DBGLVL,"Returning 0x%x for locked buffer address", 
                    pld->lpDDSurface->lpGbl->fpVidMem));
    
    pld->ddRVal = DD_OK;

    DBG_CB_EXIT(D3DLockD3DBuffer,DDHAL_DRIVER_HANDLED);
    return DDHAL_DRIVER_HANDLED;
    
} // D3DLockD3DBuffer

//-----------------------------Public Routine----------------------------------
//
// D3DUnlockD3DBuffer
//
// Called by the runtime to unlock a vertex buffer.  
// 
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DUnlockD3DBuffer(
    LPDDHAL_UNLOCKDATA puld)
{
    DBG_CB_ENTRY(D3DUnlockD3DBuffer);

    // We don't need to do anything special here.

    puld->ddRVal = DD_OK;

    DBG_CB_EXIT(D3DUnlockD3DBuffer,DDHAL_DRIVER_HANDLED);
    return DDHAL_DRIVER_HANDLED;
    
} // D3DUnlockD3DBuffer

#endif // DX7_VERTEXBUFFERS
//@@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3ddp2p3.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3ddp2p3.c
*
* Content: D3D DrawPrimitives2 callback support
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "dma.h"
#include "tag.h"

//-----------------------------------------------------------------------------
// in-the-file nonexported forward declarations
//-----------------------------------------------------------------------------
BOOL __DP2_PrimitiveOpsParser( 
    P3_D3DCONTEXT *pContext, 
    LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d,
    LPD3DHAL_DP2COMMAND *lplpIns, 
    LPBYTE insStart, 
    LPDWORD lpVertices);

//-----------------------------------------------------------------------------
// Macros to access and validate command and vertex buffer data
// These checks need ALWAYS to be made for all builds, free and checked. 
//-----------------------------------------------------------------------------
#define STARTVERTEXSIZE (sizeof(D3DHAL_DP2STARTVERTEX))

#define NEXTINSTRUCTION(ptr, type, num, extrabytes)                            \
    ptr = (LPD3DHAL_DP2COMMAND)((LPBYTE)ptr + sizeof(D3DHAL_DP2COMMAND) +      \
                                ((num) * sizeof(type)) + (extrabytes))

#define PARSE_ERROR_AND_EXIT( pDP2Data, pIns, pStartIns, ddrvalue)              \
   {                                                                            \
            pDP2Data->dwErrorOffset = (DWORD)((LPBYTE)pIns - (LPBYTE)pStartIns);\
            pDP2Data->ddrval = ddrvalue;                                        \
            bParseError = TRUE;                                                 \
            break;                                                              \
   }

#define CHECK_CMDBUF_LIMITS( pDP2Data, pBuf, type, num, extrabytes)            \
        CHECK_CMDBUF_LIMITS_S( pDP2Data, pBuf, sizeof(type), num, extrabytes)

#define CHECK_CMDBUF_LIMITS_S( pDP2Data, pBuf, typesize, num, extrabytes)      \
{                                                                              \
        LPBYTE pBase,pEnd,pBufEnd;                                             \
        pBase = (LPBYTE)(pDP2Data->lpDDCommands->lpGbl->fpVidMem +             \
                        pDP2Data->dwCommandOffset);                            \
        pEnd  = pBase + pDP2Data->dwCommandLength;                             \
        pBufEnd = ((LPBYTE)pBuf + ((num) * (typesize)) + (extrabytes) - 1);    \
        if (! ((LPBYTE)pBufEnd < pEnd) && ( pBase <= (LPBYTE)pBuf))            \
        {                                                                      \
            DISPDBG((ERRLVL,"Trying to read past Command Buffer limits "       \
                    "%x %x %x %x",pBase ,(LPBYTE)pBuf, pBufEnd, pEnd ));       \
            PARSE_ERROR_AND_EXIT( pDP2Data, lpIns, lpInsStart,                 \
                                  D3DERR_COMMAND_UNPARSED      );              \
        }                                                                      \
}    

#define LP_FVF_VERTEX(lpBaseAddr, wIndex)                         \
         (LPDWORD)((LPBYTE)(lpBaseAddr) + (wIndex) * pContext->FVFData.dwStride)

#define LP_FVF_NXT_VTX(lpVtx)                                    \
         (LPDWORD)((LPBYTE)(lpVtx) + pContext->FVFData.dwStride)



//-----------------------------------------------------------------------------
// These defines are derived from the VertexTagList initialisation in stateset.c

#define FVF_TEXCOORD_BASE   6
#define FVF_XYZ         (7 << 0)
#define FVF_RHW         (1 << 3)
#define FVF_DIFFUSE     (1 << 4)
#define FVF_SPECULAR    (1 << 5)
#define FVF_TEXCOORD1   (3 << FVF_TEXCOORD_BASE)
#define FVF_TEXCOORD2   (3 << (FVF_TEXCOORD_BASE + 2))

//-----------------------------------------------------------------------------
//
// ReconsiderStateChanges
//
//-----------------------------------------------------------------------------
static D3DSTATE localState[] =
{
    { (D3DTRANSFORMSTATETYPE)D3DRENDERSTATE_SHADEMODE, 0 },
    { (D3DTRANSFORMSTATETYPE)D3DRENDERSTATE_CULLMODE, 0 }
};

#define NUM_LOCAL_STATES ( sizeof( localState ) / sizeof( D3DSTATE ))

void ReconsiderStateChanges( P3_D3DCONTEXT *pContext )
{
    int i;

    for( i = 0; i < NUM_LOCAL_STATES; i++ )
    {
        localState[i].dwArg[0] = 
                    pContext->RenderStates[localState[i].drstRenderStateType];
    }

    _D3D_ST_ProcessRenderStates(pContext, NUM_LOCAL_STATES, localState, FALSE);

    _D3D_ST_RealizeHWStateChanges( pContext );
    
} // ReconsiderStateChanges

//-----------------------------------------------------------------------------
//
// __CheckFVFRequest
//
// This utility function verifies that the requested FVF format makes sense
// and computes useful offsets into the data and a stride between succesive
// vertices.
//
//-----------------------------------------------------------------------------
#define FVFEQUAL(fvfcode, fvfmask) \
    (((DWORD)fvfcode & (DWORD)fvfmask)) == (DWORD)fvfmask)
DWORD __CheckFVFRequest(P3_D3DCONTEXT *pContext, DWORD dwFVF)
{
    UINT i, iTexCount;
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    int nonTexStride, texMask;
    FVFOFFSETS KeptFVF;
    P3_SOFTWARECOPY* pSoftP3RX = &pContext->SoftCopyGlint;
    P3_DMA_DEFS();

    DISPDBG((DBGLVL,"Looking at FVF Code %x:",dwFVF));

    // Check for bogus fields
    if ( (dwFVF & (D3DFVF_RESERVED0 | D3DFVF_RESERVED2)) ||
         (!(dwFVF & (D3DFVF_XYZ | D3DFVF_XYZRHW)))       ||
         (dwFVF & (D3DFVF_NORMAL) )                      )
    {
        DISPDBG((ERRLVL,"ERROR: Invalid FVF Buffer for this hardware!(%x)"
                        ,dwFVF));
                        
        // can't set reserved bits, shouldn't have normals in
        // output to rasterizers (since we're not a TnL driver/hw)
        // and must have coordinates
        return DDERR_INVALIDPARAMS;
    }

    KeptFVF = pContext->FVFData;

    // Ensure the default offsets are setup
    ZeroMemory(&pContext->FVFData, sizeof(FVFOFFSETS));

    // Minimum FVF coordinate fields
    pContext->FVFData.dwStride = sizeof(D3DVALUE) * 3;
    pContext->FVFData.vFmat |= FVF_XYZ;

    // RHW if present in FVF
    if (dwFVF & D3DFVF_XYZRHW)
    {
        DISPDBG((DBGLVL, "  D3DFVF_XYZRHW"));
        pContext->FVFData.dwStride += sizeof(D3DVALUE);
        pContext->FVFData.vFmat |= FVF_RHW;
    }

#if DX8_POINTSPRITES
    // Point size offsets for point sprites
    if (dwFVF & D3DFVF_PSIZE)
    {
        pContext->FVFData.dwPntSizeOffset = pContext->FVFData.dwStride;
        pContext->FVFData.dwStride  += sizeof(D3DVALUE);
    }
#else
    if (dwFVF & D3DFVF_RESERVED1)
    {
        DISPDBG((DBGLVL, "  D3DFVF_RESERVED1"));
        pContext->FVFData.dwStride += sizeof(D3DVALUE);
    }
#endif // DX8_POINTSPRITES    

    // Diffuse color
    if (dwFVF & D3DFVF_DIFFUSE)
    {
        DISPDBG((DBGLVL, "  D3DFVF_DIFFUSE"));
        pContext->FVFData.dwColOffset = pContext->FVFData.dwStride;
        pContext->FVFData.dwStride += sizeof(D3DCOLOR);
        pContext->FVFData.vFmat |= FVF_DIFFUSE;
    }

    // Specular color
    if (dwFVF & D3DFVF_SPECULAR)
    {
        DISPDBG((DBGLVL, "  D3DFVF_SPECULAR"));
        pContext->FVFData.dwSpcOffset = pContext->FVFData.dwStride;
        pContext->FVFData.dwStride  += sizeof(D3DCOLOR);
        pContext->FVFData.vFmat |= FVF_SPECULAR;
    }

    // Store some info for later setting up our inline hostin renderers
    nonTexStride = pContext->FVFData.dwStride / sizeof(DWORD);
    texMask = 0;
    pContext->FVFData.dwStrideHostInline = pContext->FVFData.dwStride;
    pContext->FVFData.dwNonTexStride = pContext->FVFData.dwStride;    

    // Up until this point the vertex format is the same for both
    pContext->FVFData.vFmatHostInline = pContext->FVFData.vFmat;

    // Get number of texture coordinates present in this FVF code
    iTexCount = (dwFVF & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT;
    pContext->FVFData.dwTexCount = iTexCount;

    for (i=0; i<D3DHAL_TSS_MAXSTAGES;i++)
    {
        pContext->FVFData.dwTexCoordOffset[i] = 0;
    }

    // Do we have tex coords in FVF? What kinds?
    if (iTexCount >= 1)
    {
        DISPDBG((DBGLVL,"Texture enabled: %d stages", iTexCount));

        // What is the dimensionality of each of our texcoords?
        if (0xFFFF0000 & dwFVF)
        {
            //expansion of FVF, these 16 bits are designated for up to
            //8 sets of texture coordinates with each set having 2bits
            //Normally a capable driver has to process all coordinates
            //Code below shows correct parsing
            UINT numcoord;
            for (i = 0; i < iTexCount; i++)
            {
                if (FVFEQUAL(dwFVF,D3DFVF_TEXCOORDSIZE1(i))
                {
                    // one less D3DVALUE for 1D textures
                    numcoord = 1;                
                }
                else if (FVFEQUAL(dwFVF,D3DFVF_TEXCOORDSIZE3(i))
                {
                    // one more D3DVALUE for 3D textures
                    numcoord = 3;                
                }
                else if (FVFEQUAL(dwFVF,D3DFVF_TEXCOORDSIZE4(i))
                {
                    // two more D3DVALUEs for 4D textures
                    numcoord = 4;                
                }
                else
                {
                    // D3DFVF_TEXCOORDSIZE2(i) is always 0
                    // i.e. case 0 regular 2 D3DVALUEs
                    numcoord = 2;                
                }
                
                DISPDBG((DBGLVL,"Expanded TexCoord set %d has a offset %8lx",
                                 i,pContext->FVFData.dwStride));

                pContext->FVFData.dwTexCoordOffset[i] = 
                                                pContext->FVFData.dwStride; 
                
                pContext->FVFData.dwStride += sizeof(D3DVALUE) * numcoord;
            }
            
            DISPDBG((DBGLVL,"Expanded dwVertexType=0x%08lx has %d "
                            "Texture Coords with total stride=0x%08lx",
                            dwFVF, iTexCount, pContext->FVFData.dwStride));
        }
        else
        {
            // If the top FVF bits are not set, the default is to consider all
            // text coords to be u.v (2D)
            for (i = 0; i < iTexCount; i++)
            {
                pContext->FVFData.dwTexCoordOffset[i] = 
                                                pContext->FVFData.dwStride;

                pContext->FVFData.dwStride += sizeof(D3DVALUE) * 2;
            }

        }

        // Update the offsets to our current (2) textures
        if( pContext->iTexStage[0] != -1 )
        {
            DWORD dwTexCoordSet = 
                pContext->TextureStageState[pContext->iTexStage[0]].
                                         m_dwVal[D3DTSS_TEXCOORDINDEX];

            // The texture coordinate index may contain texgen flags
            // in the high word. These flags are not interesting here
            // so we mask them off.
            dwTexCoordSet = dwTexCoordSet & 0x0000FFFFul;
                                         
            pContext->FVFData.dwTexOffset[0] = 
                    pContext->FVFData.dwTexCoordOffset[dwTexCoordSet];

            texMask |= 3 << ( 2 * dwTexCoordSet );

            pContext->FVFData.vFmat |= FVF_TEXCOORD1;
        }

        if( pContext->iTexStage[1] != -1 )
        {
            DWORD dwTexCoordSet = 
                pContext->TextureStageState[pContext->iTexStage[1]].
                                         m_dwVal[D3DTSS_TEXCOORDINDEX];
                                         
            // The texture coordinate index may contain texgen flags
            // in the high word. These flags are not interesting here
            // so we mask them off.
            dwTexCoordSet = dwTexCoordSet & 0x0000FFFFul;

            pContext->FVFData.dwTexOffset[1] = 
                    pContext->FVFData.dwTexCoordOffset[dwTexCoordSet];

            texMask |= 3 << ( 2 * dwTexCoordSet );

            pContext->FVFData.vFmat |= FVF_TEXCOORD2;
        }               

    } // if (iTexCount >= 1)


    //---------------------------------------------------------
    // Update Permedia 3 hw registers for host inline rendering
    //---------------------------------------------------------
    
    // Update the Hostinline renderers with the correct values.
    // These usually aren't the same as the Hostin renderer values
    if (pContext->FVFData.vFmat & FVF_TEXCOORD1)
    {
        // Add this texture coordinate into the stride
        pContext->FVFData.dwStrideHostInline += (sizeof(D3DVALUE) * 2);

        // Set up the vertex format bit
        pContext->FVFData.vFmatHostInline |= FVF_TEXCOORD1;
    }
    
    if (pContext->FVFData.vFmat & FVF_TEXCOORD2)
    {
        P3_SURF_INTERNAL* pTexture = pContext->pCurrentTexture[TEXSTAGE_1];

        // If the texture coordinates aren't the same, or we are mipmapping, 
        // then we must send the second set of texture coordinates
        if ((pContext->FVFData.dwTexOffset[0] != 
             pContext->FVFData.dwTexOffset[1]) ||
                ((pTexture != NULL) &&
                 (pContext->TextureStageState[TEXSTAGE_1].m_dwVal[D3DTSS_MIPFILTER] != D3DTFP_NONE) &&
                 (pTexture->bMipMap)))
        {
            pContext->FVFData.dwStrideHostInline += (sizeof(D3DVALUE) * 2);

            // Add in the second texture set to the vertex format
            pContext->FVFData.vFmatHostInline |= FVF_TEXCOORD2;
        }
    }

    // VertexValid is all 1's for the stride, because we will never want 
    // to send a gap in the inline hostin triangle renderer
    pContext->FVFData.dwVertexValidHostInline = 
                        (1 << (pContext->FVFData.dwStrideHostInline >> 2)) - 1;

    // The vertex valid for Hostin renderers is more complex because the chip 
    // may be required to skip data.
    pContext->FVFData.dwVertexValid = ((1 << nonTexStride) - 1) | 
                                      (texMask << nonTexStride);

    // If the FVF has changed, resend the state. This can be improved because 
    // you don't always have to send the default stuff (only if that state is 
    // enabled and the vertex doesn't contain it).
    if (memcmp(&KeptFVF, &pContext->FVFData, sizeof(KeptFVF)) != 0)
    {
        // Update P3 for the changed FVF
        P3_DMA_GET_BUFFER_ENTRIES( 12 );

        SEND_P3_DATA(V0FloatPackedColour, 0xFFFFFFFF);
        SEND_P3_DATA(V1FloatPackedColour, 0xFFFFFFFF);
        SEND_P3_DATA(V2FloatPackedColour, 0xFFFFFFFF);
    
        SEND_P3_DATA(V0FloatPackedSpecularFog, 0x0);
        SEND_P3_DATA(V1FloatPackedSpecularFog, 0x0);
        SEND_P3_DATA(V2FloatPackedSpecularFog, 0x0);

        pSoftP3RX->P3RX_P3VertexControl.CacheEnable = 1;

        P3_DMA_COMMIT_BUFFER();

    }

    DISPDBG((DBGLVL,"FVF stride set to %d",pContext->FVFData.dwStride));

    return DD_OK;
    
} // __CheckFVFRequest

//-----------------------------Public Routine----------------------------------
//
// DWORD D3DDrawPrimitives2_P3
//
// Renders primitives and returns the updated render state.
//
// D3dDrawPrimitives2 must be implemented in Direct3D drivers.
//
// The driver must do the following: 
//
// -Ensure that the context handle specified by dwhContext is valid. 
//
// -Check that a flip to the drawing surface associated with the context is not
//  in progress. If the drawing surface is involved in a flip, the driver should
//  set ddrval to DDERR_WASSTILLDRAWING and return DDHAL_DRIVER_HANDLED. 
//
// -Determine the location at which the first D3DNTHAL_DP2COMMAND structure is 
//  found by adding dwCommandOffset bytes to the Command Buffer to which 
//  lpDDCommands points. 
//
// -Determine the location in the Vertex Buffer at which the first vertex is found
//  This is should only be done if there is data in the Vertex Buffer; that is, 
//  when a D3DDP2OP_* command token is received (except when the token is 
//  D3DDP2OP_LINELIST_IMM or D3DDP2OP_TRIANGLEFAN_IMM). These later two opcodes 
//  indicate that the vertex data is passed immediately in the command stream, 
//  rather than in a Vertex Buffer. So, assuming there is data in the Vertex 
//  Buffer, if the Vertex Buffer is in user memory, the first vertex is 
//  dwVertexOffset bytes into the buffer to which lpVertices points. Otherwise, 
//  the driver should apply dwVertexOffset to the memory associated with the 
//  DD_SURFACE_LOCAL structure to which lpDDVertex points. 
//
// -Check dwVertexType to ensure that the driver supports the requested FVF. The 
//  driver should fail the call if any of the following conditions exist: 
//
//  *Vertex coordinates are not specified; that is, if D3DFVF_XYZRHW is not set. 
//  *Normals are specified; that is, if D3DFVF_NORMAL is set. 
//  *Any of the reserved D3DFVF_RESERVEDx bits are set. 
//
// -Process all of the commands in the Command Buffer sequentially. For each 
//  D3DNTHAL_DP2COMMAND structure, the driver should do the following: 
//
//  *If the command is D3DDP2OP_RENDERSTATE, process the wStateCount 
//   D3DNTHAL_DP2RENDERSTATE structures that follow in the Command Buffer, 
//   updating the driver state for each render state structure. When the 
//   D3DNTHALDP2_EXECUTEBUFFER flag is set, the driver should also reflect the 
//   state change in the array to which lpdwRStates points. 
//  *If the command is D3DDP2OP_TEXTURESTAGESTATE, process the wStateCount 
//   D3DNTHAL_DP2TEXTURESTAGESTATE structures that follow in the Command Buffer, 
//   updating the driver's texture state associated with the specified texture 
//   stage for each texture state structure. 
//  *If the command is D3DDP2OP_VIEWPORTINFO, process the D3DNTHAL_DP2VIEWPORTINFO
//   structure that follows in the Command Buffer, updating the viewport 
//   information stored in the driver's internal rendering context. 
//  *If the command is D3DDP2OP_WINFO, process the D3DNTHAL_DP2WINFO structure 
//   that follows in the Command Buffer, updating the w-buffering information 
//   stored in the driver's internal rendering context. 
//  *Otherwise, process the D3DNTHAL_DP2Xxx primitive structures that follow the 
//   D3DDP2OP_Xxx primitive rendering command in the Command Buffer. 
//  *If the command is unknown, call the runtime's D3dParseUnknownCommand callback
//   The runtime provides this callback to the driver's DdGetDriverInfo callback 
//   with the GUID_D3DPARSEUNKNOWNCOMMANDCALLBACK guid. 
//
// The driver doesn't need to probe for readability the memory in which the 
// Command and Vertex Buffers are stored. However, the driver is responsible for 
// ensuring that it does not exceed the bounds of these buffers; that is, the 
// driver must stay within the bounds specified by dwCommandLength and 
// dwVertexLength.
//
// If the driver needs to fail D3dDrawPrimitives2, it should fill in 
// dwErrorOffset with the offset into Command Buffer at which the first 
// unhandled D3DNTHAL_DP2COMMAND can be found.
//
//
// Parameters
//
//      pdp2d 
//          Points to a D3DNTHAL_DRAWPRIMITIVES2DATA structure that contains 
//          the information required for the driver to render one or more 
//          primitives. 
//
//          .dwhContext 
//              Specifies the context handle of the Direct3D device. 
//          .dwFlags 
//              Specifies flags that provide additional instructions to the 
//              driver or provide information from the driver. This member 
//              can be a bitwise OR of the following values: 
//
//              D3DNTHALDP2_USERMEMVERTICES 
//                      The lpVertices member is valid; that is, the driver 
//                      should obtain the vertex data from the user-allocated 
//                      memory to which lpVertices points. This flag is set 
//                      by Direct3D only. 
//              D3DNTHALDP2_EXECUTEBUFFER 
//                      Indicates that the Command and Vertex Buffers were 
//                      created in system memory. The driver should update 
//                      the state array to which lpdwRStates points. This 
//                      flag is set by Direct3D only. 
//              D3DNTHALDP2_SWAPVERTEXBUFFER 
//                      Indicates that the driver can swap the buffer to 
//                      which lpDDVertex or lpVertices points with a new 
//                      Vertex Buffer and return immediately, asynchronously 
//                      processing the original buffer while Direct3D fills 
//                      the new Vertex Buffer. Drivers that do not support 
//                      multi-buffering of Vertex Buffers can ignore this 
//                      flag. This flag is set by Direct3D only. 
//              D3DNTHALDP2_SWAPCOMMANDBUFFER 
//                      Indicates that the driver can swap the buffer to 
//                      which lpDDCommands points with a new Command Buffer 
//                      and return immediately, asynchronously processing 
//                      the original buffer while Direct3D fills the new 
//                      Command Buffer. Drivers that do not support 
///                     multi-buffering of Command Buffers can ignore this 
//                      flag. This flag is set by Direct3D only. 
//              D3DNTHALDP2_REQVERTEXBUFSIZE 
//                      Indicates that the driver must be able to allocate 
//                      a Vertex Buffer of at least the size specified in 
//                      dwReqVertexBufSize. Drivers that do not support 
//                      multi-buffering of Vertex Buffers can ignore this 
//                      flag. This flag is set by Direct3D only. 
//              D3DNTHALDP2_REQCOMMANDBUFSIZE 
//                      Indicates that the driver must be able to allocate 
//                      a Command Buffer of at least the size specified in 
//                      dwReqCommandBufSize. Drivers that do not support 
//                      multi-buffering of Command Buffers can ignore this 
//                      flag. This flag is set by Direct3D only. 
//              D3DNTHALDP2_VIDMEMVERTEXBUF 
//                      Indicates that the Vertex Buffer allocated by the 
//                      driver as a swap buffer is not in system memory. 
//                      This flag can be set by drivers that support multi-
//                      buffering of Vertex Buffers. 
//              D3DNTHALDP2_VIDMEMCOMMANDBUF 
//                      Indicates that the Command Buffer allocated by the 
//                      driver as a swap buffer is not in system memory. This 
//                      flag can be set by drivers that support multi-
//                      buffering of Command Buffers. 
//
//          .dwVertexType 
//              Identifies the FVF of the data in the Vertex Buffer; that is, 
//              dwVertexType specifies which per-vertex data fields are present 
//              in the Vertex Buffer to which lpDDVertex or lpVertices points. 
//              This member can be a bitwise OR of the values in the table that 
//              follows. Only one of the D3DFVF_TEXx flags will be set. 
//
//              Value               Meaning 
//              ==============      =======
//              D3DFVF_XYZRHW       Each vertex has an x,y,z, and w. 
//                                  This flag is always set. 
//              D3DFVF_DIFFUSE      Each vertex has a diffuse color. 
//              D3DFVF_SPECULAR     Each vertex has a specular color. 
//              D3DFVF_TEX0         No texture coordinates are provided 
//                                  with the vertex data. 
//              D3DFVF_TEX1         Each vertex has one set of texture 
//                                  coordinates. 
//              D3DFVF_TEX2         Each vertex has two sets of texture 
//                                  coordinates. 
//              D3DFVF_TEX3         Each vertex has three sets of texture 
//                                  coordinates. 
//              D3DFVF_TEX4         Each vertex has four sets of texture 
//                                  coordinates. 
//              D3DFVF_TEX5         Each vertex has five sets of texture 
//                                  coordinates. 
//              D3DFVF_TEX6         Each vertex has six sets of texture 
//                                  coordinates. 
//              D3DFVF_TEX7         Each vertex has seven sets of texture 
//                                  coordinates. 
//              D3DFVF_TEX8         Each vertex has eight sets of texture 
//                                  coordinates. 
//
//          .lpDDCommands 
//              Points to the DD_SURFACE_LOCAL structure that identifies the 
//              DirectDraw surface containing the command data. The fpVidMem 
//              member of the embedded DD_SURFACE_GLOBAL structure points to 
//              the buffer that contains state change and primitive drawing 
//              commands for the driver to process. Specifically, this buffer 
//              contains one or more D3DNTHAL_DP2COMMAND structures, each 
//              followed by a D3DNTHAL_DP2Xxx structure whose exact type is 
//              identified by D3DNTHAL_DP2COMMAND's bCommand member. 
//          .dwCommandOffset 
//              Specifies the number of bytes into the surface to which 
//              lpDDCommands points at which the command data starts. 
//          .dwCommandLength 
//              Specifies the number of bytes of valid command data in the 
//              surface to which lpDDCommands points starting at dwCommandOffset.
//          .lpDDVertex 
//              Points to the DD_SURFACE_LOCAL structure that identifies the 
//              DirectDraw surface containing the vertex data when the 
//              D3DNTHALDP2_USERMEMVERTICES flag is not set in dwFlags. Union 
//              with lpVertices. 
//          .lpVertices 
//              Points to a user-mode memory block containing vertex data when 
//              the D3DNTHALDP2_USERMEMVERTICES flag is set in dwFlags. 
//          .dwVertexOffset 
//              Specifies the number of bytes into the surface to which 
//              lpDDVertex or lpVertices points at which the vertex data starts.
//          .dwVertexLength 
//              The number of vertices, for which valid data exists in the 
//              surface, that lpDDVertex points to (starting at dwVertexOffset). 
//              Note that dwVertexOffset is specified in bytes. 
//          .dwReqVertexBufSize 
//              Specifies the minimum number of bytes that the driver must 
//              allocate for the swap Vertex Buffer. This member is valid only 
//              when the D3DNTHALDP2_REQVERTEXBUFSIZE flag is set. Drivers that 
//              do not support multi-buffering of Vertex Buffers should ignore 
//              this member. 
//          .dwReqCommandBufSize 
//              Specifies the minimum number of bytes that the driver must 
//              allocate for the swap Command Buffer. This member is valid only 
//              when the D3DNTHALDP2_REQCOMMANDBUFSIZE flag is set. Drivers that 
//              do not support multi-buffering of Command Buffers should ignore 
//              this member. 
//          .lpdwRStates 
//              Points to a render state array that the driver should update 
//              when it parses render state commands from the Command Buffer. 
//              The driver should update this array only when the 
//              D3DNTHALDP2_EXECUTEBUFFER flag is set in dwFlags. The driver 
//              should use the D3DRENDERSTATETYPE enumerated types to update 
//              the appropriate render state's array element. 
//          .dwVertexSize 
//              Used to pass in the size of each vertex in bytes. Union with 
//              ddrval. 
//          .ddrval 
//              Specifies the location in which the driver writes the return 
//              value of D3dDrawPrimitives2. D3D_OK indicates success; 
//              otherwise, the driver should return the appropriate 
//              D3DNTERR_Xxx error code. 
//          .dwErrorOffset 
//              Specifies the location in which the driver should write the 
//              offset into the surface to which lpDDCommands points at which 
//              the first unhandled D3DNTHAL_DP2COMMAND can be found. The 
//              driver must set this value when it returns an error condition 
//              in ddrval. 
//
//-----------------------------------------------------------------------------
DWORD WINAPI 
D3DDrawPrimitives2_P3( 
    LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d )
{
    P3_THUNKEDDATA*             pThisDisplay;
    P3_D3DCONTEXT*              pContext;
    LPDWORD                     lpVertices;
    P3_VERTEXBUFFERINFO*        pVertexBufferInfo;
    P3_VERTEXBUFFERINFO*        pCommandBufferInfo;
    LPD3DHAL_DP2COMMAND         lpIns;
    LPBYTE                      lpInsStart;
    LPBYTE                      lpPrim;
    BOOL                        bParseError = FALSE;
    BOOL                        bUsedHostIn = FALSE;
    HRESULT                     ddrval;
    LPBYTE                      pUMVtx;
    int                         i;

    DBG_CB_ENTRY(D3DDrawPrimitives2_P3);

    // Get current context and validate it
    pContext = _D3D_CTX_HandleToPtr(pdp2d->dwhContext);
    
    if (!CHECK_D3DCONTEXT_VALIDITY(pContext))
    {
        pdp2d->ddrval = D3DHAL_CONTEXT_BAD;
        DISPDBG((ERRLVL,"ERROR: Context not valid"));
        DBG_CB_EXIT(D3DDrawPrimitives2_P3, D3DHAL_CONTEXT_BAD);
        return (DDHAL_DRIVER_HANDLED);
    }
   
    // Get and validate driver data
    pThisDisplay = pContext->pThisDisplay;
    VALIDATE_MODE_AND_STATE(pThisDisplay);

    // Debugging messages
    DISPDBG((DBGLVL, "  dwhContext = %x",pdp2d->dwhContext));
    DISPDBG((DBGLVL, "  dwFlags = %x",pdp2d->dwFlags));
    DBGDUMP_D3DDP2FLAGS(DBGLVL, pdp2d->dwFlags);
    DISPDBG((DBGLVL, "  dwVertexType = %x",pdp2d->dwVertexType));
    DISPDBG((DBGLVL, "  dwCommandOffset = %d",pdp2d->dwCommandOffset));
    DISPDBG((DBGLVL, "  dwCommandLength = %d",pdp2d->dwCommandLength));
    DISPDBG((DBGLVL, "  dwVertexOffset = %d",pdp2d->dwVertexOffset));
    DISPDBG((DBGLVL, "  dwVertexLength = %d",pdp2d->dwVertexLength));
    DISPDBG((DBGLVL, "  dwReqVertexBufSize = %d",pdp2d->dwReqVertexBufSize));
    DISPDBG((DBGLVL, "  dwReqCommandBufSize = %d",pdp2d->dwReqCommandBufSize));                 

    // Get appropriate pointers to commands in command buffer
    lpInsStart = (LPBYTE)(pdp2d->lpDDCommands->lpGbl->fpVidMem);
    if (lpInsStart == NULL) 
    {
        DISPDBG((ERRLVL, "ERROR: Command Buffer pointer is null"));
        pdp2d->ddrval = DDERR_INVALIDPARAMS;
        DBG_CB_EXIT(D3DDrawPrimitives2_P3, DDERR_INVALIDPARAMS);        
        return DDHAL_DRIVER_HANDLED;
    }
       
    lpIns = (LPD3DHAL_DP2COMMAND)(lpInsStart + pdp2d->dwCommandOffset);

    // Check if vertex buffer resides in user memory or in a DDraw surface
    if (pdp2d->dwFlags & D3DHALDP2_USERMEMVERTICES)
    {
        pUMVtx = (LPBYTE)pdp2d->lpVertices;
    
        // Get appropriate pointer to vertices , memory is already secured
        lpVertices = (LPDWORD)((LPBYTE)pdp2d->lpVertices + 
                                       pdp2d->dwVertexOffset);
    } 
    else
    {
        // Get appropriate pointer to vertices 
        lpVertices = (LPDWORD)((LPBYTE)pdp2d->lpDDVertex->lpGbl->fpVidMem + 
                                       pdp2d->dwVertexOffset);
    }

    if (lpVertices == NULL)
    {
        DISPDBG((ERRLVL, "ERROR: Vertex Buffer pointer is null"));
        pdp2d->ddrval = DDERR_INVALIDPARAMS;
        DBG_CB_EXIT(D3DDrawPrimitives2_P3, DDERR_INVALIDPARAMS);       
        return DDHAL_DRIVER_HANDLED;
    }

#if DX8_DDI
// Take notice of the following block of code necessary 
// for DX8 drivers to run <= DX7 apps succesfully!
#endif // DX8_DDI

    // Take the VB format and address from our header info if we are 
    // processing a DX7 or earlier context. Otherwise we'll get updates 
    // through the new DX8 DP2 tokens (D3DDP2OP_SETSTREAMSOURCE & 
    // D3DDP2OP_SETVERTEXSHADER)
    if (IS_DX7_OR_EARLIER_APP(pContext))
    {
        // Update place from where vertices will be processed for this context
        pContext->lpVertices = lpVertices;

        // Update the FVF code to be used currently. 
        pContext->dwVertexType = pdp2d->dwVertexType;
    }

    // Switch to the chips D3D context and get ready for rendering
    STOP_SOFTWARE_CURSOR(pThisDisplay);
    D3D_OPERATION(pContext, pThisDisplay);

//@@BEGIN_DDKSPLIT
//AZN This check for flips is here because otherwise DX3 tunnel in FS flickers
//@@END_DDKSPLIT
    // Can return if still drawing
    pdp2d->ddrval = 
        _DX_QueryFlipStatus(pThisDisplay, 
                            pContext->pSurfRenderInt->fpVidMem, 
                            TRUE);

    if( FAILED( pdp2d->ddrval ) ) 
    {
        DISPDBG((DBGLVL,"Returning because flip has not occurred"));
        START_SOFTWARE_CURSOR(pThisDisplay);

        DBG_CB_EXIT(D3DDrawPrimitives2_P3, 0);
        return DDHAL_DRIVER_HANDLED;
    }

//@@BEGIN_DDKSPLIT
#if DX7_VERTEXBUFFERS 
    _D3D_EB_GetAndWaitForBuffers(pThisDisplay,
                                 pdp2d,
                                 &pCommandBufferInfo,
                                 &pVertexBufferInfo);
#endif                                 
//@@END_DDKSPLIT

    DISPDBG((DBGLVL,"Command Buffer @ %x Vertex Buffer @ %x",
                    lpIns, lpVertices));

    // Process commands while we haven't exhausted the command buffer
    while (!bParseError && 
           ((LPBYTE)lpIns <
             (lpInsStart + pdp2d->dwCommandLength + pdp2d->dwCommandOffset) )
          )
    {
        // Get pointer to first primitive structure past the D3DHAL_DP2COMMAND
        lpPrim = (LPBYTE)lpIns + sizeof(D3DHAL_DP2COMMAND);

        DISPDBG((DBGLVL, "DrawPrimitive2: Parsing instruction %d Count = %d @ %x",
                    lpIns->bCommand, lpIns->wPrimitiveCount, lpIns));

        // Look for opcodes that cause rendering - we need to process state 
        // changes and wait for any pending flip.

        switch( lpIns->bCommand )
        {
            case D3DDP2OP_RENDERSTATE:
            case D3DDP2OP_TEXTURESTAGESTATE:
            case D3DDP2OP_STATESET:
            case D3DDP2OP_VIEWPORTINFO:
            case D3DDP2OP_WINFO:
            case D3DDP2OP_UPDATEPALETTE:
            case D3DDP2OP_SETPALETTE:
#if DX7_TEXMANAGEMENT
            case D3DDP2OP_SETTEXLOD:
            case D3DDP2OP_SETPRIORITY:
#if DX8_DDI
            case D3DDP2OP_ADDDIRTYRECT:
            case D3DDP2OP_ADDDIRTYBOX:
#endif // DX8_DDI
#endif
            case D3DDP2OP_ZRANGE:
            case D3DDP2OP_SETMATERIAL:
            case D3DDP2OP_SETLIGHT:
            case D3DDP2OP_CREATELIGHT:
            case D3DDP2OP_EXT:
            case D3DDP2OP_SETTRANSFORM:
            case D3DDP2OP_SETRENDERTARGET:

#if DX8_DDI
            case D3DDP2OP_CREATEVERTEXSHADER:
            case D3DDP2OP_SETVERTEXSHADER:
            case D3DDP2OP_DELETEVERTEXSHADER:
            case D3DDP2OP_SETVERTEXSHADERCONST:
            case D3DDP2OP_CREATEPIXELSHADER:
            case D3DDP2OP_SETPIXELSHADER:
            case D3DDP2OP_DELETEPIXELSHADER:
            case D3DDP2OP_SETPIXELSHADERCONST:
            case D3DDP2OP_SETSTREAMSOURCE :
            case D3DDP2OP_SETSTREAMSOURCEUM :
            case D3DDP2OP_SETINDICES :

#endif // DX8_DDI


                // These opcodes don't cause any rendering - do nothing

                break;

            default:

                // The primitive type is not actually important to 
                // make sure the hw setup changes have been done.
                _D3D_ST_RealizeHWStateChanges( pContext );

                // Need to reset the FVF data because it 
                // depends on the texture setup
                if (__CheckFVFRequest(pContext, 
                                      pContext->dwVertexType) != DD_OK) 
                {
                    DISPDBG((ERRLVL, "ERROR: D3DDrawPrimitives2_P3 cannot handle "
                                "Flexible Vertex Format requested"));

                    PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, 
                                          D3DERR_COMMAND_UNPARSED);
                }

                // Fall through as we don't need to handle any new state or
                // check our FVF formats if we're only clearing or blitting
                // surfaces
                
            case D3DDP2OP_CLEAR:
            case D3DDP2OP_TEXBLT:   
#if DX8_DDI            
            case D3DDP2OP_VOLUMEBLT:
            case D3DDP2OP_BUFFERBLT:
#endif // DX8_DDI
            
            
                // Check to see if any pending physical flip has occurred
//@@BEGIN_DDKSPLIT                
                //
                // The runtime doesn't expect to see DDERR_WASSTILLDRAWING 
                // when using DP2 to emulate Execute buffers, so we have to 
                // spin here. Also, if we have processed any of this command 
                // buffer we are forced into spinning here because if we 
                // returned the runtime would not know about the already 
                // processed commands and we would process them again - 
                // probably a bad thing. We must do this check here rather 
                // than earlier because in some cases DP2 gets called when 
                // the render surface has been freed. This causes an exception 
                // if we try to check the flip status.
               

                if(( pdp2d->dwFlags & D3DHALDP2_EXECUTEBUFFER ) ||
                                ( lpIns > 
                                     (LPD3DHAL_DP2COMMAND)( lpInsStart + 
                                                            pdp2d->dwCommandOffset )))
                {
                    while( _DX_QueryFlipStatus(pThisDisplay, 
                                               pContext->pSurfRenderInt->fpVidMem, 
                                               TRUE) == DDERR_WASSTILLDRAWING )
                    {
                        // Waste time - could back off here
                    }
                }
                else
//@@END_DDKSPLIT                 
                {
                    // Can return if still drawing

                    pdp2d->ddrval = 
                        _DX_QueryFlipStatus(pThisDisplay, 
                                            pContext->pSurfRenderInt->fpVidMem, 
                                            TRUE);

                    if( FAILED ( pdp2d->ddrval ) ) 
                    {
                        DISPDBG((DBGLVL,"Returning because flip has not occurred"));
                        START_SOFTWARE_CURSOR(pThisDisplay);

                        DBG_CB_EXIT(D3DDrawPrimitives2_P3, 0);
                        return DDHAL_DRIVER_HANDLED;
                    }
                }
                
                break;
        }

        switch( lpIns->bCommand )
        {

        case D3DDP2OP_VIEWPORTINFO:
            // Used to inform the guard-band aware drivers, the view 
            // clipping rectangle. Non-guard-band drivers should ignore 
            // and skip over these instructions and continue processing 
            // the rest of the command buffer. The clipping rectangle is 
            // specified by the members dwX, dwY, dwWidth and dwHeight. 
            DISPDBG((DBGLVL, "D3DDP2OP_VIEWPORTINFO"));
            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                D3DHAL_DP2VIEWPORTINFO, lpIns->wStateCount, 0);

            for( i = 0; i < lpIns->wStateCount; i++)
            {
                // There should be only one of these, but we'll pay attention 
                // to the last one just in case
                _D3D_OP_Viewport(pContext, (D3DHAL_DP2VIEWPORTINFO*)lpPrim);

                lpPrim += sizeof(D3DHAL_DP2VIEWPORTINFO);
            }
            
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2VIEWPORTINFO, lpIns->wStateCount, 0);
            break;

        case D3DDP2OP_WINFO:
            // Record the W Buffering info
            DISPDBG((DBGLVL, "D3DDP2OP_WINFO"));
            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                D3DHAL_DP2WINFO, lpIns->wStateCount, 0);

            pContext->WBufferInfo = *((D3DHAL_DP2WINFO*)lpPrim);
            DIRTY_WBUFFER(pContext);

            lpPrim += sizeof(D3DHAL_DP2WINFO);
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2WINFO, lpIns->wStateCount, 0);
            break;

        case D3DDP2OP_RENDERSTATE:
            // Specifies a render state change that requires processing. 
            // The rendering state to change is specified by one or more 
            // D3DHAL_DP2RENDERSTATE structures following D3DHAL_DP2COMMAND.
            DISPDBG((DBGLVL,"D3DDP2OP_RENDERSTATE: state count = %d", 
                       lpIns->wStateCount));
                       
            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                D3DHAL_DP2RENDERSTATE, lpIns->wStateCount, 0);

            if (pdp2d->dwFlags & D3DHALDP2_EXECUTEBUFFER)
            {
                _D3D_ST_ProcessRenderStates(pContext, 
                                            lpIns->wStateCount, 
                                            (LPD3DSTATE)lpPrim, 
                                            TRUE);

                // As the render states vector lives in user memory, we need to
                // access it bracketing it with a try/except block. This
                // is because the user memory might under some circumstances
                // become invalid while the driver is running and then it
                // would AV. Also, the driver might need to do some cleanup
                // before returning to the OS.
                __try
                {
                    for (i = lpIns->wStateCount; i > 0; i--)
                    {
                        pdp2d->lpdwRStates[((D3DHAL_DP2RENDERSTATE*)lpPrim)->RenderState]
                                                        = ((D3DHAL_DP2RENDERSTATE*)lpPrim)->dwState;
                        lpPrim += sizeof(D3DHAL_DP2RENDERSTATE);
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    // On this driver we don't need to do anything special
                    DISPDBG((ERRLVL,"Driver caused exception at "
                                    "line %u of file %s",
                                    __LINE__,__FILE__));
                    PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, 
                                          DDERR_GENERIC);
                }                 

                
            }
            else
            {
                _D3D_ST_ProcessRenderStates(pContext, 
                                            lpIns->wStateCount, 
                                            (LPD3DSTATE)lpPrim, 
                                            FALSE);
                                        
                lpPrim += (sizeof(D3DHAL_DP2RENDERSTATE) * lpIns->wStateCount);
            }

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2RENDERSTATE, lpIns->wStateCount, 0);
            break;

        case D3DDP2OP_TEXTURESTAGESTATE:
        
            DISPDBG((DBGLVL,"D3DDP2OP_TEXTURESTAGESTATE: state count = %d", 
                       lpIns->wStateCount));
                       
            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                D3DHAL_DP2TEXTURESTAGESTATE, 
                                lpIns->wStateCount , 0);

            _D3D_TXT_ParseTextureStageStates(
                                    pContext, 
                                    (D3DHAL_DP2TEXTURESTAGESTATE*)lpPrim,
                                    lpIns->wStateCount,
                                    TRUE);
                                        
            lpPrim += sizeof(D3DHAL_DP2TEXTURESTAGESTATE) * 
                      lpIns->wStateCount;
            
            NEXTINSTRUCTION(lpIns, 
                            D3DHAL_DP2TEXTURESTAGESTATE, 
                            lpIns->wStateCount , 0); 
            break;


        case D3DDP2OP_STATESET:
            {
                D3DHAL_DP2STATESET *pStateSetOp = (D3DHAL_DP2STATESET*)(lpPrim);
                
                DISPDBG((DBGLVL,"D3DDP2OP_STATESET: state count = %d", 
                            lpIns->wStateCount));

                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2STATESET, lpIns->wStateCount, 0);                
#if DX7_D3DSTATEBLOCKS
                for (i = 0; i < lpIns->wStateCount; i++, pStateSetOp++)
                {
                    switch (pStateSetOp->dwOperation)
                    {
#if DX8_DDI
                    case D3DHAL_STATESETCREATE :
                        // This DDI should be called only for drivers > DX7
                        // and only for those which support TLHals. It is 
                        // called only when the device created is a pure-device
                        // On receipt of this request the driver should create
                        // a state block of the type given in the field sbType
                        // and capture the current given state into it.
                        break;
#endif //DX8_DDI
                    case D3DHAL_STATESETBEGIN  :
                        _D3D_SB_BeginStateSet(pContext,pStateSetOp->dwParam);
                        break;
                    case D3DHAL_STATESETEND    :
                        _D3D_SB_EndStateSet(pContext);
                        break;
                    case D3DHAL_STATESETDELETE :
                        _D3D_SB_DeleteStateSet(pContext,pStateSetOp->dwParam);
                        break;
                    case D3DHAL_STATESETEXECUTE:
                        _D3D_SB_ExecuteStateSet(pContext,pStateSetOp->dwParam);
                        break;
                    case D3DHAL_STATESETCAPTURE:
                        _D3D_SB_CaptureStateSet(pContext,pStateSetOp->dwParam);
                        break;
                    default :
                        DISPDBG((ERRLVL,"D3DDP2OP_STATESET has invalid"
                            "dwOperation %08lx",pStateSetOp->dwOperation));
                    }
                }
#endif //DX7_D3DSTATEBLOCKS
                // Update the command buffer pointer
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2STATESET, 
                                lpIns->wStateCount, 0);
            }
            break;

        case D3DDP2OP_ZRANGE:
            DISPDBG((DBGLVL, "D3DDP2OP_ZRANGE"));
            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                D3DHAL_DP2ZRANGE, lpIns->wStateCount, 0);

            for( i = 0; i < lpIns->wStateCount; i++)
            {
                // There should be only one of these, but we'll pay attention 
                // to the last one just in case
                _D3D_OP_ZRange(pContext, (D3DHAL_DP2ZRANGE*)lpPrim);
                
                lpPrim += sizeof(D3DHAL_DP2ZRANGE);
            }
            
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2ZRANGE, lpIns->wStateCount, 0);

            break;

        case D3DDP2OP_UPDATEPALETTE:
            // Perform modifications to the palette that is used for palettized
            // textures. The palette handle attached to a surface is updated
            // with wNumEntries PALETTEENTRYs starting at a specific wStartIndex
            // member of the palette. (A PALETTENTRY (defined in wingdi.h and
            // wtypes.h) is actually a DWORD with an ARGB color for each byte.)
            // After the D3DNTHAL_DP2UPDATEPALETTE structure in the command
            // stream the actual palette data will follow (without any padding),
            // comprising one DWORD per palette entry. There will only be one
            // D3DNTHAL_DP2UPDATEPALETTE structure (plus palette data) following
            // the D3DNTHAL_DP2COMMAND structure regardless of the value of
            // wStateCount.
            {
                D3DHAL_DP2UPDATEPALETTE* pUpdatePalette;

                DISPDBG((DBGLVL, "D3DDP2OP_UPDATEPALETTE"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2UPDATEPALETTE, 1, 0);

                pUpdatePalette = (D3DHAL_DP2UPDATEPALETTE *)lpPrim;
                // Each palette entry is a DWORD ARGB 8:8:8:8
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2UPDATEPALETTE, 
                                    1, pUpdatePalette->wNumEntries * sizeof(DWORD));

                ddrval = _D3D_OP_UpdatePalette(pContext, 
                                               pUpdatePalette, 
                                               (LPDWORD)(pUpdatePalette + 1));
                if ( FAILED(ddrval) )
                {
                    PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart,
                                          ddrval);
                }

                lpPrim += (sizeof(D3DHAL_DP2UPDATEPALETTE) + 
                           pUpdatePalette->wNumEntries * 4);
                // Each palette entry is a DWORD ARGB 8:8:8:8
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2UPDATEPALETTE, 
                                1, pUpdatePalette->wNumEntries * sizeof(DWORD));
            }

            break;

        case D3DDP2OP_SETPALETTE:
            // Attach a palette to a texture, that is , map an association
            // between a palette handle and a surface handle, and specify
            // the characteristics of the palette. The number of
            // D3DNTHAL_DP2SETPALETTE structures to follow is specified by
            // the wStateCount member of the D3DNTHAL_DP2COMMAND structure
            {
                DISPDBG((DBGLVL, "D3DDP2OP_SETPALETTE"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETPALETTE, 
                                    lpIns->wStateCount, 0);

                ddrval = _D3D_OP_SetPalettes(pContext, 
                                             (D3DHAL_DP2SETPALETTE *)lpPrim,
                                             lpIns->wStateCount);
                if ( FAILED(ddrval) )
                {
                    PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart,
                                          ddrval);
                }

                lpPrim += sizeof(D3DHAL_DP2SETPALETTE) * lpIns->wStateCount;
            
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETPALETTE, 
                                lpIns->wStateCount, 0);
            }
            break;

#if DX7_TEXMANAGEMENT
        case D3DDP2OP_SETTEXLOD:
            {
                D3DHAL_DP2SETTEXLOD* pTexLod;
                
                DISPDBG((DBGLVL, "D3DDP2OP_SETTEXLOD"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETTEXLOD, lpIns->wStateCount, 0);

                for( i = 0; i < lpIns->wStateCount; i++)
                {      
                    // Get the passed material
                    pTexLod = ((D3DHAL_DP2SETTEXLOD*)lpPrim);
                    lpPrim += sizeof(D3DHAL_DP2SETTEXLOD);                
                
                    _D3D_OP_SetTexLod(pContext, pTexLod);            
                }

                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETTEXLOD, 
                                lpIns->wStateCount, 0);
            }
            break;
            
        case D3DDP2OP_SETPRIORITY:
            {
                D3DHAL_DP2SETPRIORITY* pSetPri;
                
                DISPDBG((DBGLVL, "D3DDP2OP_SETPRIORITY"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETPRIORITY, lpIns->wStateCount, 0);

                for( i = 0; i < lpIns->wStateCount; i++)
                {      
                    // Get the passed material
                    pSetPri = ((D3DHAL_DP2SETPRIORITY*)lpPrim);
                    lpPrim += sizeof(D3DHAL_DP2SETPRIORITY);                
                
                    _D3D_OP_SetPriority(pContext, pSetPri); 
                }

                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETPRIORITY, 
                                lpIns->wStateCount, 0);
            }
            break;

#if DX8_DDI
        case D3DDP2OP_ADDDIRTYRECT:
            {
                D3DHAL_DP2ADDDIRTYRECT* pAddRect;
                
                DISPDBG((DBGLVL, "D3DDP2OP_ADDDIRTYRECT"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DDP2OP_ADDDIRTYRECT, lpIns->wStateCount, 0);

                for( i = 0; i < lpIns->wStateCount; i++)
                {      
                    // Get the dirty rect
                    pAddRect = ((D3DHAL_DP2ADDDIRTYRECT*)lpPrim);
                    lpPrim += sizeof(D3DHAL_DP2ADDDIRTYRECT);                
                
                    _D3D_OP_AddDirtyRect(pContext, pAddRect);            
                }

                NEXTINSTRUCTION(lpIns, D3DHAL_DP2ADDDIRTYRECT, 
                                lpIns->wStateCount, 0);            
            }
            break;
        
        case D3DDP2OP_ADDDIRTYBOX:
            {
                D3DHAL_DP2ADDDIRTYBOX* pAddBox;
                
                DISPDBG((DBGLVL, "D3DDP2OP_ADDDIRTYBOX"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DDP2OP_ADDDIRTYBOX, lpIns->wStateCount, 0);

                for( i = 0; i < lpIns->wStateCount; i++)
                {      
                    // Get the dirty rect
                    pAddBox = ((D3DHAL_DP2ADDDIRTYBOX*)lpPrim);
                    lpPrim += sizeof(D3DHAL_DP2ADDDIRTYBOX);                
                
                    _D3D_OP_AddDirtyBox(pContext, pAddBox);            
                }

                NEXTINSTRUCTION(lpIns, D3DHAL_DP2ADDDIRTYBOX, 
                                lpIns->wStateCount, 0);            
            }
            break;
#endif // DX8_DDI

#endif // DX7_TEXMANAGEMENT

        case D3DDP2OP_SETCLIPPLANE:
            {
                D3DHAL_DP2SETCLIPPLANE* pSetPlane;
                
                DISPDBG((DBGLVL, "D3DDP2OP_SETCLIPPLANE"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETCLIPPLANE, 
                                    lpIns->wStateCount, 0);

                for( i = 0; i < lpIns->wStateCount; i++)
                {      
                    // Get the passed material
                    pSetPlane = ((D3DHAL_DP2SETCLIPPLANE*)lpPrim);
                    lpPrim += sizeof(D3DHAL_DP2SETCLIPPLANE);                

                    // (unimplemented OP as we don't support user 
                    // defined clipping planes)                
                    // _D3D_OP_SetClipPlane(pContext, pSetPlane);            
                }

                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETCLIPPLANE, 
                                lpIns->wStateCount, 0);
            }

            break;

        case D3DDP2OP_SETMATERIAL:
            {
                D3DHAL_DP2SETMATERIAL* pSetMaterial;
                
                DISPDBG((DBGLVL, "D3DDP2OP_SETMATERIAL"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                    D3DHAL_DP2SETMATERIAL, lpIns->wStateCount, 0);

                for( i = 0; i < lpIns->wStateCount; i++)
                {      
                    // Get the passed material
                    pSetMaterial = ((D3DHAL_DP2SETMATERIAL*)lpPrim);
                    lpPrim += sizeof(D3DHAL_DP2SETMATERIAL);                

                    // (unimplemented OP as we are not a TnL driver)                
                    // _D3D_OP_SetMaterial(pContext, pSetMaterial);            
                    DIRTY_MATERIAL;
                    DBGDUMP_D3DMATERIAL7(DBGLVL, &pSetMaterial);
                }

                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETMATERIAL, lpIns->wStateCount, 0);
            }
            break;

        case D3DDP2OP_SETLIGHT:
            {
                D3DHAL_DP2SETLIGHT* pSetLight;

                DISPDBG((DBGLVL, "D3DDP2OP_SETLIGHT"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETLIGHT, lpIns->wStateCount, 0);    

                for( i = 0; i < lpIns->wStateCount; i++)
                {
                    // Get the passed in light
                    pSetLight = (D3DHAL_DP2SETLIGHT*)lpPrim;
                    lpPrim += sizeof(D3DHAL_DP2SETLIGHT);

                    // (unimplemented OP as we are not a TnL driver)
                    // _D3D_OP_SetLight(pContext, pSetLight);
                    DIRTY_GAMMA_STATE;                    
                }

                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETLIGHT, lpIns->wStateCount, 0);

            }
            break;

        case D3DDP2OP_CREATELIGHT:
            {
                D3DHAL_DP2CREATELIGHT* pCreateLight;

                DISPDBG((DBGLVL, "D3DDP2OP_CREATELIGHT"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2CREATELIGHT, 1, 0);

                pCreateLight = (D3DHAL_DP2CREATELIGHT*)lpPrim;

                DISPDBG((DBGLVL,"Creating light, handle: 0x%x", 
                                pCreateLight->dwIndex));

                DIRTY_GAMMA_STATE;

                lpPrim += sizeof(D3DHAL_DP2CREATELIGHT);
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2CREATELIGHT, 1, 0);
            }
            break;

        case D3DDP2OP_SETTRANSFORM:
            {
                D3DHAL_DP2SETTRANSFORM* pTransform;

                DISPDBG((DBGLVL, "D3DDP2OP_SETTRANSFORM"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                    D3DHAL_DP2SETTRANSFORM, lpIns->wStateCount, 0);

                for( i = 0; i < lpIns->wStateCount; i++)
                {
                    pTransform = (D3DHAL_DP2SETTRANSFORM*)lpPrim;
                    switch(pTransform->xfrmType)
                    {
                        case D3DTRANSFORMSTATE_WORLD:
                            DISPDBG((DBGLVL,"D3DTRANSFORMSTATE_WORLD"));
                            DIRTY_MODELVIEW;
                            break;

                        case D3DTRANSFORMSTATE_VIEW:
                            DISPDBG((DBGLVL,"D3DTRANSFORMSTATE_VIEW"));
                            DIRTY_MODELVIEW;
                            break;

                        case D3DTRANSFORMSTATE_PROJECTION:
                            DISPDBG((DBGLVL,"D3DTRANSFORMSTATE_PROJECTION"));
                            DIRTY_PROJECTION;
                            break;

                        default:
                            DISPDBG((ERRLVL,"Texture transform not handled yet!"));
                            break;
                    }

                    // (unimplemented OP as we are not a TnL driver)
                    // _D3D_OP_SetTransform(pContext, pTransform);
                    
                    // display the matrix in the debugger               
                    DBGDUMP_D3DMATRIX(DBGLVL, &pTransform->matrix);

                    lpPrim += sizeof(D3DHAL_DP2SETTRANSFORM);                    
                }

                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETTRANSFORM, lpIns->wStateCount, 0);
            }
            break;

        case D3DDP2OP_EXT:
            DISPDBG((ERRLVL, "D3DDP2OP_EXT"));
            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, DWORD, 1, 0);

            lpPrim += sizeof(DWORD);
            NEXTINSTRUCTION(lpIns, DWORD, 1, 0);

            break;

        case D3DDP2OP_CLEAR:
            {
                D3DHAL_DP2CLEAR* pClear;

                DISPDBG((DBGLVL, "D3DDP2OP_CLEAR"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                    D3DHAL_DP2CLEAR, 1, 
                                    (lpIns->wStateCount - 1)*sizeof(RECT) );

                pClear = (D3DHAL_DP2CLEAR*)lpPrim;

                // Notice that the interpretation of wStateCount for this
                // operation is special: wStateCount means the number of
                // RECTs following the D3DHAL_DP2CLEAR struct
                _D3D_OP_Clear2(pContext, pClear, lpIns->wStateCount);

                // Return to the 3D state, because the above call
                // will have switched us to a DDRAW hw context
                D3D_OPERATION(pContext, pThisDisplay);

                lpPrim += sizeof(D3DHAL_DP2CLEAR);
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2CLEAR, 1, 
                                      (lpIns->wStateCount - 1)*sizeof(RECT) );
            }
            break;

        case D3DDP2OP_SETRENDERTARGET:
            {
                D3DHAL_DP2SETRENDERTARGET* pSetRenderTarget;
                P3_SURF_INTERNAL* pFrameBuffer;
                P3_SURF_INTERNAL* pZBuffer;
                BOOL bNewAliasBuffers;

                DISPDBG((DBGLVL, "D3DDP2OP_SETRENDERTARGET"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETRENDERTARGET, 1, 0);

                pSetRenderTarget = (D3DHAL_DP2SETRENDERTARGET*)lpPrim;

                pFrameBuffer = 
                           GetSurfaceFromHandle(pContext, 
                                                pSetRenderTarget->hRenderTarget);
                pZBuffer = GetSurfaceFromHandle(pContext, 
                                                pSetRenderTarget->hZBuffer);

                // Check that the Framebuffer is valid
                if (pFrameBuffer == NULL)
                {
                    DISPDBG((ERRLVL, "ERROR: "
                                "FrameBuffer Surface is invalid!"));
                    PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, 
                                          DDERR_GENERIC);
                }

                // Decide whether the render target's size has changed
                bNewAliasBuffers = TRUE;
                if ((pContext->pSurfRenderInt) &&
                    (pContext->pSurfRenderInt->wWidth == pFrameBuffer->wWidth) &&
                    (pContext->pSurfRenderInt->wHeight == pFrameBuffer->wHeight))
                {
                    bNewAliasBuffers = FALSE;
                }

                // Setup in hw the new render target and zbuffer
                if (FAILED(_D3D_OP_SetRenderTarget(pContext, 
                                                   pFrameBuffer, 
                                                   pZBuffer,
                                                   bNewAliasBuffers) ) )
                {
                    DISPDBG((ERRLVL, "ERROR: "
                                "FrameBuffer Surface Format is invalid!"));
                    PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, 
                                          DDERR_GENERIC);                    
                }

                // Dirty the renderstate so that the hw setup is reevaluated
                // next time before we render anything
                DIRTY_RENDER_OFFSETS(pContext);
                DIRTY_ALPHABLEND(pContext);
                DIRTY_OPTIMIZE_ALPHA(pContext);
                DIRTY_ZBUFFER(pContext);
                DIRTY_VIEWPORT(pContext);

                lpPrim += sizeof(D3DHAL_DP2SETRENDERTARGET);
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETRENDERTARGET, 1, 0);
            }
            break;

        case D3DDP2OP_TEXBLT:
            {
                DISPDBG((DBGLVL, "D3DDP2OP_TEXBLT"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                    D3DHAL_DP2TEXBLT, lpIns->wStateCount, 0);

                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    // As the texture might live in user memory, we need to
                    // access it bracketing it with a try/except block. This
                    // is because the user memory might under some circumstances
                    // become invalid while the driver is running and then it
                    // would AV. Also, the driver might need to do some cleanup
                    // before returning to the OS.
                    __try
                    {
                        _D3D_OP_TextureBlt(pContext,
                                        pThisDisplay, 
                                        (D3DHAL_DP2TEXBLT*)(lpPrim));
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        // On this driver we don't need to do anything special
                        DISPDBG((ERRLVL,"Driver caused exception at "
                                        "line %u of file %s",
                                        __LINE__,__FILE__));
                        PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, 
                                              DDERR_GENERIC);
                    }                 
                
                                 
                    lpPrim += sizeof(D3DHAL_DP2TEXBLT);
                }
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2TEXBLT, lpIns->wStateCount, 0);
            }
            break;

#if DX8_VERTEXSHADERS
        case D3DDP2OP_CREATEVERTEXSHADER:
            {
                D3DHAL_DP2CREATEVERTEXSHADER* pCreateVtxShader;
                DWORD dwExtraBytes = 0;

                DISPDBG((DBGLVL, "D3DDP2OP_CREATEVERTEXSHADER"));

                // iterate through each passed vertex shader creation block
                for (i = 0; i < lpIns->wStateCount; i++)
                {
                    // verify that the next vertex shader is readable
                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                        D3DHAL_DP2CREATEVERTEXSHADER, 1, 0);    

                    // Get the passed in vertex shader
                    pCreateVtxShader = (D3DHAL_DP2CREATEVERTEXSHADER*)lpPrim;

                    // Check if the size of the declaration and body of the 
                    // vertex shader don't exceed the command buffer limits
                    CHECK_CMDBUF_LIMITS_S(pdp2d, lpPrim,
                                          0, 0, 
                                          pCreateVtxShader->dwDeclSize + 
                                          pCreateVtxShader->dwCodeSize);  

                    // Advance lpPrim so that it points to the vertex shader's
                    // declaration and body
                    lpPrim += sizeof(D3DHAL_DP2CREATEVERTEXSHADER);

                    // Create this particular shader
                    ddrval = _D3D_OP_VertexShader_Create(pContext,
                                                      pCreateVtxShader->dwHandle,
                                                      pCreateVtxShader->dwDeclSize,
                                                      pCreateVtxShader->dwCodeSize,
                                                      lpPrim);

                    if ( FAILED(ddrval) )
                    {
                        DISPDBG((ERRLVL, "ERROR: "
                                    "Vertex Shader couldn't be created!"));
                        PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, 
                                              D3DERR_DRIVERINVALIDCALL);                      
                    }
                                          
                    // Update lpPrim in order to get to the next vertex
                    // shader creation command block. 
                    dwExtraBytes +=   pCreateVtxShader->dwDeclSize
                                    + pCreateVtxShader->dwCodeSize;

                    lpPrim +=         pCreateVtxShader->dwDeclSize
                                    + pCreateVtxShader->dwCodeSize;      
                }

                // Now skip into the next DP2 token in the command buffer
                NEXTINSTRUCTION(lpIns, 
                                D3DHAL_DP2CREATEVERTEXSHADER, 
                                lpIns->wStateCount, 
                                dwExtraBytes);
            }
            break;
            
        case D3DDP2OP_SETVERTEXSHADER:
            {
                D3DHAL_DP2VERTEXSHADER* pSetVtxShader;

                DISPDBG((DBGLVL, "D3DHAL_DP2SETVERTEXSHADER"));

                // Following the DP2 token there is one and only one
                // set vertex shader block. But lets accomodate if for
                // any reason we receive more than one
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2VERTEXSHADER, 
                                    lpIns->wStateCount, 0);    

                for (i = 0; i < lpIns->wStateCount; i++)
                {
                    // Get the passed in vertex shader
                    pSetVtxShader = (D3DHAL_DP2VERTEXSHADER*)lpPrim;

                    // Setup the given vertex shader.
                    _D3D_OP_VertexShader_Set(pContext,
                                       pSetVtxShader->dwHandle);                

                    // Now skip into the next DP2 token in the command buffer
                    lpPrim += sizeof(D3DHAL_DP2VERTEXSHADER);               
                }
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2VERTEXSHADER, 
                                lpIns->wStateCount, 0);
            }
            break;
            
        case D3DDP2OP_DELETEVERTEXSHADER:
            {
                D3DHAL_DP2VERTEXSHADER* pDelVtxShader;

                DISPDBG((DBGLVL, "D3DDP2OP_DELETEVERTEXSHADER"));

                // verify that all the following vertex shader 
                // delete blocks are readable
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2VERTEXSHADER, 
                                    lpIns->wStateCount, 0);    

                // iterate through each passed vertex shader delete block
                for (i = 0; i < lpIns->wStateCount; i++)
                {
                    // Get the passed in vertex shader
                    pDelVtxShader = (D3DHAL_DP2VERTEXSHADER*)lpPrim;

                    // Destroy the given vertex shader.
                    _D3D_OP_VertexShader_Delete(pContext,
                                          pDelVtxShader->dwHandle);

                    // Update lpPrim in order to get to the next vertex
                    // shader delete command block. 
                    lpPrim += sizeof(D3DHAL_DP2VERTEXSHADER);               
                }

                // Now skip into the next DP2 token in the command buffer
                NEXTINSTRUCTION(lpIns, 
                                D3DHAL_DP2VERTEXSHADER, 
                                lpIns->wStateCount, 
                                0);            
            }
            break;
        case D3DDP2OP_SETVERTEXSHADERCONST:
            {
                D3DHAL_DP2SETVERTEXSHADERCONST* pVtxShaderConst;
                DWORD dwExtraBytes = 0;                

                DISPDBG((DBGLVL, "D3DDP2OP_SETVERTEXSHADERCONST"));

                // verify that all the following vertex shader 
                // constant blocks are readable
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETVERTEXSHADERCONST, 
                                    lpIns->wStateCount, 0);    

                // iterate through each passed vertex shader constant block
                for (i = 0; i < lpIns->wStateCount; i++)
                {
                    // Get the passed in vertex shader constant
                    pVtxShaderConst = (D3DHAL_DP2SETVERTEXSHADERCONST*)lpPrim;

                    // Advance lpPrim so that it points to the constant
                    // values to be loaded
                    lpPrim += sizeof(D3DHAL_DP2SETVERTEXSHADERCONST);

                    // constant block in order to Set up the constant entries
                    _D3D_OP_VertexShader_SetConst(pContext,
                                            pVtxShaderConst->dwRegister,
                                            pVtxShaderConst->dwCount,
                                            (DWORD *)lpPrim);

                    // Update lpPrim in order to get to the next vertex
                    // shader constants command block. Each register has 4 floats.
                    lpPrim += pVtxShaderConst->dwCount * 4 * sizeof(FLOAT);

                    dwExtraBytes += pVtxShaderConst->dwCount * 4 * sizeof(FLOAT);
                }

                // Now skip into the next DP2 token in the command buffer
                NEXTINSTRUCTION(lpIns, 
                                D3DHAL_DP2SETVERTEXSHADERCONST, 
                                lpIns->wStateCount, 
                                dwExtraBytes);                 
            }
            break;
                        
#endif // DX8_VERTEXSHADERS

#if DX8_PIXELSHADERS
        case D3DDP2OP_CREATEPIXELSHADER:
            {
                D3DHAL_DP2CREATEPIXELSHADER* pCreatePxlShader;
                DWORD dwExtraBytes = 0;

                DISPDBG((DBGLVL, "D3DDP2OP_CREATEPIXELSHADER"));

                // iterate through each passed pixel shader creation block
                for (i = 0; i < lpIns->wStateCount; i++)
                {
                    // verify that the next pixel shader is readable
                    CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                        D3DHAL_DP2CREATEPIXELSHADER, 1, 0);    

                    // Get the passed in pixel shader
                    pCreatePxlShader = (D3DHAL_DP2CREATEPIXELSHADER*)lpPrim;

                    // Check if the size of the declaration and body of the 
                    // pixel shader don't exceed the command buffer limits
                    CHECK_CMDBUF_LIMITS_S(pdp2d, lpPrim,
                                          0, 0, 
                                          pCreatePxlShader->dwCodeSize);

                    // Update lpPrim to point to the actual pixel shader code
                    lpPrim += sizeof(D3DHAL_DP2CREATEPIXELSHADER);

                    // Create the given pixel shader
                    ddrval = _D3D_OP_PixelShader_Create(pContext,
                                                  pCreatePxlShader->dwHandle,
                                                  pCreatePxlShader->dwCodeSize,
                                                  lpPrim);

                    if ( FAILED(ddrval) )
                    {
                        DISPDBG((ERRLVL, "ERROR: "
                                    "Pixel Shader couldn't be created!"));
                        PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, 
                                              D3DERR_DRIVERINVALIDCALL);                                           
                    }                                                  

                    // Update lpPrim in order to get to the next vertex
                    // shader creation command block. 
                    lpPrim += pCreatePxlShader->dwCodeSize;               
                    
                    dwExtraBytes += pCreatePxlShader->dwCodeSize;
                }

                // Now skip into the next DP2 token in the command buffer
                NEXTINSTRUCTION(lpIns, 
                                D3DHAL_DP2CREATEPIXELSHADER, 
                                lpIns->wStateCount, 
                                dwExtraBytes);
            }
            break;
            
        case D3DDP2OP_SETPIXELSHADER:
            {
                D3DHAL_DP2PIXELSHADER* pSetPxlShader;

                DISPDBG((DBGLVL, "D3DHAL_DP2SETPIXELSHADER"));

                // Following the DP2 token there is one and only one
                // set pixel shader block. But lets accomodate if for
                // any reason we receive more than one                
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2PIXELSHADER, 
                                    lpIns->wStateCount, 0);    

                for (i = 0; i < lpIns->wStateCount; i++)
                {
                    // Get the passed in pixel shader
                    pSetPxlShader = (D3DHAL_DP2PIXELSHADER*)lpPrim;

                    // Setup the given pixel shader.
                    _D3D_OP_PixelShader_Set(pContext,
                                      pSetPxlShader->dwHandle);

                    // Now skip into the next DP2 token in the command buffer
                    lpPrim += sizeof(D3DHAL_DP2PIXELSHADER);               
                }
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2PIXELSHADER, 
                                lpIns->wStateCount, 0);
            }
            break;
            
        case D3DDP2OP_DELETEPIXELSHADER:
            {
                D3DHAL_DP2PIXELSHADER* pDelPxlShader;

                DISPDBG((DBGLVL, "D3DDP2OP_DELETEPIXELSHADER"));

                // verify that all the following pixel shader 
                // delete blocks are readable
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2PIXELSHADER, 
                                    lpIns->wStateCount, 0);    

                // iterate through each passed vertex shader delete block
                for (i = 0; i < lpIns->wStateCount; i++)
                {
                    // Get the passed in vertex shader
                    pDelPxlShader = (D3DHAL_DP2PIXELSHADER*)lpPrim;

                    // Destroy the given pixel shader
                    _D3D_OP_PixelShader_Delete(pContext,
                                         pDelPxlShader->dwHandle);

                    // Update lpPrim in order to get to the next vertex
                    // shader delete command block. 
                    lpPrim += sizeof(D3DHAL_DP2PIXELSHADER);               
                }

                // Now skip into the next DP2 token in the command buffer
                NEXTINSTRUCTION(lpIns, 
                                D3DHAL_DP2PIXELSHADER, 
                                lpIns->wStateCount, 
                                0);            
            }
            break;
            
        case D3DDP2OP_SETPIXELSHADERCONST:
            {
                D3DHAL_DP2SETPIXELSHADERCONST* pPxlShaderConst;
                DWORD dwExtraBytes = 0;

                DISPDBG((DBGLVL, "D3DDP2OP_SETPIXELSHADERCONST"));

                // verify that all the following vertex shader 
                // constant blocks are readable
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETPIXELSHADERCONST, 
                                    lpIns->wStateCount, 0);    

                // iterate through each passed vertex shader constant block
                for (i = 0; i < lpIns->wStateCount; i++)
                {
                    // Get the passed in vertex shader constant
                    pPxlShaderConst = (D3DHAL_DP2SETPIXELSHADERCONST*)lpPrim;

                    // Update lpPrim to point to the const data to setup
                    lpPrim += sizeof(D3DHAL_DP2SETPIXELSHADERCONST);     

                    // Set up the constant entries
                    _D3D_OP_PixelShader_SetConst(pContext,
                                           pPxlShaderConst->dwRegister,
                                           pPxlShaderConst->dwCount,
                                           (DWORD *)lpPrim);

                    // Update lpPrim in order to get to the next vertex
                    // shader delete command block. Each register has 4 floats.
                    lpPrim += pPxlShaderConst->dwCount * 4 * sizeof(FLOAT);

                    dwExtraBytes += pPxlShaderConst->dwCount * 4 * sizeof(FLOAT);
                }

                // Now skip into the next DP2 token in the command buffer
                NEXTINSTRUCTION(lpIns, 
                                D3DHAL_DP2SETPIXELSHADERCONST, 
                                lpIns->wStateCount, 
                                dwExtraBytes);                 
            }
            break;
                        
#endif // DX8_PIXELSHADERS

#if DX8_MULTSTREAMS

        case D3DDP2OP_SETSTREAMSOURCE :
            {
                D3DHAL_DP2SETSTREAMSOURCE* pSetStreamSrc;
                
                DISPDBG((DBGLVL, "D3DDP2OP_SETSTREAMSOURCE"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETSTREAMSOURCE, 
                                    lpIns->wStateCount, 0);

                // iterate through each 
                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    pSetStreamSrc = (D3DHAL_DP2SETSTREAMSOURCE*)lpPrim;
                    
                    _D3D_OP_MStream_SetSrc(pContext,
                                     pSetStreamSrc->dwStream,
                                     pSetStreamSrc->dwVBHandle,
                                     pSetStreamSrc->dwStride);
                                 
                    lpPrim += sizeof(D3DHAL_DP2SETSTREAMSOURCE);
                }
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETSTREAMSOURCE, 
                                lpIns->wStateCount, 0);
            }
            break;
            
        case D3DDP2OP_SETSTREAMSOURCEUM :
            {
                D3DHAL_DP2SETSTREAMSOURCEUM* pSetStreamSrcUM;
                
                DISPDBG((DBGLVL, "D3DDP2OP_SETSTREAMSOURCEUM"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETSTREAMSOURCEUM, 
                                    lpIns->wStateCount, 0);
           
                // iterate through each 
                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    pSetStreamSrcUM = (D3DHAL_DP2SETSTREAMSOURCEUM*)lpPrim;
                    
                    _D3D_OP_MStream_SetSrcUM(pContext,
                                        pSetStreamSrcUM->dwStream,
                                        pSetStreamSrcUM->dwStride,
                                        pUMVtx,
                                        pdp2d->dwVertexLength);
                                 
                    lpPrim += sizeof(D3DHAL_DP2SETSTREAMSOURCEUM);
                }
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETSTREAMSOURCEUM, 
                                lpIns->wStateCount, 0);
            }
            break;        
            
        case D3DDP2OP_SETINDICES :
            {
                D3DHAL_DP2SETINDICES* pSetIndices;
                
                DISPDBG((DBGLVL, "D3DDP2OP_SETINDICES"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2SETINDICES, 
                                    lpIns->wStateCount, 0);
           
                // iterate through each 
                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    pSetIndices = (D3DHAL_DP2SETINDICES*)lpPrim;
                    
                    _D3D_OP_MStream_SetIndices(pContext,
                                         pSetIndices->dwVBHandle,
                                         pSetIndices->dwStride);
                                 
                    lpPrim += sizeof(D3DHAL_DP2SETINDICES);
                }
                    
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2SETINDICES, 
                                lpIns->wStateCount, 0);
            }
            break;            
                        
#endif // DX8_MULTSTREAMS

#if DX8_3DTEXTURES

        case D3DDP2OP_VOLUMEBLT:
            {
                DISPDBG((DBGLVL, "D3DDP2OP_VOLUMEBLT"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                    D3DHAL_DP2VOLUMEBLT, 
                                    lpIns->wStateCount, 0);

                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    // As the texture might live in user memory, we need to
                    // access it bracketing it with a try/except block. This
                    // is because the user memory might under some circumstances
                    // become invalid while the driver is running and then it
                    // would AV. Also, the driver might need to do some cleanup
                    // before returning to the OS.
                    __try
                    {
                        _D3D_OP_VolumeBlt(pContext,
                                        pThisDisplay, 
                                        (D3DHAL_DP2VOLUMEBLT*)(lpPrim));
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                        // On this driver we don't need to do anything special
                        DISPDBG((ERRLVL,"Driver caused exception at "
                                        "line %u of file %s",
                                        __LINE__,__FILE__));
                        PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, 
                                              DDERR_GENERIC);
                    }                  
                                 
                    lpPrim += sizeof(D3DHAL_DP2VOLUMEBLT);
                }
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2VOLUMEBLT, 
                                lpIns->wStateCount, 0);
            }
            break;     

#endif // DX8_3DTEXTURES
            
#if DX8_DDI            

        case D3DDP2OP_BUFFERBLT:
            {
                DISPDBG((DBGLVL, "D3DDP2OP_BUFFERBLT"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                    D3DHAL_DP2BUFFERBLT, 
                                    lpIns->wStateCount, 0);

                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    _D3D_OP_BufferBlt(pContext,
                                    pThisDisplay, 
                                    (D3DHAL_DP2BUFFERBLT*)(lpPrim));
                                 
                    lpPrim += sizeof(D3DHAL_DP2BUFFERBLT);
                }
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2BUFFERBLT, 
                                lpIns->wStateCount, 0);
            }
            break;   
        
#endif // DX8_DDI

        // This was found to be required for a few D3DRM apps 
        case D3DOP_EXIT:
            lpIns = (D3DHAL_DP2COMMAND *)(lpInsStart + 
                                          pdp2d->dwCommandLength + 
                                          pdp2d->dwCommandOffset);
            break;

        default:

            // Pick up the right rasterizers depending on the 
            // current rendering state
            _D3D_R3_PickVertexProcessor( pContext );

            // Check if vertex buffer resides in user memory or in a DDraw surface
            if (pdp2d->dwFlags & D3DHALDP2_USERMEMVERTICES)
            {
                // As the vertex buffer lives in user memory, we need to
                // access it bracketing it with a try/except block. This
                // is because the user memory might under some circumstances
                // become invalid while the driver is running and then it
                // would AV. Also, the driver might need to do some cleanup
                // before returning to the OS.

                __try
                {
                    // Try to render as a primitive(s) in a separate loop
                    // in order not loose performance doing hw setup again
                    bParseError = __DP2_PrimitiveOpsParser( pContext, 
                                                            pdp2d, 
                                                            &lpIns, 
                                                            lpInsStart, 
                                                            pContext->lpVertices);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    // On this driver we don't need to do anything special
                    DISPDBG((ERRLVL,"Driver caused exception at "
                                    "line %u of file %s",
                                    __LINE__,__FILE__));
                    PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, 
                                          DDERR_GENERIC);
                }                
            
            }
            else
            {
                // Try to render as a primitive(s) in a separate loop
                // in order not loose performance doing hw setup again
                bParseError = __DP2_PrimitiveOpsParser( pContext, 
                                                        pdp2d, 
                                                        &lpIns, 
                                                        lpInsStart, 
                                                        pContext->lpVertices);
            }

            // We weren't succesful, so we exit with an error code
            if (bParseError)
            {
                PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, 
                                      D3DERR_COMMAND_UNPARSED);
            }
        } // switch
    } // while


//@@BEGIN_DDKSPLIT
#if DX7_VERTEXBUFFERS 
    if( bUsedHostIn )
    {
        _D3D_EB_UpdateSwapBuffers(pThisDisplay,
                                  pdp2d ,
                                  pVertexBufferInfo,
                                  pCommandBufferInfo);        
    }
#endif    
//@@END_DDKSPLIT

    START_SOFTWARE_CURSOR(pThisDisplay);

    if (!bParseError)
    {
        pdp2d->ddrval = DD_OK;
    }

    DBG_CB_EXIT(D3DDrawPrimitives2_P3, DD_OK);                              
    return DDHAL_DRIVER_HANDLED;
    
} // D3DDrawPrimitives2_P3

//-----------------------------------------------------------------------------
//
// __DP2_PrimitiveOpsParser
//
// Render command buffer which contains primitive(s) in a separate loop            
// in order not to loose performance doing hw setup repeatedly. We keep
// spinning in this loop until we reach an EOB, a non-rendering DP2 command
// or until an error is detected.
//
//-----------------------------------------------------------------------------
BOOL
__DP2_PrimitiveOpsParser( 
    P3_D3DCONTEXT *pContext, 
    LPD3DHAL_DRAWPRIMITIVES2DATA pdp2d,
    LPD3DHAL_DP2COMMAND *lplpIns, 
    LPBYTE lpInsStart, 
    LPDWORD lpVerts)
{
    P3_THUNKEDDATA*      pThisDisplay = pContext->pThisDisplay;
    LPD3DTLVERTEX        lpVertices = (LPD3DTLVERTEX) lpVerts;
    LPD3DHAL_DP2COMMAND  lpIns;
    LPD3DHAL_DP2COMMAND  lpResumeIns;  
    LPBYTE               lpPrim, lpChkPrim;
    HRESULT              ddrval;
    DWORD                dwFillMode;
    BOOL                 bParseError = FALSE;
    DWORD                i;

    DBG_ENTRY(__DP2_PrimitiveOpsParser);           

    lpIns = *lplpIns;

// This macro includes all parameters passed to all the specialized
// rendering functions (since their parameters are all the same)
// just to save us of some clutter in the actual code
#define P3_RND_PARAMS               \
            pContext,               \
            lpIns->wPrimitiveCount, \
            lpPrim,                 \
            lpVertices,             \
            pdp2d->dwVertexLength, \
            &bParseError

    // Ensure the hostin unit is setup for inline vertex data.
    {
        P3_DMA_DEFS();
        P3_DMA_GET_BUFFER_ENTRIES(6);
        pContext->SoftCopyGlint.P3RX_P3VertexControl.Size = 
                    pContext->FVFData.dwStrideHostInline / sizeof(DWORD);
                            
        COPY_P3_DATA( VertexControl, 
                      pContext->SoftCopyGlint.P3RX_P3VertexControl );
        SEND_P3_DATA( VertexValid, 
                      pContext->FVFData.dwVertexValidHostInline);
        SEND_P3_DATA( VertexFormat, 
                      pContext->FVFData.vFmatHostInline);
                      
        P3_DMA_COMMIT_BUFFER();
    }

    // Process commands while we haven't exhausted the command buffer
    while (!bParseError && 
           ((LPBYTE)lpIns < 
            (lpInsStart + pdp2d->dwCommandLength + pdp2d->dwCommandOffset))) 
    {
        BOOL bNonRenderingOP;
    
        // Get pointer to first primitive structure past the D3DHAL_DP2COMMAND
        lpPrim = (LPBYTE)lpIns + sizeof(D3DHAL_DP2COMMAND);

        // Rendering primitive functions called vary according to 
        // the fill mode selected ( POINT, WIREFRAME, SOLID );
        dwFillMode = pContext->RenderStates[D3DRENDERSTATE_FILLMODE];        

        DISPDBG((DBGLVL, "__DP2_PrimitiveOpsParser: "
                    "Parsing instruction %d Count = %d @ %x",
                    lpIns->bCommand, lpIns->wPrimitiveCount, lpIns));

        // If we are processing a known, though non-rendering opcode 
        // then  its time to quit this function
        bNonRenderingOP =
            ( lpIns->bCommand == D3DDP2OP_RENDERSTATE )       ||
            ( lpIns->bCommand == D3DDP2OP_TEXTURESTAGESTATE ) ||
            ( lpIns->bCommand == D3DDP2OP_STATESET )          ||            
            ( lpIns->bCommand == D3DDP2OP_VIEWPORTINFO )      ||
            ( lpIns->bCommand == D3DDP2OP_WINFO )             ||
            ( lpIns->bCommand == D3DDP2OP_ZRANGE )            ||
            ( lpIns->bCommand == D3DDP2OP_SETMATERIAL )       ||
            ( lpIns->bCommand == D3DDP2OP_SETLIGHT )          ||
            ( lpIns->bCommand == D3DDP2OP_TEXBLT )            ||
            ( lpIns->bCommand == D3DDP2OP_SETLIGHT )          ||
            ( lpIns->bCommand == D3DDP2OP_TEXBLT )            ||
            ( lpIns->bCommand == D3DDP2OP_CREATELIGHT )       ||
            ( lpIns->bCommand == D3DDP2OP_EXT )               ||
            ( lpIns->bCommand == D3DDP2OP_SETTRANSFORM )      ||
            ( lpIns->bCommand == D3DDP2OP_CLEAR )             ||
            ( lpIns->bCommand == D3DDP2OP_UPDATEPALETTE )     ||
            ( lpIns->bCommand == D3DDP2OP_SETPALETTE )        ||
#if DX7_TEXMANAGEMENT
            ( lpIns->bCommand == D3DDP2OP_SETTEXLOD )         ||
            ( lpIns->bCommand == D3DDP2OP_SETPRIORITY )       ||
#endif // DX7_TEXMANAGEMENT
#if DX8_DDI            
            ( lpIns->bCommand == D3DDP2OP_CREATEVERTEXSHADER) ||
            ( lpIns->bCommand == D3DDP2OP_SETVERTEXSHADER)    ||
            ( lpIns->bCommand == D3DDP2OP_DELETEVERTEXSHADER) ||
            ( lpIns->bCommand == D3DDP2OP_SETVERTEXSHADERCONST) ||
            ( lpIns->bCommand == D3DDP2OP_CREATEPIXELSHADER)  ||
            ( lpIns->bCommand == D3DDP2OP_SETPIXELSHADER)     ||
            ( lpIns->bCommand == D3DDP2OP_DELETEPIXELSHADER)  ||
            ( lpIns->bCommand == D3DDP2OP_SETPIXELSHADERCONST)||
            ( lpIns->bCommand == D3DDP2OP_SETSTREAMSOURCE )   ||
            ( lpIns->bCommand == D3DDP2OP_SETSTREAMSOURCEUM ) ||
            ( lpIns->bCommand == D3DDP2OP_SETINDICES )        ||
#endif //DX8_DDI            
            ( lpIns->bCommand == D3DDP2OP_SETRENDERTARGET);

        if (bNonRenderingOP)            
        {
            break;
        }

        // Main rendering Dp2 opcode switch                   
        switch( lpIns->bCommand )
        {
        case D3DDP2OP_POINTS:

            DISPDBG((DBGLVL, "D3DDP2OP_POINTS"));

            // Point primitives in vertex buffers are defined by the 
            // D3DHAL_DP2POINTS structure. The driver should render
            // wCount points starting at the initial vertex specified 
            // by wFirst. Then for each D3DHAL_DP2POINTS, the points
            // rendered will be (wFirst),(wFirst+1),...,
            // (wFirst+(wCount-1)). The number of D3DHAL_DP2POINTS
            // structures to process is specified by the wPrimitiveCount
            // field of D3DHAL_DP2COMMAND.
            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                D3DHAL_DP2POINTS, lpIns->wPrimitiveCount, 0);

            _D3D_R3_DP2_Points( P3_RND_PARAMS );
            
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2POINTS, 
                            lpIns->wPrimitiveCount, 0);
            break;

        case D3DDP2OP_LINELIST:

            DISPDBG((DBGLVL, "D3DDP2OP_LINELIST"));

            // Non-indexed vertex-buffer line lists are defined by the 
            // D3DHAL_DP2LINELIST structure. Given an initial vertex, 
            // the driver will render a sequence of independent lines, 
            // processing two new vertices with each line. The number 
            // of lines to render is specified by the wPrimitiveCount
            // field of D3DHAL_DP2COMMAND. The sequence of lines 
            // rendered will be 
            // (wVStart, wVStart+1),(wVStart+2, wVStart+3),...,
            // (wVStart+(wPrimitiveCount-1)*2), wVStart+wPrimitiveCount*2 - 1).

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, D3DHAL_DP2LINELIST, 1, 0);

            _D3D_R3_DP2_LineList( P3_RND_PARAMS );
        
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2LINELIST, 1, 0);
            break;

        case D3DDP2OP_INDEXEDLINELIST:

            DISPDBG((DBGLVL, "D3DDP2OP_INDEXEDLINELIST"));

            // The D3DHAL_DP2INDEXEDLINELIST structure specifies 
            // unconnected lines to render using vertex indices.
            // The line endpoints for each line are specified by wV1 
            // and wV2. The number of lines to render using this 
            // structure is specified by the wPrimitiveCount field of
            // D3DHAL_DP2COMMAND.  The sequence of lines 
            // rendered will be (wV[0], wV[1]), (wV[2], wV[3]),...
            // (wVStart[(wPrimitiveCount-1)*2], wVStart[wPrimitiveCount*2-1]).

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                D3DHAL_DP2INDEXEDLINELIST, 
                                lpIns->wPrimitiveCount, 0);

            _D3D_R3_DP2_IndexedLineList( P3_RND_PARAMS );

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2INDEXEDLINELIST, 
                                   lpIns->wPrimitiveCount, 0);
            break;

        case D3DDP2OP_INDEXEDLINELIST2:

            DISPDBG((DBGLVL, "D3DDP2OP_INDEXEDLINELIST2"));

            // The D3DHAL_DP2INDEXEDLINELIST structure specifies 
            // unconnected lines to render using vertex indices.
            // The line endpoints for each line are specified by wV1 
            // and wV2. The number of lines to render using this 
            // structure is specified by the wPrimitiveCount field of
            // D3DHAL_DP2COMMAND.  The sequence of lines 
            // rendered will be (wV[0], wV[1]), (wV[2], wV[3]),
            // (wVStart[(wPrimitiveCount-1)*2], wVStart[wPrimitiveCount*2-1]).
            // The indexes are relative to a base index value that 
            // immediately follows the command
            
            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                D3DHAL_DP2INDEXEDLINELIST, 
                                lpIns->wPrimitiveCount, STARTVERTEXSIZE);

            _D3D_R3_DP2_IndexedLineList2( P3_RND_PARAMS );

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2INDEXEDLINELIST, 
                                   lpIns->wPrimitiveCount, STARTVERTEXSIZE);
            break;

        case D3DDP2OP_LINESTRIP:

            DISPDBG((DBGLVL, "D3DDP2OP_LINESTRIP"));

            // Non-index line strips rendered with vertex buffers are
            // specified using D3DHAL_DP2LINESTRIP. The first vertex 
            // in the line strip is specified by wVStart. The 
            // number of lines to process is specified by the 
            // wPrimitiveCount field of D3DHAL_DP2COMMAND. The sequence
            // of lines rendered will be (wVStart, wVStart+1),
            // (wVStart+1, wVStart+2),(wVStart+2, wVStart+3),...,
            // (wVStart+wPrimitiveCount, wVStart+wPrimitiveCount+1).

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,D3DHAL_DP2LINESTRIP, 1, 0);

            _D3D_R3_DP2_LineStrip( P3_RND_PARAMS );

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2LINESTRIP, 1, 0);
            break;

        case D3DDP2OP_INDEXEDLINESTRIP:

            DISPDBG((DBGLVL, "D3DDP2OP_INDEXEDLINESTRIP"));

            // Indexed line strips rendered with vertex buffers are 
            // specified using D3DHAL_DP2INDEXEDLINESTRIP. The number
            // of lines to process is specified by the wPrimitiveCount
            // field of D3DHAL_DP2COMMAND. The sequence of lines 
            // rendered will be (wV[0], wV[1]), (wV[1], wV[2]),
            // (wV[2], wV[3]), ...
            // (wVStart[wPrimitiveCount-1], wVStart[wPrimitiveCount]). 
            // Although the D3DHAL_DP2INDEXEDLINESTRIP structure only
            // has enough space allocated for a single line, the wV 
            // array of indices should be treated as a variable-sized 
            // array with wPrimitiveCount+1 elements.
            // The indexes are relative to a base index value that 
            // immediately follows the command

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                WORD, 
                                lpIns->wPrimitiveCount + 1, 
                                STARTVERTEXSIZE);

            _D3D_R3_DP2_IndexedLineStrip( P3_RND_PARAMS );

            // Point to next D3DHAL_DP2COMMAND in the command buffer
            // Advance only as many vertex indices there are, with no padding!
            NEXTINSTRUCTION(lpIns, WORD, 
                            lpIns->wPrimitiveCount + 1, STARTVERTEXSIZE);
            break;

        case D3DDP2OP_TRIANGLELIST:

            DISPDBG((DBGLVL, "D3DDP2OP_TRIANGLELIST"));

            // Non-indexed vertex buffer triangle lists are defined by 
            // the D3DHAL_DP2TRIANGLELIST structure. Given an initial
            // vertex, the driver will render independent triangles, 
            // processing three new vertices with each triangle. The
            // number of triangles to render is specified by the 
            // wPrimitveCount field of D3DHAL_DP2COMMAND. The sequence
            // of vertices processed will be  (wVStart, wVStart+1, 
            // vVStart+2), (wVStart+3, wVStart+4, vVStart+5),...,
            // (wVStart+(wPrimitiveCount-1)*3), wVStart+wPrimitiveCount*3-2, 
            // vStart+wPrimitiveCount*3-1).

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                D3DHAL_DP2TRIANGLELIST, 1, 0);

            _D3D_R3_DP2_TriangleList( P3_RND_PARAMS );

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2TRIANGLELIST, 1, 0);
            break;

        case D3DDP2OP_INDEXEDTRIANGLELIST:

            DISPDBG((DBGLVL, "D3DDP2OP_INDEXEDTRIANGLELIST"));

            // The D3DHAL_DP2INDEXEDTRIANGLELIST structure specifies 
            // unconnected triangles to render with a vertex buffer.
            // The vertex indices are specified by wV1, wV2 and wV3. 
            // The wFlags field allows specifying edge flags identical 
            // to those specified by D3DOP_TRIANGLE. The number of 
            // triangles to render (that is, number of 
            // D3DHAL_DP2INDEXEDTRIANGLELIST structures to process) 
            // is specified by the wPrimitiveCount field of 
            // D3DHAL_DP2COMMAND.

            // This is the only indexed primitive where we don't get 
            // an offset into the vertex buffer in order to maintain
            // DX3 compatibility. A new primitive 
            // (D3DDP2OP_INDEXEDTRIANGLELIST2) has been added to handle
            // the corresponding D3D primitive.

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                D3DHAL_DP2INDEXEDTRIANGLELIST, 
                                lpIns->wPrimitiveCount, 0);
                                
            if( lpIns->wPrimitiveCount )
            {   
                _D3D_R3_DP2_IndexedTriangleList( P3_RND_PARAMS );
            }
    
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2INDEXEDTRIANGLELIST, 
                            lpIns->wPrimitiveCount, 0);
            break;

        case D3DDP2OP_INDEXEDTRIANGLELIST2:

            DISPDBG((DBGLVL, "D3DDP2OP_INDEXEDTRIANGLELIST2 "));

            // The D3DHAL_DP2INDEXEDTRIANGLELIST2 structure specifies 
            // unconnected triangles to render with a vertex buffer.
            // The vertex indices are specified by wV1, wV2 and wV3. 
            // The wFlags field allows specifying edge flags identical 
            // to those specified by D3DOP_TRIANGLE. The number of 
            // triangles to render (that is, number of 
            // D3DHAL_DP2INDEXEDTRIANGLELIST structures to process) 
            // is specified by the wPrimitiveCount field of 
            // D3DHAL_DP2COMMAND.
            // The indexes are relative to a base index value that 
            // immediately follows the command

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                D3DHAL_DP2INDEXEDTRIANGLELIST2, 
                                lpIns->wPrimitiveCount, STARTVERTEXSIZE);

            _D3D_R3_DP2_IndexedTriangleList2( P3_RND_PARAMS );

            NEXTINSTRUCTION(lpIns, D3DHAL_DP2INDEXEDTRIANGLELIST2, 
                                   lpIns->wPrimitiveCount, STARTVERTEXSIZE);
            break;

        case D3DDP2OP_TRIANGLESTRIP:

            DISPDBG((DBGLVL, "D3DDP2OP_TRIANGLESTRIP"));

            // Non-index triangle strips rendered with vertex buffers 
            // are specified using D3DHAL_DP2TRIANGLESTRIP. The first 
            // vertex in the triangle strip is specified by wVStart. 
            // The number of triangles to process is specified by the 
            // wPrimitiveCount field of D3DHAL_DP2COMMAND. The sequence
            // of triangles rendered for the odd-triangles case will 
            // be (wVStart, wVStart+1, vVStart+2), (wVStart+2, 
            // wVStart+1, vVStart+3),.(wVStart+2, wVStart+3, 
            // vVStart+4),.., (wVStart+wPrimitiveCount-1), 
            // wVStart+wPrimitiveCount, vStart+wPrimitiveCount+1). For an
            // even number of , the last triangle will be .,
            // (wVStart+wPrimitiveCount), wVStart+wPrimitiveCount-1, 
            // vStart+wPrimitiveCount+1).

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, D3DHAL_DP2TRIANGLESTRIP, 1, 0);

            _D3D_R3_DP2_TriangleStrip( P3_RND_PARAMS );

            // Point to next D3DHAL_DP2COMMAND in the command buffer
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2TRIANGLESTRIP, 1, 0);
            break;

        case D3DDP2OP_INDEXEDTRIANGLESTRIP:

            DISPDBG((DBGLVL, "D3DDP2OP_INDEXEDTRIANGLESTRIP"));

            // Indexed triangle strips rendered with vertex buffers are 
            // specified using D3DHAL_DP2INDEXEDTRIANGLESTRIP. The number
            // of triangles to process is specified by the wPrimitiveCount
            // field of D3DHAL_DP2COMMAND. The sequence of triangles 
            // rendered for the odd-triangles case will be 
            // (wV[0],wV[1],wV[2]),(wV[2],wV[1],wV[3]),
            // (wV[3],wV[4],wV[5]),...,(wV[wPrimitiveCount-1],
            // wV[wPrimitiveCount],wV[wPrimitiveCount+1]). For an even
            // number of triangles, the last triangle will be
            // (wV[wPrimitiveCount],wV[wPrimitiveCount-1],
            // wV[wPrimitiveCount+1]).Although the 
            // D3DHAL_DP2INDEXEDTRIANGLESTRIP structure only has 
            // enough space allocated for a single line, the wV 
            // array of indices should be treated as a variable-sized 
            // array with wPrimitiveCount+2 elements.
            // The indexes are relative to a base index value that 
            // immediately follows the command

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, WORD,
                                lpIns->wPrimitiveCount + 2, STARTVERTEXSIZE);

            _D3D_R3_DP2_IndexedTriangleStrip( P3_RND_PARAMS );
            
            // Point to next D3DHAL_DP2COMMAND in the command buffer
            NEXTINSTRUCTION(lpIns, WORD , 
                            lpIns->wPrimitiveCount + 2, STARTVERTEXSIZE);
            break;

        case D3DDP2OP_TRIANGLEFAN:

            DISPDBG((DBGLVL, "D3DDP2OP_TRIANGLEFAN"));

            // The D3DHAL_DP2TRIANGLEFAN structure is used to draw 
            // non-indexed triangle fans. The sequence of triangles
            // rendered will be (wVStart, wVstart+1, wVStart+2),
            // (wVStart,wVStart+2,wVStart+3), (wVStart,wVStart+3,
            // wVStart+4),...,(wVStart,wVStart+wPrimitiveCount,
            // wVStart+wPrimitiveCount+1).

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, 
                                D3DHAL_DP2TRIANGLEFAN, 1, 0);

            _D3D_R3_DP2_TriangleFan( P3_RND_PARAMS );
            
            NEXTINSTRUCTION(lpIns, D3DHAL_DP2TRIANGLEFAN, 1, 0);
            break;

        case D3DDP2OP_INDEXEDTRIANGLEFAN:

            DISPDBG((DBGLVL,"D3DDP2OP_INDEXEDTRIANGLEFAN"));

            // The D3DHAL_DP2INDEXEDTRIANGLEFAN structure is used to 
            // draw indexed triangle fans. The sequence of triangles
            // rendered will be (wV[0], wV[1], wV[2]), (wV[0], wV[2],
            // wV[3]), (wV[0], wV[3], wV[4]),...,(wV[0],
            // wV[wPrimitiveCount], wV[wPrimitiveCount+1]).
            // The indexes are relative to a base index value that 
            // immediately follows the command

            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim, WORD,
                                lpIns->wPrimitiveCount + 2, STARTVERTEXSIZE);

            _D3D_R3_DP2_IndexedTriangleFan( P3_RND_PARAMS );

            // Point to next D3DHAL_DP2COMMAND in the command buffer
            NEXTINSTRUCTION(lpIns,WORD ,lpIns->wPrimitiveCount + 2, 
                            STARTVERTEXSIZE);
            break;

        case D3DDP2OP_LINELIST_IMM:

            DISPDBG((DBGLVL, "D3DDP2OP_LINELIST_IMM"));

            // Draw a set of lines specified by pairs of vertices 
            // that immediately follow this instruction in the
            // command stream. The wPrimitiveCount member of the
            // D3DHAL_DP2COMMAND structure specifies the number
            // of lines that follow. 

            // Primitives in an IMM instruction are stored in the
            // command buffer and are DWORD aligned
            lpPrim = (LPBYTE)((ULONG_PTR)(lpPrim + 3 ) & ~3 );

            // Verify the command buffer validity (data lives in it!)
            CHECK_CMDBUF_LIMITS_S(pdp2d, lpPrim,
                                  pContext->FVFData.dwStride, 
                                  lpIns->wPrimitiveCount + 1, 0);            

            _D3D_R3_DP2_LineListImm( P3_RND_PARAMS );

            // Realign next command since vertices are dword aligned
            // and store # of primitives before affecting the pointer
            NEXTINSTRUCTION(lpIns, BYTE, 
                            ((lpIns->wPrimitiveCount * 2) * 
                                 pContext->FVFData.dwStride), 0);

            // Realign next command since vertices are dword aligned
            lpIns  = (LPD3DHAL_DP2COMMAND)(( ((ULONG_PTR)lpIns) + 3 ) & ~ 3);

            break;

        case D3DDP2OP_TRIANGLEFAN_IMM:

            DISPDBG((DBGLVL, "D3DDP2OP_TRIANGLEFAN_IMM"));

            // Draw a triangle fan specified by pairs of vertices 
            // that immediately follow this instruction in the
            // command stream. The wPrimitiveCount member of the
            // D3DHAL_DP2COMMAND structure specifies the number
            // of triangles that follow. 

            // Verify the command buffer validity for the first structure
            CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                BYTE , 0 , 
                                sizeof(D3DHAL_DP2TRIANGLEFAN_IMM));

            // Get pointer where data should start
            lpChkPrim = (LPBYTE)((ULONG_PTR)( lpPrim + 3 + 
                                   sizeof(D3DHAL_DP2TRIANGLEFAN_IMM)) & ~3 );

            // Verify the rest of the command buffer
            CHECK_CMDBUF_LIMITS_S(pdp2d, lpChkPrim,
                                  pContext->FVFData.dwStride, 
                                  lpIns->wPrimitiveCount + 2, 0);  
                                         
            _D3D_R3_DP2_TriangleFanImm( P3_RND_PARAMS );    
    
            // Realign next command since vertices are dword aligned
            // and store # of primitives before affecting the pointer
            NEXTINSTRUCTION(lpIns, BYTE, 
                            ((lpIns->wPrimitiveCount + 2) * 
                                    pContext->FVFData.dwStride), 
                            sizeof(D3DHAL_DP2TRIANGLEFAN_IMM)); 

            // Realign next command since vertices are dword aligned
            lpIns  = (LPD3DHAL_DP2COMMAND)(( ((ULONG_PTR)lpIns) + 3 ) & ~ 3);


            break;                                     


#if DX8_MULTSTREAMS
        case D3DDP2OP_DRAWPRIMITIVE :
            {
                D3DHAL_DP2DRAWPRIMITIVE* pDrawPrim;
                
                DISPDBG((DBGLVL, "D3DDP2OP_DRAWPRIMITIVE"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2DRAWPRIMITIVE, 
                                    lpIns->wStateCount, 0);
           
                // iterate through each 
                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    pDrawPrim = (D3DHAL_DP2DRAWPRIMITIVE*)lpPrim;
                    
                    _D3D_OP_MStream_DrawPrim(pContext,
                                       pDrawPrim->primType,
                                       pDrawPrim->VStart,
                                       pDrawPrim->PrimitiveCount);
                                 
                    lpPrim += sizeof(D3DHAL_DP2DRAWPRIMITIVE);
                }
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2DRAWPRIMITIVE, 
                                lpIns->wStateCount, 0);
                }
            break;  
            
        case D3DDP2OP_DRAWINDEXEDPRIMITIVE :
            {
                D3DHAL_DP2DRAWINDEXEDPRIMITIVE* pDrawIndxPrim;
            
                DISPDBG((DBGLVL, "D3DDP2OP_DRAWINDEXEDPRIMITIVE"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2DRAWINDEXEDPRIMITIVE, 
                                    lpIns->wStateCount, 0);
                // iterate through each 
                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    pDrawIndxPrim = (D3DHAL_DP2DRAWINDEXEDPRIMITIVE*)lpPrim;
                    
                    _D3D_OP_MStream_DrawIndxP(pContext,
                                        pDrawIndxPrim->primType,
                                        pDrawIndxPrim->BaseVertexIndex,
                                        pDrawIndxPrim->MinIndex,
                                        pDrawIndxPrim->NumVertices,
                                        pDrawIndxPrim->StartIndex,
                                        pDrawIndxPrim->PrimitiveCount);
                                 
                    lpPrim += sizeof(D3DHAL_DP2DRAWINDEXEDPRIMITIVE);
                }
               
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2DRAWINDEXEDPRIMITIVE, 
                                lpIns->wStateCount, 0);
            }
            break;  
            
        case D3DDP2OP_DRAWPRIMITIVE2 :
            {
                D3DHAL_DP2DRAWPRIMITIVE2* pDrawPrim2;
                
                DISPDBG((DBGLVL, "D3DDP2OP_DRAWPRIMITIVE2"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2DRAWPRIMITIVE2, 
                                    lpIns->wStateCount, 0);
           
                // iterate through each 
                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    pDrawPrim2 = (D3DHAL_DP2DRAWPRIMITIVE2*)lpPrim;
                    
                    _D3D_OP_MStream_DrawPrim2(pContext,
                                        pDrawPrim2->primType,
                                        pDrawPrim2->FirstVertexOffset,
                                        pDrawPrim2->PrimitiveCount);
                                 
                    lpPrim += sizeof(D3DHAL_DP2DRAWPRIMITIVE2);
                }
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2DRAWPRIMITIVE2, 
                                lpIns->wStateCount, 0);
                }
            break;    
            
        case D3DDP2OP_DRAWINDEXEDPRIMITIVE2 :
            {
                D3DHAL_DP2DRAWINDEXEDPRIMITIVE2* pDrawIndxPrim2;
            
                DISPDBG((DBGLVL, "D3DDP2OP_DRAWINDEXEDPRIMITIVE2"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2DRAWINDEXEDPRIMITIVE2, 
                                    lpIns->wStateCount, 0);
                // iterate through each 
                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    pDrawIndxPrim2 = (D3DHAL_DP2DRAWINDEXEDPRIMITIVE2*)lpPrim;
                    
                    _D3D_OP_MStream_DrawIndxP2(pContext,
                                         pDrawIndxPrim2->primType,
                                         pDrawIndxPrim2->BaseVertexOffset,
                                         pDrawIndxPrim2->MinIndex,
                                         pDrawIndxPrim2->NumVertices,
                                         pDrawIndxPrim2->StartIndexOffset,
                                         pDrawIndxPrim2->PrimitiveCount);
                                 
                    lpPrim += sizeof(D3DHAL_DP2DRAWINDEXEDPRIMITIVE2);
                }
               
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2DRAWINDEXEDPRIMITIVE2,
                                lpIns->wStateCount, 0);
            }
            break;          
    
        case D3DDP2OP_DRAWRECTPATCH :
            {
                D3DHAL_DP2DRAWRECTPATCH* pRectSurf;
                DWORD dwExtraBytes = 0;
                
                DISPDBG((DBGLVL, "D3DDP2OP_DRAWRECTPATCH"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2DRAWRECTPATCH, 
                                    lpIns->wStateCount, 0);
                                    
                // iterate through each 
                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    pRectSurf = (D3DHAL_DP2DRAWRECTPATCH*)lpPrim;

                    lpPrim += sizeof(D3DHAL_DP2DRAWRECTPATCH);                    
                    
                    _D3D_OP_MStream_DrawRectSurface(pContext, 
                                                    pRectSurf->Handle,
                                                    pRectSurf->Flags,
                                                    lpPrim);
                                                    
                    if (pRectSurf->Flags & RTPATCHFLAG_HASSEGS)
                    {
                        dwExtraBytes += sizeof(D3DVALUE)* 4;                    
                    }
                    
                    if (pRectSurf->Flags & RTPATCHFLAG_HASINFO)                    
                    {
                        dwExtraBytes += sizeof(D3DRECTPATCH_INFO);
                    }

                    lpPrim += dwExtraBytes;
                } 
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2DRAWRECTPATCH, 
                                lpIns->wStateCount, dwExtraBytes);
            }
            break;     

        case D3DDP2OP_DRAWTRIPATCH :
            {
                D3DHAL_DP2DRAWTRIPATCH* pTriSurf;
                DWORD dwExtraBytes = 0;                
                
                DISPDBG((DBGLVL, "D3DDP2OP_DRAWTRIPATCH"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_DP2DRAWTRIPATCH, 
                                    lpIns->wStateCount, 0);
                                    
                // iterate through each 
                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    pTriSurf = (D3DHAL_DP2DRAWTRIPATCH*)lpPrim;

                    lpPrim += sizeof(D3DHAL_DP2DRAWTRIPATCH);

                    _D3D_OP_MStream_DrawTriSurface(pContext, 
                                                   pTriSurf->Handle,
                                                   pTriSurf->Flags,
                                                   lpPrim);                    
                                 
                    if (pTriSurf->Flags & RTPATCHFLAG_HASSEGS)
                    {
                        dwExtraBytes += sizeof(D3DVALUE)* 3;                    
                    }
                    
                    if (pTriSurf->Flags & RTPATCHFLAG_HASINFO)                    
                    {
                        dwExtraBytes += sizeof(D3DTRIPATCH_INFO);
                    }

                    lpPrim += dwExtraBytes;
                } 
                
                NEXTINSTRUCTION(lpIns, D3DHAL_DP2DRAWTRIPATCH, 
                                lpIns->wStateCount, dwExtraBytes);
            }
            break;                 
            
        case D3DDP2OP_CLIPPEDTRIANGLEFAN :
            {
                D3DHAL_CLIPPEDTRIANGLEFAN* pClipdTriFan;
            
                DISPDBG((DBGLVL, "D3DDP2OP_CLIPPEDTRIANGLEFAN"));
                CHECK_CMDBUF_LIMITS(pdp2d, lpPrim,
                                    D3DHAL_CLIPPEDTRIANGLEFAN, 
                                    lpIns->wStateCount, 0);

                // iterate through each 
                for ( i = 0; i < lpIns->wStateCount; i++)
                {
                    pClipdTriFan = (D3DHAL_CLIPPEDTRIANGLEFAN*)lpPrim;
                    
                    _D3D_OP_MStream_ClipTriFan(pContext,
                                         pClipdTriFan->FirstVertexOffset,
                                         pClipdTriFan->dwEdgeFlags,
                                         pClipdTriFan->PrimitiveCount);
                                 
                    lpPrim += sizeof(D3DHAL_CLIPPEDTRIANGLEFAN);
                } 
                
                NEXTINSTRUCTION(lpIns, D3DHAL_CLIPPEDTRIANGLEFAN, 
                                lpIns->wStateCount, 0);
            }
            break;     

#endif // DX8_MULTSTREAMS

        // This was found to be required for a few D3DRM apps 
        case D3DOP_EXIT:
            lpIns = (D3DHAL_DP2COMMAND *)(lpInsStart + 
                                          pdp2d->dwCommandLength + 
                                          pdp2d->dwCommandOffset);
            break;

        default:

            ASSERTDD((pThisDisplay->pD3DParseUnknownCommand),
                      "D3D ParseUnknownCommand callback == NULL");

            if( SUCCEEDED(ddrval=(pThisDisplay->pD3DParseUnknownCommand)
                                    ( lpIns , 
                                      (void**)&lpResumeIns)) ) 
            {
                // Resume buffer processing after D3DParseUnknownCommand
                // was succesful in processing an unknown command
                lpIns = lpResumeIns;
                break;
            }

            DISPDBG((ERRLVL, "Unhandled opcode (%d)- "
                        "returning D3DERR_COMMAND_UNPARSED @ addr %x", 
                        lpIns->bCommand,
                        lpIns));
                    
            PARSE_ERROR_AND_EXIT( pdp2d, lpIns, lpInsStart, ddrval);
        } // switch

    } //while

    *lplpIns = lpIns;

    DBG_EXIT(__DP2_PrimitiveOpsParser, bParseError); 
    return bParseError;
    
} // __DP2_PrimitiveOpsParser


//-----------------------------Public Routine----------------------------------
//
// D3DValidateDeviceP3
//
// Returns the number of passes in which the hardware can perform the blending 
// operations specified in the current state.
//
// Direct3D drivers that support texturing must implement 
// D3dValidateTextureStageState.
//
// The driver must do the following: 
//
// Evaluate the current texture state for all texture stages associated with the 
// context. If the driver's hardware can perform the specified blending 
// operations, the driver should return the number of passes on the state data 
// that its hardware requires in order to entirely process the operations. If 
// the hardware is incapable of performing the specified blending operations, 
// the driver should return one of the following error codes in ddrval: 
//
//      D3DERR_CONFLICTINGTEXTUREFILTER 
//              The hardware cannot do both trilinear filtering and 
//              multi-texturing at the same time. 
//      D3DERR_TOOMANYOPERATIONS 
//              The hardware cannot handle the specified number of operations. 
//      D3DERR_UNSUPPORTEDALPHAARG 
//              The hardware does not support a specified alpha argument. 
//      D3DERR_UNSUPPORTEDALPHAOPERATION 
//              The hardware does not support a specified alpha operation. 
//      D3DERR_UNSUPPORTEDCOLORARG 
//              The hardware does not support a specified color argument. 
//      D3DERR_UNSUPPORTEDCOLOROPERATION 
//              The hardware does not support a specified color operation. 
//      D3DERR_UNSUPPORTEDFACTORVALUE 
//              The hardware does not support a D3DTA_TFACTOR greater than 1.0. 
//      D3DERR_WRONGTEXTUREFORMAT 
//              The hardware does not support the current state in the selected 
//              texture format
// 
// Direct3D calls D3dValidateTextureStageState in response to an application 
// request through a call to IDirect3DDevice3::ValidateTextureStageState. The 
// number of passes returned by the driver is propagated back to the application
// , which can then decide whether it wants to proceed with rendering using the 
// current state or if it wants/needs to change the blending operations to 
// render faster or render at all. There are no limits to the number of passes 
// that a driver can return.
//
// A driver that returns more than one pass is responsible for properly 
//executing the passes on all state and primitive data when rendering.
//
// Parameters
//
//      pvtssd
//
//          .dwhContext
//               Specifies the context ID of the Direct3D device. 
//          .dwFlags
//               Is currently set to zero and should be ignored by the driver. 
//          .dwReserved
//               Is reserved for system use and should be ignored by the driver.
//          .dwNumPasses
//              Specifies the location in which the driver should write the 
//              number of passes required by the hardware to perform the 
//              blending operations. 
//          .ddrval
//               return value
//
//-----------------------------------------------------------------------------

// Taken from the registry variable.
#define VDOPMODE_IGNORE_NONFATAL    0   // dualtex + trilinear (for examples) 
                                        // not flagged as a bug.

DWORD CALLBACK 
D3DValidateDeviceP3( 
    LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pvtssd )
{
    P3_D3DCONTEXT* pContext;
    P3_THUNKEDDATA* pThisDisplay;

    DBG_CB_ENTRY(D3DValidateDeviceP3);
    
    pContext = _D3D_CTX_HandleToPtr(pvtssd->dwhContext);
    if (!CHECK_D3DCONTEXT_VALIDITY(pContext))
    {
        pvtssd->ddrval = D3DHAL_CONTEXT_BAD;
        DISPDBG((WRNLVL,"ERROR: Context not valid"));
        DBG_CB_EXIT(D3DValidateDeviceP3, pvtssd->ddrval);  

        return (DDHAL_DRIVER_HANDLED);
    }

    pThisDisplay = pContext->pThisDisplay;

    STOP_SOFTWARE_CURSOR(pThisDisplay);
    D3D_OPERATION(pContext, pThisDisplay);

    // Re-do all the blend-mode setup from scratch.
    RESET_BLEND_ERROR(pContext);
    DIRTY_EVERYTHING(pContext);
    
    // The primitive type is not actually important except to keep the
    // rout from asserting various things when it tries to pick the renderer
    // (which of course does not need to be done in this case).
    ReconsiderStateChanges ( pContext );

    START_SOFTWARE_CURSOR(pThisDisplay);

    _D3DDisplayWholeTSSPipe ( pContext, DBGLVL);

    // And see if anything died.
    if (GET_BLEND_ERROR(pContext) == BS_OK )
    {
        // Cool - that worked.
        pvtssd->dwNumPasses = 1;
        pvtssd->ddrval = DD_OK;
        DBG_CB_EXIT(D3DValidateDeviceP3, pvtssd->ddrval);  

        return ( DDHAL_DRIVER_HANDLED );
    }
    else
    {
        // Oops. Failed.
        DISPDBG((DBGLVL,"ValidateDevice: failed ValidateDevice()"));

        switch ( GET_BLEND_ERROR(pContext) )
        {
            case BS_OK:
                DISPDBG((ERRLVL,"ValidateDevice: got BS_OK - that's not "
                             "an error!"));
                pvtssd->ddrval = DD_OK;
                break;

            case BS_INVALID_FILTER:
                pvtssd->ddrval = D3DERR_CONFLICTINGTEXTUREFILTER;
                break;

            case BSF_CANT_USE_COLOR_OP_HERE:
            case BSF_CANT_USE_COLOR_ARG_HERE:
            case BSF_CANT_USE_ALPHA_OP_HERE:
            case BSF_CANT_USE_ALPHA_ARG_HERE:
                pvtssd->ddrval = D3DERR_CONFLICTINGRENDERSTATE;
                break;

            case BSF_INVALID_TEXTURE:
            case BSF_TEXTURE_NOT_POW2:
                pvtssd->ddrval = D3DERR_WRONGTEXTUREFORMAT;
                break;

            case BSF_UNDEFINED_COLOR_OP:
            case BSF_UNSUPPORTED_COLOR_OP:
            case BSF_UNSUPPORTED_ALPHA_BLEND:   // doesn't fit anywhere else.
            case BSF_UNDEFINED_ALPHA_BLEND:     // doesn't fit anywhere else.
            case BSF_UNSUPPORTED_STATE:         // doesn't fit anywhere else.
            case BSF_UNDEFINED_STATE:           // doesn't fit anywhere else.
            case BS_PHONG_SHADING:              // doesn't fit anywhere else.
                pvtssd->ddrval = D3DERR_UNSUPPORTEDCOLOROPERATION;
                break;

            case BSF_UNDEFINED_COLOR_ARG:
            case BSF_UNSUPPORTED_COLOR_ARG:
                pvtssd->ddrval = D3DERR_UNSUPPORTEDCOLORARG;
                break;

            case BSF_UNDEFINED_ALPHA_OP:
            case BSF_UNSUPPORTED_ALPHA_OP:
                pvtssd->ddrval = D3DERR_UNSUPPORTEDALPHAOPERATION;
                break;

            case BSF_UNDEFINED_ALPHA_ARG:
            case BSF_UNSUPPORTED_ALPHA_ARG:
                pvtssd->ddrval = D3DERR_UNSUPPORTEDALPHAARG;
                break;

            case BSF_TOO_MANY_TEXTURES:
            case BSF_TOO_MANY_BLEND_STAGES:
                pvtssd->ddrval = D3DERR_TOOMANYOPERATIONS;
                break;

            case BSF_UNDEFINED_FILTER:
            case BSF_UNSUPPORTED_FILTER:
                pvtssd->ddrval = D3DERR_UNSUPPORTEDTEXTUREFILTER;
                break;

            case BSF_TOO_MANY_PALETTES:
                pvtssd->ddrval = D3DERR_CONFLICTINGTEXTUREPALETTE;
                break;

// Nothing maps to these, but they are valid D3D return
// codes that be used for future errors.
//              pvtssd->ddrval = D3DERR_UNSUPPORTEDFACTORVALUE;
//              break;
//              pvtssd->ddrval = D3DERR_TOOMANYPRIMITIVES;
//              break;
//              pvtssd->ddrval = D3DERR_INVALIDMATRIX;
//              break;
//              pvtssd->ddrval = D3DERR_TOOMANYVERTICES;
//              break;

            case BSF_UNINITIALISED:
                // Oops.
                DISPDBG((ERRLVL,"ValidateDevice: unitialised error"
                             " - logic problem."));
                pvtssd->ddrval = D3DERR_TOOMANYOPERATIONS;
                break;
            default:
                // Unknown.
                DISPDBG((ERRLVL,"ValidateDevice: unknown "
                             "blend-mode error."));
                pvtssd->ddrval = D3DERR_TOOMANYOPERATIONS;
                break;
        }

        pvtssd->dwNumPasses = 1;
        DBG_CB_EXIT(D3DValidateDeviceP3, pvtssd->ddrval);  
        return ( DDHAL_DRIVER_HANDLED );
    }

} // D3DValidateDeviceP3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dcntxt.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dcntxt.c
*
* Content: Main context callbacks for D3D
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#if W95_DDRAW
#include <dmemmgr.h>
#endif
#include "dma.h"
#include "tag.h"

//-----------------------------------------------------------------------------
// ****************************************************************************
// *********************** D3D Context handle management **********************
// ****************************************************************************
//-----------------------------------------------------------------------------
// Here we abstract the managment of context structures. If you wish to modify
// the way these are managed, this is the place to perform the modification
//-----------------------------------------------------------------------------

// Maximum simultaneous number of contexts we can keep track of
#define MAX_CONTEXT_NUM 200

// Since these variables are global they are forced 
// into shared data segment by the build.
P3_D3DCONTEXT*  g_D3DContextSlots[MAX_CONTEXT_NUM] = {NULL};
BOOL g_D3DInitialised = FALSE;

//-----------------------------------------------------------------------------
//
// _D3D_CTX_HandleInitialization
//
// Initialize the handle data structures (array) . Be careful not to initialize
// it twice (between mode changes for example) as this info has to be persistent
//-----------------------------------------------------------------------------
VOID _D3D_CTX_HandleInitialization(VOID)
{
    DWORD i;
    
    // Do only the first time the driver is loaded.
    if (g_D3DInitialised == FALSE)
    {
        // Clear the contexts. Since this is done only once, lets do it right,
        // rather than just clearing with a memset(g_D3DContextSlots,0,size);
        for (i = 0; i < MAX_CONTEXT_NUM; i++)
        {
            g_D3DContextSlots[i] = NULL;
        }        

        // This will assure we only initialize the data once
        g_D3DInitialised = TRUE;
    }
} // _D3D_CTX_HandleInitialization

//-----------------------------------------------------------------------------
// __CTX_NewHandle
//
// Returns a valid context handle number to use in all D3D callbacks and ready
// to be associated with a P3_D3DCONTEXT structure
//-----------------------------------------------------------------------------
DWORD __CTX_NewHandle(VOID)
{
    DWORD dwSlotNum;
    
    // Find an empty slot.
    for (dwSlotNum = 1; dwSlotNum < MAX_CONTEXT_NUM; dwSlotNum++)
    {
        if (g_D3DContextSlots[dwSlotNum] == NULL)
        {
            return dwSlotNum;
        }
    }

    DISPDBG((WRNLVL,"WARN:No empty context slots left"));
    return 0; // no empty slots left, check for this return value!
} // __CTX_NewHandle

//-----------------------------------------------------------------------------
// __CTX_AssocPtrToHandle
//
// Associate a pointer (to a P3_D3DCONTEXT) with this context handle
//-----------------------------------------------------------------------------
VOID __CTX_AssocPtrToHandle(DWORD hHandle,P3_D3DCONTEXT* pContext)
{
    ASSERTDD(hHandle < MAX_CONTEXT_NUM,
             "Accessing g_D3DContextSlots out of bounds");
             
    g_D3DContextSlots[hHandle] = pContext;        
} // __CTX_AssocPtrToHandle


//-----------------------------------------------------------------------------
// _D3D_CTX_HandleToPtr
//
// Returns the pointer associated to this context handle
//-----------------------------------------------------------------------------
P3_D3DCONTEXT* 
_D3D_CTX_HandleToPtr(ULONG_PTR hHandle)
{
    return g_D3DContextSlots[(DWORD)(hHandle)];
} // _D3D_CTX_HandleToPtr

//-----------------------------------------------------------------------------
// __CTX_HandleRelease
//
// This marks the handle number as "free" so it can be reused again when 
// a new D3D context is created
//-----------------------------------------------------------------------------
VOID __CTX_HandleRelease(DWORD hHandle)
{
    ASSERTDD(hHandle < MAX_CONTEXT_NUM,
             "Accessing g_D3DContextSlots out of bounds");
             
    g_D3DContextSlots[hHandle] = NULL;
} // __CTX_HandleRelease

//-----------------------------------------------------------------------------
// ****************************************************************************
// ***********Hardware specific context and state initial setup ***************
// ****************************************************************************
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// __CTX_CleanDirect3DContext
//
// After it has been decided that a context is indeed still active
// and is being freed, this function walks along cleaning everything
// up.  Note it can be called either as a result of a D3DContextDestroy,
// or as a result of the app exiting without freeing the context, or
// as the result of an error whilst creating the context.
// 
//-----------------------------------------------------------------------------
VOID 
__CTX_CleanDirect3DContext(
    P3_D3DCONTEXT* pContext)
{
    P3_THUNKEDDATA *pThisDisplay = pContext->pThisDisplay;

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
    // Free any antialiasing buffer we might have left around in vidmem
    if (pContext->dwAliasBackBuffer != 0)
    {
        _DX_LIN_FreeLinearMemory(&pThisDisplay->LocalVideoHeap0Info, 
                                 pContext->dwAliasBackBuffer);
        pContext->dwAliasBackBuffer = 0;
        pContext->dwAliasPixelOffset = 0;
    }

    if (pContext->dwAliasZBuffer != 0)
    {
        _DX_LIN_FreeLinearMemory(&pThisDisplay->LocalVideoHeap0Info, 
                                 pContext->dwAliasZBuffer);
        pContext->dwAliasZBuffer = 0;
        pContext->dwAliasZPixelOffset = 0;
    }
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS

//@@BEGIN_DDKSPLIT
#if DX7_VIDMEM_VB
    // Free up the useful DrawPrim buffers.
    // Yes, these are device-global rather than per-context, but that's fine
    // since whenever they are used, a macro checks to see if they are big
    // enough and if not re-allocates them. The data does not need to
    // survive across calls.
    // I'm doing the free here instead of end-of-driver-day because there
    // is no elegant place to do it then.
    if ( (void *)pThisDisplay->DrawPrimIndexBufferMem != NULL )
    {
        ASSERTDD ( pThisDisplay->DrawPrimIndexBufferMemSize > 0, 
                   "** D3DContextDestroy - DrawPrimIndexBufferMemSize "
                   "negative or zero, but memory pointer not NULL" );
        HEAP_FREE ( (void *)pThisDisplay->DrawPrimIndexBufferMem );
        pThisDisplay->DrawPrimIndexBufferMem = (ULONG_PTR)NULL;
        pThisDisplay->DrawPrimIndexBufferMemSize = 0;
    }
    else
    {
        ASSERTDD ( pThisDisplay->DrawPrimIndexBufferMemSize == 0, 
                   "** D3DContextDestroy - DrawPrimIndexBufferMemSize "
                   "not zero, but memory pointer is NULL" );
        pThisDisplay->DrawPrimIndexBufferMemSize = 0;
    }

    if ( (void *)pThisDisplay->DrawPrimVertexBufferMem != NULL )
    {
        ASSERTDD ( pThisDisplay->DrawPrimVertexBufferMemSize > 0, 
                   "** D3DContextDestroy - DrawPrimVertexBufferMemSize "
                   "negative or zero, but memory pointer not NULL" );
        HEAP_FREE ( (void *)pThisDisplay->DrawPrimVertexBufferMem );
        pThisDisplay->DrawPrimVertexBufferMem = (ULONG_PTR)NULL;
        pThisDisplay->DrawPrimVertexBufferMemSize = 0;
    }
    else
    {
        ASSERTDD ( pThisDisplay->DrawPrimVertexBufferMemSize == 0, 
                   "** D3DContextDestroy - DrawPrimVertexBufferMemSize "
                   "not zero, but memory pointer is NULL" );
        pThisDisplay->DrawPrimVertexBufferMemSize = 0;
    }
#endif DX7_VIDMEM_VB    
//@@END_DDKSPLIT

#if DX7_D3DSTATEBLOCKS
    // Free up any remaining state sets
    _D3D_SB_DeleteAllStateSets(pContext);
#endif //DX7_D3DSTATEBLOCKS
    
#if DX7_PALETTETEXTURE
    // Destroy the per context palette pointer array
    if (pContext->pPalettePointerArray) 
    {
        PA_DestroyArray(pContext->pPalettePointerArray, NULL);
    }
#endif
    
} // __CTX_CleanDirect3DContext()



//-----------------------------------------------------------------------------
//
// __CTX_Perm3_DisableUnits
//
// Disables all the mode registers to give us a clean start.
//
//-----------------------------------------------------------------------------
static VOID 
__CTX_Perm3_DisableUnits(
    P3_D3DCONTEXT* pContext)
{
    P3_THUNKEDDATA *pThisDisplay = pContext->pThisDisplay;
    P3_DMA_DEFS();

    P3_DMA_GET_BUFFER();

    P3_ENSURE_DX_SPACE(128);

    WAIT_FIFO(32);
    SEND_P3_DATA(RasterizerMode,       __PERMEDIA_DISABLE);
    SEND_P3_DATA(AreaStippleMode,      __PERMEDIA_DISABLE);
    SEND_P3_DATA(LineStippleMode,      __PERMEDIA_DISABLE);
    SEND_P3_DATA(ScissorMode,          __PERMEDIA_DISABLE);
    SEND_P3_DATA(DepthMode,            __PERMEDIA_DISABLE);
    SEND_P3_DATA(ColorDDAMode,         __PERMEDIA_DISABLE);
    SEND_P3_DATA(FogMode,              __PERMEDIA_DISABLE);
    SEND_P3_DATA(AntialiasMode,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(AlphaTestMode,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(LBReadMode,           __PERMEDIA_DISABLE);
    SEND_P3_DATA(Window,               __PERMEDIA_DISABLE);
    SEND_P3_DATA(StencilMode,          __PERMEDIA_DISABLE);
    SEND_P3_DATA(LBWriteMode,          __PERMEDIA_DISABLE);
    SEND_P3_DATA(FBReadMode,           __PERMEDIA_DISABLE);
    SEND_P3_DATA(PatternRAMMode,       __PERMEDIA_DISABLE);

    WAIT_FIFO(18);
    SEND_P3_DATA(DitherMode,           __PERMEDIA_DISABLE);
    SEND_P3_DATA(AlphaBlendMode,       __PERMEDIA_DISABLE);
    SEND_P3_DATA(LogicalOpMode,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(FBWriteMode,          __PERMEDIA_DISABLE);
    SEND_P3_DATA(StatisticMode,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(PixelSize,            __PERMEDIA_DISABLE);
    SEND_P3_DATA(FBSourceData,         __PERMEDIA_DISABLE);
    SEND_P3_DATA(LBWriteFormat,        __PERMEDIA_DISABLE);

    WAIT_FIFO(32);
    

    SEND_P3_DATA(TextureReadMode,   __PERMEDIA_DISABLE);
    SEND_P3_DATA(TextureCoordMode,  __PERMEDIA_DISABLE);

    SEND_P3_DATA(ChromaTestMode,    __PERMEDIA_DISABLE);
    SEND_P3_DATA(FilterMode,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(LUTTransfer,       __PERMEDIA_DISABLE);
    SEND_P3_DATA(LUTIndex,          __PERMEDIA_DISABLE);
    SEND_P3_DATA(LUTAddress,        __PERMEDIA_DISABLE);
    SEND_P3_DATA(LUTMode,           __PERMEDIA_DISABLE);

    if (TLCHIP_GAMMA)
    {
        WAIT_FIFO(32);
        SEND_P3_DATA(Light0Mode, 0);
        SEND_P3_DATA(Light1Mode, 0);       
        SEND_P3_DATA(Light2Mode, 0);
        SEND_P3_DATA(Light3Mode, 0);       
        SEND_P3_DATA(Light4Mode, 0);
        SEND_P3_DATA(Light5Mode, 0);       
        SEND_P3_DATA(Light6Mode, 0);
        SEND_P3_DATA(Light7Mode, 0);  
        SEND_P3_DATA(Light8Mode, 0);
        SEND_P3_DATA(Light9Mode, 0);       
        SEND_P3_DATA(Light10Mode, 0);
        SEND_P3_DATA(Light11Mode, 0);  
        SEND_P3_DATA(Light12Mode, 0);
        SEND_P3_DATA(Light13Mode, 0);       
        SEND_P3_DATA(Light14Mode, 0);
        SEND_P3_DATA(Light15Mode, 0);          

        WAIT_FIFO(32);
        SEND_P3_DATA(TransformMode, 0);
        SEND_P3_DATA(MaterialMode, 0);
        SEND_P3_DATA(GeometryMode, 0);
        SEND_P3_DATA(LightingMode, 0);
        SEND_P3_DATA(ColorMaterialMode, 0);
        SEND_P3_DATA(NormaliseMode, 0);
        SEND_P3_DATA(LineMode, 0);
        SEND_P3_DATA(TriangleMode, 0);
    }

    P3_DMA_COMMIT_BUFFER();
} // __CTX_Perm3_DisableUnits

//-----------------------------------------------------------------------------
//
// __CTX_Perm3_SetupD3D_HWDefaults
//
// Sets up the initial value of registers for this D3D context. This is done
// within the current chip context (D3D_OPERATION) so that when we return to
// it from DD or GDI we get the correct register values restored
// 
//-----------------------------------------------------------------------------
void 
__CTX_Perm3_SetupD3D_HWDefaults(
    P3_D3DCONTEXT* pContext)
{
    P3_SOFTWARECOPY* pSoftP3RX = &pContext->SoftCopyGlint;
    P3_THUNKEDDATA *pThisDisplay = pContext->pThisDisplay;

    P3_DMA_DEFS();

    // Make sure we our working within the right chip-regs context
    D3D_OPERATION(pContext, pThisDisplay);

    // Initially turn off all hardware units. 
    // We will turn on back whatever units are needed.
    __CTX_Perm3_DisableUnits(pContext);

    // Set up VertexControl register in HostIn unit.
    pSoftP3RX->P3RX_P3VertexControl.Size = 1;
    pSoftP3RX->P3RX_P3VertexControl.Flat = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RX_P3VertexControl.ReadAll = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RX_P3VertexControl.SkipFlags = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RX_P3VertexControl.CacheEnable = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RX_P3VertexControl.OGL = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RX_P3VertexControl.Line2D = __PERMEDIA_DISABLE;

    // Constant LBReadMode setup
    pSoftP3RX->LBReadMode.WindowOrigin = __GLINT_TOP_LEFT_WINDOW_ORIGIN;                // Top left
    pSoftP3RX->LBReadMode.DataType = __GLINT_LBDEFAULT;     // default
    pSoftP3RX->LBReadMode.ReadSourceEnable = __PERMEDIA_DISABLE;
    pSoftP3RX->LBReadMode.ReadDestinationEnable = __PERMEDIA_DISABLE;

    // Constant DitherMode setup
    pSoftP3RX->DitherMode.ColorOrder = COLOR_MODE;
    pSoftP3RX->DitherMode.XOffset = DITHER_XOFFSET;
    pSoftP3RX->DitherMode.YOffset = DITHER_YOFFSET;
    pSoftP3RX->DitherMode.UnitEnable = __PERMEDIA_ENABLE;

    // Alpha Blend Mode Setup
    pSoftP3RX->P3RXAlphaBlendColorMode.Enable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = 0;
    pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = 0;
    pSoftP3RX->P3RXAlphaBlendColorMode.SourceTimesTwo = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendColorMode.DestTimesTwo = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendColorMode.InvertSource = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendColorMode.InvertDest = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendColorMode.ColorFormat = P3RX_ALPHABLENDMODE_COLORFORMAT_8888;
    pSoftP3RX->P3RXAlphaBlendColorMode.ColorOrder = COLOR_MODE;
    pSoftP3RX->P3RXAlphaBlendColorMode.ColorConversion = P3RX_ALPHABLENDMODE_CONVERT_SHIFT;
    pSoftP3RX->P3RXAlphaBlendColorMode.ConstantSource = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendColorMode.ConstantDest = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendColorMode.Operation = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendColorMode.SwapSD = __PERMEDIA_DISABLE;

    pSoftP3RX->P3RXAlphaBlendAlphaMode.Enable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = 0;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = 0;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceTimesTwo = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.DestTimesTwo = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.InvertSource = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.InvertDest = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.NoAlphaBuffer = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.AlphaType = 0; // Use GL Blend modes
    pSoftP3RX->P3RXAlphaBlendAlphaMode.AlphaConversion = P3RX_ALPHABLENDMODE_CONVERT_SCALE;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.ConstantSource = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.ConstantDest = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaBlendAlphaMode.Operation = __PERMEDIA_DISABLE;
    DIRTY_ALPHABLEND(pContext);
    
    // Local Buffer Read format bits that don't change
    pSoftP3RX->P3RXLBReadFormat.GIDPosition = 0; 
    pSoftP3RX->P3RXLBReadFormat.GIDWidth = 0;                   // No GID
    pSoftP3RX->P3RXLBReadFormat.StencilPosition = 0;
    pSoftP3RX->P3RXLBReadFormat.StencilWidth = 0;               // No Stencil

    pSoftP3RX->P3RXLBWriteFormat.GIDPosition = 0; 
    pSoftP3RX->P3RXLBWriteFormat.GIDWidth = 0;                  // No GID
    pSoftP3RX->P3RXLBWriteFormat.StencilPosition = 0;
    pSoftP3RX->P3RXLBWriteFormat.StencilWidth = 0;              // No Stencil

    // Never do a source read operation
    pSoftP3RX->P3RXLBSourceReadMode.Enable = 0;
    pSoftP3RX->P3RXLBSourceReadMode.Origin = 0;
    pSoftP3RX->P3RXLBSourceReadMode.StripeHeight = 0;
    pSoftP3RX->P3RXLBSourceReadMode.StripePitch = 0;
    pSoftP3RX->P3RXLBSourceReadMode.PrefetchEnable = 0;

    // Default is to read the Z Buffer
    pSoftP3RX->P3RXLBDestReadMode.Enable = 1;
    pSoftP3RX->P3RXLBDestReadMode.Origin = 0;
    pSoftP3RX->P3RXLBDestReadMode.StripeHeight = 0;
    pSoftP3RX->P3RXLBDestReadMode.StripePitch = 0;
    pSoftP3RX->P3RXLBDestReadMode.PrefetchEnable = 0;

    // Local Buffer Write mode
    pSoftP3RX->P3RXLBWriteMode.WriteEnable = __PERMEDIA_ENABLE;    // Initially allow LB Writes
    pSoftP3RX->P3RXLBWriteMode.StripeHeight = 0;
    pSoftP3RX->P3RXLBWriteMode.StripePitch = 0;
    pSoftP3RX->P3RXLBWriteMode.Origin = __GLINT_TOP_LEFT_WINDOW_ORIGIN;
    pSoftP3RX->P3RXLBWriteMode.Operation = __PERMEDIA_DISABLE;

    // Frame Buffer WriteMode
    pSoftP3RX->P3RXFBWriteMode.WriteEnable = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RXFBWriteMode.Replicate = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXFBWriteMode.OpaqueSpan = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXFBWriteMode.StripePitch = P3RX_STRIPE_1;
    pSoftP3RX->P3RXFBWriteMode.StripeHeight = P3RX_STRIPE_1;
    pSoftP3RX->P3RXFBWriteMode.Enable0 = __PERMEDIA_ENABLE;

    // FB Destination reads
    pSoftP3RX->P3RXFBDestReadMode.ReadEnable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXFBDestReadMode.Enable0 = __PERMEDIA_ENABLE;

    // FB Source reads
    pSoftP3RX->P3RXFBSourceReadMode.ReadEnable = __PERMEDIA_DISABLE;

    // Depth comparisons
    pSoftP3RX->P3RXDepthMode.WriteMask = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RXDepthMode.CompareMode = __GLINT_DEPTH_COMPARE_MODE_ALWAYS;
    pSoftP3RX->P3RXDepthMode.NewDepthSource = __GLINT_DEPTH_SOURCE_DDA;
    pSoftP3RX->P3RXDepthMode.Enable = __PERMEDIA_DISABLE;

#define NLZ 0
#if NLZ
    pSoftP3RX->P3RXDepthMode.Normalise = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXDepthMode.NonLinearZ = __PERMEDIA_ENABLE;
#else
    pSoftP3RX->P3RXDepthMode.Normalise = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RXDepthMode.NonLinearZ = __PERMEDIA_DISABLE;
#endif
    pSoftP3RX->P3RXDepthMode.ExponentScale = 2;
    pSoftP3RX->P3RXDepthMode.ExponentWidth = 1;

    // Only setup to write to the chip after the above call, as 
    // we may upset the DMA buffer setup.
    P3_DMA_GET_BUFFER_ENTRIES(20);

    // Window Region data
    SEND_P3_DATA(FBSourceOffset, 0x0);

    // Write Masks
    SEND_P3_DATA(FBSoftwareWriteMask, __GLINT_ALL_WRITEMASKS_SET);
    SEND_P3_DATA(FBHardwareWriteMask, __GLINT_ALL_WRITEMASKS_SET);

    // Host out unit
    SEND_P3_DATA(FilterMode,    __PERMEDIA_DISABLE);
    SEND_P3_DATA(StatisticMode, __PERMEDIA_DISABLE);   // Disable Stats

    // Local Buffer
    SEND_P3_DATA(LBSourceOffset, 0);                   

    // Window setups
    SEND_P3_DATA(WindowOrigin, __GLINT_TOP_LEFT_WINDOW_ORIGIN);
    SEND_P3_DATA(FBWindowBase, 0x0);

    SEND_P3_DATA(RasterizerMode, 0);

    // Setup a step of -1, as this doesn't change very much
    SEND_P3_DATA(dY, 0xFFFF0000);

    P3_DMA_COMMIT_BUFFER();

    P3_DMA_GET_BUFFER_ENTRIES(16);

    // Stencil mode setup
    pSoftP3RX->P3RXStencilMode.StencilWidth = 0;
    pSoftP3RX->P3RXStencilMode.DPFail = __GLINT_STENCIL_METHOD_KEEP;
    pSoftP3RX->P3RXStencilMode.DPPass = __GLINT_STENCIL_METHOD_KEEP;
    pSoftP3RX->P3RXStencilMode.Enable = __PERMEDIA_DISABLE;
    COPY_P3_DATA(StencilMode, pSoftP3RX->P3RXStencilMode);

    pSoftP3RX->P3RXFogMode.Enable = __PERMEDIA_ENABLE; // Qualified by the render command
    pSoftP3RX->P3RXFogMode.ColorMode = P3RX_FOGMODE_COLORMODE_RGB; // RGBA
    pSoftP3RX->P3RXFogMode.Table = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXFogMode.UseZ = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXFogMode.ZShift = 23; // Take the top 8 bits of the z value
    pSoftP3RX->P3RXFogMode.InvertFI = __PERMEDIA_DISABLE;
    DIRTY_FOG(pContext);

    pSoftP3RX->P3RXWindow.Enable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXWindow.CompareMode = 0;
    pSoftP3RX->P3RXWindow.ForceLBUpdate = 0;
    pSoftP3RX->P3RXWindow.LBUpdateSource = 0;
    pSoftP3RX->P3RXWindow.GID = 0;
    pSoftP3RX->P3RXWindow.FrameCount = 0;
    pSoftP3RX->P3RXWindow.StencilFCP = 0;
    pSoftP3RX->P3RXWindow.DepthFCP = 0;
    COPY_P3_DATA(Window, pSoftP3RX->P3RXWindow);

    SEND_P3_DATA(ChromaUpper, 0x00000000);
    SEND_P3_DATA(ChromaLower, 0x00000000);

    // Use a black border for the bilinear filter.
    // This will only work for certain types of texture...
    SEND_P3_DATA(BorderColor0, 0x0);
    SEND_P3_DATA(BorderColor1, 0x0);

    // Alpha Test - later we'll DIRTY_EVERYTHING
    pSoftP3RX->P3RXAlphaTestMode.Enable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXAlphaTestMode.Reference = 0x0;
    pSoftP3RX->P3RXAlphaTestMode.Compare = __GLINT_ALPHA_COMPARE_MODE_ALWAYS;

    SEND_P3_DATA(AreaStippleMode, (1 | (2 << 1) | (2 << 4)));

    pSoftP3RX->P3RX_P3DeltaMode.TargetChip = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RX_P3DeltaMode.SpecularTextureEnable = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RX_P3DeltaMode.TextureParameterMode = 2; // Normalise
    pSoftP3RX->P3RX_P3DeltaMode.TextureEnable = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RX_P3DeltaMode.DiffuseTextureEnable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RX_P3DeltaMode.SmoothShadingEnable = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RX_P3DeltaMode.SubPixelCorrectionEnable = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RX_P3DeltaMode.DiamondExit = __PERMEDIA_ENABLE;

#if 1
    pSoftP3RX->P3RX_P3DeltaMode.NoDraw = __PERMEDIA_DISABLE;
#else
    pSoftP3RX->P3RX_P3DeltaMode.NoDraw = __PERMEDIA_ENABLE;
#endif

    pSoftP3RX->P3RX_P3DeltaMode.ClampEnable = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RX_P3DeltaMode.FillDirection = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RX_P3DeltaMode.DepthFormat = 3;    // Always 32 bits
    pSoftP3RX->P3RX_P3DeltaMode.ColorOrder = COLOR_MODE;
    pSoftP3RX->P3RX_P3DeltaMode.BiasCoordinates = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RX_P3DeltaMode.Texture3DEnable = __PERMEDIA_DISABLE; // Always perspective correct (q is 1 otherwise)
    pSoftP3RX->P3RX_P3DeltaMode.TextureEnable1 = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RX_P3DeltaMode.DepthEnable = __PERMEDIA_ENABLE;
    COPY_P3_DATA(DeltaMode, pSoftP3RX->P3RX_P3DeltaMode);

    P3_DMA_COMMIT_BUFFER();

    P3_DMA_GET_BUFFER_ENTRIES(18);
    
    {
        float ZBias;
            
        pContext->XBias = 0.5f;
        pContext->YBias = 0.5f;

        ZBias = 0.0f;
        SEND_P3_DATA(XBias, *(DWORD*)&pContext->XBias);
        SEND_P3_DATA(YBias, *(DWORD*)&pContext->YBias);
        SEND_P3_DATA(ZBias, *(DWORD*)&ZBias);
    }

    pSoftP3RX->P3RX_P3DeltaControl.FullScreenAA = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RX_P3DeltaControl.DrawLineEndPoint = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RX_P3DeltaControl.UseProvokingVertex = __PERMEDIA_DISABLE;
    COPY_P3_DATA(DeltaControl, pSoftP3RX->P3RX_P3DeltaControl);
    
    pSoftP3RX->P3RXTextureCoordMode.Enable = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RXTextureCoordMode.WrapS = __GLINT_TEXADDRESS_WRAP_REPEAT;
    pSoftP3RX->P3RXTextureCoordMode.WrapT = __GLINT_TEXADDRESS_WRAP_REPEAT;
    pSoftP3RX->P3RXTextureCoordMode.Operation = __GLINT_TEXADDRESS_OPERATION_3D; // Perspective correct
    pSoftP3RX->P3RXTextureCoordMode.InhibitDDAInitialisation = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureCoordMode.EnableLOD = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureCoordMode.EnableDY = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureCoordMode.TextureMapType = __GLINT_TEXADDRESS_TEXMAP_2D;  // Always 2D
    pSoftP3RX->P3RXTextureCoordMode.DuplicateCoord = __PERMEDIA_DISABLE;
    COPY_P3_DATA(TextureCoordMode, pSoftP3RX->P3RXTextureCoordMode);

    pSoftP3RX->P3RXTextureReadMode0.Enable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureReadMode0.Width = log2(256);
    pSoftP3RX->P3RXTextureReadMode0.Height = log2(256);
    pSoftP3RX->P3RXTextureReadMode0.TexelSize = P3RX_TEXREADMODE_TEXELSIZE_16;  // Pixel depth
    pSoftP3RX->P3RXTextureReadMode0.Texture3D = __PERMEDIA_DISABLE;    // 3D Texture coordinates
    pSoftP3RX->P3RXTextureReadMode0.CombineCaches = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureReadMode0.MapBaseLevel = 0;
    pSoftP3RX->P3RXTextureReadMode0.MapMaxLevel = 0;
    pSoftP3RX->P3RXTextureReadMode0.LogicalTexture = 0;
    pSoftP3RX->P3RXTextureReadMode0.Origin = __GLINT_TOP_LEFT_WINDOW_ORIGIN;
    pSoftP3RX->P3RXTextureReadMode0.TextureType = P3RX_TEXREADMODE_TEXTURETYPE_NORMAL;
    pSoftP3RX->P3RXTextureReadMode0.ByteSwap = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureReadMode0.Mirror = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureReadMode0.Invert = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureReadMode0.OpaqueSpan = __PERMEDIA_DISABLE;
    COPY_P3_DATA(TextureReadMode0, pSoftP3RX->P3RXTextureReadMode0);

    pSoftP3RX->P3RXTextureReadMode1.Enable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureReadMode1.Width = log2(256);
    pSoftP3RX->P3RXTextureReadMode1.Height = log2(256);
    pSoftP3RX->P3RXTextureReadMode1.TexelSize = P3RX_TEXREADMODE_TEXELSIZE_16;  // Pixel depth
    pSoftP3RX->P3RXTextureReadMode1.Texture3D = __PERMEDIA_DISABLE;    // 3D Texture coordinates
    pSoftP3RX->P3RXTextureReadMode1.CombineCaches = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureReadMode1.MapBaseLevel = 0;
    pSoftP3RX->P3RXTextureReadMode1.MapMaxLevel = 0;
    pSoftP3RX->P3RXTextureReadMode1.LogicalTexture = 0;
    pSoftP3RX->P3RXTextureReadMode1.Origin = __GLINT_TOP_LEFT_WINDOW_ORIGIN;
    pSoftP3RX->P3RXTextureReadMode1.TextureType = P3RX_TEXREADMODE_TEXTURETYPE_NORMAL;
    pSoftP3RX->P3RXTextureReadMode1.ByteSwap = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureReadMode1.Mirror = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureReadMode1.Invert = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureReadMode1.OpaqueSpan = __PERMEDIA_DISABLE;
    COPY_P3_DATA(TextureReadMode1, pSoftP3RX->P3RXTextureReadMode1);

    pSoftP3RX->P3RXTextureIndexMode0.Enable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureIndexMode0.Width = log2(256);
    pSoftP3RX->P3RXTextureIndexMode0.Height = log2(256);
    pSoftP3RX->P3RXTextureIndexMode0.Border = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureIndexMode0.WrapU = P3RX_TEXINDEXMODE_WRAP_CLAMPEDGE;
    pSoftP3RX->P3RXTextureIndexMode0.WrapV = P3RX_TEXINDEXMODE_WRAP_CLAMPEDGE;
    pSoftP3RX->P3RXTextureIndexMode0.MapType = __GLINT_TEXADDRESS_TEXMAP_2D;
    pSoftP3RX->P3RXTextureIndexMode0.MagnificationFilter = __GLINT_TEXTUREREAD_FILTER_NEAREST;
    pSoftP3RX->P3RXTextureIndexMode0.MinificationFilter = __GLINT_TEXTUREREAD_FILTER_NEAREST;
    pSoftP3RX->P3RXTextureIndexMode0.Texture3DEnable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureIndexMode0.MipMapEnable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureIndexMode0.NearestBias = 1;
    pSoftP3RX->P3RXTextureIndexMode0.LinearBias = 0;
    pSoftP3RX->P3RXTextureIndexMode0.SourceTexelEnable = __PERMEDIA_DISABLE;
    COPY_P3_DATA(TextureIndexMode0, pSoftP3RX->P3RXTextureIndexMode0);

    pSoftP3RX->P3RXTextureIndexMode1.Enable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureIndexMode1.Width = log2(256);
    pSoftP3RX->P3RXTextureIndexMode1.Height = log2(256);
    pSoftP3RX->P3RXTextureIndexMode1.Border = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureIndexMode1.WrapU = P3RX_TEXINDEXMODE_WRAP_CLAMPEDGE;
    pSoftP3RX->P3RXTextureIndexMode1.WrapV = P3RX_TEXINDEXMODE_WRAP_CLAMPEDGE;
    pSoftP3RX->P3RXTextureIndexMode1.MapType = __GLINT_TEXADDRESS_TEXMAP_2D;
    pSoftP3RX->P3RXTextureIndexMode1.MagnificationFilter = __GLINT_TEXTUREREAD_FILTER_NEAREST;
    pSoftP3RX->P3RXTextureIndexMode1.MinificationFilter = __GLINT_TEXTUREREAD_FILTER_NEAREST;
    pSoftP3RX->P3RXTextureIndexMode1.Texture3DEnable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureIndexMode1.MipMapEnable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureIndexMode1.NearestBias = 1;
    pSoftP3RX->P3RXTextureIndexMode1.LinearBias = 0;
    pSoftP3RX->P3RXTextureIndexMode1.SourceTexelEnable = __PERMEDIA_DISABLE;
    COPY_P3_DATA(TextureIndexMode1, pSoftP3RX->P3RXTextureIndexMode1);

    pSoftP3RX->P3RXTextureCompositeColorMode0.Enable = 0;
    pSoftP3RX->P3RXTextureCompositeColorMode0.Scale = 1;

    pSoftP3RX->P3RXTextureCompositeColorMode1.Enable = 0;
    pSoftP3RX->P3RXTextureCompositeColorMode1.Scale = 1;

    pSoftP3RX->P3RXTextureCompositeAlphaMode0.Enable = 0;
    pSoftP3RX->P3RXTextureCompositeAlphaMode0.Scale = 1;

    pSoftP3RX->P3RXTextureCompositeAlphaMode1.Enable = 0;
    pSoftP3RX->P3RXTextureCompositeAlphaMode1.Scale = 1;

    P3_DMA_COMMIT_BUFFER();

    P3_DMA_GET_BUFFER_ENTRIES(16);
    
    COPY_P3_DATA(TextureCompositeColorMode0, pSoftP3RX->P3RXTextureCompositeColorMode0);
    COPY_P3_DATA(TextureCompositeColorMode1, pSoftP3RX->P3RXTextureCompositeColorMode1);
    COPY_P3_DATA(TextureCompositeAlphaMode0, pSoftP3RX->P3RXTextureCompositeAlphaMode0);
    COPY_P3_DATA(TextureCompositeAlphaMode1, pSoftP3RX->P3RXTextureCompositeAlphaMode1);

    // Set up the TC TFACTOR defaults.
    SEND_P3_DATA(TextureCompositeFactor0, 0);
    SEND_P3_DATA(TextureCompositeFactor1, 0);

    SEND_P3_DATA(TextureCacheReplacementMode, 0 );

    P3_DMA_COMMIT_BUFFER();

    P3_DMA_GET_BUFFER_ENTRIES(24);
    
    // Used for 3D Texture-maps
    SEND_P3_DATA(TextureMapSize, 0);

    SEND_P3_DATA(TextureLODBiasS, 0);
    SEND_P3_DATA(TextureLODBiasT, 0);

    {
        float f = 1.0f;
        COPY_P3_DATA(TextureLODScale, f);
        COPY_P3_DATA(TextureLODScale1, f);
    }    

    P3RX_INVALIDATECACHE(__PERMEDIA_ENABLE, __PERMEDIA_ENABLE);
    
    pSoftP3RX->P3RXTextureApplicationMode.Enable = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RXTextureApplicationMode.EnableKs = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureApplicationMode.EnableKd = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureApplicationMode.MotionCompEnable = __PERMEDIA_DISABLE;
    
    // Put the texture application unit in pass-through
    pSoftP3RX->P3RXTextureApplicationMode.ColorA = 0;
    pSoftP3RX->P3RXTextureApplicationMode.ColorB = P3RX_TEXAPP_B_TC;
    pSoftP3RX->P3RXTextureApplicationMode.ColorI = 0;
    pSoftP3RX->P3RXTextureApplicationMode.ColorInvertI = 0;
    pSoftP3RX->P3RXTextureApplicationMode.ColorOperation = P3RX_TEXAPP_OPERATION_PASS_B;
    pSoftP3RX->P3RXTextureApplicationMode.AlphaA = 0;
    pSoftP3RX->P3RXTextureApplicationMode.AlphaB = P3RX_TEXAPP_B_TA;
    pSoftP3RX->P3RXTextureApplicationMode.AlphaI = 0;
    pSoftP3RX->P3RXTextureApplicationMode.AlphaInvertI = 0;
    pSoftP3RX->P3RXTextureApplicationMode.AlphaOperation = P3RX_TEXAPP_OPERATION_PASS_B;
    COPY_P3_DATA(TextureApplicationMode, pSoftP3RX->P3RXTextureApplicationMode);

    // Set up the TA TFACTOR default.
    SEND_P3_DATA(TextureEnvColor, 0);
        
    // Turn on texture cache and invalidate it.
    SEND_P3_DATA(TextureCacheControl, 3);
        
    P3_DMA_COMMIT_BUFFER();

    P3_DMA_GET_BUFFER_ENTRIES(16);

    //pGlint->TextureMask = 0;
    SEND_P3_DATA(TextureBaseAddr0, 0);
    SEND_P3_DATA(TextureBaseAddr1, 0);

    pSoftP3RX->P3RXChromaTestMode.Enable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXChromaTestMode.Source = __GLINT_CHROMA_FBSOURCE ;
    COPY_P3_DATA(ChromaTestMode, pSoftP3RX->P3RXChromaTestMode);

    pSoftP3RX->P3RXTextureFilterMode.Enable = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RXTextureFilterMode.Format0 = 0;
    pSoftP3RX->P3RXTextureFilterMode.ColorOrder0 = COLOR_MODE;
    pSoftP3RX->P3RXTextureFilterMode.AlphaMapEnable0 = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureFilterMode.AlphaMapSense0 = __GLINT_TEXTUREFILTER_ALPHAMAPSENSE_EXCLUDE;
    pSoftP3RX->P3RXTextureFilterMode.CombineCaches = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureFilterMode.Format1 = 0;
    pSoftP3RX->P3RXTextureFilterMode.ColorOrder1 = COLOR_MODE;
    pSoftP3RX->P3RXTextureFilterMode.AlphaMapEnable1 = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureFilterMode.AlphaMapSense1 = __GLINT_TEXTUREFILTER_ALPHAMAPSENSE_EXCLUDE;
    COPY_P3_DATA(TextureFilterMode, pSoftP3RX->P3RXTextureFilterMode);

    pSoftP3RX->P3RXLUTMode.Enable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXLUTMode.InColorOrder = P3RX_LUTMODE_INCOLORORDER_BGR;
    pSoftP3RX->P3RXLUTMode.LoadFormat = P3RX_LUTMODE_LOADFORMAT_COPY;
    pSoftP3RX->P3RXLUTMode.LoadColorOrder = P3RX_LUTMODE_LOADCOLORORDER_RGB;
    pSoftP3RX->P3RXLUTMode.FragmentOperation = P3RX_LUTMODE_FRAGMENTOP_INDEXEDTEXTURE;
    COPY_P3_DATA(LUTMode, pSoftP3RX->P3RXLUTMode);

    pSoftP3RX->P3RXRasterizerMode.D3DRules = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RXRasterizerMode.MultiRXBlit = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXRasterizerMode.OpaqueSpan = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXRasterizerMode.WordPacking = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXRasterizerMode.StripeHeight = 0;
    pSoftP3RX->P3RXRasterizerMode.BitMaskRelative = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXRasterizerMode.YLimitsEnable = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXRasterizerMode.MultiGLINT = __PERMEDIA_ENABLE;
    pSoftP3RX->P3RXRasterizerMode.HostDataByteSwapMode = 0;
    pSoftP3RX->P3RXRasterizerMode.BitMaskOffset = 0;
    pSoftP3RX->P3RXRasterizerMode.BitMaskPacking = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXRasterizerMode.BitMaskByteSwapMode = 0;
    pSoftP3RX->P3RXRasterizerMode.ForceBackgroundColor = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXRasterizerMode.BiasCoordinates = 0;
    pSoftP3RX->P3RXRasterizerMode.FractionAdjust = 0;
    pSoftP3RX->P3RXRasterizerMode.InvertBitMask = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXRasterizerMode.MirrorBitMask = __PERMEDIA_DISABLE;
    COPY_P3_DATA(RasterizerMode, pSoftP3RX->P3RXRasterizerMode);

    pSoftP3RX->P3RXScanlineOwnership.Mask = 0;
    pSoftP3RX->P3RXScanlineOwnership.MyId = 0;
    COPY_P3_DATA(ScanlineOwnership, pSoftP3RX->P3RXScanlineOwnership);
         
    P3_DMA_COMMIT_BUFFER();
    
} // __CTX_Perm3_SetupD3D_HWDefaults


//-----------------------------------------------------------------------------
//
// __CTX_SetupD3DContext_Defaults
//
// Initializes our private D3D context data (renderstates, TSS and other).
// 
//-----------------------------------------------------------------------------
void
__CTX_SetupD3DContext_Defaults(
    P3_D3DCONTEXT* pContext)
{   
    DWORD dwStageNum;
    
    // Set all the stages to 'unused' and disabled
    for (dwStageNum = 0; dwStageNum < D3DHAL_TSS_MAXSTAGES; dwStageNum++)
    {
        pContext->iTexStage[dwStageNum] = -1;
        pContext->TextureStageState[dwStageNum].m_dwVal[D3DTSS_COLOROP] =
                                                                D3DTOP_DISABLE;
    }
        
    // No texture at present. 
    pContext->TextureStageState[TEXSTAGE_0].m_dwVal[D3DTSS_COLOROP] = D3DTOP_DISABLE;
    pContext->TextureStageState[TEXSTAGE_0].m_dwVal[D3DTSS_ALPHAOP] = D3DTOP_DISABLE;

    pContext->TextureStageState[TEXSTAGE_0].m_dwVal[D3DTSS_TEXTUREMAP] = 0;
    pContext->TextureStageState[TEXSTAGE_1].m_dwVal[D3DTSS_TEXTUREMAP] = 0;

    pContext->TextureStageState[TEXSTAGE_0].m_dwVal[D3DTSS_MINFILTER] = D3DTFN_POINT;
    pContext->TextureStageState[TEXSTAGE_1].m_dwVal[D3DTSS_MINFILTER] = D3DTFN_POINT;
    pContext->TextureStageState[TEXSTAGE_0].m_dwVal[D3DTSS_MIPFILTER] = D3DTFN_POINT;
    pContext->TextureStageState[TEXSTAGE_1].m_dwVal[D3DTSS_MIPFILTER] = D3DTFN_POINT;
    pContext->TextureStageState[TEXSTAGE_0].m_dwVal[D3DTSS_MAGFILTER] = D3DTFN_POINT;
    pContext->TextureStageState[TEXSTAGE_1].m_dwVal[D3DTSS_MAGFILTER] = D3DTFN_POINT;

    pContext->eChipBlendStatus = BSF_UNINITIALISED;
    
    // Initially set values to force change of texture
    pContext->bTextureValid = TRUE;
    
    // Defaults states
    pContext->RenderStates[D3DRENDERSTATE_TEXTUREMAPBLEND] = D3DTBLEND_COPY;
    pContext->fRenderStates[D3DRENDERSTATE_FOGTABLESTART] = 0.0f;
    pContext->fRenderStates[D3DRENDERSTATE_FOGTABLEEND] = 1.0f;
    pContext->RenderStates[D3DRENDERSTATE_CULLMODE] = D3DCULL_CCW;
    pContext->RenderStates[D3DRENDERSTATE_PLANEMASK] = 0xFFFFFFFF;
    pContext->RenderStates[D3DRENDERSTATE_LOCALVIEWER] = FALSE;
    pContext->RenderStates[D3DRENDERSTATE_COLORKEYENABLE] = FALSE;    
    
#if DX8_DDI
    // New DX8 D3DRS_COLORWRITEENABLE default = allow write to all channels
    pContext->dwColorWriteHWMask = 0xFFFFFFFF;
    pContext->dwColorWriteSWMask = 0xFFFFFFFF;    
#endif //DX8_DDI  

    // On context creation, no render states are overridden (for legacy intfce's)
    STATESET_INIT(pContext->overrides); 

    // Set default culling state
    SET_CULLING_TO_CCW(pContext);

#if DX7_D3DSTATEBLOCKS
    // Default state block recording mode = no recording
    pContext->bStateRecMode = FALSE;
    pContext->pCurrSS = NULL;
    pContext->pIndexTableSS = NULL;
    pContext->dwMaxSSIndex = 0;
#endif //DX7_D3DSTATEBLOCKS


#if DX8_POINTSPRITES
    // Point sprite defaults
    pContext->PntSprite.bEnabled = FALSE; 
    pContext->PntSprite.fSize = 1.0f;
    pContext->PntSprite.fSizeMin = 1.0f;    
    pContext->PntSprite.fSizeMax = P3_MAX_POINTSPRITE_SIZE;    
#endif //DX8_POINTSPRITES

    // Multistreaming default setup
    pContext->lpVertices = NULL;
    pContext->dwVertexType = 0;
#if DX8_DDI
    pContext->lpIndices = NULL;
    pContext->dwIndicesStride = 0;    
    pContext->dwVerticesStride = 0;
#endif // DX8_DDI    

    //*********************************
    // INTERNAL CONTEXT RENDERING STATE
    //*********************************

    pContext->bKeptStipple  = FALSE;     // By default, stippling off.
    pContext->bCanChromaKey = FALSE;     // Turn Chroma keying off by default

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
    pContext->dwAliasPixelOffset = 0x0;
    pContext->dwAliasZPixelOffset = 0x0;
    pContext->dwAliasZBuffer = 0x0;
    pContext->dwAliasBackBuffer = 0x0;
#if DX8_DDI
    if (pContext->pSurfRenderInt->dwSampling)
    {
        pContext->RenderStates[D3DRS_MULTISAMPLEANTIALIAS] = TRUE;
        pContext->Flags |= SURFACE_ANTIALIAS;
    }
#endif
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS    
 
    // Set texturing on
    pContext->Flags |= SURFACE_TEXTURING; 

    // Initialize the mipmap bias
    pContext->MipMapLODBias[0] = 0.0f;
    pContext->MipMapLODBias[1] = 0.0f;

    // Initialise the RenderCommand.  States will add to this
    pContext->RenderCommand = 0;
    RENDER_SUB_PIXEL_CORRECTION_ENABLE(pContext->RenderCommand);

    // Dirty all states
    DIRTY_EVERYTHING(pContext);

} // __CTX_SetupD3DContext_Defaults

//-----------------------------------------------------------------------------
// ****************************************************************************
// ***************************** D3D HAL Callbacks ****************************
// ****************************************************************************
//-----------------------------------------------------------------------------

//-----------------------------Public Routine----------------------------------
//
// D3DContextCreate
//
// The ContextCreate callback is invoked when a new Direct3D device is being 
// created by a Direct3D application. The driver is required to generate a 
// unique context id for this new context. Direct3D will then use this context 
// id in every subsequent callback invocation for this Direct3D device. 
//
// Context is the current rasterization state. For instance, if there are 3 
// applications running, each will have a different state at any point in time.
// When each one is running, the hardware has to make sure that the context, 
// (whether doing Gouraud shading, for example) is the same as the last time 
// that application got a time slice. 
//
// State is anything that the particular device needs to know per context 
// i.e. what surface is being rendered to, shading, texture, texture handles, 
// what physical surfaces those texture handles represent, etc. The context 
// encapsulates all state for the Direct3D device - state is not shared 
// between contexts. Therefore the driver needs to maintain full state 
// information for each context. This state will be changed by calls to the 
// RenderState callback. In the case of rasterization only hardware, the 
// driver need only maintain rasterization state. As well as state, the driver 
// will also want to store the lpDDS, lpDDSZ, and dwPid from the callback 
// data argument. 
//
// The driver should not create a context handle of zero. This is guaranteed 
// to be an invalid context handle. 
//
// Parameters
//      pccd
//           Pointer to a structure containing things including the current
//           rendering surface, the current Z surface, and the DirectX object
//           handle, etc.
//
//          .lpDDGbl    
//                Points to the DirectDraw structure representing the 
//                DirectDraw object. 
//          .lpDDLcl(replaces lpDDGbl in DX7)    
//                Points to the DirectDraw structure representing the 
//                DirectDraw object. 
//          .lpDDS      
//                This is the surface that is to be used as the rendering 
//                target, i.e., the 3D accelerator sprays its bits at this 
//                surface. 
//          .lpDDSZ     
//                The surface that is to be used as the Z buffer. If this 
//                is NULL, no Z buffering is to be performed. 
//          .dwPid      
//                The process id of the Direct3D application that initiated 
//                the creation of the Direct3D device. 
//          .dwhContext 
//                The driver should place the context ID that it wants Direct3D 
//                to use when communicating with the driver. This should be 
//                unique. 
//          .ddrval     
//                Return code. DD_OK indicates success. 
//
// Return Value
//      Returns one of the following values: 
//                DDHAL_DRIVER_HANDLED  
//                DDHAL_DRIVER_NOTHANDLED   
//
// Notes:
//
// Currently the context isn't locked, so we can't switch in a register context.
// All chip specific setup is therefore saved for the first execute.
// This is guaranteed to have the lock.
// Some chip state is duplicated in the context structure.  This 
// means that a software copy is kept to stop unnecessary changes to 
// the chip state.
// 
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DContextCreate(
    LPD3DHAL_CONTEXTCREATEDATA pccd)
{
    LPDDRAWI_DDRAWSURFACE_LCL lpLclFrame = NULL;
    LPDDRAWI_DDRAWSURFACE_LCL lpLclZ = NULL;
    P3_D3DCONTEXT *pContext;
    P3_THUNKEDDATA *pThisDisplay;
    DWORD Result;
    DWORD dwSlotNum;
    ULONG_PTR dwDXInterface;
    BOOL bRet;

    DBG_CB_ENTRY(D3DContextCreate);

    // Get our pThisDisplay
    GET_THUNKEDDATA(pThisDisplay, pccd->lpDDLcl->lpGbl);

    //***********************************************************************
    // Create a new D3D context driver structure and asssociate an id with it
    //***********************************************************************

    // Find a context empty slot.
    dwSlotNum = __CTX_NewHandle();

    if (dwSlotNum == 0)
    {
        // no context slots left
        pccd->ddrval = D3DHAL_OUTOFCONTEXTS;
        DBG_CB_EXIT(D3DContextCreate,pccd->ddrval);        
        return (DDHAL_DRIVER_HANDLED);
    }

    // Return to the runtime the D3D context id that will be used to
    // identify calls for this context from now on. Store prev value
    // since that tells us which API are we being called from
    // (4=DX8, 3=DX7, 2=DX6, 1=DX5, 0=DX3)
    dwDXInterface = pccd->dwhContext;      // in: DX API version
    pccd->dwhContext = dwSlotNum;          // out: Context handle 

    // Now allocate the driver's d3d context structure in kernel memory.  
    pContext = (P3_D3DCONTEXT*)HEAP_ALLOC(FL_ZERO_MEMORY, 
                                          sizeof(P3_D3DCONTEXT), 
                                          ALLOC_TAG_DX(1));
    
    if (pContext == NULL)
    {
        DISPDBG((ERRLVL,"ERROR: Couldn't allocate Context mem"));
        goto Error_OutOfMem_A;
    }
    else
    {
        DISPDBG((DBGLVL,"Allocated Context Mem - proceeding to clear"));
        memset((void *)pContext, 0, sizeof(P3_D3DCONTEXT));
    }   

    // This context id is now to be associated with this context pointer
    __CTX_AssocPtrToHandle(dwSlotNum, pContext);    

    //*************************************************************************
    //                  Initialize the D3D context structure
    //*************************************************************************

    //*******
    // HEADER
    //*******
    
    // Set up the magic number to perform sanity checks
    pContext->MagicNo = RC_MAGIC_NO;       
    
    // Record the usage of this context handle    
    pContext->dwContextHandle = dwSlotNum;

    // Keep (self) pointers to the structure for destroy time
    pContext->pSelf = pContext;

#if DX8_DDI
    // Remember which DX interface is creating this context 
    // - it will make things much easier later
    pContext->dwDXInterface = dwDXInterface;
#endif // DX8_DDI     

    //**********************
    // GLOBAL DRIVER CONTEXT
    //**********************

    // Remember the card we are running on
    pContext->pThisDisplay = pThisDisplay;

    // On DX7 we need to keep a copy of the local ddraw object
    // for surface handle management
    pContext->pDDLcl = pccd->lpDDLcl;
    pContext->pDDGbl = pccd->lpDDLcl->lpGbl;

    //*******************
    // RENDERING SURFACES
    //*******************

    // On DX7 we extract the local surface pointers directly
    lpLclFrame = pccd->lpDDSLcl;
    
    if (pccd->lpDDSZ)
    {
        lpLclZ = pccd->lpDDSZLcl;
    }

#if DBG
    // Spew debug rendering surfaces data on the debug build
    DISPDBG((DBGLVL,"Allocated Direct3D context: 0x%x",pccd->dwhContext));    
    DISPDBG((DBGLVL,"Driver Struct = %p, Surface = %p",
                    pContext->pDDGbl, lpLclFrame));
    DISPDBG((DBGLVL,"Z Surface = %p",lpLclZ));
    
    if ((DWORD*)lpLclZ != NULL)
    {
        DISPDBG((DBGLVL,"    ZlpGbl: %p", lpLclZ->lpGbl));

        DISPDBG((DBGLVL,"    fpVidMem = %08lx",lpLclZ->lpGbl->fpVidMem));
        DISPDBG((DBGLVL,"    lPitch = %08lx",lpLclZ->lpGbl->lPitch));
        DISPDBG((DBGLVL,"    wHeight = %08lx",lpLclZ->lpGbl->wHeight));
        DISPDBG((DBGLVL,"    wWidth = %08lx",lpLclZ->lpGbl->wWidth));
    }

    DISPDBG((DBGLVL,"Buffer Surface = %p",lpLclFrame));
    if ((DWORD*)lpLclFrame != NULL)
    {
        DISPDBG((DBGLVL,"    fpVidMem = %08lx",lpLclFrame->lpGbl->fpVidMem));
        DISPDBG((DBGLVL,"    lPitch = %08lx",lpLclFrame->lpGbl->lPitch));
        DISPDBG((DBGLVL,"    wHeight = %08lx",lpLclFrame->lpGbl->wHeight));
        DISPDBG((DBGLVL,"    wWidth = %08lx",lpLclFrame->lpGbl->wWidth));
    }
#endif // DBG

#if DX7_TEXMANAGEMENT
    // Initialize texture management for this context
    if(FAILED(_D3D_TM_Ctx_Initialize(pContext)))
    {
        // We failed. Cleanup before we leave
        DISPDBG((ERRLVL,"ERROR: Couldn't initialize Texture Management"));
        goto Error_OutOfMem_B;        
    }
#endif // DX7_TEXMANAGEMENT

    // There may not have been any textures (DD surfaces) created yet through
    // D3DCreateSurfaceEx.  If this is the  case, create a new DD locals hash 
    // entry and fill it will a pointer array
    pContext->pTexturePointerArray = 
            (PointerArray*)HT_GetEntry(pThisDisplay->pDirectDrawLocalsHashTable, 
                                       (ULONG_PTR)pContext->pDDLcl);
    if (!pContext->pTexturePointerArray)
    {
        DISPDBG((DBGLVL,"Creating new pointer array for PDDLcl "
                        "0x%x in ContextCreate", pContext->pDDLcl));

        // Create a pointer array
        pContext->pTexturePointerArray = PA_CreateArray();

        if (!pContext->pTexturePointerArray)
        {
            // We ran out of memory. Cleanup before we leave
            DISPDBG((ERRLVL,"ERROR: Couldn't allocate Context mem "
                            "for pTexturePointerArray"));
            goto Error_OutOfMem_B;            
        }
        
        // It is an array of surfaces, so set the destroy callback
        PA_SetDataDestroyCallback(pContext->pTexturePointerArray, 
                                  _D3D_SU_SurfaceArrayDestroyCallback);

        // Add this DD local to the hash table, and 
        // store the texture pointer array
        if(!HT_AddEntry(pThisDisplay->pDirectDrawLocalsHashTable, 
                        (ULONG_PTR)pContext->pDDLcl, 
                        pContext->pTexturePointerArray))
        {
            // failed to add entry, noe cleanup and exit
            // We ran out of memory. Cleanup before we leave
            DISPDBG((ERRLVL,"ERROR: Couldn't allocate Context mem"));
            goto Error_OutOfMem_C;                     
        }
    }

    // Record the internal surface information
    pContext->pSurfRenderInt = 
                GetSurfaceFromHandle(pContext, 
                                     lpLclFrame->lpSurfMore->dwSurfaceHandle);

    if ( NULL == pContext->pSurfRenderInt)
    {
        // We ran out of memory when allocating for the rendertarget. 
        // Cleanup before we leave
        DISPDBG((ERRLVL,"ERROR: Couldn't allocate pSurfRenderInt mem"));
        goto Error_OutOfMem_D;            
    }
    
    if (lpLclZ) 
    {
        pContext->pSurfZBufferInt = 
                    GetSurfaceFromHandle(pContext,
                                         lpLclZ->lpSurfMore->dwSurfaceHandle);
                                         
        if ( NULL == pContext->pSurfZBufferInt)
        {
            // We ran out of memory when allocating for the depth buffer. 
            // Cleanup before we leave
            DISPDBG((ERRLVL,"ERROR: Couldn't allocate pSurfZBufferInt mem"));   
            goto Error_OutOfMem_D;              
        }                                         
    }
    else 
    {
        pContext->pSurfZBufferInt = NULL;
    }    

    pContext->ModeChangeCount = pThisDisplay->ModeChangeCount;


    //******************
    // DEBUG USEFUL INFO
    //******************

    // Store the process id in which this d3d context was created 
    pContext->OwningProcess = pccd->dwPID;

    // Depth of the primary surface
    pContext->BPP = pContext->pThisDisplay->ddpfDisplay.dwRGBBitCount >> 3;
         
    //******************************
    // HW STATE FOR THIS D3D CONTEXT
    //******************************
    
    // Did we setup a DMA buffer at start of day, or FIFO's?
    if (pThisDisplay->DMAInfo.dwBuffSize == 0)
    {
        DISPDBG((WRNLVL, "No DMA buffer available - using FIFO's for 3D"));
        pContext->b3D_FIFOS = TRUE;
    }
    else
    {
        DISPDBG((WRNLVL, "Using shared DMA buffer"));    
        pContext->b3D_FIFOS = FALSE;        
    }

    //************************************
    // DEFAULT D3D OVERALL RENDERING STATE
    //************************************

    __CTX_SetupD3DContext_Defaults(pContext);
    
    //*************************************************************************
    //         ACTUALLY SETUP HARDWARE IN ORDER TO USE THIS D3D CONTEXT
    //*************************************************************************
 
    STOP_SOFTWARE_CURSOR(pThisDisplay);    

    // Setup default states values to the chip
    __CTX_Perm3_SetupD3D_HWDefaults(pContext);
    

    // Find out info for screen size and depth
    DISPDBG((DBGLVL, "ScreenWidth %d, ScreenHeight %d, Bytes/Pixel %d",
                     pContext->pThisDisplay->dwScreenWidth, 
                     pContext->pThisDisplay->dwScreenHeight, pContext->BPP));

    // Setup the relevent registers for the surfaces in use in this context.
    if ( FAILED( _D3D_OP_SetRenderTarget(pContext, 
                                         pContext->pSurfRenderInt, 
                                         pContext->pSurfZBufferInt,
                                         TRUE) ))
    {
        goto Error_OutOfMem_D;
    }

    // Process some defaults with which we initialize each D3D context
    _D3D_ST_ProcessOneRenderState(pContext,
                                  D3DRENDERSTATE_SHADEMODE,
                                  D3DSHADE_GOURAUD);

    _D3D_ST_ProcessOneRenderState(pContext,
                                  D3DRENDERSTATE_FOGCOLOR,
                                  0xFFFFFFFF);                                  
#if DX8_DDI
    // On DX8 D3DRENDERSTATE_TEXTUREPERSPECTIVE has been retired and is assumed 
    // to be set always to TRUE. We must make sure we are setting the hw up
    // correctly, so in order to do that we make an explicit setup call here 
    _D3D_ST_ProcessOneRenderState(pContext,
                                  D3DRENDERSTATE_TEXTUREPERSPECTIVE,
                                  1);
#endif // DX8_DDI                            

#if DX7_PALETTETEXTURE
    // Palette pointer array is per context, it is NOT associated with DD Local
    pContext->pPalettePointerArray = PA_CreateArray();
    
    if (! pContext->pPalettePointerArray) 
    {
        // We ran out of memory. Cleanup before we leave
        DISPDBG((ERRLVL,"ERROR: Couldn't allocate Context mem "
                        "for pPalettePointerArray"));
        goto Error_OutOfMem_D;            
    }

    // It is an array of surfaces, so set the destroy callback
    PA_SetDataDestroyCallback(pContext->pTexturePointerArray, 
                              _D3D_SU_PaletteArrayDestroyCallback);
#endif

    START_SOFTWARE_CURSOR(pThisDisplay);

    pccd->ddrval = DD_OK;  // Call handled OK
    
    DBG_CB_EXIT(D3DContextCreate,pccd->ddrval);        
    
    return (DDHAL_DRIVER_HANDLED);

    //**************************************************************************
    // ERROR HANDLING CODE PATHS
    //**************************************************************************    
Error_OutOfMem_D:
    // Remove the texture pointer array from the hash table
    HT_RemoveEntry(pThisDisplay->pDirectDrawLocalsHashTable,
                   (ULONG_PTR)pccd->lpDDLcl,
                   pThisDisplay);
    goto Error_OutOfMem_B;

Error_OutOfMem_C:
    // Free binding surface array (we'll no longer need it, and 
    // D3DCreateSurfaceEx will create a new one if necessary)
    PA_DestroyArray(pContext->pTexturePointerArray, pThisDisplay);
    
Error_OutOfMem_B:
    // Free D3D context data structure that we allocated
    HEAP_FREE(pContext->pSelf);      
        
Error_OutOfMem_A:
    // Release the context handle (otherwise it will remain in use forever)
    __CTX_HandleRelease((DWORD)pccd->dwhContext); 

    pccd->dwhContext = 0;
    pccd->ddrval = DDERR_OUTOFMEMORY;
    DBG_CB_EXIT(D3DContextCreate,pccd->ddrval);            
    return (DDHAL_DRIVER_HANDLED);
    
} // D3DContextCreate

//-----------------------------Public Routine----------------------------------
//
// D3DContextDestroy
//
// This callback is invoked when a Direct3D Device is being destroyed. As each
// device is represented by a context ID, the driver is passed a context to
// destroy.
//
// The driver should free all resources it allocated to the context being
// deleted. For example, the driver should free any texture resources it
// associated with the context. The driver should not free the DirectDraw
// surface(s) associated with the context because these will be freed by
// DirectDraw in response to an application or Direct3D runtime request.
//
// Parameters
//     pcdd
//          Pointer to Context destroy information.
//
//          .dwhContext
//               The ID of the context to be destroyed.
//          .ddrval
//               Return code. DD_OK indicates success.
//
// Return Value
//      Returns one of the following values:
//                DDHAL_DRIVER_HANDLED
//                DDHAL_DRIVER_NOTHANDLED
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DContextDestroy(
    LPD3DHAL_CONTEXTDESTROYDATA pccd)
{
    P3_D3DCONTEXT *pContext;
    P3_THUNKEDDATA *pThisDisplay;

    DBG_CB_ENTRY(D3DContextDestroy);
    
    // Deleting context
    DISPDBG((DBGLVL,"D3DContextDestroy Context = %08lx",pccd->dwhContext));

    pContext = _D3D_CTX_HandleToPtr(pccd->dwhContext);

    if (!CHECK_D3DCONTEXT_VALIDITY(pContext))
    {
        pccd->ddrval = D3DHAL_CONTEXT_BAD;
        DISPDBG((WRNLVL,"Context not valid"));

        DBG_CB_EXIT(D3DContextDestroy,pccd->ddrval );        
        return (DDHAL_DRIVER_HANDLED);
    }

    pThisDisplay = pContext->pThisDisplay;

    // Flush any DMA and Sync the chip so that that DMA can complete
    // (deletecontexts aren't an every day occurance, so we may as well)

    STOP_SOFTWARE_CURSOR(pThisDisplay);

#if WNT_DDRAW
    if (pThisDisplay->ppdev->bEnabled)
    {
#endif
        DDRAW_OPERATION(pContext, pThisDisplay);

        {
            P3_DMA_DEFS();
            P3_DMA_GET_BUFFER();
            P3_DMA_FLUSH_BUFFER();
        }

        SYNC_WITH_GLINT;
#if WNT_DDRAW
    }
#endif

    START_SOFTWARE_CURSOR(pThisDisplay);

    // Mark the context as disabled
    pContext->MagicNo = RC_MAGIC_DISABLE;

#if DX7_TEXMANAGEMENT
    // Cleanup any texture management stuff before leaving
    _D3D_TM_Ctx_Destroy(pContext);
#endif // DX7_TEXMANAGEMENT    

    // Free and cleanup any associated hardware resources
    __CTX_CleanDirect3DContext(pContext);

    // Mark the context as now empty (dwhContext is ULONG_PTR for Win64)
    __CTX_HandleRelease((DWORD)pccd->dwhContext);

    // Finally, free up rendering context structure and set to NULL
    HEAP_FREE(pContext->pSelf);
    pContext = NULL;

    pccd->ddrval = DD_OK;

    DBG_CB_EXIT(D3DContextDestroy, pccd->ddrval);  

    return (DDHAL_DRIVER_HANDLED);       
} // D3DContextDestroy
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3ddp2op.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3ddp2op.c
*
* Content: D3D DrawPrimitives2 command buffer operations support
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "dma.h"
#include "tag.h"

//-----------------------------------------------------------------------------
//
// __OP_IntersectRectl
//
// This function intersects two RECTLs. If no intersection exists returns FALSE
//
//-----------------------------------------------------------------------------
BOOL 
__OP_IntersectRectl(
    RECTL*  prcresult,
    RECTL*  prcin1,
    RECT*  prcin2)
{
    prcresult->left  = max(prcin1->left,  prcin2->left);
    prcresult->right = min(prcin1->right, prcin2->right);

    if (prcresult->left < prcresult->right)
    {
        prcresult->top    = max(prcin1->top,    prcin2->top);
        prcresult->bottom = min(prcin1->bottom, prcin2->bottom);

        if (prcresult->top < prcresult->bottom)
        {
            return TRUE;
        }
    }

    return FALSE;
} // __OP_IntersectRectl

#if DX7_TEXMANAGEMENT       
VOID __OP_MarkManagedSurfDirty(P3_D3DCONTEXT* pContext, 
                               DWORD dwSurfHandle,
                               P3_SURF_INTERNAL* pTexture);
#endif

//-----------------------------------------------------------------------------
//
// _D3D_OP_Clear2
//
// This function processes the D3DDP2OP_CLEAR DP2 command token.
//
// It builds a mask and a value for the stencil/depth clears. The mask is used 
// to stop unwanted bits being updated during the clear. The value is scaled in 
// the case of the Z depth, and is shifted in the case of the stencil.  This 
// results in the correct value being written, at the correct location in the 
// ZBuffer, while doing fast-block fills through SGRAM
//-----------------------------------------------------------------------------

#define P3RX_UPDATE_WRITE_MASK(a)                   \
if (dwCurrentMask != a)                             \
{                                                   \
    P3_DMA_GET_BUFFER_ENTRIES(2);                   \
    SEND_P3_DATA(FBHardwareWriteMask, a);           \
    P3_DMA_COMMIT_BUFFER();                         \
    dwCurrentMask = a;                              \
}

VOID 
_D3D_OP_Clear2( 
    P3_D3DCONTEXT* pContext,
    D3DHAL_DP2CLEAR* lpcd2,
    DWORD dwNumRects)
{
    DWORD i;
    RECTL rect, rect_vwport;
    DWORD dwDepthValue;
    DWORD dwStencilValue;
    DWORD dwStencilMask;
    DWORD dwDepthMask;
    DWORD color;
    DWORD dwCurrentMask = 0xFFFFFFFF;
    BOOL bNoBlockFillZ = FALSE;
    BOOL bNoBlockFillStencil = FALSE;
    BOOL bComputeIntersections = FALSE;
    BYTE Bytes[4];
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    HRESULT ddrval;
    D3DHAL_DP2CLEAR WholeViewport;

    P3_DMA_DEFS();

    DBG_CB_ENTRY(_D3D_OP_Clear2);
    
    // Check if we were asked to clear a valid buffer
    if ( (lpcd2->dwFlags & (D3DCLEAR_TARGET  | 
                            D3DCLEAR_ZBUFFER | 
                            D3DCLEAR_STENCIL) ) == 0)
    {
        // We have been asked to do nothing - and that's what we've done.
        DBG_CB_EXIT(_D3D_OP_Clear2, DD_OK);    
        return;
    }


#if DX8_DDI
    // When zero clear rects is passed to a DX8 driver with D3DDP2OP_CLEAR 
    // token, the driver should clear the whole viewport. The zero number 
    // of rects could be passed only if D3D is using a pure device. 

    // D3DCLEAR_COMPUTERECTS has been added to the dwFlags of D3DHAL_CLEARDATA.
    // When set, the flag means that user provided clear rects  should be 
    // culled against the current viewport.

    if (!(lpcd2->dwFlags & D3DCLEAR_COMPUTERECTS))
    {
        // Do nothing for non-pure device
    }
    else
    if (dwNumRects == 0)
    {
        // When wStateCount is zero we need to clear whole viewport
        WholeViewport.dwFlags = lpcd2->dwFlags;     
        WholeViewport.dwFillColor = lpcd2->dwFillColor; 
        WholeViewport.dvFillDepth = lpcd2->dvFillDepth; 
        WholeViewport.dwFillStencil = lpcd2->dwFillStencil;
        WholeViewport.Rects[0].left = pContext->ViewportInfo.dwX;
        WholeViewport.Rects[0].top = pContext->ViewportInfo.dwY;
        WholeViewport.Rects[0].right = pContext->ViewportInfo.dwX +
                                            pContext->ViewportInfo.dwWidth;
        WholeViewport.Rects[0].bottom = pContext->ViewportInfo.dwY + 
                                             pContext->ViewportInfo.dwHeight;    
        // Replace pointers and continue as usual
        lpcd2 = &WholeViewport;
        dwNumRects = 1;
    }
    else
    {
        // We need to cull all rects against the current viewport
        // but in order not to allocate a temporary RECT array in
        // kernel heap we'll compute this inside the clearing loop

        rect_vwport.left   = pContext->ViewportInfo.dwX;
        rect_vwport.top    = pContext->ViewportInfo.dwY;
        rect_vwport.right  = pContext->ViewportInfo.dwX + 
                             pContext->ViewportInfo.dwWidth;
        rect_vwport.bottom = pContext->ViewportInfo.dwY + 
                             pContext->ViewportInfo.dwHeight;

        bComputeIntersections = TRUE;

    }
#endif // DX8_DDI

    // Check if there is any rect to clear at all
    if ( dwNumRects == 0)
    {
        // We have been asked to do nothing - and that's what we've done.
        DBG_CB_EXIT(_D3D_OP_Clear2, DD_OK);    
        return;
    }   

    // Wait until we have we finished flipping before clearing anything
    do
    {
        ddrval = 
                _DX_QueryFlipStatus(pContext->pThisDisplay, 
                                    pContext->pSurfRenderInt->fpVidMem, 
                                    TRUE);
    } while ( FAILED (ddrval) );

    // Switch to hw Ddraw context in order to do the clears
    DDRAW_OPERATION(pContext, pThisDisplay);

    // Prepare any data necessary to clear the render target
    if ((lpcd2->dwFlags & D3DCLEAR_TARGET) && 
        (pContext->pSurfRenderInt != NULL))
    {
        color = lpcd2->dwFillColor;

        // Clear depending on depth
        switch (pContext->pSurfRenderInt->dwPixelSize)
        {
            // 16 Bit colors come in as 32 Bit RGB Values
            // Color will be packed in the clear function
            case __GLINT_16BITPIXEL:
                if (pThisDisplay->ddpfDisplay.dwRBitMask == 0x7C00) 
                {
                    color = ((color & 0xf8) >> 3)            | 
                            ((color & 0xf800) >> (16 - 10))  | 
                            ((color & 0xf80000) >> (24 - 15));
                } 
                else 
                {
                    color = ((color & 0xff) >> 3)             | 
                            ((color & 0xfc00) >> (16 - 11))   | 
                            ((color & 0xf80000) >> (24 - 16));
                }
                break;
                
            case __GLINT_24BITPIXEL:
                DISPDBG((ERRLVL,"P3 doesn't support 24 bpp render target"));
                break;
                
            default:
                break;
        }
    } // if (lpcd2->dwFlags & D3DCLEAR_TARGET)

    // Prepare any data necessary to clear the depth buffer
    if ((lpcd2->dwFlags & D3DCLEAR_ZBUFFER) && 
        (pContext->pSurfZBufferInt != NULL))
    {
        float fDepth;
        
        DDPIXELFORMAT* pPixFormat = &pContext->pSurfZBufferInt->pixFmt;
                
        DWORD dwZBitDepth = pPixFormat->dwZBufferBitDepth;

        // Find the depth bits, remembering to remove any stencil bits.
        if (pPixFormat->dwFlags & DDPF_STENCILBUFFER)
        {
            dwZBitDepth -= pPixFormat->dwStencilBitDepth;
        }

        dwDepthMask = (0xFFFFFFFF >> (32 - dwZBitDepth));

        // 32 bit depth buffers on Perm3 are really 
        // limited to 31 bits of precision
        if (dwZBitDepth == 32)
        {
            dwDepthMask = dwDepthMask >> 1; 
        }

        if (lpcd2->dvFillDepth == 1.0f)
        {
            dwDepthValue = dwDepthMask;
        }
        else
        {
            fDepth = lpcd2->dvFillDepth * (float)dwDepthMask;

            // This is a hardware dependency on how the Perm3 handles the 
            // limited precision of 32bit floats(24 bits of mantissa) and
            // converts the value into a 32bit z buffer value. This doesn't
            // happen with any other z bit depth but 32.
            if (dwZBitDepth == 32)
            {
                fDepth += 0.5f;
            }
            
            myFtoi((int*)&dwDepthValue, fDepth);
        }

        // As we are fast-block filling, make sure we copy the 
        // Mask to the top bits.
        switch (pContext->pSurfZBufferInt->dwPixelSize)
        {
            case __GLINT_16BITPIXEL:
                dwDepthMask &= 0xFFFF;
                dwDepthMask |= (dwDepthMask << 16);
                break;
            case __GLINT_8BITPIXEL:
                dwDepthMask &= 0xFF;
                dwDepthMask |= dwDepthMask << 8;
                dwDepthMask |= dwDepthMask << 16;
                break;
        }

        if (pThisDisplay->pGLInfo->bDRAMBoard)
        {
            // Check for a DRAM fill that the chip isn't emulating.
            Bytes[0] = (BYTE)(dwDepthMask & 0xFF);
            Bytes[1] = (BYTE)((dwDepthMask & 0xFF00) >> 8);
            Bytes[2] = (BYTE)((dwDepthMask & 0xFF0000) >> 16);
            Bytes[3] = (BYTE)((dwDepthMask & 0xFF000000) >> 24);
            if (((Bytes[0] != 0) && (Bytes[0] != 0xFF)) ||
                ((Bytes[1] != 0) && (Bytes[1] != 0xFF)) ||
                ((Bytes[2] != 0) && (Bytes[2] != 0xFF)) ||
                ((Bytes[3] != 0) && (Bytes[3] != 0xFF)))
            {
                bNoBlockFillZ = TRUE;
            }
        }

        DISPDBG((DBGLVL,"ZClear Value = 0x%x, ZClear Mask = 0x%x", 
                   dwDepthValue, dwDepthMask));
    } // if (lpcd2->dwFlags & D3DCLEAR_ZBUFFER)

    // Prepare any data necessary to clear the stencil buffer
    if ((lpcd2->dwFlags & D3DCLEAR_STENCIL) && 
        (pContext->pSurfZBufferInt != NULL))
    {
        int dwShiftCount = 0;
        DDPIXELFORMAT* pPixFormat = &pContext->pSurfZBufferInt->pixFmt;

        // Find out where to shift the 
        dwStencilMask = pPixFormat->dwStencilBitMask;

        if (dwStencilMask != 0)
        {
            while ((dwStencilMask & 0x1) == 0) 
            {
                dwStencilMask >>= 1;
                dwShiftCount++;
            }
            
            dwStencilValue = (lpcd2->dwFillStencil << dwShiftCount);
            dwStencilMask = pPixFormat->dwStencilBitMask;

            // As we are fast-block filling, make sure we copy the 
            // Mask to the top bits.
            switch (pContext->pSurfZBufferInt->dwPixelSize)
            {
                case __GLINT_16BITPIXEL:
                    dwStencilMask &= 0xFFFF;
                    dwStencilMask |= (dwStencilMask << 16);
                    break;
                    
                case __GLINT_8BITPIXEL:
                    dwStencilMask &= 0xFF;
                    dwStencilMask |= dwStencilMask << 8;
                    dwStencilMask |= dwStencilMask << 16;
                    break;
            }

            DISPDBG((DBGLVL,"Stencil Clear Value = 0x%x, Stencil Mask = 0x%x", 
                       dwStencilValue, dwStencilMask));
        }
        else
        {
            DISPDBG((ERRLVL,"ERROR: Stencil mask is not valid!"));
            dwStencilValue = 0;
            dwStencilMask = 0;
        }

        if (pThisDisplay->pGLInfo->bDRAMBoard)
        {
            // Check for a DRAM fill that the chip isn't emulating.
            Bytes[0] = (BYTE)(dwStencilMask & 0xFF);
            Bytes[1] = (BYTE)((dwStencilMask & 0xFF00) >> 8);
            Bytes[2] = (BYTE)((dwStencilMask & 0xFF0000) >> 16);
            Bytes[3] = (BYTE)((dwStencilMask & 0xFF000000) >> 24);
            if (((Bytes[0] != 0) && (Bytes[0] != 0xFF)) ||
                ((Bytes[1] != 0) && (Bytes[1] != 0xFF)) ||
                ((Bytes[2] != 0) && (Bytes[2] != 0xFF)) ||
                ((Bytes[3] != 0) && (Bytes[3] != 0xFF)))
            {
                bNoBlockFillStencil = TRUE;
            }
        }
    } // if (lpcd2->dwFlags & D3DCLEAR_STENCIL)


    // Loop through each clearing rect and perform the clearing hw operations
    i = dwNumRects;
    while (i-- > 0) 
    {
        if (bComputeIntersections)
        {
            // Compute intersection between the viewport and the incoming 
            // RECTLs. If no intersection exists skip into next one.

            if (!__OP_IntersectRectl(&rect, &rect_vwport, &lpcd2->Rects[i]))
            {
                // No intersection, so skip it
                goto Next_Rectl_To_Clear;
            }
        }
        else
        {
            // We already have the rects we need to clear, so 
            // just use them in reverse order
            rect.left   = lpcd2->Rects[i].left;
            rect.right  = lpcd2->Rects[i].right;
            rect.top    = lpcd2->Rects[i].top;
            rect.bottom = lpcd2->Rects[i].bottom;
        }

        // Clear the frame buffer
        if ((lpcd2->dwFlags & D3DCLEAR_TARGET) && 
            (pContext->pSurfRenderInt != NULL))        
        {
            P3RX_UPDATE_WRITE_MASK(__GLINT_ALL_WRITEMASKS_SET);

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
            if (pContext->Flags & SURFACE_ANTIALIAS)
            {
                RECTL Temp = rect;
                Temp.left *= 2;
                Temp.right *= 2;
                Temp.top *= 2;
                Temp.bottom *= 2;
            
                _DD_BLT_P3Clear_AA(pThisDisplay, 
                                   &Temp, 
                                   pContext->dwAliasBackBuffer - 
                                        pThisDisplay->dwScreenFlatAddr, 
                                   color, 
                                   FALSE,
                                   pContext->pSurfRenderInt->dwPatchMode,
                                   pContext->pSurfRenderInt->dwPixelPitch,
                                   pContext->pSurfRenderInt->pixFmt.dwRGBBitCount,
                                   pContext->pSurfRenderInt->ddsCapsInt);
            }
            else
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS            
            {

                _DD_BLT_P3Clear(pThisDisplay, 
                                &rect, 
                                color, 
                                FALSE, 
                                FALSE,
                                pContext->pSurfRenderInt->fpVidMem,
                                pContext->pSurfRenderInt->dwPatchMode,
                                pContext->pSurfRenderInt->dwPixelPitch,
                                pContext->pSurfRenderInt->pixFmt.dwRGBBitCount);

            }
            
        }


        // Clear the z buffer
        if ((lpcd2->dwFlags & D3DCLEAR_ZBUFFER) &&
            (pContext->pSurfZBufferInt != NULL) )
        {
            P3RX_UPDATE_WRITE_MASK(dwDepthMask);

            if (bNoBlockFillZ)
            {
                P3_DMA_GET_BUFFER_ENTRIES(4);
                SEND_P3_DATA(FBSoftwareWriteMask, dwDepthMask);
                SEND_P3_DATA(FBDestReadMode, 
                             P3RX_FBDESTREAD_READENABLE(__PERMEDIA_ENABLE) |
                             P3RX_FBDESTREAD_ENABLE0(__PERMEDIA_ENABLE));
                P3_DMA_COMMIT_BUFFER();
            }                   

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
            if (pContext->Flags & SURFACE_ANTIALIAS)
            {
                RECTL Temp = rect;
                Temp.left *= 2;
                Temp.right *= 2;
                Temp.top *= 2;
                Temp.bottom *= 2;
                _DD_BLT_P3Clear_AA(pThisDisplay, 
                                   &Temp, 
                                   pContext->dwAliasZBuffer - 
                                        pThisDisplay->dwScreenFlatAddr, 
                                   dwDepthValue, 
                                   bNoBlockFillZ,
                                   pContext->pSurfZBufferInt->dwPatchMode,
                                   pContext->pSurfZBufferInt->dwPixelPitch,
                                   pContext->pSurfZBufferInt->pixFmt.dwRGBBitCount,
                                   pContext->pSurfZBufferInt->ddsCapsInt);

            }
            else
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS            
            {
                _DD_BLT_P3Clear(pThisDisplay, 
                                &rect, 
                                dwDepthValue, 
                                bNoBlockFillZ, 
                                TRUE,
                                pContext->pSurfZBufferInt->fpVidMem,
                                pContext->pSurfZBufferInt->dwPatchMode,
                                pContext->pSurfZBufferInt->dwPixelPitch,
                                pContext->pSurfZBufferInt->pixFmt.dwRGBBitCount
                                );
            }
            
            if (bNoBlockFillZ)
            {
                P3_DMA_GET_BUFFER_ENTRIES(4);
                SEND_P3_DATA(FBSoftwareWriteMask, __GLINT_ALL_WRITEMASKS_SET);
                SEND_P3_DATA(FBDestReadMode, __PERMEDIA_DISABLE);
                P3_DMA_COMMIT_BUFFER();
            }                   
        }

        // Clear the stencil buffer
        if ((lpcd2->dwFlags & D3DCLEAR_STENCIL) &&
            (pContext->pSurfZBufferInt != NULL) )
        {
            P3RX_UPDATE_WRITE_MASK(dwStencilMask);

            if (bNoBlockFillStencil)
            {
                P3_DMA_GET_BUFFER_ENTRIES(4);
                SEND_P3_DATA(FBSoftwareWriteMask, dwStencilMask);
                SEND_P3_DATA(FBDestReadMode, 
                             P3RX_FBDESTREAD_READENABLE(__PERMEDIA_ENABLE) |
                             P3RX_FBDESTREAD_ENABLE0(__PERMEDIA_ENABLE));
                P3_DMA_COMMIT_BUFFER();
            }                   

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
            if (pContext->Flags & SURFACE_ANTIALIAS)
            {
                RECTL Temp = rect;
                Temp.left *= 2;
                Temp.right *= 2;
                Temp.top *= 2;
                Temp.bottom *= 2;
                _DD_BLT_P3Clear_AA(pThisDisplay, 
                                   &Temp, 
                                   pContext->dwAliasZBuffer - 
                                        pThisDisplay->dwScreenFlatAddr, 
                                   dwStencilValue, 
                                   bNoBlockFillStencil,
                                   pContext->pSurfZBufferInt->dwPatchMode,
                                   pContext->pSurfZBufferInt->dwPixelPitch,
                                   pContext->pSurfZBufferInt->pixFmt.dwRGBBitCount,
                                   pContext->pSurfZBufferInt->ddsCapsInt
                                   );

            }
            else
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS            
            {

                _DD_BLT_P3Clear(pThisDisplay, 
                                &rect, 
                                dwStencilValue, 
                                bNoBlockFillStencil, 
                                TRUE,
                                pContext->pSurfZBufferInt->fpVidMem,
                                pContext->pSurfZBufferInt->dwPatchMode,
                                pContext->pSurfZBufferInt->dwPixelPitch,
                                pContext->pSurfZBufferInt->pixFmt.dwRGBBitCount
                                );
            }

            if (bNoBlockFillStencil)
            {
                P3_DMA_GET_BUFFER_ENTRIES(4);
                SEND_P3_DATA(FBSoftwareWriteMask, __GLINT_ALL_WRITEMASKS_SET);
                SEND_P3_DATA(FBDestReadMode, __PERMEDIA_DISABLE);
                P3_DMA_COMMIT_BUFFER();
            }                   

        }
        
Next_Rectl_To_Clear:
        ;

    } // while

    // Make sure the WriteMask is reset to it's default value
    {                                               
        P3_DMA_GET_BUFFER_ENTRIES(4);          

        SEND_P3_DATA(FBHardwareWriteMask, __GLINT_ALL_WRITEMASKS_SET);
        SEND_P3_DATA(FBDestReadMode, __PERMEDIA_DISABLE);

        P3_DMA_COMMIT_BUFFER();
    }

    DBG_CB_EXIT(_D3D_OP_Clear2, DD_OK);     
    return;
    
} // _D3D_OP_Clear2

//-----------------------------------------------------------------------------
//
// _D3D_OP_TextureBlt
//
// This function processes the D3DDP2OP_TEXBLT DP2 command token.
//
//-----------------------------------------------------------------------------   
VOID _D3D_OP_TextureBlt(P3_D3DCONTEXT* pContext, 
                     P3_THUNKEDDATA*pThisDisplay,
                     D3DHAL_DP2TEXBLT* pBlt)
{
    LPDDRAWI_DDRAWSURFACE_LCL pSrcLcl;
    LPDDRAWI_DDRAWSURFACE_LCL pDestLcl;
    P3_SURF_INTERNAL* pSrcTexture;
    P3_SURF_INTERNAL* pDestTexture;
    P3_SURF_FORMAT* pFormatSource;
    P3_SURF_FORMAT* pFormatDest;
    MIPTEXTURE *pSrcMipLevel, *pDstMipLevel;
    RECTL rSrc, rDest;
    int iMaxLogWidth, iCurrLogWidth;
    int iSrcLOD, iDestLOD, iCurrSrcLOD, iCurrDstLOD;
    BOOL  bMipMap, bMipMapLevelsMatch;

    DISPDBG((DBGLVL, "TextureBlt Source %d Dest %d", 
                      pBlt->dwDDSrcSurface,
                      pBlt->dwDDDestSurface));

    if (0 == pBlt->dwDDSrcSurface)
    {
        DISPDBG((ERRLVL,"Invalid handle TexBlt from %08lx to %08lx",
                        pBlt->dwDDSrcSurface,pBlt->dwDDDestSurface));
        return;
    }

    // Get the source texture structure pointer
    pSrcTexture = GetSurfaceFromHandle(pContext, pBlt->dwDDSrcSurface);    

    // Check that the source texture is valid
    if (pSrcTexture == NULL)
    {
        DISPDBG((ERRLVL, "ERROR: Source texture %d is invalid!",
                         pBlt->dwDDSrcSurface));
        return;
    }

    // Validate the destination texture handle
    if (0 == pBlt->dwDDDestSurface)
    {
#if DX7_TEXMANAGEMENT  

        // If we do texture management then a destination handle of 0
        // has the special meaning of preloading the source texture.

        if (!_D3D_TM_Preload_Tex_IntoVidMem(pContext, pSrcTexture))
        {
            DISPDBG((ERRLVL,"_D3D_OP_TextureBlt unable to "
                            "preload texture"));
        }
        
        return;
        
#else
        // If there's no driver texture managament support we can't go
        // on if the destination handle is 0
        DISPDBG((ERRLVL,"Invalid handle TexBlt from %08lx to %08lx",
                        pBlt->dwDDSrcSurface,pBlt->dwDDDestSurface));
        return;
#endif        
    }
    
    // Get the destination texture structure pointer for regular TexBlts
    pDestTexture = GetSurfaceFromHandle(pContext, pBlt->dwDDDestSurface);
    
    // Check that the destination texture is valid
    if (pDestTexture == NULL)
    {
        DISPDBG((ERRLVL, "ERROR: Dest texture %d is invalid!",
                         pBlt->dwDDDestSurface));
        return;
    }

    // Make sure the textures are of the same proportion
    if ((pSrcTexture->wWidth * pDestTexture->wHeight) != 
        (pSrcTexture->wHeight * pDestTexture->wWidth)) 
    {
        DISPDBG((ERRLVL, "ERROR: TEXBLT the src and dest textures are not of the same proportion"));
        return;
    }

    // It is possible that the source and destination textures may contain 
    // different number of mipmap levels. In this case, the driver is 
    // expected to BitBlt the common levels. For example, if a 256x256 source 
    // texture has 8 mipmap levels, and if the destination is a 64x64 texture 
    // with 6 levels, then the driver should BitBlt the 6 corresponding levels 
    // from the source. The driver can expect the dimensions of the top mip 
    // level of destination texture to be always equal to or lesser than the 
    // dimensions of the top mip level of the source texture. 

    // It might also be the case that only one of the textures is mipmapped
    // Since we keep all relevant info also in the MipLevels substructre for
    // the surface, we can treat both surfaces as mipmapped even if only
    // one of them was created as such and proceed with the TexBlt.
    
    if (pSrcTexture->bMipMap || pDestTexture->bMipMap)
    {
        bMipMap = TRUE;
        iMaxLogWidth = max(pSrcTexture->logWidth, pDestTexture->logWidth);
        iCurrLogWidth = iMaxLogWidth;
        iSrcLOD = 0;                           // start LOD for src        
        iDestLOD = 0;                          // start LOD for dest
    }
    else
    {
        // just one level
        bMipMap = FALSE;       // No mipmapping cases to be handled
        iMaxLogWidth = iCurrLogWidth = iSrcLOD = iDestLOD = 0;           
    }

    // Init the rects from and into which we will blt . This is top level 
    // mipmap or non-mipmap texture,  just use rect from Blt.
    rSrc = pBlt->rSrc;

    // Create a destination rectangle for compatibility 
    // with the DD blitting function we are calling.
    rDest.left = pBlt->pDest.x;
    rDest.top = pBlt->pDest.y;
    rDest.right = (pBlt->rSrc.right - pBlt->rSrc.left) + rDest.left;
    rDest.bottom = (pBlt->rSrc.bottom - pBlt->rSrc.top) + rDest.top;
            
    // Traverse all the mip map levels and try to match them for a blt to be 
    // done. If no mipmaps are present just do for the "first" and only 
    // levels  present.
    do 
    {
        DISPDBG((DBGLVL,"TEXBLT iteration %d %d %d %d",
                        iMaxLogWidth,iCurrLogWidth,iSrcLOD,iDestLOD));
    
        // Get the local surface pointers and make sure the level sizes
        // match in the case of mip map Texblts.
        if (bMipMap)
        {        
            bMipMapLevelsMatch = FALSE;        
            
            // Verify you only look at valid mipmap levels - they might 
            // be incomplete (and we want not to AV or access garbage!)
            // for example, a source 256x256 texture may contain 5 levels, 
            // but the destination 256x256 texture may contain 8. The 
            // driver is expected to safely handle this case, but it is 
            // not expected to produce correct results            
            if ((iSrcLOD < pSrcTexture->iMipLevels) &&
                (iDestLOD < pDestTexture->iMipLevels))
            {          
                DISPDBG((DBGLVL,"Checking match! %d vs. %d", 
                                pSrcTexture->MipLevels[iSrcLOD].logWidth,
                                pDestTexture->MipLevels[iDestLOD].logWidth)); 
              
                // Do we currently have two levels that match in size ?
                bMipMapLevelsMatch = 
                        ( pSrcTexture->MipLevels[iSrcLOD].logWidth == 
                          pDestTexture->MipLevels[iDestLOD].logWidth);                
            }

            // Record which levels are we currently blitting
            iCurrSrcLOD = iSrcLOD;
            iCurrDstLOD = iDestLOD;
            
            // Get ready for next loop by updating the LODs to use
            // increment LOD# if we are currently looking at a level 
            // equal or smaller to mip maps level 0 size
            if (iCurrLogWidth <= pSrcTexture->logWidth)
            {
                iSrcLOD++;
            }

            if (iCurrLogWidth <= pDestTexture->logWidth)
            {
                iDestLOD++;
            }            

            // Decrease the width into next smaller level
            iCurrLogWidth--;
        }
        else
        {
            // Single level blt - we set bMipMapLevelsMatch in order to blt it!
            bMipMapLevelsMatch = TRUE;
            iCurrSrcLOD = 0;
            iCurrDstLOD = 0;
        }

        if (bMipMapLevelsMatch)
        {
            // Switch to the DirectDraw context
            DDRAW_OPERATION(pContext, pThisDisplay);

            DISPDBG((DBGLVL,"Blitting level %d into level %d",
                            iCurrSrcLOD,
                            iCurrDstLOD));

            pSrcMipLevel = &pSrcTexture->MipLevels[iCurrSrcLOD];
            pDstMipLevel = &pDestTexture->MipLevels[iCurrDstLOD];

            ///////////////////////////////////////////////////////////////////
            // Here we handle all possible blt cases between different types
            // of memory and different scenarios of managed/unmanaged surfaces
            ///////////////////////////////////////////////////////////////////

#if DX7_TEXMANAGEMENT
            if ((0 == (pDestTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)) &&
                (0 == (pSrcTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)) )
#endif // DX7_TEXMANAGEMENT                
            {           
                //----------------------------------
                //----------------------------------
                // TEXBLT among non-managed textures
                //----------------------------------
                //----------------------------------

                if ((pSrcTexture->Location == SystemMemory) && 
                    (pDestTexture->Location == VideoMemory))
                {
                    //----------------------------
                    // Do the system->videomem blt
                    //----------------------------
                    _DD_P3Download(pThisDisplay,
                                   pSrcMipLevel->fpVidMem,
                                   pDstMipLevel->fpVidMem,
                                   pSrcTexture->dwPatchMode,
                                   pDestTexture->dwPatchMode,
                                   pSrcMipLevel->lPitch,
                                   pDstMipLevel->lPitch,                                                             
                                   pDstMipLevel->P3RXTextureMapWidth.Width,
                                   pDestTexture->dwPixelSize,
                                   &rSrc,
                                   &rDest);                                                           
                }
                else if ((pSrcTexture->Location == VideoMemory) && 
                         (pDestTexture->Location == VideoMemory))
                {
                    //------------------------------            
                    // Do the videomem->videomem blt
                    //------------------------------
                    _DD_BLT_P3CopyBlt(pThisDisplay,
                                      pSrcMipLevel->fpVidMem,
                                      pDstMipLevel->fpVidMem,
                                      pSrcTexture->dwPatchMode,
                                      pDestTexture->dwPatchMode,
                                      pSrcMipLevel->P3RXTextureMapWidth.Width,
                                      pDstMipLevel->P3RXTextureMapWidth.Width,
                                      pSrcMipLevel->dwOffsetFromMemoryBase,                                 
                                      pDstMipLevel->dwOffsetFromMemoryBase,
                                      pDestTexture->dwPixelSize,
                                      &rSrc,
                                      &rDest);
                }          
                else if ((pSrcTexture->Location == AGPMemory) && 
                         (pDestTexture->Location == VideoMemory))
                {
                    //-------------------------------           
                    // Do the AGP mem -> videomem blt
                    //-------------------------------    
                    DDCOLORKEY ddck_dummy = { 0 , 0 };

                    // We use the strecth blt because it handles AGP source 
                    // surfaces, not becuase we should stretch the surface in any way                
                    _DD_P3BltStretchSrcChDstCh(
                                      pThisDisplay,
                                      // src data
                                      pSrcMipLevel->fpVidMem,
                                      pSrcTexture->pFormatSurface,
                                      pSrcTexture->dwPixelSize,
                                      pSrcMipLevel->wWidth,
                                      pSrcMipLevel->wHeight,
                                      pSrcMipLevel->P3RXTextureMapWidth.Width,
                                      pSrcMipLevel->P3RXTextureMapWidth.Layout,
                                      pSrcMipLevel->dwOffsetFromMemoryBase,
                                      pSrcTexture->dwFlagsInt,
                                      &pSrcTexture->pixFmt,
                                      1,          // src IS AGP, otherwise we 
                                                  //would'nt call this
                                      // dest data
                                      pDstMipLevel->fpVidMem,
                                      pDestTexture->pFormatSurface,
                                      pDestTexture->dwPixelSize,
                                      pDstMipLevel->wWidth,
                                      pDstMipLevel->wHeight,
                                      pDstMipLevel->P3RXTextureMapWidth.Width,
                                      pDstMipLevel->P3RXTextureMapWidth.Layout,
                                      pDstMipLevel->dwOffsetFromMemoryBase,
                                      
                                      0,          // dwBltFlags no special blt effects
                                      0,          // dwBltDDFX  no special effects info
                                      ddck_dummy, // BltSrcColorKey dummy arg
                                      ddck_dummy, // BltDestColorKey dummy arg
                                      &rSrc,
                                      &rDest
                                      );
                }
                else            
                {
                    DISPDBG((ERRLVL,"Non-managed Tex Blt variation unimplemented! "
                                    "(from %d into %d)",
                                    pSrcTexture->Location,
                                    pDestTexture->Location));
                }
            }            
#if DX7_TEXMANAGEMENT              
            else if (pSrcTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
            {
                //----------------------------------
                //----------------------------------
                // TEXBLT from a managed texture
                //----------------------------------
                //----------------------------------

                if ((pDestTexture->Location == SystemMemory) ||
                    (pDestTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE))
                {
                    //-------------------------------------------------
                    // Do the Managed surf -> sysmem | managed surf blt
                    //-------------------------------------------------    

                    // make sure we'll reload the vidmem copy of the dest surf
                    if (pDestTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
                    {
                        __OP_MarkManagedSurfDirty(pContext,
                                                  pBlt->dwDDDestSurface,
                                                  pDestTexture);                                              
                    }

                    _DD_BLT_SysMemToSysMemCopy(
                                pSrcMipLevel->fpVidMem,
                                pSrcMipLevel->lPitch,
                                pSrcTexture->dwBitDepth,  
                                pDstMipLevel->fpVidMem,
                                pDstMipLevel->lPitch,  
                                pDestTexture->dwBitDepth, 
                                &rSrc,
                                &rDest);
                }
                else if (pDestTexture->Location == VideoMemory) 
                {
                    //-------------------------------------------------
                    // Do the Managed surf -> vidmem surf blt
                    //-------------------------------------------------                  

                    // This might be optimized by doing a vidmem->vidmem 
                    // when the source managed texture has a vidmem copy

                    _DD_P3Download(pThisDisplay,
                                   pSrcMipLevel->fpVidMem,
                                   pDstMipLevel->fpVidMem,
                                   pSrcTexture->dwPatchMode,
                                   pDestTexture->dwPatchMode,
                                   pSrcMipLevel->lPitch,
                                   pDstMipLevel->lPitch,                                                             
                                   pDstMipLevel->P3RXTextureMapWidth.Width,
                                   pDestTexture->dwPixelSize,
                                   &rSrc,
                                   &rDest);                                          
                }
                else            
                {
                    DISPDBG((ERRLVL,"Src-managed Tex Blt variation unimplemented! "
                                    "(from %d into %d)",
                                    pSrcTexture->Location,
                                    pDestTexture->Location));
                }
                
                
            }
            else if (pDestTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
            {
                //--------------------------------------------------------------
                //--------------------------------------------------------------
                // TEXBLT into a managed texture (except from a managed texture)
                //--------------------------------------------------------------
                //--------------------------------------------------------------

                // managed->managed is handled in the previous case

                if (pSrcTexture->Location == SystemMemory)
                {                
                    //-------------------------------------------------
                    // Do the sysmem surf -> managed surf blt
                    //-------------------------------------------------    

                    // make sure we'll reload the vidmem copy of the dest surf
                    __OP_MarkManagedSurfDirty(pContext,
                                              pBlt->dwDDDestSurface,
                                              pDestTexture);                                              
                                                                  
                    _DD_BLT_SysMemToSysMemCopy(
                                pSrcMipLevel->fpVidMem,
                                pSrcMipLevel->lPitch,
                                pSrcTexture->dwBitDepth,  
                                pDstMipLevel->fpVidMem,
                                pDstMipLevel->lPitch,  
                                pDestTexture->dwBitDepth, 
                                &rSrc, 
                                &rDest);
                }
                else if (pSrcTexture->Location == VideoMemory)                
                {
                    //-------------------------------------------------
                    // Do the vidmem surf -> Managed surf blt
                    //-------------------------------------------------                                  

                    if (0 != pSrcMipLevel->fpVidMemTM)
                    {
                        // Destination is already in vidmem so instead of
                        // "dirtying" the managed texture lets do the
                        // vidmem->vidmem blt which is faster than doing the
                        // update later (in the hope we'll really use it)

                        _DD_BLT_P3CopyBlt(pThisDisplay,
                                          pSrcMipLevel->fpVidMem,
                                          pDstMipLevel->fpVidMemTM,
                                          pSrcTexture->dwPatchMode,
                                          pDestTexture->dwPatchMode,
                                          pSrcMipLevel->P3RXTextureMapWidth.Width,
                                          pDstMipLevel->P3RXTextureMapWidth.Width,
                                          pSrcMipLevel->dwOffsetFromMemoryBase,                                 
                                          pDstMipLevel->dwOffsetFromMemoryBase,
                                          pDestTexture->dwPixelSize,
                                          &rSrc,
                                          &rDest);                        
                    } 
                    else
                    {
                        // make sure we'll reload the 
                        // vidmem copy of the dest surf
                        __OP_MarkManagedSurfDirty(pContext,
                                                  pBlt->dwDDDestSurface,
                                                  pDestTexture);   
                    }

                    // Do slow mem mapped framebuffer blt into sysmem
                    // The source surface lives in video mem so we need to get a
                    // "real" sysmem address for it:                    
                    _DD_BLT_SysMemToSysMemCopy(
                                D3DMIPLVL_GETPOINTER(pSrcMipLevel, pThisDisplay),
                                pSrcMipLevel->lPitch,
                                pSrcTexture->dwBitDepth,  
                                pDstMipLevel->fpVidMem,
                                pDstMipLevel->lPitch,  
                                pDestTexture->dwBitDepth, 
                                &rSrc,
                                &rDest);                    
                }
                else if (pSrcTexture->Location == AGPMemory)                     
                {
                    // make sure we'll reload the vidmem copy of the dest surf
                    __OP_MarkManagedSurfDirty(pContext,
                                              pBlt->dwDDDestSurface,
                                              pDestTexture);                                              
                
                    _DD_BLT_SysMemToSysMemCopy(
                                pSrcMipLevel->fpVidMem,
                                pSrcMipLevel->lPitch,
                                pSrcTexture->dwBitDepth,  
                                pDstMipLevel->fpVidMem,
                                pDstMipLevel->lPitch,  
                                pDestTexture->dwBitDepth, 
                                &rSrc,
                                &rDest);                
                }
                else            
                {
                    DISPDBG((ERRLVL,"Dest-managed Tex Blt variation unimplemented! "
                                    "(from %d into %d)",
                                    pSrcTexture->Location,
                                    pDestTexture->Location));
                }
                
            }
            else            
            {
                DISPDBG((ERRLVL,"Tex Blt variation unimplemented! "
                                "(from %d into %d)",
                                pSrcTexture->Location,
                                pDestTexture->Location));
            }
#endif // DX7_TEXMANAGEMENT        
            
        
            // Switch back to the Direct3D context
            D3D_OPERATION(pContext, pThisDisplay);
            
        } // if (bMipMapLevelsMatch)    


        // Update transfer rectangles if mip mapping
        if (bMipMap)
        {
            DWORD right, bottom;

            // Update source rectangle , the regions to be copied in mipmap 
            // sub-levels can be obtained by dividing rSrc and pDest by 
            // 2 at each level. 
            rSrc.left >>= 1;
            rSrc.top >>= 1;
            right = (rSrc.right + 1) >> 1;
            bottom = (rSrc.bottom + 1) >> 1;
            rSrc.right = ((right - rSrc.left) < 1) ? (rSrc.left + 1) : (right);
            rSrc.bottom = ((bottom - rSrc.top ) < 1) ? (rSrc.top + 1) : (bottom);     

            // Update destination rectangle   
            rDest.left >>= 1;
            rDest.top >>= 1;
            right = (rDest.right + 1) >> 1;
            bottom = (rDest.bottom + 1) >> 1;
            rDest.right = ((right - rDest.left) < 1) ? (rDest.left + 1) : (right);
            rDest.bottom = ((bottom - rDest.top ) < 1) ? (rDest.top + 1) : (bottom);              
        }

    } while (bMipMap && ((iSrcLOD < pSrcTexture->iMipLevels) &&
                         (iDestLOD < pDestTexture->iMipLevels))); // do until we're done looking at 1x1
                
} // _D3D_OP_TextureBlt

//-----------------------------------------------------------------------------
//
// _D3D_OP_SetRenderTarget
//
// Sets up the hw for the chosen render target and depth buffer
//
//-----------------------------------------------------------------------------
HRESULT 
_D3D_OP_SetRenderTarget(
    P3_D3DCONTEXT* pContext, 
    P3_SURF_INTERNAL* pRenderInt,
    P3_SURF_INTERNAL* pZBufferInt,
    BOOL bNewAliasBuffers)
{

    P3_SOFTWARECOPY* pSoftP3RX = &pContext->SoftCopyGlint;
    P3_THUNKEDDATA *pThisDisplay = pContext->pThisDisplay;
    DWORD AAMultiplier = 1;
    P3_DMA_DEFS();

    DBG_ENTRY(_D3D_OP_SetRenderTarget);

    // Verify the render target is in video memory
    if (pRenderInt)
    {    
        if (pRenderInt->ddsCapsInt.dwCaps & DDSCAPS_SYSTEMMEMORY) 
        {
            DISPDBG((ERRLVL, "ERROR: Render Surface in SYSTEM MEMORY"));
            return DDERR_GENERIC;
        }
    }
    else
    {
        // Must have a render target
        DISPDBG((ERRLVL, "ERROR: Render Surface is NULL"));
        return DDERR_GENERIC;
    }

    // If a Z Buffer verify it
    if (pZBufferInt)
    {
        if (pZBufferInt->ddsCapsInt.dwCaps & DDSCAPS_SYSTEMMEMORY) 
        {
            DISPDBG((ERRLVL, "ERROR: Z Surface in SYSTEM MEMORY, failing"));
            return DDERR_GENERIC;
        } 
    }    

    // Validate the RenderTarget to be 32 bit or 16 bit 565 
    if ((pRenderInt->pixFmt.dwRGBBitCount == 32     ) &&
        (pRenderInt->pixFmt.dwRBitMask == 0x00FF0000) &&
        (pRenderInt->pixFmt.dwGBitMask == 0x0000FF00) &&        
        (pRenderInt->pixFmt.dwBBitMask == 0x000000FF))
    {
        // were OK at 32bpp
    }
    else
    if ((pRenderInt->pixFmt.dwRGBBitCount == 16 ) &&
        (pRenderInt->pixFmt.dwRBitMask == 0xF800) &&
        (pRenderInt->pixFmt.dwGBitMask == 0x07E0) &&        
        (pRenderInt->pixFmt.dwBBitMask == 0x001F))    
    {
        // were OK at 16bpp
    }
    else
    {
        // we cant set our render target to this format !!!
        DISPDBG((WRNLVL, " SRT Error    !!!"));
        DISPDBG((WRNLVL, "    dwRGBBitCount:          0x%x", 
                                         pRenderInt->pixFmt.dwRGBBitCount));
        DISPDBG((WRNLVL, "    dwR/Y BitMask:          0x%x", 
                                         pRenderInt->pixFmt.dwRBitMask));
        DISPDBG((WRNLVL, "    dwG/U BitMask:          0x%x", 
                                         pRenderInt->pixFmt.dwGBitMask));
        DISPDBG((WRNLVL, "    dwB/V BitMask:          0x%x", 
                                         pRenderInt->pixFmt.dwBBitMask));
        DISPDBG((WRNLVL, "    dwRGBAlphaBitMask:      0x%x", 
                                         pRenderInt->pixFmt.dwRGBAlphaBitMask));
        return DDERR_GENERIC;          
    }

#if DX8_MULTISAMPLING
    // Decide whether antialising is requested and can be handled
    if ((pContext->pSurfRenderInt->dwSampling) &&
        (! _D3D_ST_CanRenderAntialiased(pContext, bNewAliasBuffers)))
    {
        return DDERR_OUTOFMEMORY;
    }
#endif // DX8_MULTISAMPLING

    // If we page flipped, clear the flag
    pThisDisplay->bFlippedSurface = FALSE;

    P3_DMA_GET_BUFFER();

    P3_ENSURE_DX_SPACE(46);
    WAIT_FIFO(26);
    
    pContext->pSurfRenderInt = pRenderInt;
    pContext->pSurfZBufferInt = pZBufferInt;

    // Check for Z Buffer
    if (pZBufferInt)
    {
        DDPIXELFORMAT* pZFormat = &pZBufferInt->pixFmt;

        if( pThisDisplay->dwDXVersion >= DX6_RUNTIME)
        {
            // On DX6 we look in the pixel format for the depth and stencil info.
            switch(pZFormat->dwZBufferBitDepth)
            {
            default:
                DISPDBG((ERRLVL,"ERROR: Unknown Z Pixel format!"));
                // Regard the buffer as 16 bit one and fall through

            case 16:
                if (pZFormat->dwStencilBitDepth == 1)
                {
                    // 15 bit Z, 1 bit stencil
                    pSoftP3RX->P3RXLBReadFormat.StencilPosition = 0; // Ignored in this mode
                    pSoftP3RX->P3RXLBReadFormat.StencilWidth = P3RX_STENCIL_WIDTH_1; 
                    pSoftP3RX->P3RXLBReadFormat.DepthWidth = P3RX_DEPTH_WIDTH_15;

                    pSoftP3RX->P3RXStencilMode.StencilWidth = P3RX_STENCIL_WIDTH_1;

                    pSoftP3RX->P3RXLBWriteFormat.StencilPosition = 0; // Ignored in this mode
                    pSoftP3RX->P3RXLBWriteFormat.StencilWidth = P3RX_STENCIL_WIDTH_1;
                    pSoftP3RX->P3RXLBWriteFormat.DepthWidth = P3RX_DEPTH_WIDTH_15;
                    
                    pSoftP3RX->P3RXDepthMode.Width = P3RX_DEPTH_WIDTH_15;
                    
                    pSoftP3RX->P3RXLBSourceReadMode.Packed16 = 1;
                    pSoftP3RX->P3RXLBDestReadMode.Packed16 = 1;
                    pSoftP3RX->P3RXLBWriteMode.Packed16 = 1;
                    pSoftP3RX->P3RXLBWriteMode.ByteEnables = 0x3;
                }
                else
                {
                    // 16 bit Z, no stencil
                    pSoftP3RX->P3RXLBReadFormat.StencilPosition = 0; // Ignored in this mode
                    pSoftP3RX->P3RXLBReadFormat.StencilWidth = P3RX_STENCIL_WIDTH_0; 
                    pSoftP3RX->P3RXStencilMode.StencilWidth = P3RX_STENCIL_WIDTH_0;
                    pSoftP3RX->P3RXLBReadFormat.DepthWidth = P3RX_DEPTH_WIDTH_16;
                    pSoftP3RX->P3RXLBWriteFormat.StencilPosition = 0; // Ignored in this mode
                    pSoftP3RX->P3RXLBWriteFormat.StencilWidth = P3RX_STENCIL_WIDTH_0;
                    pSoftP3RX->P3RXLBWriteFormat.DepthWidth = P3RX_DEPTH_WIDTH_16;
                    pSoftP3RX->P3RXDepthMode.Width = P3RX_DEPTH_WIDTH_16;
                    pSoftP3RX->P3RXLBWriteMode.ByteEnables = 0x3;
                    pSoftP3RX->P3RXLBSourceReadMode.Packed16 = 1;
                    pSoftP3RX->P3RXLBDestReadMode.Packed16 = 1;
                    pSoftP3RX->P3RXLBWriteMode.Packed16 = 1;
                }
                break;
                
            case 32:
                if (pZFormat->dwStencilBitDepth == 8)
                {
                    // 24 bit Z, 8 bit stencil
                    pSoftP3RX->P3RXLBReadFormat.StencilPosition = P3RX_STENCIL_POSITION_24; 
                    pSoftP3RX->P3RXLBReadFormat.StencilWidth = P3RX_STENCIL_WIDTH_8; 
                    pSoftP3RX->P3RXStencilMode.StencilWidth = P3RX_STENCIL_WIDTH_8;
                    pSoftP3RX->P3RXLBReadFormat.DepthWidth = P3RX_DEPTH_WIDTH_24;
                    pSoftP3RX->P3RXLBWriteFormat.StencilPosition = P3RX_STENCIL_POSITION_24; 
                    pSoftP3RX->P3RXLBWriteFormat.StencilWidth = P3RX_STENCIL_WIDTH_8;
                    pSoftP3RX->P3RXLBWriteFormat.DepthWidth = P3RX_DEPTH_WIDTH_24;
                    pSoftP3RX->P3RXDepthMode.Width = P3RX_DEPTH_WIDTH_24;
                    pSoftP3RX->P3RXLBWriteMode.ByteEnables = 0xF;
                    pSoftP3RX->P3RXLBSourceReadMode.Packed16 = 0;
                    pSoftP3RX->P3RXLBDestReadMode.Packed16 = 0;
                    pSoftP3RX->P3RXLBWriteMode.Packed16 = 0;
                }
                else
                {
                    // 32 bit Z, no stencil
                    pSoftP3RX->P3RXLBReadFormat.StencilPosition = 0;
                    pSoftP3RX->P3RXLBReadFormat.StencilWidth = P3RX_STENCIL_WIDTH_0; 
                    pSoftP3RX->P3RXStencilMode.StencilWidth = P3RX_STENCIL_WIDTH_0;
                    pSoftP3RX->P3RXLBReadFormat.DepthWidth = P3RX_DEPTH_WIDTH_32;
                    pSoftP3RX->P3RXLBWriteFormat.StencilPosition = 0; 
                    pSoftP3RX->P3RXLBWriteFormat.StencilWidth = P3RX_STENCIL_WIDTH_0;
                    pSoftP3RX->P3RXLBWriteFormat.DepthWidth = P3RX_DEPTH_WIDTH_32;
                    pSoftP3RX->P3RXDepthMode.Width = P3RX_DEPTH_WIDTH_32;
                    pSoftP3RX->P3RXLBWriteMode.ByteEnables = 0xF;
                    pSoftP3RX->P3RXLBSourceReadMode.Packed16 = 0;
                    pSoftP3RX->P3RXLBDestReadMode.Packed16 = 0;
                    pSoftP3RX->P3RXLBWriteMode.Packed16 = 0;

                }
                break;
            }

        }
        else
        // On DX5 we don't look at the pixel format, just the depth of the Z Buffer.
        {
            // Choose the correct Z Buffer depth
            switch(pZBufferInt->pixFmt.dwRGBBitCount)
            {
            default:
                DISPDBG((ERRLVL,"ERROR: Unknown depth format in _D3D_OP_SetRenderTarget!"));
                // Regard the buffer as 16 bit one and fall through

            case 16:
                pSoftP3RX->P3RXLBReadFormat.DepthWidth = __GLINT_DEPTH_WIDTH_16;
                pSoftP3RX->P3RXLBWriteFormat.DepthWidth = __GLINT_DEPTH_WIDTH_16;
                pSoftP3RX->P3RXDepthMode.Width = __GLINT_DEPTH_WIDTH_16;
                pSoftP3RX->P3RXLBWriteMode.ByteEnables = 0x3;
                pSoftP3RX->P3RXLBSourceReadMode.Packed16 = 1;
                pSoftP3RX->P3RXLBDestReadMode.Packed16 = 1;
                pSoftP3RX->P3RXLBWriteMode.Packed16 = 1;
                break;
                
            case 24:
                pSoftP3RX->P3RXLBReadFormat.DepthWidth = __GLINT_DEPTH_WIDTH_24;
                pSoftP3RX->P3RXLBWriteFormat.DepthWidth = __GLINT_DEPTH_WIDTH_24;
                pSoftP3RX->P3RXDepthMode.Width = __GLINT_DEPTH_WIDTH_24;
                pSoftP3RX->P3RXLBWriteMode.ByteEnables = 0x7;
                pSoftP3RX->P3RXLBSourceReadMode.Packed16 = 0;
                pSoftP3RX->P3RXLBDestReadMode.Packed16 = 0;
                pSoftP3RX->P3RXLBWriteMode.Packed16 = 0;
                break;
                
            case 32:
                pSoftP3RX->P3RXLBReadFormat.DepthWidth = __GLINT_DEPTH_WIDTH_32;
                pSoftP3RX->P3RXLBWriteFormat.DepthWidth = __GLINT_DEPTH_WIDTH_32;
                pSoftP3RX->P3RXDepthMode.Width = __GLINT_DEPTH_WIDTH_32;
                pSoftP3RX->P3RXLBWriteMode.ByteEnables = 0xF;
                pSoftP3RX->P3RXLBSourceReadMode.Packed16 = 0;
                pSoftP3RX->P3RXLBDestReadMode.Packed16 = 0;
                pSoftP3RX->P3RXLBWriteMode.Packed16 = 0;
                break;
                
            }
        }

        pSoftP3RX->P3RXLBSourceReadMode.Layout = pZBufferInt->dwPatchMode;
        pSoftP3RX->P3RXLBDestReadMode.Layout = pZBufferInt->dwPatchMode;
        pSoftP3RX->P3RXLBWriteMode.Layout = pZBufferInt->dwPatchMode;
    } //  if (pZBufferInt) 
    
    switch (pRenderInt->dwPixelSize)
    {
    case __GLINT_8BITPIXEL:
        // 8 Bit color index mode
        pSoftP3RX->DitherMode.ColorFormat = 
            pSoftP3RX->P3RXAlphaBlendColorMode.ColorFormat = P3RX_ALPHABLENDMODE_COLORFORMAT_CI;
        SEND_P3_DATA(PixelSize, 2 - __GLINT_8BITPIXEL);
        break;
        
    case __GLINT_16BITPIXEL:
        if (pThisDisplay->ddpfDisplay.dwRBitMask == 0x7C00)
        {
            // 5551 format
            pSoftP3RX->DitherMode.ColorFormat = P3RX_DITHERMODE_COLORFORMAT_5551;   
            pSoftP3RX->P3RXAlphaBlendColorMode.ColorFormat = P3RX_ALPHABLENDMODE_COLORFORMAT_5551;
        }
        else
        {
            // 565 format
            pSoftP3RX->DitherMode.ColorFormat = P3RX_DITHERMODE_COLORFORMAT_565;    
            pSoftP3RX->P3RXAlphaBlendColorMode.ColorFormat = P3RX_ALPHABLENDMODE_COLORFORMAT_565;
        }
        SEND_P3_DATA(PixelSize, 2 - __GLINT_16BITPIXEL);
        break;
        
    case __GLINT_24BITPIXEL:
    case __GLINT_32BITPIXEL:
        // 32 Bit Color Index mode
        pSoftP3RX->DitherMode.ColorFormat =
            pSoftP3RX->P3RXAlphaBlendColorMode.ColorFormat = P3RX_ALPHABLENDMODE_COLORFORMAT_8888;
        SEND_P3_DATA(PixelSize, 2 - __GLINT_32BITPIXEL);
        break;
    }

    pSoftP3RX->P3RXFBDestReadMode.Layout0 = pRenderInt->dwPatchMode;
    pSoftP3RX->P3RXFBWriteMode.Layout0 = pRenderInt->dwPatchMode;
    pSoftP3RX->P3RXFBSourceReadMode.Layout = pRenderInt->dwPatchMode;

    COPY_P3_DATA(FBWriteMode, pSoftP3RX->P3RXFBWriteMode);
    COPY_P3_DATA(FBDestReadMode, pSoftP3RX->P3RXFBDestReadMode);
    COPY_P3_DATA(FBSourceReadMode, pSoftP3RX->P3RXFBSourceReadMode);

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
    if (!(pContext->Flags & SURFACE_ANTIALIAS) ||
         (pContext->dwAliasBackBuffer == 0))
    {
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS
        pContext->PixelOffset = (DWORD)(pRenderInt->fpVidMem - 
                                                 pThisDisplay->dwScreenFlatAddr );

        if (pContext->pSurfZBufferInt)
        {
            pContext->ZPixelOffset = (DWORD)(pZBufferInt->fpVidMem - 
                                                        pThisDisplay->dwScreenFlatAddr);
        }
        AAMultiplier = 1;

        SEND_P3_DATA(PixelSize, (2 - pRenderInt->dwPixelSize));
#if DX8_MULTISAMPLING || DX7_ANTIALIAS
    }
    else
    {
        pContext->PixelOffset = pContext->dwAliasPixelOffset;
        pContext->ZPixelOffset = pContext->dwAliasZPixelOffset;
        AAMultiplier = 2;
    }
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS

    COPY_P3_DATA(AlphaBlendColorMode, pSoftP3RX->P3RXAlphaBlendColorMode);
    COPY_P3_DATA(DitherMode, pSoftP3RX->DitherMode);

    SEND_P3_DATA(FBWriteBufferAddr0, pContext->PixelOffset);
    SEND_P3_DATA(FBDestReadBufferAddr0, pContext->PixelOffset);
    SEND_P3_DATA(FBSourceReadBufferAddr, pContext->PixelOffset);

    SEND_P3_DATA(FBWriteBufferWidth0, 
                        pContext->pSurfRenderInt->dwPixelPitch  * AAMultiplier);
    SEND_P3_DATA(FBDestReadBufferWidth0, 
                        pContext->pSurfRenderInt->dwPixelPitch * AAMultiplier);
    SEND_P3_DATA(FBSourceReadBufferWidth, 
                        pContext->pSurfRenderInt->dwPixelPitch * AAMultiplier);

    WAIT_FIFO(20);

    // Is there a Z Buffer?
    if (pContext->pSurfZBufferInt != NULL)
    {
        // Offset is in BYTES
        SEND_P3_DATA(LBSourceReadBufferAddr, pContext->ZPixelOffset);
        SEND_P3_DATA(LBDestReadBufferAddr, pContext->ZPixelOffset);
        SEND_P3_DATA(LBWriteBufferAddr, pContext->ZPixelOffset);
        
        pSoftP3RX->P3RXLBWriteMode.Width = 
                        pContext->pSurfZBufferInt->dwPixelPitch * AAMultiplier;
        pSoftP3RX->P3RXLBSourceReadMode.Width = 
                        pContext->pSurfZBufferInt->dwPixelPitch * AAMultiplier;
        pSoftP3RX->P3RXLBDestReadMode.Width = 
                        pContext->pSurfZBufferInt->dwPixelPitch * AAMultiplier;
                        
        COPY_P3_DATA(LBDestReadMode, pSoftP3RX->P3RXLBDestReadMode);
        COPY_P3_DATA(LBSourceReadMode, pSoftP3RX->P3RXLBSourceReadMode);
        COPY_P3_DATA(LBWriteMode, pSoftP3RX->P3RXLBWriteMode);
        
        COPY_P3_DATA(StencilMode, pSoftP3RX->P3RXStencilMode);
        COPY_P3_DATA(LBReadFormat, pSoftP3RX->P3RXLBReadFormat);
        COPY_P3_DATA(LBWriteFormat, pSoftP3RX->P3RXLBWriteFormat);

        COPY_P3_DATA(DepthMode, pSoftP3RX->P3RXDepthMode);
    }

    DIRTY_VIEWPORT(pContext);

    P3_DMA_COMMIT_BUFFER();

    DBG_EXIT(_D3D_OP_SetRenderTarget,0);

    return DD_OK;
    
} // _D3D_OP_SetRenderTarget


//-----------------------------------------------------------------------------
//
// _D3D_OP_SceneCapture
//
// This function is called twice, once at the start of the rendering,
// and once at the end of the rendering.  The start is ignored, but 
// the end might be used to ensure that the DMA buffer has been flushed.
// This is needed for the case where a scene has little in it, and 
// doesn't fill the buffer up.
//
//-----------------------------------------------------------------------------
VOID  
_D3D_OP_SceneCapture(
    P3_D3DCONTEXT *pContext,
    DWORD dwFlag)
{
    P3_THUNKEDDATA *pThisDisplay;
    
    pThisDisplay = pContext->pThisDisplay;
    
    if (dwFlag == D3DHAL_SCENE_CAPTURE_START)
    {
        DISPDBG((DBGLVL,"Scene Start"));
    }
    else if (dwFlag == D3DHAL_SCENE_CAPTURE_END)    
    {   
#if DX8_MULTISAMPLING || DX7_ANTIALIAS
        if (pContext->Flags & SURFACE_ANTIALIAS) 
        {
            // Since we were antialiasing we need to put the data where 
            // the user asked which requires a copy from our AA buffer 
            // into the true target buffer

            // P3 Shrinking is done in the DDRAW context. This means you 
            // don't have to save and restore the state around the call 
            // - the next D3D_OPERATION will recover for you
            DDRAW_OPERATION(pContext, pThisDisplay);

            P3RX_AA_Shrink(pContext);
        }
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS

        DISPDBG((DBGLVL,"Scene End"));
    }
      
    return;
} // _D3D_OP_SceneCapture

#if DX7_TEXMANAGEMENT  
//-----------------------------------------------------------------------------
//
// __OP_MarkManagedSurfDirty
//
// Make sure textures are setup again if the texture is being used in any of
// the texture stages (for reloading purpouses) and make sure we mark it as
// dirty (since we're modifying the sysmem copy of the texture)
//
//-----------------------------------------------------------------------------   
VOID __OP_MarkManagedSurfDirty(P3_D3DCONTEXT* pContext, 
                               DWORD dwSurfHandle,
                               P3_SURF_INTERNAL* pTexture)
{
    // If the destination texture is in use in any of the texture
    // stages, make sure hw gets re-setup again before using it.
    if ((pContext->TextureStageState[0].m_dwVal[D3DTSS_TEXTUREMAP] 
                                    == dwSurfHandle) ||
        (pContext->TextureStageState[1].m_dwVal[D3DTSS_TEXTUREMAP]
                                    == dwSurfHandle))
    {
        DIRTY_TEXTURE(pContext);
    }

    // Mark the destination texture as needing to be updated
    // into vidmem before using it.
    pTexture->m_bTMNeedUpdate = TRUE;
    
} // __OP_MarkManagedSurfDirty

//-----------------------------------------------------------------------------
//
// _D3D_OP_SetTexLod
//
// This function processes the D3DDP2OP_SETTEXLOD DP2 command token.
// This communicates to the texture manager the most detailed mip map level
// required to load for a given managed surface. 
//
//----------------------------------------------------------------------------- 
VOID
_D3D_OP_SetTexLod(
    P3_D3DCONTEXT *pContext,
    D3DHAL_DP2SETTEXLOD* pSetTexLod)
{
    P3_SURF_INTERNAL* pTexture;
    
    // Get the source texture structure pointer
    pTexture = GetSurfaceFromHandle(pContext, pSetTexLod->dwDDSurface);    

    if (pTexture == NULL)
    {
        return;
    }

    // Set up the HW texture states again if this texture is in use
    // and the new LOD value is smaller than the current setting.
    if (((pContext->TextureStageState[0].m_dwVal[D3DTSS_TEXTUREMAP]
                                    == pSetTexLod->dwDDSurface) ||
         (pContext->TextureStageState[1].m_dwVal[D3DTSS_TEXTUREMAP]
                                    == pSetTexLod->dwDDSurface)) &&
        (pSetTexLod->dwLOD < pTexture->m_dwTexLOD))
    {
        DIRTY_TEXTURE(pContext);
    }

    // Change the texture's largest level to be actually used
    pTexture->m_dwTexLOD = pSetTexLod->dwLOD; 

} // _D3D_OP_SetTexLod

//-----------------------------------------------------------------------------
//
// _D3D_OP_SetPriority
//
// This function processes the D3DDP2OP_SETPRIORITY DP2 command token.
//
//----------------------------------------------------------------------------- 
VOID
_D3D_OP_SetPriority(
    P3_D3DCONTEXT *pContext,
    D3DHAL_DP2SETPRIORITY* pSetPriority)
{
    P3_SURF_INTERNAL* pTexture;
    
    // Get the source texture structure pointer
#if WNT_DDRAW
    pTexture = GetSurfaceFromHandle(pContext, pSetPriority->dwDDDestSurface);
#else
    pTexture = GetSurfaceFromHandle(pContext, pSetPriority->dwDDSurface);
#endif

    if (NULL != pTexture)
    {
        // Managed resources should be evicted depending on their priorities.
        // If of same priority then LRU is used to break the tie.
        pTexture->m_dwPriority = pSetPriority->dwPriority; 
    }

} // _D3D_OP_SetPriority

#if DX8_DDI
//-----------------------------------------------------------------------------
//
// _D3D_OP_AddDirtyRect
//
// This function processes the D3DDP2OP_ADDDIRTYRECT DP2 command token.
//
//----------------------------------------------------------------------------- 
VOID
_D3D_OP_AddDirtyRect(
    P3_D3DCONTEXT *pContext,
    D3DHAL_DP2ADDDIRTYRECT* pAddDirtyRect)
{
    P3_SURF_INTERNAL* pTexture;
    
    // Get the source texture structure pointer
    pTexture = GetSurfaceFromHandle(pContext, pAddDirtyRect->dwSurface);    

    if (NULL != pTexture)
    {
        //azn TODO
        // As a first implementation in this driver we mark the whole surface 
        // as dirty instead of marking just the indicated rect - which could be
        // transferred more efficiently
        __OP_MarkManagedSurfDirty(pContext, 
                                  pAddDirtyRect->dwSurface,
                                  pTexture);
    }

} // _D3D_OP_AddDirtyRect

//-----------------------------------------------------------------------------
//
// _D3D_OP_AddDirtyBox
//
// This function processes the D3DDP2OP_ADDDIRTYBOX DP2 command token.
//
//----------------------------------------------------------------------------- 
VOID
_D3D_OP_AddDirtyBox(
    P3_D3DCONTEXT *pContext,
    D3DHAL_DP2ADDDIRTYBOX* pAddDirtyBox)
{
    P3_SURF_INTERNAL* pTexture;
    
    // Get the source texture structure pointer
    pTexture = GetSurfaceFromHandle(pContext, pAddDirtyBox->dwSurface);    

    if (NULL != pTexture)
    {
        //azn TODO
        // As a first implementation in this driver we mark the whole surface 
        // as dirty instead of marking just the indicated rect - which could be
        // transferred more efficiently
        __OP_MarkManagedSurfDirty(pContext, 
                                  pAddDirtyBox->dwSurface,
                                  pTexture);
    }

} // _D3D_OP_AddDirtyBox
#endif
#endif // DX7_TEXMANAGEMENT
       


#if DX8_3DTEXTURES

//-----------------------------------------------------------------------------
//
// __OP_BasicVolumeBlt
//
// This function blts one single level/slice at a time for volume textures
//
//-----------------------------------------------------------------------------   
VOID __OP_BasicVolumeBlt(P3_D3DCONTEXT* pContext, 
                         P3_THUNKEDDATA*pThisDisplay,
                         P3_SURF_INTERNAL* pSrcTexture,
                         P3_SURF_INTERNAL* pDestTexture,
                         DWORD dwDestSurfHandle,
                         RECTL *prSrc, 
                         RECTL *prDest)
{
#if DX7_TEXMANAGEMENT
    if ((0 == (pDestTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)) &&
        (0 == (pSrcTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)) )
#endif // DX7_TEXMANAGEMENT     
    {
        if ((pSrcTexture->Location == SystemMemory) && 
            (pDestTexture->Location == VideoMemory))
        {
            //----------------------------
            // Do the system->videomem blt
            //----------------------------
            _DD_P3Download(pThisDisplay,
                           pSrcTexture->fpVidMem,
                           pDestTexture->fpVidMem,
                           pSrcTexture->dwPatchMode,
                           pDestTexture->dwPatchMode,
                           pSrcTexture->lPitch,
                           pDestTexture->lPitch,
                           pDestTexture->dwPixelPitch,
                           pDestTexture->dwPixelSize,
                           prSrc,
                           prDest);
        }
        else
        {
            DISPDBG((ERRLVL, "ERROR: __OP_BasicVolumeBlt b3DTexture (%d -> %d)"
                             "not suported yet!",
                         pSrcTexture->Location,
                         pDestTexture->Location));
        }
    }
#if DX7_TEXMANAGEMENT              
    else if (pSrcTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
    {
        //----------------------------------
        //----------------------------------
        // TEXBLT from a managed texture
        //----------------------------------
        //----------------------------------

        if ((pDestTexture->Location == SystemMemory) ||
            (pDestTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE))
        {
            //-------------------------------------------------
            // Do the Managed surf -> sysmem | managed surf blt
            //-------------------------------------------------    

            // make sure we'll reload the vidmem copy of the dest surf
            if (pDestTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
            {
                __OP_MarkManagedSurfDirty(pContext,
                                          dwDestSurfHandle,
                                          pDestTexture);                                              
            }

            _DD_BLT_SysMemToSysMemCopy(
                        pSrcTexture->fpVidMem,
                        pSrcTexture->lPitch,
                        pSrcTexture->dwBitDepth,  
                        pDestTexture->fpVidMem,
                        pDestTexture->lPitch,  
                        pDestTexture->dwBitDepth, 
                        prSrc,
                        prDest);
        }
        else if (pDestTexture->Location == VideoMemory) 
        {
            //-------------------------------------------------
            // Do the Managed surf -> vidmem surf blt
            //-------------------------------------------------                  

            // This might be optimized by doing a vidmem->vidmem 
            // when the source managed texture has a vidmem copy
            
            _DD_P3Download(pThisDisplay,
                           pSrcTexture->fpVidMem,
                           pDestTexture->fpVidMem,
                           pSrcTexture->dwPatchMode,
                           pDestTexture->dwPatchMode,
                           pSrcTexture->lPitch,
                           pDestTexture->lPitch,                                                             
                           pDestTexture->dwPixelPitch,
                           pDestTexture->dwPixelSize,
                           prSrc,
                           prDest);                                          
        }
        else            
        {
            DISPDBG((ERRLVL,"Src-managed __OP_BasicVolumeBlt variation "
                            "unimplemented! (from %d into %d)",
                            pSrcTexture->Location,
                            pDestTexture->Location));
        }
        
        
    }
    else if (pDestTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
    {
        //--------------------------------------------------------------
        //--------------------------------------------------------------
        // TEXBLT into a managed texture (except from a managed texture)
        //--------------------------------------------------------------
        //--------------------------------------------------------------

        // managed->managed is handled in the previous case

        if (pSrcTexture->Location == SystemMemory)
        {                
            //-------------------------------------------------
            // Do the sysmem surf -> managed surf blt
            //-------------------------------------------------    

            // make sure we'll reload the vidmem copy of the dest surf
            __OP_MarkManagedSurfDirty(pContext,
                                      dwDestSurfHandle,
                                      pDestTexture);                                              
                                                          
            _DD_BLT_SysMemToSysMemCopy(
                        pSrcTexture->fpVidMem,
                        pSrcTexture->lPitch,
                        pSrcTexture->dwBitDepth,  
                        pDestTexture->fpVidMem,
                        pDestTexture->lPitch,  
                        pDestTexture->dwBitDepth, 
                        prSrc, 
                        prDest);
        }
        else if (pSrcTexture->Location == VideoMemory)                
        {
            //-------------------------------------------------
            // Do the vidmem surf -> Managed surf blt
            //-------------------------------------------------                                  

              if (0 != pSrcTexture->MipLevels[0].fpVidMemTM)
            {
                // Destination is already in vidmem so instead of
                // "dirtying" the managed texture lets do the
                // vidmem->vidmem blt which is faster than doing the
                // update later (in the hope we'll really use it)

                _DD_BLT_P3CopyBlt(pThisDisplay,
                                  pSrcTexture->fpVidMem,
                                  pDestTexture->MipLevels[0].fpVidMemTM,
                                  pSrcTexture->dwPatchMode,
                                  pDestTexture->dwPatchMode,
                                  pSrcTexture->dwPixelPitch,
                                  pDestTexture->dwPixelPitch,
                                  pSrcTexture->MipLevels[0].dwOffsetFromMemoryBase,                                 
                                  pDestTexture->MipLevels[0].dwOffsetFromMemoryBase,
                                  pDestTexture->dwPixelSize,
                                  prSrc,
                                  prDest);                        
            } 
            else
            {
                // make sure we'll reload the 
                // vidmem copy of the dest surf
                __OP_MarkManagedSurfDirty(pContext,
                                          dwDestSurfHandle,
                                          pDestTexture);   
            }

            // Do slow mem mapped framebuffer blt into sysmem
            // The source surface lives in video mem so we need to get a
            // "real" sysmem address for it:                    
            _DD_BLT_SysMemToSysMemCopy(
                        D3DSURF_GETPOINTER(pSrcTexture, pThisDisplay),
                        pSrcTexture->lPitch,
                        pSrcTexture->dwBitDepth,  
                        pDestTexture->fpVidMem,
                        pDestTexture->lPitch,  
                        pDestTexture->dwBitDepth, 
                        prSrc,
                        prDest);
        }
        else if (pSrcTexture->Location == AGPMemory)                     
        {
            // make sure we'll reload the vidmem copy of the dest surf
            __OP_MarkManagedSurfDirty(pContext,
                                      dwDestSurfHandle,
                                      pDestTexture);                                              
        
            _DD_BLT_SysMemToSysMemCopy(
                        pSrcTexture->fpVidMem,
                        pSrcTexture->lPitch,
                        pSrcTexture->dwBitDepth,  
                        pDestTexture->fpVidMem,
                        pDestTexture->lPitch,  
                        pDestTexture->dwBitDepth, 
                        prSrc,
                        prDest);                
        }
        else            
        {
            DISPDBG((ERRLVL,"Dest-managed __OP_BasicVolumeBlt variation "
                            "unimplemented! (from %d into %d)",
                            pSrcTexture->Location,
                            pDestTexture->Location));
        }
        
    }
    else            
    {
        DISPDBG((ERRLVL,"__OP_BasicVolumeBlt variation unimplemented! "
                        "(from %d into %d)",
                        pSrcTexture->Location,
                        pDestTexture->Location));
    }
#endif // DX7_TEXMANAGEMENT        


} // __OP_BasicVolumeBlt

//-----------------------------------------------------------------------------
//
// _D3D_OP_VolumeBlt
//
// This function processes the D3DDP2OP_VOLUMEBLT DP2 command token.
//
//-----------------------------------------------------------------------------   
VOID _D3D_OP_VolumeBlt(P3_D3DCONTEXT* pContext, 
                       P3_THUNKEDDATA*pThisDisplay,
                       D3DHAL_DP2VOLUMEBLT* pBlt)
{
    LPDDRAWI_DDRAWSURFACE_LCL pSrcLcl;
    LPDDRAWI_DDRAWSURFACE_LCL pDestLcl;
    P3_SURF_INTERNAL* pSrcTexture;
    P3_SURF_INTERNAL* pDestTexture;
    P3_SURF_FORMAT* pFormatSource;
    P3_SURF_FORMAT* pFormatDest;
    RECTL rSrc, rDest;
    DWORD dwSrcCurrDepth, dwDestCurrDepth, dwEndDepth;

    // Get the texture structure pointers
    pSrcTexture = GetSurfaceFromHandle(pContext, pBlt->dwDDSrcSurface);
    pDestTexture = GetSurfaceFromHandle(pContext, pBlt->dwDDDestSurface);
    
    // Check that the textures are valid
    if (pSrcTexture == NULL)
    {
        DISPDBG((ERRLVL, "ERROR: Source texture %d is invalid!",
                         pBlt->dwDDSrcSurface));
        return;
    }

    if (pDestTexture == NULL)
    {
        DISPDBG((ERRLVL, "ERROR: Dest texture %d is invalid!",
                         pBlt->dwDDDestSurface));
        return;
    }

    // If we are going to blt 3D texture, both have to be 3D texture
    if ((pSrcTexture->b3DTexture == FALSE) != (pDestTexture->b3DTexture == FALSE))
    {
        DISPDBG((ERRLVL, "ERROR: TEXBLT b3DTexture (%d %d)does not match!",
                         pSrcTexture->b3DTexture,
                         pDestTexture->b3DTexture));
        return;
    }

    // Do we blt whole 3D texture ?
    if ((pBlt->srcBox.Left    == 0) &&
        (pBlt->srcBox.Top     == 0) &&
        (pBlt->srcBox.Right   == pSrcTexture->wWidth) &&
        (pBlt->srcBox.Bottom  == pSrcTexture->wHeight) &&
        (pBlt->srcBox.Front   == 0) &&
        (pBlt->srcBox.Back    == pSrcTexture->wDepth) &&
        (pBlt->dwDestX        == 0) &&
        (pBlt->dwDestY        == 0) &&
        (pBlt->dwDestZ        == 0) &&
        (pSrcTexture->wWidth  == pDestTexture->wWidth) &&
        (pSrcTexture->wHeight == pDestTexture->wHeight) &&
        (pSrcTexture->wDepth  == pDestTexture->wDepth))
    {
        // Build source rectangle

        rSrc.left   = 0;
        rSrc.top    = 0;
        rSrc.right  = pBlt->srcBox.Right;
        rSrc.bottom = pBlt->srcBox.Bottom * pBlt->srcBox.Back;

        // Destination rectangle is same as source.

        rDest = rSrc;

        // Switch to the DirectDraw context
        DDRAW_OPERATION(pContext, pThisDisplay);

        // Do the Blt!
        __OP_BasicVolumeBlt(pContext,
                            pThisDisplay,
                            pSrcTexture,
                            pDestTexture,
                            pBlt->dwDDDestSurface,
                            &rSrc,
                            &rDest);                                
      
        // Switch back to the Direct3D context
        D3D_OPERATION(pContext, pThisDisplay);

        return;
    }

    // Build source rectangle.
    rSrc.left   = pBlt->srcBox.Left;
    rSrc.top    = pBlt->srcBox.Top;
    rSrc.right  = pBlt->srcBox.Right;
    rSrc.bottom = pBlt->srcBox.Bottom;

    // Build destination rectangle.
    rDest.left   = pBlt->dwDestX;
    rDest.top    = pBlt->dwDestY;
    rDest.right  = pBlt->dwDestX + (rSrc.right - rSrc.left);
    rDest.bottom = pBlt->dwDestY + (rSrc.bottom - rSrc.top);

    // Adjust rectangle if blt from non-1st slice.
    if (pBlt->srcBox.Front)
    {
        ULONG ulOffset = pSrcTexture->wDepth * pBlt->srcBox.Front;
        rSrc.top    += ulOffset;
        rSrc.bottom += ulOffset;
    }

    // Adjust rectangle if blt to non-1st slice.
    if (pBlt->dwDestZ)
    {
        ULONG ulOffset = pDestTexture->wDepth * pBlt->dwDestZ;
        rDest.top    += ulOffset;
        rDest.bottom += ulOffset;
    }

    dwSrcCurrDepth  = pBlt->srcBox.Front;
    dwDestCurrDepth = pBlt->dwDestZ;

    dwEndDepth   = min(pBlt->dwDestZ + (pBlt->srcBox.Back - pBlt->srcBox.Front),
                       pDestTexture->wDepth);
    dwEndDepth   = min(dwEndDepth, pSrcTexture->wDepth);

    while(dwDestCurrDepth < dwEndDepth)
    {
        // Switch to the DirectDraw context
        DDRAW_OPERATION(pContext, pThisDisplay);

        // Do the Blt!
        __OP_BasicVolumeBlt(pContext,
                            pThisDisplay,
                            pSrcTexture,
                            pDestTexture,
                            pBlt->dwDDDestSurface,
                            &rSrc,
                            &rDest);  
                            
        // Switch back to the Direct3D context
        D3D_OPERATION(pContext, pThisDisplay);

        // Move the source and destination rect to next slice.
        rSrc.top     += pSrcTexture->wDepth;
        rSrc.bottom  += pSrcTexture->wDepth;
        rDest.top    += pDestTexture->wDepth;
        rDest.bottom += pDestTexture->wDepth;

        // Move on to next slice.
        dwSrcCurrDepth++;
        dwDestCurrDepth++;
    }
} // _D3D_OP_VolumeBlt

#endif // DX8_3DTEXTURES

#if DX8_DDI  

//-----------------------------------------------------------------------------
//
// _D3D_OP_BufferBlt
//
// This function processes the D3DDP2OP_BUFFERBLT DP2 command token.
//
//-----------------------------------------------------------------------------   
VOID _D3D_OP_BufferBlt(P3_D3DCONTEXT* pContext, 
                       P3_THUNKEDDATA*pThisDisplay,
                       D3DHAL_DP2BUFFERBLT* pBlt)
{

#if DX7_VERTEXBUFFERS
    // This command token is only sent to drivers 
    // supporting videomemory vertexbuffers. That is
    // why we won't see it come down to this driver.
#endif DX7_VERTEXBUFFERS

} // _D3D_OP_BufferBlt

#endif // DX8_DDI 

#if DX8_VERTEXSHADERS
//-----------------------------------------------------------------------------
//
// _D3D_OP_VertexShader_Create
//
// This function processes the D3DDP2OP_CREATEVERTEXSHADER DP2 command token.
//
//-----------------------------------------------------------------------------
HRESULT 
_D3D_OP_VertexShader_Create(
    P3_D3DCONTEXT* pContext, 
    DWORD dwVtxShaderHandle,
    DWORD dwDeclSize,
    DWORD dwCodeSize,
    BYTE *pShader)
{
    // Here we would use the data passed by the vertex shader
    // creation block in order to instantiate or compile the
    // given vertex shader. Since this hardware can't support
    // vertex shaders at this time, we just skip the data.
    
    return DD_OK;
    
} // _D3D_OP_VertexShader_Create

//-----------------------------------------------------------------------------
//
// _D3D_OP_VertexShader_Delete
//
// This function processes the D3DDP2OP_DELETEVERTEXSHADER DP2 command token.
//
//-----------------------------------------------------------------------------
VOID 
_D3D_OP_VertexShader_Delete(
    P3_D3DCONTEXT* pContext, 
    DWORD dwVtxShaderHandle)
{
    // Here we would use the data passed by the vertex shader
    // delete block in order to destroy the given vertex shader.
    // Since this hardware can't support vertex shaders at 
    // this time, we just skip the data.
    
} // _D3D_OP_VertexShader_Delete

#define RDVSD_ISLEGACY(ShaderHandle) !(ShaderHandle & D3DFVF_RESERVED0)

//-----------------------------------------------------------------------------
//
// _D3D_OP_VertexShader_Set
//
// This function processes the D3DDP2OP_SETVERTEXSHADER DP2 command token.
//
//-----------------------------------------------------------------------------
VOID 
_D3D_OP_VertexShader_Set(
    P3_D3DCONTEXT* pContext, 
    DWORD dwVtxShaderHandle)
{
    // Here we would use the data passed by the vertex shader
    // set block in order to setup the given vertex shader.
    // Since this hardware can't support vertex shaders at 
    // this time, we usually just skip the data. However under
    // the circumstances described below, we might be passed a
    // FVF vertex format

    DISPDBG((DBGLVL,"Setting up shader # 0x%x",dwVtxShaderHandle));

#if DX7_D3DSTATEBLOCKS
    if ( pContext->bStateRecMode ) 
    {
        _D3D_SB_Record_VertexShader_Set(pContext, dwVtxShaderHandle);
        return;
    }
#endif // DX7_D3DSTATEBLOCKS

    // Zero is a special handle that tells the driver to
    // invalidate the currently set shader.
    if( dwVtxShaderHandle == 0 )
    {
        DISPDBG((WRNLVL,"Invalidating the currently set shader"));
        return ;
    }    

    if( RDVSD_ISLEGACY(dwVtxShaderHandle) )
    {
        // Make it parse the FVF 
        pContext->dwVertexType = dwVtxShaderHandle;  
    }  
    else
    {
        DISPDBG((ERRLVL,"_D3D_OP_VertexShader_Set: Illegal shader handle "
                        "(This driver cant do vertex processing)"));
    }
    
} // _D3D_OP_VertexShader_Set

//-----------------------------------------------------------------------------
//
// _D3D_OP_VertexShader_SetConst
//
// This function processes the D3DDP2OP_SETVERTEXSHADERCONST DP2 command token.
//
//-----------------------------------------------------------------------------
VOID 
_D3D_OP_VertexShader_SetConst(
    P3_D3DCONTEXT* pContext, 
    DWORD dwRegister, 
    DWORD dwConst, 
    DWORD *pdwValues)
{
    // Here we would use the data passed by the vertex shader
    // constant block in order to set up the constant entry.
    // Since this hardware can't support vertex shaders at 
    // this time, we just skip the data.
    
} // _D3D_OP_VertexShader_SetConst

#endif // DX8_VERTEXSHADERS

#if DX8_PIXELSHADERS

//-----------------------------------------------------------------------------
//
// _D3D_OP_PixelShader_Create
//
// This function processes the D3DDP2OP_CREATEPIXELSHADER DP2 command token.
//
//-----------------------------------------------------------------------------
HRESULT 
_D3D_OP_PixelShader_Create(
    P3_D3DCONTEXT* pContext, 
    DWORD dwPxlShaderHandle,
    DWORD dwCodeSize,
    BYTE *pShader)
{
    // Here we would use the data passed by the pixel shader
    // creation block in order to instantiate or compile the
    // given pixel shader. 

    // Since this hardware can't support pixel shaders at this 
    // time, we fail the call in case we're called to create a
    // 255.255 version shader!

    return D3DERR_DRIVERINVALIDCALL;
    
} // _D3D_OP_PixelShader_Create

//-----------------------------------------------------------------------------
//
// _D3D_OP_PixelShader_Delete
//
// This function processes the D3DDP2OP_DELETEPIXELSHADER DP2 command token.
//
//-----------------------------------------------------------------------------
VOID 
_D3D_OP_PixelShader_Delete(
    P3_D3DCONTEXT* pContext, 
    DWORD dwPxlShaderHandle)
{
    // Here we would use the data passed by the pixel shader
    // delete block in order to destroy the given pixel shader.
    // Since this hardware can't support pixel shaders at 
    // this time, we just skip the data.
    
} // _D3D_OP_PixelShader_Delete

//-----------------------------------------------------------------------------
//
// _D3D_OP_PixelShader_Set
//
// This function processes the D3DDP2OP_SETPIXELSHADER DP2 command token.
//
//-----------------------------------------------------------------------------
VOID 
_D3D_OP_PixelShader_Set(
    P3_D3DCONTEXT* pContext, 
    DWORD dwPxlShaderHandle)
{
    // Here we would use the data passed by the pixel shader
    // set block in order to setup the given pixel shader.
    // Since this hardware can't support pixel shaders at 
    // this time, we just skip the data.
    
} // _D3D_OP_PixelShader_Set

//-----------------------------------------------------------------------------
//
// _D3D_OP_PixelShader_SetConst
//
// This function processes the D3DDP2OP_SETPIXELSHADERCONST DP2 command token.
//
//-----------------------------------------------------------------------------
VOID 
_D3D_OP_PixelShader_SetConst(
    P3_D3DCONTEXT* pContext, 
    DWORD dwRegister, 
    DWORD dwCount, 
    DWORD *pdwValues)
{
    // Here we would use the data passed by the pixel shader
    // set block in order to setup the given pixel shader constants.
    // Since this hardware can't support pixel shaders at 
    // this time, we just skip the data.
    
} // _D3D_OP_PixelShader_SetConst
#endif // DX8_PIXELSHADERS

#if DX8_MULTSTREAMS

//-----------------------------------------------------------------------------
//
// _D3D_OP_MStream_SetSrc
//
// This function processes the D3DDP2OP_SETSTREAMSOURCE DP2 command token.
//
//-----------------------------------------------------------------------------
VOID 
_D3D_OP_MStream_SetSrc(
    P3_D3DCONTEXT* pContext, 
    DWORD dwStream,
    DWORD dwVBHandle,
    DWORD dwStride)
{
    P3_SURF_INTERNAL *pSrcStream;
    
    DBG_ENTRY(_D3D_OP_MStream_SetSrc);

#if DX7_D3DSTATEBLOCKS
    if ( pContext->bStateRecMode ) 
    {
        _D3D_SB_Record_MStream_SetSrc(pContext, dwStream, dwVBHandle, dwStride);
        return;
    }
#endif // DX7_D3DSTATEBLOCKS

    if (dwVBHandle != 0)
    {
        if (dwStream == 0)
        {
            // Get the surface structure pointers for stream #0
            pSrcStream = GetSurfaceFromHandle(pContext, dwVBHandle);

            if (pSrcStream)
            {
                DISPDBG((DBGLVL,"Address of VB = 0x%x "
                                "dwVBHandle = %d , dwStride = %d",
                                pSrcStream->fpVidMem,dwVBHandle, dwStride));
                pContext->lpVertices = (LPDWORD)pSrcStream->fpVidMem;
                pContext->dwVerticesStride = dwStride;

                if (dwStride > 0)
                {
                    // DX8 has mixed types of vertices in one VB, size in bytes
                    // of the vertex buffer must be preserved
                    pContext->dwVBSizeInBytes = pSrcStream->lPitch;

                    // for VBs the wHeight should always be == 1.
                    // dwNumVertices stores the # of vertices in the VB
                    // On Win2K, both wWidth and lPitch are the buffer size
                    // On Win9x, only lPitch is the buffer size, wWidth is 0
                    // The same fact is also true for the index buffer
                    pContext->dwNumVertices = pSrcStream->lPitch / dwStride;

                    DISPDBG((DBGLVL,"dwVBHandle pContext->dwNumVertices = "
                                "pSrcStream->lPitch / dwStride = %d %d %d %d",
                                dwVBHandle,
                                pContext->dwNumVertices, 
                                pSrcStream->lPitch,dwStride));  
                    
#if DX7_D3DSTATEBLOCKS
                    pContext->dwVBHandle = dwVBHandle;
#endif // DX7_D3DSTATEBLOCKS
                }
                else
                {
                    pContext->dwVBSizeInBytes = 0;
                    pContext->dwNumVertices = 0;
                    DISPDBG((ERRLVL,"INVALID Stride is 0. VB Size undefined"));
                }
            }
            else
            {
                DISPDBG((ERRLVL,"ERROR Address of VB is NULL, "
                                "dwStream = %d dwVBHandle = %d , dwStride = %d",
                                dwStream, dwVBHandle, dwStride));
            }
        }
        else
        {
            DISPDBG((WRNLVL,"We don't handle other streams than #0"));
        }
    }
    else
    {
        // We are unsetting the stream
        pContext->lpVertices = NULL;

        DISPDBG((WRNLVL,"Unsetting a stream: "
                        "dwStream = %d dwVBHandle = %d , dwStride = %d",
                        dwStream, dwVBHandle, dwStride));
    }

    DBG_EXIT(_D3D_OP_MStream_SetSrc, 0);
} // _D3D_OP_MStream_SetSrc

//-----------------------------------------------------------------------------
//
// _D3D_OP_MStream_SetSrcUM
//
// This function processes the D3DDP2OP_SETSTREAMSOURCEUM DP2 command token.
//
//-----------------------------------------------------------------------------
VOID
_D3D_OP_MStream_SetSrcUM(
    P3_D3DCONTEXT* pContext, 
    DWORD dwStream,
    DWORD dwStride,
    LPBYTE pUMVtx,
    DWORD  dwVBSize)
{
    DBG_ENTRY(_D3D_OP_MStream_SetSrcUM);

    if (dwStream == 0)
    {
        // Set the stream # 0 information
        DISPDBG((DBGLVL,"_D3D_OP_MStream_SetSrcUM: "
                        "Setting VB@ 0x%x dwstride=%d", pUMVtx, dwStride));
        pContext->lpVertices = (LPDWORD)pUMVtx;
        pContext->dwVerticesStride = dwStride;
        pContext->dwVBSizeInBytes = dwVBSize  * dwStride;
        pContext->dwNumVertices = dwVBSize ;     // comes from the DP2 data 
                                                 // structure
    
    }
    else
    {
        DISPDBG((WRNLVL,"_D3D_OP_MStream_SetSrcUM: "
                        "We don't handle other streams than #0"));
    }
    
    DBG_EXIT(_D3D_OP_MStream_SetSrcUM, 0);
} // _D3D_OP_MStream_SetSrcUM

//-----------------------------------------------------------------------------
//
// _D3D_OP_MStream_SetIndices
//
// This function processes the D3DDP2OP_SETINDICES DP2 command token.
//
//-----------------------------------------------------------------------------             
VOID
_D3D_OP_MStream_SetIndices(
    P3_D3DCONTEXT* pContext, 
    DWORD dwVBHandle,
    DWORD dwStride)
{
    P3_SURF_INTERNAL *pIndxStream;
    
    DBG_ENTRY(_D3D_OP_MStream_SetIndices);

#if DX7_D3DSTATEBLOCKS    
    if ( pContext->bStateRecMode )
    {
        _D3D_SB_Record_MStream_SetIndices(pContext, dwVBHandle, dwStride);
        return;
    }
#endif // DX7_D3DSTATEBLOCKS    

    // NULL dwVBHandle just means that the Index should be unset
    if (dwVBHandle != 0)
    {
        // Get the indices surface structure pointer
        pIndxStream = GetSurfaceFromHandle(pContext, dwVBHandle);

        if (pIndxStream)
        {
            DISPDBG((DBGLVL,"Address of VB = 0x%x", pIndxStream->fpVidMem));

            pContext->lpIndices = (LPDWORD)pIndxStream->fpVidMem;
            pContext->dwIndicesStride = dwStride; // 2 or 4 for 16/32bit indices
#if DX7_D3DSTATEBLOCKS
            pContext->dwIndexHandle = dwVBHandle; // Index buffer handle
#endif
        }
        else
        {
            DISPDBG((ERRLVL,"ERROR Address of Index Surface is NULL, "
                            "dwVBHandle = %d , dwStride = %d",
                             dwVBHandle, dwStride));
        }
    }
    else
    {
        // We are unsetting the stream
        pContext->lpIndices = NULL;

        DISPDBG((WRNLVL,"Unsetting an index stream: "
                        "dwVBHandle = %d , dwStride = %d",
                         dwVBHandle, dwStride));
    }
    
    DBG_EXIT(_D3D_OP_MStream_SetIndices, 0);
} // _D3D_OP_MStream_SetIndices

//-----------------------------------------------------------------------------
//
// _D3D_OP_MStream_DrawPrim
//
// This function processes the D3DDP2OP_DRAWPRIMITIVE DP2 command token.
//
//-----------------------------------------------------------------------------
VOID
_D3D_OP_MStream_DrawPrim(
    P3_D3DCONTEXT* pContext, 
    D3DPRIMITIVETYPE primType,
    DWORD VStart,
    DWORD PrimitiveCount)
{
    DBG_ENTRY(_D3D_OP_MStream_DrawPrim);

    DISPDBG((DBGLVL,"_D3D_OP_MStream_DrawPrim "
               "primType=0x%x VStart=%d PrimitiveCount=%d", 
               primType, VStart, PrimitiveCount));

   _D3D_OP_MStream_DrawPrim2(pContext, 
                             primType,
                             VStart * pContext->FVFData.dwStride,
                             PrimitiveCount);
    
    DBG_EXIT(_D3D_OP_MStream_DrawPrim, 0);
} // _D3D_OP_MStream_DrawPrim

//-----------------------------------------------------------------------------
//
// _D3D_OP_MStream_DrawIndxP
//
// This function processes the D3DDP2OP_DRAWINDEXEDPRIMITIVE DP2 command token.
//
//-----------------------------------------------------------------------------
VOID
_D3D_OP_MStream_DrawIndxP(
    P3_D3DCONTEXT* pContext, 
    D3DPRIMITIVETYPE primType,
    DWORD BaseVertexIndex,
    DWORD MinIndex,
    DWORD NumVertices,
    DWORD StartIndex,
    DWORD PrimitiveCount)
{
    DBG_ENTRY(_D3D_OP_MStream_DrawIndxP);

    DISPDBG((DBGLVL,"_D3D_OP_MStream_DrawIndxP " 
               "primType=0x%x BaseVertexIndex=%d MinIndex=%d"
               "NumVertices =%d StartIndex=%d PrimitiveCount=%d", 
               primType, BaseVertexIndex, MinIndex,
               NumVertices, StartIndex, PrimitiveCount));

    _D3D_OP_MStream_DrawIndxP2(pContext, 
                               primType,
                               BaseVertexIndex * pContext->FVFData.dwStride,
                               MinIndex,
                               NumVertices,
                               StartIndex * pContext->dwIndicesStride,
                               PrimitiveCount);
                               
    DBG_EXIT(_D3D_OP_MStream_DrawIndxP, 0);
} // _D3D_OP_MStream_DrawIndxP

//-----------------------------------------------------------------------------
//
// Validate the context settings to use the current streams
//
//-----------------------------------------------------------------------------
BOOL
__OP_ValidateStreams(
    P3_D3DCONTEXT* pContext,
    BOOL bCheckIndexStream)
{
    if ((pContext->dwVerticesStride == 0) || 
        (pContext->FVFData.dwStride == 0))
    {
        DISPDBG((ERRLVL,"The zero'th stream is doesn't have a valid VB set"));
        return FALSE;        
    }

    if (pContext->dwVerticesStride < pContext->FVFData.dwStride)
    {
        DISPDBG((ERRLVL,"The stride set for the vertex stream is "
                        "less than the FVF vertex size"));
        return FALSE;
    }

//@@BEGIN_DDKSPLIT
    // This shouldn't happen, but lets watch for it since it would show
    // up as weird mangled & distorted triangles
    if (pContext->dwVerticesStride != pContext->FVFData.dwStride)
    {
        DISPDBG((ERRLVL,"Strides(indx-prim) <> %d %d ",
                         pContext->dwVerticesStride,pContext->FVFData.dwStride));
    }
//@@END_DDKSPLIT    

    if ((bCheckIndexStream) && (NULL == pContext->lpIndices))
    {
        DISPDBG((ERRLVL,"Pointer to index buffer is null"));
        return FALSE;    
    }

    if (NULL == pContext->lpVertices)
    {
        DISPDBG((ERRLVL,"Pointer to vertex buffer is null"));
        return FALSE;       
    }

    return TRUE;
} // __OP_ValidateStreams

//-----------------------------------------------------------------------------
//
// _D3D_OP_MStream_DrawPrim2
//
// This function processes the D3DDP2OP_DRAWPRIMITIVE2 DP2 command token.
//
//-----------------------------------------------------------------------------

VOID
_D3D_OP_MStream_DrawPrim2(
    P3_D3DCONTEXT* pContext, 
    D3DPRIMITIVETYPE primType,
    DWORD FirstVertexOffset,
    DWORD PrimitiveCount)
{
    BOOL bError;
    WORD wVStart;
    DWORD dwFillMode = pContext->RenderStates[D3DRENDERSTATE_FILLMODE];
    LPBYTE lpVertices;
    DWORD dwNumVertices;

    DBG_ENTRY(_D3D_OP_MStream_DrawPrim2);

    DISPDBG((DBGLVL ,"_D3D_OP_MStream_DrawPrim2 "
               "primType=0x%x FirstVertexOffset=%d PrimitiveCount=%d", 
               primType, FirstVertexOffset, PrimitiveCount));

    if (!__OP_ValidateStreams(pContext, FALSE))
    {
        return;
    }

    // Watchout: Sometimes (particularly when CLIPPEDTRIFAN are drawn), 
    // FirstVertexOffset might not be divided evenly by the dwStride
    lpVertices = ((LPBYTE)pContext->lpVertices) + FirstVertexOffset;
    dwNumVertices = pContext->dwVBSizeInBytes - FirstVertexOffset;
    dwNumVertices /= pContext->dwVerticesStride;
    wVStart = 0;
    
    switch(primType)
    {
        case D3DPT_POINTLIST:
            {
                D3DHAL_DP2POINTS dp2Points;
                dp2Points.wVStart = wVStart;
                
#if DX8_POINTSPRITES
                if(IS_POINTSPRITE_ACTIVE(pContext))
                {
                    _D3D_R3_DP2_PointsSprite_DWCount(pContext,
                                                     PrimitiveCount,
                                                     (LPBYTE)&dp2Points,
                                                     (LPD3DTLVERTEX)lpVertices,
                                                     dwNumVertices,
                                                     &bError);
                }
                else
#endif // DX8_POINTSPRITES
                {
                  
                    _D3D_R3_DP2_Points_DWCount(pContext,
                                               PrimitiveCount,
                                               (LPBYTE)&dp2Points,
                                               (LPD3DTLVERTEX)lpVertices,
                                               dwNumVertices,
                                               &bError);

                }  
            
            }
            break;
                
        case D3DPT_LINELIST:

            _D3D_R3_DP2_LineList(pContext,
                                 PrimitiveCount,
                                 (LPBYTE)&wVStart,
                                 (LPD3DTLVERTEX)lpVertices,
                                 dwNumVertices,
                                 &bError);
            break;        
            
        case D3DPT_LINESTRIP:

            _D3D_R3_DP2_LineStrip(pContext,
                                 PrimitiveCount,
                                 (LPBYTE)&wVStart,
                                 (LPD3DTLVERTEX)lpVertices,
                                 dwNumVertices,
                                 &bError);
            break;   
            
        case D3DPT_TRIANGLELIST:        

            _D3D_R3_DP2_TriangleList(pContext,
                                     PrimitiveCount,
                                     (LPBYTE)&wVStart,
                                     (LPD3DTLVERTEX)lpVertices,
                                     dwNumVertices,
                                     &bError);
            break;  
            
        case D3DPT_TRIANGLESTRIP:
        
            _D3D_R3_DP2_TriangleStrip(pContext,
                                     PrimitiveCount,
                                     (LPBYTE)&wVStart,
                                     (LPD3DTLVERTEX)lpVertices,
                                     dwNumVertices,
                                     &bError);        
            break; 
            
        case D3DPT_TRIANGLEFAN:
        
            _D3D_R3_DP2_TriangleFan(pContext,
                                    PrimitiveCount,
                                    (LPBYTE)&wVStart,
                                    (LPD3DTLVERTEX)lpVertices,
                                    dwNumVertices,
                                    &bError);
            break;         
    }
    
    DBG_EXIT(_D3D_OP_MStream_DrawPrim2, 0);
} // _D3D_OP_MStream_DrawPrim2

//-----------------------------------------------------------------------------
//
// _D3D_OP_MStream_DrawIndxP2
//
// This function processes the D3DDP2OP_DRAWINDEXEDPRIMITIVE2 DP2 command token.
//
//-----------------------------------------------------------------------------
VOID
_D3D_OP_MStream_DrawIndxP2(
    P3_D3DCONTEXT* pContext, 
    D3DPRIMITIVETYPE primType,
    INT   BaseVertexOffset,
    DWORD MinIndex,
    DWORD NumVertices,
    DWORD StartIndexOffset,
    DWORD PrimitiveCount)
{
    INT      BaseIndexOffset;
    LPDWORD  lpVertices;
    LPBYTE   lpIndices;
    BOOL bError;

    R3_DP2_PRIM_TYPE_MS *pRenderFunc; 
    
    DBG_ENTRY(_D3D_OP_MStream_DrawIndxP2);

    DISPDBG((DBGLVL,"_D3D_OP_MStream_DrawIndxP2 "
               "primType=0x%x BaseVertexOffset=%d MinIndex=%d "
               "NumVertices=%d StartIndexOffset=%d PrimitiveCount=%d", 
               primType, BaseVertexOffset, MinIndex,
               NumVertices, StartIndexOffset, PrimitiveCount));

    if (!__OP_ValidateStreams(pContext, TRUE))
    {
        return;
    }

    // The MinIndex and NumVertices parameters specify the range of vertex i
    // ndices used for each DrawIndexedPrimitive call. These are used to 
    // optimize vertex processing of indexed primitives by processing a 
    // sequential range of vertices prior to indexing into these vertices

    // **********                IMPORTANT NOTE               **********
    //
    // BaseVertexOffset is a signed quantity (INT) unlike the other parameters
    // to this call which are DWORDS. This may appear strange. Why would
    // the offset into the vertex buffer be negative? Clearly you cannot access
    // vertex data before the start of the vertex buffer, and indeed, you never
    // do. When you have a negative BaseVertexOffset you will also receive
    // indices which are large enough that when applied to the start pointer
    // (obtained from adding a negative BaseVertexOffset to the vertex data
    // pointer) which fall within the correct range of the vertices in the
    // actual vertex buffer, i.e., the indices "undo" any negative vertex offset
    // and vertex accesses will end up being in the legal range for that vertex
    // buffer.
    //
    // Hence, you must write your driver code with this in mind. For example,
    // you can't assume that given an index i and with a current vertex buffer
    // of size v:
    //
    // ((StartIndexOffset + i) >= 0) && ((StartIndexOffset + i) < v)
    //
    // Your code needs to take into account that your indices are not offsets
    // from the start of the vertex buffer but rather from the start of the
    // vertex buffer plus BaseVertexOffset and that furthermore BaseVertexOffset
    // may be negative.
    //
    // The reason BaseVertexOffset can be negative is that it provides a
    // significant advantage to the runtime in certain vertex processing scenarios.

    lpVertices = (LPDWORD)((LPBYTE)pContext->lpVertices + BaseVertexOffset);

    lpIndices =  (LPBYTE)pContext->lpIndices + StartIndexOffset;  


    // Select the appropriate rendering function
    pRenderFunc = NULL;
    
    if (pContext->dwIndicesStride == 2)
    {   
        // Handle 16 bit indices
                                      
        switch(primType)
        {                    
            case D3DPT_LINELIST:
                pRenderFunc = _D3D_R3_DP2_IndexedLineList_MS_16IND;
                break;        
                
            case D3DPT_LINESTRIP:
                pRenderFunc = _D3D_R3_DP2_IndexedLineStrip_MS_16IND;            
                break;   
                
            case D3DPT_TRIANGLELIST:
                pRenderFunc = _D3D_R3_DP2_IndexedTriangleList_MS_16IND;  
                break;
                
            case D3DPT_TRIANGLESTRIP:
                pRenderFunc = _D3D_R3_DP2_IndexedTriangleStrip_MS_16IND;  
                break;            
                
            case D3DPT_TRIANGLEFAN:
                pRenderFunc = _D3D_R3_DP2_IndexedTriangleFan_MS_16IND;  
                break;                        
        }
    }
    else
    {
        // Handle 32 bit indices

        switch(primType)
        {                    
            case D3DPT_LINELIST:
                pRenderFunc = _D3D_R3_DP2_IndexedLineList_MS_32IND;
                break;        
                
            case D3DPT_LINESTRIP:
                pRenderFunc = _D3D_R3_DP2_IndexedLineStrip_MS_32IND;            
                break;   
                
            case D3DPT_TRIANGLELIST:
                pRenderFunc = _D3D_R3_DP2_IndexedTriangleList_MS_32IND;  
                break;
                
            case D3DPT_TRIANGLESTRIP:
                pRenderFunc = _D3D_R3_DP2_IndexedTriangleStrip_MS_32IND;  
                break;            
                
            case D3DPT_TRIANGLEFAN:
                pRenderFunc = _D3D_R3_DP2_IndexedTriangleFan_MS_32IND;  
                break;                        
        }        
    }

    // Call our rendering function
    if (pRenderFunc)
    {
        // As mentioned above, the actual range of indices seen by the driver
        // doesn't necessarily lie within the range zero to one less than
        // the number of vertices in the vertex buffer due to BaseVertexOffset.
        // If BaseVertexOffset is positive the range of valid indices is
        // smaller than the size of the vertex buffer (the vertices that
        // lie in the vertex buffer before the BaseVertexOffset are not
        // considered). Furthermore, if BaseVertexOffset a valid index can
        // actually by greater than the number of vertices in the vertex
        // buffer.
        //
        // To assist with the validation performed by the rendering functions
        // we here compute a minimum and maximum index which take into
        // account the value of BaseVertexOffset. Thus a test for a valid
        // index becomes:
        //
        // ((BaseIndexOffset + StartIndexOffset + Index) >= 0) &&
        // ((BaseIndexOffset + StartIndexOffset + Index) <  VertexCount)

        BaseIndexOffset = (BaseVertexOffset / (int)pContext->dwVerticesStride);

        DISPDBG((DBGLVL,"_D3D_OP_MStream_DrawIndxP2 BaseIndexOffset = %d",
            BaseIndexOffset));

        (*pRenderFunc)(pContext,
                       PrimitiveCount,
                       (LPBYTE)lpIndices,
                       (LPD3DTLVERTEX)lpVertices,
                       BaseIndexOffset,
                       pContext->dwNumVertices,
                       &bError);     
    }
    
    DBG_EXIT(_D3D_OP_MStream_DrawIndxP2, 0);
} // _D3D_OP_MStream_DrawIndxP2



//-----------------------------------------------------------------------------
//
// _D3D_OP_MStream_ClipTriFan
//
// This function processes the D3DDP2OP_CLIPPEDTRIANGLEFAN DP2 command token.
//
//-----------------------------------------------------------------------------
VOID
_D3D_OP_MStream_ClipTriFan(    
    P3_D3DCONTEXT* pContext, 
    DWORD FirstVertexOffset,
    DWORD dwEdgeFlags,
    DWORD PrimitiveCount)
{   
    BOOL bError;
    
    DBG_ENTRY(_D3D_OP_MStream_ClipTriFan);

    DISPDBG((DBGLVL,"_D3D_OP_MStream_ClipTriFan "
               "FirstVertexOffset=%d dwEdgeFlags=0x%x PrimitiveCount=%d", 
               FirstVertexOffset, dwEdgeFlags, PrimitiveCount));

    if (pContext->RenderStates[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME)
    {
        D3DHAL_DP2TRIANGLEFAN_IMM dp2TriFanWire;

        if (!__OP_ValidateStreams(pContext, FALSE))
        {
            DBG_EXIT(_D3D_OP_MStream_ClipTriFan, 0);
            return;
        }

        dp2TriFanWire.dwEdgeFlags = dwEdgeFlags;

        _D3D_R3_DP2_TriangleFanImm(pContext,
                                   (WORD)PrimitiveCount,
                                   (LPBYTE)&dp2TriFanWire,
                                   (LPD3DTLVERTEX)pContext->lpVertices,
                                   pContext->dwNumVertices,
                                   &bError);
        
        
    }
    else
    {
       _D3D_OP_MStream_DrawPrim2(pContext, 
                                 D3DPT_TRIANGLEFAN,
                                 FirstVertexOffset,
                                 PrimitiveCount);
    }
    
    DBG_EXIT(_D3D_OP_MStream_ClipTriFan, 0);
} // _D3D_OP_MStream_ClipTriFan

//-----------------------------------------------------------------------------
//
// _D3D_OP_MStream_DrawRectSurface
//
// This function processes the D3DDP2OP_DRAWRECTSURFACE DP2 command token.
//
//-----------------------------------------------------------------------------
VOID _D3D_OP_MStream_DrawRectSurface(P3_D3DCONTEXT* pContext, 
                                     DWORD Handle,
                                     DWORD Flags,
                                     PVOID lpPrim)
{
    // High order surfaces are only supported for hw/drivers with
    // TnL support and 1.0 vertex shader support
    
} // _D3D_OP_MStream_DrawRectSurface

//-----------------------------------------------------------------------------
//
// _D3D_OP_MStream_DrawTriSurface
//
// This function processes the D3DDP2OP_DRAWTRISURFACE DP2 command token.
//
//-----------------------------------------------------------------------------                                     
VOID _D3D_OP_MStream_DrawTriSurface(P3_D3DCONTEXT* pContext, 
                                    DWORD Handle,
                                    DWORD Flags,
                                    PVOID lpPrim)
{
    // High order surfaces are only supported for hw/drivers with
    // TnL support and 1.0 vertex shader support

} // _D3D_OP_MStream_DrawTriSurface

#endif // DX8_MULTSTREAMS

//-----------------------------------------------------------------------------
//
// _D3D_OP_Viewport
//
// This function processes the D3DDP2OP_VIEWPORTINFO DP2 command token.
//
//-----------------------------------------------------------------------------                                     

VOID _D3D_OP_Viewport(P3_D3DCONTEXT* pContext,
                      D3DHAL_DP2VIEWPORTINFO* lpvp)
{
#if DX7_D3DSTATEBLOCKS
    if ( pContext->bStateRecMode )
    {
         _D3D_SB_Record_Viewport(pContext, lpvp);
    }
    else
#endif // DX7_D3DSTATEBLOCKS    
    {
        pContext->ViewportInfo = *lpvp;
        DIRTY_VIEWPORT(pContext);
    }
} // _D3D_OP_Viewport

//-----------------------------------------------------------------------------
//
// _D3D_OP_ZRange
//
// This function processes the D3DDP2OP_ZRANGE DP2 command token.
//
//-----------------------------------------------------------------------------

VOID _D3D_OP_ZRange(P3_D3DCONTEXT* pContext,
                    D3DHAL_DP2ZRANGE* lpzr)
{
#if DX7_D3DSTATEBLOCKS
    if ( pContext->bStateRecMode )
    {
        _D3D_SB_Record_ZRange(pContext, lpzr);
    }
    else
#endif // DX7_D3DSTATEBLOCKS    
    {
        pContext->ZRange = *lpzr;
        DIRTY_VIEWPORT(pContext);
    }
} // _D3D_OP_ZRange

//-----------------------------------------------------------------------------
//
// _D3D_OP_UpdatePalette
//
// This function processes the D3DDP2OP_UPDATEPALETTE DP2 command token.
//
//      Note : This function is need to skip D3DDP2OP_UPDATEPALETTE sent down 
//             by some DX6 apps, even if when PALETTE TEXTURE is not supported
//             Also notice that for legacy DX apps, the palette doesn't get
//             properly restored in another app transitions into full screen
//             mode and back. This is because the (legacy) runtimes don't
//             sent proper notification (through UpdatePalette/SetPalette) of
//             this event
//
//-----------------------------------------------------------------------------

HRESULT _D3D_OP_UpdatePalette(P3_D3DCONTEXT* pContext,
                              D3DHAL_DP2UPDATEPALETTE* pUpdatePalette,
                              DWORD* pdwPalEntries)
{
#if DX7_PALETTETEXTURE
    D3DHAL_DP2UPDATEPALETTE* pPalette;
    P3_SURF_INTERNAL* pTexture;

    // Find internal palette pointer from handle
    pPalette = GetPaletteFromHandle(pContext,
                                    pUpdatePalette->dwPaletteHandle);

    // Palette doesn't exist
    if (! pPalette) 
    {
        DISPDBG((WRNLVL, "_D3D_OP_UpdatePalette : Can't find palette"));
        return DDERR_INVALIDPARAMS;
    }

    // Check the range of palette entries
    if (pUpdatePalette->wStartIndex > LUT_ENTRIES)
    {
        DISPDBG((WRNLVL, 
                 "_D3D_OP_UpdatePalette : wStartIndex (%d) is bigger than 256", 
                 pUpdatePalette->wStartIndex));
        return DDERR_INVALIDPARAMS;
    }
    if ((pUpdatePalette->wStartIndex + pUpdatePalette->wNumEntries) 
                                                            > LUT_ENTRIES) 
    {
        DISPDBG((WRNLVL, "_D3D_OP_UpdatePalette : too many entries"));
        return DDERR_INVALIDPARAMS;
    }

    // Each palette is ARGB 8:8:8:8
    memcpy(((LPBYTE)(pPalette + 1)) + pUpdatePalette->wStartIndex*sizeof(DWORD),
           pdwPalEntries,
           pUpdatePalette->wNumEntries*sizeof(DWORD));

    // Check if the palette is in use
    // Palette Texture can not be used alone in the 2nd stage, so only the
    // 1st stage must be checked.
    if (pContext->TextureStageState[0].m_dwVal[D3DTSS_TEXTUREMAP])
    {
        pTexture = GetSurfaceFromHandle(pContext,
                                        pContext->TextureStageState[0].m_dwVal[D3DTSS_TEXTUREMAP]);
        if (pTexture)
        {
            if ((pTexture->pFormatSurface->DeviceFormat == SURF_CI8) &&
                (pTexture->dwPaletteHandle == pUpdatePalette->dwPaletteHandle))
            {
                DIRTY_TEXTURE(pContext);
            }
        }
    }
 
    return DD_OK;
#else
    return DD_OK;
#endif // DX7_PALETTETEXTURE
} // D3D_OP_UpdatePalette

//-----------------------------------------------------------------------------
//
// _D3D_OP_SetPalette
//
// This function processes the D3DDP2OP_SETPALETTE DP2 command token.
//
//      Note : This function is need to skip D3DDP2OP_SETPALETTE sent down 
//             by some DX6 apps, even if when PALETTE TEXTURE is not supported
//
//-----------------------------------------------------------------------------

HRESULT _D3D_OP_SetPalettes(P3_D3DCONTEXT* pContext,
                            D3DHAL_DP2SETPALETTE* pSetPalettes,
                            int iNumSetPalettes)
{
#if DX7_PALETTETEXTURE
    int i;
    P3_SURF_INTERNAL* pTexture;
    D3DHAL_DP2UPDATEPALETTE* pPalette;
    
    // Loop to process N surface palette association
    for (i = 0; i < iNumSetPalettes; i++, pSetPalettes++)
    {

        DISPDBG((DBGLVL,"SETPALETTE: Binding surf # %d to palette # %d",
                        pSetPalettes->dwSurfaceHandle,
                        pSetPalettes->dwPaletteHandle));               
    
        // Find internal surface pointer from handle
        pTexture = GetSurfaceFromHandle(pContext, 
                                        pSetPalettes->dwSurfaceHandle);
        if (! pTexture)
        {
            // Associated texture can't be found
            DISPDBG((WRNLVL, 
                     "SetPalettes : invalid texture handle %08lx",
                     pSetPalettes->dwSurfaceHandle));
            return DDERR_INVALIDPARAMS;
        }
 
        // Create the internal palette structure if necessary
        if (pSetPalettes->dwPaletteHandle)
        {
            // Find internal palette pointer from handle
            pPalette = GetPaletteFromHandle(pContext,
                                            pSetPalettes->dwPaletteHandle);    
    
            if (! pPalette)
            {
                pPalette = (D3DHAL_DP2UPDATEPALETTE *)
                                HEAP_ALLOC(FL_ZERO_MEMORY,
                                           sizeof(D3DHAL_DP2UPDATEPALETTE) 
                                                    + LUT_ENTRIES*sizeof(DWORD),
                                           ALLOC_TAG_DX(P));
                // Out of memory case
                if (! pPalette) 
                {
                    DISPDBG((WRNLVL, "_D3D_OP_SetPalettes : Out of memory."));
                    return DDERR_OUTOFMEMORY;
                }

                // Add this texture to the surface list
                if (! PA_SetEntry(pContext->pPalettePointerArray, 
                                  pSetPalettes->dwPaletteHandle, 
                                  pPalette))
                {
                    HEAP_FREE(pPalette);
                    DISPDBG((WRNLVL, "_D3D_OP_SetPalettes : "
                                     "PA_SetEntry() failed."));
                    return DDERR_OUTOFMEMORY;
                }

                // Set up the internal data structure
                pPalette->dwPaletteHandle = pSetPalettes->dwPaletteHandle;
                pPalette->wStartIndex = 0;
                pPalette->wNumEntries = LUT_ENTRIES;
            } 
        }

        // Record palette handle and flags in internal surface data
        pTexture->dwPaletteHandle = pSetPalettes->dwPaletteHandle;
        pTexture->dwPaletteFlags = pSetPalettes->dwPaletteFlags;

        // Mark texture as dirty if current texture is affected
        if ((pContext->TextureStageState[0].m_dwVal[D3DTSS_TEXTUREMAP] == 
                                               pSetPalettes->dwSurfaceHandle) ||
            (pContext->TextureStageState[1].m_dwVal[D3DTSS_TEXTUREMAP] == 
                                               pSetPalettes->dwSurfaceHandle))
        {
            DIRTY_TEXTURE(pContext);
        }

    }

    return DD_OK;
#else
    return DD_OK;
#endif // DX7_PALETTETEXTURE
} // _D3D_OP_SetPalettes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dsset.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dsset.h
*
* Content: State set (block) management macros and structures
*
* Copyright (c) 1999-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#if DX7_D3DSTATEBLOCKS
//-----------------------------------------------------------------------------
//                     State sets structure definitions
//-----------------------------------------------------------------------------

// How big is a FLAG field and how many bits can it accomodate
#define FLAG DWORD
#define FLAG_SIZE (8*sizeof(DWORD))

// How many RS and TS stages are there (on this hw we only store 2 TSS)
#define SB_MAX_STATE D3DSTATE_OVERRIDE_BIAS
#define SB_MAX_STAGES 2
// This value may change with the version of DX
#define SB_MAX_TSS D3DTSS_MAX

// FLAGS to indicate which state has been changed

#define SB_VIEWPORT_CHANGED         1
#define SB_ZRANGE_CHANGED           2
#define SB_CUR_VS_CHANGED           4
#define SB_INDICES_CHANGED          8

#define SB_STREAMSRC_CHANGED        (1 << 15)

#define SB_TNL_MATERIAL_CHANGED     1
#define SB_TNL_MATRIX_CHANGED       2

#define SB_TNL_CUR_PS_CHANGED       (1 << 31)

// We store state blocks in two different formats: uncompressed and compressed.
// The uncompressd format is much better while we're recording the state
// block whereas the compressed format is much more compact and suitable for
// state block execution. When a state block is ended (it's done recording)
// the driver performs this transformation. Out records are defined as unions
// in order to make the code easier to implement. The bCompressed field
// indicates the current format used in the block.
//
// In between STATESETBEGIN and STATESETEND, no shader\light will be created\
// destroyed.
//
// The compressed format will contain pointers to the commands to be executed,
// so that no extra command parsing cost is involved.
//

typedef struct _UnCompStateSet {

    // Size of uncompressed state set
    DWORD dwSize;

    // Stored state block info (uncompressed)
    // Flags tell us which fields have been set
    DWORD RenderStates[SB_MAX_STATE];
    DWORD TssStates[SB_MAX_STAGES][SB_MAX_TSS];

    FLAG bStoredRS[(SB_MAX_STATE + FLAG_SIZE)/ FLAG_SIZE];
    FLAG bStoredTSS[SB_MAX_STAGES][(SB_MAX_TSS + FLAG_SIZE) / FLAG_SIZE]; 

    // Flag to indicate what information has been changed
    // Upper 16 bits are used for stream sources
    DWORD dwFlags;

    // Information for viewport
    D3DHAL_DP2VIEWPORTINFO viewport;

    // Information for z-range;
    D3DHAL_DP2ZRANGE zRange;

#if DX8_DDI
    // Information for indices
    D3DHAL_DP2SETINDICES vertexIndex;

    // Information for stream source, only 1 for Permedia3
    D3DHAL_DP2SETSTREAMSOURCE streamSource[D3DVS_INPUTREG_MAX_V1_1];
#endif //DX8_DDI

#if DX7_SB_TNL
    // The least significant bit is used for material, others are used for matrices
    FLAG dwTnLFlags;
    
    // Information related to lights, size depends on the number of lights at 
    // D3DHAL_STATESETBEGIN time
    DWORD dwNumLights; 
    DWORD* pdwLightStateChanged;
    DWORD* pdwLightState;
    D3DLIGHT7* pLightData;
    
    // Information related to clip planes, size depends on the number of clip
    // planes at D3DHAL_STATESETBEGIN time
    DWORD dwNumClipPlanes;
    DWORD* pdwPlaneChanged;
    D3DVALUE* pPlaneCoff[4];

    // Information related to material
    D3DMATERIAL7 material;

    // Information related to transformation
    D3DMATRIX transMatrices[D3DTRANSFORMSTATE_TEXTURE7 + 1];
#endif // DX7_SB_TNL

#if DX8_SB_SHADERS
    // Number of vertex/pixel shaders, captured at D3DHAL_STATESETBEGIN time
    WORD wNumVertexShader;
    WORD wNumPixelShader;

    // Information for vertex/pixel shader constants 
    FLAG* pdwVSConstChanged;
    D3DVALUE* pdvVSConsts[4];

    FLAG* pdwPSConstChanged;
    D3DVALUE* pdvPSConsts[4];

    // Offset from the beginning of uc to the shader info blocks
    // (flags + constant register values)
    DWORD dwOffsetVSInfo;
    DWORD dwOffsetPSInfo;

    // Information for current pixel shader
    DWORD dwCurPixelShader;
#endif // DX8_SB_SHADERS

#if DX8_DDI
    // Information for current vertex shader
    DWORD dwCurVertexShader;
#endif // DX8_DDI
    
} UnCompStateSet, *PUnCompStateSet;

typedef struct _OffsetsCompSS {
            
    // Offset from the beginning of this structure    
    DWORD dwOffDP2RenderState;
    DWORD dwOffDP2TextureStageState;
    DWORD dwOffDP2Viewport;           // Single
    DWORD dwOffDP2ZRange;             // Single
#if DX8_DDI
    DWORD dwOffDP2SetIndices;         // Single
    DWORD dwOffDP2SetStreamSources;
#endif // DX8_DDI

#if DX7_SB_TNL
    DWORD dwOffDP2SetLights;
    DWORD dwOffDP2SetClipPlanes;
    DWORD dwOffDP2SetMaterial;        // Single
#endif // DX7_SB_TNL

#if DX8_SB_SHADERS
    // Number of vertex/pixel shader constant commands
    WORD wNumVSConstCmdPair;         
    WORD wNumPSConstCmdPair;
    // Double indirection to the set current shader/set shader constant pairs
    DWORD *pdwOffDP2VSConstCmd;
    DWORD *pdwOffDP2PSConstCmd;

    DWORD dwOffDP2SetPixelShader;
#endif // DX8_SB_SHADERS

#if DX8_DDI
    DWORD dwOffDP2SetVertexShader;
#endif // DX8_DDI
} OffsetsCompSS;


// After this fixed memory block, there is a size variable DP2 command stream
// Correponding DP2 command pointer is not NULL, if that command is in the 
// state set. ppDP2{VS|PS}ConstCmd has to be double indirection, DP2 command
// pointer pairs in it point to set current {V|P} shader and set {V|P} shader
// constants DP2 command.
typedef struct _CompressedStateSet {
        
    D3DHAL_DP2COMMAND* pDP2RenderState;
    D3DHAL_DP2COMMAND* pDP2TextureStageState;
    D3DHAL_DP2COMMAND* pDP2Viewport;           // Single
    D3DHAL_DP2COMMAND* pDP2ZRange;             // Single
#if DX8_DDI
    D3DHAL_DP2COMMAND* pDP2SetIndices;         // Single
    D3DHAL_DP2COMMAND* pDP2SetStreamSources;
#endif // DX8_DDI

#if DX7_SB_TNL
    D3DHAL_DP2COMMAND* pDP2SetLights;
    D3DHAL_DP2COMMAND* pDP2SetClipPlanes;
    D3DHAL_DP2COMMAND* pDP2SetMaterial;        // Single
    D3DHAL_DP2COMMAND* pDP2SetTransform;
#endif // DX7_SB_TNL
    
#if DX8_SB_SHADERS
    // Number of vertex/pixel shader constant commands
    WORD wNumVSConstCmdPair;         
    WORD wNumPSConstCmdPair;
    
    // Pairs of set vertex shader and set VS constants            
    D3DHAL_DP2COMMAND** ppDP2VSConstCmd;
    // Pairs of set pixel shader and set PS constants
    D3DHAL_DP2COMMAND** ppDP2PSConstCmd;

    // These 2 command must be after the above 2 set shader const commands
    D3DHAL_DP2COMMAND* pDP2SetPixelShader;            
#endif // DX8_SB_SHADERS

#if DX8_DDI
    D3DHAL_DP2COMMAND* pDP2SetVertexShader;
#endif DX8_DDI

} CompressedStateSet, *PCompressedStateSet;

// The state set is compressed
#define SB_COMPRESSED   0x1

// Values in the state set were changed by the capturing
#define SB_VAL_CAPTURED 0x2

typedef struct _P3StateSetRec {
    DWORD                   dwHandle;
    DWORD                   dwSSFlags;

    union {

        UnCompStateSet uc;
        CompressedStateSet cc;
    };

} P3StateSetRec , *PP3StateSetRec;


// How many pointers can we store in a 4K page. Pools of pointers are allocated 
// in this chunks in order to optimize kernel pool usage (we use 4000 vs 4096
// for any extra data the kernel allocator might put up along with the pool)
#define SSPTRS_PERPAGE (4000/sizeof(P3StateSetRec *))

#define FLAG_SET(flag, number)     \
    flag[ (number) / FLAG_SIZE ] |= (1 << ((number) % FLAG_SIZE))

#define IS_FLAG_SET(flag, number)  \
    (flag[ (number) / FLAG_SIZE ] & (1 << ((number) % FLAG_SIZE) ))

#endif //DX7_D3DSTATEBLOCKS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dstate.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dstate.c
*
* Content: D3D renderstates and texture stage states translation
*          into hardware specific settings.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "glint.h"
#include "dma.h"
#include "tag.h"

//-----------------------------Public Routine----------------------------------
//
// D3DGetDriverState
//
// This callback is used by both the DirectDraw and Direct3D runtimes to obtain 
// information from the driver about its current state.
// NOTE: We need to hook up this callback even if we don't do anything in it
//
// Parameter
//
//      pgdsd 
//          Pointer to a DD_GETDRIVERSTATEDATA structure. 
//
//          .dwFlags 
//              Flags to indicate the data requested. 
//          .lpDD 
//              Pointer to a DD_DIRECTDRAW_GLOBAL structure describing the device. 
//          .dwhContext 
//              Specifies the ID of the context for which information is being 
//              requested. 
//          .lpdwStates 
//              Pointer to the Direct3D driver state data to be filled in by the 
//              driver. 
//          .dwLength 
//              Specifies the length of the state data to be filled in by the 
//              driver. 
//          .ddRVal 
//              Specifies the return value. 
//
//
// Note: If you're driver doesn't implement this callback it won't be 
//       recognized as a DX7 level driver
//-----------------------------------------------------------------------------
DWORD CALLBACK 
D3DGetDriverState(
    LPDDHAL_GETDRIVERSTATEDATA pgdsd)
{
    P3_D3DCONTEXT*   pContext;

    DBG_CB_ENTRY(D3DGetDriverState);    

#if DX7_TEXMANAGEMENT_STATS
    if (pgdsd->dwFlags == D3DDEVINFOID_TEXTUREMANAGER)
    {
    
        if (pgdsd->dwLength < sizeof(D3DDEVINFO_TEXTUREMANAGER))
        {
            DISPDBG((ERRLVL,"D3DGetDriverState dwLength=%d is not sufficient",
                            pgdsd->dwLength));
            return DDHAL_DRIVER_NOTHANDLED;
        }

        pContext = _D3D_CTX_HandleToPtr(pgdsd->dwhContext);

        // Check if we got a valid context handle.
        if (!CHECK_D3DCONTEXT_VALIDITY(pContext))
        {
            pgdsd->ddRVal = D3DHAL_CONTEXT_BAD;
            DISPDBG((ERRLVL,"ERROR: Context not valid"));
            DBG_CB_EXIT(D3DGetDriverState, D3DHAL_CONTEXT_BAD);
            return (DDHAL_DRIVER_HANDLED);
        }
        // As the state buffer area lives in user memory, we need to
        // access it bracketing it with a try/except block. This
        // is because the user memory might under some circumstances
        // become invalid while the driver is running and then it
        // would AV. Also, the driver might need to do some cleanup
        // before returning to the OS.
        __try
        {
            _D3D_TM_STAT_GetStats(pContext,
                                  (LPD3DDEVINFO_TEXTUREMANAGER)pgdsd->lpdwStates);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            // On this driver we don't need to do anything special
            DISPDBG((ERRLVL,"Driver caused exception at "
                            "line %u of file %s",
                            __LINE__,__FILE__));
            pgdsd->ddRVal = DDERR_GENERIC;    
            DBG_CB_EXIT(D3DGetDriverState,0);         
            return DDHAL_DRIVER_NOTHANDLED; 
        } 

        pgdsd->ddRVal = DD_OK;            
        
        DBG_CB_EXIT(D3DGetDriverState,0);         
        return DDHAL_DRIVER_HANDLED;         
    }
                          
#endif // DX7_TEXMANAGEMENT_STATS

    // Fall trough for any unhandled DEVICEINFOID's
    
    DISPDBG((ERRLVL,"D3DGetDriverState DEVICEINFOID=%08lx not supported",
                    pgdsd->dwFlags));

    pgdsd->ddRVal = DDERR_UNSUPPORTED;

    DBG_CB_EXIT(D3DGetDriverState,0);                     
    return DDHAL_DRIVER_NOTHANDLED;
    
} // D3DGetDriverState

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
//-----------------------------------------------------------------------------
//
// _D3D_ST_CanRenderAntialiased
//
// Called when the D3DRENDERSTATE_ANTIALIAS RS is set to TRUE.
//
//-----------------------------------------------------------------------------
BOOL
_D3D_ST_CanRenderAntialiased(
    P3_D3DCONTEXT*   pContext,
    BOOL             bNewAliasBuffer)
{
    P3_SOFTWARECOPY* pSoftPermedia = &pContext->SoftCopyGlint;
    P3_THUNKEDDATA *pThisDisplay = pContext->pThisDisplay;
    P3_MEMREQUEST mmrq;
    DWORD dwResult;

    P3_DMA_DEFS();

#if DX8_MULTISAMPLING
    // Only 4 multisampling is supported
    // And DX7 does not specifiy the number of samples.

    if (pContext->pSurfRenderInt->dwSampling != 4)
    {
        return FALSE;
    }
#endif // DX8_MULTISAMPLING

    // Only allow AA rendering for 16-bit framebuffers with width and
    // height no larger than 1024. The size restriction comes because
    // later on we use the texture unit in order to shrink and filter
    // the resulting rendertarget. Since the maximum texture size
    // allowed in this hw is 2048, the maximum rendertarget we suppport
    // with antialiasing is 1024.
    if ((pContext->pSurfRenderInt->dwPixelSize != __GLINT_16BITPIXEL) ||
        (pContext->pSurfRenderInt->wWidth > 1024) ||
        (pContext->pSurfRenderInt->wHeight > 1024))
    {
        return FALSE;
    }

    // Do we need to release the current alias buffer
    if (bNewAliasBuffer) 
    {
        if (pContext->dwAliasBackBuffer != 0)
        {
            _DX_LIN_FreeLinearMemory(&pThisDisplay->LocalVideoHeap0Info,
                                     pContext->dwAliasBackBuffer);
            pContext->dwAliasBackBuffer = 0;
            pContext->dwAliasPixelOffset = 0;
        }
    
        if (pContext->dwAliasZBuffer != 0)
        {
            _DX_LIN_FreeLinearMemory(&pThisDisplay->LocalVideoHeap0Info,
                                     pContext->dwAliasZBuffer);
            pContext->dwAliasZBuffer = 0;
            pContext->dwAliasZPixelOffset = 0;
        }
    }

    if ((pContext->pSurfRenderInt) && (! pContext->dwAliasBackBuffer))
    {
        // Allocate a 2x buffer if we need to
        memset(&mmrq, 0, sizeof(P3_MEMREQUEST));
        mmrq.dwSize = sizeof(P3_MEMREQUEST);
        mmrq.dwBytes = pContext->pSurfRenderInt->lPitch * 2 *
                       pContext->pSurfRenderInt->wHeight * 2;
        mmrq.dwAlign = 8;
        mmrq.dwFlags = MEM3DL_FIRST_FIT;
        mmrq.dwFlags |= MEM3DL_FRONT;
        dwResult = _DX_LIN_AllocateLinearMemory(
                                &pThisDisplay->LocalVideoHeap0Info,
                                &mmrq);
                        
        // Did we get the memory we asked for?
        if (dwResult != GLDD_SUCCESS)
        {
            return FALSE;
        }
    
        // Set up new backbuffer for antialiasing
        pContext->dwAliasBackBuffer = mmrq.pMem;
        pContext->dwAliasPixelOffset = 
                pContext->dwAliasBackBuffer - 
                pThisDisplay->dwScreenFlatAddr;
    }

    if ((pContext->pSurfZBufferInt) && (! pContext->dwAliasZBuffer))
    {
        memset(&mmrq, 0, sizeof(P3_MEMREQUEST));
        mmrq.dwSize = sizeof(P3_MEMREQUEST);
        mmrq.dwBytes = pContext->pSurfZBufferInt->lPitch * 2 * 
                       pContext->pSurfZBufferInt->wHeight * 2;
        mmrq.dwAlign = 8;
        mmrq.dwFlags = MEM3DL_FIRST_FIT;
        mmrq.dwFlags |= MEM3DL_FRONT;

        dwResult = _DX_LIN_AllocateLinearMemory(
                        &pThisDisplay->LocalVideoHeap0Info, 
                        &mmrq);

        // Did we get the memory we asked for?
        if (dwResult == GLDD_SUCCESS)
        {
            pContext->dwAliasZBuffer = mmrq.pMem;
            pContext->dwAliasZPixelOffset = 
                        pContext->dwAliasZBuffer
                            - pThisDisplay->dwScreenFlatAddr;
        }
        else
        {
            // Couldn't get the antialiasing memory for the backbuffer
            if (pContext->dwAliasBackBuffer != 0)
            {
                _DX_LIN_FreeLinearMemory(
                            &pThisDisplay->LocalVideoHeap0Info, 
                            pContext->dwAliasBackBuffer);
                pContext->dwAliasBackBuffer = 0;
                pContext->dwAliasPixelOffset = 0;
            }

            // No enough resource for antialisde rendering
            return FALSE;
        }
    }

    return TRUE;
    
} // _D3D_ST_CanRenderAntialiased
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS

//-----------------------------------------------------------------------------
//
// __ST_HandleDirtyP3State
//
// Setup any pending hardware state necessary to correctly render our primitives
//
//-----------------------------------------------------------------------------
void 
__ST_HandleDirtyP3State(
    P3_THUNKEDDATA *pThisDisplay, 
    P3_D3DCONTEXT *pContext)
{
    P3_SOFTWARECOPY* pSoftP3RX = &pContext->SoftCopyGlint;
    P3_DMA_DEFS();

    DISPDBG((DBGLVL,"Permedia context Dirtied, setting states:"));

    // ********************************************************************
    // NOTE: MAINTAIN STRICT ORDERING OF THESE EVALUATIONS FOR HW REASONS!!
    // ********************************************************************
    if (pContext->dwDirtyFlags == CONTEXT_DIRTY_EVERYTHING)
    {
        // Everything needs re-doing - re-set the blend status.
        RESET_BLEND_ERROR(pContext);
    }
    
    //*********************************************************
    // Has the z buffer/stencil buffer configuration changed ???
    //*********************************************************
    if ((pContext->dwDirtyFlags & CONTEXT_DIRTY_ZBUFFER) ||
        (pContext->dwDirtyFlags & CONTEXT_DIRTY_STENCIL))
    {

        if ( ( (pContext->RenderStates[D3DRENDERSTATE_ZENABLE] == D3DZB_TRUE)
               || (pContext->RenderStates[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW) )
             && (pContext->pSurfZBufferInt) )
        {
            // This includes W buffering as well as Z buffering.
            // The actual W-specific stuff is set up later.
            if (pContext->RenderStates[D3DRENDERSTATE_ZWRITEENABLE] == TRUE)
            {
                switch ((int)pSoftP3RX->P3RXDepthMode.CompareMode)
                {
                    case __GLINT_DEPTH_COMPARE_MODE_ALWAYS:
                        // Although it seems as though the ReadDestination can be
                        // disabled, it can't.  The result isn't correct because the
                        // chip does a compare on the current value as an optimization
                        // for updating the Z [CM].

                        // NOTE! The P3 can actually do the optimisation if you
                        // use some other flags. This needs fixing in the future.
                        DISPDBG((ERRLVL,"** __ST_HandleDirtyP3State: "
                                     "please optimise the ZCMP_ALWAYS case"));

                        pSoftP3RX->P3RXLBWriteMode.WriteEnable = __PERMEDIA_ENABLE;
                        pSoftP3RX->P3RXLBDestReadMode.Enable = __PERMEDIA_ENABLE;
                        pSoftP3RX->P3RXDepthMode.WriteMask = __PERMEDIA_ENABLE;
                        break;
                    case __GLINT_DEPTH_COMPARE_MODE_NEVER:
                        pSoftP3RX->P3RXLBWriteMode.WriteEnable = __PERMEDIA_DISABLE;
                        pSoftP3RX->P3RXLBDestReadMode.Enable = __PERMEDIA_DISABLE;
                        pSoftP3RX->P3RXDepthMode.WriteMask = __PERMEDIA_DISABLE;
                        break;
                    default:
                        pSoftP3RX->P3RXLBWriteMode.WriteEnable = __PERMEDIA_ENABLE;
                        pSoftP3RX->P3RXLBDestReadMode.Enable = __PERMEDIA_ENABLE;
                        pSoftP3RX->P3RXDepthMode.WriteMask = __PERMEDIA_ENABLE;
                        break;
                }
            }
            else
            {
                if ( ( pSoftP3RX->P3RXDepthMode.CompareMode == __GLINT_DEPTH_COMPARE_MODE_NEVER )
                  || ( pSoftP3RX->P3RXDepthMode.CompareMode == __GLINT_DEPTH_COMPARE_MODE_ALWAYS ) )
                {
                    pSoftP3RX->P3RXLBDestReadMode.Enable = __PERMEDIA_DISABLE;
                }
                else
                {
                    pSoftP3RX->P3RXLBDestReadMode.Enable = __PERMEDIA_ENABLE;
                }
                pSoftP3RX->P3RXLBWriteMode.WriteEnable = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXDepthMode.WriteMask = __PERMEDIA_DISABLE;
            }

            // Enable Z test
            pSoftP3RX->P3RXDepthMode.Enable = __PERMEDIA_ENABLE;
        }
        else
        {
            // ** Not Z Buffering
            // Disable Writes
            pSoftP3RX->P3RXLBWriteMode.WriteEnable = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXDepthMode.WriteMask = __PERMEDIA_DISABLE;

            // Disable Z test
            pSoftP3RX->P3RXDepthMode.Enable = __PERMEDIA_DISABLE;
            
            // No reads
            pSoftP3RX->P3RXLBDestReadMode.Enable = __PERMEDIA_DISABLE;
        }

        if (pContext->RenderStates[D3DRENDERSTATE_STENCILENABLE] != TRUE)
        {
            DISPDBG((DBGLVL,"Disabling Stencil"));
            pSoftP3RX->P3RXStencilMode.Enable = __PERMEDIA_DISABLE;

        }
        else
        {
            DISPDBG((DBGLVL,"Enabling Stencil"));
            pSoftP3RX->P3RXStencilMode.Enable = __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXLBDestReadMode.Enable = __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXLBWriteMode.WriteEnable = __PERMEDIA_ENABLE;

            switch(pContext->RenderStates[D3DRENDERSTATE_STENCILFAIL])
            {
                case D3DSTENCILOP_KEEP:
                    pSoftP3RX->P3RXStencilMode.SFail = __GLINT_STENCIL_METHOD_KEEP;
                    break;
                case D3DSTENCILOP_ZERO:
                    pSoftP3RX->P3RXStencilMode.SFail = __GLINT_STENCIL_METHOD_ZERO;
                    break;
                case D3DSTENCILOP_REPLACE:
                    pSoftP3RX->P3RXStencilMode.SFail = __GLINT_STENCIL_METHOD_REPLACE;
                    break;
                case D3DSTENCILOP_INCR:
                    pSoftP3RX->P3RXStencilMode.SFail = __GLINT_STENCIL_METHOD_INCR_WRAP;
                    break;
                case D3DSTENCILOP_INCRSAT:
                    pSoftP3RX->P3RXStencilMode.SFail = __GLINT_STENCIL_METHOD_INCR;
                    break;
                case D3DSTENCILOP_DECR:
                    pSoftP3RX->P3RXStencilMode.SFail = __GLINT_STENCIL_METHOD_DECR_WRAP;
                    break;
                case D3DSTENCILOP_DECRSAT:
                    pSoftP3RX->P3RXStencilMode.SFail = __GLINT_STENCIL_METHOD_DECR;
                    break;
                case D3DSTENCILOP_INVERT:
                    pSoftP3RX->P3RXStencilMode.SFail = __GLINT_STENCIL_METHOD_INVERT;
                    break;
                default:
                    DISPDBG((ERRLVL,"ERROR: Illegal D3DRENDERSTATE_STENCILFAIL!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }

            switch(pContext->RenderStates[D3DRENDERSTATE_STENCILZFAIL])
            {
                case D3DSTENCILOP_KEEP:
                    pSoftP3RX->P3RXStencilMode.DPFail = __GLINT_STENCIL_METHOD_KEEP;
                    break;
                case D3DSTENCILOP_ZERO:
                    pSoftP3RX->P3RXStencilMode.DPFail = __GLINT_STENCIL_METHOD_ZERO;
                    break;
                case D3DSTENCILOP_REPLACE:
                    pSoftP3RX->P3RXStencilMode.DPFail = __GLINT_STENCIL_METHOD_REPLACE;
                    break;
                case D3DSTENCILOP_INCR:
                    pSoftP3RX->P3RXStencilMode.DPFail = __GLINT_STENCIL_METHOD_INCR_WRAP;
                    break;
                case D3DSTENCILOP_INCRSAT:
                    pSoftP3RX->P3RXStencilMode.DPFail = __GLINT_STENCIL_METHOD_INCR;
                    break;
                case D3DSTENCILOP_DECR:
                    pSoftP3RX->P3RXStencilMode.DPFail = __GLINT_STENCIL_METHOD_DECR_WRAP;
                    break;
                case D3DSTENCILOP_DECRSAT:
                    pSoftP3RX->P3RXStencilMode.DPFail = __GLINT_STENCIL_METHOD_DECR;
                    break;
                case D3DSTENCILOP_INVERT:
                    pSoftP3RX->P3RXStencilMode.DPFail = __GLINT_STENCIL_METHOD_INVERT;
                    break;
                default:
                    DISPDBG((ERRLVL,"ERROR: Illegal D3DRENDERSTATE_STENCILZFAIL!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }

            switch(pContext->RenderStates[D3DRENDERSTATE_STENCILPASS])
            {
                case D3DSTENCILOP_KEEP:
                    pSoftP3RX->P3RXStencilMode.DPPass = __GLINT_STENCIL_METHOD_KEEP;
                    break;
                case D3DSTENCILOP_ZERO:
                    pSoftP3RX->P3RXStencilMode.DPPass = __GLINT_STENCIL_METHOD_ZERO;
                    break;
                case D3DSTENCILOP_REPLACE:
                    pSoftP3RX->P3RXStencilMode.DPPass = __GLINT_STENCIL_METHOD_REPLACE;
                    break;
                case D3DSTENCILOP_INCR:
                    pSoftP3RX->P3RXStencilMode.DPPass = __GLINT_STENCIL_METHOD_INCR_WRAP;
                    break;
                case D3DSTENCILOP_INCRSAT:
                    pSoftP3RX->P3RXStencilMode.DPPass = __GLINT_STENCIL_METHOD_INCR;
                    break;
                case D3DSTENCILOP_DECR:
                    pSoftP3RX->P3RXStencilMode.DPPass = __GLINT_STENCIL_METHOD_DECR_WRAP;
                    break;
                case D3DSTENCILOP_DECRSAT:
                    pSoftP3RX->P3RXStencilMode.DPPass = __GLINT_STENCIL_METHOD_DECR;
                    break;
                case D3DSTENCILOP_INVERT:
                    pSoftP3RX->P3RXStencilMode.DPPass = __GLINT_STENCIL_METHOD_INVERT;
                    break;
                default:
                    DISPDBG((ERRLVL,"ERROR: Illegal D3DRENDERSTATE_STENCILPASS!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }

            switch (pContext->RenderStates[D3DRENDERSTATE_STENCILFUNC])
            {
                case D3DCMP_NEVER:
                    pSoftP3RX->P3RXStencilMode.CompareFunction = __GLINT_STENCIL_COMPARE_MODE_NEVER;
                    break;
                case D3DCMP_LESS:
                    pSoftP3RX->P3RXStencilMode.CompareFunction = __GLINT_STENCIL_COMPARE_MODE_LESS;
                    break;
                case D3DCMP_EQUAL:
                    pSoftP3RX->P3RXStencilMode.CompareFunction = __GLINT_STENCIL_COMPARE_MODE_EQUAL;
                    break;
                case D3DCMP_LESSEQUAL:
                    pSoftP3RX->P3RXStencilMode.CompareFunction = __GLINT_STENCIL_COMPARE_MODE_LESS_OR_EQUAL;
                    break;
                case D3DCMP_GREATER:
                    pSoftP3RX->P3RXStencilMode.CompareFunction = __GLINT_STENCIL_COMPARE_MODE_GREATER;
                    break;
                case D3DCMP_NOTEQUAL:
                    pSoftP3RX->P3RXStencilMode.CompareFunction = __GLINT_STENCIL_COMPARE_MODE_NOT_EQUAL;
                    break;
                case D3DCMP_GREATEREQUAL:
                    pSoftP3RX->P3RXStencilMode.CompareFunction = __GLINT_STENCIL_COMPARE_MODE_GREATER_OR_EQUAL;
                    break;
                case D3DCMP_ALWAYS:
                    pSoftP3RX->P3RXStencilMode.CompareFunction = __GLINT_STENCIL_COMPARE_MODE_ALWAYS;
                    break;
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown D3DRENDERSTATE_STENCILFUNC!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }

            pSoftP3RX->P3RXStencilData.StencilWriteMask = (pContext->RenderStates[D3DRENDERSTATE_STENCILWRITEMASK] & 0xFF);
            pSoftP3RX->P3RXStencilData.CompareMask = (pContext->RenderStates[D3DRENDERSTATE_STENCILMASK] & 0xFF);
            pSoftP3RX->P3RXStencilData.ReferenceValue = (pContext->RenderStates[D3DRENDERSTATE_STENCILREF] & 0xFF);
        }

        P3_DMA_GET_BUFFER();
        P3_ENSURE_DX_SPACE(32);

        WAIT_FIFO(32);

        COPY_P3_DATA(DepthMode, pSoftP3RX->P3RXDepthMode);
        COPY_P3_DATA(LBDestReadMode, pSoftP3RX->P3RXLBDestReadMode);
        COPY_P3_DATA(LBWriteMode, pSoftP3RX->P3RXLBWriteMode);
        COPY_P3_DATA(LBReadFormat, pSoftP3RX->P3RXLBReadFormat);
        COPY_P3_DATA(LBWriteFormat, pSoftP3RX->P3RXLBWriteFormat);
        COPY_P3_DATA(StencilData, pSoftP3RX->P3RXStencilData);
        COPY_P3_DATA(StencilMode, pSoftP3RX->P3RXStencilMode);

        P3_DMA_COMMIT_BUFFER();
    }

    //*********************************************************
    // Has the alphatest type changed?
    //*********************************************************
    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_ALPHATEST)
    {
        DISPDBG((DBGLVL,"  Alpha testing"));

        P3_DMA_GET_BUFFER();
        P3_ENSURE_DX_SPACE(2);

        WAIT_FIFO(2);
        
        if (pContext->RenderStates[D3DRENDERSTATE_ALPHATESTENABLE] == FALSE)
        {
            pSoftP3RX->P3RXAlphaTestMode.Enable = __PERMEDIA_DISABLE;
            DISPDBG((DBGLVL,"Alpha test disabled, ChromaTest = %d",
                            pContext->RenderStates[D3DRENDERSTATE_COLORKEYENABLE] ));
        }
        else
        {
            unsigned char ucChipAlphaRef;
            DWORD dwAlphaRef;

            if( pThisDisplay->dwDXVersion <= DX5_RUNTIME )
            {
                // Form 8 bit alpha reference value by scaling 1.16 fixed point to 0.8
                dwAlphaRef = pContext->RenderStates[D3DRENDERSTATE_ALPHAREF];

                // This conversion may need tweaking to cope with individual
                // apps' expectations. Fortunately, it's DX5 only, so there
                // are a finite number of them.
                if ( dwAlphaRef == 0x0000 )
                {
                    ucChipAlphaRef = 0x00;
                }
                else if ( dwAlphaRef < 0xfe00 )
                {
                    // Add the inverted top char to the bottom char, so that
                    // the rounding changes smoothly all the way up to 0xfe00.
                    dwAlphaRef += ~( dwAlphaRef >> 8 );
                    ucChipAlphaRef = (unsigned char)( dwAlphaRef >> 8 );
                }
                else if ( dwAlphaRef < 0xffff )
                {
                    // Clamp to make sure only 0xffff -> 0xff
                    ucChipAlphaRef = 0xfe;
                }
                else
                {
                    ucChipAlphaRef = 0xff;
                }

                DISPDBG((DBGLVL,"Alpha test enabled: Value = 0x%x, ChipAlphaRef = 0x%x",
                           pContext->RenderStates[D3DRENDERSTATE_ALPHAREF], 
                           ucChipAlphaRef ));
            }
            else
            {
                // ALPHAREF is an 8 bit value on input - just copy straight into the chip
                dwAlphaRef = (unsigned char)pContext->RenderStates[D3DRENDERSTATE_ALPHAREF];
                if ( dwAlphaRef > 0xff )
                {
                    ucChipAlphaRef = 0xff;
                }
                else
                {
                    ucChipAlphaRef = (unsigned char)dwAlphaRef;
                }

                DISPDBG((DBGLVL,"Alpha test enabled: AlphaRef = 0x%x", ucChipAlphaRef ));
            }

            pSoftP3RX->P3RXAlphaTestMode.Reference = ucChipAlphaRef;
            pSoftP3RX->P3RXAlphaTestMode.Enable = __PERMEDIA_ENABLE;
            switch (pContext->RenderStates[D3DRENDERSTATE_ALPHAFUNC])
            {
                case D3DCMP_GREATER:
                    DISPDBG((DBGLVL,"GREATER Alpha Test"));
                    pSoftP3RX->P3RXAlphaTestMode.Compare = __GLINT_ALPHA_COMPARE_MODE_GREATER;
                    break;
                case D3DCMP_GREATEREQUAL:
                    DISPDBG((DBGLVL,"GREATEREQUAL Alpha Test"));
                    pSoftP3RX->P3RXAlphaTestMode.Compare = __GLINT_ALPHA_COMPARE_MODE_GREATER_OR_EQUAL;
                    break;
                case D3DCMP_LESS:
                    DISPDBG((DBGLVL,"LESS Alpha Test"));
                    pSoftP3RX->P3RXAlphaTestMode.Compare = __GLINT_ALPHA_COMPARE_MODE_LESS;
                    break;
                case D3DCMP_LESSEQUAL:
                    DISPDBG((DBGLVL,"LESSEQUAL Alpha Test"));
                    pSoftP3RX->P3RXAlphaTestMode.Compare = __GLINT_ALPHA_COMPARE_MODE_LESS_OR_EQUAL;
                    break;
                case D3DCMP_NOTEQUAL:
                    DISPDBG((DBGLVL,"NOTEQUAL Alpha Test"));
                    pSoftP3RX->P3RXAlphaTestMode.Compare = __GLINT_ALPHA_COMPARE_MODE_NOT_EQUAL;
                    break;
                case D3DCMP_EQUAL:
                    DISPDBG((DBGLVL,"EQUAL Alpha Test"));
                    pSoftP3RX->P3RXAlphaTestMode.Compare = __GLINT_ALPHA_COMPARE_MODE_EQUAL;
                    break;
                case D3DCMP_NEVER:
                    DISPDBG((DBGLVL,"NEVER Alpha Test"));
                    pSoftP3RX->P3RXAlphaTestMode.Compare = __GLINT_ALPHA_COMPARE_MODE_NEVER;
                    break;
                case D3DCMP_ALWAYS:
                    pSoftP3RX->P3RXAlphaTestMode.Compare = __GLINT_ALPHA_COMPARE_MODE_ALWAYS;
                    break;
                default:
                    DISPDBG((ERRLVL,"Unsuported AlphaTest mode"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }
        }
        COPY_P3_DATA(AlphaTestMode, pSoftP3RX->P3RXAlphaTestMode);

        P3_DMA_COMMIT_BUFFER();
    }
            
    //*********************************************************
    // Have the fogging parameters/state changed?
    //*********************************************************
    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_FOG)
    {
        if (!pContext->RenderStates[D3DRENDERSTATE_FOGENABLE])
        {
            pContext->Flags &= ~SURFACE_FOGENABLE;

            pSoftP3RX->P3RXFogMode.Table = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXFogMode.UseZ = __PERMEDIA_DISABLE;
            // Don't need delta to do fog value setup
            pSoftP3RX->P3RX_P3DeltaMode.FogEnable = __PERMEDIA_DISABLE;
            RENDER_FOG_DISABLE(pContext->RenderCommand);
        }
        else
        {
            DWORD CurrentEntry;
            DWORD TableEntry;
            float fEntry[256];
            float FogStart;
            float FogEnd;
            float FogDensity;
            LONG  lWaitFifoEntries;
            float fValue;
            float z;
            float zIncrement;
            DWORD dwFogTableMode = 
                        pContext->RenderStates[D3DRENDERSTATE_FOGTABLEMODE];
            DWORD dwFogColor = pContext->RenderStates[D3DRENDERSTATE_FOGCOLOR];

            // Enable fog in the render command
            pContext->Flags |= SURFACE_FOGENABLE;
            RENDER_FOG_ENABLE(pContext->RenderCommand);

            DISPDBG((DBGLVL,"FogColor (BGR): 0x%x", dwFogColor));
            
            P3_DMA_GET_BUFFER_ENTRIES(2)
            SEND_P3_DATA(FogColor, RGBA_MAKE(RGBA_GETBLUE (dwFogColor),
                                             RGBA_GETGREEN(dwFogColor),
                                             RGBA_GETRED  (dwFogColor),
                                             RGBA_GETALPHA(dwFogColor)) );
            P3_DMA_COMMIT_BUFFER();

            pSoftP3RX->P3RXFogMode.ZShift = 23; // Take the top 8 bits of the z value           

            switch (dwFogTableMode)
            {
            case D3DFOG_NONE:
                pSoftP3RX->P3RXFogMode.Table = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXFogMode.UseZ = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXFogMode.InvertFI = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RX_P3DeltaMode.FogEnable = __PERMEDIA_ENABLE;
                break;
            case D3DFOG_EXP:
            case D3DFOG_EXP2:
            case D3DFOG_LINEAR:
                pSoftP3RX->P3RXFogMode.Table = __PERMEDIA_ENABLE;
                pSoftP3RX->P3RXFogMode.UseZ = __PERMEDIA_ENABLE;
                pSoftP3RX->P3RXFogMode.InvertFI = __PERMEDIA_DISABLE;
                //pSoftP3RX->P3RX_P3DeltaMode.FogEnable = __PERMEDIA_DISABLE;                

                // Don't need delta to do fog value setup (z is used as fog lookup)
                pSoftP3RX->P3RX_P3DeltaMode.FogEnable = __PERMEDIA_DISABLE;

                FogStart = pContext->fRenderStates[D3DRENDERSTATE_FOGTABLESTART];
                FogEnd = pContext->fRenderStates[D3DRENDERSTATE_FOGTABLEEND];
                FogDensity = pContext->fRenderStates[D3DRENDERSTATE_FOGTABLEDENSITY];

                DISPDBG((DBGLVL,"FogStart = %d FogEnd = %d FogDensity = %d",
                                  (LONG)(FogStart*1000.0f),
                                  (LONG)(FogEnd*1000.0f),
                                  (LONG)(FogDensity*1000.0f) ));                           

                // Compute the fog tables in order to load the hw fog tables
                if (D3DFOG_LINEAR == dwFogTableMode)
                {
                    TableEntry = 0;
                    zIncrement = 1.0f / 255.0f;
                    z = 0.0f;

                    do
                    {
                        // Linear fog, so clamp top and bottom
                        if (z < FogStart) 
                        {
                            fValue = 1.0f;
                        }
                        else if (z > FogEnd)
                        {
                            fValue = 0.0f;
                        }
                        else 
                        {
                            // If the end == the start, don't fog
                            if (FogEnd == FogStart)
                            {   
                                fValue = 1.0f;
                            }
                            else
                            {
                                fValue = (FogEnd - z) / (FogEnd - FogStart);
                            }
                            ASSERTDD(fValue <= 1.0f, 
                                     "Error: Result to big");
                            ASSERTDD(fValue >= 0.0f, 
                                     "Error: Result negative");
                        }

                        // Scale the result to fill the 
                        // 8 bit range in the table
                        fValue = fValue * 255.0f;
                        fEntry[TableEntry++] = fValue;
                        z += zIncrement;
                    } while (TableEntry < 256);
                }
                else if (D3DFOG_EXP == dwFogTableMode)
                {
                    TableEntry = 0;
                    zIncrement = 1.0f / 255.0f;
                    z = 0.0f;
                    do
                    {
                        float fz;

                        fz = z * FogDensity;

                        fValue = myPow(math_e, -fz);
                                                        
                        if (fValue <= 0.0f) fValue = 0.0f;
                        if (fValue > 1.0f) fValue = 1.0f;

                        // Scale the result to fill the 
                        // 8 bit range in the table
                        fValue = fValue * 255.0f;
                        DISPDBG((DBGLVL,"Table Entry %d = %f, for Z = %f", 
                                        TableEntry, fValue, z));
                        fEntry[TableEntry++] = fValue;
                        z += zIncrement;
                    } while (TableEntry < 256);                     
                }
                else // must be if(D3DFOG_EXP2 == dwFogTableMode)
                {
                    TableEntry = 0;
                    zIncrement = 1.0f / 255.0f;
                    z = 0.0f;
                    do
                    {
                        float fz;

                        fz = z * FogDensity;

                        fValue = myPow(math_e, -(fz * fz));
                                                        
                        if (fValue <= 0.0f) fValue = 0.0f;
                        if (fValue > 1.0f) fValue = 1.0f;

                        // Scale the result to fill the 
                        // 8 bit range in the table
                        fValue = fValue * 255.0f;
                        DISPDBG((DBGLVL,"Table Entry %d = %f, for Z = %f", 
                                        TableEntry, fValue, z));
                        fEntry[TableEntry++] = fValue;
                        z += zIncrement;
                    } while (TableEntry < 256);                     
                }

                P3_DMA_GET_BUFFER();
                lWaitFifoEntries = 2;

                // Pack the fog entries into the chip's fog table
                CurrentEntry = 0;
                for (TableEntry = 0; TableEntry < 256; TableEntry += 4)
                {
                    DWORD Val[4];
                    DWORD dwValue;
                    myFtoi((int*)&Val[0], fEntry[TableEntry]);
                    myFtoi((int*)&Val[1], fEntry[TableEntry + 1]);
                    myFtoi((int*)&Val[2], fEntry[TableEntry + 2]);
                    myFtoi((int*)&Val[3], fEntry[TableEntry + 3]);
                    
                    lWaitFifoEntries -= 2;
                    if (lWaitFifoEntries < 2)
                    {
                        P3_ENSURE_DX_SPACE(32);
                        WAIT_FIFO(32);
                        lWaitFifoEntries += 32;
                    }

                    dwValue = ((Val[0]      ) | 
                               (Val[1] <<  8) | 
                               (Val[2] << 16) | 
                               (Val[3] << 24));                                  
                    
                    SEND_P3_DATA_OFFSET(FogTable0, 
                                        dwValue, 
                                        CurrentEntry++);                       
                }

                P3_DMA_COMMIT_BUFFER();
                break;
            default:
                DISPDBG((ERRLVL,"ERROR: Unknown fog table mode!"));
                SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                break;
            } // switch (dwFogTableMode)
        } // if (!pContext->RenderStates[D3DRENDERSTATE_FOGENABLE])

        P3_DMA_GET_BUFFER_ENTRIES(6);

        SEND_P3_DATA(ZFogBias, 0);
        COPY_P3_DATA(FogMode, pSoftP3RX->P3RXFogMode);
        COPY_P3_DATA(DeltaMode, pSoftP3RX->P3RX_P3DeltaMode);

        P3_DMA_COMMIT_BUFFER();
    } // if (pContext->dwDirtyFlags & CONTEXT_DIRTY_FOG)


    //*********************************************************
    // Has any other texture state changed?
    //*********************************************************    
    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_TEXTURE)
    {
        DISPDBG((DBGLVL,"  Texture State"));
        _D3DChangeTextureP3RX(pContext);
        DIRTY_GAMMA_STATE;
    }


    //*********************************************************
    // Has the alphablend type changed?
    //*********************************************************           
    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_ALPHABLEND)
    {
        // This _must_ be done after where _D3DChangeTextureP3RX is done,
        // because it might need to change behaviour depending on
        // the D3D pipeline.    
        
        P3_DMA_GET_BUFFER_ENTRIES(6);

        if (pContext->RenderStates[D3DRENDERSTATE_BLENDENABLE] == FALSE)
        {
            if ( pContext->bAlphaBlendMustDoubleSourceColour )
            {
                // We need to double the source colour, even with no other blend.
                pSoftP3RX->P3RXAlphaBlendAlphaMode.Enable = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXAlphaBlendColorMode.Enable = __PERMEDIA_ENABLE;
                pSoftP3RX->P3RXFBDestReadMode.ReadEnable = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_ONE;
                pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_ZERO;
                pSoftP3RX->P3RXAlphaBlendColorMode.SourceTimesTwo = __PERMEDIA_ENABLE;
                pSoftP3RX->P3RXAlphaBlendColorMode.DestTimesTwo = __PERMEDIA_DISABLE;
            }
            else
            {
                pSoftP3RX->P3RXAlphaBlendAlphaMode.Enable = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXAlphaBlendColorMode.Enable = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXFBDestReadMode.ReadEnable = __PERMEDIA_DISABLE;
            }
        }
        else
        {
            BOOL bSrcUsesDst, bSrcUsesSrc, bDstUsesSrc, bDstUsesDst;

            pSoftP3RX->P3RXAlphaBlendAlphaMode.Enable = __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXAlphaBlendColorMode.Enable = __PERMEDIA_ENABLE;

            if ( pContext->bAlphaBlendMustDoubleSourceColour )
            {
                pSoftP3RX->P3RXAlphaBlendColorMode.SourceTimesTwo = __PERMEDIA_ENABLE;
            }
            else
            {
                pSoftP3RX->P3RXAlphaBlendColorMode.SourceTimesTwo = __PERMEDIA_DISABLE;
            }

            pSoftP3RX->P3RXAlphaBlendColorMode.DestTimesTwo = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceTimesTwo = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXAlphaBlendAlphaMode.DestTimesTwo = __PERMEDIA_DISABLE;

            // Assumptions. Will be overridden below in certain cases.
            // AusesB means that the A blend function uses the B data.
            bSrcUsesSrc = TRUE;
            bDstUsesSrc = FALSE;
            bSrcUsesDst = FALSE;
            bDstUsesDst = TRUE;

            switch (pContext->RenderStates[D3DRENDERSTATE_SRCBLEND])
            {
                case D3DBLEND_BOTHSRCALPHA:
                    bDstUsesSrc = TRUE;
                    pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_SRC_ALPHA;
                    pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_ONE_MINUS_SRC_ALPHA;
                    pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_SRC_ALPHA;
                    pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = __GLINT_BLEND_FUNC_ONE_MINUS_SRC_ALPHA;
                    break;
                case D3DBLEND_BOTHINVSRCALPHA:
                    bDstUsesSrc = TRUE;
                    pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_ONE_MINUS_SRC_ALPHA;
                    pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_SRC_ALPHA;
                    pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_ONE_MINUS_SRC_ALPHA;
                    pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = __GLINT_BLEND_FUNC_SRC_ALPHA;
                    break;
                default:
                    // Not a short-hand blend mode, look at source and dest
                    switch (pContext->RenderStates[D3DRENDERSTATE_SRCBLEND])
                    {
                        case D3DBLEND_ZERO:
                            bSrcUsesSrc = FALSE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_ZERO;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_ZERO;
                            break;
                        case D3DBLEND_SRCCOLOR:
                            DISPDBG((ERRLVL,"Invalid Source Blend on P3RX D3DBLEND_SRCCOLOR"));
                        case D3DBLEND_INVSRCCOLOR:
                            DISPDBG((ERRLVL,"Invalid Source Blend on P3RX D3DBLEND_INVSRCCOLOR"));
                            //azn SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_ALPHA_BLEND );
                            // fall through 
                        case D3DBLEND_ONE:
                            pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_ONE;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_ONE;
                            break;
                        case D3DBLEND_SRCALPHA:
                            pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_SRC_ALPHA;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_SRC_ALPHA;
                            break;
                        case D3DBLEND_INVSRCALPHA:
                            pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_ONE_MINUS_SRC_ALPHA;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_ONE_MINUS_SRC_ALPHA;
                            break;
                        case D3DBLEND_DESTALPHA:
                            bSrcUsesDst = TRUE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_DST_ALPHA;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_DST_ALPHA;                            
                            break;
                        case D3DBLEND_INVDESTALPHA:
                            bSrcUsesDst = TRUE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_ONE_MINUS_DST_ALPHA;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_ONE_MINUS_DST_ALPHA;
                            break;
                        case D3DBLEND_DESTCOLOR:
                            bSrcUsesDst = TRUE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_DST_COLOR;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_DST_COLOR;
                            break;
                        case D3DBLEND_INVDESTCOLOR:
                            bSrcUsesDst = TRUE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_ONE_MINUS_DST_COLOR;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_ONE_MINUS_DST_COLOR;
                            break;
                        case D3DBLEND_SRCALPHASAT:
                            bSrcUsesDst = TRUE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.SourceBlend = __GLINT_BLEND_FUNC_SRC_ALPHA_SATURATE;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.SourceBlend = __GLINT_BLEND_FUNC_SRC_ALPHA_SATURATE;
                            break;
                        default:
                            DISPDBG((ERRLVL,"Unknown Source Blend on P3RX"));
                            SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_ALPHA_BLEND );
                            break;
                    }

                    switch(pContext->RenderStates[D3DRENDERSTATE_DESTBLEND])
                    {
                        case D3DBLEND_ZERO:
                            bDstUsesDst = FALSE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_ZERO;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = __GLINT_BLEND_FUNC_ZERO;
                            break;
                        case D3DBLEND_DESTCOLOR:
                            DISPDBG((ERRLVL,"Invalid Source Blend on P3RX %d D3DBLEND_DESTCOLOR"));
                        case D3DBLEND_INVDESTCOLOR:
                            DISPDBG((ERRLVL,"Invalid Source Blend on P3RX %d D3DBLEND_INVDESTCOLOR"));
                            //azn SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_ALPHA_BLEND );
                            // fall through 
                        case D3DBLEND_ONE:
                            pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_ONE;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = __GLINT_BLEND_FUNC_ONE;
                            break;
                        case D3DBLEND_SRCCOLOR:
                            bDstUsesSrc = TRUE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_SRC_COLOR;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = __GLINT_BLEND_FUNC_SRC_COLOR;
                            if ( pContext->bAlphaBlendMustDoubleSourceColour )
                            {
                                // SRCCOLOR needs to be doubled.
                                pSoftP3RX->P3RXAlphaBlendColorMode.DestTimesTwo = __PERMEDIA_ENABLE;
                            }
                            break;
                        case D3DBLEND_INVSRCCOLOR:
                            bDstUsesSrc = TRUE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_ONE_MINUS_SRC_COLOR;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = __GLINT_BLEND_FUNC_ONE_MINUS_SRC_COLOR;
                            if ( pContext->bAlphaBlendMustDoubleSourceColour )
                            {
                                // Can't do this. What they want is:
                                // (1-(srccolor * 2))*destcolor
                                // = destcolor - 2*srccolor*destcolor
                                // All we can do is:
                                // (1-srccolor)*destcolor*2
                                // = destcolor*2 - 2*srccolor*destcolor
                                // ...which is a very different thing of course.
                                // Fail the blend.
                                SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_COLOR_OP_HERE );
                            }
                            break;
                        case D3DBLEND_SRCALPHA:
                            bDstUsesSrc = TRUE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_SRC_ALPHA;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = __GLINT_BLEND_FUNC_SRC_ALPHA;
                            break;
                        case D3DBLEND_INVSRCALPHA:
                            bDstUsesSrc = TRUE;
                            pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_ONE_MINUS_SRC_ALPHA;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = __GLINT_BLEND_FUNC_ONE_MINUS_SRC_ALPHA;
                            break;
                        case D3DBLEND_DESTALPHA:
                            pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_DST_ALPHA;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = __GLINT_BLEND_FUNC_DST_ALPHA;
                            break;
                        case D3DBLEND_INVDESTALPHA:
                            pSoftP3RX->P3RXAlphaBlendColorMode.DestBlend = __GLINT_BLEND_FUNC_ONE_MINUS_DST_ALPHA;
                            pSoftP3RX->P3RXAlphaBlendAlphaMode.DestBlend = __GLINT_BLEND_FUNC_ONE_MINUS_DST_ALPHA;
                            break;
                        default:
                            DISPDBG((ERRLVL,"Unknown Destination Blend on P3RX"));
                            SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                            break;
                    }
                    break;
            }

            if ( bSrcUsesDst || bDstUsesDst )
            {
                // Yep, using the destination data.
                pSoftP3RX->P3RXFBDestReadMode.ReadEnable = __PERMEDIA_ENABLE;
            }
            else
            {
                pSoftP3RX->P3RXFBDestReadMode.ReadEnable = __PERMEDIA_DISABLE;
            }

            // We need to verify if the blending mode will use the alpha 
            // channel of the destination fragment (buffer) and if the buffer
            // does in fact have an alpha buffer. If not, we need to make sure
            // hw will assume this value == 1.0 (0xFF in ARGB). 
            // The D3DBLEND_SRCALPHASAT blend mode also involves the 
            // destination alpha
            
            pSoftP3RX->P3RXAlphaBlendAlphaMode.NoAlphaBuffer = __PERMEDIA_DISABLE;                
            
            if ((pContext->RenderStates[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_INVDESTALPHA) ||
                (pContext->RenderStates[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_DESTALPHA)    ||
                (pContext->RenderStates[D3DRENDERSTATE_SRCBLEND]  == D3DBLEND_INVDESTALPHA) ||
                (pContext->RenderStates[D3DRENDERSTATE_SRCBLEND]  == D3DBLEND_DESTALPHA)   ||
                (pContext->RenderStates[D3DRENDERSTATE_SRCBLEND]  == D3DBLEND_SRCALPHASAT))
            {
                if (!pContext->pSurfRenderInt->pFormatSurface->bAlpha)
                {
                    pSoftP3RX->P3RXAlphaBlendAlphaMode.NoAlphaBuffer = __PERMEDIA_ENABLE;
                }
            }

            // We could now check if the src data is ever used. If not, bin
            // the whole previous pipeline! But this rarely happens.
            // A case where it might is if they are updating just the Z buffer,
            // but not changing the picture (e.g. for mirrors or portals).
        }

        COPY_P3_DATA(AlphaBlendAlphaMode, pSoftP3RX->P3RXAlphaBlendAlphaMode);
        COPY_P3_DATA(AlphaBlendColorMode, pSoftP3RX->P3RXAlphaBlendColorMode);
        COPY_P3_DATA(FBDestReadMode, pSoftP3RX->P3RXFBDestReadMode);

        P3_DMA_COMMIT_BUFFER();
    }

    //*********************************************************
    // Have w buffering parameters changed?
    //********************************************************* 
    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_WBUFFER)
    {
        float noverf;
        float NF_factor;

        if ( (pContext->RenderStates[D3DRENDERSTATE_ZENABLE] == D3DZB_USEW) && 
             (pContext->pSurfZBufferInt) )
        {
            DISPDBG((DBGLVL,"WBuffer wNear: %f, wFar: %f", 
                             pContext->WBufferInfo.dvWNear, 
                             pContext->WBufferInfo.dvWFar));

            noverf = (pContext->WBufferInfo.dvWNear / 
                                        pContext->WBufferInfo.dvWFar);
            NF_factor = (1.0 / 256.0);

            // Compare range in decending order.
            // Note that Exponent Width is determined 
            // as DepthMode.ExponentWidth +1

            if (noverf >= (myPow(2,-0) * NF_factor))
            {
                // Use linear Z
                pSoftP3RX->P3RXDepthMode.NonLinearZ = FALSE;
            }
            else if (noverf >= (myPow(2,-1) * NF_factor))
            {
                // Use exp width 1, exp scale 2
                pSoftP3RX->P3RXDepthMode.ExponentWidth = 0;
                pSoftP3RX->P3RXDepthMode.ExponentScale = 2;
                pSoftP3RX->P3RXDepthMode.NonLinearZ = TRUE;
            }
            else if (noverf >= (myPow(2,-3) * NF_factor))
            {
                // Use exp width 2, exp scale 1
                pSoftP3RX->P3RXDepthMode.ExponentWidth = 1;
                pSoftP3RX->P3RXDepthMode.ExponentScale = 1;
                pSoftP3RX->P3RXDepthMode.NonLinearZ = TRUE;
            }
            else if (noverf >= (myPow(2,-4) * NF_factor))
            {
                // Use exp width 2, exp scale 2
                pSoftP3RX->P3RXDepthMode.ExponentWidth = 1;
                pSoftP3RX->P3RXDepthMode.ExponentScale = 2;
                pSoftP3RX->P3RXDepthMode.NonLinearZ = TRUE;
            }
            else if (noverf >= (myPow(2,-7) * NF_factor))
            {
                // Use exp width 3, exp scale 1
                pSoftP3RX->P3RXDepthMode.ExponentWidth = 2;
                pSoftP3RX->P3RXDepthMode.ExponentScale = 1;
                pSoftP3RX->P3RXDepthMode.NonLinearZ = TRUE;
            }
            else
            {
                // Use exp width 3, exp scale 2
                pSoftP3RX->P3RXDepthMode.ExponentWidth = 3;
                pSoftP3RX->P3RXDepthMode.ExponentScale = 2;
                pSoftP3RX->P3RXDepthMode.NonLinearZ = TRUE;
            }

        }
        else
        {
            pSoftP3RX->P3RXDepthMode.NonLinearZ = FALSE;
        }

        P3_DMA_GET_BUFFER_ENTRIES(2);
        COPY_P3_DATA(DepthMode, pSoftP3RX->P3RXDepthMode);
        P3_DMA_COMMIT_BUFFER();
    }

    //*********************************************************
    // Have the rendertarget/ z buffer address changed?
    //********************************************************* 
    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_RENDER_OFFSETS)
    {
        DISPDBG((DBGLVL,"  Render Offsets"));
        _D3D_OP_SetRenderTarget(pContext, 
                                pContext->pSurfRenderInt, 
                                pContext->pSurfZBufferInt,
                                FALSE);

        P3_DMA_GET_BUFFER_ENTRIES(2);
        COPY_P3_DATA(DeltaControl, pSoftP3RX->P3RX_P3DeltaControl);
        P3_DMA_COMMIT_BUFFER();
    }

    //*********************************************************
    // Have the viewport parameters changed?
    //********************************************************* 
    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_VIEWPORT)
    {
        P3_DMA_GET_BUFFER_ENTRIES(12);

        DISPDBG((DBGLVL,"Viewport left: %d, top: %d, width: %d, height: %d",
                        pContext->ViewportInfo.dwX,
                        pContext->ViewportInfo.dwY,
                        pContext->ViewportInfo.dwWidth,
                        pContext->ViewportInfo.dwHeight));

        // If a valid viewport is setup, scissor it
        if ((pContext->ViewportInfo.dwWidth != 0) &&
            (pContext->ViewportInfo.dwHeight != 0))
        {
#if DX8_MULTISAMPLING || DX7_ANTIALIAS
            if (pContext->Flags & SURFACE_ANTIALIAS)
            {
                pSoftP3RX->P3RXScissorMinXY.X = pContext->ViewportInfo.dwX * 2;
                pSoftP3RX->P3RXScissorMinXY.Y = pContext->ViewportInfo.dwY * 2;
                pSoftP3RX->P3RXScissorMaxXY.X = (pContext->ViewportInfo.dwWidth * 2) + 
                                                    pContext->ViewportInfo.dwX;
                pSoftP3RX->P3RXScissorMaxXY.Y = (pContext->ViewportInfo.dwHeight * 2) + 
                                                    pContext->ViewportInfo.dwY;
            }
            else
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS            
            {

                pSoftP3RX->P3RXScissorMinXY.X = pContext->ViewportInfo.dwX;
                pSoftP3RX->P3RXScissorMinXY.Y = pContext->ViewportInfo.dwY;
                pSoftP3RX->P3RXScissorMaxXY.X = pContext->ViewportInfo.dwWidth +
                                                    pContext->ViewportInfo.dwX;
                pSoftP3RX->P3RXScissorMaxXY.Y = pContext->ViewportInfo.dwHeight + 
                                                    pContext->ViewportInfo.dwY;
            }

            COPY_P3_DATA(ScissorMinXY, pSoftP3RX->P3RXScissorMinXY);
            COPY_P3_DATA(ScissorMaxXY, pSoftP3RX->P3RXScissorMaxXY);

            SEND_P3_DATA(YLimits, (pContext->ViewportInfo.dwY & 0xFFFF) | 
                                  (pSoftP3RX->P3RXScissorMaxXY.Y << 16));

            SEND_P3_DATA(XLimits, (pContext->ViewportInfo.dwX & 0xFFFF) | 
                                  (pSoftP3RX->P3RXScissorMaxXY.X << 16));
            
            // Enable user scissor
            SEND_P3_DATA(ScissorMode, 1);

            pSoftP3RX->P3RXRasterizerMode.YLimitsEnable = __PERMEDIA_ENABLE;
            COPY_P3_DATA(RasterizerMode, pSoftP3RX->P3RXRasterizerMode);
        }
        else
        {
            SEND_P3_DATA(ScissorMode, 0);

            pSoftP3RX->P3RXRasterizerMode.YLimitsEnable = __PERMEDIA_DISABLE;
            COPY_P3_DATA(RasterizerMode, pSoftP3RX->P3RXRasterizerMode);
        }

        P3_DMA_COMMIT_BUFFER();
    }

    //*********************************************************
    // Can we optimize the pipeline? (Depends on misc. RS)
    //********************************************************* 
    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_PIPELINEORDER)
    {
        // Must switch over the router mode if we are testing and expect 
        // the Z to be discarded.
        P3_DMA_GET_BUFFER_ENTRIES(2);

        DISPDBG((DBGLVL, "  Pipeline order"));
        if (((pContext->RenderStates[D3DRENDERSTATE_ALPHATESTENABLE]) ||
             (pContext->RenderStates[D3DRENDERSTATE_COLORKEYENABLE])) &&
             (pContext->RenderStates[D3DRENDERSTATE_ZWRITEENABLE]))
        {
            SEND_P3_DATA(RouterMode, __PERMEDIA_DISABLE);
        }
        else
        {
            SEND_P3_DATA(RouterMode, __PERMEDIA_ENABLE);
        }

        P3_DMA_COMMIT_BUFFER();
    }

    //*********************************************************
    // Can we optimize the alpha pipeline? (Depends on misc. RS)
    //********************************************************* 
    // DO AT THE END
    //*********************************************************     
    if (pContext->dwDirtyFlags & CONTEXT_DIRTY_OPTIMIZE_ALPHA)
    {
        P3_DMA_GET_BUFFER_ENTRIES(6);
        DISPDBG((DBGLVL, " Alpha optimizations"));

        pSoftP3RX->P3RXFBDestReadMode.AlphaFiltering = __PERMEDIA_DISABLE;

        // There may be an optimization when blending is on
        if (pContext->RenderStates[D3DRENDERSTATE_BLENDENABLE])
        {
            // Check the RouterMode path
            if (((pContext->RenderStates[D3DRENDERSTATE_ALPHATESTENABLE]) ||
                 (pContext->RenderStates[D3DRENDERSTATE_COLORKEYENABLE])) &&
                 (pContext->RenderStates[D3DRENDERSTATE_ZWRITEENABLE]))
            {
                // Slow mode
    
            }
            else
            {
                // Fast mode.  The Z value will be written before the alpha test.  This means that we
                // can use the alpha test to discard pixels if it is not already in use.
                if (!(pContext->RenderStates[D3DRENDERSTATE_ALPHATESTENABLE]) &&
                    !(pContext->RenderStates[D3DRENDERSTATE_COLORKEYENABLE]))
                {
                    // Check for known blends.
                    if ((pContext->RenderStates[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_BOTHSRCALPHA) ||
                         ((pContext->RenderStates[D3DRENDERSTATE_SRCBLEND] == D3DBLEND_SRCALPHA) &&
                          (pContext->RenderStates[D3DRENDERSTATE_DESTBLEND] == D3DBLEND_INVSRCALPHA)))
                    {
                        // SRCALPHA:INVSRCALPH
                        pSoftP3RX->P3RXAlphaTestMode.Reference = 0;
                        pSoftP3RX->P3RXAlphaTestMode.Enable = __PERMEDIA_ENABLE;
                        pSoftP3RX->P3RXAlphaTestMode.Compare = __GLINT_ALPHA_COMPARE_MODE_GREATER;
                        
                        pSoftP3RX->P3RXFBDestReadMode.AlphaFiltering = __PERMEDIA_ENABLE;
                        pSoftP3RX->P3RXFBDestReadEnables.ReferenceAlpha = 0xFF;
                    }
                }
            }
        }

        COPY_P3_DATA(FBDestReadEnables, pSoftP3RX->P3RXFBDestReadEnables);
        COPY_P3_DATA(FBDestReadMode, pSoftP3RX->P3RXFBDestReadMode);
        COPY_P3_DATA(AlphaTestMode, pSoftP3RX->P3RXAlphaTestMode);

        P3_DMA_COMMIT_BUFFER();
    }

} // __ST_HandleDirtyP3State

//-----------------------------------------------------------------------------
//
// _D3D_ST_ProcessOneRenderState
//
//-----------------------------------------------------------------------------
#define NOT_HANDLED DISPDBG((DBGLVL, "             **Not Currently Handled**"));

DWORD 
_D3D_ST_ProcessOneRenderState(
    P3_D3DCONTEXT* pContext, 
    DWORD dwRSType,
    DWORD dwRSVal)
{
    P3_SOFTWARECOPY* pSoftP3RX;
    P3_THUNKEDDATA *pThisDisplay = pContext->pThisDisplay;
    DWORD *pFlags;
    DWORD *pdwTextureStageState_0, *pdwTextureStageState_1;
#if DX8_MULTISAMPLING || DX7_ANTIALIAS
    BOOL bDX7_Antialiasing = FALSE;
#endif // DX8_MULTISAMPLING || DX7_ANTIALIASING

    P3_DMA_DEFS();

    DBG_ENTRY(_D3D_ST_ProcessOneRenderState); 

    pSoftP3RX = &pContext->SoftCopyGlint;

    DISPDBG((DBGLVL, "_D3D_ST_ProcessOneRenderState: dwType =%08lx, dwVal=%d",
                     dwRSType, dwRSVal));

    if (dwRSType >= D3DHAL_MAX_RSTATES)
    {
        DISPDBG((WRNLVL, "_D3D_ST_ProcessOneRenderState: OUT OF RANGE"
                         " dwType =%08lx, dwVal=%d", dwRSType, dwRSVal));
        return DD_OK;
    }

    // Store the state in the context
    pContext->RenderStates[dwRSType] = dwRSVal;

    // Prepare pointer to the contexts state flags for updates
    pFlags = &pContext->Flags;    

    // Prepare pointers to the stored TSS in case we need them
    pdwTextureStageState_0 =
                    &(pContext->TextureStageState[TEXSTAGE_0].m_dwVal[0]);
    pdwTextureStageState_1 = 
                    &(pContext->TextureStageState[TEXSTAGE_1].m_dwVal[0]);

    // Prepare DMA Buffer for 8 entries in case we need to add to it
    P3_DMA_GET_BUFFER();
    P3_ENSURE_DX_SPACE(8);
    WAIT_FIFO(8);

    // Process according to the type of renderstate. For multivalued 
    // renderstates do some kind of value checking and make sure to
    // setup valid defaults where needed.
    switch (dwRSType) 
    {
        //----------------------------------------------------------------------
        //----------------------------------------------------------------------
        // The following are D3D renderstates which are still in use by DX8 Apps
        //----------------------------------------------------------------------
        //----------------------------------------------------------------------  
        case D3DRENDERSTATE_ZENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_ZENABLE = 0x%x",dwRSVal));
            DIRTY_ZBUFFER(pContext);
            break;

        case D3DRENDERSTATE_FILLMODE:
            DISPDBG((DBGLVL, "SET D3DRS_FILLMODE =  0x%x",dwRSVal));
            switch (dwRSVal)
            {
                case D3DFILL_POINT:
                case D3DFILL_WIREFRAME:
                case D3DFILL_SOLID:
                    // These values are OK
                    break;
                default:
                    // We've received an illegal value, default to solid fills...
                    DISPDBG((ERRLVL,"_D3D_ST_ProcessOneRenderState: "
                                 "unknown FILLMODE value"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    pContext->RenderStates[D3DRENDERSTATE_FILLMODE] = 
                                                                D3DFILL_SOLID;
                    break;
            }
            break;

        case D3DRENDERSTATE_SHADEMODE:
            DISPDBG((DBGLVL, "SET D3DRS_SHADEMODE = 0x%x",dwRSVal));
            switch(dwRSVal)
            {
                case D3DSHADE_PHONG:
                    // Can't actually do Phong, but everyone knows this and 
                    // assumes we use Gouraud instead.
                    SET_BLEND_ERROR ( pContext,  BS_PHONG_SHADING );
                    // fall through and setup Gouraud instead
                    
                case D3DSHADE_GOURAUD:
                    pSoftP3RX->ColorDDAMode.UnitEnable = 1;                
                    pSoftP3RX->ColorDDAMode.ShadeMode = 1;
                    COPY_P3_DATA(ColorDDAMode, pSoftP3RX->ColorDDAMode); 
                    
                    pSoftP3RX->P3RX_P3DeltaMode.SmoothShadingEnable = 1;
                    pSoftP3RX->P3RX_P3DeltaControl.UseProvokingVertex = 0;
                    pSoftP3RX->P3RX_P3VertexControl.Flat = 0;
                    COPY_P3_DATA(DeltaMode, pSoftP3RX->P3RX_P3DeltaMode);
                    COPY_P3_DATA(DeltaControl, pSoftP3RX->P3RX_P3DeltaControl);
                    COPY_P3_DATA(VertexControl, pSoftP3RX->P3RX_P3VertexControl);
                    
                    *pFlags |= SURFACE_GOURAUD;
                    
                    // If we are texturing, some changes may need to be made
                    if (pdwTextureStageState_0[D3DTSS_TEXTUREMAP] != 0)
                    {
                        DIRTY_TEXTURE(pContext);
                    }
                    break;
                    
                case D3DSHADE_FLAT:
                    pSoftP3RX->ColorDDAMode.UnitEnable = 1;                  
                    pSoftP3RX->ColorDDAMode.ShadeMode = 0;
                    COPY_P3_DATA(ColorDDAMode, pSoftP3RX->ColorDDAMode);
                    pSoftP3RX->P3RX_P3DeltaMode.SmoothShadingEnable = 0;

                    pSoftP3RX->P3RX_P3DeltaControl.UseProvokingVertex = 1;
                    pSoftP3RX->P3RX_P3VertexControl.Flat = 1;
                    COPY_P3_DATA(DeltaMode, pSoftP3RX->P3RX_P3DeltaMode);
                    COPY_P3_DATA(DeltaControl, pSoftP3RX->P3RX_P3DeltaControl);
                    COPY_P3_DATA(VertexControl, pSoftP3RX->P3RX_P3VertexControl);
                    
                    *pFlags &= ~SURFACE_GOURAUD;
                    // If we are texturing, some changes may need to be made
                    if (pdwTextureStageState_0[D3DTSS_TEXTUREMAP] != 0)
                    {
                        DIRTY_TEXTURE(pContext);
                    }
                    break;
                    
                default:
                    DISPDBG((ERRLVL,"_D3D_ST_ProcessOneRenderState: "
                                 "unknown SHADEMODE value"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }
            break;            

        case D3DRENDERSTATE_LINEPATTERN:
            DISPDBG((DBGLVL, "SET D3DRS_LINEPATTERN = 0x%x",dwRSVal));

            if (dwRSVal == 0)
            {
                pSoftP3RX->PXRXLineStippleMode.StippleEnable = __PERMEDIA_DISABLE;

                RENDER_LINE_STIPPLE_DISABLE(pContext->RenderCommand);                
            }
            else
            {
                pSoftP3RX->PXRXLineStippleMode.StippleEnable = __PERMEDIA_ENABLE;
                pSoftP3RX->PXRXLineStippleMode.RepeatFactor = 
                                                    (dwRSVal & 0x0000FFFF) -1 ;
                pSoftP3RX->PXRXLineStippleMode.StippleMask = 
                                                    (dwRSVal & 0xFFFF0000) >> 16;
                pSoftP3RX->PXRXLineStippleMode.Mirror = __PERMEDIA_DISABLE;

                RENDER_LINE_STIPPLE_ENABLE(pContext->RenderCommand);                               
            }

            COPY_P3_DATA( LineStippleMode, pSoftP3RX->PXRXLineStippleMode);
            break;

        case D3DRENDERSTATE_ZWRITEENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_ZWRITEENABLE = 0x%x",dwRSVal));
            if (dwRSVal != 0)
            {
                // Local Buffer Write mode
                if(!(*pFlags & SURFACE_ZWRITEENABLE))
                {
                    DISPDBG((DBGLVL, "Enabling Z Writes"));
                    *pFlags |= SURFACE_ZWRITEENABLE;
                    DIRTY_ZBUFFER(pContext);
                    DIRTY_PIPELINEORDER(pContext);
                    DIRTY_OPTIMIZE_ALPHA(pContext);
                }
            }
            else
            {
                if (*pFlags & SURFACE_ZWRITEENABLE)
                {
                    DISPDBG((DBGLVL, "Disabling Z Writes"));
                    *pFlags &= ~SURFACE_ZWRITEENABLE;
                    DIRTY_ZBUFFER(pContext);
                    DIRTY_PIPELINEORDER(pContext);
                    DIRTY_OPTIMIZE_ALPHA(pContext);
                }
            }
            break;

        case D3DRENDERSTATE_ALPHATESTENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_ALPHATESTENABLE = 0x%x",dwRSVal));
            DIRTY_ALPHATEST(pContext);
            DIRTY_PIPELINEORDER(pContext);
            DIRTY_OPTIMIZE_ALPHA(pContext);
            break;

        case D3DRENDERSTATE_LASTPIXEL:
            DISPDBG((DBGLVL, "SET D3DRS_LASTPIXEL = 0x%x",dwRSVal));
            NOT_HANDLED;
            break;
            
        case D3DRENDERSTATE_SRCBLEND:
            DISPDBG((DBGLVL, "SET D3DRS_SRCBLEND = 0x%x",dwRSVal));
            DIRTY_ALPHABLEND(pContext);
            DIRTY_OPTIMIZE_ALPHA(pContext);
            break;
            
        case D3DRENDERSTATE_DESTBLEND:
            DISPDBG((DBGLVL, "SET D3DRS_DESTBLEND = 0x%x",dwRSVal));
            DIRTY_ALPHABLEND(pContext);
            DIRTY_OPTIMIZE_ALPHA(pContext);
            break;
            
        case D3DRENDERSTATE_CULLMODE:
            DISPDBG((DBGLVL, "SET D3DRS_CULLMODE = 0x%x",dwRSVal));
            switch(dwRSVal)
            {
                case D3DCULL_NONE:              
                    SET_CULLING_TO_NONE(pContext);
                    pSoftP3RX->P3RX_P3DeltaMode.BackfaceCull = 0;
                    break;

                case D3DCULL_CCW:
                    SET_CULLING_TO_CCW(pContext);
                    pSoftP3RX->P3RX_P3DeltaMode.BackfaceCull = 0;
                    break;

                case D3DCULL_CW:
                    SET_CULLING_TO_CW(pContext);
                    pSoftP3RX->P3RX_P3DeltaMode.BackfaceCull = 0;
                    break;
                    
                default:
                    DISPDBG((ERRLVL,"_D3D_ST_ProcessOneRenderState: "
                                 "unknown cull mode"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }

            COPY_P3_DATA(DeltaMode, pSoftP3RX->P3RX_P3DeltaMode);
            break;
            
        case D3DRENDERSTATE_ZFUNC:
            DISPDBG((DBGLVL, "SET D3DRS_ZFUNC = 0x%x",dwRSVal));
            switch (dwRSVal)
            {
                case D3DCMP_NEVER:
                    pSoftP3RX->P3RXDepthMode.CompareMode = 
                                    __GLINT_DEPTH_COMPARE_MODE_NEVER;
                    break;
                case D3DCMP_LESS:
                    pSoftP3RX->P3RXDepthMode.CompareMode = 
                                    __GLINT_DEPTH_COMPARE_MODE_LESS;
                    break;
                case D3DCMP_EQUAL:
                    pSoftP3RX->P3RXDepthMode.CompareMode = 
                                    __GLINT_DEPTH_COMPARE_MODE_EQUAL;
                    break;
                case D3DCMP_LESSEQUAL:
                    pSoftP3RX->P3RXDepthMode.CompareMode = 
                                    __GLINT_DEPTH_COMPARE_MODE_LESS_OR_EQUAL;
                    break;
                case D3DCMP_GREATER:
                    pSoftP3RX->P3RXDepthMode.CompareMode = 
                                    __GLINT_DEPTH_COMPARE_MODE_GREATER;
                    break;
                case D3DCMP_NOTEQUAL:
                    pSoftP3RX->P3RXDepthMode.CompareMode = 
                                    __GLINT_DEPTH_COMPARE_MODE_NOT_EQUAL;
                    break;
                case D3DCMP_GREATEREQUAL:
                    pSoftP3RX->P3RXDepthMode.CompareMode = 
                                    __GLINT_DEPTH_COMPARE_MODE_GREATER_OR_EQUAL;
                    break;
                case D3DCMP_ALWAYS:
                    pSoftP3RX->P3RXDepthMode.CompareMode = 
                                    __GLINT_DEPTH_COMPARE_MODE_ALWAYS;
                    break;                  
                default:
                    DISPDBG((ERRLVL,"_D3D_ST_ProcessOneRenderState: "
                                 "unknown ZFUNC mode"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );

                    // Set Less or equal as default
                    pSoftP3RX->P3RXDepthMode.CompareMode = 
                                        __GLINT_DEPTH_COMPARE_MODE_LESS_OR_EQUAL;
                    break;
            }
            DIRTY_ZBUFFER(pContext);
            break;
            
        case D3DRENDERSTATE_ALPHAREF:
            DISPDBG((DBGLVL, "SET D3DRS_ALPHAREF = 0x%x",dwRSVal));
            DIRTY_ALPHATEST(pContext);
            break;
            
        case D3DRENDERSTATE_ALPHAFUNC:
            DISPDBG((DBGLVL, "SET D3DRS_ALPHAFUNC = 0x%x",dwRSVal));
            DIRTY_ALPHATEST(pContext);
            break;
            
        case D3DRENDERSTATE_DITHERENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_DITHERENABLE = 0x%x",dwRSVal));
            if (dwRSVal != 0)
            {
                pSoftP3RX->DitherMode.DitherEnable = __PERMEDIA_ENABLE;
            }
            else
            {
                pSoftP3RX->DitherMode.DitherEnable = __PERMEDIA_DISABLE;
            } 
            COPY_P3_DATA(DitherMode, pSoftP3RX->DitherMode);
            break;

        case D3DRENDERSTATE_BLENDENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_BLENDENABLE = 0x%x",dwRSVal));

            // Although render states whose values are boolean in type are 
            // documented as only accepting TRUE(1) and FALSE(0) the runtime 
            // does not validate this and accepts any non-zero value as true. 
            // The sample driver interprets this strictly and does interpret 
            // values other than 1 as being TRUE. However, as the runtime 
            // does not offer validation your driver should interpret 0 as 
            // FALSE and any other non-zero value as TRUE. 
            
            if (dwRSVal != 0)
            {
                if(!(*pFlags & SURFACE_ALPHAENABLE))
                {
                    // Set the blend enable flag in the render context struct
                    *pFlags |= SURFACE_ALPHAENABLE;
                    DIRTY_ALPHABLEND(pContext);
                    DIRTY_OPTIMIZE_ALPHA(pContext);
                }
            }
            else 
            {
                if (*pFlags & SURFACE_ALPHAENABLE)
                {
                    // Turn off blend enable flag in render context struct
                    *pFlags &= ~SURFACE_ALPHAENABLE;
                    DIRTY_ALPHABLEND(pContext);
                    DIRTY_OPTIMIZE_ALPHA(pContext);
                }
            }
            break;

        case D3DRENDERSTATE_FOGENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_FOGENABLE = 0x%x",dwRSVal));
            DIRTY_FOG(pContext);
            break;

        case D3DRENDERSTATE_SPECULARENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_SPECULARENABLE = 0x%x",dwRSVal));
            if (dwRSVal)
            {
                *pFlags |= SURFACE_SPECULAR;
                pSoftP3RX->P3RXTextureApplicationMode.EnableKs = __PERMEDIA_ENABLE;
                pSoftP3RX->P3RX_P3DeltaMode.SpecularTextureEnable = 1;
            }
            else
            {
                *pFlags &= ~SURFACE_SPECULAR;
                pSoftP3RX->P3RXTextureApplicationMode.EnableKs = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RX_P3DeltaMode.SpecularTextureEnable = 0;
            }
            DIRTY_TEXTURE(pContext);
            break;

        case D3DRENDERSTATE_ZVISIBLE:
            DISPDBG((DBGLVL, "SET D3DRS_ZVISIBLE = %d", dwRSVal));
            if (dwRSVal)
            { 
                DISPDBG((ERRLVL,"_D3D_ST_ProcessOneRenderState:"
                             " ZVISIBLE enabled - no longer supported."));
            }
            break;

        case D3DRENDERSTATE_STIPPLEDALPHA:
            DISPDBG((DBGLVL, "SET D3DRS_STIPPLEDALPHA = 0x%x",dwRSVal));
            if(dwRSVal)
            {
                if (!(*pFlags & SURFACE_ALPHASTIPPLE))
                {
                    *pFlags |= SURFACE_ALPHASTIPPLE;
                    if (pContext->bKeptStipple)
                    {
                        RENDER_AREA_STIPPLE_DISABLE(pContext->RenderCommand);
                    }
                }
            }
            else 
            {
                if (*pFlags & SURFACE_ALPHASTIPPLE)
                {
                    // If Alpha Stipple is being turned off, turn the normal 
                    // stipple back on, and enable it.
                    int i;
                    for (i = 0; i < 32; i++)
                    {
                        P3_ENSURE_DX_SPACE(2);
                        WAIT_FIFO(2);
                        SEND_P3_DATA_OFFSET(AreaStipplePattern0, 
                                             (DWORD)pContext->CurrentStipple[i], i);
                    }

                    *pFlags &= ~SURFACE_ALPHASTIPPLE;

                    if (pContext->bKeptStipple)
                    {
                        RENDER_AREA_STIPPLE_ENABLE(pContext->RenderCommand);
                    }
                }
            }
            break;

        case D3DRENDERSTATE_FOGCOLOR:
            DISPDBG((DBGLVL, "SET D3DRS_FOGCOLOR = 0x%x",dwRSVal));
            DIRTY_FOG(pContext);
            break;
            
        case D3DRENDERSTATE_FOGTABLEMODE:
            DISPDBG((DBGLVL, "SET D3DRS_FOGTABLEMODE = 0x%x", dwRSVal));
            DIRTY_FOG(pContext);
            break;            
            
        case D3DRENDERSTATE_FOGTABLESTART:
            DISPDBG((DBGLVL, "SET D3DRS_FOGTABLESTART = 0x%x",dwRSVal));
            DIRTY_FOG(pContext);
            break;
            
        case D3DRENDERSTATE_FOGTABLEEND:
            DISPDBG((DBGLVL, "SET D3DRS_FOGTABLEEND = 0x%x",dwRSVal));
            DIRTY_FOG(pContext);
            break;
            
        case D3DRENDERSTATE_FOGTABLEDENSITY:
            DISPDBG((DBGLVL, "SET D3DRS_FOGTABLEDENSITY = 0x%x",dwRSVal));
            DIRTY_FOG(pContext);
            break;

        case D3DRENDERSTATE_EDGEANTIALIAS:    
            DISPDBG((DBGLVL, "SET D3DRS_EDGEANTIALIAS = 0x%x",dwRSVal));
            NOT_HANDLED;
            break;        

        case D3DRENDERSTATE_ZBIAS:    
            DISPDBG((DBGLVL, "SET D3DRS_ZBIAS = 0x%x",dwRSVal));
            NOT_HANDLED;
            break;    

        case D3DRENDERSTATE_RANGEFOGENABLE:    
            DISPDBG((DBGLVL, "SET D3DRS_RANGEFOGENABLE = 0x%x",dwRSVal));
            NOT_HANDLED;
            break;               

        case D3DRENDERSTATE_STENCILENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_STENCILENABLE = 0x%x", dwRSVal));
            DIRTY_STENCIL(pContext);
            break;
            
        case D3DRENDERSTATE_STENCILFAIL:
            DISPDBG((DBGLVL, "SET D3DRS_STENCILFAIL = 0x%x", dwRSVal));
            DIRTY_STENCIL(pContext);
            break;
            
        case D3DRENDERSTATE_STENCILZFAIL:
            DISPDBG((DBGLVL, "SET D3DRS_STENCILZFAIL = 0x%x", dwRSVal));
            DIRTY_STENCIL(pContext);
            break;
            
        case D3DRENDERSTATE_STENCILPASS:
            DISPDBG((DBGLVL, "SET D3DRS_STENCILPASS = 0x%x", dwRSVal));
            DIRTY_STENCIL(pContext);
            break;
            
        case D3DRENDERSTATE_STENCILFUNC:
            DISPDBG((DBGLVL, "SET D3DRS_STENCILFUNC = 0x%x", dwRSVal));
            DIRTY_STENCIL(pContext);
            break;
            
        case D3DRENDERSTATE_STENCILREF:
            DISPDBG((DBGLVL, "SET D3DRS_STENCILREF = 0x%x", dwRSVal));
            DIRTY_STENCIL(pContext);
            break;
            
        case D3DRENDERSTATE_STENCILMASK:
            DISPDBG((DBGLVL, "SET D3DRS_STENCILMASK = 0x%x", dwRSVal));
            DIRTY_STENCIL(pContext);
            break;
            
        case D3DRENDERSTATE_STENCILWRITEMASK:
            DISPDBG((DBGLVL, "SET D3DRS_STENCILENABLE = 0x%x", dwRSVal));
            DIRTY_STENCIL(pContext);
            break;  

        case D3DRENDERSTATE_TEXTUREFACTOR:
            // Should not need to dirty anything. This is a good thing -
            // this may be changed frequently in between calls, and may be
            // the only thing to change. Used for some of the odder blend modes.
            DISPDBG((DBGLVL, "SET D3DRS_TEXTUREFACTOR = 0x%x", dwRSVal));            
            SEND_P3_DATA ( TextureEnvColor, FORMAT_8888_32BIT_BGR(dwRSVal) );
            SEND_P3_DATA ( TextureCompositeFactor0, FORMAT_8888_32BIT_BGR(dwRSVal) );
            SEND_P3_DATA ( TextureCompositeFactor1, FORMAT_8888_32BIT_BGR(dwRSVal) );
            break;

        case D3DRENDERSTATE_WRAP0:
        case D3DRENDERSTATE_WRAP1:        
        case D3DRENDERSTATE_WRAP2:        
        case D3DRENDERSTATE_WRAP3:
        case D3DRENDERSTATE_WRAP4:
        case D3DRENDERSTATE_WRAP5:
        case D3DRENDERSTATE_WRAP6:
        case D3DRENDERSTATE_WRAP7:        
            DISPDBG((DBGLVL, "SET D3DRS_WRAP %d = 0x%x", 
                        dwRSType - D3DRENDERSTATE_WRAP0, (DWORD)dwRSVal));                        
            DIRTY_TEXTURE(pContext);        
            break;

        case D3DRENDERSTATE_LOCALVIEWER:
            DISPDBG((DBGLVL, "SET D3DRS_LOCALVIEWER = %d", dwRSVal));
            DIRTY_GAMMA_STATE;
            break;
        case D3DRENDERSTATE_CLIPPING:
            DISPDBG((DBGLVL, "SET D3DRS_CLIPPING = %d", dwRSVal));
            DIRTY_GAMMA_STATE;
            break;
        case D3DRENDERSTATE_LIGHTING:
            DISPDBG((DBGLVL, "SET D3DRS_LIGHTING = %d", dwRSVal));
            DIRTY_GAMMA_STATE;
            break;
        case D3DRENDERSTATE_AMBIENT:
            DISPDBG((DBGLVL, "SET D3DRS_AMBIENT = 0x%x", dwRSVal));
            DIRTY_GAMMA_STATE;
            break;

        //----------------------------------------------------------------------
        //----------------------------------------------------------------------
        // The following are internal D3D renderstates which are created by 
        // the runtime. Apps don't send them. 
        //----------------------------------------------------------------------
        //----------------------------------------------------------------------  

        case D3DRENDERSTATE_SCENECAPTURE:
            DISPDBG((DBGLVL, "SET D3DRS_SCENECAPTURE = 0x%x", dwRSVal));
            {
                DWORD dwFlag;

                if (dwRSVal)
                {
                    dwFlag = D3DHAL_SCENE_CAPTURE_START;
                }
                else
                {
                    dwFlag = D3DHAL_SCENE_CAPTURE_END;
                }
                
#if DX7_TEXMANAGEMENT
                if (dwRSVal)
                {
                    // Reset Texture Management counters for next frame
                    _D3D_TM_STAT_ResetCounters(pContext); 
                }
#endif // DX7_TEXMANAGEMENT                

                // Flush all DMA ops before going to next frame
                P3_DMA_COMMIT_BUFFER();
                
                _D3D_OP_SceneCapture(pContext, dwFlag);

                // Restart DMA ops
                P3_DMA_GET_BUFFER();
            }
            break;

#if DX7_TEXMANAGEMENT
        case D3DRENDERSTATE_EVICTMANAGEDTEXTURES:     
            DISPDBG((DBGLVL, "SET D3DRENDERSTATE_EVICTMANAGEDTEXTURES = 0x%x", 
                             dwRSVal));
            if (NULL != pContext->pTextureManager)
            {
                _D3D_TM_EvictAllManagedTextures(pContext);        
            }
            break;
#endif // DX7_TEXMANAGEMENT 
            
        //----------------------------------------------------------------------
        //----------------------------------------------------------------------
        // The following are new DX8 renderstates which we need to process 
        // correctly in order to run DX8 apps
        //----------------------------------------------------------------------
        //----------------------------------------------------------------------        

#if DX8_POINTSPRITES
        // Pointsprite support
        case D3DRS_POINTSIZE:
            DISPDBG((DBGLVL, "SET D3DRS_POINTSIZE = 0x%x",dwRSVal));
            *(DWORD*)(&pContext->PntSprite.fSize) = dwRSVal;
            break;

        case D3DRS_POINTSPRITEENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_POINTSPRITEENABLE = 0x%x",dwRSVal));
            pContext->PntSprite.bEnabled = dwRSVal;
            break;

        case D3DRS_POINTSIZE_MIN:
            DISPDBG((DBGLVL, "SET D3DRS_POINTSIZE_MIN = 0x%x",dwRSVal));
            *(DWORD*)(&pContext->PntSprite.fSizeMin) = dwRSVal;
            break;

        case D3DRS_POINTSIZE_MAX:
            DISPDBG((DBGLVL, "SET D3DRS_POINTSIZE_MAX = 0x%x",dwRSVal)); 
            *(DWORD*)(&pContext->PntSprite.fSizeMax) = dwRSVal;
            break; 
            
        // All of the following point sprite related render states are
        // ignored by this driver since we are a Non-TnLHal driver.
        case D3DRS_POINTSCALEENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_POINTSCALEENABLE = 0x%x",dwRSVal));
            pContext->PntSprite.bScaleEnabled = dwRSVal; 
            break;
            
        case D3DRS_POINTSCALE_A:
            DISPDBG((DBGLVL, "SET D3DRS_POINTSCALE_A = 0x%x",dwRSVal));
            *(DWORD*)(&pContext->PntSprite.fScale_A) = dwRSVal;
            break;

        case D3DRS_POINTSCALE_B:
            DISPDBG((DBGLVL, "SET D3DRS_POINTSCALE_B = 0x%x",dwRSVal));
            *(DWORD*)(&pContext->PntSprite.fScale_B) = dwRSVal;
            break;

        case D3DRS_POINTSCALE_C:
            DISPDBG((DBGLVL, "SET D3DRS_POINTSCALE_C = 0x%x",dwRSVal));
            *(DWORD*)(&pContext->PntSprite.fScale_C) = dwRSVal;
            break;
           
#endif // DX8_POINTSPRITES

#if DX8_VERTEXSHADERS
        case D3DRS_SOFTWAREVERTEXPROCESSING:
            DISPDBG((DBGLVL, "SET D3DRS_SOFTWAREVERTEXPROCESSING = 0x%x",dwRSVal));
            NOT_HANDLED;
            break;
#endif // DX8_VERTEXSHADERS                

#if DX8_DDI
        case D3DRS_COLORWRITEENABLE:
            {
                DWORD dwColMask = 0x0;
                
                DISPDBG((DBGLVL, "SET D3DRS_COLORWRITEENABLE = 0x%x",dwRSVal));

                if (dwRSVal & D3DCOLORWRITEENABLE_RED)
                {
                    dwColMask |= pContext->pSurfRenderInt->pixFmt.dwRBitMask;
                }

                if (dwRSVal & D3DCOLORWRITEENABLE_GREEN)
                {
                    dwColMask |= pContext->pSurfRenderInt->pixFmt.dwGBitMask;      
                }       

                if (dwRSVal & D3DCOLORWRITEENABLE_BLUE)
                {
                    dwColMask |= pContext->pSurfRenderInt->pixFmt.dwBBitMask;        
                }    

                if (dwRSVal & D3DCOLORWRITEENABLE_ALPHA)
                {
                    dwColMask |= pContext->pSurfRenderInt->pixFmt.dwRGBAlphaBitMask;        
                }   

                // Replicate mask into higher word for P3 in 16 bpp mode
                if (pContext->pSurfRenderInt->dwPixelSize == __GLINT_16BITPIXEL)
                {
                    dwColMask |= (dwColMask << 16);
                    pContext->dwColorWriteSWMask = dwColMask;
                }
                else
                {
                    pContext->dwColorWriteSWMask = 0xFFFFFFFF;
                }
                        
                pContext->dwColorWriteHWMask = dwColMask;

                SEND_P3_DATA(FBHardwareWriteMask, pContext->dwColorWriteHWMask);
                DISPDBG((DBGLVL,"dwColMask = 0x%08x",dwColMask));
                SEND_P3_DATA(FBSoftwareWriteMask, pContext->dwColorWriteSWMask);                
            }
            
            break;        
#endif // DX8_DDI

        //----------------------------------------------------------------------        
        //----------------------------------------------------------------------
        // The following are retired renderstates from DX8 but which we need to
        // process correctly in order to run apps which use legacy interfaces 
        // These apps might send down the pipeline these renderstates and expect
        // correct driver behavior !
        //----------------------------------------------------------------------
        //----------------------------------------------------------------------        

        case D3DRENDERSTATE_TEXTUREHANDLE:
            DISPDBG((DBGLVL, "SET D3DRS_TEXTUREHANDLE = 0x%x",dwRSVal));
            if (dwRSVal != pdwTextureStageState_0[D3DTSS_TEXTUREMAP])
            {
                pdwTextureStageState_0[D3DTSS_TEXTUREMAP] = dwRSVal;
                DIRTY_TEXTURE(pContext);
            }
            break;

#if DX7_ANTIALIAS
        // DX7 uses D3DRENDERSTATE_ANTIALIAS.
        case D3DRENDERSTATE_ANTIALIAS:
            bDX7_Antialiasing = TRUE;
            if (dwRSVal && pContext->pSurfRenderInt)
            {
                // Always reallocate alias buffer for DX7
                // P3 driver supports only 2x2 (4) multi sample antialiasing

#if DX8_MULTISAMPLING
                pContext->pSurfRenderInt->dwSampling = 4;
#endif // DX8_MULTISAMPLING
                if (! _D3D_ST_CanRenderAntialiased(pContext, TRUE))
                {
#if DX8_MULTISAMPLING                
                    // Reset dwSampling in case of failure
                    pContext->pSurfRenderInt->dwSampling = 0;
#endif // DX8_MULTISAMPLING                    
                    P3_DMA_COMMIT_BUFFER();
                    return DDERR_OUTOFMEMORY;
                }
            }
            // then fall through...
#endif // DX7_ANTIALIAS

#if DX8_MULTISAMPLING
        // DX8 uses D3DRS_MULTISAMPLEANTIALIAS
        case D3DRS_MULTISAMPLEANTIALIAS:
#endif // DX8_MULTISAMPLING

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
            DISPDBG((DBGLVL, "ChangeState: AntiAlias 0x%x",dwRSVal));
            P3_DMA_COMMIT_BUFFER();
            if (dwRSVal 
#if DX8_MULTISAMPLING
                && pContext->pSurfRenderInt->dwSampling
#endif // DX8_MULTISAMPLING
               )
            {
                pSoftP3RX->P3RX_P3DeltaControl.FullScreenAA = __PERMEDIA_ENABLE;
                *pFlags |= SURFACE_ANTIALIAS;
            }
            else
            {
                pSoftP3RX->P3RX_P3DeltaControl.FullScreenAA = __PERMEDIA_DISABLE;
                *pFlags &= ~SURFACE_ANTIALIAS;
            }
            P3_DMA_GET_BUFFER_ENTRIES( 4 );
            DIRTY_RENDER_OFFSETS(pContext);
            break;
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS

        case D3DRENDERSTATE_TEXTUREPERSPECTIVE:
            DISPDBG((DBGLVL, "SET D3DRS_TEXTUREPERSPECTIVE = 0x%x",dwRSVal));
            if (dwRSVal != 0)
            {
                *pFlags |= SURFACE_PERSPCORRECT;
                pSoftP3RX->P3RX_P3DeltaControl.ForceQ = 0;
            }
            else
            {   
                *pFlags &= ~SURFACE_PERSPCORRECT;
                pSoftP3RX->P3RX_P3DeltaControl.ForceQ = 1;
            }

            COPY_P3_DATA(DeltaControl, pSoftP3RX->P3RX_P3DeltaControl);
            break;
            
        case D3DRENDERSTATE_TEXTUREMAPBLEND:
            DISPDBG((DBGLVL, "SET D3DRS_TEXTUREMAPBLEND = 0x%x", dwRSVal));               
            *pFlags &= ~SURFACE_MODULATE;
            switch(dwRSVal)
            {
                case D3DTBLEND_DECALMASK: // unsupported - do decal as fallback.
                    SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_COLOR_OP );
                    // fall through
                case D3DTBLEND_DECAL:
                case D3DTBLEND_COPY:
                    pdwTextureStageState_0[D3DTSS_COLOROP]   = D3DTOP_SELECTARG1;
                    pdwTextureStageState_0[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
                    pdwTextureStageState_0[D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG1;
                    pdwTextureStageState_0[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
                    pdwTextureStageState_1[D3DTSS_COLOROP]   = D3DTOP_DISABLE;
                    break;

                case D3DTBLEND_MODULATEMASK: // unsupported - do modulate as fallback.
                    SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_COLOR_OP );
                    // fall through
                case D3DTBLEND_MODULATE:
                    pdwTextureStageState_0[D3DTSS_COLOROP]   = D3DTOP_MODULATE;
                    pdwTextureStageState_0[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
                    pdwTextureStageState_0[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
                    // In the changetexture* code we modify the below value,
                    // dependent on the SURFACE_MODULATE flag...
                    pdwTextureStageState_0[D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG1;
                    pdwTextureStageState_0[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
                    pdwTextureStageState_0[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
                    pdwTextureStageState_1[D3DTSS_COLOROP]   = D3DTOP_DISABLE;
                    *pFlags |= SURFACE_MODULATE;
                    break;

                case D3DTBLEND_MODULATEALPHA:
                    pdwTextureStageState_0[D3DTSS_COLOROP]   = D3DTOP_MODULATE;
                    pdwTextureStageState_0[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
                    pdwTextureStageState_0[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
                    pdwTextureStageState_0[D3DTSS_ALPHAOP]   = D3DTOP_MODULATE;
                    pdwTextureStageState_0[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
                    pdwTextureStageState_0[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
                    pdwTextureStageState_1[D3DTSS_COLOROP]   = D3DTOP_DISABLE;
                    break;

                case D3DTBLEND_DECALALPHA:
                    pdwTextureStageState_0[D3DTSS_COLOROP]   = D3DTOP_BLENDTEXTUREALPHA;
                    pdwTextureStageState_0[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
                    pdwTextureStageState_0[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
                    pdwTextureStageState_0[D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG2;
                    pdwTextureStageState_0[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
                    pdwTextureStageState_0[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
                    pdwTextureStageState_1[D3DTSS_COLOROP]   = D3DTOP_DISABLE;
                    break;

                case D3DTBLEND_ADD:
                    pdwTextureStageState_0[D3DTSS_COLOROP]   = D3DTOP_ADD;
                    pdwTextureStageState_0[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
                    pdwTextureStageState_0[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
                    pdwTextureStageState_0[D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG2;
                    pdwTextureStageState_0[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
                    pdwTextureStageState_0[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
                    pdwTextureStageState_1[D3DTSS_COLOROP]   = D3DTOP_DISABLE;
                    break;

                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown texture blend!"));
                    // This needs to be flagged here, because we don't know
                    // what effect it is meant to have on the TSS stuff.
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }
            DIRTY_TEXTURE(pContext);
            break;
            
        case D3DRENDERSTATE_TEXTUREMAG:
            DISPDBG((DBGLVL, "SET D3DRS_TEXTUREMAG = 0x%x",dwRSVal));
            switch(dwRSVal)
            {
                case D3DFILTER_NEAREST:
                case D3DFILTER_MIPNEAREST:
                    pdwTextureStageState_0[D3DTSS_MAGFILTER] = D3DTFG_POINT;
                    break;
                case D3DFILTER_LINEAR:
                case D3DFILTER_LINEARMIPLINEAR:
                case D3DFILTER_MIPLINEAR:
                    pdwTextureStageState_0[D3DTSS_MAGFILTER] = D3DTFG_LINEAR;
                    break;
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown MAG filter!"));
                    break;
            }
            DIRTY_TEXTURE(pContext);
            break;
            
        case D3DRENDERSTATE_TEXTUREMIN:
            DISPDBG((DBGLVL, "SET D3DRS_TEXTUREMIN = 0x%x",dwRSVal));
            switch(dwRSVal)
            {
                case D3DFILTER_NEAREST:
                    pdwTextureStageState_0[D3DTSS_MINFILTER] = D3DTFN_POINT;
                    pdwTextureStageState_0[D3DTSS_MIPFILTER] = D3DTFP_NONE;
                    break;
                case D3DFILTER_MIPNEAREST:
                    pdwTextureStageState_0[D3DTSS_MINFILTER] = D3DTFN_POINT;
                    pdwTextureStageState_0[D3DTSS_MIPFILTER] = D3DTFP_POINT;
                    break;
                case D3DFILTER_LINEARMIPNEAREST:
                    pdwTextureStageState_0[D3DTSS_MINFILTER] = D3DTFN_POINT;
                    pdwTextureStageState_0[D3DTSS_MIPFILTER] = D3DTFP_LINEAR;
                    break;
                case D3DFILTER_LINEAR:
                    pdwTextureStageState_0[D3DTSS_MINFILTER] = D3DTFN_LINEAR;
                    pdwTextureStageState_0[D3DTSS_MIPFILTER] = D3DTFP_NONE;
                    break;
                case D3DFILTER_MIPLINEAR:
                    pdwTextureStageState_0[D3DTSS_MINFILTER] = D3DTFN_LINEAR;
                    pdwTextureStageState_0[D3DTSS_MIPFILTER] = D3DTFP_POINT;
                    break;
                case D3DFILTER_LINEARMIPLINEAR:
                    pdwTextureStageState_0[D3DTSS_MINFILTER] = D3DTFN_LINEAR;
                    pdwTextureStageState_0[D3DTSS_MIPFILTER] = D3DTFP_LINEAR;
                    break;
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown MIN filter!"));
                    break;
            }
            DIRTY_TEXTURE(pContext);
            break;
            
        case D3DRENDERSTATE_WRAPU:
            // map legacy WRAPU state through to controls for tex coord 0        
            DISPDBG((DBGLVL, "SET D3DRS_WRAPU = 0x%x",dwRSVal));        
            pContext->RenderStates[D3DRENDERSTATE_WRAP0] &= ~D3DWRAP_U;
            pContext->RenderStates[D3DRENDERSTATE_WRAP0] |= ((dwRSVal) ? D3DWRAP_U : 0);
            DIRTY_TEXTURE(pContext);
            break;
            
        case D3DRENDERSTATE_WRAPV:
            // map legacy WRAPV state through to controls for tex coord 0    
            DISPDBG((DBGLVL, "SET D3DRS_WRAPV = 0x%x",dwRSVal));             
            pContext->RenderStates[D3DRENDERSTATE_WRAP0] &= ~D3DWRAP_V;
            pContext->RenderStates[D3DRENDERSTATE_WRAP0] |= ((dwRSVal) ? D3DWRAP_V : 0);
            DIRTY_TEXTURE(pContext);
            break;

        case D3DRENDERSTATE_TEXTUREADDRESS:
            DISPDBG((DBGLVL, "SET D3DRS_TEXTUREADDRESS = 0x%x",dwRSVal));  
            pdwTextureStageState_0[D3DTSS_ADDRESS] =           
            pdwTextureStageState_0[D3DTSS_ADDRESSU] =
            pdwTextureStageState_0[D3DTSS_ADDRESSV] = dwRSVal;
            DIRTY_TEXTURE(pContext);
            break;
            
        case D3DRENDERSTATE_TEXTUREADDRESSU:
            DISPDBG((DBGLVL, "SET D3DRS_TEXTUREADDRESSU = 0x%x",dwRSVal));         
            pdwTextureStageState_0[D3DTSS_ADDRESSU] = dwRSVal;
            DIRTY_TEXTURE(pContext);
            break;

        case D3DRENDERSTATE_TEXTUREADDRESSV:
            DISPDBG((DBGLVL, "SET D3DRS_TEXTUREADDRESSV = 0x%x",dwRSVal));         
            pdwTextureStageState_0[D3DTSS_ADDRESSV] = dwRSVal;
            DIRTY_TEXTURE(pContext);
            break;

        case D3DRENDERSTATE_MIPMAPLODBIAS:
            DISPDBG((DBGLVL, "SET D3DRS_MIPMAPLODBIAS = 0x%x",dwRSVal));         
            pdwTextureStageState_0[D3DTSS_MIPMAPLODBIAS] = dwRSVal;
            DIRTY_TEXTURE(pContext);
            break;
        case D3DRENDERSTATE_BORDERCOLOR:
            DISPDBG((DBGLVL, "SET D3DRS_BORDERCOLOR = 0x%x",dwRSVal));         
            pdwTextureStageState_0[D3DTSS_BORDERCOLOR] = dwRSVal;
            DIRTY_TEXTURE(pContext);
            break;

        case D3DRENDERSTATE_STIPPLEPATTERN00:
        case D3DRENDERSTATE_STIPPLEPATTERN01:
        case D3DRENDERSTATE_STIPPLEPATTERN02:
        case D3DRENDERSTATE_STIPPLEPATTERN03:
        case D3DRENDERSTATE_STIPPLEPATTERN04:
        case D3DRENDERSTATE_STIPPLEPATTERN05:   
        case D3DRENDERSTATE_STIPPLEPATTERN06:
        case D3DRENDERSTATE_STIPPLEPATTERN07:
        case D3DRENDERSTATE_STIPPLEPATTERN08:
        case D3DRENDERSTATE_STIPPLEPATTERN09:
        case D3DRENDERSTATE_STIPPLEPATTERN10:
        case D3DRENDERSTATE_STIPPLEPATTERN11: 
        case D3DRENDERSTATE_STIPPLEPATTERN12:
        case D3DRENDERSTATE_STIPPLEPATTERN13:
        case D3DRENDERSTATE_STIPPLEPATTERN14:
        case D3DRENDERSTATE_STIPPLEPATTERN15:
        case D3DRENDERSTATE_STIPPLEPATTERN16:
        case D3DRENDERSTATE_STIPPLEPATTERN17: 
        case D3DRENDERSTATE_STIPPLEPATTERN18:
        case D3DRENDERSTATE_STIPPLEPATTERN19:
        case D3DRENDERSTATE_STIPPLEPATTERN20:
        case D3DRENDERSTATE_STIPPLEPATTERN21:
        case D3DRENDERSTATE_STIPPLEPATTERN22:
        case D3DRENDERSTATE_STIPPLEPATTERN23: 
        case D3DRENDERSTATE_STIPPLEPATTERN24:
        case D3DRENDERSTATE_STIPPLEPATTERN25:
        case D3DRENDERSTATE_STIPPLEPATTERN26:
        case D3DRENDERSTATE_STIPPLEPATTERN27:
        case D3DRENDERSTATE_STIPPLEPATTERN28:
        case D3DRENDERSTATE_STIPPLEPATTERN29:   
        case D3DRENDERSTATE_STIPPLEPATTERN30:
        case D3DRENDERSTATE_STIPPLEPATTERN31:     
            DISPDBG((DBGLVL, "SET D3DRS_STIPPLEPATTERN 2%d = 0x%x",
                        dwRSType - D3DRENDERSTATE_STIPPLEPATTERN00, 
                        dwRSVal));
                        
            pContext->CurrentStipple
                       [(dwRSType - D3DRENDERSTATE_STIPPLEPATTERN00)] = dwRSVal;
                       
            if (!(*pFlags & SURFACE_ALPHASTIPPLE))
            {
                // Flat-Stippled Alpha is not on, so use the current stipple pattern
                SEND_P3_DATA_OFFSET(AreaStipplePattern0,
                        (DWORD)dwRSVal, dwRSType - D3DRENDERSTATE_STIPPLEPATTERN00);
            }

            break;

        case D3DRENDERSTATE_ROP2:
            DISPDBG((DBGLVL, "SET D3DRS_ROP2 = 0x%x",dwRSVal));
            NOT_HANDLED;
            break;
            
        case D3DRENDERSTATE_PLANEMASK:
            DISPDBG((DBGLVL, "SET D3DRS_PLANEMASK = 0x%x",dwRSVal));
            SEND_P3_DATA(FBHardwareWriteMask, (DWORD)dwRSVal);
            break;
            
        case D3DRENDERSTATE_MONOENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_MONOENABLE = 0x%x", dwRSVal));
            if (dwRSVal)
            {
                *pFlags |= SURFACE_MONO;
            }
            else
            {
                *pFlags &= ~SURFACE_MONO;
            }
            break;
            
        case D3DRENDERSTATE_SUBPIXEL:
            DISPDBG((DBGLVL, "SET D3DRS_SUBPIXEL = 0x%x", dwRSVal));
            NOT_HANDLED;
            break;
            
        case D3DRENDERSTATE_SUBPIXELX:
            DISPDBG((DBGLVL, "SET D3DRS_SUBPIXELX = 0x%x", dwRSVal));
            NOT_HANDLED;
            break;
            
        case D3DRENDERSTATE_STIPPLEENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_STIPPLEENABLE = 0x%x", dwRSVal));
            if (dwRSVal)
            {
                if (!(*pFlags & SURFACE_ALPHASTIPPLE))
                {
                    RENDER_AREA_STIPPLE_ENABLE(pContext->RenderCommand);
                }
                pContext->bKeptStipple = TRUE;
            }
            else
            {
                RENDER_AREA_STIPPLE_DISABLE(pContext->RenderCommand);
                pContext->bKeptStipple = FALSE;
            }
            break;

        case D3DRENDERSTATE_COLORKEYENABLE:
            DISPDBG((DBGLVL, "SET D3DRS_COLORKEYENABLE = 0x%x",dwRSVal));
            DIRTY_TEXTURE(pContext);
            DIRTY_ALPHATEST(pContext);
            DIRTY_PIPELINEORDER(pContext);
            DIRTY_OPTIMIZE_ALPHA(pContext);
            break;       
            
        //----------------------------------------------------------------------
        //----------------------------------------------------------------------
        // The default case handles any other unknown renderstate
        //----------------------------------------------------------------------
        //----------------------------------------------------------------------        

        default:
            // There are a few states that we just don't understand.
            DISPDBG((WRNLVL, "_D3D_ST_ProcessOneRenderState"
                             " Unhandled opcode = %d", dwRSType));
            //SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
            break;
    }

    // Commit DMA Buffer
    P3_DMA_COMMIT_BUFFER();

    DBG_EXIT(_D3D_ST_ProcessOneRenderState,0); 

    return DD_OK;
    
} // _D3D_ST_ProcessOneRenderState 


//-----------------------------------------------------------------------------
//
// _D3D_ST_ProcessRenderStates
//
// Updates the context's renderstates processing an array of D3DSTATE 
// structures with dwStateCount elements in it. bDoOverride indicates
// if legacy state overrides are to be taken into account.
//-----------------------------------------------------------------------------

DWORD 
_D3D_ST_ProcessRenderStates(
    P3_D3DCONTEXT* pContext, 
    DWORD dwStateCount, 
    D3DSTATE *pState, 
    BOOL bDoOverride)
{
    DWORD dwCurrState;

    DBG_ENTRY(_D3D_ST_ProcessRenderStates); 

    DISPDBG((DBGLVL, "_D3D_ST_ProcessRenderStates: "
                     "Valid Context =%08lx, dwStateCount=%d",
                     pContext, dwStateCount));

    for (dwCurrState = 0; dwCurrState < dwStateCount; dwCurrState++, pState++)
    {
        DWORD dwRSType = (DWORD) pState->drstRenderStateType;
        DWORD dwRSVal = pState->dwArg[0];

        // Override states for legacy API apps
        if (bDoOverride)
        {
            // Make sure the override is within the valid range
            if ((dwRSType >= (D3DSTATE_OVERRIDE_BIAS + MAX_STATE)) ||
                (dwRSType < 1))
            {
                DISPDBG((ERRLVL, "_D3D_ST_ProcessRenderStates: "
                                 "Invalid render state %d",
                                 dwRSType));
                continue;
            }

            if (IS_OVERRIDE(dwRSType)) 
            {
                DWORD override = GET_OVERRIDE(dwRSType);
                if (dwRSVal) 
                {
                    DISPDBG((DBGLVL, "_D3D_ST_ProcessRenderStates: "
                                     "setting override for state %d", 
                                     override));
                    STATESET_SET(pContext->overrides, override);
                }
                else 
                {
                    DISPDBG((DBGLVL, "_D3D_ST_ProcessRenderStates: "
                                     "clearing override for state %d", 
                                     override));
                    STATESET_CLEAR(pContext->overrides, override);
                }
                continue;
            }

            if (STATESET_ISSET(pContext->overrides, dwRSType)) 
            {
                DISPDBG((DBGLVL, "_D3D_ST_ProcessRenderStates: "
                                 "state %d is overridden, ignoring", 
                                 dwRSType));
                continue;
            }
        }

        // Make sure the render state is within the valid range
        if ((dwRSType >= MAX_STATE) || (dwRSType < 1))
        {
            continue;
        }

#if DX7_D3DSTATEBLOCKS
        if (pContext->bStateRecMode)
        {
            // Record this render state into the 
            // current state set being recorded
            _D3D_SB_RecordStateSetRS(pContext, dwRSType, dwRSVal);        
        }
        else
#endif //DX7_D3DSTATEBLOCKS        
        {
            // Process the next render state
            _D3D_ST_ProcessOneRenderState(pContext, dwRSType, dwRSVal);
        }

    }

    DBG_EXIT(_D3D_ST_ProcessRenderStates,0); 

    return DD_OK;
    
} // _D3D_ST_ProcessRenderStates 

//-----------------------------------------------------------------------------
//
// _D3D_ST_RealizeHWStateChanges
//
// Verifies if there are pending hardware render state changes to set up, 
// before proceeding to rasterize/render primitives. This might be convenient
// if the combined setting of some renderstates allows us to optimize the
// hardware setup in some way.
//
//-----------------------------------------------------------------------------
BOOL 
_D3D_ST_RealizeHWStateChanges( 
    P3_D3DCONTEXT* pContext)
{
    P3_THUNKEDDATA *pThisDisplay;

    DBG_ENTRY(_D3D_ST_RealizeHWStateChanges);     

    pThisDisplay = pContext->pThisDisplay;

    // Check if a flip or a mode change have happened. If so, we will 
    // need to setup the render target registers before doing any 
    // new rendering
    if (pContext->ModeChangeCount != pThisDisplay->ModeChangeCount) 
    {
        pContext->ModeChangeCount = pThisDisplay->ModeChangeCount;
        pThisDisplay->bFlippedSurface = TRUE;
    }

    if (pThisDisplay->bFlippedSurface) 
    {
        DIRTY_RENDER_OFFSETS(pContext);
    }

    // If there are any pending renderstates to process, do so
    if ( pContext->dwDirtyFlags )
    {
        // Now setup any pending hardware state necessary to correctly 
        // render our primitives
        __ST_HandleDirtyP3State( pThisDisplay, pContext);      

        // Mark the context as up to date
        pContext->dwDirtyFlags = 0;

        // Verify that the working set textures are valid so we may proceed
        // with rendering. Otherwise we will abort the attempt to render
        // anything
        if (!pContext->bTextureValid)
        {
            DISPDBG((ERRLVL,"ERROR: _D3D_ST_RealizeHWStateChanges:"
                            "Invalid Texture Handle, not rendering"));

            // re-dirty the texture setup so that we may try again later
            pContext->dwDirtyFlags |= CONTEXT_DIRTY_TEXTURE;

            DBG_EXIT(_D3D_ST_RealizeHWStateChanges,1);   
            return FALSE;
        }
    }

    DBG_EXIT(_D3D_ST_RealizeHWStateChanges,0);   

    return TRUE;
} // _D3D_ST_RealizeHWStateChanges
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dstrct.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dstrct.c
*
* Content: Internal D3D structure management.
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "glint.h"
#include "d3dstrct.h"

//----------------------------------------------------------------------------
// This file provides a centralized place where we manage ans use internal
// data structures for the driver. This way, we can change the data structure
// or its management without affecting the rest of the code.
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//********************** A R R A Y     S T R U C T U R E *********************
//----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// PA_CreateArray
//
// Creates an array of pointers.
//
//-----------------------------------------------------------------------------
PointerArray* 
PA_CreateArray()
{
    PointerArray* pNewArray;
    
    pNewArray = HEAP_ALLOC(HEAP_ZERO_MEMORY, 
                           sizeof(PointerArray),
                           ALLOC_TAG_DX(5));

    if (!pNewArray)
    {
        DISPDBG((ERRLVL,"ERROR: PointerArray allocation failed"));
        return NULL;
    }

    // Explicit initialization
    pNewArray->pPointers          = NULL;
    pNewArray->dwNumPointers      = 0;
    pNewArray->pfnDestroyCallback = NULL;
    
    return pNewArray;
} // PA_CreateArray

//-----------------------------------------------------------------------------
//
// PA_SetDataDestroyCallback
//
// Records the data pointer destroy callback.
//
//-----------------------------------------------------------------------------
void 
PA_SetDataDestroyCallback(
    PointerArray* pArray, 
    PA_DestroyCB DestroyCallback)
{
    pArray->pfnDestroyCallback = DestroyCallback;
    
} // PA_SetDataDestroyCallback

//-----------------------------------------------------------------------------
//
// PA_DestroyArray
//
// Destroys all the pointers in the array.  Optionally calls a callback with 
// each pointer to allow clients to free objects associated with the pointer
//-----------------------------------------------------------------------------
BOOL 
PA_DestroyArray(PointerArray* pArray, VOID *pExtra)
{
    if (pArray != NULL)
    {
        if (pArray->pPointers != NULL)
        {
            DWORD dwCount;
            
            // If there is a registered destroy callback, call it for every
            // non-null data pointer
            if (pArray->pfnDestroyCallback != NULL) 
            {
                for (dwCount = 0; dwCount < pArray->dwNumPointers; dwCount++)
                {
                    if (pArray->pPointers[dwCount] != 0)
                    {
                        // Call the data destroy callback
                        pArray->pfnDestroyCallback(
                                        pArray, 
                                        (void*)pArray->pPointers[dwCount],
                                        pExtra);
                    }
                }
            }

            // Free the Array of Pointers
            HEAP_FREE(pArray->pPointers);
            pArray->pPointers = NULL;
        }

        // Free the pointer array
        HEAP_FREE(pArray);
    }

    return TRUE;
} // PA_DestroyArray

//-----------------------------------------------------------------------------
//
// PA_GetEntry
//
// Look up the Pointer in the array an return it
//
//-----------------------------------------------------------------------------
void* 
PA_GetEntry(PointerArray* pArray, DWORD dwNum)
{
    ASSERTDD((pArray != NULL), "ERROR: Bad Pointer array!");

    if ((pArray->dwNumPointers == 0)         || 
        (dwNum > (pArray->dwNumPointers - 1))  )
    {
        // We will be getting called frequently by D3DCreateSurfaceEx for
        // handles which might not be initialized so this will be hit often
        DISPDBG((DBGLVL,"PA_GetEntry: Ptr outside of range (usually OK)"));
        return NULL;
    }

    return (void*)pArray->pPointers[dwNum]; 
} // PA_GetEntry

//-----------------------------------------------------------------------------
//
// PA_SetEntry
//
// Sets an entry in the array of pointers.  If the entry is larger than
// the array, the array is grown to accomodate it. Returns FALSE if we
// fail to set the data for any reason (mainly out of memory).
//
//-----------------------------------------------------------------------------
BOOL 
PA_SetEntry(
    PointerArray* pArray, 
    DWORD dwNum, 
    void* pData)
{   
    ASSERTDD(pArray != NULL, "Bad pointer array");

    if ( (dwNum + 1 ) > pArray->dwNumPointers )
    {
        ULONG_PTR* pNewArray;
        DWORD dwNewArrayLength, dwNewArraySize;
        
        //
        // The array either already exists and has to be grown in size
        // or doesnt exist at all
        //
        
        DISPDBG((DBGLVL, "Expanding/creating pointer array"));
        
        dwNewArrayLength = (dwNum * 2) + 1; // Tunable heuristic
                                            // ask for double of the space
                                            // needed for the new element
        dwNewArraySize = dwNewArrayLength * sizeof(ULONG_PTR);
        pNewArray = (ULONG_PTR*)HEAP_ALLOC(HEAP_ZERO_MEMORY,
                                           dwNewArraySize,
                                           ALLOC_TAG_DX(7));
        if (pNewArray == NULL)
        {
            DISPDBG((DBGLVL,"ERROR: Failed to allocate new Pointer array!!"));
            return FALSE;
        }

        if (pArray->pPointers != NULL)
        {
            // We had an old valid array before this, so we need to transfer 
            // old array elements into the new array and destroy the old array
            memcpy( pNewArray, 
                    pArray->pPointers,
                    (pArray->dwNumPointers * sizeof(ULONG_PTR)) );
                    
            HEAP_FREE(pArray->pPointers);

        }

        // Update our pointer to the array and its size info
        pArray->pPointers = pNewArray;
        pArray->dwNumPointers = dwNewArrayLength;
    }

    pArray->pPointers[dwNum] = (ULONG_PTR)pData;

    return TRUE;
    
} // PA_SetEntry

//----------------------------------------------------------------------------
//********************** H A S H       S T R U C T U R E *********************
//----------------------------------------------------------------------------

// Manages a hash table
// Each slot contains front and back pointers, a handle, and an app-specific 
// data pointer. Entries are the things that the clients add/remove
// Slots are the internal data chunks that are managed as part of the hash table

//-----------------------------------------------------------------------------
//
// HT_CreateHashTable
//
//-----------------------------------------------------------------------------
HashTable* 
HT_CreateHashTable()
{
    HashTable* pHashTable;

    DISPDBG((DBGLVL,"In HT_CreateHashTable"));

    pHashTable = (HashTable*)HEAP_ALLOC(HEAP_ZERO_MEMORY,
                                        sizeof(HashTable),
                                        ALLOC_TAG_DX(8));
    if (pHashTable == NULL)
    {
        DISPDBG((DBGLVL,"Hash table alloc failed!"));
        return NULL;
    }   

    return pHashTable;
} // HT_CreateHashTable


//-----------------------------------------------------------------------------
//
// HT_SetDataDestroyCallback
//
//-----------------------------------------------------------------------------
void 
HT_SetDataDestroyCallback(
    HashTable* pHashTable, 
    DataDestroyCB DestroyCallback)
{
    DISPDBG((DBGLVL,"In HT_SetDataDestroyCallback"));
    ASSERTDD(pHashTable != NULL,"ERROR: HashTable passed in is not valid!");

    pHashTable->pfnDestroyCallback = DestroyCallback;
} // HT_SetDataDestroyCallback

//-----------------------------------------------------------------------------
//
// HT_ClearEntriesHashTable
//
//-----------------------------------------------------------------------------
void 
HT_ClearEntriesHashTable(HashTable* pHashTable, VOID* pExtra)
{
    int i;
    HashSlot* pHashSlot = NULL;

    DISPDBG((DBGLVL,"In HT_ClearEntriesHashTable"));
    
    ASSERTDD(pHashTable != NULL,"ERROR: HashTable passed in is not valid!");

    for (i = 0; i < HASH_SIZE; i++)
    {
        while (pHashSlot = pHashTable->Slots[i])
        {
            HT_RemoveEntry(pHashTable, pHashSlot->dwHandle, pExtra);
        }

        pHashTable->Slots[i] = NULL;
    }

} // HT_ClearEntriesHashTable

//-----------------------------------------------------------------------------
//
// HT_DestroyHashTable
//
//-----------------------------------------------------------------------------
void 
HT_DestroyHashTable(HashTable* pHashTable, VOID* pExtra)
{

    HT_ClearEntriesHashTable(pHashTable, pExtra);

    HEAP_FREE(pHashTable);

} // HT_DestroyHashTable


//-----------------------------------------------------------------------------
//
// vBOOL HT_AddEntry
//
//-----------------------------------------------------------------------------
BOOL HT_AddEntry(HashTable* pTable, ULONG_PTR dwHandle, void* pData)
{
    HashSlot* pHashSlot = NULL;
    
    DISPDBG((DBGLVL,"In HT_AddEntry"));
    ASSERTDD(pTable != NULL,"ERROR: HashTable passed in is not valid!");

    pHashSlot = HEAP_ALLOC(HEAP_ZERO_MEMORY,
                           sizeof(HashSlot),
                           ALLOC_TAG_DX(9));
    
    if (pHashSlot == NULL)
    {
        DISPDBG((ERRLVL,"Hash entry alloc failed!"));
        return FALSE;
    }
    
    // Sew this new entry into the hash table
    if (pTable->Slots[HT_HASH_OF(dwHandle)])
    {
        pTable->Slots[HT_HASH_OF(dwHandle)]->pPrev = pHashSlot;
    }
           
    // Carry on a next pointer
    pHashSlot->pNext = pTable->Slots[HT_HASH_OF(dwHandle)];    
    pHashSlot->pPrev = NULL;      

    // Remember the app-supplied data and the handle
    pHashSlot->pData = pData;
    pHashSlot->dwHandle = dwHandle;

    // hash table refers to this one now.
    pTable->Slots[HT_HASH_OF(dwHandle)] = pHashSlot; 

    return TRUE;
} // HT_AddEntry

//-----------------------------------------------------------------------------
//
// BOOL HT_RemoveEntry
//
//-----------------------------------------------------------------------------
BOOL HT_RemoveEntry(HashTable* pTable, ULONG_PTR dwHandle, VOID *pExtra)
{
    HashSlot* pSlot = HT_GetSlotFromHandle(pTable, dwHandle);

    DISPDBG((DBGLVL,"In HT_RemoveEntry"));
    ASSERTDD(pTable != NULL,"ERROR: HashTable passed in is not valid!");

    if (pSlot == NULL)
    {
        DISPDBG((WRNLVL,"WARNING: Hash entry does not exist"));
        return FALSE;
    }

    // Mark the entry as gone from the hash table if it is at the front
    if (pTable->Slots[HT_HASH_OF(dwHandle)]->dwHandle == pSlot->dwHandle) 
    {
        pTable->Slots[HT_HASH_OF(dwHandle)] = 
                        pTable->Slots[HT_HASH_OF(dwHandle)]->pNext;
    }

    // and sew the list back together.
    if (pSlot->pPrev)
    {
        pSlot->pPrev->pNext = pSlot->pNext;
    }

    if (pSlot->pNext)
    {
        pSlot->pNext->pPrev = pSlot->pPrev;
    }

    // If the destroy data callback is setup, call it.
    if ((pSlot->pData != NULL) && (pTable->pfnDestroyCallback))
    {
        DISPDBG((WRNLVL,"Calling DestroyCallback for undestroyed data"));
        pTable->pfnDestroyCallback(pTable, pSlot->pData, pExtra);
    }

    // Free the memory associated with the slot
    HEAP_FREE(pSlot);

    return TRUE;
} // HT_RemoveEntry

//-----------------------------------------------------------------------------
//
// BOOL HT_SwapEntries
//
//-----------------------------------------------------------------------------
BOOL HT_SwapEntries(HashTable* pTable, DWORD dwHandle1, DWORD dwHandle2)
{
    HashSlot* pEntry1;
    HashSlot* pEntry2;
    void* pDataTemp;

    ASSERTDD(pTable != NULL,"ERROR: HashTable passed in is not valid!");

    pEntry1 = HT_GetSlotFromHandle(pTable, dwHandle1);
    pEntry2 = HT_GetSlotFromHandle(pTable, dwHandle2);

    // The handle remains the same, the pointers to the actual data are swapped
    if (pEntry1 && pEntry2)
    {
        pDataTemp = pEntry1->pData;
        pEntry1->pData = pEntry2->pData;
        pEntry2->pData = pDataTemp;

        return TRUE;
    }

    DISPDBG((ERRLVL,"ERROR: Swapped entries are invalid!"));
    
    return FALSE;
} // HT_SwapEntries
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dsset.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dsset.c
*
* Content: State set (block) management
*
* Copyright (c) 1999-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#include "glint.h"

//-----------------------------------------------------------------------------
// This module implements an emulation mechanism for handling state blocks 
// (which are a required feature of the DX7 DDI) for hardware that doesn't
// offer any silicon support of the feature. It works simply by recording the
// render states and texture stage states set during state block recording
// and then "plays" them back when execution of the stage state is requested.
// Internal data structures are interchangeable between an uncompressed
// version (for recording speed) and a compressed format (for memory
// efficiency) since it is anticipated some apps may request thousands of 
// state blocks.
//
// The following symbols have to be replaced according to your perticular
// driver implementation:
//                          - HEAP_ALLOC
//                          - HEAP_FREE
//                          - DISPDBG
//                          - _D3D_ST_ProcessOneRenderState
//                          - _D3D_TXT_ParseTextureStageStates
//-----------------------------------------------------------------------------

#if DX7_D3DSTATEBLOCKS

//-----------------------------------------------------------------------------
//
// P3StateSetRec *__SB_FindStateSet
//
// Find a state identified by dwHandle starting from pRootSS.
// If not found, returns NULL.
//
//-----------------------------------------------------------------------------
P3StateSetRec *__SB_FindStateSet(P3_D3DCONTEXT *pContext,
                                 DWORD dwHandle)
{
    if (dwHandle <= pContext->dwMaxSSIndex)
    {
        return pContext->pIndexTableSS[dwHandle - 1];
    }
    else
    {
        DISPDBG((DBGLVL,"State set %x not found (Max = %x)",
                        dwHandle, pContext->dwMaxSSIndex));
        return NULL;
    }
} // __SB_FindStateSet

//-----------------------------------------------------------------------------
//
// void __SB_DumpStateSet
//
// Dump info stored in a state set
//
//-----------------------------------------------------------------------------
#define ELEMS_IN_ARRAY(a) ((sizeof(a)/sizeof(a[0])))

void __SB_DumpStateSet(P3StateSetRec *pSSRec)
{
    DWORD i,j;

    DISPDBG((DBGLVL,"__SB_DumpStateSet %x, Id=%x dwSSFlags=%x",
                    pSSRec,pSSRec->dwHandle,pSSRec->dwSSFlags));

    if (!(pSSRec->dwSSFlags & SB_COMPRESSED))
    {
        // uncompressed state set

        // Dump render states values
        for (i=0; i< MAX_STATE; i++)
        {
            DISPDBG((DBGLVL,"RS %x = %x",i, pSSRec->uc.RenderStates[i]));
        }

        // Dump TSS's values
        for (j=0; j<= SB_MAX_STAGES; j++)
        {
            for (i=0; i<= D3DTSS_TEXTURETRANSFORMFLAGS; i++)
            {
                DISPDBG((DBGLVL,"TSS [%x] %x = %x",
                                j, i, pSSRec->uc.TssStates[j][i]));
            }
        }

        // Dump RS bit masks
        for (i=0; i< ELEMS_IN_ARRAY(pSSRec->uc.bStoredRS); i++)
        {
            DISPDBG((DBGLVL,"bStoredRS[%x] = %x",
                            i, pSSRec->uc.bStoredRS[i]));
        }

        // Dump TSS bit masks
        for (j=0; j<= SB_MAX_STAGES; j++)
        {        
            for (i=0; i< ELEMS_IN_ARRAY(pSSRec->uc.bStoredTSS[j]); i++)
            {
                DISPDBG((DBGLVL,"bStoredTSS[%x][%x] = %x",
                                j, i, pSSRec->uc.bStoredTSS[j][i]));
            }
        }

    }
    else
    {
        // compressed state set

        D3DHAL_DP2COMMAND              *pDP2Cmd;
        D3DHAL_DP2RENDERSTATE          *pDP2RenderState;
        D3DHAL_DP2TEXTURESTAGESTATE    *pDP2TSState;

        pDP2Cmd = pSSRec->cc.pDP2RenderState;
        if (pDP2Cmd) 
        {
            DISPDBG((DBGLVL,"dwNumRS =%x", pDP2Cmd->wStateCount));
            pDP2RenderState = (D3DHAL_DP2RENDERSTATE *)(pDP2Cmd + 1);
            for (i=0; i< pDP2Cmd->wStateCount; i++, pDP2RenderState++)
            {
                DISPDBG((DBGLVL,"RS %x = %x",
                                pDP2RenderState->RenderState, 
                                pDP2RenderState->dwState));
            }
        
        }

        pDP2Cmd = pSSRec->cc.pDP2TextureStageState;
        if (pDP2Cmd)
        {
            DISPDBG((DBGLVL,"dwNumTSS=%x", pDP2Cmd->wStateCount));
            pDP2TSState = (D3DHAL_DP2TEXTURESTAGESTATE *)(pDP2Cmd + 1);
            for (i = 0; i < pDP2Cmd->wStateCount; i++, pDP2TSState++)
            {
                DISPDBG((DBGLVL,"TSS [%x] %x = %x",
                                pDP2TSState->wStage,
                                pDP2TSState->TSState, 
                                pDP2TSState->dwValue));
            }        
        }
    }

} // __SB_DumpStateSet

//-----------------------------------------------------------------------------
//
// void __SB_AddStateSetIndexTableEntry
//
// Add an antry to the index table. If necessary, grow it.
//-----------------------------------------------------------------------------
void __SB_AddStateSetIndexTableEntry(P3_D3DCONTEXT* pContext,
                                     DWORD dwNewHandle,
                                     P3StateSetRec *pNewSSRec)
{
    DWORD dwNewSize;
    P3StateSetRec **pNewIndexTableSS;

    // If the current list is not large enough, we'll have to grow a new one.
    if (dwNewHandle > pContext->dwMaxSSIndex)
    {
        // New size of our index table
        // (round up dwNewHandle in steps of SSPTRS_PERPAGE)
        dwNewSize = ((dwNewHandle -1 + SSPTRS_PERPAGE) / SSPTRS_PERPAGE)
                      * SSPTRS_PERPAGE;

        // we have to grow our list
        pNewIndexTableSS = (P3StateSetRec **)
                                HEAP_ALLOC( FL_ZERO_MEMORY,
                                            dwNewSize*sizeof(P3StateSetRec *),
                                            ALLOC_TAG_DX(2));

        if (!pNewIndexTableSS)
        {
            // we weren't able to grow the list so we will keep the old one
            // and (sigh) forget about this state set since that is the 
            // safest thing to do. We will delete also the state set structure
            // since no one will otherwise be able to find it later.
            DISPDBG((ERRLVL,"Out of mem growing state set list,"
                            " droping current state set"));
            HEAP_FREE(pNewSSRec);
            return;
        }

        if (pContext->pIndexTableSS)
        {
            // if we already had a previous list, we must transfer its data
            memcpy(pNewIndexTableSS, 
                   pContext->pIndexTableSS,
                   pContext->dwMaxSSIndex*sizeof(P3StateSetRec *));
            
            //and get rid of it
            HEAP_FREE(pContext->pIndexTableSS);
        }

        // New index table data
        pContext->pIndexTableSS = pNewIndexTableSS;
        pContext->dwMaxSSIndex = dwNewSize;
    }

    // Store our state set pointer into our access list
    pContext->pIndexTableSS[dwNewHandle - 1] = pNewSSRec;
    
} // __SB_AddStateSetIndexTableEntry

//-----------------------------------------------------------------------------
//
// int __SB_GetCompressedSize
//
// Calculate the size of the compressed state set
//
//-----------------------------------------------------------------------------

int __SB_GetCompressedSize(P3_D3DCONTEXT* pContext, 
                           P3StateSetRec* pUncompressedSS,
                           OffsetsCompSS* offsetSS)
{
    DWORD   dwSize;
    DWORD   dwCount;
    int     i, j;

    // Calculate the size of fixed part
    dwSize = sizeof(CompressedStateSet) + 2*sizeof(DWORD);

    // Calculate size of the render states 
    dwCount = 0;
    for (i = 0; i < MAX_STATE; i++)
    {
        if (IS_FLAG_SET(pUncompressedSS->uc.bStoredRS , i))
        {
            dwCount++;
        }
    }
    if (dwCount) 
    {
        offsetSS->dwOffDP2RenderState = dwSize;
        dwSize += (sizeof(D3DHAL_DP2COMMAND) + dwCount * sizeof(D3DHAL_DP2RENDERSTATE));
    }

    // Calculate size of the texture stage states
    dwCount = 0;
    for (j = 0; j <= SB_MAX_STAGES; j++)
    {
        for (i = 0; i <= D3DTSS_TEXTURETRANSFORMFLAGS; i++)
        {
            if (IS_FLAG_SET(pUncompressedSS->uc.bStoredTSS[j] , i))
            {
                dwCount++;
            }
        }
    }
    if (dwCount) 
    {
        offsetSS->dwOffDP2TextureStageState = dwSize;
        dwSize += (sizeof(D3DHAL_DP2COMMAND) + dwCount * sizeof(D3DHAL_DP2TEXTURESTAGESTATE));
    }
    
    // Calculate size of Viewport and ZRange
    if (pUncompressedSS->uc.dwFlags & SB_VIEWPORT_CHANGED) 
    {
        offsetSS->dwOffDP2Viewport = dwSize;
        dwSize += (sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2VIEWPORTINFO));
    }

    if (pUncompressedSS->uc.dwFlags & SB_ZRANGE_CHANGED) 
    {
        offsetSS->dwOffDP2ZRange = dwSize;
        dwSize += (sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2ZRANGE));
    }

#if DX8_DDI
    if (pUncompressedSS->uc.dwFlags & SB_INDICES_CHANGED) 
    {
        offsetSS->dwOffDP2SetIndices = dwSize;
        dwSize += (sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETINDICES));
    }

    dwCount = 0;
    for (i = 0; i < D3DVS_INPUTREG_MAX_V1_1; i++) 
    {
        if (pUncompressedSS->uc.dwFlags & (SB_STREAMSRC_CHANGED << i)) 
        {
            dwCount++;
        }
    }
    if (dwCount) 
    {
        offsetSS->dwOffDP2SetStreamSources = dwSize;
        dwSize += (sizeof(D3DHAL_DP2COMMAND) + dwCount * sizeof(D3DHAL_DP2SETSTREAMSOURCE));
    }
#endif // DX8_DDI

#if DX7_SB_TNL
    // TODO, Calculate size needed for lights, clip planes, material, transformation
#endif // DX7_SB_TNL

#if DX7_SB_TNL
    // TODO, Calculate size needed for {V|P} shader constants
#endif // DX7_SB_TNL

#if DX8_DDI
    if (pUncompressedSS->uc.dwFlags & SB_CUR_VS_CHANGED) 
    {
        offsetSS->dwOffDP2SetVertexShader = dwSize;
        dwSize += (sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2VERTEXSHADER));
    }
#endif // DX8_DDI

    return (dwSize);
} // __SB_GetCompressedSize


//-----------------------------------------------------------------------------
//
// void __SB_CompressStateSet
//
// Compress a state set so it uses the minimum necessary space. Since we expect 
// some apps to make extensive use of state sets we want to keep things tidy.
// Returns address of new structure (ir old, if it wasn't compressed)
//
//-----------------------------------------------------------------------------
P3StateSetRec * __SB_CompressStateSet(P3_D3DCONTEXT* pContext,
                                      P3StateSetRec *pUncompressedSS)
{
    P3StateSetRec *pCompressedSS;
    LPBYTE pTmp;
    OffsetsCompSS offsetSS;
    DWORD i, j, dwSize, dwCount;
    D3DHAL_DP2COMMAND* pDP2Cmd;

    // Initialize the offset structure
    memset(&offsetSS, 0, sizeof(OffsetsCompSS));

    // Create a new state set of just the right size we need
    dwSize = __SB_GetCompressedSize(pContext, pUncompressedSS, &offsetSS);

    if (dwSize >= pUncompressedSS->uc.dwSize)
    {
        // it is not efficient to compress, leave uncompressed !
        pUncompressedSS->dwSSFlags &= (~SB_COMPRESSED);
        return pUncompressedSS;
    }

    pTmp = HEAP_ALLOC(FL_ZERO_MEMORY, dwSize, ALLOC_TAG_DX(3));
    if (! pTmp)
    {
        DISPDBG((ERRLVL,"Not enough memory left to compress D3D state set"));
        pUncompressedSS->dwSSFlags &= (~SB_COMPRESSED);
        return pUncompressedSS;
    }

    pCompressedSS = (P3StateSetRec *)pTmp;
        
    // Adjust data in new compressed state set
    pCompressedSS->dwSSFlags |= SB_COMPRESSED;
    pCompressedSS->dwHandle = pUncompressedSS->dwHandle;

    // Set up render state in the compressed state set
    if (offsetSS.dwOffDP2RenderState)
    {
        D3DHAL_DP2RENDERSTATE* pDP2RS;
        
        pDP2Cmd = (D3DHAL_DP2COMMAND *)(pTmp + offsetSS.dwOffDP2RenderState); 
        pCompressedSS->cc.pDP2RenderState = pDP2Cmd;
    
        pDP2Cmd->bCommand = D3DDP2OP_RENDERSTATE;
        pDP2RS = (D3DHAL_DP2RENDERSTATE *)(pDP2Cmd + 1);
    
        for (i = 0; i < MAX_STATE; i++)
        {
            if (IS_FLAG_SET(pUncompressedSS->uc.bStoredRS , i))
            {
                pDP2RS->RenderState = i;
                pDP2RS->dwState = pUncompressedSS->uc.RenderStates[i];
                pDP2RS++;
            }
        }

        pDP2Cmd->wStateCount = (WORD)(pDP2RS - ((D3DHAL_DP2RENDERSTATE *)(pDP2Cmd + 1)));
    }

    // Set up texture stage state in the compress state set
    if (offsetSS.dwOffDP2TextureStageState)
    {
        D3DHAL_DP2TEXTURESTAGESTATE* pDP2TSS;
        
        pDP2Cmd = (D3DHAL_DP2COMMAND *)(pTmp + offsetSS.dwOffDP2TextureStageState);
        pCompressedSS->cc.pDP2TextureStageState = pDP2Cmd;
    
        pDP2Cmd->bCommand = D3DDP2OP_TEXTURESTAGESTATE;
        pDP2TSS = (D3DHAL_DP2TEXTURESTAGESTATE *)(pDP2Cmd + 1);
    
        for (j = 0; j < SB_MAX_STAGES; j++)
        {
            for (i = 0; i <= D3DTSS_TEXTURETRANSFORMFLAGS; i++)
            {
                if (IS_FLAG_SET(pUncompressedSS->uc.bStoredTSS[j] , i))
                {
                    pDP2TSS->wStage = (WORD)j;                   
                    pDP2TSS->TSState = (WORD)i;
                    pDP2TSS->dwValue =  pUncompressedSS->uc.TssStates[j][i];
                    pDP2TSS++;
                }
            }
        }

        pDP2Cmd->wStateCount = (WORD)(pDP2TSS - ((D3DHAL_DP2TEXTURESTAGESTATE *)(pDP2Cmd + 1)));
    }

    // Set up the viewport and zrange in the compressed state set
    if (offsetSS.dwOffDP2Viewport) 
    {
        D3DHAL_DP2VIEWPORTINFO* pDP2ViewPort;

        pDP2Cmd = (D3DHAL_DP2COMMAND *)(pTmp + offsetSS.dwOffDP2Viewport);
        pCompressedSS->cc.pDP2Viewport = pDP2Cmd;
        
        pDP2Cmd->bCommand = D3DDP2OP_VIEWPORTINFO;
        pDP2ViewPort = (D3DHAL_DP2VIEWPORTINFO *)(pDP2Cmd + 1);

        *pDP2ViewPort = pUncompressedSS->uc.viewport;
    }
    
    if (offsetSS.dwOffDP2ZRange) 
    {
        D3DHAL_DP2ZRANGE* pDP2ZRange;

        pDP2Cmd = (D3DHAL_DP2COMMAND *)(pTmp + offsetSS.dwOffDP2ZRange);
        pCompressedSS->cc.pDP2ZRange = pDP2Cmd;

        pDP2Cmd->bCommand = D3DDP2OP_ZRANGE;
        pDP2ZRange = (D3DHAL_DP2ZRANGE *)(pDP2Cmd + 1);

        *pDP2ZRange = pUncompressedSS->uc.zRange;
    }
    
#if DX8_DDI
    // Set up the vertex shader in the compressed state set
    if (offsetSS.dwOffDP2SetIndices) 
    {
        D3DHAL_DP2SETINDICES* pDP2SetIndices;

        pDP2Cmd = (D3DHAL_DP2COMMAND *)(pTmp + offsetSS.dwOffDP2SetIndices);
        pCompressedSS->cc.pDP2SetIndices = pDP2Cmd;

        pDP2Cmd->bCommand = D3DDP2OP_SETINDICES;
        pDP2SetIndices = (D3DHAL_DP2SETINDICES *)(pDP2Cmd + 1);

        *pDP2SetIndices = pUncompressedSS->uc.vertexIndex;

        pDP2Cmd->wStateCount = 1;
    }

    // Set up the vertex shader in the compressed state set
    if (offsetSS.dwOffDP2SetStreamSources) 
    {
        D3DHAL_DP2SETSTREAMSOURCE* pDP2SetStmSrc;

        pDP2Cmd = (D3DHAL_DP2COMMAND *)(pTmp + offsetSS.dwOffDP2SetStreamSources);
        pCompressedSS->cc.pDP2SetStreamSources = pDP2Cmd;

        pDP2Cmd->bCommand = D3DDP2OP_SETSTREAMSOURCE;
        pDP2SetStmSrc = (D3DHAL_DP2SETSTREAMSOURCE *)(pDP2Cmd + 1);

        for (i = 0; i < D3DVS_INPUTREG_MAX_V1_1; i++) 
        {
            if (pUncompressedSS->uc.dwFlags & (SB_STREAMSRC_CHANGED << i)) 
            {
                *pDP2SetStmSrc = pUncompressedSS->uc.streamSource[i];
                pDP2SetStmSrc++;
            }
        }

        pDP2Cmd->wPrimitiveCount = (WORD)(pDP2SetStmSrc - ((D3DHAL_DP2SETSTREAMSOURCE *)(pDP2Cmd + 1)) );
    }
#endif // DX8_DDI

#if DX7_SB_TNL
    // TODO, set up light, material, transform, clip plane
#endif // DX7_SB_TNL

#if DX8_SB_SHADERS
    // TODO, set up shader constants
#endif // DX8_SB_SHADERS

#if DX8_DDI
    // Set up the vertex shader in the compressed state set
    if (offsetSS.dwOffDP2SetVertexShader) 
    {
        D3DHAL_DP2VERTEXSHADER* pDP2SetVtxShader;

        pDP2Cmd = (D3DHAL_DP2COMMAND *)(pTmp + offsetSS.dwOffDP2SetVertexShader);
        pCompressedSS->cc.pDP2SetVertexShader = pDP2Cmd;

        pDP2Cmd->bCommand = D3DDP2OP_SETVERTEXSHADER;
        pDP2SetVtxShader = (D3DHAL_DP2VERTEXSHADER *)(pDP2Cmd + 1);

        pDP2SetVtxShader->dwHandle = pUncompressedSS->uc.dwCurVertexShader;
    }
#endif // DX8_DDI

    // Get rid of the old(uncompressed) one
    HEAP_FREE(pUncompressedSS);
    return pCompressedSS;

} // __SB_CompressStateSet


//-----------------------------------------------------------------------------
//
// void _D3D_SB_DeleteAllStateSets
//
// Delete any remaining state sets for cleanup purpouses
//
//-----------------------------------------------------------------------------
void _D3D_SB_DeleteAllStateSets(P3_D3DCONTEXT* pContext)
{
    P3StateSetRec *pSSRec;
    DWORD dwSSIndex;

    DISPDBG((DBGLVL,"_D3D_SB_DeleteAllStateSets"));

    if (pContext->pIndexTableSS)
    {
        for(dwSSIndex = 0; dwSSIndex < pContext->dwMaxSSIndex; dwSSIndex++)
        {
            if (pSSRec = pContext->pIndexTableSS[dwSSIndex])
            {
                HEAP_FREE(pSSRec);
            }
        }

        // free fast index table
        HEAP_FREE(pContext->pIndexTableSS);
    }
    
} // _D3D_SB_DeleteAllStateSets

//-----------------------------------------------------------------------------
//
// void _D3D_SB_BeginStateSet
//
// Create a new state set identified by dwParam and start recording states
//
//-----------------------------------------------------------------------------
void _D3D_SB_BeginStateSet(P3_D3DCONTEXT* pContext, DWORD dwParam)
{
    DWORD dwSSSize;
    P3StateSetRec *pSSRec;

    DISPDBG((DBGLVL,"_D3D_SB_BeginStateSet dwParam=%08lx",dwParam));
    
    // Calculate the maximum size of the state set
    dwSSSize = sizeof(P3StateSetRec);
#if DX7_SB_TNL
    // TODO, Size depends on number of lights, clip planes
#endif // DX7_SB_TNL

#if DX8_SB_SHADERS
    // TODO, size depends on number of vertext/pixel shaders
#endif // DX8_SB_SHADERS
    
    // Create a new state set
    pSSRec = (P3StateSetRec *)HEAP_ALLOC(FL_ZERO_MEMORY, 
                                         dwSSSize, 
                                         ALLOC_TAG_DX(4));
    if (!pSSRec)
    {
        DISPDBG((ERRLVL,"Run out of memory for additional state sets"));
        return;
    }

    // Remember handle to current state set
    pSSRec->dwHandle = dwParam;
    pSSRec->dwSSFlags &= (~SB_COMPRESSED);

    // Remember the size of the uncompressed state set
    pSSRec->uc.dwSize = dwSSSize;

#if DX7_SB_TNL
    // TODO, Set up pointers for data used for lights, clip planes
#endif // DX7_SB_TNL

#if DX8_SB_SHADERS
    // TODO, Set up pointers for data used for {V|P} shader constants
#endif // DX8_SB_SHADERS

    // Get pointer to current recording state set
    pContext->pCurrSS = pSSRec;

    // Start recording mode
    pContext->bStateRecMode = TRUE;
    
} // _D3D_SB_BeginStateSet

//-----------------------------------------------------------------------------
//
// void _D3D_SB_EndStateSet
//
// stop recording states - revert to executing them.
//
//-----------------------------------------------------------------------------
void _D3D_SB_EndStateSet(P3_D3DCONTEXT* pContext)
{
    DWORD dwHandle;
    P3StateSetRec *pNewSSRec;

    DISPDBG((DBGLVL,"_D3D_SB_EndStateSet"));

    if (pContext->pCurrSS)
    {
        dwHandle = pContext->pCurrSS->dwHandle;

        // compress the current state set
        // Note: after being compressed the uncompressed version is free'd.
        pNewSSRec = __SB_CompressStateSet(pContext, pContext->pCurrSS);

        __SB_AddStateSetIndexTableEntry(pContext, dwHandle, pNewSSRec);
    }

    // No state set being currently recorded
    pContext->pCurrSS = NULL;

    // End recording mode
    pContext->bStateRecMode = FALSE;
    
} // _D3D_SB_EndStateSet

//-----------------------------------------------------------------------------
//
// void _D3D_SB_DeleteStateSet
//
// Delete the recorder state ste identified by dwParam
//
//-----------------------------------------------------------------------------
void _D3D_SB_DeleteStateSet(P3_D3DCONTEXT* pContext, DWORD dwParam)
{
    P3StateSetRec *pSSRec;
    DWORD i;
    
    DISPDBG((DBGLVL,"_D3D_SB_DeleteStateSet dwParam=%08lx",dwParam));

    if (pSSRec = __SB_FindStateSet(pContext, dwParam))
    {
        // Clear index table entry
        pContext->pIndexTableSS[dwParam - 1] = NULL;

        // Now delete the actual state set structure
        HEAP_FREE(pSSRec);
    }
    
} // _D3D_SB_DeleteStateSet

//-----------------------------------------------------------------------------
//
// void _D3D_SB_ExecuteStateSet
//
// Execute the render states and texture stage states of which a given 
// state set is comprised. Distinguish between the compressed and
// uncomressed representations of records. 
//
//-----------------------------------------------------------------------------
void _D3D_SB_ExecuteStateSet(P3_D3DCONTEXT* pContext, DWORD dwParam)
{
    P3StateSetRec *pSSRec;
    DWORD i,j;
    
    DISPDBG((DBGLVL,"_D3D_SB_ExecuteStateSet dwParam=%08lx",dwParam));
    
    if (pSSRec = __SB_FindStateSet(pContext, dwParam))
    {

        if (!(pSSRec->dwSSFlags & SB_COMPRESSED))
        {
            // uncompressed state set

            // Execute any necessary render states
            for (i=0; i< MAX_STATE; i++)
            {
                if (IS_FLAG_SET(pSSRec->uc.bStoredRS , i))
                {
                    DWORD dwRSType, dwRSVal;

                    dwRSType = i;
                    dwRSVal = pSSRec->uc.RenderStates[dwRSType];

                    // Store the state in the context
                    pContext->RenderStates[dwRSType] = dwRSVal;

                    DISPDBG((DBGLVL,"_D3D_SB_ExecuteStateSet RS %x = %x",
                                    dwRSType, dwRSVal));

                    // Process it
                    _D3D_ST_ProcessOneRenderState(pContext, dwRSType, dwRSVal);

                }
            }

            // Execute any necessary TSS's
            for (j=0; j<SB_MAX_STAGES; j++)
            {
                for (i=0; i<= D3DTSS_TEXTURETRANSFORMFLAGS; i++)
                {
                    if (IS_FLAG_SET(pSSRec->uc.bStoredTSS[j] , i))
                    {
                        D3DHAL_DP2TEXTURESTAGESTATE dp2TSS;

                        dp2TSS.TSState = (WORD)i;
                        dp2TSS.wStage = (WORD)j;                         
                        dp2TSS.dwValue = pSSRec->uc.TssStates[j][i];
                        
                        DISPDBG((DBGLVL,
                                 "_D3D_SB_ExecuteStateSet TSS %x [%x] = %x",
                                  dp2TSS.TSState,
                                  dp2TSS.wStage,
                                  dp2TSS.dwValue));
                                    
                        // If a state set is changed by _D3D_SB_CaptureStateSet(),
                        // then texture filter values in it are DX6 semantic, otherwise
                        // it is DX8
                        if (pSSRec->dwSSFlags & SB_VAL_CAPTURED)
                        {
                            _D3D_TXT_ParseTextureStageStates(pContext, 
                                                             &dp2TSS, 
                                                             1, 
                                                             FALSE); //It is already DX6
                        }
                        else
                        {
                            _D3D_TXT_ParseTextureStageStates(pContext, 
                                                             &dp2TSS, 
                                                             1, 
                                                             TRUE);
                        }
                    }
                }
            }

            // Excute viewport info, z range
            if (pSSRec->uc.dwFlags & SB_VIEWPORT_CHANGED) 
            {
                _D3D_OP_Viewport(pContext, &pSSRec->uc.viewport);
            }

            if (pSSRec->uc.dwFlags & SB_ZRANGE_CHANGED) 
            {
                _D3D_OP_ZRange(pContext, &pSSRec->uc.zRange);
            }

#if DX8_DDI
            // Excute vertex indices and stream sources
            if (pSSRec->uc.dwFlags & SB_INDICES_CHANGED) 
            {
                _D3D_OP_MStream_SetIndices(pContext,
                                           pSSRec->uc.vertexIndex.dwVBHandle,
                                           pSSRec->uc.vertexIndex.dwStride);
            }

            for (i = 0; i < D3DVS_INPUTREG_MAX_V1_1; i++) 
            {
                if (pSSRec->uc.dwFlags & (SB_STREAMSRC_CHANGED << i)) 
                {
                    _D3D_OP_MStream_SetSrc(pContext,
                                           pSSRec->uc.streamSource[i].dwStream,
                                           pSSRec->uc.streamSource[i].dwVBHandle,
                                           pSSRec->uc.streamSource[i].dwStride);
                }
            }
#endif // DX8_DDI

#if DX7_SB_TNL
            // TODO, Execute any necessary state for lights, materials, 
            // transforms, clip planes
#endif // DX7_SB_TNL
        
#if DX8_SB_SHADERS
            // TODO, Execute any necessary set current shader and set shader
            // constants pairs
#endif // DX8_SB_SHADERS

#if DX8_DDI
            // Note : This should be done after setting shader constants, since
            // current shader may have to be set before changing constants
            if (pSSRec->uc.dwFlags & SB_CUR_VS_CHANGED) 
            {
                _D3D_OP_VertexShader_Set(pContext,
                                         pSSRec->uc.dwCurVertexShader);
            }
#endif // DX8_DDI
        }
        else
        {
            // compressed state set
    
            // Execute any necessary RS's
            if (pSSRec->cc.pDP2RenderState) 
            {

                DISPDBG((DBGLVL, "_D3D_SB_ExecuteStateSet RenderState"));

                _D3D_ST_ProcessRenderStates(pContext, 
                                            pSSRec->cc.pDP2RenderState->wStateCount,
                                            (LPD3DSTATE)(pSSRec->cc.pDP2RenderState + 1),
                                            FALSE);
            }

            // Execute any necessary TSS's
            if (pSSRec->cc.pDP2TextureStageState)
            {
                DISPDBG((DBGLVL,"_D3D_SB_ExecuteStateSet TSS"));

                // If a state set is changed by _D3D_SB_CaptureStateSet(),
                // then texture filter values in it are DX6 semantic, otherwise
                // it is DX8
                if (pSSRec->dwSSFlags & SB_VAL_CAPTURED)
                {
                    _D3D_TXT_ParseTextureStageStates(pContext, 
                                                     (D3DHAL_DP2TEXTURESTAGESTATE *)(pSSRec->cc.pDP2TextureStageState + 1), 
                                                     pSSRec->cc.pDP2TextureStageState->wStateCount,
                                                     FALSE); // It is already DX6
                } 
                else
                {
                    _D3D_TXT_ParseTextureStageStates(pContext, 
                                                     (D3DHAL_DP2TEXTURESTAGESTATE *)(pSSRec->cc.pDP2TextureStageState + 1), 
                                                     pSSRec->cc.pDP2TextureStageState->wStateCount,
                                                     TRUE);
                }
            }

            // execute viewport info, z range             
            if (pSSRec->cc.pDP2Viewport) 
            {
                _D3D_OP_Viewport(pContext, 
                                 ((D3DHAL_DP2VIEWPORTINFO *)(pSSRec->cc.pDP2Viewport + 1)) 
                                );
            }

            if (pSSRec->cc.pDP2ZRange)
            {
                _D3D_OP_ZRange(pContext, 
                               ((D3DHAL_DP2ZRANGE *)(pSSRec->cc.pDP2ZRange + 1)) 
                               );
            }

#if DX8_DDI
            // Execute vertex index, stream, shader
            if (pSSRec->cc.pDP2SetIndices) 
            {
                D3DHAL_DP2SETINDICES* pDP2SetIndices;

                pDP2SetIndices = (D3DHAL_DP2SETINDICES *)(pSSRec->cc.pDP2SetIndices + 1);

                _D3D_OP_MStream_SetIndices(pContext,
                                           pDP2SetIndices->dwVBHandle,
                                           pDP2SetIndices->dwStride);
            }

            if (pSSRec->cc.pDP2SetStreamSources) 
            {
                D3DHAL_DP2SETSTREAMSOURCE *pDP2SetStmSrc;

                DISPDBG((DBGLVL,"More than 1 stream (%d)", 
                        pSSRec->cc.pDP2SetStreamSources->wStateCount));
                 
                pDP2SetStmSrc = (D3DHAL_DP2SETSTREAMSOURCE *)(pSSRec->cc.pDP2SetStreamSources + 1);
                ASSERTDD(pDP2SetStmSrc->dwStream == 0, "Wrong vertex stream");
                for (i = 0; i < pSSRec->cc.pDP2SetStreamSources->wStateCount; i++, pDP2SetStmSrc++) 
                {
                    _D3D_OP_MStream_SetSrc(pContext,
                                           pDP2SetStmSrc->dwStream,
                                           pDP2SetStmSrc->dwVBHandle,
                                           pDP2SetStmSrc->dwStride);
                }
            }
#endif // DX8_DDI

#if DX7_SB_TNL
            // TODO, Execute any necessary state for lights, materials, 
            // transforms, clip planes
#endif // DX7_SB_TNL

#if DX8_SB_SHADERS
            // TODO, Execute any necessary state for setting {V|P} shader constants 
#endif // DX8_SB_SHADERS

#if DX8_DDI
            // Execute current pixel shader (legacy FVF code)
            if (pSSRec->cc.pDP2SetVertexShader) 
            {
                _D3D_OP_VertexShader_Set(pContext,
                                         ((D3DHAL_DP2VERTEXSHADER *)(pSSRec->cc.pDP2SetVertexShader + 1))->dwHandle);
            }
#endif // DX8_DDI
        }
    }

} // _D3D_SB_ExecuteStateSet

//-----------------------------------------------------------------------------
//
// void _D3D_SB_CaptureStateSet
//
// Capture the render states and texture stage states of which a given 
// state set is comprised. Distinguish between the compressed and
// uncomressed representations of records. This functionality allows the
// app to have a push/pop state feature.
//
//-----------------------------------------------------------------------------
void _D3D_SB_CaptureStateSet(P3_D3DCONTEXT* pContext, DWORD dwParam)
{
    P3StateSetRec *pSSRec;
    DWORD i, j;

    DISPDBG((DBGLVL,"_D3D_SB_CaptureStateSet dwParam=%08lx",dwParam));

    if (pSSRec = __SB_FindStateSet(pContext, dwParam))
    {
        // Mark it as having DX6 texture filter values instead of DX8,
        // so that _D3D_SB_ExecuteStateSet() uses the FALSE for the
        // bTranslateDX8FilterValueToDX6 of _D3D_TXT_ParseTextureStageStates()
        pSSRec->dwSSFlags |= SB_VAL_CAPTURED;

        // Actually capture the values
        if (!(pSSRec->dwSSFlags & SB_COMPRESSED))
        {
            // uncompressed state set

            // Capture any necessary render states
            for (i=0; i< MAX_STATE; i++)
                if (IS_FLAG_SET(pSSRec->uc.bStoredRS , i))
                {
                    pSSRec->uc.RenderStates[i] = pContext->RenderStates[i];
                }

            // Capture any necessary TSS's
            for (j=0; j<SB_MAX_STAGES; j++)
            {
                for (i=0; i<= D3DTSS_TEXTURETRANSFORMFLAGS; i++)
                {
                    if (IS_FLAG_SET(pSSRec->uc.bStoredTSS[j] , i))
                    {
                        pSSRec->uc.TssStates[j][i] = 
                                    pContext->TextureStageState[j].m_dwVal[i];
                             
                    }
                }
            }

            // Capture viewport info, z range
            if (pSSRec->uc.dwFlags & SB_VIEWPORT_CHANGED) 
            {
                pSSRec->uc.viewport = pContext->ViewportInfo;
            }

            if (pSSRec->uc.dwFlags & SB_ZRANGE_CHANGED) 
            {
                pSSRec->uc.zRange = pContext->ZRange;
            }

#if DX8_DDI
            // Capture vertex indices and stream sources
            if (pSSRec->uc.dwFlags & SB_INDICES_CHANGED) 
            {
                pSSRec->uc.vertexIndex.dwVBHandle = pContext->dwIndexHandle;
                pSSRec->uc.vertexIndex.dwStride = pContext->dwIndicesStride;
            }

            // Note : P3 supports only one stream    
            for (i = 0; i < D3DVS_INPUTREG_MAX_V1_1; i++) 
            {
                ASSERTDD(i == 0, "Wrong vertex stream");
                if (pSSRec->uc.dwFlags & (SB_STREAMSRC_CHANGED << i)) 
                {
                    pSSRec->uc.streamSource[i].dwStream = 0;
                    pSSRec->uc.streamSource[i].dwVBHandle = pContext->dwVBHandle; 
                    pSSRec->uc.streamSource[i].dwStride = pContext->dwVerticesStride;
                }
            }
#endif // DX8_DDI

#if DX7_SB_TNL
            // TODO, Capture any necessary state for lights, materials, 
            // transforms, clip planes
#endif // DX7_SB_TNL
        
#if DX8_SB_SHADERS
            // TODO, Capture any necessary state for {V|P} shader constants
#endif // DX8_SB_SHADERS

#if DX8_DDI
            // Capture the current vertex shader
            if (pSSRec->uc.dwFlags & SB_CUR_VS_CHANGED) 
            {
                pSSRec->uc.dwCurVertexShader = pContext->dwVertexType;
            }
#endif // DX8_DDI
        }
        else
        {
            // compressed state set

            // Capture any necessary render states
            if (pSSRec->cc.pDP2RenderState) 
            {
            
                D3DHAL_DP2RENDERSTATE* pDP2RS;
                pDP2RS = (D3DHAL_DP2RENDERSTATE *)(pSSRec->cc.pDP2RenderState + 1);
                for (i = 0; i < pSSRec->cc.pDP2RenderState->wStateCount; i++, pDP2RS++)
                {
                    pDP2RS->dwState = pContext->RenderStates[pDP2RS->RenderState];
                }
            }

            // Capture any necessary TSS's
            if (pSSRec->cc.pDP2TextureStageState)
            {
                D3DHAL_DP2TEXTURESTAGESTATE* pDP2TSS;
                pDP2TSS = (D3DHAL_DP2TEXTURESTAGESTATE *)(pSSRec->cc.pDP2TextureStageState + 1);

                for (i = 0; i < pSSRec->cc.pDP2TextureStageState->wStateCount; i++, pDP2TSS++)
                {
                    pDP2TSS->dwValue = pContext->TextureStageState[pDP2TSS->wStage].m_dwVal[pDP2TSS->TSState];
                }
            }

            // Capture viewport info, z range

            if (pSSRec->cc.pDP2Viewport)
            {
                *((D3DHAL_DP2VIEWPORTINFO *)(pSSRec->cc.pDP2Viewport + 1)) = pContext->ViewportInfo;
            }

            if (pSSRec->cc.pDP2ZRange) 
            {
                *((D3DHAL_DP2ZRANGE *)(pSSRec->cc.pDP2ZRange + 1)) = pContext->ZRange;
            }

#if DX8_DDI
            // Capture vertex index, stream, shader
            if (pSSRec->cc.pDP2SetIndices) 
            {
                D3DHAL_DP2SETINDICES* pDP2SetIndices;
                pDP2SetIndices = (D3DHAL_DP2SETINDICES *)(pSSRec->cc.pDP2SetIndices + 1);
                pDP2SetIndices->dwVBHandle = pContext->dwIndexHandle;
                pDP2SetIndices->dwStride = pContext->dwIndicesStride; // 2 | 4
            }

            if (pSSRec->cc.pDP2SetStreamSources)
            {
                D3DHAL_DP2SETSTREAMSOURCE* pDP2SetStmSrc;
                pDP2SetStmSrc = (D3DHAL_DP2SETSTREAMSOURCE *)(pSSRec->cc.pDP2SetStreamSources + 1);
                pDP2SetStmSrc->dwStream = 0;                         // Only stream for permedia 3
                pDP2SetStmSrc->dwVBHandle = pContext->dwVBHandle;
                pDP2SetStmSrc->dwStride = pContext->dwVerticesStride;
            }
#endif // DX8_DDI

#if DX7_SB_TNL
            // TODO, Capture any necessary state for lights, materials, 
            // transforms, clip planes
#endif // DX7_SB_TNL

#if DX8_SB_SHADERS
            // TODO, Capture any necessary state for {V|P} shader constants
#endif // DX8_SB_SHADERS

#if DX8_DDI
            // Capture current vertex shader
            if (pSSRec->cc.pDP2SetVertexShader) 
            {
                D3DHAL_DP2VERTEXSHADER* pSetVtxShader;
                pSetVtxShader = (D3DHAL_DP2VERTEXSHADER *)(pSSRec->cc.pDP2SetVertexShader + 1);
                pSetVtxShader->dwHandle = pContext->dwVertexType;
            }
#endif // DX8_DDI
        }    
    }

} // _D3D_SB_CaptureStateSet

//-----------------------------------------------------------------------------
// Recording happens between BeginStateSet and EndStateSet calls so we
// never need to deal with recording into a compressed state set (since
// compression happens in EndStateSet)
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// void _D3D_SB_RecordStateSetRS
//
// Record this render state into the current state set being recorded
//
//-----------------------------------------------------------------------------
void _D3D_SB_RecordStateSetRS(P3_D3DCONTEXT* pContext, 
                              DWORD dwRSType, 
                              DWORD dwRSVal)
{
    if (pContext->pCurrSS != NULL)
    {
        DISPDBG((DBGLVL,"Recording SB # %x : RS %x = %x",
                        pContext->pCurrSS->dwHandle,dwRSType,dwRSVal));

       // Recording the state in an uncompressed stateblock
        pContext->pCurrSS->uc.RenderStates[dwRSType] = dwRSVal;
        FLAG_SET(pContext->pCurrSS->uc.bStoredRS, dwRSType);
    }
} // _D3D_SB_RecordStateSetRS

//-----------------------------------------------------------------------------
//
// void _D3D_SB_RecordStateSetTSS
//
// Record this texture stage state into the current state set being recorded
//
//-----------------------------------------------------------------------------
void _D3D_SB_RecordStateSetTSS(P3_D3DCONTEXT* pContext, 
                               DWORD dwTSStage, 
                               DWORD dwTSState,
                               DWORD dwTSVal)
{   
   if (pContext->pCurrSS != NULL)
   {
       DISPDBG((DBGLVL,"Recording SB # %x : TSS %x [%x] = %x",
                       pContext->pCurrSS->dwHandle,dwTSState, dwTSStage, dwTSVal));

       // Recording the state in an uncompressed stateblock
       pContext->pCurrSS->uc.TssStates[dwTSStage][dwTSState] = dwTSVal;
       FLAG_SET(pContext->pCurrSS->uc.bStoredTSS[dwTSStage], dwTSState);
   }
} // _D3D_SB_RecordStateSetTSS

#if DX8_MULTSTREAMS
//-----------------------------------------------------------------------------
//
// void _D3D_SB_Record_VertexShader_Set
//
// Record this vertex shader set code into the current state set being recorded
//
//-----------------------------------------------------------------------------
void _D3D_SB_Record_VertexShader_Set(P3_D3DCONTEXT* pContext, 
                                     DWORD dwVtxShaderHandle)
{                                     
    if (pContext->pCurrSS != NULL)
    {
        ASSERTDD (!(pContext->pCurrSS->dwSSFlags & SB_COMPRESSED), 
                  "ERROR : StateSet compressed");

        pContext->pCurrSS->uc.dwCurVertexShader = dwVtxShaderHandle;
        pContext->pCurrSS->uc.dwFlags |= SB_CUR_VS_CHANGED;
    }
} // _D3D_SB_Record_VertexShader_Set

//-----------------------------------------------------------------------------
//
// void _D3D_SB_Record_MStream_SetSrc
//
// Record this stream src set code into the current state set being recorded
//
//-----------------------------------------------------------------------------
void _D3D_SB_Record_MStream_SetSrc(P3_D3DCONTEXT* pContext, 
                                    DWORD dwStream,
                                    DWORD dwVBHandle,
                                    DWORD dwStride)
{                                     
    if (pContext->pCurrSS != NULL)
    {
        ASSERTDD (!(pContext->pCurrSS->dwSSFlags & SB_COMPRESSED), 
                  "ERROR : StateSet compressed");
    
        pContext->pCurrSS->uc.streamSource[dwStream].dwStream = dwStream;
        pContext->pCurrSS->uc.streamSource[dwStream].dwVBHandle = dwVBHandle;
        pContext->pCurrSS->uc.streamSource[dwStream].dwStride = dwStride;
        
        pContext->pCurrSS->uc.dwFlags |= (SB_STREAMSRC_CHANGED << dwStream);
    }
} // _D3D_SB_Record_MStream_SetSrc

//-----------------------------------------------------------------------------
//
// void _D3D_SB_Record_MStream_SetIndices
//
// Record this stream indices code into the current state set being recorded
//
//-----------------------------------------------------------------------------
void _D3D_SB_Record_MStream_SetIndices(P3_D3DCONTEXT* pContext, 
                                       DWORD dwVBHandle,
                                       DWORD dwStride)
{                     
    if (pContext->pCurrSS != NULL)
    {
        ASSERTDD (!(pContext->pCurrSS->dwSSFlags & SB_COMPRESSED), 
                  "ERROR : StateSet compressed");

        pContext->pCurrSS->uc.vertexIndex.dwVBHandle = dwVBHandle;
        pContext->pCurrSS->uc.vertexIndex.dwStride = dwStride;
        pContext->pCurrSS->uc.dwFlags |= SB_INDICES_CHANGED;
    }        
} // _D3D_SB_Record_MStream_SetIndices
#endif // DX8_MULTSTREAMS

//-----------------------------------------------------------------------------
//
// void _D3D_SB_Record_Viewport
//
// Record this viewport info into the current state set being recorded
//
//-----------------------------------------------------------------------------
void _D3D_SB_Record_Viewport(P3_D3DCONTEXT* pContext,
                             D3DHAL_DP2VIEWPORTINFO* lpvp)
{             
    if (pContext->pCurrSS != NULL)
    {
        ASSERTDD (!(pContext->pCurrSS->dwSSFlags & SB_COMPRESSED), 
                  "ERROR : StateSet compressed");
    
        pContext->pCurrSS->uc.viewport = *lpvp;
        pContext->pCurrSS->uc.dwFlags |= SB_VIEWPORT_CHANGED;
    }        
} // _D3D_SB_Record_Viewport

//-----------------------------------------------------------------------------
//
// void _D3D_SB_Record_ZRange
//
// Record this z range info into the current state set being recorded
//
//-----------------------------------------------------------------------------
VOID _D3D_SB_Record_ZRange(P3_D3DCONTEXT* pContext,
                           D3DHAL_DP2ZRANGE* lpzr)
{
    if (pContext->pCurrSS != NULL)
    {
        ASSERTDD (!(pContext->pCurrSS->dwSSFlags & SB_COMPRESSED), 
                  "ERROR : StateSet compressed");

        pContext->pCurrSS->uc.zRange = *lpzr;
        pContext->pCurrSS->uc.dwFlags |= SB_ZRANGE_CHANGED;
    }        
}        

#endif //DX7_D3DSTATEBLOCKS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dprim.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dprim.c
*
* Content: D3D primitives rendering
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

// For the mipmap LOD calculation

#define BIAS_SHIFT 1
#define CULL_HERE 1

#include <limits.h>
#include "glint.h"
#include "dma.h"
#include "tag.h"

//-----------------------------------------------------------------------------
//
// Specialized hardaware rendering functions for the Permedia3, 
// for all primitve types
//
//-----------------------------------------------------------------------------

#define GET_FOG(x)  ((x) & 0xff000000 )
#define GET_SPEC(x) ((x) & 0x00ffffff )


#define SEND_R3FVFVERTEX_XYZ(Num, Index)        \
{                                               \
        MEMORY_BARRIER(); \
        dmaPtr[0] = GAMBIT_XYZ_VTX | Num;       \
        MEMORY_BARRIER(); \
        dmaPtr[1] = AS_ULONG(pv[Index]->sx);    \
        MEMORY_BARRIER(); \
        dmaPtr[2] = AS_ULONG(pv[Index]->sy);    \
        MEMORY_BARRIER(); \
        dmaPtr[3] = AS_ULONG(pv[Index]->sz);    \
        dmaPtr += 4;                            \
        CHECK_FIFO(4);                          \
}

#define SEND_R3FVFVERTEX_XYZ_STQ(Num, Index)            \
{                                                       \
        MEMORY_BARRIER(); \
        dmaPtr[0] = GAMBIT_XYZ_STQ_VTX | Num;           \
        MEMORY_BARRIER(); \
        *(float volatile*)&dmaPtr[1] = tc[Index].tu1;   \
        MEMORY_BARRIER(); \
        *(float volatile*)&dmaPtr[2] = tc[Index].tv1;   \
        MEMORY_BARRIER(); \
        dmaPtr[3] = q[Index];                           \
        MEMORY_BARRIER(); \
        dmaPtr[4] = AS_ULONG(pv[Index]->sx);            \
        MEMORY_BARRIER(); \
        dmaPtr[5] = AS_ULONG(pv[Index]->sy);            \
        MEMORY_BARRIER(); \
        dmaPtr[6] = AS_ULONG(pv[Index]->sz);            \
        dmaPtr += 7;                                    \
        CHECK_FIFO(7);                                  \
}

#define SEND_R3FVFVERTEX_XYZ_FOG(Num, Index)                    \
{                                                               \
        MEMORY_BARRIER(); \
        dmaPtr[0] = GAMBIT_XYZ_VTX | VTX_SPECULAR | Num;        \
        MEMORY_BARRIER(); \
        dmaPtr[1] = AS_ULONG(pv[Index]->sx);                    \
        MEMORY_BARRIER(); \
        dmaPtr[2] = AS_ULONG(pv[Index]->sy);                    \
        MEMORY_BARRIER(); \
        dmaPtr[3] = AS_ULONG(pv[Index]->sz);                    \
        MEMORY_BARRIER(); \
        dmaPtr[4] = GET_FOG( FVFSPEC(pv[Index])->specular );    \
        dmaPtr += 5;                                            \
        CHECK_FIFO(5);                                          \
}

#define SEND_R3FVFVERTEX_XYZ_STQ_FOG(Num, Index)                \
{                                                               \
        MEMORY_BARRIER(); \
        dmaPtr[0] = GAMBIT_XYZ_STQ_VTX | VTX_SPECULAR | Num;    \
        MEMORY_BARRIER(); \
        *(float volatile*)&dmaPtr[1] = tc[Index].tu1;           \
        MEMORY_BARRIER(); \
        *(float volatile*)&dmaPtr[2] = tc[Index].tv1;           \
        MEMORY_BARRIER(); \
        dmaPtr[3] = q[Index];                                   \
        MEMORY_BARRIER(); \
        dmaPtr[4] = AS_ULONG(pv[Index]->sx);                    \
        MEMORY_BARRIER(); \
        dmaPtr[5] = AS_ULONG(pv[Index]->sy);                    \
        MEMORY_BARRIER(); \
        dmaPtr[6] = AS_ULONG(pv[Index]->sz);                    \
        MEMORY_BARRIER(); \
        dmaPtr[7] = GET_FOG( FVFSPEC(pv[Index])->specular );    \
        dmaPtr += 8;                                            \
        CHECK_FIFO(8);                                          \
}

#define SEND_R3FVFVERTEX_XYZ_RGBA(Num, Index)           \
{                                                       \
        MEMORY_BARRIER(); \
        dmaPtr[0] = GAMBIT_XYZ_VTX | VTX_COLOR | Num;   \
        MEMORY_BARRIER(); \
        dmaPtr[1] = AS_ULONG(pv[Index]->sx);            \
        MEMORY_BARRIER(); \
        dmaPtr[2] = AS_ULONG(pv[Index]->sy);            \
        MEMORY_BARRIER(); \
        dmaPtr[3] = AS_ULONG(pv[Index]->sz);            \
        MEMORY_BARRIER(); \
        dmaPtr[4] = FVFCOLOR(pv[Index])->color;         \
        MEMORY_BARRIER(); \
        dmaPtr += 5;                                    \
        CHECK_FIFO(5);                                  \
}
 
#define SEND_R3FVFVERTEX_XYZ_RGBA_SFOG(Num, Index)                      \
{                                                                       \
        MEMORY_BARRIER(); \
        dmaPtr[0] = GAMBIT_XYZ_VTX | VTX_COLOR | VTX_SPECULAR | Num;    \
        MEMORY_BARRIER(); \
        dmaPtr[1] = AS_ULONG(pv[Index]->sx);                            \
        MEMORY_BARRIER(); \
        dmaPtr[2] = AS_ULONG(pv[Index]->sy);                            \
        MEMORY_BARRIER(); \
        dmaPtr[3] = AS_ULONG(pv[Index]->sz);                            \
        MEMORY_BARRIER(); \
        dmaPtr[4] = FVFCOLOR(pv[Index])->color;                         \
        MEMORY_BARRIER(); \
        dmaPtr[5] = FVFSPEC(pv[Index])->specular;                       \
        dmaPtr += 6;                                                    \
        CHECK_FIFO(6);                                                  \
}

#define SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(Num, Index)                      \
{                                                                           \
        MEMORY_BARRIER(); \
        dmaPtr[0] = GAMBIT_XYZ_STQ_VTX | VTX_COLOR | VTX_SPECULAR | Num;    \
        MEMORY_BARRIER(); \
        *(float volatile*)&dmaPtr[1] = tc[Index].tu1;                       \
        MEMORY_BARRIER(); \
        *(float volatile*)&dmaPtr[2] = tc[Index].tv1;                       \
        MEMORY_BARRIER(); \
        dmaPtr[3] = q[Index];                                               \
        MEMORY_BARRIER(); \
        dmaPtr[4] = AS_ULONG(pv[Index]->sx);                                \
        MEMORY_BARRIER(); \
        dmaPtr[5] = AS_ULONG(pv[Index]->sy);                                \
        MEMORY_BARRIER(); \
        dmaPtr[6] = AS_ULONG(pv[Index]->sz);                                \
        MEMORY_BARRIER(); \
        dmaPtr[7] = FVFCOLOR(pv[Index])->color;                             \
        MEMORY_BARRIER(); \
        dmaPtr[8] = FVFSPEC(pv[Index])->specular;                           \
        dmaPtr += 9;                                                       \
        CHECK_FIFO(9);                                                     \
}

#define SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG_POINT(Num, Index, offset)        \
{                                                                           \
        float TempY = Y_ADJUST(pv[Index]->sy);                              \
        if (offset == TRUE) TempY += 1.0f;                                  \
        MEMORY_BARRIER(); \
        dmaPtr[0] = GAMBIT_XYZ_STQ_VTX | VTX_COLOR | VTX_SPECULAR | Num;    \
        MEMORY_BARRIER(); \
        *(float volatile*)&dmaPtr[1] = tc[Index].tu1;                       \
        MEMORY_BARRIER(); \
        *(float volatile*)&dmaPtr[2] = tc[Index].tv1;                       \
        MEMORY_BARRIER(); \
        dmaPtr[3] = q[Index];                                               \
        MEMORY_BARRIER(); \
        dmaPtr[4] = AS_ULONG(pv[Index]->sx);                                \
        MEMORY_BARRIER(); \
        dmaPtr[5] = AS_ULONG(TempY);                                        \
        MEMORY_BARRIER(); \
        dmaPtr[6] = AS_ULONG(pv[Index]->sz);                                \
        MEMORY_BARRIER(); \
        dmaPtr[7] = FVFCOLOR(pv[Index])->color;                             \
        MEMORY_BARRIER(); \
        dmaPtr[8] = FVFSPEC(pv[Index])->specular;                           \
        dmaPtr += 9;                                                        \
        CHECK_FIFO(9);                                                      \
}

#define SEND_R3FVFVERTEX_STQ2(Num, Index)   \
{                                                   \
        MEMORY_BARRIER(); \
    dmaPtr[0] = GAMBIT_STQ_VTX | Num;               \
        MEMORY_BARRIER(); \
    *(float volatile*)&dmaPtr[1] = tc[Index].tu2;   \
        MEMORY_BARRIER(); \
    *(float volatile*)&dmaPtr[2] = tc[Index].tv2;   \
        MEMORY_BARRIER(); \
    dmaPtr[3] = q[Index];                           \
    dmaPtr += 4;                                    \
    CHECK_FIFO(4);                                  \
}

#if DX8_3DTEXTURES
#define SEND_R3FVFVERTEX_3DTEX(Num, Index)   \
{                                                    \
        MEMORY_BARRIER(); \
    dmaPtr[0] = GAMBIT_STQ_VTX | Num;                \
        MEMORY_BARRIER(); \
    *(float volatile*)&dmaPtr[1] = tc[Index].tw1;    \
        MEMORY_BARRIER(); \
    *(float volatile*)&dmaPtr[2] = 0; /* Not used */ \
        MEMORY_BARRIER(); \
    dmaPtr[3] = q[Index];                            \
    dmaPtr += 4;                                     \
    CHECK_FIFO(4);                                   \
}
#endif // DX8_3DTEXTURES

#if DX8_3DTEXTURES
#define GET_TC_3DTEX( Index ) \
        *(DWORD *)&tc[Index].tu1 = *(DWORD *)&FVFTEX(pv[Index], 0)->tu;     \
        *(DWORD *)&tc[Index].tv1 = *(DWORD *)&FVFTEX(pv[Index], 0)->tv;     \
        *(DWORD *)&tc[Index].tw1 = *(DWORD *)&FVFTEX(pv[Index], 0)->tw;
#endif // DX8_3DTEXTURES

#define GET_TC( Index ) \
        *(DWORD *)&tc[Index].tu1 = *(DWORD *)&FVFTEX(pv[Index], 0)->tu;     \
        *(DWORD *)&tc[Index].tv1 = *(DWORD *)&FVFTEX(pv[Index], 0)->tv;

#if DX8_3DTEXTURES
#define GET_TC2_3DTEX( Index )    \
        *(DWORD *)&tc[Index].tu2 = *(DWORD *)&FVFTEX(pv[Index], 1)->tu;     \
        *(DWORD *)&tc[Index].tv2 = *(DWORD *)&FVFTEX(pv[Index], 1)->tv;     \
        *(DWORD *)&tc[Index].tw2 = *(DWORD *)&FVFTEX(pv[Index], 1)->tw;
#endif // DX8_3DTEXTURES

#define GET_TC2( Index )    \
        *(DWORD *)&tc[Index].tu2 = *(DWORD *)&FVFTEX(pv[Index], 1)->tu;     \
        *(DWORD *)&tc[Index].tv2 = *(DWORD *)&FVFTEX(pv[Index], 1)->tv;

#define GET_ONE_TEXCOORD(vtx)                           \
        GET_TC(vtx);                                    \
        if( pContext->iTexStage[1] != -1 )          \
        {                                               \
            GET_TC2(vtx);                               \
        }

#define GET_TEXCOORDS() \
        GET_TC(0); GET_TC(1); GET_TC(2);        \
        if( pContext->iTexStage[1] != -1 )  \
        {                                       \
            GET_TC2(0); GET_TC2(1); GET_TC2(2); \
        }

#if DX8_3DTEXTURES
#define SCALE_BY_Q_3DTEX( Index )           \
    tc[Index].tu1 *= *(float *)&q[Index];   \
    tc[Index].tv1 *= *(float *)&q[Index];   \
    tc[Index].tw1 *= *(float *)&q[Index];
#endif // DX8_3DTEXTURES

#define SCALE_BY_Q( Index )                 \
    tc[Index].tu1 *= *(float *)&q[Index];   \
    tc[Index].tv1 *= *(float *)&q[Index];

#if DX8_3DTEXTURES
#define SCALE_BY_Q2_3DTEX( Index )          \
    tc[Index].tu2 *= *(float *)&q[Index];   \
    tc[Index].tv2 *= *(float *)&q[Index];   \
    tc[Index].tw2 *= *(float *)&q[Index];
#endif // DX8_3DTEXTURES

#define SCALE_BY_Q2( Index )                \
    tc[Index].tu2 *= *(float *)&q[Index];   \
    tc[Index].tv2 *= *(float *)&q[Index];

#define DRAW_LINE()                             \
        MEMORY_BARRIER(); \
        dmaPtr[0] = DrawLine01_Tag;             \
        MEMORY_BARRIER(); \
        dmaPtr[1] = renderCmd;                  \
        dmaPtr += 2;                            \
        CHECK_FIFO(2)

#define DRAW_POINT()                            \
        MEMORY_BARRIER(); \
        dmaPtr[0] = DrawPoint_Tag;              \
        MEMORY_BARRIER(); \
        dmaPtr[1] = renderCmd;                  \
        dmaPtr += 2;                            \
        CHECK_FIFO(2)

#define DRAW_LINE_01_OR_10( vtx )               \
        MEMORY_BARRIER(); \
        dmaPtr[0] = vtx ? DrawLine01_Tag        \
                        : DrawLine10_Tag;       \
        MEMORY_BARRIER(); \
        dmaPtr[1] = renderCmd;                  \
        dmaPtr += 2;                            \
        CHECK_FIFO(2)

#define DRAW_TRIANGLE()                         \
        MEMORY_BARRIER(); \
        dmaPtr[0] = DrawTriangle_Tag;           \
        MEMORY_BARRIER(); \
        dmaPtr[1] = renderCmd;                  \
        dmaPtr += 2;                            \
        CHECK_FIFO(2)

//-----------------------------------------------------------------------------
// Easy edge flag renaming
//-----------------------------------------------------------------------------
#define SIDE_0      D3DTRIFLAG_EDGEENABLE1
#define SIDE_1      D3DTRIFLAG_EDGEENABLE2
#define SIDE_2      D3DTRIFLAG_EDGEENABLE3
#define ALL_SIDES   ( SIDE_0 | SIDE_1 | SIDE_2 )

//-----------------------------------------------------------------------------
// Cycle vertex indices for triangle strips viz. 0 -> 1, 1 -> 2, 2 -> 0
// See Graphics Gems 3, Pg 69.
//-----------------------------------------------------------------------------

#define INIT_VERTEX_INDICES(pContext, vtx_a, vtx_b)   \
    vtx_a = 0;                                        \
    vtx_b = 0 ^ 1;                                    \
    pContext->dwProvokingVertex = 1;

#define CONST_c (0 ^ 1 ^ 2)

#define CYCLE_VERTEX_INDICES(pContext, vtx_a, vtx_b)  \
        vtx_a ^= vtx_b;                               \
        vtx_b ^= CONST_c;                             \
        pContext->dwProvokingVertex = vtx_b;          \
        vtx_b ^= vtx_a;

//-----------------------------------------------------------------------------
// Local typedef for temporary texture coordinate storage
//-----------------------------------------------------------------------------

typedef struct
{
    float tu1;
    float tv1;
#if DX8_3DTEXTURES
    float tw1;
#endif // DX8_3DTEXTURES
    float tu2;
    float tv2;
#if DX8_3DTEXTURES
    float tw2;
#endif // DX8_3DTEXTURES
} TEXCOORDS;

//-----------------------------------------------------------------------------
// Macros to access and validate command and vertex buffer data
// These checks need ALWAYS to be made for all builds, free and checked. 
//-----------------------------------------------------------------------------
#define LP_FVF_VERTEX(lpBaseAddr, wIndex)                         \
         (LPD3DTLVERTEX)((LPBYTE)(lpBaseAddr) + (wIndex) * pContext->FVFData.dwStride)

#define LP_FVF_NXT_VTX(lpVtx)                                    \
         (LPD3DTLVERTEX)((LPBYTE)(lpVtx) + pContext->FVFData.dwStride)

#define CHECK_DATABUF_LIMITS(pbError, dwVBLen, iIndex )                        \
   {                                                                           \
        if (! (((LONG)(iIndex) >= 0) &&                                        \
               ((LONG)(iIndex) <(LONG)dwVBLen)))                               \
        {                                                                      \
            DISPDBG((ERRLVL,"D3D: Trying to read past Vertex Buffer limits "   \
                "%d limit= %d ",(LONG)(iIndex), (LONG)dwVBLen));               \
            *pbError = TRUE;                                                   \
            return;                                                            \
        }                                                                      \
   }

//-----------------------------------------------------------------------------
// Define values for FVF defaults
//-----------------------------------------------------------------------------
const FVFCOLOR     gc_FVFColorDefault = { 0xFFFFFFFF  };
const FVFSPECULAR  gc_FVFSpecDefault  = { 0x00000000  };
const FVFTEXCOORDS gc_FVFTexCoordDefault = { 0.0f, 
                                             0.0f 
#if DX8_3DTEXTURES
                                           , 0.0f 
#endif
                                           };

//-----------------------------------------------------------------------------
// Macros and functions for texture coord adjustment on wrapping
//-----------------------------------------------------------------------------

#define SHIFT_SET_0     1
#define SHIFT_SET_1     2


#define TEXSHIFT 1

#if TEXSHIFT
#if 0
// 8.0f as a DWORD
#define TEX_SHIFT_LIMIT 0x41000000
#define FP_SIGN_MASK    0x7fffffff

#define TEXTURE_SHIFT( coord )  \
    if(( *(DWORD *)&tc[0].##coord & FP_SIGN_MASK ) > TEX_SHIFT_LIMIT )  \
    {                                                                   \
        myFtoi( &intVal, tc[0].##coord );                               \
                                                                        \
        intVal &= ~1;                                                   \
                                                                        \
        tc[0].##coord -= intVal;                                        \
        tc[1].##coord -= intVal;                                        \
        tc[2].##coord -= intVal;                                        \
                                                                        \
        FLUSH_DUE_TO_WRAP( coord, TRUE );                               \
    }
#endif

#define TEX_SHIFT_LIMIT 4.0

#define TEXTURE_SHIFT( coord )  \
    if((tc[0].##coord >  TEX_SHIFT_LIMIT ) ||                           \
       (tc[0].##coord < -TEX_SHIFT_LIMIT ) )                            \
    {                                                                   \
        myFtoi( &intVal, tc[0].##coord );                               \
                                                                        \
        intVal &= ~1;                                                   \
                                                                        \
        tc[0].##coord -= intVal;                                        \
        tc[1].##coord -= intVal;                                        \
        tc[2].##coord -= intVal;                                        \
                                                                        \
        FLUSH_DUE_TO_WRAP( coord, TRUE );                               \
    }

#define WRAP_R3(par, wrapit, vertexSharing) if(wrapit) {        \
    float elp;                                                  \
    float erp;                                                  \
    float emp;                                                  \
    elp=(float)myFabs(tc[1].##par-tc[0].##par);                 \
    erp=(float)myFabs(tc[2].##par-tc[1].##par);                 \
    emp=(float)myFabs(tc[0].##par-tc[2].##par);                 \
    if( (elp > 0.5f) && (erp > 0.5f) )                          \
    {                                                           \
        if (tc[1].##par < tc[2].##par) { tc[1].##par += 1.0f; } \
        else { tc[2].##par += 1.0f; tc[0].##par += 1.0f; }      \
        FLUSH_DUE_TO_WRAP(par,vertexSharing);                   \
    }                                                           \
    else if( (erp > 0.5f) && (emp > 0.5f) )                     \
    {                                                           \
        if (tc[2].##par < tc[0].##par) { tc[2].##par += 1.0f; } \
        else { tc[0].##par += 1.0f; tc[1].##par += 1.0f; }      \
        FLUSH_DUE_TO_WRAP(par,vertexSharing);                   \
    }                                                           \
    else if( (emp > 0.5f) && (elp > 0.5f) )                     \
    {                                                           \
        if(tc[0].##par < tc[1].##par) { tc[0].##par += 1.0f; }  \
        else { tc[1].##par += 1.0f; tc[2].##par += 1.0f; }      \
        FLUSH_DUE_TO_WRAP(par,vertexSharing);                   \
    }                                                           \
    else                                                        \
    {                                                           \
        DONT_FLUSH_DUE_TO_WRAP(par,vertexSharing);              \
    }                                                           \
} else {                                                        \
    DONT_FLUSH_DUE_TO_WRAP(par,vertexSharing);                  \
}
    
//-----------------------------------------------------------------------------
//
// __TextureShift
//
//-----------------------------------------------------------------------------
void 
__TextureShift( 
    P3_D3DCONTEXT *pContext, 
    TEXCOORDS tc[], 
    DWORD shiftMask )
{
    int intVal;

    if( shiftMask & SHIFT_SET_0 )
    {
        if( pContext->TextureStageState[0].m_dwVal[D3DTSS_ADDRESSU] != 
                                                            D3DTADDRESS_CLAMP )
        {
            TEXTURE_SHIFT( tu1 );
        }

        if( pContext->TextureStageState[0].m_dwVal[D3DTSS_ADDRESSV] != 
                                                            D3DTADDRESS_CLAMP )
        {
            TEXTURE_SHIFT( tv1 );
        }
    }

    if( shiftMask & SHIFT_SET_1 )
    {
        if( pContext->TextureStageState[1].m_dwVal[D3DTSS_ADDRESSU] != 
                                                            D3DTADDRESS_CLAMP )
        {
            TEXTURE_SHIFT( tu2 );
        }

        if( pContext->TextureStageState[1].m_dwVal[D3DTSS_ADDRESSV] != 
                                                            D3DTADDRESS_CLAMP )
        {
            TEXTURE_SHIFT( tv2 );
        }
    }
} // __TextureShift

#endif //TEXSHIFT

//-----------------------------------------------------------------------------
//
// __BackfaceCullNoTexture
//
//-----------------------------------------------------------------------------
int _inline 
__BackfaceCullNoTexture( 
    P3_D3DCONTEXT *pContext, 
    D3DTLVERTEX *pv[] )
{
    DWORD Flags = pContext->Flags;
    float PixelArea;

    PixelArea = (((pv[0]->sx - pv[2]->sx) * (pv[1]->sy - pv[2]->sy)) -
                            ((pv[1]->sx - pv[2]->sx) * (pv[0]->sy - pv[2]->sy)));

    if (CULLED(pContext,PixelArea))
    {
        return 1;
    }         
        
    pContext->R3flushDueToTexCoordAdjust = 0;

    return 0;
} // __BackfaceCullNoTexture

//-----------------------------------------------------------------------------
//
// __BackfaceCullSingleTex
//
//-----------------------------------------------------------------------------
int _inline 
__BackfaceCullSingleTex( 
    P3_D3DCONTEXT *pContext, 
    D3DTLVERTEX *pv[], 
    TEXCOORDS tc[] )
{
    DWORD Flags = pContext->Flags;
    float PixelArea;

    PixelArea = (((pv[0]->sx - pv[2]->sx) * (pv[1]->sy - pv[2]->sy)) -
                            ((pv[1]->sx - pv[2]->sx) * (pv[0]->sy - pv[2]->sy)));

    if (CULLED(pContext,PixelArea))
    {
        return 1;
    }    

    pContext->R3flushDueToTexCoordAdjust = 0;

#if TEXSHIFT
    __TextureShift( pContext, tc, SHIFT_SET_0 );
#endif

    return 0;
    
} // __BackfaceCullSingleTex

//-----------------------------------------------------------------------------
//
// __BackfaceCullAndMipMap
//
//-----------------------------------------------------------------------------
int _inline 
__BackfaceCullAndMipMap( 
    P3_D3DCONTEXT *pContext, 
    D3DTLVERTEX *pv[], 
    TEXCOORDS tc[] )
{
    DWORD Flags = pContext->Flags;
    float PixelArea;
    int iNewMipLevel;
    P3_SURF_INTERNAL* pTexture;
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;

    P3_DMA_DEFS();

    PixelArea = (((pv[0]->sx - pv[2]->sx) * (pv[1]->sy - pv[2]->sy)) -
                            ((pv[1]->sx - pv[2]->sx) * (pv[0]->sy - pv[2]->sy)));

    if (CULLED(pContext,PixelArea))
    {
        return 1;
    }    

    // 39 for vertex data, 2 for triangle and 4 for possible LOD change
    // for the three vertex case - the one vertex case will check for
    // too much but this shouldn't be a problem.

    P3_DMA_GET_BUFFER_ENTRIES( 4 );

    pContext->R3flushDueToTexCoordAdjust = 0;

    if( Flags & SURFACE_TEXTURING )
    {
        float TextureArea, textureAreaFactor;
        int maxLevel;

        pTexture = pContext->pCurrentTexture[TEXSTAGE_0];

        // Setup LOD of texture # 0 (if necessary)
        if( pContext->bTex0Valid &&
            ( pContext->TextureStageState[TEXSTAGE_0].m_dwVal[D3DTSS_MIPFILTER] != D3DTFP_NONE )
            && pTexture->bMipMap )
        {
            maxLevel = pTexture->iMipLevels - 1;
            textureAreaFactor = pTexture->fArea * pContext->MipMapLODBias[TEXSTAGE_0];

            TextureArea = (((tc[0].tu1 - tc[2].tu1) * (tc[1].tv1 - tc[2].tv1)) -
                    ((tc[1].tu1 - tc[2].tu1) * (tc[0].tv1 - tc[2].tv1))) * textureAreaFactor;

            // Ensure that both of these values are positive from now on.

            *(signed long *)&PixelArea &= ~(1 << 31);
            *(signed long *)&TextureArea &= ~(1 << 31);

            FIND_PERMEDIA_MIPLEVEL();

            DISPDBG((DBGLVL,"iNewMipLevel = %x",iNewMipLevel));

            SEND_P3_DATA( LOD, iNewMipLevel << 8 );
        }

        pTexture = pContext->pCurrentTexture[TEXSTAGE_1];

        // Setup LOD of texture # 1 (if necessary)
        if( pContext->bTex1Valid && ( pContext->TextureStageState[TEXSTAGE_1].m_dwVal[D3DTSS_MIPFILTER] != D3DTFP_NONE )
                                            && pTexture->bMipMap )
        {
            ASSERTDD( pContext->bTex0Valid, "Second texture valid when first isn't" );

            maxLevel = pTexture->iMipLevels - 1;
            textureAreaFactor = pTexture->fArea * pContext->MipMapLODBias[TEXSTAGE_1];

            TextureArea = (((tc[0].tu2 - tc[2].tu2) * (tc[1].tv2 - tc[2].tv2)) -
                    ((tc[1].tu2 - tc[2].tu2) * (tc[0].tv2 - tc[2].tv2))) * textureAreaFactor;

            // Ensure that both of these values are positive from now on.

            *(signed long *)&PixelArea &= ~(1 << 31);
            *(signed long *)&TextureArea &= ~(1 << 31);

            FIND_PERMEDIA_MIPLEVEL();

            SEND_P3_DATA( LOD1, iNewMipLevel << 8 );
        }

        if( pContext->RenderStates[D3DRENDERSTATE_WRAP0] )
        {
            WRAP_R3( tu1, pContext->RenderStates[D3DRENDERSTATE_WRAP0] & D3DWRAP_U, TRUE );
            WRAP_R3( tv1, pContext->RenderStates[D3DRENDERSTATE_WRAP0] & D3DWRAP_V, TRUE );
        }
        else
        {
#if TEXSHIFT
            __TextureShift( pContext, tc, SHIFT_SET_0 );
#endif
        }

        if( pContext->RenderStates[D3DRENDERSTATE_WRAP1] )
        {
            WRAP_R3( tu2, pContext->RenderStates[D3DRENDERSTATE_WRAP1] & D3DWRAP_U, TRUE );
            WRAP_R3( tv2, pContext->RenderStates[D3DRENDERSTATE_WRAP1] & D3DWRAP_V, TRUE );
        }
        else
        {
#if TEXSHIFT
            __TextureShift( pContext, tc, SHIFT_SET_1 );
#endif
        }
    }

    P3_DMA_COMMIT_BUFFER();

    return 0;
    
} // __BackfaceCullAndMipMap

//-----------------------------------------------------------------------------
//
// __ProcessTri_1Vtx_NoTexture
//
//-----------------------------------------------------------------------------
int
__ProcessTri_1Vtx_NoTexture( 
    P3_D3DCONTEXT *pContext, 
    D3DTLVERTEX *pv[], 
    int vtx )
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    DWORD Flags = pContext->Flags;
    ULONG renderCmd = pContext->RenderCommand;

    P3_DMA_DEFS();

#if CULL_HERE
    if( __BackfaceCullNoTexture( pContext, pv ))
        return 1;
#endif

    P3_DMA_GET_BUFFER_ENTRIES( 9 );

    if( pContext->Flags & SURFACE_GOURAUD )
    {
        // 9 DWORDS.
        SEND_R3FVFVERTEX_XYZ_RGBA_SFOG(V0FloatS_Tag + (vtx*16), vtx);
    }
    else
    {
        DWORD Col0 = FVFCOLOR(pContext->pProvokingVertex)->color;

        if( Flags & SURFACE_SPECULAR )
        {
            DWORD Spec0 = GET_SPEC( FVFSPEC(pContext->pProvokingVertex)->specular );

            CLAMP8888( Col0, Col0, Spec0 );
        }

        if( Flags & SURFACE_FOGENABLE )
        {
            // 8 DWORDS.
            SEND_R3FVFVERTEX_XYZ_FOG(V0FloatS_Tag + (vtx*16), vtx);
        }
        else
        {
            // 7 DWORDS.
            SEND_R3FVFVERTEX_XYZ(V0FloatS_Tag + (vtx*16), vtx);
        }

        // 2 DWORDS.
        SEND_P3_DATA(ConstantColor, RGBA_MAKE(RGBA_GETBLUE(Col0),
                                                RGBA_GETGREEN(Col0),
                                                RGBA_GETRED(Col0),
                                                RGBA_GETALPHA(Col0)));
    }

    RENDER_TRAPEZOID(renderCmd);

    DRAW_TRIANGLE();

    P3_DMA_COMMIT_BUFFER();

    return 0;
    
} // __ProcessTri_1Vtx_NoTexture

//-----------------------------------------------------------------------------
//
// __ProcessTri_3Vtx_NoTexture
//
//-----------------------------------------------------------------------------
int
__ProcessTri_3Vtx_NoTexture( 
    P3_D3DCONTEXT *pContext, 
    D3DTLVERTEX *pv[],
    int WireEdgeFlags)
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    DWORD Flags = pContext->Flags;
    ULONG renderCmd = pContext->RenderCommand;

    P3_DMA_DEFS();

#if CULL_HERE
    if( __BackfaceCullNoTexture( pContext, pv ))
        return 1;
#endif

    P3_DMA_GET_BUFFER_ENTRIES( 20 );

    if( pContext->Flags & SURFACE_GOURAUD )
    {
        SEND_R3FVFVERTEX_XYZ_RGBA_SFOG(V0FloatS_Tag, 0);
        SEND_R3FVFVERTEX_XYZ_RGBA_SFOG(V1FloatS_Tag, 1);
        SEND_R3FVFVERTEX_XYZ_RGBA_SFOG(V2FloatS_Tag, 2);
    }
    else
    {
        DWORD Col0 = FVFCOLOR(pContext->pProvokingVertex)->color;

        if( Flags & SURFACE_SPECULAR )
        {
            DWORD Spec0 = GET_SPEC( FVFSPEC(pContext->pProvokingVertex)->specular );

            CLAMP8888( Col0, Col0, Spec0 );
        }

        if( Flags & SURFACE_FOGENABLE )
        {
            SEND_R3FVFVERTEX_XYZ_FOG(V0FloatS_Tag, 0);
            SEND_R3FVFVERTEX_XYZ_FOG(V1FloatS_Tag, 1);
            SEND_R3FVFVERTEX_XYZ_FOG(V2FloatS_Tag, 2);
        }
        else
        {
            SEND_R3FVFVERTEX_XYZ(V0FloatS_Tag, 0);
            SEND_R3FVFVERTEX_XYZ(V1FloatS_Tag, 1);
            SEND_R3FVFVERTEX_XYZ(V2FloatS_Tag, 2);
        }

        SEND_P3_DATA(ConstantColor, RGBA_MAKE(RGBA_GETBLUE(Col0),
                                            RGBA_GETGREEN(Col0),
                                            RGBA_GETRED(Col0),
                                            RGBA_GETALPHA(Col0)));
    }

    RENDER_TRAPEZOID(renderCmd);

    DRAW_TRIANGLE();

    P3_DMA_COMMIT_BUFFER();

    return 0;
} // __ProcessTri_3Vtx_NoTexture

//-----------------------------------------------------------------------------
//
// __ProcessTri_1Vtx_PerspSingleTexGouraud
//
//-----------------------------------------------------------------------------
int
__ProcessTri_1Vtx_PerspSingleTexGouraud( 
    P3_D3DCONTEXT *pContext, 
    D3DTLVERTEX *pv[], 
    int vtx )
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    TEXCOORDS tc[3];
    DWORD q[3];
    ULONG renderCmd = pContext->RenderCommand;
#if DX8_3DTEXTURES
    P3_SURF_INTERNAL* pTexture = pContext->pCurrentTexture[TEXSTAGE_0];
    BOOL b3DTexture = (pTexture ? pTexture->b3DTexture : FALSE);
#endif // DX8_3DTEXTURES

    P3_DMA_DEFS();

    // We need to refresh all texture coords as they will have been modified
    // by the scale by Q and potentially D3D wrapping or TextureShift.

#if DX8_3DTEXTURES
    if (b3DTexture)
    {
        GET_TC_3DTEX(0); GET_TC_3DTEX(1); GET_TC_3DTEX(2);
    }
    else
    {
        GET_TC(0); GET_TC(1); GET_TC(2);
    }
#else
    GET_TC(0); GET_TC(1); GET_TC(2);
#endif // DX8_3DTEXTURES

#if CULL_HERE
    if( __BackfaceCullSingleTex( pContext, pv, tc ))
        return 1;
#endif

    P3_DMA_GET_BUFFER_ENTRIES( 15 );

    q[vtx] = *(DWORD *)&(pv[vtx]->rhw);


#if DX8_3DTEXTURES
    if (b3DTexture)
    {
        SCALE_BY_Q_3DTEX( vtx );
    }
    else
    {
        SCALE_BY_Q( vtx );
    }
#else
    SCALE_BY_Q( vtx );
#endif // DX8_3DTEXTURES

#if DX8_3DTEXTURES
    if (b3DTexture)
    {
        SEND_R3FVFVERTEX_3DTEX(V0FloatS1_Tag + (vtx*16), vtx);
    }
#endif // DX8_3DTEXTURES
    SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V0FloatS_Tag + (vtx*16), vtx);

    RENDER_TRAPEZOID(renderCmd);

    DRAW_TRIANGLE();

    P3_DMA_COMMIT_BUFFER();

    return pContext->R3flushDueToTexCoordAdjust;
    
} // __ProcessTri_1Vtx_PerspSingleTexGouraud

//-----------------------------------------------------------------------------
//
// __ProcessTri_3Vtx_PerspSingleTexGouraud
//
//-----------------------------------------------------------------------------
int
__ProcessTri_3Vtx_PerspSingleTexGouraud( 
    P3_D3DCONTEXT *pContext, 
    D3DTLVERTEX *pv[],
    int WireEdgeFlags )
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    TEXCOORDS tc[3];
    DWORD q[3];
    int forcedQ = 0;
    ULONG renderCmd = pContext->RenderCommand;
#if DX8_3DTEXTURES
    P3_SURF_INTERNAL* pTexture = pContext->pCurrentTexture[TEXSTAGE_0];
    BOOL b3DTexture = (pTexture ? pTexture->b3DTexture : FALSE);
#endif // DX8_3DTEXTURES

    P3_DMA_DEFS();

#if DX8_3DTEXTURES
    if (b3DTexture)
    {
        GET_TC_3DTEX(0); GET_TC_3DTEX(1); GET_TC_3DTEX(2);
    }
    else
    {
        GET_TC(0); GET_TC(1); GET_TC(2);
    }
#else
    GET_TC(0); GET_TC(1); GET_TC(2);
#endif // DX8_3DTEXTURES

#if CULL_HERE
    if( __BackfaceCullSingleTex( pContext, pv, tc ))
        return 1;
#endif

    P3_DMA_GET_BUFFER_ENTRIES( 26 );

    q[0] = *(DWORD *)&(pv[0]->rhw);
    q[1] = *(DWORD *)&(pv[1]->rhw);
    q[2] = *(DWORD *)&(pv[2]->rhw);

    // Check for equal Q's

    if((( q[0] ^ q[1] ) | ( q[1] ^ q[2] )) == 0 ) 
    {
        // Force to 1.0f

        forcedQ = q[0] = q[1] = q[2] = 0x3f800000;
    }
    else
    {
#if DX8_3DTEXTURES
        if (b3DTexture)
        {
            SCALE_BY_Q_3DTEX( 0 );
            SCALE_BY_Q_3DTEX( 1 );
            SCALE_BY_Q_3DTEX( 2 );
        }
        else
        {
            SCALE_BY_Q( 0 );
            SCALE_BY_Q( 1 );
            SCALE_BY_Q( 2 );
        }
#else
        SCALE_BY_Q( 0 );
        SCALE_BY_Q( 1 );
        SCALE_BY_Q( 2 );
#endif // DX8_3DTEXTURES
    }

#if DX8_3DTEXTURES
    if (b3DTexture)
    {
        SEND_R3FVFVERTEX_3DTEX(V0FloatS1_Tag, 0);
    }
#endif // DX8_3DTEXTURES
    SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V0FloatS_Tag, 0);

    
#if DX8_3DTEXTURES
    if (b3DTexture)
    {
        SEND_R3FVFVERTEX_3DTEX(V1FloatS1_Tag, 1);
    }
#endif // DX8_3DTEXTURES
    SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V1FloatS_Tag, 1);

    P3_DMA_COMMIT_BUFFER();
    P3_DMA_GET_BUFFER_ENTRIES( 15 );
    
#if DX8_3DTEXTURES
    if (b3DTexture)
    {
        SEND_R3FVFVERTEX_3DTEX(V2FloatS1_Tag, 2);
    }
#endif // DX8_3DTEXTURES
    SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V2FloatS_Tag, 2);

    RENDER_TRAPEZOID(renderCmd);

    DRAW_TRIANGLE();

    P3_DMA_COMMIT_BUFFER();

    return ( pContext->R3flushDueToTexCoordAdjust | forcedQ );
    
} // __ProcessTri_3Vtx_PerspSingleTexGouraud

//-----------------------------------------------------------------------------
//
// __ProcessTri_1Vtx_Generic
//
//-----------------------------------------------------------------------------
int
__ProcessTri_1Vtx_Generic( 
    P3_D3DCONTEXT *pContext,
    D3DTLVERTEX *pv[], 
    int vtx )
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    DWORD Flags = pContext->Flags;
    TEXCOORDS tc[3];
    DWORD q[3];
    ULONG renderCmd = pContext->RenderCommand;

    P3_DMA_DEFS();

    // We need to refresh all texture coords as they will have been modified
    // by the scale by Q and potentially D3D wrapping or TextureShift.

    GET_TEXCOORDS();

    if( __BackfaceCullAndMipMap( pContext, pv, tc ))
        return 1;

    if( Flags & SURFACE_PERSPCORRECT )
    {
        q[vtx] = *(DWORD *)&(pv[vtx]->rhw);
        SCALE_BY_Q( vtx );
    }

    // Send vertex data including check for flat shading

    P3_DMA_GET_BUFFER_ENTRIES( 16 );

    if( pContext->Flags & SURFACE_GOURAUD )
    {
        // 9 DWORDS.
        SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V0FloatS_Tag + (vtx*16), vtx);
    }
    else
    {
        DWORD Col0 = FVFCOLOR(pContext->pProvokingVertex)->color;

        if( Flags & SURFACE_SPECULAR )
        {
            DWORD Spec0 = GET_SPEC( FVFSPEC(pContext->pProvokingVertex)->specular );

            CLAMP8888( Col0, Col0, Spec0 );
        }

        if( Flags & SURFACE_FOGENABLE )
        {
            // 8 DWORDS.
            SEND_R3FVFVERTEX_XYZ_STQ_FOG(V0FloatS_Tag + (vtx*16), vtx);
        }
        else
        {
            // 7 DWORDS.
            SEND_R3FVFVERTEX_XYZ_STQ(V0FloatS_Tag + (vtx*16), vtx);
        }

        // 2 DWORDS.
        SEND_P3_DATA(ConstantColor,
            RGBA_MAKE(RGBA_GETBLUE(Col0),
                        RGBA_GETGREEN(Col0),
                        RGBA_GETRED(Col0),
                        RGBA_GETALPHA(Col0)));
    }

    // Send the second set of texture coordinates including scale-by-q

    if( pContext->iTexStage[1] != -1
                && ( pContext->FVFData.dwTexOffset[0] != pContext->FVFData.dwTexOffset[1]))
    {
        DISPDBG((DBGLVL,"Sending 2nd texture coordinates"));

        if( Flags & SURFACE_PERSPCORRECT )
        {
            SCALE_BY_Q2( vtx );
        }

        // 4 DWORDS.
        SEND_R3FVFVERTEX_STQ2(V0FloatS1_Tag + (vtx*16), vtx);
    }

    RENDER_TRAPEZOID(renderCmd);

    // 2 DWORDS.
    DRAW_TRIANGLE();

    P3_DMA_COMMIT_BUFFER();

    return pContext->R3flushDueToTexCoordAdjust;
} // __ProcessTri_1Vtx_Generic

//-----------------------------------------------------------------------------
// 
// __ProcessTri_3Vtx_Generic
//
//-----------------------------------------------------------------------------
int
__ProcessTri_3Vtx_Generic( 
    P3_D3DCONTEXT *pContext, 
    D3DTLVERTEX *pv[],
    int WireEdgeFlags )
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    DWORD Flags = pContext->Flags;
    TEXCOORDS tc[3];
    DWORD q[3];
    int forcedQ = 0;
    ULONG renderCmd = pContext->RenderCommand;

    P3_DMA_DEFS();

    GET_TEXCOORDS();

    if( __BackfaceCullAndMipMap( pContext, pv, tc ))
        return 1;     
        
    if( Flags & SURFACE_PERSPCORRECT )
    {
        q[0] = *(DWORD *)&(pv[0]->rhw);
        q[1] = *(DWORD *)&(pv[1]->rhw);
        q[2] = *(DWORD *)&(pv[2]->rhw);

        // Check for equal Q's

        if((( q[0] ^ q[1] ) | ( q[1] ^ q[2] )) == 0 ) 
        {
            // Force to 1.0f

            forcedQ = q[0] = q[1] = q[2] = 0x3f800000;
        }
        else
        {
            SCALE_BY_Q( 0 );
            SCALE_BY_Q( 1 );
            SCALE_BY_Q( 2 );
        }
    }
    else
    {
        q[0] = q[1] = q[2] = 0x3f800000;
    }

    // Send vertex data including check for flat shading

    // Worst case 27 DWORDS
    P3_DMA_GET_BUFFER_ENTRIES(29);

    if( pContext->Flags & SURFACE_GOURAUD )
    {
        if( Flags & SURFACE_TEXTURING )
        {
            // 9 DWORDs each.
            SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V0FloatS_Tag, 0);
            SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V1FloatS_Tag, 1);
            SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V2FloatS_Tag, 2);
        }
        else
        {
            // 6 DWORDs each.
            SEND_R3FVFVERTEX_XYZ_RGBA_SFOG(V0FloatS_Tag, 0);
            SEND_R3FVFVERTEX_XYZ_RGBA_SFOG(V1FloatS_Tag, 1);
            SEND_R3FVFVERTEX_XYZ_RGBA_SFOG(V2FloatS_Tag, 2);
        }
    }
    else
    {
        DWORD Col0 = FVFCOLOR(pContext->pProvokingVertex)->color;

        if( Flags & SURFACE_SPECULAR )
        {
            DWORD Spec0 = GET_SPEC( FVFSPEC(pContext->pProvokingVertex)->specular );

            CLAMP8888( Col0, Col0, Spec0 );
        }

        if( Flags & SURFACE_TEXTURING )
        {
            if( Flags & SURFACE_FOGENABLE )
            {
                // 8 DWORDs each.
                SEND_R3FVFVERTEX_XYZ_STQ_FOG(V0FloatS_Tag, 0);
                SEND_R3FVFVERTEX_XYZ_STQ_FOG(V1FloatS_Tag, 1);
                SEND_R3FVFVERTEX_XYZ_STQ_FOG(V2FloatS_Tag, 2);
            }
            else
            {
                // 7 DWORDs each.
                SEND_R3FVFVERTEX_XYZ_STQ(V0FloatS_Tag, 0);
                SEND_R3FVFVERTEX_XYZ_STQ(V1FloatS_Tag, 1);
                SEND_R3FVFVERTEX_XYZ_STQ(V2FloatS_Tag, 2);
            }
        }
        else
        {
            if( Flags & SURFACE_FOGENABLE )
            {
                // 5 DWORDs each.
                SEND_R3FVFVERTEX_XYZ_FOG(V0FloatS_Tag, 0);
                SEND_R3FVFVERTEX_XYZ_FOG(V1FloatS_Tag, 1);
                SEND_R3FVFVERTEX_XYZ_FOG(V2FloatS_Tag, 2);
            }
            else
            {
                // 4 DWORDs each.
                SEND_R3FVFVERTEX_XYZ(V0FloatS_Tag, 0);
                SEND_R3FVFVERTEX_XYZ(V1FloatS_Tag, 1);
                SEND_R3FVFVERTEX_XYZ(V2FloatS_Tag, 2);
            }
        }

        SEND_P3_DATA(ConstantColor,
            RGBA_MAKE(RGBA_GETBLUE(Col0),
                        RGBA_GETGREEN(Col0),
                        RGBA_GETRED(Col0),
                        RGBA_GETALPHA(Col0)));
    }

    // Send the second set of texture coordinates including scale-by-q

    if( pContext->iTexStage[1] != -1
                && ( pContext->FVFData.dwTexOffset[0] != pContext->FVFData.dwTexOffset[1]))
    {
        DISPDBG((DBGLVL,"Sending 2nd texture coordinates"));

        if( Flags & SURFACE_PERSPCORRECT )
        {
            SCALE_BY_Q2( 0 );
            SCALE_BY_Q2( 1 );
            SCALE_BY_Q2( 2 );
        }

        // 12 DWORDS    
        P3_DMA_COMMIT_BUFFER(); 
        P3_DMA_GET_BUFFER_ENTRIES(14);        
        // 4 DWORDs each.
        SEND_R3FVFVERTEX_STQ2(V0FloatS1_Tag, 0);
        SEND_R3FVFVERTEX_STQ2(V1FloatS1_Tag, 1);
        SEND_R3FVFVERTEX_STQ2(V2FloatS1_Tag, 2);
    }

    RENDER_TRAPEZOID(renderCmd);

    DRAW_TRIANGLE();

    P3_DMA_COMMIT_BUFFER();    

    return ( pContext->R3flushDueToTexCoordAdjust | forcedQ );
} // __ProcessTri_3Vtx_Generic



//-----------------------------------------------------------------------------
//
// __ProcessTri_1Vtx_Wire
//
//-----------------------------------------------------------------------------
int
__ProcessTri_1Vtx_Wire(
    P3_D3DCONTEXT *pContext,
    D3DTLVERTEX *pv[], 
    int vtx )
{ 
    DISPDBG((WRNLVL,"WE SHOULDN'T DO __ProcessTri_1Vtx_Wire"));
    return 1;
} // __ProcessTri_1Vtx_Wire

//-----------------------------------------------------------------------------
//
// __ProcessTri_3Vtx_Wire
//
//-----------------------------------------------------------------------------
int
__ProcessTri_3Vtx_Wire(
    P3_D3DCONTEXT *pContext,
    D3DTLVERTEX *pv[], 
    int WireEdgeFlags )
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    DWORD Flags = pContext->Flags;
    TEXCOORDS tc[3];
    int i;
    DWORD q[3];
    ULONG renderCmd = pContext->RenderCommand;
    const int edges[] = { SIDE_0, SIDE_1, SIDE_2 };

    P3_DMA_DEFS();

    GET_TEXCOORDS();

    if( __BackfaceCullAndMipMap( pContext, pv, tc ))
        return 1;

    RENDER_LINE(renderCmd);

    if( Flags & SURFACE_PERSPCORRECT )
    {
        q[0] = *(DWORD *)&(pv[0]->rhw);
        q[1] = *(DWORD *)&(pv[1]->rhw);
        q[2] = *(DWORD *)&(pv[2]->rhw);

        SCALE_BY_Q( 0 );
        SCALE_BY_Q( 1 );
        SCALE_BY_Q( 2 );

        if(pContext->iTexStage[1] != -1 )
        {
            SCALE_BY_Q2( 0 );
            SCALE_BY_Q2( 1 );
            SCALE_BY_Q2( 2 );
        }
    }

    // Send vertex data including check for flat shading

    for( i = 0; i < 3; i++ )
    {
        int v0, v1;

        v0 = i;
        v1 = i + 1;

        if( v1 == 3 )
            v1 = 0;

        if( WireEdgeFlags & edges[i] )
        {
            P3_DMA_GET_BUFFER_ENTRIES(30);
            
            if( pContext->Flags & SURFACE_GOURAUD )
            {
                // 9 DWORDs each.            
                SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V0FloatS_Tag, v0);
                SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V1FloatS_Tag, v1);
            }
            else
            {
                DWORD Col0 = FVFCOLOR(pContext->pProvokingVertex)->color;

                if( Flags & SURFACE_SPECULAR )
                {
                    DWORD Spec0 = GET_SPEC( FVFSPEC(pContext->pProvokingVertex)->specular );

                    CLAMP8888( Col0, Col0, Spec0 );
                }

                if( Flags & SURFACE_FOGENABLE )
                {
                    // 6 DWORDs each.                
                    SEND_R3FVFVERTEX_XYZ_STQ_FOG(V0FloatS_Tag, v0);
                    SEND_R3FVFVERTEX_XYZ_STQ_FOG(V1FloatS_Tag, v1);
                }
                else
                {
                    // 7 DWORDs each.                
                    SEND_R3FVFVERTEX_XYZ_STQ(V0FloatS_Tag, v0);
                    SEND_R3FVFVERTEX_XYZ_STQ(V1FloatS_Tag, v1);
                }

                SEND_P3_DATA(ConstantColor,
                    RGBA_MAKE(RGBA_GETBLUE(Col0),
                                RGBA_GETGREEN(Col0),
                                RGBA_GETRED(Col0),
                                RGBA_GETALPHA(Col0)));
            }

            // Send the second set of texture coordinates
            if( pContext->iTexStage[1] != -1
                    && ( pContext->FVFData.dwTexOffset[0] != pContext->FVFData.dwTexOffset[1] ))
            {
                // 4 DWORDs each.                
                SEND_R3FVFVERTEX_STQ2(V0FloatS1_Tag, v0);
                SEND_R3FVFVERTEX_STQ2(V1FloatS1_Tag, v1);
            }

            DRAW_LINE();

            P3_DMA_COMMIT_BUFFER();            
        }
    }

    return 1;
} // __ProcessTri_3Vtx_Wire

//-----------------------------------------------------------------------------
//
// __ProcessTri_1Vtx_Point
//
//-----------------------------------------------------------------------------
int
__ProcessTri_1Vtx_Point(
    P3_D3DCONTEXT *pContext,
    D3DTLVERTEX *pv[], 
    int vtx )
{ 
    DISPDBG((WRNLVL,"WE SHOULDN'T DO __ProcessTri_1Vtx_Wire"));
    return 1;
} // __ProcessTri_1Vtx_Point

//-----------------------------------------------------------------------------
//
// __ProcessTri_3Vtx_Point
//
//-----------------------------------------------------------------------------
int
__ProcessTri_3Vtx_Point(
    P3_D3DCONTEXT *pContext,
    D3DTLVERTEX *pv[], 
    int WireEdgeFlags )
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    DWORD Flags = pContext->Flags;
    TEXCOORDS tc[3];
    int i;
    DWORD q[3];
    ULONG renderCmd = pContext->RenderCommand;
    const int edges[] = { SIDE_0, SIDE_1, SIDE_2 };

    P3_DMA_DEFS();

    GET_TEXCOORDS();

    if( __BackfaceCullAndMipMap( pContext, pv, tc ))
        return 1;

    RENDER_POINT(renderCmd);

    if( Flags & SURFACE_PERSPCORRECT )
    {
        q[0] = *(DWORD *)&(pv[0]->rhw);
        q[1] = *(DWORD *)&(pv[1]->rhw);
        q[2] = *(DWORD *)&(pv[2]->rhw);

        SCALE_BY_Q( 0 );
        SCALE_BY_Q( 1 );
        SCALE_BY_Q( 2 );

        if(pContext->iTexStage[1] != -1)
        {
            SCALE_BY_Q2( 0 );
            SCALE_BY_Q2( 1 );
            SCALE_BY_Q2( 2 );
        }
    }

    // Send vertex data including check for flat shading

    for( i = 0; i < 3; i++ )
    {
        int v0, v1;

        v0 = i;
        v1 = i + 1;

        if( v1 == 3 )
            v1 = 0;

        if( WireEdgeFlags & edges[i] )
        {            
            P3_DMA_GET_BUFFER_ENTRIES( 16 );
            if( pContext->Flags & SURFACE_GOURAUD )
            {
                SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V0FloatS_Tag, v0);
            }
            else
            {
                DWORD Col0 = FVFCOLOR(pContext->pProvokingVertex)->color;

                if( Flags & SURFACE_SPECULAR )
                {
                    DWORD Spec0 = GET_SPEC( FVFSPEC(pContext->pProvokingVertex)->specular );

                    CLAMP8888( Col0, Col0, Spec0 );
                }

                if( Flags & SURFACE_FOGENABLE )
                {
                    SEND_R3FVFVERTEX_XYZ_STQ_FOG(V0FloatS_Tag, v0);
                }
                else
                {
                    SEND_R3FVFVERTEX_XYZ_STQ(V0FloatS_Tag, v0);
                }

                SEND_P3_DATA(ConstantColor,
                    RGBA_MAKE(RGBA_GETBLUE(Col0),
                                RGBA_GETGREEN(Col0),
                                RGBA_GETRED(Col0),
                                RGBA_GETALPHA(Col0)));
            }

            // Send the second set of texture coordinates

            if( pContext->iTexStage[1] != -1
                    && ( pContext->FVFData.dwTexOffset[0] != pContext->FVFData.dwTexOffset[1]))
            {
                DISPDBG((DBGLVL,"Sending 2nd texture coordinates"));

                SEND_R3FVFVERTEX_STQ2(V0FloatS1_Tag, v0);
            }

            DRAW_POINT();

            P3_DMA_COMMIT_BUFFER();
        }
    }

    return 1;
} // __ProcessTri_3Vtx_Point

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_TriangleList
// 
// Render D3DDP2OP_TRIANGLELIST triangles
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_TriangleList( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex, i;
    D3DTLVERTEX *pv[3];

    DBG_ENTRY(_D3D_R3_DP2_TriangleList); 

    dwIndex = ((D3DHAL_DP2TRIANGLELIST*)lpPrim)->wVStart;

    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex);
    pv[1] = LP_FVF_NXT_VTX(pv[0]);
    pv[2] = LP_FVF_NXT_VTX(pv[1]);

    // Check first & last vertex
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex + 3*dwPrimCount - 1);

    pContext->dwProvokingVertex = 0;
    for( i = 0; i < dwPrimCount; i++ )
    {    
        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];
        
        (*pContext->pRendTri_3V)( pContext, pv, ALL_SIDES);

        pv[0] = LP_FVF_NXT_VTX(pv[2]);
        pv[1] = LP_FVF_NXT_VTX(pv[0]);
        pv[2] = LP_FVF_NXT_VTX(pv[1]);
    }

    DBG_EXIT(_D3D_R3_DP2_TriangleList,0); 
    
} // _D3D_R3_DP2_TriangleList

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_TriangleFan
// 
// Render a D3DDP2OP_TRIANGLEFAN triangle
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_TriangleFan(
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex, i;
    D3DTLVERTEX *pv[3];
    int vtx, lastVtx, bCulled;
    SAVE_CULLING_STATE(pContext);
    
    DBG_ENTRY(_D3D_R3_DP2_TriangleFan); 

    lastVtx = vtx = 2;

    dwIndex = ((D3DHAL_DP2TRIANGLEFAN*)lpPrim)->wVStart;

    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex); 
    pv[1] = LP_FVF_NXT_VTX(pv[0]);
    pv[2] = LP_FVF_NXT_VTX(pv[1]);

    // Check first & last vertex
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex + dwPrimCount + 1);    

    pContext->dwProvokingVertex = 1;
    pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];

    bCulled = (*pContext->pRendTri_3V)( pContext, pv, ALL_SIDES);

    for( i = 1; i < dwPrimCount; i++ )
    {
        vtx ^= 3; // 2 -> 1, 1 -> 2

        FLIP_CCW_CW_CULLING(pContext);

        pv[vtx] = LP_FVF_NXT_VTX(pv[lastVtx]);
       
        pContext->dwProvokingVertex = lastVtx;
        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];
        
        if( bCulled )
            bCulled = (*pContext->pRendTri_3V)( pContext, pv, ALL_SIDES);
        else
            bCulled = (*pContext->pRendTri_1V)( pContext, pv, vtx );

        lastVtx = vtx;
    }

    RESTORE_CULLING_STATE(pContext);

    DBG_EXIT(_D3D_R3_DP2_TriangleFan,0);     
    
} // _D3D_R3_DP2_TriangleFan

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_TriangleFanImm
//
// Render D3DDP2OP_TRIANGLEFAN_IMM triangles 
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_TriangleFanImm(
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[3];
    DWORD i, dwEdgeFlags, eFlags;
    int vtx, lastVtx, bCulled;
    SAVE_CULLING_STATE(pContext);    

    DBG_ENTRY(_D3D_R3_DP2_TriangleFanImm); 

    lastVtx = vtx = 2;

    // Edge flags are used for wireframe fillmode
    dwEdgeFlags = ((D3DHAL_DP2TRIANGLEFAN_IMM *)lpPrim)->dwEdgeFlags;
    lpPrim += sizeof(D3DHAL_DP2TRIANGLEFAN_IMM); 

    // Vertices in an IMM instruction are stored in the
    // command buffer and are DWORD aligned

    lpPrim = (LPBYTE)((ULONG_PTR)( lpPrim + 3 ) & ~3 );

    pv[0] = (LPD3DTLVERTEX)lpPrim;
    pv[1] = LP_FVF_NXT_VTX(pv[0]);
    pv[2] = LP_FVF_NXT_VTX(pv[1]);

    // since data is in the command buffer, we've already verified it as valid

    // Build up edge flags for the next single primitive
    eFlags  = ( dwEdgeFlags & 1 ) ? SIDE_0 : 0;
    eFlags |= ( dwEdgeFlags & 2 ) ? SIDE_1 : 0;
    dwEdgeFlags >>= 2;

    pContext->dwProvokingVertex = 1;
    pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];
    
    bCulled = (*pContext->pRendTri_3V)( pContext, pv, eFlags);

    for( i = 1; i < dwPrimCount; i++ )
    {
        // 2 -> 1, 1 -> 2

        vtx ^= 3;
        FLIP_CCW_CW_CULLING(pContext);
        
        pv[vtx] = LP_FVF_NXT_VTX(pv[lastVtx]);

        if( i == ( dwPrimCount - 1 ))
        {
            eFlags  = ( dwEdgeFlags & 1 ) ? SIDE_1 : 0;
            eFlags |= ( dwEdgeFlags & 2 ) ? SIDE_2 : 0;
        }
        else
        {
            eFlags = ( dwEdgeFlags & 1 ) ? SIDE_1 : 0;
            dwEdgeFlags >>= 1;
        }
        
        pContext->dwProvokingVertex = lastVtx;
        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];
        
        if( bCulled )
            bCulled = (*pContext->pRendTri_3V)( pContext, pv, eFlags);
        else
            bCulled = (*pContext->pRendTri_1V)( pContext, pv, vtx );

        lastVtx = vtx;
    }

    RESTORE_CULLING_STATE(pContext);

    DBG_EXIT(_D3D_R3_DP2_TriangleFanImm,0); 
    
} // _D3D_R3_DP2_TriangleFanImm

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_TriangleStrip
// 
// Render D3DDP2OP_TRIANGLESTRIP triangles 
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_TriangleStrip( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex, i;
    D3DTLVERTEX *pv[3];
    int vtx_a, vtx_b, lastVtx, bCulled;
    SAVE_CULLING_STATE(pContext);    

    DBG_ENTRY(_D3D_R3_DP2_TriangleStrip);       

    dwIndex = ((D3DHAL_DP2TRIANGLEFAN*)lpPrim)->wVStart;

    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex);
    pv[1] = LP_FVF_NXT_VTX(pv[0]);
    pv[2] = LP_FVF_NXT_VTX(pv[1]);

    // Check first & last vertex
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex + dwPrimCount + 1);

    pContext->dwProvokingVertex = 0;
    pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];
    
    bCulled = (*pContext->pRendTri_3V)( pContext, pv, ALL_SIDES);

    lastVtx = 2;
    INIT_VERTEX_INDICES(pContext, vtx_a, vtx_b);

    for( i = 1; i < dwPrimCount; i++ )
    {
        FLIP_CCW_CW_CULLING(pContext);
        
        pv[vtx_a] = LP_FVF_NXT_VTX(pv[lastVtx]);

        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];

        if( bCulled )
            bCulled = (*pContext->pRendTri_3V)( pContext, pv,ALL_SIDES);
        else
            bCulled = (*pContext->pRendTri_1V)( pContext, pv, vtx_a );

        lastVtx = vtx_a;
        CYCLE_VERTEX_INDICES(pContext, vtx_a, vtx_b);
    }

    RESTORE_CULLING_STATE(pContext);
    
    DBG_EXIT(_D3D_R3_DP2_TriangleStrip,0);     
    
} // _D3D_R3_DP2_TriangleStrip

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedTriangleStrip
// 
// Render D3DDP2OP_INDEXEDTRIANGLESTRIP triangles
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedTriangleStrip( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex0, dwIndex1, dwIndex2, i;
    WORD wVStart;
    D3DTLVERTEX *pv[3];
    int vtx_a, vtx_b, bCulled;
    SAVE_CULLING_STATE(pContext);    

    DBG_ENTRY(_D3D_R3_DP2_IndexedTriangleStrip); 

    wVStart = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
    lpPrim += sizeof(D3DHAL_DP2STARTVERTEX);

    dwIndex0 = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[0];
    dwIndex1 = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[1];
    dwIndex2 = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[2];

    lpVertices = LP_FVF_VERTEX(lpVertices, wVStart);

    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
    pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
    pv[2] = LP_FVF_VERTEX(lpVertices, dwIndex2);

    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex0);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex1);    
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex2);    

    pContext->dwProvokingVertex = 0;
    pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];

    bCulled = (*pContext->pRendTri_3V)( pContext, pv, ALL_SIDES);
    lpPrim += sizeof(WORD);

    INIT_VERTEX_INDICES(pContext, vtx_a, vtx_b);

    for( i = 1; i < dwPrimCount; i++ )
    {
        FLIP_CCW_CW_CULLING(pContext);
        
        dwIndex2 = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[2];
        pv[vtx_a] = LP_FVF_VERTEX(lpVertices, dwIndex2);

        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex2);            

        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];

        if( bCulled )
            bCulled = (*pContext->pRendTri_3V)( pContext, pv, ALL_SIDES);
        else
            bCulled = (*pContext->pRendTri_1V)( pContext, pv, vtx_a );

        lpPrim += sizeof(WORD);

        CYCLE_VERTEX_INDICES(pContext, vtx_a, vtx_b);
    }

    RESTORE_CULLING_STATE(pContext);
    
    DBG_EXIT(_D3D_R3_DP2_IndexedTriangleStrip,0); 
    
} // _D3D_R3_DP2_IndexedTriangleStrip

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedTriangleFan
// 
// Render D3DDP2OP_INDEXEDTRIANGLEFAN triangles 
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedTriangleFan( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex0, dwIndex1, dwIndex2, i;
    WORD wVStart;
    D3DTLVERTEX *pv[3];
    int vtx, lastVtx, bCulled;
    SAVE_CULLING_STATE(pContext);    

    DBG_ENTRY(_D3D_R3_DP2_IndexedTriangleFan);     

    wVStart = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
    lpPrim += sizeof(D3DHAL_DP2STARTVERTEX);

    dwIndex0 = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[0];
    dwIndex1 = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[1];
    dwIndex2 = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[2];

    lastVtx = vtx = 2;
    pv[0] = LP_FVF_VERTEX(lpVertices, wVStart + dwIndex0);
    pv[1] = LP_FVF_VERTEX(lpVertices, wVStart + dwIndex1);
    pv[2] = LP_FVF_VERTEX(lpVertices, wVStart + dwIndex2);

    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, (DWORD)(wVStart) + dwIndex0);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, (DWORD)(wVStart) + dwIndex1);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, (DWORD)(wVStart) + dwIndex2);    

    pContext->dwProvokingVertex = 1;
    pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];
    
    bCulled = (*pContext->pRendTri_3V)( pContext, pv, ALL_SIDES);
    lpPrim += sizeof(WORD);

    for( i = 1; i < dwPrimCount; i++ )
    {
        // 2 -> 1, 1 -> 2

        vtx ^= 3;
        FLIP_CCW_CW_CULLING(pContext);
        
        dwIndex2 = ((D3DHAL_DP2INDEXEDTRIANGLEFAN*)lpPrim)->wV[2];
        pv[vtx] = LP_FVF_VERTEX(lpVertices, wVStart + dwIndex2);
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, wVStart + dwIndex2);         

        pContext->dwProvokingVertex = lastVtx;
        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];
        
        if( bCulled )
            bCulled = (*pContext->pRendTri_3V)( pContext, pv, ALL_SIDES);
        else
            bCulled = (*pContext->pRendTri_1V)( pContext, pv, vtx );

        lastVtx = vtx;
        lpPrim += sizeof(WORD);
    }

    RESTORE_CULLING_STATE(pContext);
    
    DBG_EXIT(_D3D_R3_DP2_IndexedTriangleFan,0);       
    
} // _D3D_R3_DP2_IndexedTriangleFan

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedTriangleList
// 
// Render D3DDP2OP_INDEXEDTRIANGLELIST triangles 
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedTriangleList( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex0, dwIndex1, dwIndex2, i, primData;
    WORD wFlags;
    D3DTLVERTEX *pv[3];

    DBG_ENTRY(_D3D_R3_DP2_IndexedTriangleList); 

    pContext->dwProvokingVertex = 0;
    
    for( i = 0; i < dwPrimCount; i++ )
    {
        dwIndex0 = ((D3DHAL_DP2INDEXEDTRIANGLELIST*)lpPrim)->wV1;
        dwIndex1 = ((D3DHAL_DP2INDEXEDTRIANGLELIST*)lpPrim)->wV2;
        dwIndex2 = ((D3DHAL_DP2INDEXEDTRIANGLELIST*)lpPrim)->wV3;
        wFlags  = ((D3DHAL_DP2INDEXEDTRIANGLELIST*)lpPrim)->wFlags;

        pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
        pv[2] = LP_FVF_VERTEX(lpVertices, dwIndex2);

        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex0);        
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex1);  
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex2);  

        lpPrim += sizeof(D3DHAL_DP2INDEXEDTRIANGLELIST);

        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];

        (*pContext->pRendTri_3V)( pContext, pv, wFlags);
    }

    DBG_EXIT(_D3D_R3_DP2_IndexedTriangleList,0); 
    
} // _D3D_R3_DP2_IndexedTriangleList

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedTriangleList2
// 
// Render D3DDP2OP_INDEXEDTRIANGLELIST2 triangles 
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedTriangleList2( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex0, dwIndex1, dwIndex2, i;
    WORD wVStart;
    D3DTLVERTEX *pv[3];

    DBG_ENTRY(_D3D_R3_DP2_IndexedTriangleList2); 
    
    wVStart = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
    lpPrim += sizeof(D3DHAL_DP2STARTVERTEX);

    lpVertices = LP_FVF_VERTEX(lpVertices, wVStart);

    pContext->dwProvokingVertex = 0;
    for( i = 0; i < dwPrimCount; i++ )
    {
        dwIndex0 = ((D3DHAL_DP2INDEXEDTRIANGLELIST2*)lpPrim)->wV1;
        dwIndex1 = ((D3DHAL_DP2INDEXEDTRIANGLELIST2*)lpPrim)->wV2;
        dwIndex2 = ((D3DHAL_DP2INDEXEDTRIANGLELIST2*)lpPrim)->wV3;

        pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
        pv[2] = LP_FVF_VERTEX(lpVertices, dwIndex2);

        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, (DWORD)wVStart + dwIndex0);    
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, (DWORD)wVStart + dwIndex1);           
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, (DWORD)wVStart + dwIndex2);           

        lpPrim += sizeof(D3DHAL_DP2INDEXEDTRIANGLELIST2);

        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];

        (*pContext->pRendTri_3V)( pContext, pv, ALL_SIDES);
    }

    DBG_EXIT(_D3D_R3_DP2_IndexedTriangleList2,0); 
    
} // _D3D_R3_DP2_IndexedTriangleList2

//-----------------------------------------------------------------------------
//
// __ProcessLine
// 
// Render a single line
//
//-----------------------------------------------------------------------------
void
__ProcessLine(
    P3_D3DCONTEXT *pContext,
    D3DTLVERTEX *pv[],
    D3DTLVERTEX *pProvokingVtx)
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    DWORD Flags = pContext->Flags;
    TEXCOORDS tc[2];
    DWORD q[2];
    ULONG renderCmd = pContext->RenderCommand;

    P3_DMA_DEFS();    

    RENDER_LINE(renderCmd);   

    GET_TC(0); GET_TC(1);

    P3_DMA_GET_BUFFER_ENTRIES(22);

    if (pContext->RenderStates[D3DRENDERSTATE_LINEPATTERN])    
    {
        // if we are line stippling then reset rendering for each line
        SEND_P3_DATA( UpdateLineStippleCounters , 0);
    }

    if( Flags & SURFACE_PERSPCORRECT )
    {
        q[0] = *(DWORD *)&(pv[0]->rhw);
        q[1] = *(DWORD *)&(pv[1]->rhw);

        SCALE_BY_Q( 0 );
        SCALE_BY_Q( 1 );
    }
    else
    {
        q[0] = q[1] = 0;
    }

    if (Flags & SURFACE_GOURAUD)
    {
        SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V0FloatS_Tag, 0);
        SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG(V1FloatS_Tag, 1);
    }
    else
    {
        DWORD Col0 = FVFCOLOR(pProvokingVtx)->color;                    
    
        SEND_R3FVFVERTEX_XYZ_STQ_FOG(V0FloatS_Tag, 0);
        SEND_R3FVFVERTEX_XYZ_STQ_FOG(V1FloatS_Tag, 1);

        if( pContext->Flags & SURFACE_SPECULAR )                    
        {                                                           
            DWORD Spec0 = GET_SPEC( FVFSPEC(pProvokingVtx)->specular );     
            CLAMP8888( Col0, Col0, Spec0 );                             
        }                                                               
        SEND_P3_DATA(ConstantColor, RGBA_MAKE(RGBA_GETBLUE(Col0),       
                                                RGBA_GETGREEN(Col0),    
                                                RGBA_GETRED(Col0),      
                                                RGBA_GETALPHA(Col0)));  
    }

    DRAW_LINE();

    P3_DMA_COMMIT_BUFFER();
   
} // __ProcessLine

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_LineList
// 
// Render D3DDP2OP_LINELIST lines
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_LineList( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[2];
    WORD wVStart;
    DWORD i;
       
    DBG_ENTRY(_D3D_R3_DP2_LineList);

    wVStart = ((D3DHAL_DP2LINELIST*)lpPrim)->wVStart;

    pv[0] = LP_FVF_VERTEX(lpVertices, wVStart);
    pv[1] = LP_FVF_NXT_VTX(pv[0]);

    // Check first & last vertex
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, wVStart);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen,
                           (LONG)wVStart + 2*dwPrimCount - 1)

    for( i = 0; i < dwPrimCount; i++ )
    {
        __ProcessLine(pContext, pv, pv[0]);

        pv[0] = LP_FVF_NXT_VTX(pv[1]);
        pv[1] = LP_FVF_NXT_VTX(pv[0]);
    }

    DBG_EXIT(_D3D_R3_DP2_LineList,0);
    
} // _D3D_R3_DP2_LineList

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_LineListImm
// 
// Render D3DDP2OP_LINELIST_IMM lines
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_LineListImm( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[2];
    DWORD i;

    DBG_ENTRY(_D3D_R3_DP2_LineListImm);

    pv[0] = (LPD3DTLVERTEX)lpPrim;
    pv[1] = LP_FVF_NXT_VTX(pv[0]);
    
    // since data is in the command buffer, we've already verified it as valid

    for( i = 0; i < dwPrimCount; i++ )
    {
        __ProcessLine(pContext, pv, pv[0]);

        pv[0] = LP_FVF_NXT_VTX(pv[1]);
        pv[1] = LP_FVF_NXT_VTX(pv[0]);
    }

    DBG_EXIT(_D3D_R3_DP2_LineListImm,0);
    
} // _D3D_R3_DP2_LineListImm

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_LineStrip
// 
// Render D3DDP2OP_LINESTRIP lines
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_LineStrip( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[2];
    WORD wVStart;
    DWORD i;

    DBG_ENTRY(_D3D_R3_DP2_LineStrip);

    wVStart = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
    pv[0] = LP_FVF_VERTEX(lpVertices, wVStart);
    pv[1] = LP_FVF_NXT_VTX(pv[0]);    

    // Check first & last vertex
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, wVStart);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, wVStart + dwPrimCount);

    for( i = 0; i < dwPrimCount; i++ )
    {
        __ProcessLine(pContext, pv, pv[0]);

        pv[0] = pv[1];
        pv[1] = LP_FVF_NXT_VTX(pv[1]);
    }

    DBG_EXIT(_D3D_R3_DP2_LineStrip,0);    
    
} // _D3D_R3_DP2_LineStrip

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedLineList
// 
// Render D3DDP2OP_INDEXEDLINELIST lines
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedLineList( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[2];
    DWORD primData, dwIndex0, dwIndex1, i;

    DBG_ENTRY(_D3D_R3_DP2_IndexedLineList);
    
    for( i = 0; i < dwPrimCount; i++ )
    {
        primData = *(DWORD *)lpPrim;
        dwIndex0 = ( primData >>  0 ) & 0xffff;
        dwIndex1 = ( primData >> 16 );

        pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex0);        
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex1);        

        lpPrim += sizeof(D3DHAL_DP2INDEXEDLINELIST);

        __ProcessLine(pContext, pv, pv[0]);
    }

    DBG_EXIT(_D3D_R3_DP2_IndexedLineList,0);
    
} // _D3D_R3_DP2_IndexedLineList

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedLineList2
// 
// Render D3DDP2OP_INDEXEDLINELIST2 lines
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedLineList2( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[2];
    DWORD primData, i;
    WORD wVStart, dwIndex0, dwIndex1;

    DBG_ENTRY(_D3D_R3_DP2_IndexedLineList2);    

    wVStart = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
    lpVertices = LP_FVF_VERTEX(lpVertices, wVStart);

    lpPrim += sizeof(D3DHAL_DP2STARTVERTEX);

    for( i = 0; i < dwPrimCount; i++ )
    {
        primData = *(DWORD *)lpPrim;
        dwIndex0 = ( (WORD)(primData >>  0) ) & 0xffff;
        dwIndex1 = ( (WORD)(primData >> 16) );

        pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex0 + wVStart);
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex1 + wVStart);        

        lpPrim += sizeof(D3DHAL_DP2INDEXEDLINELIST);

        __ProcessLine(pContext, pv, pv[0]);
    }

    DBG_EXIT(_D3D_R3_DP2_IndexedLineList2,0);  
    
} // _D3D_R3_DP2_IndexedLineList2

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedLineStrip
// 
// Render D3DDP2OP_INDEXEDLINESTRIP lines
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedLineStrip( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[2];
    WORD wVStart, dwIndex, *pwIndx;
    DWORD i;

    DBG_ENTRY(_D3D_R3_DP2_IndexedLineStrip);      

    wVStart = ((D3DHAL_DP2STARTVERTEX*)lpPrim)->wVStart;
    lpVertices = LP_FVF_VERTEX(lpVertices, wVStart);

    lpPrim += sizeof(D3DHAL_DP2STARTVERTEX);
    pwIndx = (WORD *)lpPrim;

    dwIndex = *pwIndx++;
    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex);

    for( i = 0; i < dwPrimCount; i++ )
    {
        dwIndex = *pwIndx++;
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex);
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex);        

        __ProcessLine(pContext, pv, pv[0]);

        pv[0] = pv[1];       
    }
 
    DBG_EXIT(_D3D_R3_DP2_IndexedLineStrip,0);  
    
} // _D3D_R3_DP2_IndexedLineStrip

//-----------------------------------------------------------------------------
//
// __ProcessPoints
// 
// Render a set points specified by adjacent FVF vertices
//
//-----------------------------------------------------------------------------
void
__ProcessPoints(
    P3_D3DCONTEXT *pContext,
    D3DTLVERTEX *pv[],
    DWORD dwCount)
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;
    DWORD Flags = pContext->Flags;
    DWORD q[1];
    TEXCOORDS tc[1];
    ULONG renderCmd = pContext->RenderCommand;
    DWORD j;
    D3DTLVERTEX *ptmpV;

    P3_DMA_DEFS();

    ptmpV = pv[0];
    
    RENDER_LINE(renderCmd);   

    q[0] = 0;
    
    for( j = 0; j < dwCount; j++ )
    {
        P3_DMA_GET_BUFFER_ENTRIES( 20 );

        GET_TC(0);

        if( Flags & SURFACE_PERSPCORRECT )
        {
            q[0] = *(DWORD *)&(pv[0]->rhw);

            SCALE_BY_Q( 0 );
        }

        SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG_POINT(V0FloatS_Tag, 0, FALSE);
        SEND_R3FVFVERTEX_XYZ_STQ_RGBA_SFOG_POINT(V1FloatS_Tag, 0, TRUE);

        DRAW_LINE();

        P3_DMA_COMMIT_BUFFER();
        
        pv[0] = LP_FVF_NXT_VTX(pv[0]);           
    }

    pv[0] = ptmpV;

} // __ProcessPoints

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_Points
// 
// Render D3DDP2OP_POINTS points
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_Points( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[1];
    WORD wVStart, wCount;
    DWORD i;

    DBG_ENTRY(_D3D_R3_DP2_Points);      

    for( i = 0; i < dwPrimCount; i++ )
    {
        wVStart = ((D3DHAL_DP2POINTS*)lpPrim)->wVStart;
        wCount = ((D3DHAL_DP2POINTS*)lpPrim)->wCount;
        lpVertices = LP_FVF_VERTEX(lpVertices, wVStart);

        // Check first & last vertex
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, wVStart);
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, wVStart + wCount - 1);

        pv[0] = LP_FVF_VERTEX(lpVertices, 0);
        __ProcessPoints(pContext, pv, wCount);

        lpPrim += sizeof(D3DHAL_DP2POINTS);
    }

    DBG_EXIT(_D3D_R3_DP2_Points,0);       

} // _D3D_R3_DP2_Points

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_Points_DWCount
// 
// Render D3DDP2OP_POINTS points for DX8 case
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_Points_DWCount( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[1];
    WORD wVStart;
    DWORD i;

    DBG_ENTRY(_D3D_R3_DP2_Points_DWCount);      

    wVStart = ((D3DHAL_DP2POINTS*)lpPrim)->wVStart;
    lpVertices = LP_FVF_VERTEX(lpVertices, wVStart);

    // Check first & last vertex
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, wVStart);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, wVStart + dwPrimCount - 1);

    pv[0] = LP_FVF_VERTEX(lpVertices, 0);
    __ProcessPoints(pContext, pv, dwPrimCount);

    DBG_EXIT(_D3D_R3_DP2_Points_DWCount,0);       

} // _D3D_R3_DP2_Points_DWCount

#if DX8_POINTSPRITES

#define SPRITETEXCOORDMAX 1.0f

//Size of maximum FVF that we can get. Used for temporary storage
typedef BYTE P3FVFMAXVERTEX[ 3 * sizeof( D3DVALUE ) +    // Position coordinates
                             5 * 4                  +    // D3DFVF_XYZB5
                                 sizeof( D3DVALUE ) +    // FVF_TRANSFORMED
                             3 * sizeof( D3DVALUE ) +    // Normals
                                 sizeof( DWORD )    +    // RESERVED1
                                 sizeof( DWORD )    +    // Diffuse color
                                 sizeof( D3DCOLOR ) +    // Specular color
                                 sizeof( D3DVALUE ) +    // Point sprite size
                             4 * 8 * sizeof( D3DVALUE )  // 8 sets of 4D texture coordinates
                           ];

//-----------------------------------------------------------------------------
//
// __Render_One_PointSprite
//
// Render a point sprite with FVF vertexes when the point sprite enable is on
//
// Note: this is not the most optimized implementation possible for 
//       pointprites on this hw. We are merely following the definition.
//       Later implementation will be optimized.
//-----------------------------------------------------------------------------
void
__Render_One_PointSprite(
    P3_D3DCONTEXT *pContext,
    D3DTLVERTEX *lpVertex)
{
    // notice these are BYTE[], so its not necessary to write &fvfVUL to 
    // get the address of fvfVUL (just write fvfVUL)
    P3FVFMAXVERTEX fvfVUL, fvfVUR, fvfVLL, fvfVLR ; 

    D3DVALUE fPntSize, fPntSizeHalf, fD2, fD, fScalePntSize, fFac;
    D3DTLVERTEX *pv[3];
    FVFOFFSETS OrigFVF;
    BOOL bTexturingWOTexCoords = FALSE;
    SAVE_CULLING_STATE(pContext);

    DBG_ENTRY(__Render_One_PointSprite);          

    // Get point sprite size , if FVF data comes with it, grab it from there
    if (pContext->FVFData.dwPntSizeOffset)
    {
        fPntSize = FVFPSIZE(lpVertex)->psize;
        DISPDBG((DBGLVL,"FVF Data fPntSize = %d",(LONG)(fPntSize*1000.0f) ));
    }
    else
    {
        fPntSize = pContext->PntSprite.fSize;
        DISPDBG((DBGLVL,"RS fPntSize = %d",(LONG)(fPntSize*1000.0f) ));        
    }

    // We don't need to compute the point size according to the scale
    // factors and viewport size, etc as we are not a TnL driver.
    // See the spec for deatils

    // Clamp fPntSize to limits defined by the driver caps (dvMaxPointSize)
    // and the D3DRS_POINTSIZE_MIN and D3DRS_POINTSIZE_MAX renderstates
    fPntSize = max(pContext->PntSprite.fSizeMin, 
                   fPntSize);
                   
    fPntSize = min( min(pContext->PntSprite.fSizeMax, 
                        P3_MAX_POINTSPRITE_SIZE), 
                    fPntSize);           

    // Divide by 2 to get the amount by which to modify vertex coords
    fPntSizeHalf =  fPntSize * 0.5f;

    // Initialize square vertex values
    memcpy( fvfVUL, lpVertex, pContext->FVFData.dwStride);
    memcpy( fvfVUR, lpVertex, pContext->FVFData.dwStride);
    memcpy( fvfVLL, lpVertex, pContext->FVFData.dwStride);
    memcpy( fvfVLR, lpVertex, pContext->FVFData.dwStride);

    // Make this a square of size fPntSize
    ((D3DTLVERTEX *)fvfVUL)->sx -= fPntSizeHalf;
    ((D3DTLVERTEX *)fvfVUL)->sy -= fPntSizeHalf;

    ((D3DTLVERTEX *)fvfVUR)->sx += fPntSizeHalf;
    ((D3DTLVERTEX *)fvfVUR)->sy -= fPntSizeHalf;

    ((D3DTLVERTEX *)fvfVLL)->sx -= fPntSizeHalf;
    ((D3DTLVERTEX *)fvfVLL)->sy += fPntSizeHalf;

    ((D3DTLVERTEX *)fvfVLR)->sx += fPntSizeHalf;
    ((D3DTLVERTEX *)fvfVLR)->sy += fPntSizeHalf;

    // This is for the case in which PntSprite.bEnabled is false
    // and we are texturing even if we have no tex  coord data in 
    // the pointsprite vertexes
    bTexturingWOTexCoords = (pContext->FVFData.dwNonTexStride == 
                              pContext->FVFData.dwStride )
                          && (!pContext->bTexDisabled);

    if (pContext->PntSprite.bEnabled || bTexturingWOTexCoords)  
    {
        // Remember orig FVF offsets in order to fake our own texcoords
        OrigFVF = pContext->FVFData;
    
        // We "create" new texturing info in our data in order to
        // process vertexes even without texturing coord info
        // This is OK since we are using P3FVFMAXVERTEX as the type
        // of our temporary data structures for each vertex so we
        // can't overflow.

        // If stage 0 texture is used
        pContext->FVFData.dwTexCount = 1;
        pContext->FVFData.dwTexOffset[0] =
        pContext->FVFData.dwTexCoordOffset[0] = 
                        pContext->FVFData.dwNonTexStride;
                        
        // If stage 1 texture is used
        // we can use the same tex coord set since they are equal
        pContext->FVFData.dwTexOffset[1] =
                    pContext->FVFData.dwTexCoordOffset[0];

        if (pContext->PntSprite.bEnabled)
        {
            // Set up texture coordinates according to spec 
            FVFTEX(fvfVUL, 0)->tu = 0.0f;
            FVFTEX(fvfVUL, 0)->tv = 0.0f;
           
            FVFTEX(fvfVUR, 0)->tu = SPRITETEXCOORDMAX;
            FVFTEX(fvfVUR, 0)->tv = 0.0f;
            
            FVFTEX(fvfVLL, 0)->tu = 0.0f;
            FVFTEX(fvfVLL, 0)->tv = SPRITETEXCOORDMAX;
            
            FVFTEX(fvfVLR, 0)->tu = SPRITETEXCOORDMAX;
            FVFTEX(fvfVLR, 0)->tv = SPRITETEXCOORDMAX;  
        }
        else
        {
            // if we got here then PntSprite.bEnabled is false 
            // so just make the tex coords == (0,0)
            FVFTEX(fvfVUL, 0)->tu = 0.0f;
            FVFTEX(fvfVUL, 0)->tv = 0.0f;
           
            FVFTEX(fvfVUR, 0)->tu = 0.0f;
            FVFTEX(fvfVUR, 0)->tv = 0.0f;
            
            FVFTEX(fvfVLL, 0)->tu = 0.0f;
            FVFTEX(fvfVLL, 0)->tv = 0.0f;
            
            FVFTEX(fvfVLR, 0)->tu = 0.0f;
            FVFTEX(fvfVLR, 0)->tv = 0.0f;           
        }

#if DX8_3DTEXTURES        
        // Allow for the case of 3D texturing
        FVFTEX(fvfVUL, 0)->tw = 0.0f;    
        FVFTEX(fvfVUR, 0)->tw = 0.0f;  
        FVFTEX(fvfVLL, 0)->tw = 0.0f;          
        FVFTEX(fvfVLR, 0)->tw = 0.0f;          
#endif        
    } 

   // Make sure Culling doesn't prevent pointsprites from rendering
   SET_CULLING_TO_NONE(pContext);  // culling state was previously saved

   // here we are going to send the required quad
   pv[0] = (D3DTLVERTEX*)fvfVUL;
   pv[1] = (D3DTLVERTEX*)fvfVUR;
   pv[2] = (D3DTLVERTEX*)fvfVLL;
    __ProcessTri_3Vtx_Generic(pContext, pv, ALL_SIDES);

   pv[0] = (D3DTLVERTEX*)fvfVLL;
   pv[1] = (D3DTLVERTEX*)fvfVUR;
   pv[2] = (D3DTLVERTEX*)fvfVLR;
    __ProcessTri_3Vtx_Generic(pContext, pv, ALL_SIDES); 

   // Restore original Culling settings
   RESTORE_CULLING_STATE(pContext);

   // Restore original FVF offsets 
   if (pContext->PntSprite.bEnabled || bTexturingWOTexCoords)     
   {
       pContext->FVFData = OrigFVF;
   }

   DBG_EXIT(__Render_One_PointSprite, 0);    
    
} // __Render_One_PointSprite

//-----------------------------------------------------------------------------
//
// __ProcessTri_1Vtx_PointSprite
//
//-----------------------------------------------------------------------------
int
__ProcessTri_1Vtx_PointSprite(
    P3_D3DCONTEXT *pContext,
    D3DTLVERTEX *pv[], 
    int vtx )
{ 
    DISPDBG((WRNLVL,"WE SHOULDN'T DO __ProcessTri_1Vtx_PointSprite"));
    return 1;
} // __ProcessTri_1Vtx_PointSprite


//-----------------------------------------------------------------------------
//
// __ProcessTri_3Vtx_PointSprite
//
//-----------------------------------------------------------------------------
int
__ProcessTri_3Vtx_PointSprite(
    P3_D3DCONTEXT *pContext,
    D3DTLVERTEX *pv[], 
    int WireEdgeFlags )
{
#if CULL_HERE
    if( __BackfaceCullNoTexture( pContext, pv ))
        return 1;
#endif

    __Render_One_PointSprite(pContext, pv[0]);
    __Render_One_PointSprite(pContext, pv[1]);
    __Render_One_PointSprite(pContext, pv[2]);    

    return 1;    
} // __ProcessTri_3Vtx_PointSprite

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_PointsSprite_DWCount
// 
// Render D3DDP2OP_POINTS points sprites
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_PointsSprite_DWCount( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[1];
    WORD wVStart;
    DWORD j;

    DBG_ENTRY(_D3D_R3_DP2_PointsSprite_DWCount);      

    wVStart = ((D3DHAL_DP2POINTS*)lpPrim)->wVStart;
    lpVertices = LP_FVF_VERTEX(lpVertices, wVStart);

    // Check first & last vertex
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, wVStart);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, wVStart + dwPrimCount - 1);

    pContext->dwProvokingVertex = 0;
    
    for( j = 0; j < dwPrimCount; j++ )
    {
        pv[0] = LP_FVF_VERTEX(lpVertices, j);

        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    

        __Render_One_PointSprite(pContext, pv[0]);           
    }

    DBG_EXIT(_D3D_R3_DP2_PointsSprite_DWCount,0);       


} // _D3D_R3_DP2_PointsSprite_DWCount

#endif // DX8_POINTSPRITES

#if DX8_MULTSTREAMS


// Macro to render a single triangle depending on the current Fillmode. 
// Notice that for proper line rendering we require one more element in pv (4)
#define RENDER_ONE_TRIANGLE_CYCLE(pContext, dwFillMode, pv, bVtxInvalid, vtx_a)\
{                                                                            \
    if (dwFillMode == D3DFILL_SOLID)                                         \
    {                                                                        \
        if( bVtxInvalid )                                                    \
            bVtxInvalid = (*pContext->pRendTri_3V)( pContext, pv, ALL_SIDES);    \
        else                                                                 \
            bVtxInvalid = (*pContext->pRendTri_1V)( pContext, pv, vtx_a );          \
    }                                                                        \
    else if (dwFillMode == D3DFILL_WIREFRAME)                                \
    {                                                                        \
        if(!__BackfaceCullNoTexture( pContext, pv ))                         \
        {                                                                    \
            pv[3] = pv[0];                                                   \
            __ProcessLine(pContext, &pv[0], pv[pContext->dwProvokingVertex]);\
            __ProcessLine(pContext, &pv[1], pv[pContext->dwProvokingVertex]);\
            __ProcessLine(pContext, &pv[2], pv[pContext->dwProvokingVertex]);\
        }                                                                    \
    }                                                                        \
    else                                                                     \
/*#if DX8_POINTSPRITES*/                                                     \
    if(IS_POINTSPRITE_ACTIVE(pContext))                                      \
    {                                                                        \
        __ProcessTri_3Vtx_PointSprite( pContext, pv, ALL_SIDES );        \
    }                                                                        \
    else                                                                     \
/*#endif*/                                                                   \
    {                                                                        \
        if(!__BackfaceCullNoTexture( pContext, pv ))                         \
        {                                                                    \
            __ProcessPoints( pContext, &pv[0], 1);                           \
            __ProcessPoints( pContext, &pv[1], 1);                           \
            __ProcessPoints( pContext, &pv[2], 1);                           \
        }                                                                    \
    }                                                                        \
}

#define INIT_RENDER_ONE_TRIANGLE(pContext, dwFillMode, pv,VtxInvalid) \
{                                                       \
    int vtx_a_local = 0;                                \
    VtxInvalid= 1;                                      \
    RENDER_ONE_TRIANGLE_CYCLE(pContext,                 \
                              dwFillMode,               \
                              pv,                       \
                              VtxInvalid,               \
                              vtx_a_local);             \
}

#define RENDER_ONE_TRIANGLE(pContext, dwFillMode, pv)   \
{                                                       \
    int vtx_a = 0, VtxInvalid= 1;                       \
    RENDER_ONE_TRIANGLE_CYCLE(pContext,                 \
                              dwFillMode,               \
                              pv,                       \
                              VtxInvalid,               \
                              vtx_a);                   \
}

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedLineList_MS_16IND
// 
// Render D3DDP2OP_INDEXEDLINELIST lines
// 16 bit index streams are assumed
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedLineList_MS_16IND( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    INT IdxOffset,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[2];
    WORD *pwIndx;
    DWORD dwIndex0, dwIndex1, i;

    DBG_ENTRY(_D3D_R3_DP2_IndexedLineList_MS_16IND);
    
    pwIndx = (WORD *)lpPrim;

    for( i = 0; i < dwPrimCount; i++ )
    {
        dwIndex0 = *pwIndx++;
        dwIndex1 = *pwIndx++;

        pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);

        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex0);        
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex1);  

        __ProcessLine( pContext, pv, pv[0]);
    }

    DBG_EXIT(_D3D_R3_DP2_IndexedLineList_MS_16IND,0);
    
} // _D3D_R3_DP2_IndexedLineList_MS_16IND



//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedLineStrip_MS_16IND
// 
// Render D3DDP2OP_INDEXEDLINESTRIP lines
// 16 bit index streams are assumed
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedLineStrip_MS_16IND( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    INT IdxOffset,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[2];
    DWORD dwIndex, i;
    WORD *pwIndx;

    DBG_ENTRY(_D3D_R3_DP2_IndexedLineStrip_MS_32IND);      

    pwIndx = (WORD *)lpPrim;
    
    dwIndex = *pwIndx++;
    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex);

    for( i = 0; i < dwPrimCount; i++ )
    {
        dwIndex = *pwIndx++;
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex);
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex);

        __ProcessLine(pContext, pv, pv[0]);

        pv[0] = pv[1];        
    }

    DBG_EXIT(_D3D_R3_DP2_IndexedLineStrip_MS_16IND,0);  
    
} // _D3D_R3_DP2_IndexedLineStrip_MS_16IND


//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedTriangleList_MS_16IND
// 
// Render D3DDP2OP_INDEXEDTRIANGLELIST triangles 
// 16 bit index streams are assumed
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedTriangleList_MS_16IND( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    INT IdxOffset,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex0, dwIndex1, dwIndex2, i;
    D3DTLVERTEX *pv[4];
    WORD *pwIndexData;
    DWORD dwFillMode = pContext->RenderStates[D3DRS_FILLMODE];    

    DBG_ENTRY(_D3D_R3_DP2_IndexedTriangleList_MS_16IND); 

    DISPDBG((DBGLVL,"pContext = 0x%x dwPrimCount=%d lpPrim=0x%x lpVertices=0x%x "
               "IdxOffset=%d dwVertexBufferLen=%d ",
               pContext,(DWORD)dwPrimCount,lpPrim,lpVertices,
               IdxOffset, dwVertexBufferLen));
               

    pwIndexData = (WORD *)lpPrim;

    pContext->dwProvokingVertex = 0;
    for( i = 0; i < dwPrimCount; i++ )
    {
        dwIndex0 = *pwIndexData++;
        dwIndex1 = *pwIndexData++;
        dwIndex2 = *pwIndexData++;

        pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
        pv[2] = LP_FVF_VERTEX(lpVertices, dwIndex2);

        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex0);        
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex1);  
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex2);  

        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    

        RENDER_ONE_TRIANGLE(pContext,dwFillMode,pv);    
    }

    DBG_EXIT(_D3D_R3_DP2_IndexedTriangleList_MS_16IND,0); 
    
} // _D3D_R3_DP2_IndexedTriangleList_MS_16IND


//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedTriangleStrip_MS_16IND
// 
// Render D3DDP2OP_INDEXEDTRIANGLESTRIP triangles 
// 16 bit index streams are assumed
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedTriangleStrip_MS_16IND( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    INT IdxOffset,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex0, dwIndex1, dwIndex2, i;
    D3DTLVERTEX *pv[4];
    int  vtx_a, vtx_b, bCulled;
    WORD *pwIndexData;
    DWORD dwFillMode = pContext->RenderStates[D3DRS_FILLMODE];  
    SAVE_CULLING_STATE(pContext);    

    DBG_ENTRY(_D3D_R3_DP2_IndexedTriangleStrip_MS_16IND); 

    pwIndexData = (WORD *)lpPrim;    

    dwIndex0 = *pwIndexData++;
    dwIndex1 = *pwIndexData++;
    dwIndex2 = *pwIndexData++;

    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
    pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
    pv[2] = LP_FVF_VERTEX(lpVertices, dwIndex2);

    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex0);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex1);    
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex2);    

    pContext->dwProvokingVertex = 0;
    pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    
    
    INIT_RENDER_ONE_TRIANGLE(pContext,dwFillMode,pv,bCulled); 
    lpPrim += sizeof(WORD);

    INIT_VERTEX_INDICES(pContext, vtx_a, vtx_b);

    for( i = 1; i < dwPrimCount; i++ )
    {
        FLIP_CCW_CW_CULLING(pContext);
        
        dwIndex2 = *pwIndexData++;
        pv[vtx_a] = LP_FVF_VERTEX(lpVertices, dwIndex2);

        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex2);            

        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    

        RENDER_ONE_TRIANGLE_CYCLE(pContext,
                                  dwFillMode,
                                  pv,
                                  bCulled,
                                  vtx_a); 
            
        CYCLE_VERTEX_INDICES(pContext, vtx_a, vtx_b);
    }

    RESTORE_CULLING_STATE(pContext);
    
    DBG_EXIT(_D3D_R3_DP2_IndexedTriangleStrip_MS_16IND,0); 
    
} // _D3D_R3_DP2_IndexedTriangleStrip_MS_16IND


//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedTriangleFan_MS_16IND
// 
// Render D3DDP2OP_INDEXEDTRIANGLEFAN triangles in  
// 16 bit index streams are assumed
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedTriangleFan_MS_16IND( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    INT IdxOffset,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex0, dwIndex1, dwIndex2, i;
    D3DTLVERTEX *pv[4];
    int  vtx, lastVtx, bCulled;
    WORD *pwIndexData;
    DWORD dwFillMode = pContext->RenderStates[D3DRS_FILLMODE];
    SAVE_CULLING_STATE(pContext);    

    DBG_ENTRY(_D3D_R3_DP2_IndexedTriangleFan_MS_16IND);     

    pwIndexData = (WORD *)lpPrim;
    
    dwIndex0 = *pwIndexData++;
    dwIndex1 = *pwIndexData++;
    dwIndex2 = *pwIndexData++;

    lastVtx = vtx = 2;
    
    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
    pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
    pv[2] = LP_FVF_VERTEX(lpVertices, dwIndex2);

    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex0);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex1);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex2);    

    pContext->dwProvokingVertex = 1;
    pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    
    
    INIT_RENDER_ONE_TRIANGLE(pContext,dwFillMode,pv,bCulled); 
    lpPrim += sizeof(WORD);

    for( i = 1; i < dwPrimCount; i++ )
    {
        // 2 -> 1, 1 -> 2

        vtx ^= 3;
        FLIP_CCW_CW_CULLING(pContext);
        
        dwIndex2 = *pwIndexData++;
        pv[vtx] = LP_FVF_VERTEX(lpVertices, dwIndex2);
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex2);         

        pContext->dwProvokingVertex = lastVtx;

        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    

        RENDER_ONE_TRIANGLE_CYCLE(pContext,
                                  dwFillMode,
                                  pv,
                                  bCulled,
                                  vtx);            

        lastVtx = vtx;

    }

    RESTORE_CULLING_STATE(pContext);
    
    DBG_EXIT(_D3D_R3_DP2_IndexedTriangleFan_MS_16IND,0);       
    
} // _D3D_R3_DP2_IndexedTriangleFan_MS_16IND


//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedLineList_MS_32IND
// 
// Render D3DDP2OP_INDEXEDLINELIST lines
// Indices come as 32-bit entities ( DX7 only uses 16-bit indices)
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedLineList_MS_32IND( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    INT IdxOffset,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[2];
    DWORD *pdwIndx, dwIndex0, dwIndex1, i;

    DBG_ENTRY(_D3D_R3_DP2_IndexedLineList_MS_32IND);
    
    pdwIndx = (DWORD *)lpPrim;

    for( i = 0; i < dwPrimCount; i++ )
    {
        dwIndex0 = *pdwIndx++;
        dwIndex1 = *pdwIndx++;

        pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);

        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex0);        
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex1);        

        __ProcessLine(pContext, pv, pv[0]);
    }

    DBG_EXIT(_D3D_R3_DP2_IndexedLineList_MS_32IND,0);
    
} // _D3D_R3_DP2_IndexedLineList_MS_32IND


//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedLineStrip_MS_32IND
// 
// Render D3DDP2OP_INDEXEDLINESTRIP lines
// Indices come as 32-bit entities ( DX7 only uses 16-bit indices)
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedLineStrip_MS_32IND( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    INT IdxOffset,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    D3DTLVERTEX *pv[2];
    DWORD dwIndex, *pdwIndx, i;

    DBG_ENTRY(_D3D_R3_DP2_IndexedLineStrip_MS_32IND);      

    pdwIndx = (DWORD *)lpPrim;

    dwIndex = *pdwIndx++;
    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex);

    for( i = 0; i < dwPrimCount; i++ )
    {
        dwIndex = *pdwIndx++;
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex);
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex);        

        __ProcessLine(pContext, pv, pv[0]);

        pv[0] = pv[1];
    }

    DBG_EXIT(_D3D_R3_DP2_IndexedLineStrip_MS_32IND,0);  
    
} // _D3D_R3_DP2_IndexedLineStrip_MS_32IND

//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedTriangleList_MS_32IND
// 
// Render D3DDP2OP_INDEXEDTRIANGLELIST triangles
// Indices come as 32-bit entities ( DX7 only uses 16-bit indices)
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedTriangleList_MS_32IND( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    INT IdxOffset,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex0, dwIndex1, dwIndex2, *pdwIndexData, i;
    D3DTLVERTEX *pv[4];
    DWORD dwFillMode = pContext->RenderStates[D3DRS_FILLMODE];    

    DBG_ENTRY(_D3D_R3_DP2_IndexedTriangleList_MS_32IND); 

    DISPDBG((DBGLVL,"pContext = 0x%x dwPrimCount=%d lpPrim=0x%x lpVertices=0x%x "
               "IdxOffset=%d dwVertexBufferLen=%d ",
               pContext,(DWORD)dwPrimCount,lpPrim,lpVertices,IdxOffset,
               dwVertexBufferLen));
               

    pdwIndexData = (DWORD *)lpPrim;

    pContext->dwProvokingVertex = 0;
    for( i = 0; i < dwPrimCount; i++ )
    {
        dwIndex0 = *pdwIndexData++;
        dwIndex1 = *pdwIndexData++;
        dwIndex2 = *pdwIndexData++;

        pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
        pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
        pv[2] = LP_FVF_VERTEX(lpVertices, dwIndex2);

        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex0);        
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex1);  
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex2);  

        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    

        RENDER_ONE_TRIANGLE(pContext,dwFillMode,pv);         
    }

    DBG_EXIT(_D3D_R3_DP2_IndexedTriangleList_MS_32IND,0); 
    
} // _D3D_R3_DP2_IndexedTriangleList_MS_32IND


//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedTriangleStrip_MS_32IND
// 
// Render D3DDP2OP_INDEXEDTRIANGLESTRIP triangles
// Indices come as 32-bit entities ( DX7 only uses 16-bit indices)
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedTriangleStrip_MS_32IND( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    INT IdxOffset,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex0, dwIndex1, dwIndex2, i, *pdwIndexData;
    D3DTLVERTEX *pv[4];
    int vtx_a, vtx_b, bCulled;
    DWORD dwFillMode = pContext->RenderStates[D3DRS_FILLMODE];   
    SAVE_CULLING_STATE(pContext);    

    DBG_ENTRY(_D3D_R3_DP2_IndexedTriangleStrip_MS_32IND); 

    pdwIndexData = (DWORD *)lpPrim;    

    dwIndex0 = *pdwIndexData++;
    dwIndex1 = *pdwIndexData++;
    dwIndex2 = *pdwIndexData++;

    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
    pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
    pv[2] = LP_FVF_VERTEX(lpVertices, dwIndex2);

    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex0);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex1);    
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex2);    

    pContext->dwProvokingVertex = 0;
    pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    
    
    INIT_RENDER_ONE_TRIANGLE(pContext,dwFillMode,pv,bCulled); 
    lpPrim += sizeof(WORD);

    INIT_VERTEX_INDICES(pContext, vtx_a, vtx_b);

    for( i = 1; i < dwPrimCount; i++ )
    {
        FLIP_CCW_CW_CULLING(pContext);
        
        dwIndex2 = *pdwIndexData++;
        pv[vtx_a] = LP_FVF_VERTEX(lpVertices, dwIndex2);

        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex2);            
        
        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    

        RENDER_ONE_TRIANGLE_CYCLE(pContext,
                                  dwFillMode,
                                  pv,
                                  bCulled,
                                  vtx_a);               
            
        CYCLE_VERTEX_INDICES(pContext, vtx_a, vtx_b);
    }

    RESTORE_CULLING_STATE(pContext);
    
    DBG_EXIT(_D3D_R3_DP2_IndexedTriangleStrip_MS_32IND,0); 
    
} // _D3D_R3_DP2_IndexedTriangleStrip_MS_32IND


//-----------------------------------------------------------------------------
//
// _D3D_R3_DP2_IndexedTriangleFan_MS_32IND
// 
// Render D3DDP2OP_INDEXEDTRIANGLEFAN triangles
// Indices come as 32-bit entities ( DX7 only uses 16-bit indices)
//
//-----------------------------------------------------------------------------
void
_D3D_R3_DP2_IndexedTriangleFan_MS_32IND( 
    P3_D3DCONTEXT *pContext,
    DWORD dwPrimCount, 
    LPBYTE lpPrim,
    LPD3DTLVERTEX lpVertices,
    INT IdxOffset,
    DWORD dwVertexBufferLen,
    BOOL *pbError)
{
    DWORD dwIndex0, dwIndex1, dwIndex2, i, *pdwIndexData;
    D3DTLVERTEX *pv[4];
    int  vtx, lastVtx, bCulled;
    DWORD dwFillMode = pContext->RenderStates[D3DRS_FILLMODE];    
    SAVE_CULLING_STATE(pContext);    

    DBG_ENTRY(_D3D_R3_DP2_IndexedTriangleFan_MS_32IND);     

    pdwIndexData = (DWORD *)lpPrim;
    
    dwIndex0 = *pdwIndexData++;
    dwIndex1 = *pdwIndexData++;
    dwIndex2 = *pdwIndexData++;

    lastVtx = vtx = 2;
    
    pv[0] = LP_FVF_VERTEX(lpVertices, dwIndex0);
    pv[1] = LP_FVF_VERTEX(lpVertices, dwIndex1);
    pv[2] = LP_FVF_VERTEX(lpVertices, dwIndex2);

    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex0);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex1);
    CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, IdxOffset + dwIndex2);    

    pContext->dwProvokingVertex = 1;
    pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    
    
    INIT_RENDER_ONE_TRIANGLE(pContext,dwFillMode,pv,bCulled); 
    lpPrim += sizeof(WORD);

    for( i = 1; i < dwPrimCount; i++ )
    {
        // 2 -> 1, 1 -> 2

        vtx ^= 3;
        FLIP_CCW_CW_CULLING(pContext);
        
        dwIndex2 = *pdwIndexData++;
        pv[vtx] = LP_FVF_VERTEX(lpVertices, dwIndex2);
        CHECK_DATABUF_LIMITS(pbError, dwVertexBufferLen, dwIndex2);         

        pContext->dwProvokingVertex = lastVtx;
        pContext->pProvokingVertex = pv[pContext->dwProvokingVertex];    

        RENDER_ONE_TRIANGLE_CYCLE(pContext,
                                  dwFillMode,
                                  pv,
                                  bCulled,
                                  vtx);   

        lastVtx = vtx;
    }

    RESTORE_CULLING_STATE(pContext);
    
    DBG_EXIT(_D3D_R3_DP2_IndexedTriangleFan_MS_32IND,0);       
    
} // _D3D_R3_DP2_IndexedTriangleFan_MS_32IND

#endif // DX8_MULTSTREAMS

//-----------------------------------------------------------------------------
//
// _D3D_R3_PickVertexProcessor
//
// Pick appropriate triangle rendering functions based on texturing
//
//-----------------------------------------------------------------------------
void
_D3D_R3_PickVertexProcessor( 
    P3_D3DCONTEXT *pContext )
{
    DWORD Flags = pContext->Flags;

    DBG_ENTRY(_D3D_R3_PickVertexProcessor); 

    if (pContext->RenderStates[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME)
    {
        // Wireframe mode renderers
        pContext->pRendTri_1V    = __ProcessTri_1Vtx_Wire;  
        pContext->pRendTri_3V = __ProcessTri_3Vtx_Wire;    
    }
    else if (pContext->RenderStates[D3DRENDERSTATE_FILLMODE] == D3DFILL_POINT)
    {
#if DX8_DDI
        if(IS_POINTSPRITE_ACTIVE(pContext))
        {
            // Point sprite mode renderers    
            pContext->pRendTri_1V    = __ProcessTri_1Vtx_PointSprite;  
            pContext->pRendTri_3V = __ProcessTri_3Vtx_PointSprite;      
        }
        else
#endif
        {
            // Point mode renderers    
            pContext->pRendTri_1V    = __ProcessTri_1Vtx_Point;  
            pContext->pRendTri_3V = __ProcessTri_3Vtx_Point;      
        }
    }
    else
#if !defined(_WIN64)    
    // We avoid this path in IA64 as something is wrongly fed into the chip
    if( ( Flags & SURFACE_PERSPCORRECT ) && 
              ( Flags & SURFACE_GOURAUD )      && 
              (pContext->bTex0Valid)           && 
              (!pContext->bTex1Valid)           )
    {
        // Solid mode renderes for single textured-gouraud shaded-persp corr 
        if(( pContext->RenderStates[D3DRENDERSTATE_WRAP0] )
                        || ( pContext->RenderStates[D3DRENDERSTATE_WRAP1] ))
        {
            pContext->pRendTri_1V    = __ProcessTri_1Vtx_Generic;
            pContext->pRendTri_3V = __ProcessTri_3Vtx_Generic;
        }
        else
        {
            pContext->pRendTri_1V    = __ProcessTri_1Vtx_PerspSingleTexGouraud;
            pContext->pRendTri_3V = __ProcessTri_3Vtx_PerspSingleTexGouraud;
        }
    }
    else
#endif !defined(_WIN64)    
    {
        // Solid mode renderers for textured triangles    
        if( pContext->bTex0Valid || pContext->bTex1Valid )
        {
            pContext->pRendTri_1V    = __ProcessTri_1Vtx_Generic;
            pContext->pRendTri_3V = __ProcessTri_3Vtx_Generic;
        }
        else
        {
        // Solid mode renderers for non-textured triangles           
            pContext->pRendTri_1V    = __ProcessTri_1Vtx_NoTexture;
            pContext->pRendTri_3V = __ProcessTri_3Vtx_NoTexture;
        }
    }


    


    DBG_EXIT(_D3D_R3_PickVertexProcessor,0); 
    
} // _D3D_R3_PickVertexProcessor
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dstrct.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dstrct.h
*
* Content: Internal D3D structure management headers and macros
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef __D3DSTRCT_H
#define __D3DSTRCT_H

//-----------------------------------------------------------------------------
//
// Array functions and structures
//
//-----------------------------------------------------------------------------

typedef void (*PA_DestroyCB)(struct tagPointerArray* pTable, 
                             void* pData, 
                             void* pExtra);

typedef struct tagPointerArray
{
    ULONG_PTR* pPointers;
    DWORD dwNumPointers;
    PA_DestroyCB pfnDestroyCallback;
} PointerArray;

PointerArray* PA_CreateArray();
BOOL PA_DestroyArray(PointerArray* pArray, VOID* pExtra);
void* PA_GetEntry(PointerArray* pArray, DWORD dwNum);
BOOL PA_SetEntry(PointerArray* pArray, DWORD dwNum, void* pData);
void PA_SetDataDestroyCallback(PointerArray* pArray,
                               PA_DestroyCB DestroyCallback);

//-----------------------------------------------------------------------------
//
// Hashing functions and structures
//
//-----------------------------------------------------------------------------

#define HASH_SIZE 4096      // this many entries in the hash table

#define HT_HASH_OF(i)    ((i) & 0xFFF)

typedef struct tagHashSlot
{
    void* pData;
    ULONG_PTR dwHandle;

    struct tagHashSlot* pNext;
    struct tagHashSlot* pPrev;

} HashSlot;

typedef void (*DataDestroyCB)(struct tagHashTable* pTable, 
                              void* pData, 
                              void*pExtra);

typedef struct tagHashTable
{
    HashSlot* Slots[HASH_SIZE];
    DataDestroyCB pfnDestroyCallback;
} HashTable;

// Helper functions
static __inline HashSlot* HT_GetSlotFromHandle(HashTable* pTable, 
                                               ULONG_PTR dwHandle)
{
    HashSlot* pBase = NULL; 
    
    ASSERTDD(pTable != NULL,"ERROR: HashTable passed in is not valid!");

    pBase = pTable->Slots[HT_HASH_OF(dwHandle)];

    while (pBase != NULL)
    {
        if (pBase->dwHandle == dwHandle)
            return pBase;
        pBase = pBase->pNext;
    }

    return NULL;
} // HT_GetSlotFromHandle

static __inline void* HT_GetEntry(HashTable* pTable, ULONG_PTR dwHandle)
{
    HashSlot* pEntry = HT_GetSlotFromHandle(pTable, dwHandle);

    if (pEntry)
    {
        return pEntry->pData;
    }
    return NULL;
} /// HT_GetEntry


// Public interfaces
HashTable* HT_CreateHashTable();
void HT_ClearEntriesHashTable(HashTable* pHashTable, VOID* pExtra);
void HT_DestroyHashTable(HashTable* pHashTable, VOID* pExtra);
void HT_SetDataDestroyCallback(HashTable* pTable, 
                               DataDestroyCB DestroyCallback);
BOOL HT_SwapEntries(HashTable* pTable, DWORD dwHandle1, DWORD dwHandle2);
BOOL HT_AddEntry(HashTable* pTable, ULONG_PTR dwHandle, void* pData);
BOOL HT_RemoveEntry(HashTable* pTable, ULONG_PTR dwHandle, VOID* pExtra);

#endif // __D3DSTRCT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dtxman.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dtxman.h
*
* Content:  D3D Texture cache manager definitions and macros.
*
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights Reserved.
\*****************************************************************************/
#ifndef __D3DTEXMAN
#define __D3DTEXMAN

#if DX7_TEXMANAGEMENT

__inline ULONGLONG TextureCost(P3_SURF_INTERNAL* pTexture)
{
#ifdef _X86_
    ULONGLONG retval = 0;
    _asm
    {
        mov     ebx, pTexture;
        mov     eax, [ebx]P3_SURF_INTERNAL.m_dwPriority;
        mov     ecx, eax;
        shr     eax, 1;
        mov     DWORD PTR retval + 4, eax;
        shl     ecx, 31;
        mov     eax, [ebx]P3_SURF_INTERNAL.m_dwTicks;
        shr     eax, 1;
        or      eax, ecx;
        mov     DWORD PTR retval, eax;
    }
    return retval;
#else
    return ((ULONGLONG)pTexture->m_dwPriority << 31) + 
            ((ULONGLONG)(pTexture->m_dwTicks >> 1));
#endif
}

typedef struct _TextureHeap 
{
    DWORD   m_next;
    DWORD   m_size;
    P3_SURF_INTERNAL **m_data_p;
} TextureHeap, *PTextureHeap;

typedef struct _TextureCacheManager 
{    
    TextureHeap m_heap;
    unsigned int tcm_ticks;
#if DX7_TEXMANAGEMENT_STATS    
    D3DDEVINFO_TEXTUREMANAGER m_stats;  
#endif

}TextureCacheManager, *PTextureCacheManager;

//
// Texture Management function declarations
//

void __TM_TextureHeapHeapify(PTextureHeap,DWORD);
BOOL __TM_TextureHeapAddSurface(PTextureHeap,P3_SURF_INTERNAL *);
P3_SURF_INTERNAL* __TM_TextureHeapExtractMin(PTextureHeap);
P3_SURF_INTERNAL* __TM_TextureHeapExtractMax(PTextureHeap);
void __TM_TextureHeapDelSurface(PTextureHeap,DWORD);
void __TM_TextureHeapUpdate(PTextureHeap,DWORD,DWORD,DWORD); 
BOOL __TM_FreeTextures(P3_D3DCONTEXT* , DWORD);

HRESULT _D3D_TM_Ctx_Initialize(P3_D3DCONTEXT* pContext);
void _D3D_TM_Ctx_Destroy(P3_D3DCONTEXT* pContext);
void _D3D_TM_RemoveTexture(P3_THUNKEDDATA* pThisDisplay, P3_SURF_INTERNAL*);      
void _D3D_TM_RemoveDDSurface(P3_THUNKEDDATA* , LPDDRAWI_DDRAWSURFACE_LCL);
HRESULT _D3D_TM_AllocTexture(P3_D3DCONTEXT*,P3_SURF_INTERNAL*);
void _D3D_TM_EvictAllManagedTextures(P3_D3DCONTEXT*);
void _DD_TM_EvictAllManagedTextures(P3_THUNKEDDATA* pThisDisplay);
void _D3D_TM_TimeStampTexture(PTextureCacheManager,P3_SURF_INTERNAL*);
BOOL _D3D_TM_Preload_Tex_IntoVidMem(P3_D3DCONTEXT*, P3_SURF_INTERNAL*);
void _D3D_TM_MarkDDSurfaceAsDirty(P3_THUNKEDDATA*,LPDDRAWI_DDRAWSURFACE_LCL, BOOL);

void _D3D_TM_HW_FreeVidmemSurface(P3_THUNKEDDATA*,P3_SURF_INTERNAL*);
void _D3D_TM_HW_AllocVidmemSurface(P3_D3DCONTEXT*,P3_SURF_INTERNAL*);

//
// Macros to get surface offset and pointer
//

#if WNT_DDRAW

#define DDSURF_GETPOINTER(pSurfGbl, pThisDisplay)                       \
    (pSurfGbl->fpVidMem + (FLATPTR)pThisDisplay->ppdev->pjScreen)
#define D3DMIPLVL_GETPOINTER(pMipLevel, pThisDisplay)                   \
    (pMipLevel->fpVidMem + (FLATPTR)pThisDisplay->ppdev->pjScreen)
#define D3DSURF_GETPOINTER(pSurfInt, pThisDisplay)                      \
    (pSurfInt->fpVidMem + (FLATPTR)pThisDisplay->ppdev->pjScreen)
#define D3DTMMIPLVL_GETOFFSET(mipLevel, pThisDisplay)                   \
    (mipLevel.fpVidMemTM)

#else

#define DDSURF_GETPOINTER(pSurfGbl, pThisDisplay)                       \
    (pSurfGbl->fpVidMem)
#define D3DMIPLVL_GETPOINTER(pMipLevel, pThisDisplay)                   \
    (pMipLevel->fpVidMem)
#define D3DSURF_GETPOINTER(pSurfInt, pThisDisplay)                      \
    (pSurfInt->fpVidMem)
#define D3DTMMIPLVL_GETOFFSET(mipLevel, pThisDisplay)                   \
    (mipLevel.fpVidMemTM - pThisDisplay->dwScreenFlatAddr)

#endif // WNT_DDRAW


//
// Inline function definitions
//

__inline void _D3D_TM_InitSurfData(P3_SURF_INTERNAL* pD3DSurf,
                                   LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl) 
{
    pD3DSurf->m_dwBytes = pD3DSurf->wHeight * pD3DSurf->lPitch;
    pD3DSurf->m_bTMNeedUpdate = TRUE;
    pD3DSurf->dwCaps2= pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2;    
    pD3DSurf->m_dwTexLOD = 0;
}


#if DX7_TEXMANAGEMENT_STATS
__inline void __TM_STAT_Inc_TotSz(
    PTextureCacheManager pTextureCacheManager,
    P3_SURF_INTERNAL* pD3DSurf)
{
    ++pTextureCacheManager->m_stats.dwTotalManaged;
    pTextureCacheManager->m_stats.dwTotalBytes += pD3DSurf->m_dwBytes;
}

__inline void __TM_STAT_Inc_WrkSet(
    PTextureCacheManager pTextureCacheManager,
    P3_SURF_INTERNAL* pD3DSurf)
{
    ++pTextureCacheManager->m_stats.dwWorkingSet;
    pTextureCacheManager->m_stats.dwWorkingSetBytes += pD3DSurf->m_dwBytes;
}    

__inline void __TM_STAT_Dec_TotSz(
    PTextureCacheManager pTextureCacheManager,
    P3_SURF_INTERNAL* pD3DSurf)
{
    --pTextureCacheManager->m_stats.dwTotalManaged;
    pTextureCacheManager->m_stats.dwTotalBytes -= pD3DSurf->m_dwBytes;
}

__inline void __TM_STAT_Dec_WrkSet(
    PTextureCacheManager pTextureCacheManager,
    P3_SURF_INTERNAL* pD3DSurf)
{
    --pTextureCacheManager->m_stats.dwWorkingSet;
    pTextureCacheManager->m_stats.dwWorkingSetBytes -= pD3DSurf->m_dwBytes;
}

__inline void _D3D_TM_STAT_Inc_NumUsedTexInVid(P3_D3DCONTEXT *pContext,
                                               P3_SURF_INTERNAL* pD3DSurf)
{   
    if (pD3DSurf->m_dwHeapIndex)
    {
        ++pContext->pTextureManager->m_stats.dwNumUsedTexInVid;
    }
}

__inline void _D3D_TM_STAT_Inc_NumTexturesUsed(P3_D3DCONTEXT *pContext)
{
    ++pContext->pTextureManager->m_stats.dwNumTexturesUsed;
}

__inline void _D3D_TM_STAT_ResetCounters(P3_D3DCONTEXT *pContext)
{
    pContext->pTextureManager->m_stats.bThrashing = 0;
    pContext->pTextureManager->m_stats.dwNumEvicts = 0;
    pContext->pTextureManager->m_stats.dwNumVidCreates = 0;
    pContext->pTextureManager->m_stats.dwNumUsedTexInVid = 0;
    pContext->pTextureManager->m_stats.dwNumTexturesUsed = 0;
}

__inline void _D3D_TM_STAT_GetStats(P3_D3DCONTEXT *pContext,
                                    D3DDEVINFO_TEXTUREMANAGER* stats)
{
    memcpy(stats, 
           &pContext->pTextureManager->m_stats, 
           sizeof(D3DDEVINFO_TEXTUREMANAGER));
}
#else
// since we won't collect any stats, we just don't do anything
// inside these inlined functions
__inline void __TM_STAT_Inc_TotSz(
    PTextureCacheManager pTextureCacheManager,
    P3_SURF_INTERNAL* pD3DSurf)
{
    NULL;
}

__inline void __TM_STAT_Inc_WrkSet(
    PTextureCacheManager pTextureCacheManager,
    P3_SURF_INTERNAL* pD3DSurf)
{
    NULL;
}    

__inline void __TM_STAT_Dec_TotSz(
    PTextureCacheManager pTextureCacheManager,
    P3_SURF_INTERNAL* pD3DSurf)
{
    NULL;
}

__inline void __TM_STAT_Dec_WrkSet(
    PTextureCacheManager pTextureCacheManager,
    P3_SURF_INTERNAL* pD3DSurf)
{
    NULL;
}

__inline void _D3D_TM_STAT_Inc_NumUsedTexInVid(P3_D3DCONTEXT *pContext,
                                               P3_SURF_INTERNAL* pD3DSurf)
{   
    NULL;
}

__inline void _D3D_TM_STAT_Inc_NumTexturesUsed(P3_D3DCONTEXT *pContext)
{
    NULL;
}

__inline void _D3D_TM_STAT_ResetCounters(P3_D3DCONTEXT *pContext)
{
    NULL;
}

#endif // DX7_TEXMANAGEMENT_STATS


#endif // DX7_TEXMANAGEMENT

#endif // __D3DTEXMAN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dsurf.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dsurf.h
*
* Content: Surface management macros and structures
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#ifndef __D3DSURF_H
#define __D3DSURF_H

#define SURF_MAGIC_NO 0xd3d10100

#define CHECK_SURF_INTERNAL_AND_DDSURFACE_VALIDITY(ptr)   \
    (((ptr) != NULL) && ((ptr)->MagicNo == SURF_MAGIC_NO))

typedef enum tagSurfaceLocation
{
    VideoMemory = 0,
    SystemMemory,
    AGPMemory
} SurfaceLocation;

//********************************************************
// INFORMATION STORED FOR EACH D3D/DD SURFACE MIPMAP LEVEL
//********************************************************
typedef struct tagMIPTEXTURE {

    int wWidth;
    int wHeight;
    int logWidth;            
    int logHeight;                 // Widths and heights for this mip level

    DWORD dwOffsetFromMemoryBase;  // Offset(bytes) to the start of the texture
    FLATPTR fpVidMem;       
    DWORD lPitch;

    struct TextureMapWidth P3RXTextureMapWidth;  // Texture layout info
                                                 // for this mip level
#if DX7_TEXMANAGEMENT
    FLATPTR fpVidMemTM;            // Address of TM vidmem surface
#endif // DX7_TEXMANAGEMENT  

} MIPTEXTURE;

//*******************************************
// INFORMATION STORED FOR EACH D3D/DD SURFACE
//*******************************************
typedef struct _p3_SURF_INTERNAL {

    ULONG MagicNo ;          // Magic number to verify validity of pointer

    P3_SURF_FORMAT* pFormatSurface;    // A pointer to the surface format
    SurfaceLocation Location;// Is Texture in Vidmem?
    DWORD dwLUTOffset;       // The offset to the LUT in the Local Buffer 
                             // for this texture (if it's palletized).
    DWORD dwGARTDevLast;     // The last GART Dev base address that this 
                             // texture was used from

    DWORD wWidth;            // Width and Height of surface
    DWORD wHeight;           // (stored as DWORDS for IA64 compatibility)

    int logWidth;            // Logs of the width and height
    int logHeight;    
    float fArea;             // Area in floating point of the surface

    DDSCAPS ddsCapsInt;      // Store PDD_SURFACE_LOCAL data that we    
    DWORD dwFlagsInt;        //    we'll need later for hw setup
    DWORD dwCKLow, dwCKHigh; //    With the exception of D3DCreateSurfaceEx
    DDPIXELFORMAT pixFmt;    //    we can't/shouldn't at any other time
    DWORD dwPixelSize;       //    look inside these structures as they
    DWORD dwPixelPitch;      //    are DX RT property and may be destroyed
    DWORD dwPatchMode;       //    at any time without notifying the
    DWORD lPitch;            //    driver   
    DWORD dwBitDepth;        //
    ULONG lOffsetFromMemoryBase; 
    FLATPTR fpVidMem;        // Pointer to the surface memory

    BOOL bMipMap;            // Do we have mipmaps in this texture?   
    int iMipLevels;          // The # of mipmap levels stored    
    MIPTEXTURE MipLevels[P3_LOD_LEVELS];     // Mipmaps setting info

#if DX8_3DTEXTURES
    BOOL  b3DTexture;        // Is this a 3D texture ?   
    WORD  wDepth;            // depth of the 3D texture
    int   logDepth;          // log of the depth
    DWORD dwSlice;           // size of each 2D slice
    DWORD dwSliceInTexel;    // size of each 2D slice in Texel
    
#endif // DX8_3DTEXTURES

#if DX8_MULTISAMPLING
    DWORD dwSampling;        // Number of pixels for sampling.
#endif // DX8_MULTISAMPLING
  
#if DX7_TEXMANAGEMENT
    DWORD  dwCaps2;
    DWORD  m_dwBytes;
    DWORD  m_dwPriority;
    DWORD  m_dwTicks;
    DWORD  m_dwHeapIndex;
    BOOL   m_bTMNeedUpdate;
    DWORD  m_dwTexLOD;         // Level of detail we're required to load
#endif // DX7_TEXMANAGEMENT

#if DX7_PALETTETEXTURE       // Saved when D3DDP2OP_SETPALETTE is received
    DWORD dwPaletteHandle;   // Palette handle associated to this texture
    DWORD dwPaletteFlags;    // Palette flags regarding the assoc palette
#endif
   
} P3_SURF_INTERNAL;

#endif // __D3DSURF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\dcontext.h ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: dcontext.h
*
* Content: D3D context definition and other useful macros
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/
#ifndef __DCONTEXT_H
#define __DCONTEXT_H

#ifndef __SOFTCOPY
#include "softcopy.h"
#endif

#include "d3dsurf.h"
#include "d3dsset.h"

//-----------------------------------------------------------------------------
// Definitions for state overrides 
//-----------------------------------------------------------------------------
#define IS_OVERRIDE(type)       ((DWORD)(type) > D3DSTATE_OVERRIDE_BIAS)
#define GET_OVERRIDE(type)      ((DWORD)(type) - D3DSTATE_OVERRIDE_BIAS)

#define MAX_STATE       D3DSTATE_OVERRIDE_BIAS
#define DWORD_BITS      32
#define DWORD_SHIFT     5

typedef struct _D3DStateSet {
    DWORD               bits[MAX_STATE >> DWORD_SHIFT];
} D3DStateSet;

#define STATESET_MASK(set, state)       \
        (set).bits[((state) - 1) >> DWORD_SHIFT]

#define STATESET_BIT(state)     (1 << (((state) - 1) & (DWORD_BITS - 1)))

#define STATESET_ISSET(set, state) \
        STATESET_MASK(set, state) & STATESET_BIT(state)

#define STATESET_SET(set, state) \
        STATESET_MASK(set, state) |= STATESET_BIT(state)

#define STATESET_CLEAR(set, state) \
        STATESET_MASK(set, state) &= ~STATESET_BIT(state)

#define STATESET_INIT(set)      memset(&(set), 0, sizeof(set))

//-----------------------------------------------------------------------------
// Rendering flags , used to set/test the P3_D3DCONTEXT.Flags field
//
// SURFACE_ALPHASTIPPLE - Use alpha value to calculate a stipple pattern
// SURFACE_ENDPOINTENABLE - Enable last point on lines
// SURFACE_ALPHACHROMA - Is the alpha blending a chromakeying operation?
// SURFACE_MIPMAPPING - Is the filter mode setup for MipMapping?
// SURFACE_MODULATE - Are we emulating MODULATE (as apposed to MODULATEALPHA)?
// SURFACE_ANTIALIAS -  Are we antialiasing
//-----------------------------------------------------------------------------
#define SURFACE_GOURAUD         (1 << 0)
#define SURFACE_ZENABLE         (1 << 1)
#define SURFACE_SPECULAR        (1 << 2)
#define SURFACE_FOGENABLE       (1 << 3)
#define SURFACE_PERSPCORRECT    (1 << 4)
#define SURFACE_TEXTURING       (1 << 5)
#define SURFACE_ALPHAENABLE     (1 << 6)
#define SURFACE_MONO            (1 << 7)
#define SURFACE_ALPHASTIPPLE    (1 << 10)
#define SURFACE_ZWRITEENABLE    (1 << 11)
#define SURFACE_ENDPOINTENABLE  (1 << 12)
#define SURFACE_ALPHACHROMA     (1 << 13)
#define SURFACE_MIPMAPPING      (1 << 14)
#define SURFACE_MODULATE        (1 << 15)
#define SURFACE_ANTIALIAS       (1 << 16)

//-----------------------------------------------------------------------------
// Field values for P3_D3DCONTEXT.MagicNo field to signal its validity
#define RC_MAGIC_DISABLE 0xd3d00000
#define RC_MAGIC_NO 0xd3d00100

#define CHECK_D3DCONTEXT_VALIDITY(ptr)          \
    ( ((ptr) != NULL) && ((ptr)->MagicNo == RC_MAGIC_NO) )

//-----------------------------------------------------------------------------
// Renderer dirty flags definitions. 
//
// They help us keep track what state needs to be refreshed in the hw
//-----------------------------------------------------------------------------
#define CONTEXT_DIRTY_ALPHABLEND        (1 << 1)
#define CONTEXT_DIRTY_ZBUFFER           (1 << 2)
#define CONTEXT_DIRTY_TEXTURE           (1 << 3)
#define CONTEXT_DIRTY_RENDER_OFFSETS    (1 << 4)
#define CONTEXT_DIRTY_TEXTURESTAGEBLEND (1 << 5)
#define CONTEXT_DIRTY_ALPHATEST         (1 << 6)
#define CONTEXT_DIRTY_FOG               (1 << 7)
#define CONTEXT_DIRTY_STENCIL           (1 << 8)
#define CONTEXT_DIRTY_WBUFFER           (1 << 9)
#define CONTEXT_DIRTY_VIEWPORT          (1 << 10)
#define CONTEXT_DIRTY_PIPELINEORDER     (1 << 11)
#define CONTEXT_DIRTY_OPTIMIZE_ALPHA    (1 << 12)
#define CONTEXT_DIRTY_GAMMA             (1 << 31)
#define CONTEXT_DIRTY_EVERYTHING        (0xffffffff)

// Gamma state flags go into the dwDirtyGammaFlags field
#define CONTEXT_DIRTY_GAMMA_STATE               (1 << 0)
#define CONTEXT_DIRTY_GAMMA_MODELVIEW_MATRIX    (1 << 1)
#define CONTEXT_DIRTY_GAMMA_PROJECTION_MATRIX   (1 << 2)
#define CONTEXT_DIRTY_GAMMA_MATERIAL            (1 << 3)
// * Bits 16 + are for light dirty bits *
#define CONTEXT_DIRTY_GAMMA_EVERYTHING          (0xffffffff)


#define DIRTY_ALPHABLEND(pContext)                              \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_ALPHABLEND
    
#define DIRTY_ALPHATEST(pContext)                               \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_ALPHATEST

#define DIRTY_OPTIMIZE_ALPHA(pContext)                          \
do                                                              \
{                                                               \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_OPTIMIZE_ALPHA |    \
                                CONTEXT_DIRTY_ALPHATEST;        \
} while(0)

#define DIRTY_PIPELINEORDER(pContext)                           \
do                                                              \
{                                                               \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_PIPELINEORDER;      \
} while(0)

#define DIRTY_TEXTURE(pContext)                                 \
do                                                              \
{                                                               \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_TEXTURE;            \
    pContext->pCurrentTexture[TEXSTAGE_0] = NULL;               \
    pContext->pCurrentTexture[TEXSTAGE_1] = NULL;               \
} while (0)

#define DIRTY_ZBUFFER(pContext)                                 \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_ZBUFFER

#define DIRTY_RENDER_OFFSETS(pContext)                          \
do                                                              \
{                                                               \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_RENDER_OFFSETS;     \
} while (0)

#define DIRTY_VIEWPORT(pContext)                                \
do                                                              \
{                                                               \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_VIEWPORT;           \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_GAMMA;              \
} while(0)

#define DIRTY_TEXTURESTAGEBLEND(pContext)                       \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_TEXTURESTAGEBLEND
    
#define DIRTY_FOG(pContext)                                     \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_FOG
    
#define DIRTY_STENCIL(pContext)                                 \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_STENCIL
    
#define DIRTY_WBUFFER(pContext)                                 \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_WBUFFER

#define DIRTY_GAMMA_STATE                                               \
do                                                                      \
{                                                                       \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_GAMMA;                      \
    pContext->dwDirtyGammaFlags |= CONTEXT_DIRTY_GAMMA_STATE;           \
} while(0)

#define DIRTY_MODELVIEW                                                     \
do                                                                          \
{                                                                           \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_GAMMA;                          \
    pContext->dwDirtyGammaFlags |= CONTEXT_DIRTY_GAMMA_MODELVIEW_MATRIX;    \
} while(0)

#define DIRTY_PROJECTION                                                    \
do                                                                          \
{                                                                           \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_GAMMA;                          \
    pContext->dwDirtyGammaFlags |= CONTEXT_DIRTY_GAMMA_PROJECTION_MATRIX;   \
} while(0)

#define DIRTY_MATERIAL                                                  \
do                                                                      \
{                                                                       \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_GAMMA;                      \
    pContext->dwDirtyGammaFlags |= CONTEXT_DIRTY_GAMMA_MATERIAL;        \
} while(0)

#define DIRTY_LIGHT(pContext, a)                                        \
do                                                                      \
{                                                                       \
    pContext->dwDirtyFlags |= CONTEXT_DIRTY_GAMMA;                      \
    pContext->dwDirtyGammaFlags |= (1 << (16 + (a)));                   \
} while(0)

#define DIRTY_EVERYTHING(pContext)                                      \
do                                                                      \
{                                                                       \
    pContext->dwDirtyFlags = CONTEXT_DIRTY_EVERYTHING;                  \
} while(0)

//-----------------------------------------------------------------------------
//
// Texture Stage helper definitions
//
//-----------------------------------------------------------------------------
typedef struct tagTexStageState
{
    union
    {
        DWORD   m_dwVal[D3DTSS_MAX]; // state array (unsigned)
        FLOAT   m_fVal[D3DTSS_MAX];  // state array (float)
    };
} TexStageState;

typedef enum
{
    TEXSTAGE_0 = 0,
    TEXSTAGE_1 = 1,
    TEXSTAGE_2 = 2,
    TEXSTAGE_3 = 3,
    TEXSTAGE_4 = 4,
    TEXSTAGE_5 = 5,
    TEXSTAGE_6 = 6,
    TEXSTAGE_7 = 7,
    TEXSTAGE_8 = 8,
    TEXSTAGE_9 = 9
};

//-----------------------------------------------------------------------------
#define LUT_ENTRIES 256

//-----------------------------------------------------------------------------
// Possible ValidateDevice-type errors. Some of these match possible VD()
// returns, others don't (yet). Some of these are also non-fatal, and can
// be approximated. The behaviour of these depends on the current display
// mode of the driver.

// This flag is set if the error is fatal, and no sensible alternative
// could be done. If this flag is not set, the rendering can be done
// with a fair degree of fidelity, but not exactly what was requested.
//-----------------------------------------------------------------------------
#define BLEND_STATUS_FATAL_FLAG 0x10000

// These are ordered in rough severity order, most severe last.
typedef enum
{
    BS_OK = 0,

    // Non-fatal errors.
    BS_INVALID_FILTER,                      // Filter can't be done in this mode (e.g. trilinear with dual-texture).
    BS_PHONG_SHADING,                       // We can do gouraud instead.

    // Fatal errors.
    BSF_BASE = BLEND_STATUS_FATAL_FLAG,     // Not actually a real error value.

    BSF_UNSUPPORTED_FILTER,                 // Filter not supported at all (e.g. cubic)
    BSF_TEXTURE_NOT_POW2,                   // Using tile or wrap mode with a non-power-of-two texture dimension.
    BSF_TOO_MANY_PALETTES,                  // More than one palette used at a time.
    BSF_CANT_USE_ALPHA_ARG_HERE,            // Some units can do this, but not in this stage.
    BSF_CANT_USE_ALPHA_OP_HERE,             // Some units can do this, but not in this stage.
    BSF_CANT_USE_COLOR_ARG_HERE,            // Some units can do this, but not in this stage.
    BSF_CANT_USE_COLOR_OP_HERE,             // Some units can do this, but not in this stage.
    BSF_INVALID_TEXTURE,                    // Invalid or NULL texture.
    BSF_UNSUPPORTED_ALPHA_ARG,
    BSF_UNSUPPORTED_ALPHA_OP,
    BSF_UNSUPPORTED_COLOR_ARG,
    BSF_UNSUPPORTED_COLOR_OP,
    BSF_UNSUPPORTED_ALPHA_BLEND,
    BSF_UNSUPPORTED_STATE,                  // A render state value that we know, but don't support (and not one of the specific ones above).
    BSF_TOO_MANY_TEXTURES,
    BSF_TOO_MANY_BLEND_STAGES,
    BSF_UNDEFINED_FILTER,
    BSF_UNDEFINED_ALPHA_ARG,
    BSF_UNDEFINED_ALPHA_OP,
    BSF_UNDEFINED_COLOR_ARG,
    BSF_UNDEFINED_COLOR_OP,
    BSF_UNDEFINED_ALPHA_BLEND,
    BSF_UNDEFINED_STATE,                    // A render state value that we've never heard of (can happen via extensions that we don't support).

    // Always last.
    BSF_UNINITIALISED                       // Haven't done any validation setup yet!

} D3D_BLEND_STATUS;

// Useful macro for setting errors.
#if DBG
#define SET_BLEND_ERROR(pContext,errnum)                                                                     \
do                                                          \
{                                                           \
    if ( pContext->eChipBlendStatus < (errnum) )            \
    {                                                       \
        pContext->eChipBlendStatus = (errnum);              \
    }                                                       \
    DISPDBG(( WRNLVL, "azn SET_BLEND_ERROR: Error" #errnum ));   \
} while (FALSE)
#else
#define SET_BLEND_ERROR(pContext,errnum)                          \
            if ( pContext->eChipBlendStatus < (errnum) ) \
                pContext->eChipBlendStatus = (errnum)

#endif // DBG

#define RESET_BLEND_ERROR(pContext) pContext->eChipBlendStatus = BS_OK
#define GET_BLEND_ERROR(pContext) (pContext->eChipBlendStatus)


//-----------------------------------------------------------------------------
// FVF (Flexible Vertex Format) Support declarations
//-----------------------------------------------------------------------------
typedef struct _FVFOFFSETS
{      
    DWORD dwColOffset;
    DWORD dwSpcOffset;
    DWORD dwTexOffset[D3DHAL_TSS_MAXSTAGES];      //offset for current texture#i
    DWORD dwTexCoordOffset[D3DHAL_TSS_MAXSTAGES]; //offset into each tex coord
    DWORD dwNormalOffset;
    DWORD dwNonTexStride;
    DWORD dwStride;
    DWORD dwStrideHostInline;
    DWORD dwVertexValid;
    DWORD dwVertexValidHostInline;
    DWORD vFmat;
    DWORD vFmatHostInline;
    DWORD dwTexCount;
#if DX8_POINTSPRITES
    DWORD dwPntSizeOffset;
#endif // DX8_POINTSPRITES    

} FVFOFFSETS , *LPFVFOFFSETS;

#if DX8_POINTSPRITES

#define P3_MAX_POINTSPRITE_SIZE 64.0f

// Macro to determine if poinsprites are in order or just normal points
#define IS_POINTSPRITE_ACTIVE(pContext)   \
 ( (pContext->PntSprite.bEnabled)    ||  \
   (pContext->PntSprite.fSize != 1.0f)     ||  \
   (pContext->FVFData.dwPntSizeOffset) )

#endif // DX8_POINTSPRITES    

typedef struct _FVFTEXCOORDS{
    D3DVALUE tu;
    D3DVALUE tv;
#if DX8_3DTEXTURES
    D3DVALUE tw;
#endif // DX8_3DTEXTURES
} FVFTEXCOORDS, *LPFVFTEXCOORDS;

typedef struct _FVFCOLOR {
    D3DCOLOR color;
} FVFCOLOR, *LPFVFCOLOR;

typedef struct _FVFSPECULAR {
    D3DCOLOR specular;
} FVFSPECULAR, *LPFVFSPECULAR;

typedef struct _FVFXYZ {
    float x;
    float y;
    float z;
    float rhw;
} FVFXYZRHW, *LPFVFXYZRHW;

typedef struct _FVFNORMAL {
    float nx;
    float ny;
    float nz;
} FVFNORMAL, *LPFVFNORMAL;

typedef struct _FVFPSIZE{
    D3DVALUE psize;
} FVFPSIZE, *LPFVFPSIZE;

extern const FVFCOLOR gc_FVFColorDefault;
extern const FVFSPECULAR gc_FVFSpecDefault;
extern const FVFTEXCOORDS gc_FVFTexCoordDefault;

#define OFFSET_OFF(type, mem) ((DWORD)((char*)&((type *)0)->mem - (char*)(type*)0))

//  If we are asked to pick a texture coordinate (indexed by 
//  D3DTSS_TEXCOORDINDEX in the TSS) which the incoming vertex data doesn't 
//  have, then we should assume 0,0 as default values for it.
#define FVFTEX(lpVtx, num)                                  \
        (pContext->FVFData.dwTexOffset[(num)]?              \
          ((LPFVFTEXCOORDS)((LPBYTE)(lpVtx) +               \
                pContext->FVFData.dwTexOffset[(num)]))      \
          :&gc_FVFTexCoordDefault )

// Make sure FVFCOLOR and FVFSPEC pick up default values if 
// the components are not present in the FVF vertex data
#define FVFCOLOR(lpVtx)                                                     \
         (pContext->FVFData.dwColOffset?                                    \
            ((LPFVFCOLOR)((LPBYTE)(lpVtx) + pContext->FVFData.dwColOffset)) \
            :&gc_FVFColorDefault)
#define FVFSPEC(lpVtx)                                                          \
       (pContext->FVFData.dwSpcOffset?                                          \
             ((LPFVFSPECULAR)((LPBYTE)(lpVtx) + pContext->FVFData.dwSpcOffset)) \
            :&gc_FVFSpecDefault )
            
#define FVFXYZRHW(lpVtx)   ((LPFVFXYZRHW)((LPBYTE)(lpVtx)))
#define FVFNORMAL(lpVtx)   ((LPFVFNORMAL)((LPBYTE)(lpVtx) + pContext->FVFData.dwNormalOffset))

#if DX8_POINTSPRITES
#define FVFPSIZE( lpVtx)   ((LPFVFPSIZE)((LPBYTE)(lpVtx) + pContext->FVFData.dwPntSizeOffset))
#endif // DX8_POINTSPRITES


#if DX7_TEXMANAGEMENT
// Declaration for compiling purpouses
typedef struct _TextureCacheManager *PTextureCacheManager;
#endif // DX7_TEXMANAGEMENT

//-----------------------------------------------------------------------------
//
// Basic renderers defined in d3dprim.c . 
// We have a function pointer to them in P3_D3DCONTEXT
//
//-----------------------------------------------------------------------------
typedef struct _p3_d3dcontext P3_D3DCONTEXT; 

typedef int PROC_1_VERT( P3_D3DCONTEXT *pContext, 
                         D3DTLVERTEX *pv[], 
                         int vtx );
                         
typedef int PROC_3_VERTS( P3_D3DCONTEXT *pContext, 
                          D3DTLVERTEX *pv[],
                          int edgeflags );

//-----------------------------------------------------------------------------
//
// Definition of the P3_D3DCONTEXT structure .
//
//-----------------------------------------------------------------------------

typedef struct _p3_d3dcontext 
{
    //***********************
    // Structure "header"
    //***********************

    unsigned long MagicNo ;    // Magic number to verify validity of pointer

    P3_D3DCONTEXT* pSelf;     // Ptr to self (useful if we do some realignment)

    DWORD dwContextHandle;    // The handle passed back to D3D

    ULONG_PTR dwDXInterface;  // Which DX interface (DX8,DX7,DX6,DX5,DX3) is
                              // creating this context.

    //******************************************************************
    // Global DD and driver context in which this D3D context is running
    //******************************************************************
    P3_THUNKEDDATA*     pThisDisplay;     // The card we are running on.

    LPDDRAWI_DIRECTDRAW_LCL pDDLcl;    // D3D Surfaces (created through    
                                       // D3DCreateSurfaceEx) will be
                                       // associated through this pDDLcl
    LPDDRAWI_DIRECTDRAW_GBL pDDGbl;    // A pointer to the DirectDraw global
                                       // object associated with this context
                                       
    //***********************************************
    // Stored render target and z buffer surface info
    //***********************************************    

    P3_SURF_INTERNAL*   pSurfRenderInt;   // render target
    P3_SURF_INTERNAL*   pSurfZBufferInt;  // depth buffer
    DWORD PixelOffset;       // Offset in videomemory in pixels to start 
    DWORD ZPixelOffset;      // of buffers

    DWORD ModeChangeCount;   // Keeps track of rendertarget flips

    //************************
    // For debugging purpouses
    //************************
    DWORD OwningProcess;    // Process Id
    BOOL bTexDisabled;      // Is texturing enabled ?
    DWORD BPP;              // Bytes per pixel of primary

#if DX7_PALETTETEXTURE
    //**********************************************
    // Palette array associated to this D3D context
    //**********************************************    
    PointerArray* pPalettePointerArray;     // An array of palette pointers 
                                            // for use in this context
#endif

    //**********************************************
    // Surfaces array associated to this D3D context
    //**********************************************    
    PointerArray* pTexturePointerArray;     // An array of texture pointers 
                                            // for use in this context

    //**************************************************************
    // Hardware setup and transport information for this D3D context
    //**************************************************************

    P3_SOFTWARECOPY SoftCopyGlint;  // Software copy of registers for Permedia3    
    BOOL                b3D_FIFOS;  // This context using FIFO's?

    DWORD dwDirtyFlags;       // Hw state which stills needs update from D3D RS
    DWORD dwDirtyGammaFlags;  //  idem for TnL  

    DWORD RenderCommand;      // Rendering command to be issued to hw

    float XBias;              // For biasing coordinates
    float YBias;

    //************************************************
    // Triangle hw rendering function pointers
    //************************************************
    PROC_1_VERT  *pRendTri_1V;
    PROC_3_VERTS *pRendTri_3V;

    //************************************************
    // Context stored D3D states (render,TSS,TnL,etc.)
    //************************************************
    union
    {
        DWORD RenderStates[D3DHAL_MAX_RSTATES];
        float fRenderStates[D3DHAL_MAX_RSTATES];
    };
    
    TexStageState TextureStageState[D3DHAL_TSS_MAXSTAGES];    

    D3DStateSet overrides;     // To overide renderstates in legacy DX3 apps

    D3DHAL_DP2VIEWPORTINFO ViewportInfo; // Structures to store the viewport                                             
    D3DHAL_DP2ZRANGE ZRange;             // settings. They come into the HAL 
                                         // in two seperate OP codes.
    D3DHAL_DP2WINFO WBufferInfo;         // Structure to store w-buffering setup
    D3DMATERIAL7 Material;

    //********************************************
    // Command and Vertex buffer related state 
    // (including DX8 multistreaming data)
    //********************************************
    LPDWORD   lpVertices;
    DWORD     dwVertexType;

#if DX8_DDI
    LPDWORD lpIndices;
    DWORD   dwIndicesStride;
    DWORD   dwVerticesStride;
    DWORD   dwNumVertices;
    DWORD   dwVBSizeInBytes;
#endif // DX8_DDI    

    FVFOFFSETS FVFData;

    //*****************************************************
    // Internal context state for primitives rendering
    //*****************************************************

    ULONG Flags;

    DWORD dwP3HostinTriLookup;      // Store mix of states to select an 
                                    // appropriate rendering function
    DWORD dwProvokingVertex;    // Simplifies the Delta renderers 
                                // to have this be global
    D3DTLVERTEX *pProvokingVertex;

    DWORD   CullAndMask;
    DWORD   CullXorMask;  

    //*****************************************************
    // Internal context state kept TSS texturing
    //       (Chip <-> D3D texture stage management)
    //*****************************************************
    
    // Pointer to the current texture for MipMapping
    P3_SURF_INTERNAL* pCurrentTexture[D3DHAL_TSS_MAXSTAGES];     

    D3D_BLEND_STATUS eChipBlendStatus;    // Is the current D3D blend valid?
    
    BOOL bTextureValid;     // Are textures valid for rendering?
    BOOL bTex0Valid;
    BOOL bTex1Valid;    
    BOOL bCanChromaKey;

    int iChipStage[4];   // iChipStage[n] = x means that stage n on the chip
                         // (0,1 = texcomp0,1, 2=texapp, 3=placeholder) is 
                         // in D3D stage x.

    // iTexStage[n] = x means that texture n on the chip is "defined"
    // in D3D stage x, i.e. filter mode, FVF coord set number, etc.
    // A single texture may be used in multiple D3D stages, so x may
    // not be the only valid value. However, all instances of the texture
    // must be the same of course. The assignment code checks that they are.
    // A value of -1 means the texture is unused.
    int iTexStage[D3DHAL_TSS_MAXSTAGES];

    // iStageTex[n] = x means that the texture used by D3D stage n is
    // chip texture x. It therefore follows that iStageTex[iTexStage[n]] == n.
    // The reverse (iTexStage[iStageTex[n]] == n) need NOT be true, because
    // of course each chip texture can be used by multiple D3D stages.
    // -1 means that the stage does not use a texture (NULL handle or 
    // invalid texture).
    int iStageTex[D3DTSS_MAX];


    BOOL bBumpmapEnabled;     // TRUE if the current alpha in chipstage1 
                              // should be the bumpmap, instead of the 
                              // diffuse (normal default).

    BOOL bBumpmapInverted;     // TRUE if the bumpmapping is the inverse 
                               // of the normal a0-a1+0.5, i.e. a1-a0+0.5

    BOOL bStage0DotProduct;    // TRUE if chip stage 0 is using DOTPRODUCT 
                               // (can't use DOTPROD in stage 1).
                               
    BOOL bAlphaBlendMustDoubleSourceColour;  // TRUE if the source colour 
                                             // needs to be *2 in the 
                                             // alpha-blend unit.

    //*****************************************************
    // Internal context state kept for various D3D features
    //*****************************************************

    BOOL bKeptStipple;          // D3DRENDERSTATE_STIPPLEDALPHA
    DWORD CurrentStipple[32];
    float MipMapLODBias[2];     // D3DTSS_MIPMAPLODBIAS

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
    // For antialiasing
    DWORD dwAliasPixelOffset;
    DWORD dwAliasBackBuffer;
    DWORD dwAliasZPixelOffset;
    DWORD dwAliasZBuffer;
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS

#if DX7_D3DSTATEBLOCKS
    BOOL bStateRecMode;            // Toggle for executing or recording states
    P3StateSetRec   *pCurrSS;      // Ptr to SS currently being recorded
    P3StateSetRec   **pIndexTableSS; // Pointer to table of indexes
    DWORD           dwMaxSSIndex;    // size of table of indexes

    DWORD           dwVBHandle;     // Stream 0 handle
    DWORD           dwIndexHandle;  // Index handle
#endif
    
#if DX8_POINTSPRITES               // Point sprite support
    struct
    {
        BOOL bEnabled;
        D3DVALUE fSize;    

        BOOL bScaleEnabled;    
        D3DVALUE fScale_A;
        D3DVALUE fScale_B;
        D3DVALUE fScale_C;    
        D3DVALUE fSizeMin;      
        D3DVALUE fSizeMax;
        
    } PntSprite;
#endif // DX8_POINTSPRITES

#if DX8_DDI
    DWORD dwColorWriteHWMask;    // For the new DX8 D3DRS_COLORWRITEENABLE
    DWORD dwColorWriteSWMask; 
#endif //DX8_DDI

#if DX7_TEXMANAGEMENT
    //*****************
    // Texture Management
    //*****************
    PTextureCacheManager   pTextureManager;
#endif // DX7_TEXMANAGEMENT    

    //*****************
    // Other
    //*****************

    // Track adjustments to texture coordinates that invalidate vertex sharing
    // (They force us to send the next triangle as 3 vtx's even if only the
    //  coords of 1 have changed since we adjusted the tc's in order to fit
    //  hw limitations)
    union
    {
        struct
        {
            BYTE flushWrap_tu1; // The s1 texture coordinate was wrapped
            BYTE flushWrap_tv1; // The t1 texture coordinate was wrapped
            BYTE flushWrap_tu2; // The s2 texture coordinate was wrapped
            BYTE flushWrap_tv2; // The t2 texture coordinate was wrapped
        };
            
        DWORD R3flushDueToTexCoordAdjust;
    };
    

       
} P3_D3DCONTEXT ;


//-----------------------------------------------------------------------------
//
// Triangle culling macros and definitions
//
//-----------------------------------------------------------------------------
#define SET_CULLING_TO_NONE(pCtxt)   \
            pCtxt->CullAndMask = 0;  \
            pCtxt->CullXorMask = 0;  

#define SET_CULLING_TO_CCW(pCtxt)            \
            pCtxt->CullAndMask = 1UL << 31;  \
            pCtxt->CullXorMask = 0;  

#define SET_CULLING_TO_CW(pCtxt)             \
            pCtxt->CullAndMask = 1UL << 31;  \
            pCtxt->CullXorMask = 1UL << 31; 

#define FLIP_CCW_CW_CULLING(pCtxt)           \
            pCtxt->CullXorMask ^= 1UL << 31;

#define SAVE_CULLING_STATE(pCtxt)                   \
        DWORD oldCullAndMask = pCtxt->CullAndMask;  \
        DWORD oldCullXorMask = pCtxt->CullXorMask;

#define RESTORE_CULLING_STATE(pCtxt)                \
        pCtxt->CullAndMask = oldCullAndMask;        \
        pCtxt->CullXorMask = oldCullXorMask;

#define _CULL_CALC(pCtxt,PixelArea)                 \
    ((*(DWORD *)&PixelArea) ^ pCtxt->CullXorMask) 

#if 1
#define CULLED(pCtxt,PixelArea) \
    ((signed long)(_CULL_CALC(pCtxt,PixelArea) & pCtxt->CullAndMask) < 0) ? 1 : \
    ( ((_CULL_CALC(pCtxt,PixelArea)& ~pCtxt->CullAndMask) ==  0.0f) ? 1 : 0 )
#else
static __inline int CULLED(P3_D3DCONTEXT *pCtxt, float PixelArea)
{
    int cull;
    
    cull = (*(DWORD *)&PixelArea) ^ pCtxt->CullXorMask;

    if ((signed long)(cull & pContext->CullAndMask) < 0)
    {
        return 1;         // True back face rejection...
    }
    
    if ((cull & ~pCtxt->CullAndMask) == 0.0f)
    {
        return 1;
    }

    return 0;
}
#endif
//-----------------------------------------------------------------------------
//
// GetSurfaceFromHandle
// Get internal surface structure pointer from handle
//
//-----------------------------------------------------------------------------
static __inline P3_SURF_INTERNAL* 
GetSurfaceFromHandle(
    P3_D3DCONTEXT* pContext, 
    DWORD dwHandle)
{
    P3_SURF_INTERNAL* pTexture;
    {
        // There may never have been any texture arrays allocated...
        ASSERTDD(pContext->pTexturePointerArray, 
                 "ERROR: Texture pointer array is not set!");

        pTexture = PA_GetEntry(pContext->pTexturePointerArray, dwHandle);
    }
    DISPDBG((DBGLVL, "Texture pointer: 0x%x", pTexture));
    return pTexture;
}

//-----------------------------------------------------------------------------
//
// GetPaletteFromHandle
// Get internal palette structure pointer from handle
//
//-----------------------------------------------------------------------------
#if DX7_PALETTETEXTURE
static __inline D3DHAL_DP2UPDATEPALETTE* 
GetPaletteFromHandle(
    P3_D3DCONTEXT* pContext, 
    DWORD dwHandle)
{
    D3DHAL_DP2UPDATEPALETTE* pPalette;
    {
        // There may never have been any palette arrays allocated...
        ASSERTDD(pContext->pPalettePointerArray, 
                 "ERROR: Palette pointer array is not set!");

        pPalette = PA_GetEntry(pContext->pPalettePointerArray, dwHandle);
    }
    DISPDBG((DBGLVL, "Palette pointer: 0x%x", pPalette));
    return pPalette;
}
#endif


//-----------------------------------------------------------------------------
//
// Determine what level API is the app using which created this context
//
//-----------------------------------------------------------------------------

#define IS_DX7_APP(pContext)             ((pContext)->dwDXInterface == 3)
#define IS_DX7_OR_EARLIER_APP(pContext)  ((pContext)->dwDXInterface <= 3)


#endif // __DCONTEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dtxman.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dtxman.c
*
* Content:  D3D Texture cache manager
*
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights Reserved.
\*****************************************************************************/
#include "glint.h"
#include "dma.h"

#if DX7_TEXMANAGEMENT

//-----------------------------------------------------------------------------
// The driver can optionally manage textures which have been marked as 
// manageable. These DirectDraw surfaces are marked as manageable with the 
// DDSCAPS2_TEXTUREMANAGE flag in the dwCaps2 field of the structure refered to 
// by lpSurfMore->ddCapsEx.
//
// The driver makes explicit its support for driver-managed textures by setting 
// DDCAPS2_CANMANAGETEXTURE in the dwCaps2 field of the DD_HALINFO structure. 
// DD_HALINFO is returned in response to the initialization of the DirectDraw 
// component of the driver, DrvGetDirectDrawInfo.
//
// The driver can then create the necessary surfaces in video or non-local 
// memory in a lazy fashion. That is, the driver leaves them in system memory 
// until it requires them, which is just before rasterizing a primitive that 
// makes use of the texture.
//
// Surfaces should be evicted primarily by their priority assignment. The driver 
// should respond to the D3DDP2OP_SETPRIORITY token in the D3dDrawPrimitives2 
// command stream, which sets the priority for a given surface. As a secondary 
// measure, it is expected that the driver will use a least recently used (LRU) 
// scheme. This scheme should be used as a tie breaker, whenever the priority of 
// two or more textures is identical in a particular scenario. Logically, any 
// surface that is in use shouldn't be evicted at all.
//
// The driver must be cautious of honoring DdBlt calls and DdLock calls when 
// managing textures. This is because any change to the system memory image of 
// the surface must be propagated into the video memory copy of it before the 
// texture is used again. The driver should determine if it is better to update 
// just a portion of the surface or all of it.
// 
// The driver is allowed to perform texture management in order to perform 
// optimization transformations on the textures or to decide for itself where 
// and when to transfer textures in memory.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// Porting to your hardware/driver
//
// The following structures/functions/symbols are specific to this 
// implementation. You should supply your own if needed:
//
//     P3_SURF_INTERNAL
//     P3_D3DCONTEXT
//     DISPDBG
//     HEAP_ALLOC ALLOC_TAG_DX
//     _D3D_TM_HW_FreeVidmemSurface
//     _D3D_TM_HW_AllocVidmemSurface
//
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// Global texture management object and ref count
//-----------------------------------------------------------------------------
DWORD g_TMCount = 0;
TextureCacheManager g_TextureManager;

//-----------------------------------------------------------------------------
// Macros and definitions
//-----------------------------------------------------------------------------
// Number of pointers to DX surfaces for first allocated heap
#define TM_INIT_HEAP_SIZE  1024
// Subsequent increments
#define TM_GROW_HEAP_SIZE(n)  ((n)*2)

// Access to binary-tree structure in the heap. The heap is really just a
// linear array of pointers (to P3_SURF_INTERNAL structures) which is
// accessed as if it were a binary tree: m_data_p[1] is the root of the tree
// and the its immediate children are [2] and [3]. The children/parents of 
// element are uniquely defined by the below macros.
#define parent(k) ((k) / 2)
#define lchild(k) ((k) * 2)
#define rchild(k) ((k) * 2 + 1)

//-----------------------------------------------------------------------------
//
// void __TM_TextureHeapFindSlot
//
// Starting at element k in the TM heap, search the heap (towards the root node)
// for an element whose parent is cheaper than llCost. Return the value of it.
//
// An important difference between __TM_TextureHeapFindSlot and
// __TM_TextureHeapHeapify is that the former searches upwards in the tree
// whereas the latter searches downwards through the tree.
//
//-----------------------------------------------------------------------------
DWORD
__TM_TextureHeapFindSlot(
    PTextureHeap pTextureHeap, 
    ULONGLONG llCost,
    DWORD k)
{
    // Starting with element k, traverse the (binary-tree) heap upwards until 
    // you find an element whose parent is less expensive (cost-wise) 
    // than llCost . (Short circuited && expression below!)
    while( (k > 1) &&
           (llCost < TextureCost(pTextureHeap->m_data_p[parent(k)])) )
    {
        // Slot k is assumed to be empty. So since we are looking for
        // slot where to put things, we need to move downwards the
        // parent slot before we go on in order for the new k to be 
        // available
        pTextureHeap->m_data_p[k] = pTextureHeap->m_data_p[parent(k)];
        pTextureHeap->m_data_p[k]->m_dwHeapIndex = k; // update surf reference
        k = parent(k);                                // look now at parent
    }

    return k;
} // __TM_TextureHeapFindSlot

//-----------------------------------------------------------------------------
//
// void __TM_TextureHeapHeapify
//
// Starting at element k in the TM heap, make sure the heap is well-ordered
// (parents are always lower cost than their children). This algorithm assumes
// the heap is well ordered with the possible exception of element k
//
//-----------------------------------------------------------------------------
void 
__TM_TextureHeapHeapify(
    PTextureHeap pTextureHeap, 
    DWORD k)
{
    while(TRUE) 
    {
        DWORD smallest;
        DWORD l = lchild(k);
        DWORD r = rchild(k);

        // Figure out who has the smallest TextureCost, either k,l or r.
        if(l < pTextureHeap->m_next)
        {
            if(TextureCost(pTextureHeap->m_data_p[l]) <
               TextureCost(pTextureHeap->m_data_p[k]))
            {
                smallest = l;
            }
            else
            {
                smallest = k;
            }
        }
        else
        {
            smallest = k;
        }
        
        if(r < pTextureHeap->m_next)
        {
            if(TextureCost(pTextureHeap->m_data_p[r]) <
               TextureCost(pTextureHeap->m_data_p[smallest]))
            {
                smallest = r;
            }
        }
        
        if(smallest != k) 
        {
            // it wasn't k. So now swap k with the smallest of the three
            // and repeat the loop in order with the new position of k 
            // in order to keep the order right (parents are always lower 
            // cost than children)
            P3_SURF_INTERNAL* ptempD3DSurf = pTextureHeap->m_data_p[k];
            pTextureHeap->m_data_p[k] = pTextureHeap->m_data_p[smallest];
            pTextureHeap->m_data_p[k]->m_dwHeapIndex = k;
            pTextureHeap->m_data_p[smallest] = ptempD3DSurf;
            ptempD3DSurf->m_dwHeapIndex = smallest;
            k = smallest;
        }
        else
        {
            // it was k, so the order is now all right, leave here
            break;
        }
    }
} // __TM_TextureHeapHeapify

//-----------------------------------------------------------------------------
//
// BOOL __TM_TextureHeapAddSurface
//
// Add a DX surface to a texture management heap. 
// Returns success or failure status
//
//-----------------------------------------------------------------------------
BOOL 
__TM_TextureHeapAddSurface(
    PTextureHeap pTextureHeap, 
    P3_SURF_INTERNAL* pD3DSurf)
{
    P3_SURF_INTERNAL* *ppD3DSurf;
    ULONGLONG llCost;
    DWORD k;

    if(pTextureHeap->m_next == pTextureHeap->m_size) 
    {   
        // Heap is full, we must grow it
        DWORD dwNewSize = TM_GROW_HEAP_SIZE(pTextureHeap->m_size);

        ppD3DSurf = (P3_SURF_INTERNAL* *)
                          HEAP_ALLOC( FL_ZERO_MEMORY, 
                                       sizeof(P3_SURF_INTERNAL*) * dwNewSize,
                                       ALLOC_TAG_DX(B));
        if(ppD3DSurf == 0)
        {
            DISPDBG((ERRLVL,"Failed to allocate memory to grow heap."));
            return FALSE;
        }

        // Transfer data 
        memcpy(ppD3DSurf + 1, pTextureHeap->m_data_p + 1, 
            sizeof(P3_SURF_INTERNAL*) * (pTextureHeap->m_next - 1));

        // Free previous heap
        HEAP_FREE( pTextureHeap->m_data_p);
        
        // Update texture heap structure    
        pTextureHeap->m_size = dwNewSize;
        pTextureHeap->m_data_p = ppD3DSurf;
    }

    // Get the cost of the surface we are about to add
    llCost = TextureCost(pD3DSurf);

    // Starting at the last element in the heap (where we can theoretically
    // place our new element) search upwards for an appropriate place to put 
    // it in. This will also maintain our tree/heap balanced 
    k = __TM_TextureHeapFindSlot(pTextureHeap, llCost, pTextureHeap->m_next);

    // Add the new surface to the heap in the [k] place
    pTextureHeap->m_data_p[k] = pD3DSurf;
    ++pTextureHeap->m_next;    

    //Update the surface's reference to its place on the heap
    pD3DSurf->m_dwHeapIndex = k;
    
    return TRUE;
    
} // __TM_TextureHeapAddSurface

//-----------------------------------------------------------------------------
//
// void __TM_TextureHeapDelSurface
//
// Delete the k element from the TM heap
//
//-----------------------------------------------------------------------------
void __TM_TextureHeapDelSurface(PTextureHeap pTextureHeap, DWORD k)
{
    P3_SURF_INTERNAL* pD3DSurf = pTextureHeap->m_data_p[k];
    ULONGLONG llCost;

    // (virtually) delete the heaps last element and get its cost
    --pTextureHeap->m_next;
    llCost = TextureCost(pTextureHeap->m_data_p[pTextureHeap->m_next]);
    
    if(llCost < TextureCost(pD3DSurf))
    {
        // If the cost of the last element is less than that of the surface
        // we are really trying to delete (k), look for a new place where
        // to put the m_next element based on its cost.
    
        // Starting at the k element in the heap (where we can theoretically
        // place our new element) search upwards for an appropriate place to 
        // put it in
        k = __TM_TextureHeapFindSlot(pTextureHeap, llCost, k);

        // Overwrite the data of k with the data of the last element
        pTextureHeap->m_data_p[k] = pTextureHeap->m_data_p[pTextureHeap->m_next];
        pTextureHeap->m_data_p[k]->m_dwHeapIndex = k;
    }
    else
    {
        // If the cost of the last element is greather than that of the surface
        // we are really trying to delete (k), replace (k) by (m_next)
        pTextureHeap->m_data_p[k] = pTextureHeap->m_data_p[pTextureHeap->m_next];
        pTextureHeap->m_data_p[k]->m_dwHeapIndex = k;

        // Now make sure we keep the heap correctly ordered        
        __TM_TextureHeapHeapify(pTextureHeap,k);
    }
    
    pD3DSurf->m_dwHeapIndex = 0;
    
} // __TM_TextureHeapDelSurface


//-----------------------------------------------------------------------------
//
// P3_SURF_INTERNAL* __TM_TextureHeapExtractMin
//
// Extract
//
//-----------------------------------------------------------------------------
P3_SURF_INTERNAL* 
__TM_TextureHeapExtractMin(
    PTextureHeap pTextureHeap)
{
    // Obtaint pointer to surface we are extracting from the heap
    // (the root node, which is the least expensive element of the
    // whole heap because of the way we build the heap).
    P3_SURF_INTERNAL* pD3DSurf = pTextureHeap->m_data_p[1];

    // Update heap internal counter and move last 
    // element now to first position.
    --pTextureHeap->m_next;
    pTextureHeap->m_data_p[1] = pTextureHeap->m_data_p[pTextureHeap->m_next];
    pTextureHeap->m_data_p[1]->m_dwHeapIndex = 1;

    // Now make sure we keep the heap correctly ordered
    __TM_TextureHeapHeapify(pTextureHeap,1);

    // Clear the deleted surface's reference to its place on the heap (deleted)
    pD3DSurf->m_dwHeapIndex = 0;
    
    return pD3DSurf;
    
} // __TM_TextureHeapExtractMin

//-----------------------------------------------------------------------------
//
// P3_SURF_INTERNAL* __TM_TextureHeapExtractMax
//
//-----------------------------------------------------------------------------
P3_SURF_INTERNAL* 
__TM_TextureHeapExtractMax(
    PTextureHeap pTextureHeap)
{
    // When extracting the max element from the heap, we don't need to
    // search the entire heap, but just the leafnodes. This is because
    // it is guaranteed that parent nodes are cheaper than the leaf nodes
    // so once you have looked through the leaves, you won't find anything
    // cheaper. 
    // NOTE: (lchild(i) >= m_next) is true only for leaf nodes.
    // ALSO NOTE: You cannot have a rchild without a lchild, so simply
    //            checking for lchild is sufficient.
    unsigned max = pTextureHeap->m_next - 1;
    ULONGLONG llMaxCost = 0;
    ULONGLONG llCost;
    unsigned i;
    P3_SURF_INTERNAL* pD3DSurf;

    // Search all the terminal nodes of the binary-tree (heap)
    // for the most expensive element and store its index in max
    for(i = max; lchild(i) >= pTextureHeap->m_next; --i)
    {
        llCost = TextureCost(pTextureHeap->m_data_p[i]);
        if(llMaxCost < llCost)
        {
            llMaxCost = llCost;
            max = i;
        }
    }

    // Return the surface associated to this maximum cost heap element 
    pD3DSurf = pTextureHeap->m_data_p[max];

    // Delete it from the heap ( will automatically maintain heap ordered)
    __TM_TextureHeapDelSurface(pTextureHeap, max);
    
    return pD3DSurf;
    
} // __TM_TextureHeapExtractMax

//-----------------------------------------------------------------------------
//
// void __TM_TextureHeapUpdate
//
// Updates the priority & number of of ticks of surface # k in the heap
//
//-----------------------------------------------------------------------------
void 
__TM_TextureHeapUpdate(
    PTextureHeap pTextureHeap, 
    DWORD k,
    DWORD dwPriority, 
    DWORD dwTicks) 
{
    P3_SURF_INTERNAL* pD3DSurf = pTextureHeap->m_data_p[k];
    ULONGLONG llCost = 0;
#ifdef _X86_
    _asm
    {
        mov     edx, 0;
        shl     edx, 31;
        mov     eax, dwPriority;
        mov     ecx, eax;
        shr     eax, 1;
        or      edx, eax;
        mov     DWORD PTR llCost + 4, edx;
        shl     ecx, 31;
        mov     eax, dwTicks;
        shr     eax, 1;
        or      eax, ecx;
        mov     DWORD PTR llCost, eax;
    }
#else
    llCost = ((ULONGLONG)dwPriority << 31) + ((ULONGLONG)(dwTicks >> 1));
#endif
    if(llCost < TextureCost(pD3DSurf))
    {
        // Starting at the k element in the heap (where we can theoretically
        // place our new element) search upwards for an appropriate place 
        // to move it to in order to keep the tree well ordered.
        k = __TM_TextureHeapFindSlot(pTextureHeap, llCost, k);
        
        pD3DSurf->m_dwPriority = dwPriority;
        pD3DSurf->m_dwTicks = dwTicks;
        pD3DSurf->m_dwHeapIndex = k;
        pTextureHeap->m_data_p[k] = pD3DSurf;
    }
    else
    {
        pD3DSurf->m_dwPriority = dwPriority;
        pD3DSurf->m_dwTicks = dwTicks;

        // Now make sure we keep the heap correctly ordered        
        __TM_TextureHeapHeapify(pTextureHeap,k);
    }
}

//-----------------------------------------------------------------------------
//
// BOOL __TM_FreeTextures
//
// Free the LRU texture 
//
//-----------------------------------------------------------------------------
BOOL 
__TM_FreeTextures(
    P3_D3DCONTEXT* pContext,
    DWORD dwBytes)
{
    P3_SURF_INTERNAL* pD3DSurf;
    DWORD k;

    PTextureCacheManager pTextureCacheManager =  pContext->pTextureManager;
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;    
    
    // No textures left to be freed
    if(pTextureCacheManager->m_heap.m_next <= 1)
        return FALSE;

    // Keep remove textures until we accunulate dwBytes of removed stuff
    // or we have no more surfaces left to be removed.
    for(k = 0; 
        (pTextureCacheManager->m_heap.m_next > 1) && (k < dwBytes); 
        k += pD3DSurf->m_dwBytes)
    {
        // Find the LRU texture (the one with lowest cost) and remove it.
        pD3DSurf = __TM_TextureHeapExtractMin(&pTextureCacheManager->m_heap);
        _D3D_TM_RemoveTexture(pThisDisplay, pD3DSurf);

#if DX7_TEXMANAGEMENT_STATS
        // Update stats
        pTextureCacheManager->m_stats.dwLastPri = pD3DSurf->m_dwPriority;
        ++pTextureCacheManager->m_stats.dwNumEvicts;
#endif        
        
        DISPDBG((WRNLVL, "Removed texture with timestamp %u,%u (current = %u).", 
                          pD3DSurf->m_dwPriority, 
                          pD3DSurf->m_dwTicks, 
                          pTextureCacheManager->tcm_ticks));
    }
    
    return TRUE;
    
} // __TM_FreeTextures

//-----------------------------------------------------------------------------
//
// HRESULT __TM_TextureHeapInitialize
//
// Allocate the heap and initialize
//
//-----------------------------------------------------------------------------
HRESULT 
__TM_TextureHeapInitialize(
    PTextureCacheManager pTextureCacheManager)
{
    pTextureCacheManager->m_heap.m_next = 1;
    pTextureCacheManager->m_heap.m_size = TM_INIT_HEAP_SIZE;
    pTextureCacheManager->m_heap.m_data_p = (P3_SURF_INTERNAL* *)
        HEAP_ALLOC( FL_ZERO_MEMORY, 
                     sizeof(P3_SURF_INTERNAL*) * 
                        pTextureCacheManager->m_heap.m_size,
                     ALLOC_TAG_DX(C));
            
    if(pTextureCacheManager->m_heap.m_data_p == 0)
    {
        DISPDBG((ERRLVL,"Failed to allocate texture heap."));
        return E_OUTOFMEMORY;
    }
    
    memset(pTextureCacheManager->m_heap.m_data_p, 
           0, 
           sizeof(P3_SURF_INTERNAL*) * pTextureCacheManager->m_heap.m_size);
        
    return DD_OK;
    
} // __TM_TextureHeapInitialize


//-----------------------------------------------------------------------------
//
// HRESULT _D3D_TM_Ctx_Initialize
//
// Initialize texture management for this context
// Should be called when the context is being created
//
//-----------------------------------------------------------------------------
HRESULT 
_D3D_TM_Ctx_Initialize(
    P3_D3DCONTEXT* pContext)
{

    HRESULT hr = DD_OK;
    
    if (0 == g_TMCount)
    {
        // first use - must initialize
        hr = __TM_TextureHeapInitialize(&g_TextureManager);

        // init ticks count for LRU policy
        g_TextureManager.tcm_ticks = 0;
    }

    if (SUCCEEDED(hr))
    {   
        // Initialization succesful or uneccesary.
        // Increment the reference count and make the context 
        // remember where the texture management object is.
        g_TMCount++;
        pContext->pTextureManager = &g_TextureManager;
    }

    return hr;
    
} //  _D3D_TM_Ctx_Initialize

//-----------------------------------------------------------------------------
//
// void _D3D_TM_Ctx_Destroy
//
// Clean up texture management for this context 
// Should be called when the context is being destroyed
//
//-----------------------------------------------------------------------------
void 
_D3D_TM_Ctx_Destroy(    
    P3_D3DCONTEXT* pContext)
{
    // clean up texture manager stuff if it 
    // is already allocated for this context
    if (pContext->pTextureManager)
    {
        // Decrement reference count for the 
        // driver global texture manager object
        g_TMCount--;

        // If necessary, deallocate the texture manager heap;
        if (0 == g_TMCount)
        {
            if (0 != g_TextureManager.m_heap.m_data_p)
            {
                _D3D_TM_EvictAllManagedTextures(pContext);
                HEAP_FREE(g_TextureManager.m_heap.m_data_p);
                g_TextureManager.m_heap.m_data_p = NULL;
            }
        }

        pContext->pTextureManager = NULL;        
    }
} // _D3D_TM_Ctx_Destroy

//-----------------------------------------------------------------------------
//
// HRESULT _D3D_TM_AllocTexture
//
// add a new HW handle and create a surface (for a managed texture) in vidmem
//
//-----------------------------------------------------------------------------
HRESULT 
_D3D_TM_AllocTexture(
    P3_D3DCONTEXT* pContext,
    P3_SURF_INTERNAL* pTexture)
{
    DWORD trycount = 0, bytecount = pTexture->m_dwBytes;
    PTextureCacheManager pTextureCacheManager = pContext->pTextureManager;
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;      
    INT iLOD;

    // Decide the largest level to allocate video memory based on what
    // is specified through D3DDP2OP_SETTEXLOD token
    iLOD = pTexture->m_dwTexLOD;
    if (iLOD > (pTexture->iMipLevels - 1))
    {
        iLOD = pTexture->iMipLevels - 1;
    }        

    // Attempt to allocate a texture. (do until the texture is in vidmem)
    while((FLATPTR)NULL == pTexture->MipLevels[iLOD].fpVidMemTM)
    {  
        _D3D_TM_HW_AllocVidmemSurface(pContext, pTexture);
        ++trycount;
                              
        DISPDBG((DBGLVL,"Got fpVidMemTM = %08lx",
                        pTexture->MipLevels[0].fpVidMemTM));

        // We were able to allocate the vidmem surface
        if ((FLATPTR)NULL != pTexture->MipLevels[iLOD].fpVidMemTM)
        {
            // No problem, there is enough memory. 
            pTexture->m_dwTicks = pTextureCacheManager->tcm_ticks;

            // Add texture to manager's heap to track it
            if(!__TM_TextureHeapAddSurface(&pTextureCacheManager->m_heap,
                                           pTexture))
            {          
                // Failed - undo vidmem allocation
                // This call will set all MipLevels[i].fpVidMemTM to NULL
                _D3D_TM_HW_FreeVidmemSurface(pThisDisplay, pTexture);                                           
                
                DISPDBG((ERRLVL,"Out of memory"));
                return DDERR_OUTOFMEMORY;
            }

            // Mark surface as needing update from sysmem before use
            pTexture->m_bTMNeedUpdate = TRUE;
            break;
        }
        else
        {
            // we weren't able to allocate the vidmem surface
            // we will now try to free some managed surfaces to make space
            if (!__TM_FreeTextures(pContext, bytecount))
            {
                DISPDBG((ERRLVL,"all Freed no further video memory available"));
                return DDERR_OUTOFVIDEOMEMORY; //nothing left
            }
            
            bytecount <<= 1;
        }
    }

    if(trycount > 1)
    {
        DISPDBG((DBGLVL, "Allocated texture after %u tries.", trycount));
    }
    
    __TM_STAT_Inc_TotSz(pTextureCacheManager, pTexture);
    __TM_STAT_Inc_WrkSet(pTextureCacheManager, pTexture);

#if DX7_TEXMANAGEMENT_STATS    
    ++pTextureCacheManager->m_stats.dwNumVidCreates;
#endif // DX7_TEXMANAGEMENT_STATS    
    
    return DD_OK;
    
} // _D3D_TM_AllocTexture

//-----------------------------------------------------------------------------
//
// void _D3D_TM_RemoveTexture
//
// remove all HW handles and release the managed surface 
// (usually done for every surface in vidmem when D3DDestroyDDLocal is called)
//
//-----------------------------------------------------------------------------
void 
_D3D_TM_RemoveTexture(
    P3_THUNKEDDATA *pThisDisplay,
    P3_SURF_INTERNAL* pTexture)
{    
//@@BEGIN_DDKSPLIT
// azn - we should attach the g_TextureManager ptr to pThisDisplay, 
//       NOT to pContext !!!
//@@END_DDKSPLIT
    PTextureCacheManager pTextureCacheManager =  &g_TextureManager; 
    int i;
 
    // Check if surface is currently in video memory
    for (i = 0; i < pTexture->iMipLevels; i++)
    {
        if (pTexture->MipLevels[i].fpVidMemTM != (FLATPTR)NULL)
        {
            // Free (deallocate) the surface from video memory
            // and mark the texture as not longer in vidmem
            _D3D_TM_HW_FreeVidmemSurface(pThisDisplay, pTexture);

            // Update statistics
            __TM_STAT_Dec_TotSz(pTextureCacheManager, pTexture);
            __TM_STAT_Dec_WrkSet(pTextureCacheManager, pTexture);        

            // The job is done
            break;
        }
    }

    // Remove heap references to this surface
    if (pTexture->m_dwHeapIndex && pTextureCacheManager->m_heap.m_data_p)
    {
        __TM_TextureHeapDelSurface(&pTextureCacheManager->m_heap,
                                   pTexture->m_dwHeapIndex); 
    }
    
} // _D3D_TM_RemoveTexture

//-----------------------------------------------------------------------------
//
// void _D3D_TM_RemoveDDSurface
//
// remove all HW handles and release the managed surface 
// (usually done for every surface in vidmem when D3DDestroyDDLocal is called)
//
//-----------------------------------------------------------------------------
void 
_D3D_TM_RemoveDDSurface(
    P3_THUNKEDDATA *pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl)
{
    // We don't know which D3D context this is so we have to do a search 
    // through them (if there are any at all)
    if (pThisDisplay->pDirectDrawLocalsHashTable != NULL)
    {
        DWORD dwSurfaceHandle = pDDSLcl->lpSurfMore->dwSurfaceHandle;
        PointerArray* pSurfaceArray;
       
        // Get a pointer to an array of surface pointers associated to this lpDD
        // The PDD_DIRECTDRAW_LOCAL was stored at D3DCreateSurfaceEx call time
        // in PDD_SURFACE_LOCAL->dwReserved1 
        pSurfaceArray = (PointerArray*)
                            HT_GetEntry(pThisDisplay->pDirectDrawLocalsHashTable,
                                        pDDSLcl->dwReserved1);

        if (pSurfaceArray)
        {
            // Found a surface array associated to this lpDD !
            P3_SURF_INTERNAL* pSurfInternal;

            // Check the surface in this array associated to this surface handle
            pSurfInternal = PA_GetEntry(pSurfaceArray, dwSurfaceHandle);

            if (pSurfInternal)
            {
                // Got it! remove it
                _D3D_TM_RemoveTexture(pThisDisplay, pSurfInternal);
            }
        }                                        
    } 


} // _D3D_TM_RemoveDDSurface

//-----------------------------------------------------------------------------
//
// void _D3D_TM_EvictAllManagedTextures
//
// Remove all managed surfaces from video memory
//
//-----------------------------------------------------------------------------
void 
_D3D_TM_EvictAllManagedTextures(
    P3_D3DCONTEXT* pContext)
{
    PTextureCacheManager pTextureCacheManager = pContext->pTextureManager;
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;    
    P3_SURF_INTERNAL* pD3DSurf;
    
    while(pTextureCacheManager->m_heap.m_next > 1)
    {
        pD3DSurf = __TM_TextureHeapExtractMin(&pTextureCacheManager->m_heap);
        _D3D_TM_RemoveTexture(pThisDisplay, pD3DSurf);
    }
    
    pTextureCacheManager->tcm_ticks = 0;
    
} // _D3D_TM_EvictAllManagedTextures

//-----------------------------------------------------------------------------
//
// void _DD_TM_EvictAllManagedTextures
//
// Remove all managed surfaces from video memory
//
//-----------------------------------------------------------------------------
void 
_DD_TM_EvictAllManagedTextures(
    P3_THUNKEDDATA* pThisDisplay)
{
    PTextureCacheManager pTextureCacheManager = &g_TextureManager;
    P3_SURF_INTERNAL* pD3DSurf;
    
    while(pTextureCacheManager->m_heap.m_next > 1)
    {
        pD3DSurf = __TM_TextureHeapExtractMin(&pTextureCacheManager->m_heap);
        _D3D_TM_RemoveTexture(pThisDisplay, pD3DSurf);
    }
    
    pTextureCacheManager->tcm_ticks = 0;
    
} // _D3D_TM_EvictAllManagedTextures

//-----------------------------------------------------------------------------
//
// void _D3D_TM_TimeStampTexture
//
//-----------------------------------------------------------------------------
void
_D3D_TM_TimeStampTexture(
    PTextureCacheManager pTextureCacheManager,
    P3_SURF_INTERNAL* pD3DSurf)
{
    __TM_TextureHeapUpdate(&pTextureCacheManager->m_heap,
                           pD3DSurf->m_dwHeapIndex, 
                           pD3DSurf->m_dwPriority, 
                           pTextureCacheManager->tcm_ticks);
                           
    pTextureCacheManager->tcm_ticks += 2;
    
} // _D3D_TM_TimeStampTexture

//-----------------------------------------------------------------------------
//
// void _D3D_TM_HW_FreeVidmemSurface
//
// This is a hw/driver dependent function which takes care of evicting a
// managed texture that's living in videomemory out of it.
// After this all mipmaps fpVidMemTM should be NULL.
//
//-----------------------------------------------------------------------------
void
_D3D_TM_HW_FreeVidmemSurface(
    P3_THUNKEDDATA* pThisDisplay,
    P3_SURF_INTERNAL* pD3DSurf)
{
    INT i, iLimit;

    if (pD3DSurf->bMipMap)
    {
        iLimit = pD3DSurf->iMipLevels;
    }
    else
    {
        iLimit = 1;
    }

    for(i = 0; i < iLimit; i++)
    {
        if (pD3DSurf->MipLevels[i].fpVidMemTM != (FLATPTR)NULL)
        {
           // NOTE: if we weren't managing our own vidmem we would need to
           //       get the address of the VidMemFree callback using 
           //       EngFindImageProcAddress and use this callback into Ddraw to 
           //       do the video memory management. The declaration of 
           //       VidMemFree is
           //
           //       void VidMemFree(LPVMEMHEAP pvmh, FLATPTR ptr);  
           //
           //       You can find more information on this callback in the 
           //       Graphics Drivers DDK documentation           
           
            _DX_LIN_FreeLinearMemory(
                    &pThisDisplay->LocalVideoHeap0Info, 
                    (DWORD)(pD3DSurf->MipLevels[i].fpVidMemTM));

            pD3DSurf->MipLevels[i].fpVidMemTM = (FLATPTR)NULL;                    
        }    
    }
    
} // _D3D_TM_HW_FreeVidmemSurface

//-----------------------------------------------------------------------------
//
// void _D3D_TM_HW_AllocVidmemSurface
//
// This is a hw/driver dependent function which takes care of allocating a
// managed texture that's living only in system memory into videomemory.
// After this fpVidMemTM should not be NULL. This is also the way to
// check if the call failed or was succesful (notice we don't return a
// function result)
//
//-----------------------------------------------------------------------------
void
_D3D_TM_HW_AllocVidmemSurface(
    P3_D3DCONTEXT* pContext,
    P3_SURF_INTERNAL* pD3DSurf)
{
    INT i, iLimit, iStart;
    P3_THUNKEDDATA* pThisDisplay;
    
    pThisDisplay = pContext->pThisDisplay;    

    if (pD3DSurf->bMipMap)
    {
        // Load only the necessary levels given any D3DDP2OP_SETTEXLOD command
        iStart = pD3DSurf->m_dwTexLOD;
        if (iStart > (pD3DSurf->iMipLevels - 1))
        {
            // we should at least load the smallest mipmap if we're loading 
            // the texture into vidmem (and make sure we never try to use any
            // other than these levels), otherwise we won't be able to render            
            iStart = pD3DSurf->iMipLevels - 1;
        }        
    
        iLimit = pD3DSurf->iMipLevels;
    }
    else
    {
        iStart = 0;
        iLimit = 1;
    }

    for(i = iStart; i < iLimit; i++)
    {
        if (pD3DSurf->MipLevels[i].fpVidMemTM == (FLATPTR)NULL)
        {        
           // NOTE: if we weren't managing our own vidmem we would need to
           //       get the address of the HeapVidMemAllocAligned callback 
           //       using EngFindImageProcAddress and use this callback into 
           //       Ddraw to do the video off-screen allocation. The 
           //       declaration of HeapVidMemAllocAligned is
           //
           //       FLATPTR HeapVidMemAllocAligned(LPVIDMEM lpVidMem, 
           //                                      DWORD    dwWidth,
           //                                      DWORD    dwHeight,
           //                                      LPSURFACEALIGNEMENT lpAlign,
           //                                      LPLONG   lpNewPitch);
           //
           //       You can find more information on this callback in the 
           //       Graphics Drivers DDK documentation
           
            P3_MEMREQUEST mmrq;
            DWORD dwResult;
            
            memset(&mmrq, 0, sizeof(P3_MEMREQUEST));
            mmrq.dwSize = sizeof(P3_MEMREQUEST);
            mmrq.dwBytes = pD3DSurf->MipLevels[i].lPitch * 
                           pD3DSurf->MipLevels[i].wHeight;
            mmrq.dwAlign = 8;
            mmrq.dwFlags = MEM3DL_FIRST_FIT;
            mmrq.dwFlags |= MEM3DL_FRONT;

            dwResult = _DX_LIN_AllocateLinearMemory(
                            &pThisDisplay->LocalVideoHeap0Info,
                            &mmrq);        

            if (dwResult == GLDD_SUCCESS)
            {
                // Record the new vidmem addr for this managed mip level
                pD3DSurf->MipLevels[i].fpVidMemTM = mmrq.pMem;
            }
            else
            {
                // Failure, we'll need to deallocate any mipmap
                // allocated up to this point.
                _D3D_TM_HW_FreeVidmemSurface(pThisDisplay, pD3DSurf);
                
                break; // don't do the loop anymore
            }
        }    
    }

} // _D3D_TM_HW_AllocVidmemSurface

//-----------------------------------------------------------------------------
//
// void _D3D_TM_Preload_Tex_IntoVidMem
//
// Transfer a texture from system memory into videomemory. If the texture
// still hasn't been allocated videomemory we try to do so (even evicting
// uneeded textures if necessary!).
//
//-----------------------------------------------------------------------------
BOOL
_D3D_TM_Preload_Tex_IntoVidMem(
    P3_D3DCONTEXT* pContext,
    P3_SURF_INTERNAL* pD3DSurf)
{
    P3_THUNKEDDATA* pThisDisplay = pContext->pThisDisplay;  
    INT iLOD;

    // Decide the largest level to load based on what
    // is specified through D3DDP2OP_SETTEXLOD token
    iLOD = pD3DSurf->m_dwTexLOD;
    if (iLOD > (pD3DSurf->iMipLevels - 1))
    {
        iLOD = pD3DSurf->iMipLevels - 1;
    }
    
    if (!(pD3DSurf->dwCaps2 & DDSCAPS2_TEXTUREMANAGE))
    {
        DISPDBG((ERRLVL,"Must be a managed texture to do texture preload"));
        return FALSE; // INVALIDPARAMS
    }

    // Check if the largest required mipmap level has been allocated vidmem
    // (only required mipmap levels are ever allocated vidmem)
    if ((FLATPTR)NULL == pD3DSurf->MipLevels[iLOD].fpVidMemTM)
    {
        // add a new HW handle and create a surface 
        // (for a managed texture) in vidmem        
        if ((FAILED(_D3D_TM_AllocTexture(pContext, pD3DSurf))) ||  
            ((FLATPTR)NULL == pD3DSurf->MipLevels[iLOD].fpVidMemTM))
        {
            DISPDBG((ERRLVL,"_D3D_OP_TextureBlt unable to "
                            "allocate memory from heap"));
            return FALSE; // OUTOFVIDEOMEMORY
        }
        
        pD3DSurf->m_bTMNeedUpdate = TRUE;
    }
    
    if (pD3DSurf->m_bTMNeedUpdate)
    {
        // texture download   
        DWORD   iLimit, iCurrLOD;

        if (pD3DSurf->bMipMap)
        {
            iLimit = pD3DSurf->iMipLevels;
        }
        else
        {
            iLimit = 1;
        }

        // Switch to the DirectDraw context
        DDRAW_OPERATION(pContext, pThisDisplay);

        // Blt managed texture's required mipmap levels into vid mem
        for (iCurrLOD = iLOD; iCurrLOD < iLimit ; iCurrLOD++)
        {
            RECTL   rect;
            rect.left=rect.top = 0;
            rect.right = pD3DSurf->MipLevels[iCurrLOD].wWidth;
            rect.bottom = pD3DSurf->MipLevels[iCurrLOD].wHeight;
        
            _DD_P3Download(pThisDisplay,
                           pD3DSurf->MipLevels[iCurrLOD].fpVidMem,
                           pD3DSurf->MipLevels[iCurrLOD].fpVidMemTM,
                           pD3DSurf->dwPatchMode,
                           pD3DSurf->dwPatchMode,
                           pD3DSurf->MipLevels[iCurrLOD].lPitch,
                           pD3DSurf->MipLevels[iCurrLOD].lPitch,                                                             
                           pD3DSurf->MipLevels[iCurrLOD].P3RXTextureMapWidth.Width,
                           pD3DSurf->dwPixelSize,
                           &rect,
                           &rect);   
                           
            DISPDBG((DBGLVL, "Copy from %08lx to %08lx"
                             " w=%08lx h=%08lx p=%08lx",
                             pD3DSurf->MipLevels[iCurrLOD].fpVidMem,
                             pD3DSurf->MipLevels[iCurrLOD].fpVidMemTM,
                             pD3DSurf->MipLevels[iCurrLOD].wWidth,
                             pD3DSurf->MipLevels[iCurrLOD].wHeight,
                             pD3DSurf->MipLevels[iCurrLOD].lPitch));                           
        }

        // Switch back to the Direct3D context
        D3D_OPERATION(pContext, pThisDisplay);
        
        // Texture updated in vidmem
        pD3DSurf->m_bTMNeedUpdate = FALSE;                                  
    }

    return TRUE;

} // _D3D_TM_Preload_Tex_IntoVidMem

//-----------------------------------------------------------------------------
//
// void _D3D_TM_MarkDDSurfaceAsDirty
//
// Help mark a DD surface as dirty given that we need to search for it
// based on its lpSurfMore->dwSurfaceHandle and the lpDDLcl.
//
//-----------------------------------------------------------------------------
void
_D3D_TM_MarkDDSurfaceAsDirty(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl, 
    BOOL bDirty)
{

    // We don't know which D3D context this is so we have to do a search 
    // through them (if there are any at all)
    if (pThisDisplay->pDirectDrawLocalsHashTable != NULL)
    {
        DWORD dwSurfaceHandle = pDDSLcl->lpSurfMore->dwSurfaceHandle;
        PointerArray* pSurfaceArray;
       
        // Get a pointer to an array of surface pointers associated to this lpDD
        // The PDD_DIRECTDRAW_LOCAL was stored at D3DCreateSurfaceEx call time
        // in PDD_SURFACE_LOCAL->dwReserved1 
        pSurfaceArray = (PointerArray*)
                            HT_GetEntry(pThisDisplay->pDirectDrawLocalsHashTable,
                                        pDDSLcl->dwReserved1);

        if (pSurfaceArray)
        {
            // Found a surface array associated to this lpDD !
            P3_SURF_INTERNAL* pSurfInternal;

            // Check the surface in this array associated to this surface handle
            pSurfInternal = PA_GetEntry(pSurfaceArray, dwSurfaceHandle);

            if (pSurfInternal)
            {
                // Got it! Now update dirty TM value
                pSurfInternal->m_bTMNeedUpdate = bDirty;
            }
        }                                        
    } 

} // _D3D_TM_MarkDDSurfaceAsDirty

#endif // DX7_TEXMANAGEMENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dsurf.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dsurf.c
*
* Content: Surface management callbacks for D3D
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "dma.h"

//@@BEGIN_DDKSPLIT

#if DBG

// Whistler bug 281090 detection func, print warning msg only, remove later
void 
vDetectMixedMIPLevels(
    LPDDRAWI_DDRAWSURFACE_LCL pTopLevel)
{
    LPDDRAWI_DDRAWSURFACE_LCL pCurLevel;
    DWORD dwMIPCaps;

    // Check whether this is a MIP texture
    dwMIPCaps = DDSCAPS_COMPLEX | DDSCAPS_TEXTURE | DDSCAPS_MIPMAP;
    if ((pTopLevel->ddsCaps.dwCaps & dwMIPCaps) != dwMIPCaps)
    {
        return;
    }

    // Check whether all the levels have the same cap bits
    pCurLevel = pTopLevel;
    do 
    {        
        if (pCurLevel->ddsCaps.dwCaps != pTopLevel->ddsCaps.dwCaps) 
        {
            DISPDBG((ERRLVL, 
                     "BUG281090 : MIP levels of mixed type (0x%x : 0x%x, 0x%x)",
                     pTopLevel->lpSurfMore->dwSurfaceHandle,
                     pCurLevel->ddsCaps.dwCaps, pTopLevel->ddsCaps.dwCaps));
        }

        if (pCurLevel->lpAttachList)
        {
            pCurLevel = pCurLevel->lpAttachList->lpAttached;
        }
        else
        {
            break;
        }
    } while ((pCurLevel != NULL) && (pCurLevel != pTopLevel));
}

#endif

//@@END_DDKSPLIT

//-----------------------------Public Routine----------------------------------
//
// D3DCreateSurfaceEx
//
// D3dCreateSurfaceEx creates a Direct3D surface from a DirectDraw surface and 
// associates a requested handle value to it.
//
// All Direct3D drivers must support D3dCreateSurfaceEx.
//
// D3dCreateSurfaceEx creates an association between a DirectDraw surface and 
// a small integer surface handle. By creating these associations between a
// handle and a DirectDraw surface, D3dCreateSurfaceEx allows a surface handle
// to be imbedded in the Direct3D command stream. For example when the
// D3DDP2OP_TEXBLT command token is sent to D3dDrawPrimitives2 to load a texture
// map, it uses a source handle and destination handle which were associated
//  with a DirectDraw surface through D3dCreateSurfaceEx.
//
// For every DirectDraw surface created under the local DirectDraw object, the
// runtime generates a valid handle that uniquely identifies the surface and
// places it in pcsxd->lpDDSLcl->lpSurfMore->dwSurfaceHandle. This handle value
// is also used with the D3DRENDERSTATE_TEXTUREHANDLE render state to enable
// texturing, and with the D3DDP2OP_SETRENDERTARGET and D3DDP2OP_CLEAR commands
// to set and/or clear new rendering and depth buffers. The driver should fail
// the call and return DDHAL_DRIVER_HANDLE if it cannot create the Direct3D
// surface. 
//
// As appropriate, the driver should also store any surface-related information
// that it will subsequently need when using the surface. The driver must create
// a new surface table for each new lpDDLcl and implicitly grow the table when
// necessary to accommodate more surfaces. Typically this is done with an
// exponential growth algorithm so that you don't have to grow the table too
// often. Direct3D calls D3dCreateSurfaceEx after the surface is created by
// DirectDraw by request of the Direct3D runtime or the application.
//
// Parameters
//
//      lpcsxd
//           pointer to CreateSurfaceEx structure that contains the information
//           required for the driver to create the surface (described below). 
//
//           dwFlags
//                   Currently unused
//           lpDDLcl
//                   Handle to the DirectDraw object created by the application.
//                   This is the scope within which the lpDDSLcl handles exist.
//                   A DD_DIRECTDRAW_LOCAL structure describes the driver.
//           lpDDSLcl
//                   Handle to the DirectDraw surface we are being asked to
//                   create for Direct3D. These handles are unique within each
//                   different DD_DIRECTDRAW_LOCAL. A DD_SURFACE_LOCAL structure
//                   represents the created surface object.
//           ddRVal
//                   Specifies the location in which the driver writes the return
//                   value of the D3dCreateSurfaceEx callback. A return code of
//                   DD_OK indicates success.
//
// Return Value
//
//      DDHAL_DRIVER_HANDLE
//      DDHAL_DRIVER_NOTHANDLE
//
//-----------------------------------------------------------------------------
DWORD CALLBACK
D3DCreateSurfaceEx(
    LPDDHAL_CREATESURFACEEXDATA lpcsxd )
{
    P3_THUNKEDDATA *pThisDisplay;
    PointerArray* pSurfaceArray;
    GET_THUNKEDDATA(pThisDisplay, lpcsxd->lpDDLcl->lpGbl);

    DBG_CB_ENTRY(D3DCreateSurfaceEx);

    DISPDBG((DBGLVL,"D3DCreateSurfaceEx surface %d @ %x caps = %x",
                    (DWORD)lpcsxd->lpDDSLcl->lpSurfMore->dwSurfaceHandle,
                    lpcsxd->lpDDSLcl->lpGbl->fpVidMem,
                    lpcsxd->lpDDSLcl->ddsCaps.dwCaps));               

    // Get a pointer to an array of DWORD's containing surfaces
    pSurfaceArray = (PointerArray*)HT_GetEntry(pThisDisplay->pDirectDrawLocalsHashTable,
                                               (ULONG_PTR)lpcsxd->lpDDLcl);

    // If there isn't a handle set for this directdraw object, create one.
    if (!pSurfaceArray)
    {
        DISPDBG((DBGLVL,"Creating new pointer array for PDDLcl 0x%x", 
                        lpcsxd->lpDDLcl));

        pSurfaceArray = PA_CreateArray();

        if (pSurfaceArray)
        {
            PA_SetDataDestroyCallback(pSurfaceArray, 
                                      _D3D_SU_SurfaceArrayDestroyCallback);

            if(!HT_AddEntry(pThisDisplay->pDirectDrawLocalsHashTable, 
                            (ULONG_PTR)lpcsxd->lpDDLcl, 
                            pSurfaceArray))
            {
                // failed to add entry, noe cleanup and exit
                // We ran out of memory. Cleanup before we leave  
                PA_DestroyArray(pSurfaceArray, pThisDisplay);
                DISPDBG((ERRLVL,"ERROR: Couldn't allocate "
                                "surface internal data mem for pSurfaceArray"));
                lpcsxd->ddRVal = DDERR_OUTOFMEMORY;
                DBG_CB_EXIT(D3DCreateSurfaceEx,lpcsxd->ddRVal);
                return DDHAL_DRIVER_HANDLED;                   
            }
        }
        else
        {
            DISPDBG((ERRLVL,"ERROR: Couldn't allocate "
                            "surface internal data mem"));
            lpcsxd->ddRVal = DDERR_OUTOFMEMORY;
            DBG_CB_EXIT(D3DCreateSurfaceEx,lpcsxd->ddRVal);
            return DDHAL_DRIVER_HANDLED;       
        }
    }

    // Recursively record the surface(s)

    lpcsxd->ddRVal = _D3D_SU_SurfInternalSetDataRecursive(pThisDisplay, 
                                                          pSurfaceArray,
                                                          lpcsxd->lpDDLcl,
                                                          lpcsxd->lpDDSLcl,
                                                          lpcsxd->lpDDSLcl);

//@@BEGIN_DDKSPLIT

#if DBG

    // Whistler bug 281090 detection code, print warning msg only, remove later
    vDetectMixedMIPLevels(lpcsxd->lpDDSLcl);

#endif

//@@END_DDKSPLIT

    DBG_CB_EXIT(D3DCreateSurfaceEx,lpcsxd->ddRVal);
    return DDHAL_DRIVER_HANDLED;
    
} // D3DCreateSurfaceEx

//-----------------------------Public Routine----------------------------------
//
// D3DDestroyDDLocal
//
// D3dDestroyDDLocal destroys all the Direct3D surfaces previously created by
// D3DCreateSurfaceEx that belong to the same given local DirectDraw object.
//
// All Direct3D drivers must support D3dDestroyDDLocal.
// Direct3D calls D3dDestroyDDLocal when the application indicates that the
// Direct3D context is no longer required and it will be destroyed along with
// all surfaces associated to it. The association comes through the pointer to
// the local DirectDraw object. The driver must free any memory that the
// driver's D3dCreateSurfaceExDDK_D3dCreateSurfaceEx_GG callback allocated for
// each surface if necessary. The driver should not destroy the DirectDraw
// surfaces associated with these Direct3D surfaces; this is the application's
// responsibility.
//
// Parameters
//
//      lpdddd
//            Pointer to the DestroyLocalDD structure that contains the
//            information required for the driver to destroy the surfaces.
//
//            dwFlags
//                  Currently unused
//            pDDLcl
//                  Pointer to the local Direct Draw object which serves as a
//                  reference for all the D3D surfaces that have to be 
//                  destroyed.
//            ddRVal
//                  Specifies the location in which the driver writes the 
//                  return value of D3dDestroyDDLocal. A return code of DD_OK
//                  indicates success.
//
// Return Value
//
//      DDHAL_DRIVER_HANDLED
//      DDHAL_DRIVER_NOTHANDLED
//-----------------------------------------------------------------------------
DWORD CALLBACK
D3DDestroyDDLocal(
    LPDDHAL_DESTROYDDLOCALDATA pddl)
{
    P3_THUNKEDDATA *pThisDisplay;
    GET_THUNKEDDATA(pThisDisplay, pddl->pDDLcl->lpGbl);

    DBG_CB_ENTRY(D3DDestroyDDLocal);
    
    // Removing this entry from the hash table will cause the data destroy 
    // callback to be called, which will in turn free all of the texture 
    // structures that were allocated for this LCL
    HT_RemoveEntry(pThisDisplay->pDirectDrawLocalsHashTable,
                   (ULONG_PTR)pddl->pDDLcl,
                   pThisDisplay);

    pddl->ddRVal = DD_OK;
    
    DBG_CB_EXIT(D3DDestroyDDLocal, DDHAL_DRIVER_HANDLED);    
    return DDHAL_DRIVER_HANDLED;
    
} // D3DDestroyDDLocal


//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------

HRESULT 
_D3D_SU_SurfInternalSetDataRecursive(
    P3_THUNKEDDATA* pThisDisplay, 
    PointerArray* pSurfaceArray,
    LPDDRAWI_DIRECTDRAW_LCL pDDLcl,
    LPDDRAWI_DDRAWSURFACE_LCL pRootDDSurfLcl,
    LPDDRAWI_DDRAWSURFACE_LCL pCurDDSurfLcl)
{
    P3_SURF_INTERNAL* pSurfInternal;
    DWORD dwSurfaceHandle;
    LPATTACHLIST pCurAttachList;
    HRESULT hRes;

    DBG_CB_ENTRY(_D3D_SU_SurfInternalSetDataRecursive);

    dwSurfaceHandle = (DWORD)pCurDDSurfLcl->lpSurfMore->dwSurfaceHandle;
                    
#if DBG
    DISPDBG((DBGLVL, "D3DCreateSuraceEx Handle = %d fpVidMem = 0x%x (%s)",
                     dwSurfaceHandle, 
                     pCurDDSurfLcl->lpGbl->fpVidMem,
                     pcSimpleCapsString(pCurDDSurfLcl->ddsCaps.dwCaps)));
#endif                         
                
    DBGDUMP_DDRAWSURFACE_LCL(10, pCurDDSurfLcl);

    // If this surface doesn't have a handle, return safely
    if (! dwSurfaceHandle)
    {
        return (DD_OK);
    }

    DISPDBG((DBGLVL,"Surface has a valid handle.  Setting it up"));

    // Get the texture from within the surface array
    pSurfInternal = PA_GetEntry(pSurfaceArray, dwSurfaceHandle);

    // If we didn't find the texture, create one
    if (! pSurfInternal)
    {
        DISPDBG((DBGLVL,"Creating new internal surface for handle: 0x%x", 
                        dwSurfaceHandle));

        // Allocate the texture data space, because it hasn't 
        // been done already
        pSurfInternal = (P3_SURF_INTERNAL*)HEAP_ALLOC(HEAP_ZERO_MEMORY,
                                                      sizeof(P3_SURF_INTERNAL),
                                                      ALLOC_TAG_DX(A));
        if (pSurfInternal == NULL)
        {
            DISPDBG((ERRLVL,"ERROR: Couldn't allocate surface "
                            "internal data mem"));
            
            DBG_CB_EXIT(_D3D_SU_SurfInternalSetDataRecursive, 
                        DDERR_OUTOFMEMORY);
            return (DDERR_OUTOFMEMORY);
        }
    }
    else
    {
        DISPDBG((DBGLVL,"Surface handle re-used: 0x%x", 
                        dwSurfaceHandle));
    }

    // Add this texture to the surface list
    if (! PA_SetEntry(pSurfaceArray, dwSurfaceHandle, pSurfInternal))
    {
        return (DDERR_OUTOFMEMORY);
    }

    // Setup the surface structure
    _D3D_SU_SurfInternalSetData(pThisDisplay, 
                                pSurfInternal,
                                pCurDDSurfLcl,
                                dwSurfaceHandle);

    // Keep a pointer to the DD_DIRECTDRAW_LOCAL in order to 
    // update colorkeying in DDSetColorKey possible. Notice
    // this is stored in DD_SURFACE_LOCAL.dwReserved1 as
    // DD_SURFACE_GLOBAL.dwReserved1 is being used for other
    // purpouses
    pCurDDSurfLcl->dwReserved1 = (ULONG_PTR)pDDLcl;
  
    // Don't need a seperate handle for mipmaps 
    // or cubemaps as they are atomic in DX7.
    if ((pCurDDSurfLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP) || 
        (pCurDDSurfLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP))
    {
        return (DD_OK);
    }

    pCurAttachList = pCurDDSurfLcl->lpAttachList;
    // Simple surface, mission accomplished
    if (! pCurAttachList)
    {
        return (DD_OK);
    }

    // This recursion is usually needed for complex flipping chains
    pCurDDSurfLcl = pCurAttachList->lpAttached;
    if (pCurDDSurfLcl && (pCurDDSurfLcl != pRootDDSurfLcl)) 
    {
        hRes = _D3D_SU_SurfInternalSetDataRecursive(pThisDisplay, 
                                                    pSurfaceArray,
                                                    pDDLcl,
                                                    pRootDDSurfLcl,
                                                    pCurDDSurfLcl);
        if (FAILED(hRes)) 
        {
            return (hRes);
        }
    }
    
    // This part will normally be enterned when stereo mode is on
    if (pCurAttachList->lpLink) 
    {
        pCurDDSurfLcl = pCurAttachList->lpLink->lpAttached;
        if (pCurDDSurfLcl && (pCurDDSurfLcl != pRootDDSurfLcl)) 
        {
            hRes = _D3D_SU_SurfInternalSetDataRecursive(pThisDisplay, 
                                                        pSurfaceArray,
                                                        pDDLcl,
                                                        pRootDDSurfLcl,
                                                        pCurDDSurfLcl);
            if (FAILED(hRes)) 
            {
                return (hRes);
            }
        }
    }

    return (DD_OK);
}

//-----------------------------------------------------------------------------
//
// _D3D_SU_SurfInternalSetMipMapLevelData
//
// Records the a LOD level and all associated information so that the chip 
// can use it later.
//
// Notice that ONLY while the D3DCreateSurfaceEx call is being made is the 
// LPDDRAWI_DDRAWSURFACE_LCL/PDD_LOCAL_SURFACE structure valid (Win9x/Win2K)
// so we cannot just cache a pointer to it for later use.
//
//-----------------------------------------------------------------------------
void 
_D3D_SU_SurfInternalSetMipMapLevelData(
    P3_THUNKEDDATA *pThisDisplay, 
    P3_SURF_INTERNAL* pTexture, 
    LPDDRAWI_DDRAWSURFACE_LCL pSurf, 
    int LOD)
{
    ASSERTDD(pSurf != NULL, "ERROR: NULL surface!");

    DISPDBG((6,"Storing LOD: %d, Pitch: %d, Width: %d", 
                LOD, pSurf->lpGbl->lPitch, pSurf->lpGbl->wWidth));

    // Get the byte offset to the texture map from the base of video
    // memory or as a physical mem address (for AGP surfaces). This
    // cases will be taken care of by DDSurf_SurfaceOffsetFromMemoryBase.
    pTexture->MipLevels[LOD].dwOffsetFromMemoryBase = 
                    DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pSurf);

    // Store the DD surface's fpVidMem ptr
    pTexture->MipLevels[LOD].fpVidMem = pSurf->lpGbl->fpVidMem;

    // The TextureMapWidth hardware register holds width, layout, border and 
    // AGP settings, and we will create an instance for each miplevel we'll use

    // Store the layout for this texture map 
    // (linear layout is always used in this driver, we don't use patched surfs)
    pTexture->MipLevels[LOD].P3RXTextureMapWidth.Layout = P3RX_LAYOUT_LINEAR;

    // Store the pitch for this texture map level                               
    pTexture->MipLevels[LOD].P3RXTextureMapWidth.Width = 
                                DDSurf_GetPixelPitch(pSurf);

    // Store the DD surface's lPitch
    pTexture->MipLevels[LOD].lPitch = pSurf->lpGbl->lPitch;   
                                
    // Store AGP settings for this texture map    
    if( pSurf->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM )
        pTexture->MipLevels[LOD].P3RXTextureMapWidth.HostTexture = 1;
    else
        pTexture->MipLevels[LOD].P3RXTextureMapWidth.HostTexture = 0;

    // Store mip level size
    pTexture->MipLevels[LOD].wWidth =  (int)pSurf->lpGbl->wWidth;
    pTexture->MipLevels[LOD].wHeight = (int)pSurf->lpGbl->wHeight;    
    pTexture->MipLevels[LOD].logWidth = log2((int)pSurf->lpGbl->wWidth);
    pTexture->MipLevels[LOD].logHeight = log2((int)pSurf->lpGbl->wHeight);
    
} // _D3D_SU_SurfInternalSetMipMapLevelData


//-----------------------------------------------------------------------------
//
// _D3D_SU_SurfInternalSetData
//
// Sets up all the necessary data for an internal surface structure.
//
//-----------------------------------------------------------------------------
BOOL 
_D3D_SU_SurfInternalSetData(
    P3_THUNKEDDATA *pThisDisplay, 
    P3_SURF_INTERNAL *pSurface,
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl,
    DWORD dwSurfaceHandle)
{
    DBG_ENTRY(_D3D_SU_SurfInternalSetData);

    // Store the pointer to the texture in the structure
    pSurface->pFormatSurface = _DD_SUR_GetSurfaceFormat(pDDSLcl);
    DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pDDSLcl); 

    // Initially no LUT
    pSurface->dwLUTOffset = 0;

    // Need to remember the sizes and the log of the sizes of the maps
    pSurface->wWidth = (WORD)(pDDSLcl->lpGbl->wWidth);
    pSurface->wHeight = (WORD)(pDDSLcl->lpGbl->wHeight);
    pSurface->fArea = (float)pSurface->wWidth * (float)pSurface->wHeight;
    pSurface->logWidth = log2((int)pDDSLcl->lpGbl->wWidth);
    pSurface->logHeight = log2((int)pDDSLcl->lpGbl->wHeight);

    // Store the pointer to surface memory
    pSurface->fpVidMem = pDDSLcl->lpGbl->fpVidMem;

    // Magic number for validity check
    pSurface->MagicNo = SURF_MAGIC_NO;

    // This value is used if the texture turns out to be agp
    pSurface->dwGARTDevLast = pThisDisplay->dwGARTDev;

    // For AGP and correct rendering we need to know where the surface is stored
    if(pDDSLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY)
    {
        if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
        {
            DISPDBG((DBGLVL,"  Surface %d is in AGP Memory",dwSurfaceHandle));
            pSurface->Location = AGPMemory;
        }
        else
        {
            DISPDBG((DBGLVL,"  Surface %d is in Video Memory",dwSurfaceHandle));
            pSurface->Location = VideoMemory;
        }
    }
    else
    {
        DISPDBG((DBGLVL,"  Surface %d is in system memory - "
                        "disabling use for rendering", dwSurfaceHandle));
        pSurface->Location = SystemMemory;
    }

    // Store caps & other DD fields for later
    pSurface->ddsCapsInt = pDDSLcl->ddsCaps;
    pSurface->dwFlagsInt = pDDSLcl->dwFlags;
    pSurface->dwCKLow = pDDSLcl->ddckCKSrcBlt.dwColorSpaceLowValue;
    pSurface->dwCKHigh = pDDSLcl->ddckCKSrcBlt.dwColorSpaceHighValue;
    pSurface->pixFmt = *DDSurf_GetPixelFormat(pDDSLcl);
    pSurface->dwPixelSize = DDSurf_GetChipPixelSize(pDDSLcl);
    pSurface->dwPixelPitch = DDSurf_GetPixelPitch(pDDSLcl);
    pSurface->dwPatchMode = P3RX_LAYOUT_LINEAR;
    pSurface->lOffsetFromMemoryBase = DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pDDSLcl);
    pSurface->lPitch = pDDSLcl->lpGbl->lPitch;
    pSurface->dwBitDepth = DDSurf_BitDepth(pDDSLcl);

#if DX7_TEXMANAGEMENT  
    _D3D_TM_InitSurfData(pSurface, pDDSLcl);
#endif
    
#if DX8_MULTISAMPLING
    pSurface->dwSampling =
       (pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps3 & DDSCAPS3_MULTISAMPLE_MASK );
#endif // DX8_MULTISAMPLING

    // Additional surface setup if it is a texture
    if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE )
    {
        LPDDRAWI_DDRAWSURFACE_LCL lpNextSurf;
        int iLOD;
        
        lpNextSurf = pDDSLcl;
        iLOD = 0;

#if DX8_3DTEXTURES
        if ((pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME) &&
            (pSurface->dwBitDepth != 0))
        { 
            // Mark this texture as 3D texture.
            pSurface->b3DTexture     = TRUE;
            pSurface->wDepth         = LOWORD(pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps4);
            pSurface->logDepth       = log2((int)pSurface->wDepth);
            pSurface->dwSlice        = pDDSLcl->lpGbl->dwBlockSizeY;
            pSurface->dwSliceInTexel = pDDSLcl->lpGbl->dwBlockSizeY /
                                   (DDSurf_BitDepth(pDDSLcl) / 8);
        }
        else
        {
            // Not a 3D texture
            pSurface->b3DTexture     = FALSE;
            pSurface->wDepth         = 0;
            pSurface->logDepth       = 0;
            pSurface->dwSlice        = 0;
            pSurface->dwSliceInTexel = 0;
        }
#endif // DX8_3DTEXTURES

        // For Permedia the texture offset is in pixels.
        // Store the offsets for each of the mipmap levels
        if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
        {
            BOOL bMoreSurfaces = TRUE;

            pSurface->bMipMap = TRUE;

            // Walk the chain of surfaces and find all of the mipmap levels

            do
            {
                DISPDBG((DBGLVL, "Loading texture iLOD:%d, Ptr:0x%x", 
                                 iLOD, lpNextSurf->lpGbl->fpVidMem));

                _D3D_SU_SurfInternalSetMipMapLevelData(pThisDisplay, 
                                                       pSurface, 
                                                       lpNextSurf, 
                                                       iLOD);

                // Is there another surface in the chain?

                if (lpNextSurf->lpAttachList)
                    lpNextSurf = lpNextSurf->lpAttachList->lpAttached;
                else
                    bMoreSurfaces = FALSE;

                iLOD++;
            }
            while( bMoreSurfaces );

            // This isn't really a MipMap if iLOD is 1

            if (iLOD == 1) 
            {
                DISPDBG((DBGLVL, "Texture was not a mipmap - only 1 level"));
                pSurface->bMipMap = FALSE;
            }           

            pSurface->iMipLevels = iLOD;
        }
        else // NOT A MIPMAP, simply store away the offset
        {
            pSurface->bMipMap = FALSE;
            pSurface->iMipLevels = 1;
            _D3D_SU_SurfInternalSetMipMapLevelData(pThisDisplay, 
                                                   pSurface, 
                                                   lpNextSurf, 
                                                   iLOD);
        }
    } // if (pDDSLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE )

#if DX7_PALETTETEXTURE
    // Initialize the palette handle and flags
    pSurface->dwPaletteHandle = 0;
    pSurface->dwPaletteFlags = 0;            
#endif

    DBG_EXIT(_D3D_SU_SurfInternalSetData, TRUE);
    return TRUE;
    
} // _D3D_SU_SurfInternalSetData 

//-----------------------------------------------------------------------------
//
// _D3D_SU_SurfaceArrayDestroyCallback
//
// Called when a surface is removed from the pointer array associated with a
// DirectDraw local.  Simply frees the memory
//-----------------------------------------------------------------------------
void 
_D3D_SU_SurfaceArrayDestroyCallback(
    PointerArray* pArray, 
    void* pData,
    void* pExtra)
{
    P3_SURF_INTERNAL* pTexture = (P3_SURF_INTERNAL*)pData;
    P3_THUNKEDDATA *pThisDisplay =  (P3_THUNKEDDATA*)pExtra;
    
    DBG_ENTRY(_D3D_SU_SurfaceArrayDestroyCallback);

#if DX7_TEXMANAGEMENT
    if (pTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
    {
        _D3D_TM_RemoveTexture(pThisDisplay, pTexture);
    }
#endif

    // Simply free the data
    HEAP_FREE(pData);

    DBG_EXIT(_D3D_SU_SurfaceArrayDestroyCallback, TRUE);    
    
} // _D3D_SU_SurfaceArrayDestroyCallback


//-----------------------------------------------------------------------------
//
// _D3D_SU_DirectDrawLocalDestroyCallback
//
// Called when a directdraw local is removed from the hash table.
// We use the pointer associated with it to free the pointer array that 
// was created.
//
//-----------------------------------------------------------------------------

void 
_D3D_SU_DirectDrawLocalDestroyCallback(
    HashTable* pTable, 
    void* pData,
    void* pExtra)
{
    PointerArray* pPointerArray = (PointerArray*)pData;

    DBG_ENTRY(_D3D_SU_DirectDrawLocalDestroyCallback);    

    if (pPointerArray)
    {

        DISPDBG((DBGLVL, "Destroying an array of surface pointers for this "
                         "LCL ddraw object"));
        // The data hanging off the local object is a pointerarray.
        // Calling destory will cause it to free the data items through the
        // callback if one is registered.
        PA_DestroyArray(pPointerArray, pExtra);
    }
    
    DBG_EXIT(_D3D_SU_DirectDrawLocalDestroyCallback, TRUE);  
    
} // _D3D_SU_DirectDrawLocalDestroyCallback


#if DX7_PALETTETEXTURE
//-----------------------------------------------------------------------------
//
// _D3D_SU_PaletteArrayDestroyCallback
//
// Called when a palette is removed from the pointer array.
// Simply frees the memory
//-----------------------------------------------------------------------------
void
_D3D_SU_PaletteArrayDestroyCallback(
    PointerArray* pArray,
    void* pData,
    void* pExtra)
{
    DBG_ENTRY(_D3D_SU_PaletteArrayDestroyCallback);

    // Simply free the data
    HEAP_FREE(pData);

    DBG_EXIT(_D3D_SU_PaletteArrayDestroyCallback, TRUE);

} // _D3D_SU_PaletteArrayDestroyCallback
#endif // DX7_PALETTESURFACE

//-----------------------------------------------------------------------------
//
// _D3D_SU_DumpSurfInternal
//
// Dumps into the debugger the drivers private data structure for the surface
//
//-----------------------------------------------------------------------------

void 
_D3D_SU_DumpSurfInternal(
    DWORD lvl,
    char *psHeader,
    P3_SURF_INTERNAL *pSurface)
{
    int i;
    
    DISPDBG((lvl,"Dumping %s surface @ %x",psHeader,pSurface));
    
    DISPDBG((lvl,"    MagicNo = 0x%x",pSurface->MagicNo));
    DISPDBG((lvl,"    pFormatSurface = 0x%x",pSurface->pFormatSurface)); // P3_SURF_FORMAT* pFormatSurface; 
    DISPDBG((lvl,"    Location = %d",pSurface->Location));
    DISPDBG((lvl,"    dwLUTOffset = 0x%x",pSurface->dwLUTOffset));
    DISPDBG((lvl,"    dwGARTDevLast = 0x%x",pSurface->dwGARTDevLast));
    DISPDBG((lvl,"    wWidth = %d",(LONG)pSurface->wWidth));
    DISPDBG((lvl,"    wHeight = %d",(LONG)pSurface->wHeight));
    DISPDBG((lvl,"    logWidth = %d",pSurface->logWidth));
    DISPDBG((lvl,"    logHeight = %d",pSurface->logHeight));
    DISPDBG((lvl,"    fArea = 0x%x",*(DWORD *)&pSurface->fArea));
    // DDSCAPS ddsCapsInt;  
    DISPDBG((lvl,"    dwFlagsInt = 0x%x",pSurface->dwFlagsInt));
    DISPDBG((lvl,"    dwCKLow = 0x%x",pSurface->dwCKLow));
    DISPDBG((lvl,"    dwCKHigh = 0x%x",pSurface->dwCKHigh));
    // DDPIXELFORMAT pixFmt;    
    DISPDBG((lvl,"    dwPixelSize = 0x%x",pSurface->dwPixelSize));   
    DISPDBG((lvl,"    dwPixelPitch = 0x%x",pSurface->dwPixelPitch));    
    DISPDBG((lvl,"    dwPatchMode = 0x%x",pSurface->dwPatchMode));   
    DISPDBG((lvl,"    lPitch = 0x%x",pSurface->lPitch)); 
    DISPDBG((lvl,"    fpVidMem = 0x%x",pSurface->fpVidMem)); 
#if DX8_3DTEXTURES
    DISPDBG((lvl,"    b3DTexture = 0x%x",pSurface->b3DTexture)); 
    DISPDBG((lvl,"    wDepth = %d",(LONG)pSurface->wDepth)); 
#endif // DX8_3DTEXTURES
    DISPDBG((lvl,"    bMipMap = 0x%x",pSurface->bMipMap)); 
    DISPDBG((lvl,"    iMipLevels = %d",pSurface->iMipLevels));     

    for (i = 0; i < pSurface->iMipLevels; i++)
    {
        DISPDBG((lvl,"    MipLevels[%d].logWidth = 0x%x",
                            i,pSurface->MipLevels[i].logWidth)); 
        DISPDBG((lvl,"    MipLevels[%d].logHeight = 0x%x",
                            i,pSurface->MipLevels[i].logHeight));         
        DISPDBG((lvl,"    MipLevels[%d].dwOffsetFromMemoryBase = 0x%x",
                            i,pSurface->MipLevels[i].dwOffsetFromMemoryBase));         
        DISPDBG((lvl,"    MipLevels[%d].fpVidMem = 0x%x",
                            i,pSurface->MipLevels[i].fpVidMem));     
        DISPDBG((lvl,"    MipLevels[%d].lPitch = 0x%x",
                            i,pSurface->MipLevels[i].lPitch));                             
        DISPDBG((lvl,"    MipLevels[%d].P3RXTextureMapWidth = 0x%x",
                            i,*(DWORD*)(&pSurface->MipLevels[i].P3RXTextureMapWidth)));          
    }


} // _D3D_SU_DumpSurfInternal
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\dd.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: dd.c
*
* Content: Main DirectDraw callbacks
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#define INITGUID

#include "glint.h"

#if W95_DDRAW
#include "ddkmmini.h"
#include <mmsystem.h>
#endif

#include "dma.h"
#include "tag.h"

void __GetDDHALInfo(P3_THUNKEDDATA* pThisDisplay, DDHALINFO* pHALInfo);

#if W95_DDRAW

// These variables MUST be initialised, therby forcing them into DATA. 
// This segment is shared.
P3_THUNKEDDATA* g_pDriverData = NULL;

//-----------------------------------------------------------------------------
//
// ***************************WIN9x ONLY**********************************
//
// DllMain
//
// DLL Entry point.
//
//-----------------------------------------------------------------------------
BOOL WINAPI 
DllMain(
    HINSTANCE hModule, 
    DWORD dwReason, 
    LPVOID lpvReserved)
{
    // The 16 bit side requires an HINSTANCE
    g_DXGlobals.hInstance = hModule;

    switch( dwReason ) 
    {
        case DLL_PROCESS_ATTACH:
            // We don't care about thread attach messages.
            DisableThreadLibraryCalls( hModule );
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        default:
            break;
    }

    return TRUE;

} // DllMain

//-----------------------------Public Routine----------------------------------
//
// ***************************WIN9x ONLY**********************************
//
// DdDestroyDriver
//
// Destroys a DirectDraw driver. 
//
// Parameters
//      pddd 
//              Address of a DDHAL_DESTROYDRIVERDATA structure that contains
//              information necessary to destroy the driver.
//          Members
//
//          LPDDRAWI_DIRECTDRAW_GBL
//          lpDD
//                      Address of the DirectDraw structure representing
//                      the DirectDraw object. 
//          HRESULT                    
//          ddRVal
//                      Passes the DirectDraw return values. 
//          LPDDHAL_DESTROYDRIVER      
//          DestroyDriver 
//                      This member is used by the DirectDraw API and should
//                      not be filled in by the driver. 
//
// Return Value
//      Returns one of the following values: 
//
//      DDHAL_DRIVER_HANDLED 
//      DDHAL_DRIVER_NOTHANDLED 
//-----------------------------------------------------------------------------

//
// (!!!) Temp patch, move to Win9x header later, this CB is currently not used.
//

#define DIRECTX_DESTROYDRIVER_ESCAPE  0xbadbadee

DWORD CALLBACK 
DdDestroyDriver(
    LPDDHAL_DESTROYDRIVERDATA pddd)
{
    HDC hDC;
    P3_THUNKEDDATA* pThisDisplay;
    LPGLINTINFO pGLInfo;

    DISPDBG((DBGLVL,"*** In DdDestroyDriver"));

    GET_THUNKEDDATA(pThisDisplay, pddd->lpDD);
    
    pGLInfo = pThisDisplay->pGLInfo;

    // Destroy the hash table
    HT_DestroyHashTable(pThisDisplay->pDirectDrawLocalsHashTable, pThisDisplay);

    DISPDBG((DBGLVL,"Calling Display Driver's DestroyDriver16"));
    
    hDC = CREATE_DRIVER_DC ( pThisDisplay->pGLInfo );
    
    if ( hDC != NULL )
    {
        DISPDBG((DBGLVL,"HDC: 0x%x", hDC));
        
        ExtEscape ( hDC, 
                    DIRECTX_DESTROYDRIVER_ESCAPE, 
                    sizeof(DDHAL_DESTROYDRIVERDATA), 
                    (LPCSTR)pddd, 
                    0, 
                    NULL );
                    
        DELETE_DRIVER_DC ( hDC );
    }

    pddd->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
    
} // DdDestroyDriver

//-----------------------------Public Routine----------------------------------
//
// ***************************WIN9x ONLY**********************************
//
// DriverInit
//
// The entry point called by DirectDraw to initialize the 32-bit driver. 
//
// DriverInit is called after the control function receives QUERYESCAPESUPPORT
// with DDGET32BITDRIVERNAME escapes and returns the entry point (szEntryPoint).
// DriverInit is only called once during driver initialization; it is not
// called on mode changes. 
//
// The dwDriverData parameter points to a region of shared data between the
// 16- and 32-bit address space. It must be aliased through MapSLFix (a
// standard Windows driver routine), which converts it to a 32-bit pointer,
// g_pDriverData. MapSLFix creates a 16-bit selector for a 32-bit pointer, so
// you can use what it returns from the 16-bit side. A 16:16 pointer is created
// to point to the needed 32-bit objects, so a 64K piece of memory is shared
// between 16- and 32-bit sides. Since only 64K of linear address space is
// accessible with a 16:16 pointer, any objects larger than 64K will require
// two 16:16 pointers tiled together (most objects should be smaller than 64K).
// The pointer is used to set the fReset flag to TRUE because the display
// parameters are being reset. The buildDDHALInfo32 function is called from
// this function to fill out all of the 32-bit function names and driver
// information.
//
// Returns 1.
//
// Parameters
//      DWORD
//      dwDriverData 
//              Doubleword pointer that points to a shared memory region
//              between 16- and 32-bit address space. 
//-----------------------------------------------------------------------------
DWORD CALLBACK
DriverInit( 
    DWORD dwDriverData )
{
    P3_THUNKEDDATA* pThisDisplay;
    DWORD DataPointer = 0;
    HANDLE hDevice = NULL;
    DWORD InPtr = dwDriverData;
    DWORD dwSizeRet;
    DWORD bResult;

    // The g_pThisTemp may have been hosed, so we must reset
    // it to continue
#if DBG
    g_pThisTemp = NULL;
#endif
    //extern LPVOID _stdcall MapSL( DWORD );   // 16:16 -> 0:32
    //DataPointer = (DWORD)MapSL(dwDriverData);

    //!! Don't laugh at this... I tried calling the MapSL function
    //to fix up the pointer, but couldn't get it to work all of the time
    //(When the display was running the second instance of itself).
    hDevice = CreateFile("\\\\.\\perm3mvd", 
                         GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, 
                         (LPSECURITY_ATTRIBUTES) NULL, 
                         OPEN_EXISTING, 
                         FILE_ATTRIBUTE_NORMAL, 
                         (HANDLE) NULL); 

    if (hDevice == (HANDLE) INVALID_HANDLE_VALUE) 
    { 
        DISPDBG((ERRLVL, "ERROR: Invalid Handle"));
        return 0; 
    }
    else 
    { 
        DISPDBG((DBGLVL, "Got handle"));
        
        bResult = DeviceIoControl(hDevice, 
                                  GLINT_16TO32_POINTER, 
                                  &InPtr, 
                                  sizeof(DWORD), 
                                  &DataPointer, 
                                  sizeof(DWORD), 
                                  &dwSizeRet, 
                                  0);
                                  
        if (!bResult || (DataPointer == 0))
        {
            DISPDBG((ERRLVL,"ERROR: Pointer conversion failed!"));
            CloseHandle(hDevice); 
            return 0;
        }
    }
    CloseHandle(hDevice);

#if DBG
    g_pThisTemp = (P3_THUNKEDDATA*)DataPointer;
#endif

    //
    // Sanity check
    //

    if (! (((P3_THUNKEDDATA*)DataPointer)->pGLInfo)) {
        return 0;
    }

    if (((P3_THUNKEDDATA*)DataPointer)->pGLInfo->dwDeviceHandle == 1)
    {
        g_pDriverData = (P3_THUNKEDDATA*)DataPointer;
        DISPDBG((ERRLVL, "Device is the Primary, Setting sData: 0x%x", 
                         g_pDriverData));
    }
    else
    {
        DISPDBG((ERRLVL, "Device NOT Primary Display, "
                         "Setting dwReturn: 0x%x", 
                         DataPointer));
    }

    pThisDisplay = (P3_THUNKEDDATA*)DataPointer;
    if (pThisDisplay->dwSetupThisDisplay == 0)
    {
        // Pass the current pointer to the init function
        if (! _DD_InitDDHAL32Bit((P3_THUNKEDDATA*)DataPointer)) 
        {
            DISPDBG((ERRLVL,"ERROR: DriverInit Failed!"));
            return 0;
        }
        else
        {
            //
            // Initialize the heap manager data structure
            //

            _DX_LIN_UnInitialiseHeapManager(&pThisDisplay->LocalVideoHeap0Info);

            if (!_DX_LIN_InitialiseHeapManager(
                     &pThisDisplay->LocalVideoHeap0Info,
                     pThisDisplay->LocalVideoHeap0Info.dwMemStart,
                     pThisDisplay->LocalVideoHeap0Info.dwMemEnd))
            {
                DISPDBG((ERRLVL, "ERROR: Heap0 initialization failed!"));
            }

            DISPDBG((ERRLVL,"Returned g_pDriverData"));
        }

    }
    
    // Increase the reference count on the display object.
    pThisDisplay->dwSetupThisDisplay++;

    // Set up the size of the ddCaps
    pThisDisplay->ddhi32.ddCaps.dwSize = sizeof(DDCORECAPS);

    // Set the flag that says we have to handle a mode change.
    // This will cause the chip to be initialised properly at the 
    // right time (whilst in a Win16Lock)
    ((P3_THUNKEDDATA*)DataPointer)->bResetMode = TRUE;
    ((P3_THUNKEDDATA*)DataPointer)->bStartOfDay = TRUE;
    ((P3_THUNKEDDATA*)DataPointer)->pGLInfo->dwDirectXState = 
                                                DIRECTX_LASTOP_UNKNOWN;
                                                

    return (DWORD)DataPointer;

} // DriverInit

//-----------------------------Public Routine----------------------------------
//
// ***************************WIN9x ONLY**********************************
//
// DdControlColor
//
// Controls the luminance and brightness controls of an overlay surface
// or a primary surface. This callback is optional. 
//
// Parameters
//      lpColorControl 
//                  Points to a DD_COLORCONTROLDATA structure that contains
//                  the color control information for a specified overlay
//                  surface.
//
//          Members
//
//              PDD_DIRECTDRAW_GLOBAL
//              lpDD 
//                          Points to a DD_DIRECTDRAW_GLOBAL structure that
//                          describes the driver. 
//              PDD_SURFACE_LOCAL
//              lpDDSurface 
//                          Points to the DD_SURFACE_LOCAL structure
//                          representing the overlay surface. 
//              DDCOLORCONTROL
//              ColorData 
//                          Is a DDCOLORCONTROL structure. See dwFlags to
//                          determine how to use this member. The
//                          DDCOLORCONTROL structure is defined in ddraw.h.
//              DWORD
//              dwFlags 
//                          Is the color control flags. This member can be
//                          one of the following values: 
//
//                  DDRAWI_GETCOLOR     The driver should return the color
//                                      controls it supports for the
//                                      specified overlay in ColorData.
//                                      The driver should set the appropriate
//                                      flags in the dwFlags member of the
//                                      DDCOLORCONTROL structure to indicate
//                                      which other members the driver has
//                                      returned valid data in. 
//                  DDRAWI_SETCOLOR 
//                                      The driver should set the current color
//                                      controls for the specified overlay
//                                      using the values specified in ColorData.
//              HRESULT
//              ddRVal 
//                          Is the location in which the driver writes the
//                          return value of the DdControlColor callback. A
//                          return code of DD_OK indicates success. 
//              VOID*
//              ColorControl 
//                          Is unused on Windows 2000. 
//
// Return Value
//          DdControlColor returns one of the following callback codes: 
//
//          DDHAL_DRIVER_HANDLED 
//          DDHAL_DRIVER_NOTHANDLED 
// Comments
//
//      DdControlColor can be optionally implemented in a DirectDraw driver.
//-----------------------------------------------------------------------------

// Set this to 1 to support gamma correction, or zero to disable.
#define COLCON_SUPPORTS_GAMMA 1

DWORD CALLBACK 
DdControlColor( 
    LPDDHAL_COLORCONTROLDATA lpColConData )
{
    P3_THUNKEDDATA* pThisDisplay;
    P3_SURF_FORMAT* pFormatSurface;

    GET_THUNKEDDATA(pThisDisplay, lpColConData->lpDD);

    DISPDBG((DBGLVL,"DdControlColor"));

    //
    // What the DDCOLORCONTROL structure looks like:
    //  {
    //      DWORD   dwSize;
    //      DWORD   dwFlags;
    //      LONG    lBrightness;
    //      LONG    lContrast;
    //      LONG    lHue;
    //      LONG    lSaturation;
    //      LONG    lSharpness;
    //      LONG    lGamma;
    //      LONG    lColorEnable;
    //      DWORD   dwReserved1;
    //  } DDCOLORCONTROL;
    //

    pFormatSurface = _DD_SUR_GetSurfaceFormat(lpColConData->lpDDSurface);
    if ( pFormatSurface->dwBitsPerPixel <= 8 )
    {
        // Can't do colour control on this format screen.
        // Only works on true-colour screens (and we don't 
        // support 332 as a primary).
        lpColConData->lpColorData->dwFlags = 0;
        lpColConData->ddRVal = DD_OK;
        return ( DDHAL_DRIVER_HANDLED );
    }

    // See what they want.
    if ( lpColConData->dwFlags == DDRAWI_GETCOLOR )
    {
        // Get the colour info.
        lpColConData->lpColorData->lBrightness  = 
                                pThisDisplay->ColConBrightness;
        lpColConData->lpColorData->lContrast    = 
                                pThisDisplay->ColConContrast;
                                
#if COLCON_SUPPORTS_GAMMA
        lpColConData->lpColorData->lGamma  = 
                            pThisDisplay->ColConGamma;
        lpColConData->lpColorData->dwFlags = 
                            DDCOLOR_BRIGHTNESS | 
                            DDCOLOR_CONTRAST   | 
                            DDCOLOR_GAMMA;
#else
        // We don't support gamma values.
        lpColConData->lpColorData->lGamma = 0;
        lpColConData->lpColorData->dwFlags =
                            DDCOLOR_BRIGHTNESS | 
                            DDCOLOR_CONTRAST;
#endif
        
    }
    else if ( lpColConData->dwFlags == DDRAWI_SETCOLOR )
    {
        WORD wRamp[256*3];
        WORD *pwRampR, *pwRampG, *pwRampB;
        BOOL bRes;
        HDC hDC;
        float fCol1, fCol2, fCol3, fCol4;
        float fBrightGrad, fBrightBase;
        float fContGrad1, fContBase1;
        float fContGrad2, fContBase2;
        float fContGrad3, fContBase3;
        float fContCutoff12, fContCutoff23;
        float fGammaGrad1, fGammaBase1;
        float fGammaGrad2, fGammaBase2;
        float fGammaCutoff12;
        float fTemp;
        int iTemp, iCount;

        // Set some new colour info.
        if ( ( lpColConData->lpColorData->dwFlags & DDCOLOR_BRIGHTNESS ) != 0 )
        {
            pThisDisplay->ColConBrightness  = 
                        lpColConData->lpColorData->lBrightness;
        }
        if ( ( lpColConData->lpColorData->dwFlags & DDCOLOR_CONTRAST ) != 0 )
        {
            pThisDisplay->ColConContrast    = 
                        lpColConData->lpColorData->lContrast;
        }
#if COLCON_SUPPORTS_GAMMA
        if ( ( lpColConData->lpColorData->dwFlags & DDCOLOR_GAMMA ) != 0 )
        {
            pThisDisplay->ColConGamma = 
                    lpColConData->lpColorData->lGamma;
        }
#endif


        // Set up the constants.

        // Brightness.
        // 0->10000 maps to 0.0->1.0. Default is 0
        fCol1 = (float)(pThisDisplay->ColConBrightness) / 10000.0f;
        fBrightGrad = 1.0f - fCol1;
        fBrightBase = fCol1;

        // Contrast
        // 0->20000 maps to 0.0->1.0. Default 10000 maps to 0.5
        fCol1 = (float)(pThisDisplay->ColConContrast) / 20000.0f;
        fContCutoff12 = fCol1 / 2.0f;
        fContCutoff23 = 1.0f - ( fCol1 / 2.0f );
        fContGrad1 = ( 1.0f - fCol1 ) / fCol1;
        fContBase1 = 0.0f;
        fContGrad2 = fCol1 / ( 1.0f - fCol1 );
        fContBase2 = ( 0.5f - fCol1 ) / ( 1.0f - fCol1 );
        fContGrad3 = ( 1.0f - fCol1 ) / fCol1;
        fContBase3 = ( ( 2.0f * fCol1 ) - 1.0f ) / fCol1;

        // Gamma
        // 1->500 maps to 0.01->5.0, default of 100 maps to 1.0
        // But then map to 0.0->0.5->1.0 non-linearly.
        if ( pThisDisplay->ColConGamma <= 2 )
        {
            // App is probably using the old docs that forgot to point 
            // out the *100
            ASSERTDD ( FALSE, "** Colorcontrol32: App set gamma value of 2"
                              " or less - probably using old DX docs" );
            fTemp = (float)(pThisDisplay->ColConGamma);
        }
        else
        {
            fTemp = (float)(pThisDisplay->ColConGamma) / 100.0f;
        }

        fTemp = 1.0f - ( 1.0f / ( 1.0f + fTemp ) );
        fGammaCutoff12 = 1.0f - fTemp;
        fGammaGrad1 = fTemp / ( 1.0f - fTemp );
        fGammaBase1 = 0.0f;
        fGammaGrad2 = ( 1.0f - fTemp ) / fTemp;
        fGammaBase2 = ( 2.0f * fTemp - 1.0f ) / fTemp;

        // Now set up the table.
        fCol1 = 0.0f;
        pwRampR = &(wRamp[0]);
        pwRampG = &(wRamp[256]);
        pwRampB = &(wRamp[512]);
        for ( iCount = 256; iCount > 0; iCount-- )
        {
            fCol1 += 1.0f / 256.0f;

            // Apply linear approximation gamma.
            if ( fCol1 < fGammaCutoff12 )
            {
                fCol2 = fGammaBase1 + fGammaGrad1 * fCol1;
            }
            else
            {
                fCol2 = fGammaBase2 + fGammaGrad2 * fCol1;
            }

            // Apply contrast
            if ( fCol2 < fContCutoff12 )
            {
                fCol3 = fContBase1 + fContGrad1 * fCol2;
            }
            else if ( fCol2 < fContCutoff23 )
            {
                fCol3 = fContBase2 + fContGrad2 * fCol2;
            }
            else
            {
                fCol3 = fContBase3 + fContGrad3 * fCol2;
            }

            // Apply brightness
            fCol4 = fBrightBase + fBrightGrad * fCol3;

            // Convert 0.0->1.0 to 0->65535
            fTemp = ( fCol4 * 65536.0f );
            myFtoi ( &iTemp, fTemp );
            if ( iTemp < 0 )
            {
                iTemp = 0;
            }
            else if ( iTemp > 65535 )
            {
                iTemp = 65535;
            }

            *pwRampR = (WORD)iTemp;
            *pwRampG = (WORD)iTemp;
            *pwRampB = (WORD)iTemp;

            pwRampR++;
            pwRampG++;
            pwRampB++;
        }

        // And do the hardware itself.

        hDC = CREATE_DRIVER_DC ( pThisDisplay->pGLInfo );
        if ( hDC != NULL )
        {
            bRes = SetDeviceGammaRamp ( hDC, wRamp );
            DELETE_DRIVER_DC ( hDC );
            ASSERTDD ( bRes, "DdControlColor - SetDeviceGammaRamp failed" );
        }
        else
        {
            ASSERTDD ( FALSE, "DdControlColor - CREATE_DRIVER_DC failed" );
        }
    }
    else
    {
        // Don't know what they want to do. Panic.
        ASSERTDD ( FALSE, "DdControlColor - don't know what to do." );
        lpColConData->ddRVal = DDERR_INVALIDPARAMS;
        return ( DDHAL_DRIVER_HANDLED );
    }

    lpColConData->ddRVal = DD_OK;
    return ( DDHAL_DRIVER_HANDLED );

} // DdControlColor

#endif // W95_DDRAW

DirectXGlobals  g_DXGlobals = { 0 };

#if WNT_DDRAW
//-----------------------------Public Routine----------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// DdMapMemory
//
// Maps application-modifiable portions of the frame buffer into the 
// user-mode address space of the specified process, or unmaps memory.
//
// DdMapMemory is called to perform memory mapping before the first call to 
// DdLock. The handle returned by the driver in fpProcess will be passed to 
// every DdLock call made on the driver. 
//
// DdMapMemory is also called to unmap memory after the last DdUnLock call is 
// made.
//
// To prevent driver crashes, the driver must not map any portion of the frame
// buffer that must not be modified by an application.
//
// Parameters
//      lpMapMemory 
//          Points to a DD_MAPMEMORYDATA structure that contains details for 
//          the memory mapping or unmapping operation. 
//
//          .lpDD 
//              Points to a DD_DIRECTDRAW_GLOBAL structure that represents 
//              the driver. 
//          .bMap 
//              Specifies the memory operation that the driver should perform. 
//              A value of TRUE indicates that the driver should map memory; 
//              FALSE means that the driver should unmap memory. 
//          .hProcess 
//              Specifies a handle to the process whose address space is 
//              affected. 
//          .fpProcess 
//              Specifies the location in which the driver should return the 
//              base address of the process's memory mapped space when bMap 
//              is TRUE. When bMap is FALSE, fpProcess contains the base 
//              address of the memory to be unmapped by the driver.
//          .ddRVal 
//              Specifies the location in which the driver writes the return 
//              value of the DdMapMemory callback. A return code of DD_OK 
//              indicates success. 
//
//-----------------------------------------------------------------------------

DWORD CALLBACK
DdMapMemory(
    PDD_MAPMEMORYDATA lpMapMemory)
{
    PDEV*                           ppdev;
    VIDEO_SHARE_MEMORY              ShareMemory;
    VIDEO_SHARE_MEMORY_INFORMATION  ShareMemoryInformation;
    DWORD                           ReturnedDataLength;

    DBG_CB_ENTRY(DdMapMemory);

    ppdev = (PDEV*) lpMapMemory->lpDD->dhpdev;

    if (lpMapMemory->bMap)
    {
        ShareMemory.ProcessHandle = lpMapMemory->hProcess;

        // 'RequestedVirtualAddress' isn't actually used for the SHARE IOCTL:

        ShareMemory.RequestedVirtualAddress = 0;

        // We map in starting at the top of the frame buffer:

        ShareMemory.ViewOffset = 0;

        // We map down to the end of the frame buffer.
        //
        // Note: There is a 64k granularity on the mapping (meaning that
        //       we have to round up to 64k).
        //
        // Note: If there is any portion of the frame buffer that must
        //       not be modified by an application, that portion of memory
        //       MUST NOT be mapped in by this call.  This would include
        //       any data that, if modified by a malicious application,
        //       would cause the driver to crash.  This could include, for
        //       example, any DSP code that is kept in off-screen memory.

        ShareMemory.ViewSize
            = ROUND_UP_TO_64K(ppdev->cyMemory * ppdev->lDelta);

        if (EngDeviceIoControl(ppdev->hDriver,
                       IOCTL_VIDEO_SHARE_VIDEO_MEMORY,
                       &ShareMemory,
                       sizeof(VIDEO_SHARE_MEMORY),
                       &ShareMemoryInformation,
                       sizeof(VIDEO_SHARE_MEMORY_INFORMATION),
                       &ReturnedDataLength))
        {
            DISPDBG((ERRLVL, "Failed IOCTL_VIDEO_SHARE_MEMORY"));

            lpMapMemory->ddRVal = DDERR_GENERIC;
     
            DISPDBG((ERRLVL, "DdMapMemory: Exit GEN, DDHAL_DRIVER_HANDLED"));
            
            DBG_CB_EXIT(DdMapMemory, DDERR_GENERIC);
            return(DDHAL_DRIVER_HANDLED);
        }

        lpMapMemory->fpProcess = 
                            (FLATPTR) ShareMemoryInformation.VirtualAddress;
    }
    else
    {
        ShareMemory.ProcessHandle           = lpMapMemory->hProcess;
        ShareMemory.ViewOffset              = 0;
        ShareMemory.ViewSize                = 0;
        ShareMemory.RequestedVirtualAddress = (VOID*) lpMapMemory->fpProcess;

        if (EngDeviceIoControl(ppdev->hDriver,
                       IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY,
                       &ShareMemory,
                       sizeof(VIDEO_SHARE_MEMORY),
                       NULL,
                       0,
                       &ReturnedDataLength))
        {
            RIP("Failed IOCTL_VIDEO_UNSHARE_MEMORY");
        }
    }

    lpMapMemory->ddRVal = DD_OK;

    DBG_CB_EXIT(DdMapMemory, DD_OK);
    return(DDHAL_DRIVER_HANDLED);
} // DdMapMemory

//-----------------------------Public Routine----------------------------------
//
// ***************************WIN NT ONLY**********************************
//
// BOOL DrvGetDirectDrawInfo
//
// Function called by DirectDraw to returns the capabilities of the graphics
// hardware
//
// Parameters:
//
// dhpdev-------Is a handle to the PDEV returned by the driver's DrvEnablePDEV
//              routine.
// pHalInfo-----Points to a DD_HALINFO structure in which the driver should
//              return the hardware capabilities that it supports. 
// pdwNumHeaps--Points to the location in which the driver should return the
//              number of VIDEOMEMORY structures pointed to by pvmList. 
// pvmList------Points to an array of VIDEOMEMORY structures in which the
//              driver should return information about each video memory chunk
//              that it controls. The driver should ignore this parameter when
//              it is NULL. 
// pdwNumFourCC-Points to the location in which the driver should return the
//              number of DWORDs pointed to by pdwFourCC. 
// pdwFourCC----Points to an array of DWORDs in which the driver should return
//              information about each FOURCC that it supports. The driver
//              should ignore this parameter when it is NULL.
//
// Return:
//  Returns TRUE if it succeeds; otherwise, it returns FALSE
//
// Note:
//  This function will be called twice before DrvEnableDirectDraw is called.
//
// Comments
//  The driver's DrvGetDirectDrawInfo routine should do the following: 
//  1)When pvmList and pdwFourCC are NULL: 
//  Reserve off-screen video memory for DirectDraw use. Write the number of
//  driver video memory heaps and supported FOURCCs in pdwNumHeaps and
//  pdwNumFourCC, respectively. 
//
//  2)When pvmList and pdwFourCC are not NULL: 
//  Write the number of driver video memory heaps and supported FOURCCs in
//  pdwNumHeaps and pdwNumFourCC, respectively.
//  Get ptr to reserved offscreen mem? 
//  For each VIDEOMEMORY structure in the list to which pvmList points, fill in
//  the appropriate members to describe a particular chunk of display memory.
//  The list of structures provides DirectDraw with a complete description of
//  the driver's off-screen memory. 
//
//  3)Initialize the members of the DD_HALINFO structure with driver-specific
//  information as follows: 
//  Initialize the appropriate members of the VIDEOMEMORYINFO structure to
//  describe the general characteristics of the display's memory. 
//  Initialize the appropriate members of the DDNTCORECAPS structure to
//  describe the capabilities of the hardware. 
//  If the driver implements a DdGetDriverInfo function, set GetDriverInfo to
//  point to it and set dwFlags to DDHALINFO_GETDRIVERINFOSET
//
//-----------------------------------------------------------------------------
BOOL 
DrvGetDirectDrawInfo(
    DHPDEV dhpdev,
    DD_HALINFO*     pHalInfo,
    DWORD*          pdwNumHeaps,
    VIDEOMEMORY*    pvmList,            // Will be NULL on first call
    DWORD*          pdwNumFourCC,
    DWORD*          pdwFourCC)          // Will be NULL on first call
{
    BOOL        bCanFlip;
    PDEV*       ppdev;
    LONGLONG    li;
    DWORD Unused = 0;
    P3_THUNKEDDATA* pThisDisplay;
    DWORD dwChipConfig;
    DWORD cHeaps;
    static DWORD fourCC[] =  { FOURCC_YUV422 };  // The FourCC's we support
    

    ppdev = (PDEV*) dhpdev;
    pThisDisplay = (P3_THUNKEDDATA*) ppdev->thunkData;

    DBG_CB_ENTRY(DrvGetDirectDrawInfo);

    *pdwNumFourCC = 0;

    // We may not support DirectDraw on this card:

    if (!(ppdev->flStatus & STAT_DIRECTDRAW))
    {
        DISPDBG((ERRLVL, "DrvGetDirectDrawInfo: exit, not enabled"));
        DBG_CB_EXIT(DrvGetDirectDrawInfo,FALSE);
        return(FALSE);
    }

    // Need a pointer to the registers to read config info
    pThisDisplay->pGLInfo->pRegs = (ULONG_PTR) ppdev->pulCtrlBase[0];

//@@BEGIN_DDKSPLIT
    //azn - loss of bits 64->32
//@@END_DDKSPLIT
   
    pThisDisplay->control = (FLATPTR)pThisDisplay->pGLInfo->pRegs;
    pThisDisplay->pGlint = (FPGLREG)pThisDisplay->control;

#if DBG
    // We can only initialise g_pThisTemp after 
    // the registers have been mapped in.
    g_pThisTemp = pThisDisplay;
#endif

    // Decide if we can use AGP or not
    dwChipConfig = 
        (DWORD)((PREGISTERS)pThisDisplay->pGLInfo->pRegs)->Glint.ChipConfig;

    // Make the AGP decision (NT Only!)
    if ( ((dwChipConfig & PM_CHIPCONFIG_AGP1XCAPABLE) ||
          (dwChipConfig & PM_CHIPCONFIG_AGP2XCAPABLE) ||
          (dwChipConfig & PM_CHIPCONFIG_AGP4XCAPABLE))    )
    {
        DISPDBG((WRNLVL,"AGP Permedia3 Board detected!"));
        pThisDisplay->bCanAGP = TRUE;        
    }
    else
    {
        DISPDBG((WRNLVL,"Permedia3 Board is NOT AGP"));    
        pThisDisplay->bCanAGP = FALSE;
    }

    // Fill in the DDHAL Informational caps that Win95 has setup.
    __GetDDHALInfo(pThisDisplay, pHalInfo);

    // On Win2K we need to return the D3D callbacks
    DISPDBG((DBGLVL ,"Creating Direct3D info"));
    _D3DHALCreateDriver(pThisDisplay);

    // Record the pointers that were created.  Note that the above call 
    // may not have recreated a previous set of data.
    pHalInfo->lpD3DGlobalDriverData = (void*)pThisDisplay->lpD3DGlobalDriverData;
    pHalInfo->lpD3DHALCallbacks = (void*)pThisDisplay->lpD3DHALCallbacks;
    pHalInfo->lpD3DBufCallbacks = (void *)pThisDisplay->lpD3DBufCallbacks;
    if ( (pHalInfo->lpD3DBufCallbacks) && 
         (pHalInfo->lpD3DBufCallbacks->dwSize != 0))
    {
        pHalInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
    }

    // Fill in any DDHAL caps that are specific to Windows NT.
     // Current primary surface attributes:
    pHalInfo->vmiData.pvPrimary       = ppdev->pjScreen;
    pHalInfo->vmiData.fpPrimary       = 0;
    pHalInfo->vmiData.dwDisplayWidth  = ppdev->cxScreen;
    pHalInfo->vmiData.dwDisplayHeight = ppdev->cyScreen;
    pHalInfo->vmiData.lDisplayPitch   = ppdev->lDelta;

    pHalInfo->vmiData.ddpfDisplay.dwSize        = sizeof(DDPIXELFORMAT);
    pHalInfo->vmiData.ddpfDisplay.dwFlags       = DDPF_RGB;
    pHalInfo->vmiData.ddpfDisplay.dwRGBBitCount = ppdev->cjPelSize * 8;
    if (ppdev->iBitmapFormat == BMF_8BPP)
    {
        pHalInfo->vmiData.ddpfDisplay.dwFlags |= DDPF_PALETTEINDEXED8;
    }

    // These masks will be zero at 8bpp:
    pHalInfo->vmiData.ddpfDisplay.dwRBitMask = ppdev->flRed;
    pHalInfo->vmiData.ddpfDisplay.dwGBitMask = ppdev->flGreen;
    pHalInfo->vmiData.ddpfDisplay.dwBBitMask = ppdev->flBlue;

//@@BEGIN_DDKSPLIT
    // Free up as much off-screen memory as possible:
    //TMM ?? bMoveAllDfbsFromOffscreenToDibs(ppdev);
//@@END_DDKSPLIT

    // We have to tell DirectDraw our preferred off-screen alignment, even
    // if we're doing our own off-screen memory management:
    pHalInfo->vmiData.dwOffscreenAlign = 4;

    pHalInfo->vmiData.dwZBufferAlign = 4;
    pHalInfo->vmiData.dwTextureAlign = 4;
    pHalInfo->vmiData.dwOverlayAlign = 4;

    // Since we do our own memory allocation, we have to set dwVidMemTotal
    // ourselves.  Note that this represents the amount of available off-
    // screen memory, not all of video memory:
    pHalInfo->ddCaps.dwVidMemTotal = 
                ppdev->heap.cxMax * ppdev->heap.cyMax * ppdev->cjPelSize;

    // If we are on Permedia, then setup the YUV modes for Video playback 
    // acceleration. We can do YUV conversions at any depth except 8 bits...
    // On Win95 this information is setup in the Mini Display Driver.
    if (ppdev->iBitmapFormat != BMF_8BPP) 
    {
        *pdwNumFourCC = sizeof( fourCC ) / sizeof( fourCC[0] );
        if (pdwFourCC)
        {
            memcpy(pdwFourCC, fourCC, sizeof(fourCC));
        }
    }

    cHeaps = 0;

    if(pThisDisplay->bCanAGP)
    {
        ++cHeaps; // agp memory heap
    }

    // Report the heaps we want DD to manage. 
    // Currently this is needed in this sample for the AGP heap.
    if(pvmList)
    {
        VIDEOMEMORY *pVm = pvmList;
        
        // If we support AGP , then define the AGP heap               
        if(pThisDisplay->bCanAGP)
        {
            DWORD dwAGPMemBytes;

//@@BEGIN_DDKSPLIT                
            // azn This business of hard-allocating 32MB is not right. 
            // We need to fix it and verify with JeffN what's the best 
            // policy to show in the sample

            // Request a suitably sized AGP heap, don't ask for a heap 
            // larger than the available memory 
            // This is taken care of by the W2000 runtime policy, so I don't 
            // think we need to do this for W2k.  CTM.
//@@END_DDKSPLIT                

            // Default to 32Mb of AGP memory
            dwAGPMemBytes = 32*1024*1024;

            // Report the AGP heap
            // fpStart---Points to the starting address of a memory range in the
            // heap. 
            // fpEnd-----Points to the ending address of a memory range if the heap
            // is linear. This address is inclusive, that is, it specifies the last
            // valid address in the range. Thus, the number of bytes specified by
            // fpStart and fpEnd is (fpEnd-fpStart+1).          
                
            // DDraw ignores our start address so just set to zero
            pVm->fpStart = 0;

            // Fetch the last byte of AGP memory
            pVm->fpEnd = dwAGPMemBytes - 1;
            
            pVm->dwFlags = VIDMEM_ISNONLOCAL | 
                           VIDMEM_ISLINEAR   | 
                           VIDMEM_ISWC;
            
            // Only use AGP memory for texture surfaces
            pVm->ddsCaps.dwCaps = DDSCAPS_OVERLAY        | 
                                  DDSCAPS_OFFSCREENPLAIN |
                                  DDSCAPS_FRONTBUFFER    |
                                  DDSCAPS_BACKBUFFER     | 
                                  DDSCAPS_ZBUFFER        | 
                                  DDSCAPS_3DDEVICE;

            pVm->ddsCapsAlt.dwCaps = DDSCAPS_OVERLAY        | 
                                     DDSCAPS_OFFSCREENPLAIN |
                                     DDSCAPS_FRONTBUFFER    |
                                     DDSCAPS_BACKBUFFER     | 
                                     DDSCAPS_ZBUFFER        | 
                                     DDSCAPS_3DDEVICE;

            DISPDBG((DBGLVL, "Initialised AGP Heap for P2, Start:0x%x, End:0x%x", 
                        pVm->fpStart, pVm->fpEnd));

            ++pVm;
        }
        else
        {
            DISPDBG((WRNLVL, "NOT reporting AGP heap"));
        }
    }
    else
    {
        DISPDBG((DBGLVL, "Heap info NOT requested"));
    }

    // Report the number of heaps we support
    if (pdwNumHeaps)
    {
        *pdwNumHeaps = cHeaps;
    }

    DBG_CB_EXIT(DrvGetDirectDrawInfo,TRUE);
    
    return(TRUE);
} // DrvGetDirectDrawInfo


#endif  // WNT_DDRAW

#if USE_FLIP_BACKOFF
//-----------------------------------------------------------------------------
//
// __WaitTimeDelay 
//
//-----------------------------------------------------------------------------
#define WAIT_TIME_DELAY 2
void __WaitTimeDelay(void)
{
    static DWORD dwLastTime; // Doesn't matter what the 
                             // start value is (honest!)
    DWORD dwCurTime, iTimeDiff;

    // Make sure that we don't start hammering on the chip.
    // If someone uses the WAIT flag, or they do a loop
    // themselves, we will constantly be reading the chip,
    // which will disrupt the DMA stream. Therefore,
    // make sure we don't start reading it too often.
    // This #define will need tweaking, of course.  
    
    do
    {
        dwCurTime = timeGetTime();
        // Be careful about wraparound conditions.
        iTimeDiff = (signed int)( dwCurTime - dwLastTime );
    } while ( ( iTimeDiff > 0 ) && ( iTimeDiff < WAIT_TIME_DELAY ) );
    
    // And store the new "last" time.
    dwLastTime = dwCurTime;
    
} // __WaitTimeDelay
#endif //#if USE_FLIP_BACKOFF

//-----------------------------------------------------------------------------
//
// __QueryRenderIDStatus 
//
// Checks to see if the given two RenderIDs have been finished yet.
//
// If there is a problem, the pipeline will be flushed and the
// RenderIDs set to the newest ID.
//
// If bAllowDMAFlush is TRUE, then if either RenderID is still in the
// pipe, the current DMA buffer is flushed. Otherwise there is a 
// fairly good chance that the command with that RenderID may simply
// sit in the DMA buffer and never be executed. To disable this,
// pass in FALSE. This may be needed because the routine has already
// grabbed the DMA buffer, etc. and in that case it needs to do the flush
// itself when it gets DDERR_WASSTILLDRAWING.
//
// The return value is either DD_OK (both RenderIDs have been finished),
// or DDERR_WASSTILLDRAWING.
//
//-----------------------------------------------------------------------------
HRESULT 
__QueryRenderIDStatus( 
    P3_THUNKEDDATA* pThisDisplay,  
    BOOL bAllowDMAFlush )
{
    P3_DMA_DEFS();

    ASSERTDD ( CHIP_RENDER_ID_IS_VALID(), 
               "** __QueryRenderIDStatus:Chip RenderID was invalid - fix it!");
               
    if ( RENDER_ID_HAS_COMPLETED ( pThisDisplay->dwLastFlipRenderID ))
    {
        // OK, the RenderID has cleared the pipe, so we can carry on.
        return ( DD_OK );
    }
    else
    {
        // Can't flip yet - one surface is still pending.
        if (!NEED_TO_RESYNC_CHIP_AND_SURFACE (pThisDisplay->dwLastFlipRenderID))
        {
            // No error - we just need to wait. We'll flush the buffer and 
            // return DDERR_WASSTILLDRAWING

            if ( bAllowDMAFlush )
            {
                DDRAW_OPERATION(pContext, pThisDisplay);
                P3_DMA_GET_BUFFER();
                P3_DMA_FLUSH_BUFFER();
            }

#if USE_FLIP_BACKOFF
            __WaitTimeDelay();
#endif 

            return ( DDERR_WASSTILLDRAWING );
        }
        else
        {
            // Something went wrong - need to do a safety-net resync.
            
            DISPDBG((ERRLVL,"__QueryRenderIDStatus: "
                            "RenderID failure - need a resync"));
            SYNC_WITH_GLINT;
            pThisDisplay->dwLastFlipRenderID = GET_HOST_RENDER_ID();

            // And continue with the operation.
            return ( DD_OK );
        }
    }
} // __QueryRenderIDStatus

//-----------------------------------------------------------------------------
//
// _DX_QueryFlipStatus
//
// Checks and sees if the most recent flip has occurred. If so returns DD_OK.
//
//-----------------------------------------------------------------------------
HRESULT 
_DX_QueryFlipStatus( 
    P3_THUNKEDDATA* pThisDisplay, 
    FLATPTR fpVidMem, 
    BOOL bAllowDMAFlush )
{       
    // If fpVidMem == 0, the Query is asking for the 'general flip status'.
    // The question is "Am I safe to add another flip, independent of surfaces".
    // If fpVidmem != 0, the Query is asking if it is safe to 'use' the current 
    // fpvidmem surface. It will only be safe to use unconditionally if that 
    // surface has been succesfully flipped away from, OR it was not the last 
    // surface flipped away from.
    
    // The answers will be yes, iff the RenderID of the flip travelling down 
    // the core has been sent to the MemoryController and put in the scratch ID, 
    // and iff the bypass pending bit has been cleared. These two checks 
    // effectively guarantee that the previously queue'd flip has taken place.

    // The fpFlipFrom is a record of the last surface that was flipped away from
    if((fpVidMem == 0) || (fpVidMem == pThisDisplay->flipRecord.fpFlipFrom))
    {
        DWORD dwVidControl;
        HRESULT hres;

        // Check if the pThisDisplay->dwLastFlipRenderID has completed
        hres = __QueryRenderIDStatus ( pThisDisplay, bAllowDMAFlush );

        if ( SUCCEEDED(hres) )
        {
            BOOL bFlipHasFinished;
            // OK, the previous flip has got to the end of the pipe,
            // but it may not actually have happened yet.
            // Read the Bypass pending bit.  If it's clear then 
            // we proceed.
#if W95_DDRAW
            if ( ( ( pThisDisplay->pGLInfo->dwFlags & GMVF_DFP_DISPLAY ) != 0 ) &&
                 ( ( pThisDisplay->pGLInfo->dwScreenWidth != 
                      pThisDisplay->pGLInfo->dwVideoWidth     ) ||
                   ( pThisDisplay->pGLInfo->dwScreenHeight != 
                      pThisDisplay->pGLInfo->dwVideoHeight    )  ) )
            {
                // Display driver is using the overlay on a DFP, so we need to
                // check the overlay pending bit, not the screen pending bit.
                if ( ( ( READ_GLINT_CTRL_REG(VideoOverlayUpdate) ) & 0x1 ) == 0 )
                {
                    bFlipHasFinished = TRUE;
                }
                else
                {
                    bFlipHasFinished = FALSE;
                }
            }
            else
#endif // W95_DDRAW
            {
                dwVidControl = READ_GLINT_CTRL_REG(VideoControl);
                if (dwVidControl & (0x1 << 7))
                {
                    bFlipHasFinished = FALSE;
                }
                else
                {
                    bFlipHasFinished = TRUE;
                }
            }
            
            if ( bFlipHasFinished )
            {
                // This flip has actually completed.
                return ( DD_OK );            
            }
            else
            {
#if USE_FLIP_BACKOFF
                __WaitTimeDelay();
#endif //#if USE_FLIP_BACKOFF

                return ( DDERR_WASSTILLDRAWING );
            }
        }
        else
        {
            // No, still waiting for the flip command to exit the pipe.
            return ( DDERR_WASSTILLDRAWING );
        }
    }
    else
    {
        return ( DD_OK );
    }
} // _DX_QueryFlipStatus 

//-----------------------------Public Routine----------------------------------
//
// DdFlip
//
// Causes the surface memory associated with the target surface to become 
// the primary surface, and the current surface to become the nonprimary 
// surface.
//
// DdFlip allows a display driver to perform multi-buffering. DirectDraw drivers 
// must implement this function.
//
// The driver should update its surface pointers so that the next frame will be 
// written to the surface to which lpSurfTarg points. If a previous flip request 
// is still pending, the driver should fail the call and return 
// DDERR_WASSTILLDRAWING. The driver should ensure that the scan line is not in 
// the vertical blank before performing the flip. DdFlip does not affect the 
// actual display of the video data.
//
// If the driver's hardware supports overlays or textures, DdFlip should make 
// any necessary checks based on the surface type before performing the flip.
//
// Parameters
//
//      lpFlipData
//          Points to a DD_FLIPDATA structure that contains the information 
//          required to perform the flip. 
//
//          .lpDD 
//              Points to the DD_DIRECTDRAW_GLOBAL structure that describes 
//              the driver. 
//          .lpSurfCurr 
//              Points to the DD_SURFACE_LOCAL structure describing the 
//              current surface. 
//          .lpSurfTarg 
//              Points to the DD_SURFACE_LOCAL structure describing the 
//              target surface; that is, the surface to which the driver 
//              should flip. 
//          .dwFlags 
//              This is a set of flags that provide the driver with details 
//              for the flip. This member can be a bit-wise OR of the 
//              following flags: 
//
//              DDFLIP_EVEN 
//                  The surface to which lpSurfTarg points contains only 
//                  the even field of video data. This flag is valid only when 
//                  the surface is an overlay, and is mutually exclusive of 
//                  DDFLIP_ODD. 
//              DDFLIP_ODD 
//                  The surface to which lpSurfTarg points contains only the 
//                  odd field of video data. This flag is valid only when the
//                  surface is an overlay, and is mutually exclusive of 
//                  DDFLIP_EVEN. 
//              DDFLIP_NOVSYNC 
//                  The driver should perform the flip and return immediately. 
//                  Typically, the now current back buffer (which used to be 
//                  the front buffer) is still visible until the next vertical 
//                  retrace. Subsequent operations involving the surfaces 
//                  to which lpSurfCurr and lpSurfTarg point will not check 
//                  to see if the physical flip has finished. This allows an 
//                  application to perform flips at a higher frequency than 
//                  the monitor refresh rate, although it might introduce 
//                  visible artifacts. 
//              DDFLIP_INTERVAL2 
//                  The driver should perform the flip on every other vertical 
//                  sync. It should return DDERR_WASSTILLDRAWING until the 
//                  second vertical retrace has occurred. This flag is mutually 
//                  exclusive of DDFLIP_INTERVAL3 and DDFLIP_INTERVAL4. 
//              DDFLIP_INTERVAL3 
//                  The driver should perform the flip on every third vertical 
//                  sync. It should return DDERR_WASSTILLDRAWING until the 
//                  third vertical retrace has occurred. This flag is mutually 
//                  exclusive of DDFLIP_INTERVAL2 and DDFLIP_INTERVAL4. 
//              DDFLIP_INTERVAL4 
//                  The driver should perform the flip on every fourth vertical 
//                  sync. It should return DDERR_WASSTILLDRAWING until the 
//                  fourth vertical retrace has occurred. This flag is mutually 
//                  exclusive of DDFLIP_INTERVAL2 and DDFLIP_INTERVAL3. 
//
//          .ddRVal 
//              Specifies the location in which the driver writes the return 
//              value of the DdFlip callback. A return code of DD_OK indicates 
//              success. 
//          .Flip 
//              This is unused on Windows 2000. 
//          .lpSurfCurrLeft 
//              Points to the DD_SURFACE_LOCAL structure describing the current 
//              left surface. 
//          .lpSurfTargLeft 
//              Points to the DD_SURFACE_LOCAL structure describing the left 
//              target surface to flip to. 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK
DdFlip( 
    LPDDHAL_FLIPDATA lpFlipData)
{
    DWORD       dwDDSurfaceOffset;
    P3_THUNKEDDATA* pThisDisplay;
    HRESULT ddrval;
    GET_THUNKEDDATA(pThisDisplay, lpFlipData->lpDD);
    
    DBG_CB_ENTRY(DdFlip);
    
    VALIDATE_MODE_AND_STATE(pThisDisplay);

    STOP_SOFTWARE_CURSOR(pThisDisplay);

    // Is the previous Flip already done? Check if the current surface is
    // already displayed and don't allow a new flip (unless the DDFLIP_NOVSYNC
    // is set) to queue if the old one isn't finished.
    ddrval = _DX_QueryFlipStatus(pThisDisplay, 0, TRUE);
    if((FAILED(ddrval)) && 
       !(lpFlipData->dwFlags & DDFLIP_NOVSYNC))
    {
        lpFlipData->ddRVal = DDERR_WASSTILLDRAWING;

        START_SOFTWARE_CURSOR(pThisDisplay);

        DBG_CB_EXIT(DdFlip,DDERR_WASSTILLDRAWING);  
        return DDHAL_DRIVER_HANDLED;
    }

    // Set the flipped flag so that the D3D side does any necessary 
    // setup updates before starting to render the next frame 
    pThisDisplay->bFlippedSurface = TRUE;


    // Do the flip
    {
        P3_DMA_DEFS();
        DWORD dwNewRenderID;

        DDRAW_OPERATION(pContext, pThisDisplay);

        P3_DMA_GET_BUFFER_ENTRIES(12);

        // Make sure all the rendering is finished
        SYNC_WITH_GLINT;

        // Check the surface type (overlay or not overlay)
        
        // Update the overlay
        if ((((pThisDisplay->pGLInfo->dwFlags & GMVF_DFP_DISPLAY) != 0) &&
             ((pThisDisplay->pGLInfo->dwScreenWidth != 
                    pThisDisplay->pGLInfo->dwVideoWidth) ||
              (pThisDisplay->pGLInfo->dwScreenHeight != 
                    pThisDisplay->pGLInfo->dwVideoHeight))) ||
              (lpFlipData->lpSurfTarg->ddsCaps.dwCaps & DDSCAPS_OVERLAY))
        {
            DWORD dwVideoOverlayUpdate;

            do
            {
                dwVideoOverlayUpdate = READ_GLINT_CTRL_REG(VideoOverlayUpdate);
            } while ((dwVideoOverlayUpdate & 0x1) != 0);

            // Just let the overlay routine do the hard work.
            // Tell it that this is a screen emulation.
            _DD_OV_UpdateSource(pThisDisplay, 
                                lpFlipData->lpSurfTarg);

            UPDATE_OVERLAY(pThisDisplay, 
                           !(lpFlipData->dwFlags & DDFLIP_NOVSYNC),
                           FALSE);
        }
        else // Normal mode - flip the screen address.
        {                        
            ULONG ulVControl;

#if W95_DDRAW
            // Apps should use the DDFLIP_NOVSYNC to take advantage of
            // the new capability of the Perm3
            if (! (lpFlipData->dwFlags & DDFLIP_NOVSYNC))
            {
                if (READ_GLINT_CTRL_REG(VideoControl) & __GP_VIDEO_ENABLE)  
                {
                    LOAD_GLINT_CTRL_REG(IntFlags, INTR_VBLANK_SET); 
                    while (((READ_GLINT_CTRL_REG(IntFlags)) & INTR_VBLANK_SET) == 0);
                }
            }
#endif

#if DX7_STEREO
            if (lpFlipData->dwFlags & DDFLIP_STEREO )   // will be stereo
            {
                if (lpFlipData->lpSurfTargLeft)
                {
                    dwDDSurfaceOffset = 
                        (DWORD)(lpFlipData->lpSurfTargLeft->lpGbl->fpVidMem -
                                pThisDisplay->dwScreenFlatAddr);
                    
                    // Update the screenbase address using the DownloadAddress 
                    // & Data mechanism (therefore through the core)
                    SEND_P3_DATA(VTGAddress, 
                                 VTG_VIDEO_ADDRESS(VID_SCREENBASERIGHT));
                    SEND_P3_DATA(VTGData, (dwDDSurfaceOffset >> 4) );
                }
        
                ulVControl = READ_GLINT_CTRL_REG(VideoControl);
                LOAD_GLINT_CTRL_REG(VideoControl, 
                                    ulVControl | __VIDEO_STEREOENABLE);
            }
            else
            {
                ulVControl = READ_GLINT_CTRL_REG(VideoControl);
                LOAD_GLINT_CTRL_REG(VideoControl, 
                                    ulVControl & (~__VIDEO_STEREOENABLE));
            }
#endif
            // Get the surface offset from the start of memory
            dwDDSurfaceOffset = 
                (DWORD)(lpFlipData->lpSurfTarg->lpGbl->fpVidMem - 
                        pThisDisplay->dwScreenFlatAddr);

            // Update the screenbase address using the DownloadAddress/data 
            // mechanism (therefore through the core)
            // Setup so that DownloadData will update the ScreenBase Address.
            SEND_P3_DATA(VTGAddress, VTG_VIDEO_ADDRESS(VID_SCREENBASE));
            SEND_P3_DATA(VTGData, (dwDDSurfaceOffset >> 4) );
        }

        // Send a new RenderID to the chip.
        dwNewRenderID = GET_NEW_HOST_RENDER_ID();
        SEND_HOST_RENDER_ID ( dwNewRenderID );
        pThisDisplay->dwLastFlipRenderID = dwNewRenderID;

        // Flush the P3 Data
        P3_DMA_COMMIT_BUFFER();
        P3_DMA_FLUSH_BUFFER();

    }

    // Remember where we flipped from
    pThisDisplay->flipRecord.fpFlipFrom = 
                            lpFlipData->lpSurfCurr->lpGbl->fpVidMem;

    lpFlipData->ddRVal = DD_OK;

    START_SOFTWARE_CURSOR(pThisDisplay);

    DBG_CB_EXIT(DdFlip,DD_OK);        
    
    return DDHAL_DRIVER_HANDLED;

} // DdFlip 

//-----------------------------Public Routine----------------------------------
//
// DdWaitForVerticalBlank
//
// Returns the vertical blank status of the device.
//
// Parameters
//
//      lpWaitForVerticalBlank 
//          Points to a DD_WAITFORVERTICALBLANKDATA structure that
//          contains the information required to obtain the vertical
//          blank status.
//
//          PDD_DIRECTDRAW_GLOBAL
//          lpDD 
//                  Points to the DirectDraw structure representing
//                  the DirectDraw object.
//          DWORD
//          dwFlags
//                  Specifies how the driver should wait for the vertical blank.
//                  This member can be one of the following values: 
//
//              DDWAITVB_I_TESTVB           The driver should determine whether
//                                          a vertical blank is currently
//                                          occurring and return the status in
//                                          bIsInVB. 
//              DDWAITVB_BLOCKBEGIN         The driver should return when it
//                                          detects the beginning of the vertical
//                                          blank interval. 
//              DDWAITVB_BLOCKBEGINEVENT    Is currently unsupported on Windows
//                                          2000 and should be ignored by the
//                                          driver. 
//              DDWAITVB_BLOCKEND           The driver should return when it
//                                          detects the end of the vertical
//                                          blank interval and display begins.
//          DWORD
//          bIsInVB 
//                  Indicates the status of the vertical blank. A value of
//                  TRUE indicates that the device is in a vertical blank;
//                  FALSE means that it is not. The driver should return the
//                  current vertical blanking status in this member when
//                  dwFlags is DDWAITVB_I_TESTVB. 
//          DWORD
//          hEvent 
//                  Is currently unsupported on Windows 2000 and should be ignored
//                  by the driver. 
//          HRESULT
//          ddRVal 
//                  Is the location in which the driver writes the return value of
//                  the DdWaitForVerticalBlank callback. A return code of DD_OK
//                  indicates success. 
//          VOID*
//          WaitForVerticalBlank 
//                  Is unused on Windows 2000.
//
// Return Value
//      DdWaitForVerticalBlank returns one of the following callback codes:
//
//      DDHAL_DRIVER_HANDLED 
//      DDHAL_DRIVER_NOTHANDLED 
//
// Comments
//      Depending on the value of dwFlags, the driver should do the following:
//
//      If dwFlags is DDWAITVB_I_TESTVB, the driver should query the current
//      vertical blanking status. The driver should set bIsInVB to TRUE if the
//      monitor is currently in a vertical blank; otherwise it should set it
//      to FALSE.
//
//      If dwFlags is DDWAITVB_BLOCKBEGIN, the driver should block and wait
//      until a vertical blank begins. If a vertical blank is in progress when
//      the driver begins the block, the driver should wait until the next
//      vertical blank begins before returning.
//
//      If dwFlags is DDWAITVB_BLOCKEND, the driver should block and wait
//      until a vertical blank ends.
//
//      When the driver successfully handles the action specified in dwFlags,
//      it should set DD_OK in ddRVal and return DDHAL_DRIVER_HANDLED. The
//      driver should return DDHAL_DRIVER_NOTHANDLED for those flags that it
//      is incapable of handling.
//
//      DdWaitForVerticalBlank allows an application to synchronize itself
//      with the vertical blanking interval (VBI).
//
//-----------------------------------------------------------------------------
// bit in VideoControl Register
#define __GP_VIDEO_ENABLE               0x0001

DWORD CALLBACK 
DdWaitForVerticalBlank(
    LPDDHAL_WAITFORVERTICALBLANKDATA lpWaitForVerticalBlank)
{
    static BOOL bBlankReturn = TRUE;
    P3_THUNKEDDATA* pThisDisplay;

    GET_THUNKEDDATA(pThisDisplay, lpWaitForVerticalBlank->lpDD);

    DBG_CB_ENTRY(DdWaitForVerticalBlank);

    switch(lpWaitForVerticalBlank->dwFlags)
    {
        case DDWAITVB_I_TESTVB:

            //
            // just toggle the return bit when monitor is powered off
            //

            if( ! ( READ_GLINT_CTRL_REG(VideoControl) & __GP_VIDEO_ENABLE ) )
            {
                lpWaitForVerticalBlank->bIsInVB = bBlankReturn;
                bBlankReturn = !bBlankReturn;
            }
            else
            {
                // Just a request for current VBLANK status
                lpWaitForVerticalBlank->bIsInVB = IN_VBLANK;
            }

            lpWaitForVerticalBlank->ddRVal = DD_OK;
            DBG_CB_EXIT(DdWaitForVerticalBlank,DD_OK);               
            return DDHAL_DRIVER_HANDLED;

        case DDWAITVB_BLOCKBEGIN:

            //
            // only wait when the monitor is on
            //

            if( READ_GLINT_CTRL_REG(VideoControl) & __GP_VIDEO_ENABLE ) 
            {
                // if blockbegin is requested we wait until the vertical 
                // retrace is over, and then wait for the display period to end.
                while(IN_VBLANK)
                    NULL;
                
                while(!IN_VBLANK)
                    NULL;
            }

            lpWaitForVerticalBlank->ddRVal = DD_OK;
            DBG_CB_EXIT(DdWaitForVerticalBlank,DD_OK);               
            return DDHAL_DRIVER_HANDLED;

        case DDWAITVB_BLOCKEND:

            //
            // only wait when the monitor is on
            //

            if( READ_GLINT_CTRL_REG(VideoControl) & __GP_VIDEO_ENABLE ) 
            {
                // if blockend is requested we wait for the vblank interval to end.
                if( IN_VBLANK )
                {
                    while( IN_VBLANK )
                        NULL;
                }
                else
                {
                    while(IN_DISPLAY)
                        NULL;
                    
                    while(IN_VBLANK)
                        NULL;
                }
            }
            
            lpWaitForVerticalBlank->ddRVal = DD_OK;
            DBG_CB_EXIT(DdWaitForVerticalBlank,DD_OK);               
            return DDHAL_DRIVER_HANDLED;
    }

    DBG_CB_EXIT(DdWaitForVerticalBlank,0);   
    return DDHAL_DRIVER_NOTHANDLED;

} // DdWaitForVerticalBlank

//-----------------------------Public Routine----------------------------------
//
// DdLock
//
// Locks a specified area of surface memory and provides a valid pointer to a
// block of memory associated with a surface.
//
// Parameters
//      lpLock 
//              Points to a DD_LOCKDATA structure that contains the information
//              required to perform the lockdown.
//
//          Members
//
//          PDD_DIRECTDRAW_GLOBAL
//          lpDD
//                  Points to a DD_DIRECTDRAW_GLOBAL structure that
//                  describes the driver.
//          PDD_SURFACE_LOCAL
//          lpDDSurface
//                  Points to a DD_SURFACE_LOCAL structure that describes the
//                  surface associated with the memory region to be locked down.
//          DWORD
//          bHasRect
//                  Specifies whether the area in rArea is valid.
//          RECTL
//          rArea
//                  Is a RECTL structure that defines the area on the
//                  surface to lock down.
//          LPVOID
//          lpSurfData 
//                  Is the location in which the driver can return a pointer
//                  to the memory region that it locked down.
//          HRESULT
//          ddRVal
//                  Is the location in which the driver writes the return value
//                  of the DdLock callback. A return code of DD_OK
//                  indicates success.
//          VOID*
//          Lock
//                  Is unused on Windows 2000. 
//          DWORD
//          dwFlags 
//                  Is a bitmask that tells the driver how to perform the
//                  memory lockdown. This member is a bitwise-OR of any
//                  of the following values:
//
//              DDLOCK_SURFACEMEMORYPTR     The driver should return a valid
//                                          memory pointer to the top of the
//                                          rectangle specified in rArea. If
//                                          no rectangle is specified, the
//                                          driver should return a pointer to
//                                          the top of the surface. 
//              DDLOCK_WAIT                 This flag is reserved for system
//                                          use and should be ignored by the
//                                          driver. Otherwise performance may
//                                          be adversely hurt.
//              DDLOCK_READONLY             The surface being locked will only
//                                          be read from. On Windows 2000,
//                                          this flag is currently never set.
//              DDLOCK_WRITEONLY            The surface being locked will only
//                                          be written to. On Windows 2000,
//                                          this flag is currently never set.
//              DDLOCK_EVENT                This flag is reserved for system
//                                          use and should be ignored by the
//                                          driver. 
//          FLATPTR
//          fpProcess
//                  Is a pointer to a user-mode mapping of the driver's memory.
//                  The driver performs this mapping in DdMapMemory. 
//  Return Value
//          DdLock returns one of the following callback codes: 
//
//          DDHAL_DRIVER_HANDLED 
//          DDHAL_DRIVER_NOTHANDLED 
//  Comments
//
//      DdLock should set ddRVal to DDERR_WASSTILLDRAWING and return
//      DDHAL_DRIVER_HANDLED if a blt or flip is in progress.
//
//      Unless otherwise specified by dwFlags, the driver can return a memory
//      pointer to the top of the surface in lpSurfData. If the driver needs
//      to calculate its own address for the surface, it can rely on the
//      pointer passed in fpProcess as being a per-process pointer to the
//      user-mode mapping of its DirectDraw-accessible frame buffer.
//
//      A lock does not provide exclusive access to the requested memory block;
//      that is, multiple threads can lock the same surface at the same time.
//      It is the application's responsibility to synchronize access to the 
//      memory block whose pointer is being obtained.
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdLock( 
    LPDDHAL_LOCKDATA lpLockData )
{ 
    HRESULT     ddrval;
    P3_THUNKEDDATA* pThisDisplay;

    GET_THUNKEDDATA(pThisDisplay, lpLockData->lpDD);

    DBG_CB_ENTRY(DdLock);

    VALIDATE_MODE_AND_STATE(pThisDisplay);

    DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, lpLockData->lpDDSurface);   

    //  This call is invoked to lock a DirectDraw Videomemory surface. To make
    //  sure there are no pending drawing operations on the surface, flush all
    //  drawing operations and wait for a flip if it is still pending.
   
    STOP_SOFTWARE_CURSOR(pThisDisplay);

    // Check to see if any pending physical flip has occurred.  
    ddrval = _DX_QueryFlipStatus(pThisDisplay, 
                             lpLockData->lpDDSurface->lpGbl->fpVidMem, 
                             TRUE);    
    if( FAILED(ddrval) )
    {
        lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
        START_SOFTWARE_CURSOR(pThisDisplay);        
        
        DBG_CB_EXIT(DdLock,DDERR_WASSTILLDRAWING);        
        return DDHAL_DRIVER_HANDLED;
    }
    
    // don't allow a lock if a blt is in progress    
    if(DRAW_ENGINE_BUSY(pThisDisplay))
    {
        lpLockData->ddRVal = DDERR_WASSTILLDRAWING;
        START_SOFTWARE_CURSOR(pThisDisplay);        
        
        DBG_CB_EXIT(DdLock, lpLockData->ddRVal);           
        return DDHAL_DRIVER_HANDLED;
    }

#if DX7_TEXMANAGEMENT
    //
    //  If the user attempts to lock a driver managed surface, 
    //  mark it as dirty  and return. This way next time we attempt
    //  to use the surface we will reload it from the sysmem copy
    //
    if (lpLockData->lpDDSurface->lpSurfMore->ddsCapsEx.dwCaps2 & 
        DDSCAPS2_TEXTUREMANAGE)
    {
        DISPDBG((DBGLVL, "DDraw:Lock %08lx %08lx",
                         lpLockData->lpDDSurface->lpSurfMore->dwSurfaceHandle, 
                         lpLockData->lpDDSurface->lpGbl->fpVidMem));

        _D3D_TM_MarkDDSurfaceAsDirty(pThisDisplay, 
                                     lpLockData->lpDDSurface, 
                                     TRUE);

        if (lpLockData->bHasRect)  
        {
#if DX8_3DTEXTURES        
            if (lpLockData->dwFlags & DDLOCK_HASVOLUMETEXTUREBOXRECT)
            {
                DWORD left, right, front, back;            
                // Sub Volume Lock suppport (DX8.1 feature)
                // Check if we are able to lock just a subvolume instead of 
                // the whole volume texture and therefore potentially increase 
                // performance.     

                // left and .right subfields of the rArea field have to be 
                // reinterpreted as also containing respectively the Front and 
                // Back coordinates of the locked volume in their higher 16 bits
                front = lpLockData->rArea.left  >> 16;
                back  = lpLockData->rArea.right >> 16;   
                left  = lpLockData->rArea.left  && 0xFFFF;
                right = lpLockData->rArea.right && 0xFFFF;     

                lpLockData->lpSurfData = (LPVOID)
                    (lpLockData->lpDDSurface->lpGbl->fpVidMem +
                    (front * lpLockData->lpDDSurface->lpGbl->dwBlockSizeY ) +
                    (lpLockData->lpDDSurface->lpGbl->lPitch * 
                                                lpLockData->rArea.top) +    
                    (lpLockData->rArea.left << 
                            DDSurf_GetPixelShift(lpLockData->lpDDSurface)));                
            }
            else
#endif // DX8_3DTEXTURES            
            {           
                lpLockData->lpSurfData = (LPVOID)
                    (lpLockData->lpDDSurface->lpGbl->fpVidMem +
                    (lpLockData->lpDDSurface->lpGbl->lPitch * 
                                                lpLockData->rArea.top) +    
                    (lpLockData->rArea.left << 
                            DDSurf_GetPixelShift(lpLockData->lpDDSurface)));
            }
        }
        else
        {
            lpLockData->lpSurfData = (LPVOID)
                                     (lpLockData->lpDDSurface->lpGbl->fpVidMem);
        }
                                
        lpLockData->ddRVal = DD_OK;

        START_SOFTWARE_CURSOR(pThisDisplay);        

        DBG_CB_EXIT(DdLock, lpLockData->ddRVal);        
        
        return DDHAL_DRIVER_HANDLED;
    }
#endif // DX7_TEXMANAGEMENT  

    // Switch to DirectDraw context
    DDRAW_OPERATION(pContext, pThisDisplay);

    // send a flush and wait for outstanding operations
    // before allowing surfaces to be locked.    
    {P3_DMA_DEFS();
     P3_DMA_GET_BUFFER();
     P3_DMA_FLUSH_BUFFER();
    }

    // Wait for outstanding operations before allowing surfaces to be locked
    SYNC_WITH_GLINT;

    // Since all our surfaces are linear we don't need to do 
    // a patch->unpatch conversion here.

    START_SOFTWARE_CURSOR(pThisDisplay);

    lpLockData->ddRVal = DD_OK;
    DBG_CB_EXIT(DdLock,lpLockData->ddRVal);      

    // Because we correctly set fpVidMem to be the offset into our frame
    // buffer when we created the surface, DirectDraw will automatically take
    // care of adding in the user-mode frame buffer address if we return
    // DDHAL_DRIVER_NOTHANDLED
    
    return(DDHAL_DRIVER_NOTHANDLED);
    
} // DdLock

//-----------------------------Public Routine----------------------------------
//
// DdUnlock
//
// Releases the lock held on the specified surface.
//
// Parameters
//
//      lpUnlock 
//                      Points to a DD_UNLOCKDATA structure that contains the
//                      information required to perform the lock release.
//
// Members
//
//      PDD_DIRECTDRAW_GLOBAL
//      lpDD 
//                  Points to a DD_DIRECTDRAW_GLOBAL structure that
//                  describes the driver.
//      PDD_SURFACE_LOCAL
//      lpDDSurface
//                  Points to a DD_SURFACE_LOCAL structure that describes the
//                  surface to be unlocked. 
//      HRESULT
//      ddRVal
//                  Is the location in which the driver writes the return value
//                  of the DdUnlock callback. A return code of DD_OK indicates
//                  success. 
//      VOID*
//      Unlock
//                  Is unused on Windows 2000. 
//
//  Return Value
//      DdUnlock returns one of the following callback codes: 
//
//      DDHAL_DRIVER_HANDLED 
//      DDHAL_DRIVER_NOTHANDLED 
//
//  Comments
//          The driver does not need to verify that the memory was previously
//          locked down by DdLock, because DirectDraw does parameter validation
//          before calling this routine. 
//-----------------------------------------------------------------------------
DWORD CALLBACK
DdUnlock( 
    LPDDHAL_UNLOCKDATA lpUnlockData )
{ 
    P3_THUNKEDDATA* pThisDisplay;

    DBG_CB_ENTRY(DdUnlock);

    lpUnlockData->ddRVal = DD_OK;

    DBG_CB_EXIT(DdUnlock,lpUnlockData->ddRVal);
    
    return ( DDHAL_DRIVER_HANDLED );

} // DdUnlock


//-----------------------------Public Routine----------------------------------
// DdGetScanLine
//
// Returns the number of the current physical scan line.
//
// Parameters
//      pGetScanLine 
//                      Points to a DD_GETSCANLINEDATA structure in which the
//                      driver returns the number of the current scan line. 
//          Members
//
//          PDD_DIRECTDRAW_GLOBAL
//          lpDD 
//                      Points to a DD_DIRECTDRAW_GLOBAL structure that
//                      represents the driver. 
//          DWORD
//          dwScanLine 
//                      Is the location in which the driver returns the number
//                      of the current scan line. 
//          HRESULT
//          ddRVal 
//                      Is the location in which the driver writes the return
//                      value of the DdGetScanLine callback. A return code of
//                      DD_OK indicates success. 
//          VOID *
//          GetScanLine 
//                      Is unused on Windows 2000. 
// Return Value
//          DdGetScanLine returns one of the following callback codes: 
//
//          DDHAL_DRIVER_HANDLED 
//          DDHAL_DRIVER_NOTHANDLED 
//
// Comments
//          If the monitor is not in vertical blank, the driver should write
//          the scan line value in dwScanLine. The number must be between zero
//          and n, where scan line 0 is the first visible scan line and n is
//          the last visible scan line on the screen. The driver should then
//          set DD_OK in ddRVal and return DDHAL_DRIVER_HANDLED.
//
//          The scan line is indeterminate if a vertical blank is in progress.
//          In this situation, the driver should set ddRVal to
//          DDERR_VERTICALBLANKINPROGRESS and return DDHAL_DRIVER_HANDLED.
//
//-----------------------------------------------------------------------------
DWORD CALLBACK
DdGetScanLine(
    LPDDHAL_GETSCANLINEDATA lpGetScanLine)
{
    P3_THUNKEDDATA* pThisDisplay;

    GET_THUNKEDDATA(pThisDisplay, lpGetScanLine->lpDD);

    DBG_CB_ENTRY(DdGetScanLine);    

    VALIDATE_MODE_AND_STATE(pThisDisplay);

    //
    // If a vertical blank is in progress the scan line is in
    // indeterminant. If the scan line is indeterminant we return
    // the error code DDERR_VERTICALBLANKINPROGRESS.
    // Otherwise we return the scan line and a success code
    //
    if( IN_VBLANK )
    {
        lpGetScanLine->ddRVal = DDERR_VERTICALBLANKINPROGRESS;
        lpGetScanLine->dwScanLine = 0;
    }
    else
    {
        LONG lVBEnd = READ_GLINT_CTRL_REG(VbEnd);
        LONG lScanline = READ_GLINT_CTRL_REG(LineCount);

        // Need to return a number from 0 -> (ScreenHeight + VBlank Size)
        lScanline = lScanline - lVBEnd;
        if (lScanline < 0)
        {
            lScanline = pThisDisplay->dwScreenHeight + (lVBEnd + lScanline);
        }

        // Modes less than 400 high are line-doubled.
        if (pThisDisplay->dwScreenHeight < 400)
        {
            lScanline >>= 1;
        }

        DISPDBG((DBGLVL,"Scanline: %d", lScanline));

        lpGetScanLine->dwScanLine = (DWORD)lScanline;
        lpGetScanLine->ddRVal = DD_OK;
    }

    DBG_CB_EXIT(DdGetScanLine,lpGetScanLine->ddRVal);  
    
    return DDHAL_DRIVER_HANDLED;

} // DdGetScanLine

//-----------------------------Public Routine----------------------------------
// DdGetBltStatus
//
// Queries the blt status of the specified surface.
//
// Parameters
//      lpGetBltStatus 
//                  Points to a DD_GETBLTSTATUSDATA structure that contains the
//                  information required to perform the blt status query. 
//
//          Members
//
//          PDD_DIRECTDRAW_GLOBAL
//          lpDD 
//                              Points to a DD_DIRECTDRAW_GLOBAL structure that
//                              describes the driver. 
//          PDD_SURFACE_LOCAL
//          lpDDSurface 
//                              Points to a DD_SURFACE_LOCAL structure
//                              representing the surface whose blt status is
//                              being queried. 
//          DWORD
//          dwFlags 
//                              Specifies the blt status being requested. This
//                              member can be one of the following values which
//                              are defined in ddraw.h: 
//
//                  DDGBS_CANBLT        Queries whether the driver 
//                                      can currently perform a blit.
//                  DDGBS_ISBLTDONE     Queries whether the driver
//                                      has completed the last blit. 
//          HRESULT
//          ddRVal 
//                              Is the location in which the driver writes the
//                              return value of the DdGetBltStatus callback.
//                              A return code of DD_OK indicates success.
//          VOID*
//          GetBltStatus
//                              Is unused on Windows 2000. 
// Return Value
//          DdGetBltStatus returns one of the following callback codes: 
//
//          DDHAL_DRIVER_HANDLED 
//          DDHAL_DRIVER_NOTHANDLED 
//
// Comments
//          The blt status that the driver returns is based on the dwFlags
//          member of the structure that lpGetBltStatus points to as follows: 
//
//          If the flag is DDGBS_CANBLT, the driver should determine whether
//          the surface is currently involved in a flip. If a flip is not in
//          progress and if the hardware is otherwise capable of currently
//          accepting a blt request, the driver should return DD_OK in ddRVal.
//          If a flip is in progress or if the hardware cannot currently
//          accept another blt request, the driver should set ddRVal to
//          DDERR_WASSTILLDRAWING. 
//
//          If the flag is DDGBS_ISBLTDONE, the driver should set ddRVal to
//          DDERR_WASSTILLDRAWING if a blt is currently in progress; otherwise
//          it should return DD_OK.
//
//
//-----------------------------------------------------------------------------
DWORD CALLBACK DdGetBltStatus(
    LPDDHAL_GETBLTSTATUSDATA lpGetBltStatus )
{
    P3_THUNKEDDATA* pThisDisplay;

    GET_THUNKEDDATA(pThisDisplay, lpGetBltStatus->lpDD);

    DBG_CB_ENTRY(DdGetBltStatus);    

    STOP_SOFTWARE_CURSOR(pThisDisplay);

    // Notice that your implementation could be optimized to check for the
    // particular surface specified. Here we are just querying the general
    // blt status of the engine.

    // Driver is being queried whether it can add a blt
    if( lpGetBltStatus->dwFlags == DDGBS_CANBLT )
    {
        // Must explicitely wait for the flip 
        lpGetBltStatus->ddRVal = 
            _DX_QueryFlipStatus(pThisDisplay, 
                                lpGetBltStatus->lpDDSurface->lpGbl->fpVidMem, 
                                TRUE);
                                
        if( SUCCEEDED( lpGetBltStatus->ddRVal ) )
        {
            // so there was no flip going on, is the engine idle to add a blt?
            if( DRAW_ENGINE_BUSY(pThisDisplay) )
            {
                lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;
            }
            else
            {
                lpGetBltStatus->ddRVal = DD_OK;
            }
        }
    }
    else if ( lpGetBltStatus->dwFlags == DDGBS_ISBLTDONE )
    {
        if ( DRAW_ENGINE_BUSY(pThisDisplay) )
        {
            lpGetBltStatus->ddRVal = DDERR_WASSTILLDRAWING;
        }
        else
        {
            lpGetBltStatus->ddRVal = DD_OK;
        }
    }

    START_SOFTWARE_CURSOR(pThisDisplay);

    DBG_CB_EXIT(DdGetBltStatus, lpGetBltStatus->ddRVal);   
    
    return DDHAL_DRIVER_HANDLED;

} // DdGetBltStatus

//-----------------------------Public Routine----------------------------------
//
// DdGetFlipStatus
//
// Determines whether the most recently requested flip
// on a surface has occurred.
//
// Parameters
//      lpGetFlipStatus 
//                  Points to a DD_GETFLIPSTATUSDATA structure that contains
//                  the information required to perform the flip status query.
//
//          Members
//
//          PDD_DIRECTDRAW_GLOBAL
//          lpDD 
//                          Points to a DD_DIRECTDRAW_GLOBAL structure
//                          representing the driver. 
//          PDD_SURFACE_LOCAL
//          lpDDSurface 
//                          Points to a DD_SURFACE_LOCAL structure that
//                          describes the surface whose flip status is
//                          being queried.
//          DWORD
//          dwFlags 
//                          Specifies the flip status being requested. This
//                          member can be one of the following values which
//                          are defined in ddraw.h: 
//
//                  DDGFS_CANFLIP       Queries whether the driver can
//                                      currently perform a flip. 
//                  DDGFS_ISFLIPDONE    Queries whether the driver has
//                                      finished the last flip. 
//          HRESULT
//          ddRVal 
//                          Is the location in which the driver writes the
//                          return value of the DdGetFlipStatus callback.
//                          A return code of DD_OK indicates success. 
//          VOID*
//          GetFlipStatus 
//                          Is unused on Windows 2000.
//
// Return Value
//          DdGetFlipStatus returns one of the following callback codes: 
//
//          DDHAL_DRIVER_HANDLED 
//          DDHAL_DRIVER_NOTHANDLED 
//
// Comments
//
//          The driver should report its flip status based on the flag set in
//          the dwFlags member of the structure that lpGetFlipStatus points
//          to as follows: 
//
//          If the flag is DDGFS_CANFLIP, the driver should determine whether
//          the surface is currently involved in a flip. If a flip or a blt is
//          not in progress and if the hardware is otherwise capable of
//          currently accepting a flip request, the driver should return DD_OK
//          in ddRVal. If a flip is in progress or if the hardware cannot
//          currently accept a flip request, the driver should set ddRVal to
//          DDERR_WASSTILLDRAWING.
//
//          If the flag is DDGFS_ISFLIPDONE, the driver should set ddRVal to
//          DDERR_WASSTILLDRAWING if a flip is currently in progress; otherwise
//          it should return DD_OK. 
//
// Notes:
//
// If the display has went through one refresh cycle since the flip
// occurred we return DD_OK.  If it has not went through one refresh
// cycle we return DDERR_WASSTILLDRAWING to indicate that this surface
// is still busy "drawing" the flipped page.   We also return
// DDERR_WASSTILLDRAWING if the bltter is busy and the caller wanted
// to know if they could flip yet
// 
// On the Permedia, flips are done using SuspendUntilFrameBlank,
// so no syncs ever need to be done in software, so this always
// returns DD_OK.
//
//-----------------------------------------------------------------------------
DWORD CALLBACK
DdGetFlipStatus(
    LPDDHAL_GETFLIPSTATUSDATA lpGetFlipStatus )
{
    P3_THUNKEDDATA* pThisDisplay;

    GET_THUNKEDDATA(pThisDisplay, lpGetFlipStatus->lpDD);

    DBG_CB_ENTRY(DdGetFlipStatus);     

    STOP_SOFTWARE_CURSOR(pThisDisplay);

    //
    // don't want a flip to work until after the last flip is done,
    // so we ask for the general flip status and ignore the vmem
    //
    lpGetFlipStatus->ddRVal = _DX_QueryFlipStatus(pThisDisplay, 0, TRUE);

    //
    // check if the bltter busy if someone wants to know if they can flip
    //
    if( lpGetFlipStatus->dwFlags == DDGFS_CANFLIP )
    {
        if( ( SUCCEEDED( lpGetFlipStatus->ddRVal ) ) && 
            ( DRAW_ENGINE_BUSY(pThisDisplay) )     )
        {
            lpGetFlipStatus->ddRVal = DDERR_WASSTILLDRAWING;
        }
    }

    START_SOFTWARE_CURSOR(pThisDisplay);

    DBG_CB_EXIT(DdGetFlipStatus,lpGetFlipStatus->ddRVal);   
    
    return DDHAL_DRIVER_HANDLED;
    

} // DdGetFlipStatus


//-----------------------------------------------------------------------------
// __SetupRops
//
// Build array for supported ROPS
//-----------------------------------------------------------------------------
static void 
__SetupRops( 
    LPBYTE proplist, 
    LPDWORD proptable, 
    int cnt )
{
    int         i;
    DWORD       idx;
    DWORD       bit;
    DWORD       rop;

    for(i=0; i<cnt; i++)
    {
        rop = proplist[i];
        idx = rop / 32; 
        bit = 1L << ((DWORD)(rop % 32));
        proptable[idx] |= bit;
    }

} // __SetupRops 


//-----------------------------------------------------------------------------
//
// ChangeDDHAL32Mode
//
// CALLED PER MODE CHANGE - NEVER AT START OF DAY (NO LOCK)
// Sets up Chip registers for this mode.
//
//-----------------------------------------------------------------------------
void 
ChangeDDHAL32Mode(
    P3_THUNKEDDATA* pThisDisplay)
{

    DISPDBG((DBGLVL,"New Screen Width: %d",pThisDisplay->dwScreenWidth));

//@@BEGIN_DDKSPLIT            
#if AZN  
    // If the driver has just started, reset the DMA Buffers to a known state.
    if (pThisDisplay->bStartOfDay)
    {
#if 0
        unsigned long i;

        for (i = 0; i < pThisDisplay->pGLInfo->NumberOfSubBuffers; i++)
        {
            pThisDisplay->pGLInfo->DMAPartition[i].bStampedDMA = TRUE;
            pThisDisplay->pGLInfo->DMAPartition[i].Locked = FALSE;
          
//azn - this is hard to say in 64 bits!
            memset((void*)pThisDisplay->pGLInfo->DMAPartition[i].VirtAddr, 
                   0x4D,
                   (pThisDisplay->pGLInfo->DMAPartition[i].MaxAddress - 
                            pThisDisplay->pGLInfo->DMAPartition[i].VirtAddr));

        }
#endif
        // We don't need start of day setup anymore
        pThisDisplay->bStartOfDay = FALSE;
    }
#endif
//@@END_DDKSPLIT    

    STOP_SOFTWARE_CURSOR(pThisDisplay);

    // Switch to DirectDraw context
    DDRAW_OPERATION(pContext, pThisDisplay);

    // Set up video Control
#if WNT_DDRAW 
    {
        ULONG vidCon;
        
        vidCon = READ_GLINT_CTRL_REG(VideoControl);
        vidCon &= ~(3 << 9);
        vidCon |= (0 << 9);     // P3/P2 Limit to frame rate

        LOAD_GLINT_CTRL_REG(VideoControl, vidCon);
    }
#endif // WNT_DDRAW 

    // We have handled the display mode change
    pThisDisplay->bResetMode = 0;
    pThisDisplay->ModeChangeCount++;

    START_SOFTWARE_CURSOR(pThisDisplay);

}  // ChangeDDHAL32Mode


//-----------------------------------------------------------------------------
//
// Function: __GetDDHALInfo
//
// Returns: void
//
// Description:
//
// Takes a pointer to a partially or fully filled in pThisDisplay and a pointer
// to an empty DDHALINFO and fills in the DDHALINFO.  This eases porting to NT
// and means that caps changes are done in only one place.  The pThisDisplay
// may not be fully constructed here, so you should only:
// a) Query the registry
// b) DISPDBG
// If you need to add anything to pThisDisplay for NT, you should fill it in 
// during the DrvGetDirectDraw call.
//
// The problem here is when the code is run on NT.  If there was any other way...
//
// The following caps have been found to cause NT to bail....
// DDCAPS_GDI, DDFXCAPS_BLTMIRRORUPDOWN, DDFXCAPS_BLTMIRRORLEFTRIGHT
//
//
//-----------------------------------------------------------------------------

//
// use bits to indicate which ROPs you support.
//
// DWORD 0, bit 0 == ROP 0
// DWORD 8, bit 31 == ROP 255
//

static DWORD ropsAGP[DD_ROP_SPACE] = { 0 }; 

void 
__GetDDHALInfo(
    P3_THUNKEDDATA* pThisDisplay, 
    DDHALINFO* pHALInfo)
{
    DWORD dwResult;
    BOOL bRet;
    int i;

    static BYTE ropList95[] =
    {
        SRCCOPY >> 16,
        WHITENESS >> 16,
        BLACKNESS >> 16
    };

    static BYTE ropListNT[] =
    {
        SRCCOPY >> 16
    };

    static BYTE ropListAGP[] = 
    {
        SRCCOPY >> 16,
        WHITENESS >> 16,
        BLACKNESS >> 16
    };    

    static DWORD rops[DD_ROP_SPACE] = { 0 };  
      
    // Setup the HAL driver caps.
    memset( pHALInfo, 0, sizeof(DDHALINFO) );
    pHALInfo->dwSize = sizeof(DDHALINFO);


    // Setup the ROPS we do.
#ifdef WNT_DDRAW
    __SetupRops( ropListNT, 
                 rops, 
                 sizeof(ropListNT)/sizeof(ropListNT[0]));
#else
    __SetupRops( ropList95, 
                 rops, 
                 sizeof(ropList95)/sizeof(ropList95[0]));
#endif

    __SetupRops( ropListAGP, 
                 ropsAGP, 
                 sizeof(ropListAGP)/sizeof(ropListAGP[0]));

    // The most basic DirectDraw functionality
    pHALInfo->ddCaps.dwCaps =   DDCAPS_BLT          |
                                DDCAPS_BLTQUEUE     |
                                DDCAPS_BLTCOLORFILL |
                                DDCAPS_READSCANLINE;

    pHALInfo->ddCaps.ddsCaps.dwCaps =   DDSCAPS_OFFSCREENPLAIN |
                                        DDSCAPS_PRIMARYSURFACE |
                                        DDSCAPS_FLIP;

    // More caps on Win95 than on NT (mainly for D3D)
#ifdef WNT_DDRAW
    pHALInfo->ddCaps.dwCaps |= DDCAPS_3D           | 
                               DDCAPS_BLTDEPTHFILL;
                               
    pHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_3DDEVICE | 
                                       DDSCAPS_ZBUFFER | 
                                       DDSCAPS_ALPHA;
    pHALInfo->ddCaps.dwCaps2 = 0;
#else
    pHALInfo->ddCaps.dwCaps |=  DDCAPS_3D          |
                                DDCAPS_GDI         |
                                DDCAPS_ALPHA       |
                                DDCAPS_BLTDEPTHFILL;

    pHALInfo->ddCaps.ddsCaps.dwCaps |=  DDSCAPS_ALPHA    |
                                        DDSCAPS_3DDEVICE |
                                        DDSCAPS_ZBUFFER;
    
    pHALInfo->ddCaps.dwCaps2 = DDCAPS2_NOPAGELOCKREQUIRED | DDCAPS2_FLIPNOVSYNC;

#endif // WNT_DDRAW

#if DX7_TEXMANAGEMENT
    // We need to set this bit up in order to be able to do
    // out own texture management
    pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_CANMANAGETEXTURE;
#if DX8_DDI
    pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_CANMANAGERESOURCE;
#endif
#endif

#if DX8_DDI
    // We need to flag we can run in windowed mode, otherwise we
    // might get restricted by apps to run in fullscreen only
    pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_CANRENDERWINDOWED;  
#endif    

    pHALInfo->ddCaps.dwFXCaps = 0;
 
    // P3RX can do:
    // 1. Stretching/Shrinking
    // 2. YUV->RGB conversion
    // 3. Mirroring in X and Y
    // 4. ColorKeying from a source color and a source color space
    pHALInfo->ddCaps.dwCaps |= DDCAPS_BLTSTRETCH   |
                               DDCAPS_BLTFOURCC    |
                               DDCAPS_COLORKEY     |
                               DDCAPS_CANBLTSYSMEM;

    // Special effects caps
    pHALInfo->ddCaps.dwFXCaps = DDFXCAPS_BLTSTRETCHY  |
                                DDFXCAPS_BLTSTRETCHX  |
                                DDFXCAPS_BLTSTRETCHYN |
                                DDFXCAPS_BLTSTRETCHXN |
                                DDFXCAPS_BLTSHRINKY   |
                                DDFXCAPS_BLTSHRINKX   |
                                DDFXCAPS_BLTSHRINKYN  |
                                DDFXCAPS_BLTSHRINKXN;

    // ColorKey caps
    pHALInfo->ddCaps.dwCKeyCaps = DDCKEYCAPS_SRCBLT         |  
                                  DDCKEYCAPS_SRCBLTCLRSPACE |
                                  DDCKEYCAPS_DESTBLT        | 
                                  DDCKEYCAPS_DESTBLTCLRSPACE;

    pHALInfo->ddCaps.dwSVBCaps = DDCAPS_BLT;

    // We can do a texture from sysmem to video mem.
    pHALInfo->ddCaps.dwSVBCKeyCaps = DDCKEYCAPS_DESTBLT         | 
                                     DDCKEYCAPS_DESTBLTCLRSPACE;
    pHALInfo->ddCaps.dwSVBFXCaps = 0;

    // Fill in the sysmem->vidmem rops (only can copy);
    for( i=0;i<DD_ROP_SPACE;i++ )
    {
        pHALInfo->ddCaps.dwSVBRops[i] = rops[i];
    }

    pHALInfo->ddCaps.dwFXCaps |= DDFXCAPS_BLTMIRRORUPDOWN  |
                                DDFXCAPS_BLTMIRRORLEFTRIGHT;

    pHALInfo->ddCaps.dwCKeyCaps |=  DDCKEYCAPS_SRCBLTCLRSPACEYUV;

    pHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_TEXTURE;

#if DX7_STEREO
    // Report the stereo capability back to runtime
    pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_STEREO;
    pHALInfo->ddCaps.dwSVCaps = DDSVCAPS_STEREOSEQUENTIAL;
#endif

    // Z Buffer is only 16 Bits
    pHALInfo->ddCaps.dwZBufferBitDepths = DDBD_16;
    pHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_MIPMAP;

    if (pThisDisplay->bCanAGP && (pThisDisplay->dwDXVersion > DX5_RUNTIME))
    {
        pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_NONLOCALVIDMEM;
        pHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_LOCALVIDMEM   | 
                                           DDSCAPS_NONLOCALVIDMEM;
            
        // We support the hybrid AGP model.  This means we have 
        // specific things we can do from AGP->Video  memory, but 
        // we can also texture directly from AGP memory
        pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_NONLOCALVIDMEMCAPS;
    }
    else
    {
        DISPDBG((WRNLVL,"P3 Board is NOT AGP"));
    }
    
    // If we are a P3 we can do videoports 
    if (RENDERCHIP_PERMEDIAP3)
    {
#ifdef SUPPORT_VIDEOPORT
        // We support 1 video port.  Must set CurrVideoPorts to 0
        // We can't do interleaved bobbing yet - maybe in the future.
        pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_VIDEOPORT            | 
                                    DDCAPS2_CANBOBNONINTERLEAVED;

        pHALInfo->ddCaps.dwMaxVideoPorts = 1;
        pHALInfo->ddCaps.dwCurrVideoPorts = 0;

#if W95_DDRAW
        pHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_VIDEOPORT;
#endif // W95_DDRAW

#endif // SUPPORT_VIDEOPORT


        if ( ( ( pThisDisplay->pGLInfo->dwFlags & GMVF_DFP_DISPLAY ) != 0 ) &&
             ( ( pThisDisplay->pGLInfo->dwScreenWidth != 
                 pThisDisplay->pGLInfo->dwVideoWidth ) ||
               ( pThisDisplay->pGLInfo->dwScreenHeight != 
                 pThisDisplay->pGLInfo->dwVideoHeight ) ) )
        {
            // Display driver is using the overlay to show the 
            // picture - disable the overlay.
            pHALInfo->ddCaps.dwMaxVisibleOverlays = 0;
            pHALInfo->ddCaps.dwCurrVisibleOverlays = 0;
        }
#if WNT_DDRAW
        else if (pThisDisplay->ppdev->flCaps & CAPS_DISABLE_OVERLAY)
#else
        else if (pThisDisplay->pGLInfo->dwFlags & GMVF_DISABLE_OVERLAY)
#endif
        {
            // Overlays not supported in hw
            pHALInfo->ddCaps.dwMaxVisibleOverlays = 0;
            pHALInfo->ddCaps.dwCurrVisibleOverlays = 0;            
        }

        else        
        {
            // Overlay is free to use.
            pHALInfo->ddCaps.dwMaxVisibleOverlays = 1;
            pHALInfo->ddCaps.dwCurrVisibleOverlays = 0;

            pHALInfo->ddCaps.dwCaps |=  DDCAPS_OVERLAY          |
                                        DDCAPS_OVERLAYFOURCC    |
                                        DDCAPS_OVERLAYSTRETCH   | 
                                        DDCAPS_COLORKEYHWASSIST |
                                        DDCAPS_OVERLAYCANTCLIP;

            pHALInfo->ddCaps.dwCKeyCaps |= DDCKEYCAPS_SRCOVERLAY           |
                                           DDCKEYCAPS_SRCOVERLAYONEACTIVE  |
                                           DDCKEYCAPS_SRCOVERLAYYUV        |
                                           DDCKEYCAPS_DESTOVERLAY          |
                                           DDCKEYCAPS_DESTOVERLAYONEACTIVE |
                                           DDCKEYCAPS_DESTOVERLAYYUV;

            pHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_OVERLAY;

            pHALInfo->ddCaps.dwFXCaps |= DDFXCAPS_OVERLAYSHRINKX   |
                                         DDFXCAPS_OVERLAYSHRINKXN  |
                                         DDFXCAPS_OVERLAYSHRINKY   |
                                         DDFXCAPS_OVERLAYSHRINKYN  |
                                         DDFXCAPS_OVERLAYSTRETCHX  |
                                         DDFXCAPS_OVERLAYSTRETCHXN |
                                         DDFXCAPS_OVERLAYSTRETCHY  |
                                         DDFXCAPS_OVERLAYSTRETCHYN;

            // Indicates that Perm3 has no stretch ratio limitation
            pHALInfo->ddCaps.dwMinOverlayStretch = 1;
            pHALInfo->ddCaps.dwMaxOverlayStretch = 32000;
        }
    }

#ifdef W95_DDRAW
    // Enable colour control asc brightness, contrast, gamma.
    pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_COLORCONTROLPRIMARY;    
#endif    

    // Also permit surfaces wider than the display buffer.
    pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_WIDESURFACES;

    // Enable copy blts betweemn Four CC formats for DShow acceleration
    pHALInfo->ddCaps.dwCaps2 |= DDCAPS2_COPYFOURCC;
    
    // Won't do Video-Sys mem Blits. 
    pHALInfo->ddCaps.dwVSBCaps = 0;
    pHALInfo->ddCaps.dwVSBCKeyCaps = 0;
    pHALInfo->ddCaps.dwVSBFXCaps = 0;
    for( i=0;i<DD_ROP_SPACE;i++ )
    {
        pHALInfo->ddCaps.dwVSBRops[i] = 0;
    }

    // Won't do Sys-Sys mem Blits
    pHALInfo->ddCaps.dwSSBCaps = 0;
    pHALInfo->ddCaps.dwSSBCKeyCaps = 0;
    pHALInfo->ddCaps.dwSSBFXCaps = 0;
    for( i=0;i<DD_ROP_SPACE;i++ )
    {
        pHALInfo->ddCaps.dwSSBRops[i] = 0;
    }

    //
    // bit depths supported for alpha and Z
    //

    pHALInfo->ddCaps.dwAlphaBltConstBitDepths = DDBD_2 | 
                                                DDBD_4 | 
                                                DDBD_8;
                                                
    pHALInfo->ddCaps.dwAlphaBltPixelBitDepths = DDBD_1 | 
                                                DDBD_8;
    pHALInfo->ddCaps.dwAlphaBltSurfaceBitDepths = DDBD_1 | 
                                                  DDBD_2 | 
                                                  DDBD_4 | 
                                                  DDBD_8;
                                                  
    // No alpha blending for overlays, so I'm not sure what these should be.
    // Because we support 32bpp overlays, it's just that you can't use the
    // alpha bits for blending. Pass.
    pHALInfo->ddCaps.dwAlphaBltConstBitDepths = DDBD_2 | 
                                                DDBD_4 | 
                                                DDBD_8;
                                                
    pHALInfo->ddCaps.dwAlphaBltPixelBitDepths = DDBD_1 | 
                                                DDBD_8;
                                                
    pHALInfo->ddCaps.dwAlphaBltSurfaceBitDepths = DDBD_1 | 
                                                  DDBD_2 | 
                                                  DDBD_4 | 
                                                  DDBD_8;

    //
    // ROPS supported
    //
    for( i=0;i<DD_ROP_SPACE;i++ )
    {
        pHALInfo->ddCaps.dwRops[i] = rops[i];
    }

#if W95_DDRAW
    // Reset to NULL for debugging
    pThisDisplay->lpD3DGlobalDriverData = 0;
    ZeroMemory(&pThisDisplay->DDExeBufCallbacks, 
               sizeof(DDHAL_DDEXEBUFCALLBACKS));
    
    // Note that the NT code does this elsewhere
    _D3DHALCreateDriver(
            pThisDisplay);
            // (LPD3DHAL_GLOBALDRIVERDATA*)&pThisDisplay->lpD3DGlobalDriverData,
            // (LPD3DHAL_CALLBACKS*) &pThisDisplay->lpD3DHALCallbacks,
            // &pThisDisplay->DDExeBufCallbacks);

    // If we filled in the execute buffer callbacks, set the cap bit
    if (pThisDisplay->DDExeBufCallbacks.dwSize != 0)
    {
        pHALInfo->ddCaps.ddsCaps.dwCaps |= DDSCAPS_EXECUTEBUFFER;
    }
#endif

    // For DX5 and beyond we support this new informational callback.
    pHALInfo->GetDriverInfo = DdGetDriverInfo;
    pHALInfo->dwFlags |= DDHALINFO_GETDRIVERINFOSET;

#if DX8_DDI
    // Flag our support for a new class of GUIDs that may come through
    // GetDriverInfo for DX8 drivers. (This support will be compulsory)
    pHALInfo->dwFlags |= DDHALINFO_GETDRIVERINFO2;
#endif DX8_DDI    


} // __GetDDHALInfo

static HashTable* g_pDirectDrawLocalsHashTable = NULL; // azn

//-----------------------------------------------------------------------------
//
// _DD_InitDDHAL32Bit
//
// CALLED ONCE AT START OF DAY
// No Chip register setup is done here - it is all handled in the mode
// change code.  DO NOT DO IT HERE - THERE IS NO WIN16LOCK AT THIS TIME!!!
//
//-----------------------------------------------------------------------------
BOOL 
_DD_InitDDHAL32Bit(
    P3_THUNKEDDATA* pThisDisplay)
{
    BOOL bRet;
    DWORD Result;
    LPGLINTINFO pGLInfo = pThisDisplay->pGLInfo;

    ASSERTDD(pGLInfo != NULL, "ERROR: pGLInfo not valid!");

    // Note: Can't use P3_DMA_DEFS macro here, as pGlint isn't initialised yet.

    DISPDBG((DBGLVL, "** In _DD_InitDDHAL32Bit, pGlint 0x%x", 
                     pThisDisplay->control));
    DISPDBG((DBGLVL, "Sizeof DDHALINFO: %d", (int) sizeof(DDHALINFO)));

    // Force D3D to setup surface offsets as if a flip had happened 
    pThisDisplay->bFlippedSurface = TRUE;
   
    // A flag to say that the driver is essentially at the start of day. This 
    // is set to let later calls in the driver know that they have work to do.
    pThisDisplay->bStartOfDay = TRUE;
    
#if W95_DDRAW
    // At start of day the videoport is dead to the world
    pThisDisplay->VidPort.bActive = FALSE;
#endif  //      W95_DDRAW

    // Reset the GART copies.
    pThisDisplay->dwGARTLin = 0;
    pThisDisplay->dwGARTDev = 0;
    pThisDisplay->dwGARTLinBase = 0;
    pThisDisplay->dwGARTDevBase = 0;

    pThisDisplay->pGlint = (FPGLREG)pThisDisplay->control;

    // Set up the global overlay data
    pThisDisplay->bOverlayVisible                   = (DWORD)FALSE;
    pThisDisplay->OverlayDstRectL                   = 0;
    pThisDisplay->OverlayDstRectR                   = 0;
    pThisDisplay->OverlayDstRectT                   = 0;
    pThisDisplay->OverlayDstRectB                   = 0;
    pThisDisplay->OverlaySrcRectL                   = 0;
    pThisDisplay->OverlaySrcRectR                   = 0;
    pThisDisplay->OverlaySrcRectT                   = 0;
    pThisDisplay->OverlaySrcRectB                   = 0;
    pThisDisplay->OverlayDstSurfLcl                 = (ULONG_PTR)NULL;
    pThisDisplay->OverlaySrcSurfLcl                 = (ULONG_PTR)NULL;
    pThisDisplay->OverlayDstColourKey               = CLR_INVALID;
    pThisDisplay->OverlaySrcColourKey               = CLR_INVALID;
    pThisDisplay->OverlayClipRgnMem                 = (ULONG_PTR)NULL;
    pThisDisplay->OverlayClipRgnMemSize             = 0;
    pThisDisplay->OverlayUpdateCountdown    = 0;
    pThisDisplay->bOverlayFlippedThisVbl    = (DWORD)FALSE;
    pThisDisplay->bOverlayUpdatedThisVbl    = (DWORD)FALSE;
    pThisDisplay->OverlayTempSurf.VidMem    = (ULONG_PTR)NULL;
    pThisDisplay->OverlayTempSurf.Pitch             = (DWORD)0;

#if W95_DDRAW
    // Set up colour control data.
    pThisDisplay->ColConBrightness = 0;
    pThisDisplay->ColConContrast = 10000;
    pThisDisplay->ColConGamma = 100;
#endif // W95_DDRAW

#if DX7_VIDMEM_VB
    // Set up DrawPrim temporary index buffer.
    pThisDisplay->DrawPrimIndexBufferMem            = (ULONG_PTR)NULL;
    pThisDisplay->DrawPrimIndexBufferMemSize        = 0;
    pThisDisplay->DrawPrimVertexBufferMem           = (ULONG_PTR)NULL;
    pThisDisplay->DrawPrimVertexBufferMemSize       = 0;
#endif // DX7_VIDMEM_VB

    // Set up current RenderID to be as far away from a "sensible"
    // value as possible. Hopefully, if the context switch fails and
    // someone starts using it for something else, these values and 
    // the ones they use will be very different, and various asserts 
    // will scream immediately.
    
    // Also, say that the RenderID is invalid, because we have not actually
    // set up the chip. The context switch should set up & flush the
    // chip, and then it will set bRenderIDValid to TRUE.
    // Loads of asserts throughout the code will scream if something
    // doesn't do the setup & flush for some reason.
    pThisDisplay->dwRenderID            = 0x8eaddead | RENDER_ID_KNACKERED_BITS;
    pThisDisplay->dwLastFlipRenderID    = 0x8eaddead | RENDER_ID_KNACKERED_BITS;
    pThisDisplay->bRenderIDValid = (DWORD)FALSE;

#if W95_DDRAW

    // Create a shared heap
    if (g_DXGlobals.hHeap32 == 0)
        g_DXGlobals.hHeap32 = (DWORD)HeapCreate( HEAP_SHARED, 2500, 0);

#endif // W95_DDRAW
    
    // Make sure we're running the right chip. If not, STOP.
    ASSERTDD((RENDERCHIP_P3RXFAMILY),"ERROR: Invalid RENDERFAMILY!!");

    // Dump some debugging information 
    DISPDBG((DBGLVL, "************* _DD_InitDDHAL32Bit *************************************" ));
    DISPDBG((DBGLVL, "    dwScreenFlatAddr=%08lx", pThisDisplay->dwScreenFlatAddr ));
    DISPDBG((DBGLVL, "    dwScreenStart =%08lx", pThisDisplay->dwScreenStart));
    DISPDBG((DBGLVL, "    dwLocalBuffer=%08lx", pThisDisplay->dwLocalBuffer ));
    DISPDBG((DBGLVL, "    dwScreenWidth=%08lx", pThisDisplay->dwScreenWidth ));
    DISPDBG((DBGLVL, "    dwScreenHeight=%08lx", pThisDisplay->dwScreenHeight ));
    DISPDBG((DBGLVL, "    bReset=%08lx", pThisDisplay->bResetMode ));
    DISPDBG((DBGLVL, "    dwRGBBitCount=%ld", pThisDisplay->ddpfDisplay.dwRGBBitCount ));
    DISPDBG((DBGLVL, "    pGLInfo=%08lp", pGLInfo ));
    DISPDBG((DBGLVL, "    Render:  0x%x, Rev:0x%x", pGLInfo->dwRenderChipID,  pGLInfo->dwRenderChipRev));
#if W95_DDRAW
    DISPDBG((DBGLVL, "    Support: 0x%x, Rev:0x%x", pGLInfo->dwSupportChipID, pGLInfo->dwSupportChipRev));
    DISPDBG((DBGLVL, "    Board:   0x%x, Rev:0x%x", pGLInfo->dwBoardID, pGLInfo->dwBoardRev));
    // DISPDBG((DBGLVL, "    BF Size: 0x%x, LB Depth:0x%x", pGLInfo->cBlockFillSize, pGLInfo->cLBDepth));
#endif  //      W95_DDRAW
    DISPDBG((DBGLVL, "    FB Size: 0x%x", pGLInfo->ddFBSize));
    DISPDBG((DBGLVL, "    RMask:   0x%x", pThisDisplay->ddpfDisplay.dwRBitMask ));
    DISPDBG((DBGLVL, "    GMask:   0x%x", pThisDisplay->ddpfDisplay.dwGBitMask ));
    DISPDBG((DBGLVL, "    BMask:   0x%x", pThisDisplay->ddpfDisplay.dwBBitMask ));
    DISPDBG((DBGLVL, "******************************************************************" ));

    // Allocate a DMA buffer for the DX driver
    HWC_AllocDMABuffer(pThisDisplay);

#define SURFCB pThisDisplay->DDSurfCallbacks
#define HALCB pThisDisplay->DDHALCallbacks

    // Fill in the HAL Callback pointers    
    memset(&HALCB, 0, sizeof(DDHAL_DDCALLBACKS));
    HALCB.dwSize = sizeof(DDHAL_DDCALLBACKS);

    // Field the HAL DDraw callbacks we support
    HALCB.CanCreateSurface = DdCanCreateSurface;
    HALCB.CreateSurface = DdCreateSurface;
    HALCB.WaitForVerticalBlank = DdWaitForVerticalBlank;
    HALCB.GetScanLine = DdGetScanLine;
    
#if WNT_DDRAW
    HALCB.MapMemory = DdMapMemory;
#else    
    HALCB.DestroyDriver = DdDestroyDriver;   // Only on Win95.
#endif // WNT_DDRAW
    
    HALCB.dwFlags = DDHAL_CB32_WAITFORVERTICALBLANK |
#if WNT_DDRAW
                    DDHAL_CB32_MAPMEMORY            |
#else  // WNT_DDRAW
                    DDHAL_CB32_DESTROYDRIVER        |
#endif
                    DDHAL_CB32_GETSCANLINE          | 
                    DDHAL_CB32_CANCREATESURFACE     |
                    DDHAL_CB32_CREATESURFACE;

    // Fill in the Surface Callback pointers
    memset(&SURFCB, 0, sizeof(DDHAL_DDSURFACECALLBACKS));
    SURFCB.dwSize = sizeof(DDHAL_DDSURFACECALLBACKS);

    // Field the Ddraw Surface callbacks we support    
    SURFCB.DestroySurface = DdDestroySurface;
    SURFCB.Lock = DdLock;
    SURFCB.Unlock = DdUnlock;
    SURFCB.GetBltStatus = DdGetBltStatus;
    SURFCB.GetFlipStatus = DdGetFlipStatus;
    SURFCB.SetColorKey = DdSetColorKey;
    SURFCB.Flip = DdFlip;
    SURFCB.Blt = DdBlt;

    SURFCB.dwFlags = DDHAL_SURFCB32_DESTROYSURFACE     |
                     DDHAL_SURFCB32_FLIP               |
                     DDHAL_SURFCB32_LOCK               |
                     DDHAL_SURFCB32_BLT                |
                     DDHAL_SURFCB32_GETBLTSTATUS       |
                     DDHAL_SURFCB32_GETFLIPSTATUS      |
                     DDHAL_SURFCB32_SETCOLORKEY        |
                     DDHAL_SURFCB32_UNLOCK;            

    pThisDisplay->hInstance = g_DXGlobals.hInstance;

#if WNT_DDRAW
    if (0 == (pThisDisplay->ppdev->flCaps & CAPS_DISABLE_OVERLAY))
#else
    if (0 == (pThisDisplay->pGLInfo->dwFlags & GMVF_DISABLE_OVERLAY))
#endif
    {
        SURFCB.UpdateOverlay = DdUpdateOverlay;   // Now supporting overlays.
        SURFCB.SetOverlayPosition = DdSetOverlayPosition;
        SURFCB.dwFlags |=
                         DDHAL_SURFCB32_UPDATEOVERLAY      | // Now supporting 
                         DDHAL_SURFCB32_SETOVERLAYPOSITION ; // overlays. 
    }
    
    

    // Fill in the DDHAL Informational caps
    __GetDDHALInfo(pThisDisplay, &pThisDisplay->ddhi32);

    // Create/get DD locals hash table to store our DX surface handles
//@@BEGIN_DDKSPLIT
    // azn
    // We need to move this creation/destruction of g_pDirectDrawLocalsHashTable
    // into DrvEnableDriver and DrvDisableDriver and maybe maintain a Ref count
    // as we might be running on a multi-Perm3 machine.
//@@END_DDKSPLIT
    if (g_pDirectDrawLocalsHashTable == NULL) 
    {
        DISPDBG((DBGLVL,"pDirectDrawLocalsHashTable CREATED"));    
        g_pDirectDrawLocalsHashTable = 
        pThisDisplay->pDirectDrawLocalsHashTable = HT_CreateHashTable();    
    }
    else
    {
        DISPDBG((DBGLVL,"Hash table for DirectDraw locals already exists"));
        pThisDisplay->pDirectDrawLocalsHashTable = 
                                                g_pDirectDrawLocalsHashTable;
    }       

    if (pThisDisplay->pDirectDrawLocalsHashTable == NULL)
    {
        return (FALSE);
    }

    HT_SetDataDestroyCallback(pThisDisplay->pDirectDrawLocalsHashTable, 
                              _D3D_SU_DirectDrawLocalDestroyCallback);

#if W95_DDRAW
    if ( g_DXGlobals.hHeap32 == 0 )
    {
        return ( FALSE );
    }
    else
    {
        return ( TRUE );
    }
#endif

    return (TRUE);
    
} // _DD_InitDDHAL32Bit 


#if DX7_STEREO
//-----------------------------------------------------------------------------
//
//  _DD_bIsStereoMode
//
//  Decide if mode can be displayed as stereo mode. Here we limit stereo
//  modes so that two front and two backbuffers can be created for rendering.
//
//-----------------------------------------------------------------------------

BOOL 
_DD_bIsStereoMode(
    P3_THUNKEDDATA* pThisDisplay, 
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwBpp)
{
    DWORD dwLines;

    // we need to check dwBpp for a valid value as PDD_STEREOMODE.dwBpp is a
    // parameter passed on from the user mode API call and which is expected
    // to have the values 8,16,24,32 (though we don't really support 24bpp)
    if ((dwWidth >= 320) && (dwHeight >= 240) &&
        ((dwBpp == 8) || (dwBpp == 16) || (dwBpp == 24) || (dwBpp ==32) ) )
    {
        // This the total number of "lines" that fit in our available vidmem
        // at the given width and pixel format
        dwLines = pThisDisplay->pGLInfo->ddFBSize / (dwWidth*dwBpp/8);

        // Here we limit stereo modes so that two front and two backbuffers 
        // can be created for rendering.
        if (dwLines > (dwHeight*4))
        {
            return TRUE;
        }
    }

    return FALSE;
}
#endif // DX7_STEREO


#ifdef WNT_DDRAW
typedef DD_NONLOCALVIDMEMCAPS DDNONLOCALVIDMEMCAPS;
#else
#define DD_MISCELLANEOUSCALLBACKS DDHAL_DDMISCELLANEOUSCALLBACKS
#endif

//-----------------------------Public Routine----------------------------------
//
// DdGetDriverInfo
//
// Queries the driver for additional information about itself.
//
// Parameters
//      lpGetDriverInfo 
//              Points to a DD_GETDRIVERINFODATA structure that contains the
//              information required to perform the query. 
//
//      Members
//
//          VOID *
//          dphdev 
//                      Is a handle to the driver's PDEV. 
//          DWORD
//          dwSize 
//                      Specifies the size in bytes of this
//                      DD_GETDRIVERINFODATA structure.
//          DWORD
//          dwFlags 
//                      Is currently unused and is set to zero. 
//          GUID
//          guidInfo 
//                      Specifies the GUID of the DirectX support for which the
//                      driver is being queried. In a Windows 2000 DirectDraw
//                      driver, this member can be one of the following values
//                      (in alphabetic order):
//
//              GUID_ColorControlCallbacks  Queries whether the driver supports
//                                          DdControlColor. If the driver does
//                                          support it, the driver should
//                                          initialize and return a
//                                          DD_COLORCONTROLCALLBACKS structure
//                                          in the buffer to which lpvData
//                                          points.
//              GUID_D3DCallbacks           Queries whether the driver supports
//                                          any of the functionality specified
//                                          through the D3DNTHAL_CALLBACKS
//                                          structure. If the driver does not
//                                          provide any of this support, it
//                                          should initialize and return a
//                                          D3DNTHAL_CALLBACKS structure in
//                                          the buffer to which lpvData points 
//              GUID_D3DCallbacks2          Obsolete. 
//              GUID_D3DCallbacks3          Queries whether the driver supports
//                                          any of the functionality specified
//                                          through the D3DNTHAL_CALLBACKS3
//                                          structure. If the driver does provide
//                                          any of this support, it should
//                                          initialize and return a
//                                          D3DNTHAL_CALLBACKS3 structure in
//                                          the buffer to which lpvData points.
//              GUID_D3DCaps                Obsolete.
//              GUID_D3DExtendedCaps        Queries whether the driver supports
//                                          any of the Direct3D functionality
//                                          specified through the
//                                          D3DNTHAL_D3DEXTENDEDCAPS structure.
//                                          If the driver does provide any of
//                                          this support, it should initialize
//                                          and return a
//                                          D3DNTHAL_D3DEXTENDEDCAPS structure
//                                          in the buffer to which lpvData
//                                          points. 
//              GUID_D3DParseUnknownCommandCallback     Provides the Direct3D
//                                          portion of the driver with the
//                                          Direct3D runtime's
//                                          D3dParseUnknownCommandCallback.
//                                          The driver's D3dDrawPrimitives2
//                                          callback calls
//                                          D3dParseUnknownCommandCallback
//                                          to parse commands from the
//                                          command buffer that the driver
//                                          doesn't understand. 
//                                          DirectDraw passes a pointer to this 
//                                          function in the buffer to which 
//                                          lpvData points. If the driver 
//                                          supports this aspect of Direct3D, 
//                                          it should store the pointer. 
//              GUID_GetHeapAlignment       Queries whether the driver supports 
//                                          surface alignment requirements on a 
//                                          per-heap basis. If the driver does 
//                                          provide this support, it should 
//                                          initialize and return a 
//                                          DD_GETHEAPALIGNMENTDATA structure 
//                                          in the buffer to which lpvData 
//                                          points. 
//              GUID_KernelCallbacks        Queries whether the driver supports 
//                                          any of the functionality specified 
//                                          through the DD_KERNELCALLBACKS 
//                                          structure. If the driver does 
//                                          provide any of this support, it 
//                                          should initialize and return a 
//                                          DD_KERNELCALLBACKS structure in the 
//                                          buffer to which lpvData points. 
//              GUID_KernelCaps             Queries whether the driver supports 
//                                          any of the kernel-mode capabilities 
//                                          specified through the DDKERNELCAPS 
//                                          structure. If the driver does 
//                                          provide any of this support, it 
//                                          should initialize and return a 
//                                          DDKERNELCAPS structure in the buffer 
//                                          to which lpvData points. 
//              GUID_MiscellaneousCallbacks Queries whether the driver supports 
//                                          DdGetAvailDriverMemory. If the 
//                                          driver does support it, the driver 
//                                          should initialize and return a 
//                                          DD_MISCELLANEOUSCALLBACKS structure 
//                                          in the buffer to which lpvData 
//                                          points. 
//              GUID_Miscellaneous2Callbacks   Queries whether the driver 
//                                          supports the additional miscellaneous 
//                                          functionality specified in the 
//                                          DD_MISCELLANEOUS2CALLBACKS structure. 
//                                          If the driver does support any of 
//                                          this support, the driver should 
//                                          initialize and return a 
//                                          DD_MISCELLANEOUS2CALLBACKS structure 
//                                          in the buffer to which lpvData 
//                                          points. 
//              GUID_MotionCompCallbacks    Queries whether the driver supports 
//                                          the motion compensation 
//                                          functionality specified through the 
//                                          DD_MOTIONCOMPCALLBACKS structure. 
//                                          If the driver does provide any of 
//                                          this support, is should initialize 
//                                          and return a DD_MOTIONCOMPCALLBACKS 
//                                          structure in the buffer to which 
//                                          lpvData points. 
//              GUID_NonLocalVidMemCaps     Queries whether the driver supports 
//                                          any of the nonlocal display memory 
//                                          capabilities specified through the 
//                                          DD_NONLOCALVIDMEMCAPS structure. 
//                                          If the driver does provide any of 
//                                          this support, it should initialize 
//                                          and return a DD_NONLOCALVIDMEMCAPS 
//                                          structure in the buffer to which 
//                                          lpvData points. 
//              GUID_NTCallbacks            Queries whether the driver supports 
//                                          any of the functionality specified 
//                                          through the DD_NTCALLBACKS structure. 
//                                          If the driver does provide any of 
//                                          this support, it should initialize 
//                                          and return a DD_NTCALLBACKS 
//                                          structure in the buffer to which 
//                                          lpvData points. 
//              GUID_NTPrivateDriverCaps    Queries whether the driver supports 
//                                          the Windows 95/ Windows 98-style 
//                                          surface creation techniques 
//                                          specified through the 
//                                          DD_NTPRIVATEDRIVERCAPS structure. 
//                                          If the driver does provide any of 
//                                          this support, it should initialize 
//                                          and return a DD_NTPRIVATEDRIVERCAPS 
//                                          structure in the buffer to which 
//                                          lpvData points. 
//              GUID_UpdateNonLocalHeap     Queries whether the driver supports 
//                                          retrieval of the base addresses of 
//                                          each nonlocal heap in turn. If the 
//                                          driver does provide this support, 
//                                          it should initialize and return a 
//                                          DD_UPDATENONLOCALHEAPDATA structure 
//                                          in the buffer to which lpvData 
//                                          points. 
//              GUID_VideoPortCallbacks     Queries whether the driver supports 
//                                          the video port extensions (VPE). If 
//                                          the driver does support VPE, it 
//                                          should initialize and return a 
//                                          DD_VIDEOPORTCALLBACKS structure in 
//                                          the buffer to which lpvData points. 
//              GUID_VideoPortCaps          Queries whether the driver supports 
//                                          any of the VPE object capabilities 
//                                          specified through the DDVIDEOPORTCAPS 
//                                          structure. If the driver does provide 
//                                          any of this support, it should 
//                                          initialize and return a 
//                                          DDVIDEOPORTCAPS structure in the 
//                                          buffer to which lpvData points. 
//              GUID_ZPixelFormats          Queries the pixel formats supported 
//                                          by the depth buffer. If the driver 
//                                          supports Direct3D, it should allocate 
//                                          and initialize the appropriate 
//                                          members of a DDPIXELFORMAT structure 
//                                          for every z-buffer format that it 
//                                          supports and return these in the 
//                                          buffer to which lpvData points. 
//
//      DWORD
//      dwExpectedSize 
//                  Specifies the number of bytes of data that DirectDraw
//                  expects the driver to pass back in the buffer to which
//                  lpvData points. 
//      PVOID
//      lpvData 
//                  Points to a DirectDraw-allocated buffer into which the
//                  driver copies the requested data. This buffer is
//                  typically dwExpectedSize bytes in size. The driver must
//                  not write more than dwExpectedSize bytes of data in it. 
//      DWORD
//      dwActualSize 
//                  Is the location in which the driver returns the number
//                  of bytes of data it writes in lpvData. 
//      HRESULT
//      ddRVal 
//                  Specifies the driver's return value. 
//
// Return Value
//      DdGetDriverInfo must return DDHAL_DRIVER_HANDLED.
//
// Comments
//
//      Drivers must implement DdGetDriverInfo to expose driver-supported
//      DirectDraw functionality that is not returnable through
//      DrvEnableDirectDraw.
//
//      The driver's DrvGetDirectDrawInfo function returns a pointer to
//      DdGetDriverInfo in the GetDriverInfo member of the DD_HALINFO structure.
//
//      To inform DirectDraw that the DdGetDriverInfo member has been set
//      correctly, the driver must also set the DDHALINFO_GETDRIVERINFOSET bit
//      of dwFlags in the DD_HALINFO structure. 
//
//      DdGetDriverInfo should determine whether the driver and its hardware
//      support the callbacks or capabilities requested by the specified GUID.
//      For all GUIDs except GUID_D3DParseUnknownCommandCallback, if the driver
//      does provide the requested support, it should set the following members
//      of the DD_GETDRIVERINFODATA structure: 
//
//      Set dwActualSize to be the size in bytes of the callback or capability
//      structure being returned by the driver.
//
//      In the memory that lpvData points to, initialize the members of the
//      callback or capability structure that corresponds with the requested
//      feature as follows: 
//
//      Set the dwSize member to be the size in bytes of the structure. 
//
//      For callbacks, set the function pointers to point to those callbacks
//      implemented by the driver, and set the bits in the dwFlags member to
//      indicate which functions the driver supports. 
//
//      For capabilities, set the appropriate members of the capability
//      structure with values supported by the driver/device. 
//
//  Return DD_OK in ddRVal. 
//      If the driver does not support the feature, it should set ddRVal
//      to DDERR_CURRENTLYNOTAVAIL and return.
//
//      DirectDraw informs the driver of the expected amount of data in the
//      dwExpectedSize member of the DD_GETDRIVERINFODATA structure. The
//      driver must not fill in more data than dwExpectedSize bytes.
//
//  To avoid problems using DdGetDriverInfo: 
//
//  Do not implement dependencies based on the order in which DdGetDriverInfo 
//  is called. For example, avoid hooking driver initialization steps into 
//  DdGetDriverInfo. 
//
//  Do not try to ascertain the DirectDraw version based on the calls to 
//  DdGetDriverInfo. 
//
//  Do not assume anything about the number of times DirectDraw will call the 
//  driver, or the number of times DirectDraw will query a given GUID. It is 
//  possible that DirectDraw will probe the driver repeatedly with the same 
//  GUID. Implementing assumptions about this in the driver hampers its 
//  compatibility with future runtimes. 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdGetDriverInfo(
    LPDDHAL_GETDRIVERINFODATA lpData)
{
    DWORD dwSize;
    P3_THUNKEDDATA* pThisDisplay;

#if WNT_DDRAW
    pThisDisplay = (P3_THUNKEDDATA*)(((PPDEV)(lpData->dhpdev))->thunkData);
#else    
    pThisDisplay = (P3_THUNKEDDATA*)lpData->dwContext;
    if (! pThisDisplay) 
    {
        pThisDisplay = g_pDriverData;
    }
#endif
    
    DBG_CB_ENTRY(DdGetDriverInfo);

    // Default to 'not supported'
    lpData->ddRVal = DDERR_CURRENTLYNOTAVAIL;

    //------------------------------------
    // Process any D3D related GUIDs here
    //------------------------------------
    _D3DGetDriverInfo(lpData);


    //------------------------------------
    // any other GUIDS are handled here
    //------------------------------------
    if (MATCH_GUID((lpData->guidInfo), GUID_MiscellaneousCallbacks) )
    {        
        DD_MISCELLANEOUSCALLBACKS MISC_CB;
        
        DISPDBG((DBGLVL,"  GUID_MiscellaneousCallbacks"));

        memset(&MISC_CB, 0, sizeof(DD_MISCELLANEOUSCALLBACKS));
        MISC_CB.dwSize = sizeof(DD_MISCELLANEOUSCALLBACKS);

#if W95_DDRAW
        MISC_CB.GetHeapAlignment = DdGetHeapAlignment;
        MISC_CB.dwFlags = DDHAL_MISCCB32_GETHEAPALIGNMENT;

        // Setup the AGP callback if running on an AGP board.
        if ((pThisDisplay->dwDXVersion > DX5_RUNTIME) && 
             pThisDisplay->bCanAGP)
        {
            MISC_CB.dwFlags |= DDHAL_MISCCB32_UPDATENONLOCALHEAP;
            MISC_CB.UpdateNonLocalHeap = DdUpdateNonLocalHeap;
        }
#endif // W95_DDRAW
        
        MISC_CB.dwFlags |= DDHAL_MISCCB32_GETAVAILDRIVERMEMORY;
        MISC_CB.GetAvailDriverMemory = DdGetAvailDriverMemory;
    
        // Copy the filled in structure into the  passed data area
        dwSize = min(lpData->dwExpectedSize , sizeof(MISC_CB));
        lpData->dwActualSize = sizeof(MISC_CB);
        memcpy(lpData->lpvData, &MISC_CB, dwSize );
        lpData->ddRVal = DD_OK;
    }

#if WNT_DDRAW
    if (MATCH_GUID((lpData->guidInfo), GUID_UpdateNonLocalHeap))
    {
        // On NT kernels the AGP heap details are passed into the driver 
        // here, rather than through a seperate callback.
        if (pThisDisplay->bCanAGP)
        {
            DDHAL_UPDATENONLOCALHEAPDATA* plhd;
        
            DISPDBG((DBGLVL, "  GUID_UpdateNonLocalHeap"));

            plhd = (DDHAL_UPDATENONLOCALHEAPDATA*)lpData->lpvData;

            // Fill in the base pointers
            pThisDisplay->dwGARTDevBase = (DWORD)plhd->fpGARTDev;
            pThisDisplay->dwGARTLinBase = (DWORD)plhd->fpGARTLin;
        
            // Fill in the changeable base pointers.
            pThisDisplay->dwGARTDev = pThisDisplay->dwGARTDevBase;
            pThisDisplay->dwGARTLin = pThisDisplay->dwGARTLinBase;

            lpData->ddRVal = DD_OK;
        }
    }
#endif // WNT_DDRAW

    if (MATCH_GUID((lpData->guidInfo), GUID_NonLocalVidMemCaps) &&
        (pThisDisplay->bCanAGP))
    {
        int i;

        DDNONLOCALVIDMEMCAPS NLVCAPS;

        DISPDBG((DBGLVL,"  GUID_NonLocalVidMemCaps"));

        if (lpData->dwExpectedSize != sizeof(DDNONLOCALVIDMEMCAPS) ) 
        {
            DISPDBG((ERRLVL,"ERROR: NON-Local vidmem caps size incorrect!"));
            DBG_CB_EXIT(DdGetDriverInfo, lpData->ddRVal );            
            return DDHAL_DRIVER_HANDLED;
        }

        // The flag D3DDEVCAPS_TEXTURENONLOCALVIDMEM in the D3D caps 
        // indicates that although we are exposing DMA-Model AGP, we
        // can still texture directly from AGP memory.
        memset(&NLVCAPS, 0, sizeof(DDNONLOCALVIDMEMCAPS));
        NLVCAPS.dwSize = sizeof(DDNONLOCALVIDMEMCAPS);
        
        NLVCAPS.dwNLVBCaps = DDCAPS_BLT        | 
                             DDCAPS_ALPHA      |
                             DDCAPS_BLTSTRETCH |
                             DDCAPS_BLTQUEUE   |
                             DDCAPS_BLTFOURCC  |
                             DDCAPS_COLORKEY   |
                             DDCAPS_CANBLTSYSMEM;
                             
        NLVCAPS.dwNLVBCaps2 = DDCAPS2_WIDESURFACES;
        
        NLVCAPS.dwNLVBCKeyCaps = DDCKEYCAPS_SRCBLT         | 
                                 DDCKEYCAPS_SRCBLTCLRSPACE |
                                 DDCKEYCAPS_DESTBLT        | 
                                 DDCKEYCAPS_DESTBLTCLRSPACE;
                                 
        NLVCAPS.dwNLVBFXCaps = DDFXCAPS_BLTSTRETCHY  |
                               DDFXCAPS_BLTSTRETCHX  |
                               DDFXCAPS_BLTSTRETCHYN |
                               DDFXCAPS_BLTSTRETCHXN |
                               DDFXCAPS_BLTSHRINKY   |
                               DDFXCAPS_BLTSHRINKX   |
                               DDFXCAPS_BLTSHRINKYN  |
                               DDFXCAPS_BLTSHRINKXN;

        for( i=0;i<DD_ROP_SPACE;i++ )
        {
            NLVCAPS.dwNLVBRops[i] = ropsAGP[i];
        }

        // Copy the filled in structure into the passed data area
        dwSize = min( lpData->dwExpectedSize, sizeof(DDNONLOCALVIDMEMCAPS));
        lpData->dwActualSize = sizeof(DDNONLOCALVIDMEMCAPS);       
        memcpy(lpData->lpvData, &NLVCAPS, dwSize );        
        lpData->ddRVal = DD_OK;
    }

//@@BEGIN_DDKSPLIT
#ifdef SUPPORT_VIDEOPORT
#if W95_DDRAW
    // Fill in the VideoPort callbacks
    if (MATCH_GUID((lpData->guidInfo), GUID_VideoPortCallbacks) )
    {
        DDHAL_DDVIDEOPORTCALLBACKS VIDCB;

        DISPDBG((DBGLVL,"  GUID_VideoPortCallbacks"));

        memset(&VIDCB, 0, sizeof(DDHAL_DDVIDEOPORTCALLBACKS));
        VIDCB.dwSize = sizeof(DDHAL_DDVIDEOPORTCALLBACKS);
        VIDCB.CanCreateVideoPort = DdCanCreateVideoPort;
        VIDCB.CreateVideoPort = DdCreateVideoPort;
        VIDCB.FlipVideoPort = DdFlipVideoPort;
        VIDCB.GetVideoPortBandwidth = DdGetVideoPortBandwidth;
        VIDCB.GetVideoPortInputFormats = DdGetVideoPortInputFormats;
        VIDCB.GetVideoPortOutputFormats = DdGetVideoPortOutputFormats;
        VIDCB.GetVideoPortField = DdGetVideoPortField;
        VIDCB.GetVideoPortLine = DdGetVideoPortLine;
        VIDCB.GetVideoPortConnectInfo = DDGetVideoPortConnectInfo;
        VIDCB.DestroyVideoPort = DdDestroyVideoPort;
        VIDCB.GetVideoPortFlipStatus = DdGetVideoPortFlipStatus;
        VIDCB.UpdateVideoPort = DdUpdateVideoPort;
        VIDCB.WaitForVideoPortSync = DdWaitForVideoPortSync;
        VIDCB.GetVideoSignalStatus = DdGetVideoSignalStatus;

        VIDCB.dwFlags = DDHAL_VPORT32_CANCREATEVIDEOPORT |
                        DDHAL_VPORT32_CREATEVIDEOPORT    |
                        DDHAL_VPORT32_DESTROY            |
                        DDHAL_VPORT32_FLIP               |
                        DDHAL_VPORT32_GETBANDWIDTH       |
                        DDHAL_VPORT32_GETINPUTFORMATS    |
                        DDHAL_VPORT32_GETOUTPUTFORMATS   | 
                        DDHAL_VPORT32_GETFIELD           |
                        DDHAL_VPORT32_GETLINE            |
                        DDHAL_VPORT32_GETFLIPSTATUS      |
                        DDHAL_VPORT32_UPDATE             |
                        DDHAL_VPORT32_WAITFORSYNC        |
                        DDHAL_VPORT32_GETCONNECT         |
                        DDHAL_VPORT32_GETSIGNALSTATUS;
        
        // Copy the filled in structure into the 
        // passed data area
        dwSize = lpData->dwExpectedSize;
        if ( sizeof(VIDCB) < dwSize )
        {
            dwSize = sizeof(VIDCB);
        }
        lpData->dwActualSize = sizeof(VIDCB);
        memcpy(lpData->lpvData, &VIDCB, dwSize );
        lpData->ddRVal = DD_OK;
    }

    // Fill in the VideoPortCaps
    if (MATCH_GUID((lpData->guidInfo), GUID_VideoPortCaps) )
    {
        DDVIDEOPORTCAPS VIDCAPS;

        DISPDBG((DBGLVL,"  GUID_VideoPortCaps"));

        if (lpData->dwExpectedSize != sizeof(VIDCAPS) )
        {
            DISPDBG((ERRLVL,"ERROR: VIDCAPS size incorrect"));
            DBG_CB_EXIT(DdGetDriverInfo, lpData->ddRVal );              
            return DDHAL_DRIVER_HANDLED;
        }

        // Now fill in the videoport description (it's easier if it's on
        // the 32 bit side..)
        VIDCAPS.dwSize = sizeof(DDVIDEOPORTCAPS);
        VIDCAPS.dwFlags = DDVPD_ALIGN    | 
                          DDVPD_AUTOFLIP | 
                          DDVPD_WIDTH    |  
                          DDVPD_HEIGHT   | 
                          DDVPD_FX       | 
                          DDVPD_CAPS;
        VIDCAPS.dwMaxWidth = 2048;
        VIDCAPS.dwMaxVBIWidth = 2048;
        VIDCAPS.dwMaxHeight = 2048;
        VIDCAPS.dwVideoPortID = 0;

        VIDCAPS.dwCaps = DDVPCAPS_AUTOFLIP       | 
                         DDVPCAPS_NONINTERLACED  | 
                         DDVPCAPS_INTERLACED     | 
                         DDVPCAPS_READBACKFIELD  |
                         DDVPCAPS_READBACKLINE   | 
                         DDVPCAPS_SKIPEVENFIELDS | 
                         DDVPCAPS_SKIPODDFIELDS  | 
                         DDVPCAPS_VBISURFACE     | 
                         DDVPCAPS_OVERSAMPLEDVBI; 
        
        VIDCAPS.dwFX = DDVPFX_CROPX           |   
                       DDVPFX_CROPY           | 
                       DDVPFX_INTERLEAVE      | 
                       DDVPFX_MIRRORLEFTRIGHT |
                       DDVPFX_MIRRORUPDOWN    | 
                       DDVPFX_PRESHRINKXB     | 
                       DDVPFX_VBICONVERT      | 
                       DDVPFX_VBINOSCALE      | 
                       DDVPFX_PRESHRINKYB     | 
                       DDVPFX_IGNOREVBIXCROP;
        
        VIDCAPS.dwNumAutoFlipSurfaces = 2;
        VIDCAPS.dwAlignVideoPortBoundary = 4;
        VIDCAPS.dwAlignVideoPortPrescaleWidth = 4;
        VIDCAPS.dwAlignVideoPortCropBoundary = 4;
        VIDCAPS.dwAlignVideoPortCropWidth = 4;
        VIDCAPS.dwPreshrinkXStep = 1;
        VIDCAPS.dwPreshrinkYStep = 1;

        lpData->dwActualSize = sizeof(VIDCAPS);
        memcpy(lpData->lpvData, &VIDCAPS, sizeof(VIDCAPS) );
        lpData->ddRVal = DD_OK;
    }

    // Fill in the kernel Callbacks
    if (MATCH_GUID((lpData->guidInfo), GUID_KernelCallbacks) )
    {
        DDHAL_DDKERNELCALLBACKS KERNCB;

        DISPDBG((DBGLVL,"  GUID_KernelCallbacks"));

        memset(&KERNCB, 0, sizeof(DDHAL_DDKERNELCALLBACKS));

        KERNCB.dwSize = sizeof(KERNCB);
        KERNCB.SyncSurfaceData = DdSyncSurfaceData;
        KERNCB.SyncVideoPortData = DdSyncVideoPortData;
        
        KERNCB.dwFlags = DDHAL_KERNEL_SYNCSURFACEDATA |
                         DDHAL_KERNEL_SYNCVIDEOPORTDATA;

        dwSize = lpData->dwExpectedSize;
        if ( sizeof(KERNCB) < dwSize )
        {
            dwSize = sizeof(KERNCB);
        }
        lpData->dwActualSize = sizeof(KERNCB);
        memcpy(lpData->lpvData, &KERNCB, dwSize );
        lpData->ddRVal = DD_OK;
    }

    // Fill in the kernel caps
    if (MATCH_GUID((lpData->guidInfo), GUID_KernelCaps) )
    {
        DDKERNELCAPS KERNCAPS;

        DISPDBG((DBGLVL,"  GUID_KernelCaps"));

        if (lpData->dwExpectedSize != sizeof(DDKERNELCAPS) ) 
        {
            DISPDBG((ERRLVL,"ERROR: Kernel caps structure invalid size!"));
            return DDHAL_DRIVER_HANDLED;
        }

        ZeroMemory(&KERNCAPS, sizeof(KERNCAPS));
        KERNCAPS.dwSize = sizeof(KERNCAPS);
        KERNCAPS.dwCaps = DDKERNELCAPS_LOCK        | 
                          DDKERNELCAPS_FLIPOVERLAY | 
                          DDKERNELCAPS_SETSTATE;
    
        if (!(pThisDisplay->pGLInfo->dwFlags & GMVF_NOIRQ))
        {
            KERNCAPS.dwCaps |= DDKERNELCAPS_CAPTURE_SYSMEM | 
                               DDKERNELCAPS_FIELDPOLARITY  | 
                               DDKERNELCAPS_SKIPFIELDS     | 
                               DDKERNELCAPS_FLIPVIDEOPORT  | 
                               DDKERNELCAPS_AUTOFLIP;

            KERNCAPS.dwIRQCaps = DDIRQ_VPORT0_VSYNC  | 
                                 DDIRQ_DISPLAY_VSYNC | 
                                 DDIRQ_BUSMASTER;
        }
                            
        lpData->dwActualSize = sizeof(DDKERNELCAPS);
        memcpy(lpData->lpvData, &KERNCAPS, sizeof(DDKERNELCAPS) );
        lpData->ddRVal = DD_OK;
    }

#endif // W95_DDRAW
#endif // SUPPORT_VIDEOPORT
//@@END_DDKSPLIT

#ifdef W95_DDRAW
#ifdef USE_DD_CONTROL_COLOR
    // Fill in the colour control callbacks.
    if (MATCH_GUID((lpData->guidInfo), GUID_ColorControlCallbacks) )
    {
        DDHAL_DDCOLORCONTROLCALLBACKS ColConCB;

        DISPDBG((DBGLVL,"  GUID_ColorControlCallbacks"));

        memset(&ColConCB, 0, sizeof(ColConCB));
        ColConCB.dwSize = sizeof(ColConCB);
        ColConCB.dwFlags = DDHAL_COLOR_COLORCONTROL;
        ColConCB.ColorControl = DdControlColor;

        dwSize = min( lpData->dwExpectedSize, sizeof(ColConCB));
        lpData->dwActualSize = sizeof(ColConCB);
        memcpy(lpData->lpvData, &ColConCB, dwSize);
        lpData->ddRVal = DD_OK;
    }
#endif
#endif

#if !defined(_WIN64) && WNT_DDRAW
    // Fill in the NT specific callbacks
    if (MATCH_GUID((lpData->guidInfo), GUID_NTCallbacks) )
    {
        DD_NTCALLBACKS NtCallbacks;

        memset(&NtCallbacks, 0, sizeof(NtCallbacks));

        dwSize = min(lpData->dwExpectedSize, sizeof(DD_NTCALLBACKS));

        NtCallbacks.dwSize           = dwSize;
        NtCallbacks.dwFlags          = DDHAL_NTCB32_FREEDRIVERMEMORY |
                                       DDHAL_NTCB32_SETEXCLUSIVEMODE |
                                       DDHAL_NTCB32_FLIPTOGDISURFACE;

        NtCallbacks.FreeDriverMemory = DdFreeDriverMemory;
        NtCallbacks.SetExclusiveMode = DdSetExclusiveMode;
        NtCallbacks.FlipToGDISurface = DdFlipToGDISurface;

        memcpy(lpData->lpvData, &NtCallbacks, dwSize);
        lpData->ddRVal = DD_OK;
    }
#endif

#if DX7_STEREO
    if (MATCH_GUID((lpData->guidInfo), GUID_DDMoreSurfaceCaps) )
    {
#if WNT_DDRAW
        DD_MORESURFACECAPS DDMoreSurfaceCaps;
#else
        DDMORESURFACECAPS DDMoreSurfaceCaps;
#endif
        DDSCAPSEX   ddsCapsEx, ddsCapsExAlt;
        ULONG ulCopyPointer;

        DISPDBG((DBGLVL,"  GUID_DDMoreSurfaceCaps"));

        // fill in everything until expectedsize...
        memset(&DDMoreSurfaceCaps, 0, sizeof(DDMoreSurfaceCaps));

        // Caps for heaps 2..n
        memset(&ddsCapsEx, 0, sizeof(ddsCapsEx));
        memset(&ddsCapsExAlt, 0, sizeof(ddsCapsEx));

        DDMoreSurfaceCaps.dwSize=lpData->dwExpectedSize;

        if (_DD_bIsStereoMode(pThisDisplay,
                              pThisDisplay->dwScreenWidth,
                              pThisDisplay->dwScreenHeight,
                              pThisDisplay->ddpfDisplay.dwRGBBitCount))
        {
            DDMoreSurfaceCaps.ddsCapsMore.dwCaps2 =
                DDSCAPS2_STEREOSURFACELEFT;
        }
        lpData->dwActualSize = lpData->dwExpectedSize;

        dwSize = min(sizeof(DDMoreSurfaceCaps),lpData->dwExpectedSize);
        memcpy(lpData->lpvData, &DDMoreSurfaceCaps, dwSize);

        // Now fill in ddsCapsEx and ddsCapsExAlt heaps
        // Hardware with different restrictions for different heaps
        // should prepare ddsCapsEx and ddsCapsExAlt carefully and
        // fill them into lpvData in proper order
        while (dwSize < lpData->dwExpectedSize)
        {
            memcpy( (PBYTE)lpData->lpvData+dwSize,
                    &ddsCapsEx,
                    sizeof(DDSCAPSEX));
            dwSize += sizeof(DDSCAPSEX);
            memcpy( (PBYTE)lpData->lpvData+dwSize,
                    &ddsCapsExAlt,
                    sizeof(DDSCAPSEX));
            dwSize += sizeof(DDSCAPSEX);
        }

        lpData->ddRVal = DD_OK;
    }
#endif // DX7_STEREO

    // We always handled it.
    DBG_CB_EXIT(DdGetDriverInfo, lpData->ddRVal );      
    return DDHAL_DRIVER_HANDLED;
    
} // DdGetDriverInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\d3dtxt.c ===
/******************************Module*Header**********************************\
*
*                           *******************
*                           * D3D SAMPLE CODE *
*                           *******************
*
* Module Name: d3dtxt.c
*
*  Content: D3D texture setup
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "dma.h"
#include "chroma.h"
#include "tag.h"

//-----------------------------------------------------------------------------

// Some variables shared through this module (not globals)
// These are set up in _D3DChangeTextureP3RX.

// P3 has 16 texture map base address slots, numbered 0 to 15 hence ...
#define P3_TEX_MAP_MAX_LEVEL    15

typedef struct
{
    DWORD dwTex0MipBase;
    DWORD dwTex0MipMax;
    DWORD dwTex0ActMaxLevel; // Controlled by D3DTSS_MAXMIPLEVEL, default 0
    DWORD dwTex1MipBase;
    DWORD dwTex1MipMax;
    DWORD dwTex1ActMaxLevel; // Same for Texture 1
} P3_MIP_BASES;

#define TSSTATE(stageno,argno)        \
                        ( pContext->TextureStageState[stageno].m_dwVal[argno] )
#define TSSTATESELECT(stageno,argno)  \
                            ( TSSTATE(stageno,argno) & D3DTA_SELECTMASK )
#define TSSTATEINVMASK(stageno,argno) \
                            ( TSSTATE(stageno,argno) & ~D3DTA_COMPLEMENT )
#define TSSTATEALPHA(stageno,argno)   \
                            ( TSSTATE(stageno,argno)  & ~D3DTA_ALPHAREPLICATE )

#define IS_ALPHA_ARG 1
#define IS_COLOR_ARG 0


#if DX8_DDI
//-----------------------------------------------------------------------------
//
// __TXT_MapDX8toDX6TexFilter
//
// map DX8 enums into DX6(&7) texture filtering enums 
//
//-----------------------------------------------------------------------------
DWORD
__TXT_MapDX8toDX6TexFilter( DWORD dwStageState, DWORD dwValue )
{
    switch (dwStageState)
    {
    case D3DTSS_MAGFILTER:
        switch (dwValue)
        {
        case D3DTEXF_POINT            : return D3DTFG_POINT;
        case D3DTEXF_LINEAR           : return D3DTFG_LINEAR;
        case D3DTEXF_FLATCUBIC        : return D3DTFG_FLATCUBIC;
        case D3DTEXF_GAUSSIANCUBIC    : return D3DTFG_GAUSSIANCUBIC;
        case D3DTEXF_ANISOTROPIC      : return D3DTFG_ANISOTROPIC;
        }
        break;
    case D3DTSS_MINFILTER:
        switch (dwValue)
        {
        case D3DTEXF_POINT            : return D3DTFN_POINT;
        case D3DTEXF_LINEAR           : return D3DTFN_LINEAR;
        case D3DTEXF_FLATCUBIC        : return D3DTFN_ANISOTROPIC;
        }
        break;
    case D3DTSS_MIPFILTER:
        switch (dwValue)
        {
        case D3DTEXF_NONE             : return D3DTFP_NONE;
        case D3DTEXF_POINT            : return D3DTFP_POINT;
        case D3DTEXF_LINEAR           : return D3DTFP_LINEAR;
        }
        break;
    }
    return 0x0;
} // __TXT_MapDX8toDX6TexFilter
#endif // DX8_DDI

//-----------------------------------------------------------------------------
//
// _D3D_TXT_ParseTextureStageStates
//
// Parse the texture state stages command token and update our context state
//
// Note : bTranslateDX8FilterValueToDX6 will only be FALSE when it is called
//        from _D3D_SB_ExecuteStateSet if that state set's value has been 
//        changes by _D3D_SB_CaptureStateSet (Basically DX6 filter values are
//        stored in the state set directly, thus no need to translate them.)
//
//-----------------------------------------------------------------------------
void 
_D3D_TXT_ParseTextureStageStates(
    P3_D3DCONTEXT* pContext, 
    D3DHAL_DP2TEXTURESTAGESTATE *pState, 
    DWORD dwCount,
    BOOL bTranslateDX8FilterValueToDX6)
{
    DWORD i;
    DWORD dwStage, dwState, dwValue;
    
    DISPDBG((DBGLVL,"*** In _D3D_TXT_ParseTextureStageStates"));

    for (i = 0; i < dwCount; i++, pState++)
    {
        dwStage = pState->wStage;
        dwState = pState->TSState;
        dwValue = pState->dwValue;
      
        // check for range before continuing
        if ( (dwStage < D3DHAL_TSS_MAXSTAGES) &&
             (dwState < D3DTSS_MAX))
        {

#if DX7_D3DSTATEBLOCKS 
            if (pContext->bStateRecMode)
            {
                // Record this texture stage state into the 
                //current state set being recorded 
                _D3D_SB_RecordStateSetTSS(pContext, dwStage, dwState, dwValue);

                // skip any further processing and go to the next TSS
                continue;
            }
#endif //DX7_D3DSTATEBLOCKS       

#if DX7_TEXMANAGEMENT
            if ((D3DTSS_TEXTUREMAP == dwState) && (0 != dwValue))
            {
                P3_SURF_INTERNAL* pTexture;

                pTexture = GetSurfaceFromHandle(pContext, dwValue);

                // If this is a valid managed texture
                if (CHECK_SURF_INTERNAL_AND_DDSURFACE_VALIDITY(pTexture) &&
                    (pTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)) 
                {
                    // Update stats
                    _D3D_TM_STAT_Inc_NumTexturesUsed(pContext);
                    _D3D_TM_STAT_Inc_NumUsedTexInVid(pContext, pTexture);
                }
            }
#endif // DX7_TEXMANAGEMENT  

            DISPDBG((DBGLVL,"  Stage = %d, State = 0x%x, Value = 0x%x", 
                               dwStage, dwState, dwValue));

            // Special case a texture handle change and the address update
            switch ( dwState )
            {
            case D3DTSS_TEXTUREMAP:
                DISPDBG((DBGLVL,"  D3DTSS_TEXTUREMAP: Handle=0x%x", dwValue));

                if (pContext->TextureStageState[dwStage].m_dwVal[dwState] != 
                                                                       dwValue)
                {
                    pContext->TextureStageState[dwStage].m_dwVal[dwState] = 
                                                                        dwValue;
                    DIRTY_TEXTURE(pContext);
                }
                break;

            case D3DTSS_ADDRESS:
                DISPDBG((DBGLVL,"  D3DTSS_ADDRESS"));
                // map single set ADDRESS to both U and V controls
                pContext->TextureStageState[dwStage].m_dwVal[D3DTSS_ADDRESSU] = 
                pContext->TextureStageState[dwStage].m_dwVal[D3DTSS_ADDRESSV] = 
                pContext->TextureStageState[dwStage].m_dwVal[dwState] = dwValue;

                DIRTY_TEXTURE(pContext);
                break;
                
            case D3DTSS_COLOROP:
            case D3DTSS_ALPHAOP:
            case D3DTSS_COLORARG1:
            case D3DTSS_COLORARG2:
            case D3DTSS_ALPHAARG1:
            case D3DTSS_ALPHAARG2:
                pContext->TextureStageState[dwStage].m_dwVal[dwState] = dwValue;
                pContext->Flags &= ~SURFACE_MODULATE;
                DIRTY_TEXTURESTAGEBLEND(pContext);
                DIRTY_TEXTURE(pContext);
                break;
                
            case D3DTSS_TEXCOORDINDEX:
                DISPDBG((DBGLVL,"  D3DTSS_TEXCOORDINDEX: stage %d, value %d", 
                            dwStage, dwValue ));
                pContext->TextureStageState[dwStage].m_dwVal[dwState] = dwValue;
                
                // Update the offsets to the texture coordinates                                         
                // NOTE: The texture coordinate index can contain various flags
                // in addition to the actual value. These flags are:
                //     D3DTSS_TCI_PASSTHRU (default - resolves to zero)
                //     D3DTSS_TCI_CAMERASPACENORMAL 
                //     D3DTSS_TCI_CAMERASPACEPOSITION 
                //     D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR 
                // and are used for texture coordinate generation.
                //
                // These flags are not relevant when considering the offset of
                // texture coordinates in the vertex stream. These flags appear
                // in the high word of the index value DWORD. Only the low word
                // contains actual index data. Therefore, we will mask of the
                // low word when looking up the offset table for this texture
                // coordinate index.
                pContext->FVFData.dwTexOffset[dwStage] = 
                    pContext->FVFData.dwTexCoordOffset[dwValue & 0x0000FFFFul];
                    
                DIRTY_TEXTURE(pContext);
                break;
                
            case D3DTSS_MIPMAPLODBIAS:
                DISPDBG((DBGLVL,"  D3DTSS_MIPMAPLODBIAS: stage %d, value %d", 
                            dwStage, dwValue ));
                pContext->TextureStageState[dwStage].m_dwVal[dwState] = dwValue;
                DIRTY_TEXTURE(pContext);
                break;
                
            case D3DTSS_MAGFILTER:        
            case D3DTSS_MINFILTER:
            case D3DTSS_MIPFILTER:
#if DX8_DDI        
                if((!IS_DX7_OR_EARLIER_APP(pContext)) && 
                   bTranslateDX8FilterValueToDX6)
                {
                    // filtering values are somewhat different in DX8 
                    // so translate them before using them.
                    dwValue = __TXT_MapDX8toDX6TexFilter(dwState, dwValue);
                }
#endif DX8_DDI            
                
                pContext->TextureStageState[dwStage].m_dwVal[dwState] = dwValue;
                DIRTY_TEXTURE(pContext);        
                break;
                
            case D3DTSS_MAXMIPLEVEL:
                DISPDBG((DBGLVL,"  D3DTSS_MAXMIPLEVEL: stage %d, value %d", 
                            dwStage, dwValue ));
                pContext->TextureStageState[dwStage].m_dwVal[dwState] = dwValue;
                DIRTY_TEXTURE(pContext);
                break;     
                
            default:
                pContext->TextureStageState[dwStage].m_dwVal[dwState] = dwValue;
                DIRTY_TEXTURE(pContext);
                break;
            } // switch
        } 
        else
        {
            DISPDBG((WRNLVL,"Out of range stage/state %d %d",dwStage,dwState));
        }// if
    } // for
} // _D3D_TXT_ParseTextureStageStates



//-----------------------------------------------------------------------------
//
// SETARG
//
// dwArg = the argument.
// num = argument number (1 or 2).
// bIsAlpha = TRUE if this is the alpha channel, 
//            FALSE if this is the colour channel.
// iD3DStage = D3D stage number.
// iChipStageNo = chip stage number (should only be 0 or 1 on P3)
//
//-----------------------------------------------------------------------------
void
SETARG(
    P3_D3DCONTEXT *pContext, 
    struct TextureCompositeRGBAMode *pMode,
    DWORD dwArg, 
    DWORD num,
    BOOL bIsAlpha,    
    DWORD iD3DStage, 
    DWORD iChipStageNo)    
{                       
    BOOL bSetArgToggleInvert;
    DWORD dwArgValue, dwInvertArgValue;
    BOOL bArgValueAssigned = FALSE,
         bInvertArgValueAssigned;

    bSetArgToggleInvert = FALSE;                            
    switch (dwArg & D3DTA_SELECTMASK)                       
    {                                                       
        case D3DTA_TEXTURE:                                 
            if ((dwArg & D3DTA_ALPHAREPLICATE) || (bIsAlpha))   
            {                                                   
                dwArgValue = ( pContext->iStageTex[iD3DStage] == 0 ) ?   
                                                         P3RX_TEXCOMP_T0A :   
                                                         P3RX_TEXCOMP_T1A;  
                bArgValueAssigned = TRUE;
                DISPDBG((DBGLVL,"  Tex%dA", pContext->iStageTex[iD3DStage] ));     
            }                                                   
            else                                                
            {                                                   
                dwArgValue = ( pContext->iStageTex[iD3DStage] == 0 ) ?   
                                                         P3RX_TEXCOMP_T0C :   
                                                         P3RX_TEXCOMP_T1C; 
                bArgValueAssigned = TRUE;                                                         
                DISPDBG((DBGLVL,"  Tex%dC", pContext->iStageTex[iD3DStage] ));   
            }                                                   
            break;                
            
        case D3DTA_DIFFUSE:                                     
            if ((dwArg & D3DTA_ALPHAREPLICATE) || (bIsAlpha))   
            {                                                   
                dwArgValue = P3RX_TEXCOMP_CA;      
                bArgValueAssigned = TRUE;
                DISPDBG((DBGLVL,"  DiffA" ));                        
            }                                                   
            else                                                
            {                                                   
                dwArgValue = P3RX_TEXCOMP_CC;              
                bArgValueAssigned = TRUE;
                DISPDBG((DBGLVL,"  DiffC" ));                        
            }                                                   
            break;        
            
        case D3DTA_CURRENT:                                     
            // Cope with a "current" argument in texcomp0 
            if ( iChipStageNo == 0 )                            
            {                                                                           
                // This is texcomp0
                if ( pContext->bBumpmapEnabled )                                        
                {                                                                       
                    // Emboss bumpmapping is on
                    if ((dwArg & D3DTA_ALPHAREPLICATE) || (bIsAlpha))                   
                    {                                                                   
                        // This is the alpha-channel, where the D3D stages 0 & 1
                        // should have put the heightfield info.
                        dwArgValue = P3RX_TEXCOMP_HEIGHTA;                         
                        bArgValueAssigned = TRUE;
                        DISPDBG((DBGLVL,"  BumpA" ));                                        
                        // And cope with inverted bumpmaps.
                        bSetArgToggleInvert = pContext->bBumpmapInverted;               
                    }                                                                   
                    else                                                                
                    {                                                                   
                        // Colour channel - this will hold the diffuse colour.
                        dwArgValue = P3RX_TEXCOMP_CC;                              
                        bArgValueAssigned = TRUE;
                        DISPDBG((DBGLVL,"  DiffC" ));                                        
                    }                                                                   
                }                                                                       
                else                                                    
                {                                                       
                    // Embossing is off - default to diffuse.
                    if ((dwArg & D3DTA_ALPHAREPLICATE) || (bIsAlpha))   
                    {                                                   
                        dwArgValue = P3RX_TEXCOMP_CA;              
                        bArgValueAssigned = TRUE;
                        DISPDBG((DBGLVL,"  DiffA" ));                        
                    }                                                   
                    else                                                
                    {                                                   
                        dwArgValue = P3RX_TEXCOMP_CC;              
                        bArgValueAssigned = TRUE;
                        DISPDBG((DBGLVL,"  DiffC" ));                        
                    }                                                   
                }                                                       
            }                                                           
            else                                                        
            {                                                           
                // texcomp stage 1
                if ( pContext->bStage0DotProduct )                      
                {                                                       
                    // Need to take the dotproduct sum result,
                    // even in the alpha channel, according to the docs.
                    dwArgValue = P3RX_TEXCOMP_SUM;                 
                    bArgValueAssigned = TRUE;
                }                                                       
                else                                                    
                {                                                       
                    if ((dwArg & D3DTA_ALPHAREPLICATE) || (bIsAlpha))   
                    {                                                   
                        dwArgValue = P3RX_TEXCOMP_OA;              
                        bArgValueAssigned = TRUE;
                        DISPDBG((DBGLVL,"  CurrA" ));                        
                    }                                                   
                    else                                                
                    {                                                   
                        dwArgValue = P3RX_TEXCOMP_OC;              
                        bArgValueAssigned = TRUE;
                        DISPDBG((DBGLVL,"  CurrC" ));                        
                    }                                                   
                }                                                       
            }                                                           
            break;      
            
        case D3DTA_TFACTOR:                                     
            if ((dwArg & D3DTA_ALPHAREPLICATE) || (bIsAlpha))   
            {                                                   
                dwArgValue = P3RX_TEXCOMP_FA;              
                bArgValueAssigned = TRUE;
                DISPDBG((DBGLVL,"  TfactA" ));                       
            }                                                   
            else                                                
            {                                                   
                dwArgValue = P3RX_TEXCOMP_FC;              
                bArgValueAssigned = TRUE;
                DISPDBG((DBGLVL,"  TfactC" ));                       
            }                                                   
            break;                                              
            
        default:                                                
            if ( bIsAlpha )                                     
            {                                                   
                DISPDBG((ERRLVL,"ERROR: Invalid AlphaArgument"));
                SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_ALPHA_ARG );
            }
            else
            {
                DISPDBG((ERRLVL,"ERROR: Invalid ColorArgument"));
                SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_COLOR_ARG );
            }
            break;
    } // switch
    
    if ( ( (dwArg & D3DTA_COMPLEMENT) == 0 ) == bSetArgToggleInvert )
    {                                                           
        dwInvertArgValue= __PERMEDIA_ENABLE;   
        bInvertArgValueAssigned = TRUE;
        DISPDBG((DBGLVL,"    inverted" ));                           
    }                                                           
    else                                                        
    {                                                           
        dwInvertArgValue = __PERMEDIA_DISABLE;   
        bInvertArgValueAssigned = TRUE;        
    }                                                           
                                                                
    // Set up the I input for MODULATExxx_ADDxxx modes.
    if ( num == 1 )                                             
    {                                                           
        switch (dwArg & D3DTA_SELECTMASK)                       
        {                                                       
            case D3DTA_TEXTURE:                                 
                pMode->I = ( pContext->iStageTex[iD3DStage] == 0 ) ?  
                                                P3RX_TEXCOMP_I_T0A :  
                                                P3RX_TEXCOMP_I_T1A;   
                DISPDBG((DBGLVL,"  I: Tex%dA", pContext->iStageTex[iD3DStage] ));    
                break;    
                
            case D3DTA_DIFFUSE:                                     
                pMode->I = P3RX_TEXCOMP_I_CA;                       
                DISPDBG((DBGLVL,"  I: DiffA" ));                         
                break;                                              
                
            case D3DTA_CURRENT:                                     
                if ( iChipStageNo == 0 )                            
                {                                                   
                    if ( pContext->bBumpmapEnabled )                
                    {                                               
                        // Bumpmapping mode. 
                        pMode->I = P3RX_TEXCOMP_I_HA;               
                        DISPDBG((DBGLVL,"  I: BumpA" ));                 
                    }                                               
                    else                                            
                    {                                               
                        pMode->I = P3RX_TEXCOMP_I_CA;               
                        DISPDBG((DBGLVL,"  I: DiffA" ));                 
                    }                                               
                }                                                   
                else                                                
                {                                                   
                    pMode->I = P3RX_TEXCOMP_I_OA;                   
                    DISPDBG((DBGLVL,"  I: CurrA" ));                     
                }                                                   
                break;                                              
                
            case D3DTA_TFACTOR:                                     
                pMode->I = P3RX_TEXCOMP_I_FA;                       
                DISPDBG((DBGLVL,"  I: TfactA" ));                        
                break;                                              
                
            default:                                                
                if ( bIsAlpha )                                     
                {                                                   
                    DISPDBG((ERRLVL,"ERROR: Invalid AlphaArgument"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_ALPHA_ARG );    
                }                                                   
                else                                                
                {                                                   
                    DISPDBG((ERRLVL,"ERROR: Invalid ColorArgument"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_COLOR_ARG );    
                }                                                   
                break;                                              
        } // switch
        
        if ( ( (dwArg & D3DTA_COMPLEMENT) == 0 ) == bSetArgToggleInvert )
        {                                                           
            pMode->InvertI = __PERMEDIA_ENABLE;                        
        }                                                           
        else                                                        
        {                                                           
            pMode->InvertI = __PERMEDIA_DISABLE;                       
        }                                                           
    } // if ( num == 1 )          

    if (bArgValueAssigned)
    {
        if (num == 1)
        {
            pMode->Arg1 = dwArgValue;
        }
        else
        {
            pMode->Arg2 = dwArgValue;        
        }
    }

    if (bInvertArgValueAssigned)
    {
        if (num == 1)
        {
            pMode->InvertArg1 = dwInvertArgValue;
        }
        else
        {
            pMode->InvertArg2 = dwInvertArgValue;        
        }
    }    
} // SETARG

//-----------------------------------------------------------------------------
//
// SETTAARG_ALPHA
//
// TexApp blend mode for the alpha channel.
//
//-----------------------------------------------------------------------------
void
SETTAARG_ALPHA(
    P3_D3DCONTEXT *pContext, 
    struct TextureApplicationMode *pMode,
    DWORD dwArg, 
    DWORD num) 
{                                                          
    switch (dwArg & D3DTA_SELECTMASK)                               
    {                                                               
        case D3DTA_TEXTURE:                                         
            DISPDBG((ERRLVL,"ERROR: Invalid TA AlphaArgument"));
            SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_ALPHA_ARG_HERE );    
            break;                                                  
        case D3DTA_DIFFUSE:                                         
            if ( (num) == 1 )                                       
            {                                                       
                pMode->AlphaA = P3RX_TEXAPP_A_CA;          
                DISPDBG((DBGLVL,"  DiffA" ));                        
            }                                                       
            else                                                    
            {                                                       
                DISPDBG((ERRLVL,"ERROR: Invalid TA AlphaArgument"));
                SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_ALPHA_ARG_HERE );
            }                                                       
            break;                                                  
        case D3DTA_CURRENT:                                         
            if ( (num) == 2 )                                       
            {                                                       
                pMode->AlphaB = P3RX_TEXAPP_B_TA;          
                DISPDBG((DBGLVL,"  CurrA" ));                        
            }                                                       
            else                                                    
            {                                                       
                // Can't do
                DISPDBG((ERRLVL,"ERROR: Invalid TA AlphaArgument"));
                SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_ALPHA_ARG_HERE );
            }                                                       
            break;                                                  
        case D3DTA_TFACTOR:                                         
            if ( (num) == 1 )                                       
            {                                                       
                pMode->AlphaA = P3RX_TEXAPP_A_KA;          
                DISPDBG((DBGLVL,"  TfactA" ));                       
            }                                                       
            else                                                    
            {                        
                if ( (num) != 2)
                {
                    DISPDBG((ERRLVL," ** SETTAARG: num must be 1 or 2"));
                }
                pMode->AlphaB = P3RX_TEXAPP_B_KA;          
                DISPDBG((DBGLVL,"  TfactA" ));                       
            }                                                       
            break;                                                  
        default:                                                    
            DISPDBG((ERRLVL,"ERROR: Unknown TA AlphaArgument"));
            SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_ALPHA_ARG );        
            break;                                                  
    }         
    
    if ( (dwArg & D3DTA_COMPLEMENT) != 0 )                          
    {                                                               
        // Can't do COMPLEMENT on the args.
        DISPDBG((ERRLVL,"ERROR: Can't do COMPLEMENT in TA unit"));
        SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_ALPHA_ARG_HERE );            
    }                                                               
} // SETTAARG_ALPHA

//-----------------------------------------------------------------------------
//
// SETTAARG_COLOR
//
// TexApp blend mode for the color channel.
//
//-----------------------------------------------------------------------------
void 
SETTAARG_COLOR(
    P3_D3DCONTEXT *pContext, 
    struct TextureApplicationMode *pMode,
    DWORD dwArg, 
    DWORD num) 
{                                                                   
    switch (dwArg & D3DTA_SELECTMASK)                               
    {                                                               
            DISPDBG((ERRLVL,"ERROR: Invalid TA ColorArgument"));
            SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_COLOR_ARG_HERE );    
            break;                                                  
        case D3DTA_DIFFUSE:                                         
            if ( (num) == 1 )                                       
            {                                                       
                if ( (dwArg & D3DTA_ALPHAREPLICATE) != 0 )      
                {                                               
                    pMode->ColorA = P3RX_TEXAPP_A_CA;      
                    DISPDBG((DBGLVL,"  DiffA" ));                    
                }                                               
                else                                            
                {                                               
                    pMode->ColorA = P3RX_TEXAPP_A_CC;      
                    DISPDBG((DBGLVL,"  DiffC" ));                    
                }                                               
                // Set up the I input for MODULATExxx_ADDxxx modes
                pMode->ColorI = P3RX_TEXAPP_I_CA;          
                DISPDBG((DBGLVL,"  I: DiffA" ));                     
            }                                                       
            else                                                    
            {                                                       
                DISPDBG((ERRLVL,"ERROR: Invalid TA ColorArgument"));
                SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_COLOR_ARG_HERE );
            }                                                       
            break;                                                  
        case D3DTA_CURRENT:                                         
            if ( (num) == 2 )                                       
            {                                                       
                if (dwArg & D3DTA_ALPHAREPLICATE)   
                {                                                   
                    pMode->ColorB = P3RX_TEXAPP_B_TA;          
                    DISPDBG((DBGLVL,"  CurrA" ));                        
                }                                                   
                else                                                
                {                                                   
                    pMode->ColorB = P3RX_TEXAPP_B_TC;          
                    DISPDBG((DBGLVL,"  CurrC" ));                        
                }                                                   
            }                                                       
            else                                                    
            {                                                       
                // Can't do.
                DISPDBG((ERRLVL,"ERROR: Invalid TA ColorArgument"));
                SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_COLOR_ARG_HERE );
            }                                                       
            break;                                                  
        case D3DTA_TFACTOR:                                         
            if ( (num) == 1 )                                       
            {                                                       
                if ( (dwArg & D3DTA_ALPHAREPLICATE) != 0 )      
                {                                               
                    pMode->ColorA = P3RX_TEXAPP_A_KA;      
                    DISPDBG((DBGLVL,"  TfactA" ));                   
                }                                               
                else                                            
                {                                               
                    pMode->ColorA = P3RX_TEXAPP_A_KC;      
                    DISPDBG((DBGLVL,"  TfactC" ));                   
                }                                               
                // Set up the I input for MODULATExxx_ADDxxx modes. 
                pMode->ColorI = P3RX_TEXAPP_I_KA;          
                DISPDBG((DBGLVL,"  I: TfactA" ));                    
            }                                                       
            else                                                    
            {                           
                if ( (num) != 2)
                {
                    DISPDBG((ERRLVL," ** SETTAARG: num must be 1 or 2"));    
                }
                
                if (dwArg & D3DTA_ALPHAREPLICATE)   
                {                                                   
                    pMode->ColorB = P3RX_TEXAPP_B_KA;          
                    DISPDBG((DBGLVL,"  TfactA" ));                       
                }                                                   
                else                                                
                {                                                   
                    pMode->ColorB = P3RX_TEXAPP_B_KC;          
                    DISPDBG((DBGLVL,"  TfactC" ));                       
                }                                                   
            }                                                       
            break;                                                  
        default:                                                    
            DISPDBG((ERRLVL,"ERROR: Unknown TA ColorArgument"));
            SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_COLOR_ARG );        
            break;                                                  
    }                                                               
    if ( (dwArg & D3DTA_COMPLEMENT) != 0 )                          
    {                                                               
        // Can't do COMPLEMENT on the args.
        DISPDBG((ERRLVL,"ERROR: Can't do COMPLEMENT in TA unit"));
        SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_COLOR_ARG_HERE );            
    }                                                               
} // SETTAARG_COLOR

//-----------------------------------------------------------------------------
//
// SETOP
//
// Note - SETOP must be done after SETARG for DISABLE to work.
//
//-----------------------------------------------------------------------------
void 
SETOP(
    P3_D3DCONTEXT *pContext, 
    struct TextureCompositeRGBAMode* pMode, 
    DWORD dwOperation, 
    DWORD iD3DStage, 
    DWORD iChipStageNo, 
    BOOL bIsAlpha)
{                                                                   
    pMode->Enable = __PERMEDIA_ENABLE;                                 
    pMode->Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;                
    pMode->InvertI = __PERMEDIA_DISABLE;                               
    pMode->A = P3RX_TEXCOMP_ARG1;                                   
    pMode->B = P3RX_TEXCOMP_ARG2;                                   
    switch (dwOperation)                                            
    {                                                               
        case D3DTOP_DISABLE:                                        
            if ( bIsAlpha )                                         
            {                                                       
                // Just pass through "current"
                pMode->Operation = P3RX_TEXCOMP_OPERATION_PASS_A;   
                if ( iChipStageNo == 0 )                            
                {                                                   
                    if ( pContext->bBumpmapEnabled )                
                    {                                               
                        // Embossing is on.
                        pMode->Arg1 = P3RX_TEXCOMP_HEIGHTA;    
                    }                                               
                    else                                            
                    {                                               
                        // Current = diffuse in stage0.
                        pMode->Arg1 = P3RX_TEXCOMP_CA;         
                    }                                               
                }                                                   
                else                                                
                {                                                   
                    if ( pContext->bStage0DotProduct )              
                    {                                               
                        pMode->Arg1 = P3RX_TEXCOMP_SUM;        
                    }                                               
                    else                                            
                    {                                               
                        pMode->Arg1 = P3RX_TEXCOMP_OA;         
                    }                                               
                }                                                   
            }                                                       
            else                                                    
            {                                                       
                DISPDBG((ERRLVL,"SETOP: Colour op was DISABLE"
                                     " - should never have got here."));
            }                                                       
            break;                                                  
            
        case D3DTOP_SELECTARG1:                                     
            DISPDBG((DBGLVL,"  D3DTOP_SELECTARG1"));                     
            pMode->Operation = P3RX_TEXCOMP_OPERATION_PASS_A;       
            break;                                                  
            
        case D3DTOP_SELECTARG2:                                     
            DISPDBG((DBGLVL,"  D3DTOP_SELECTARG2"));                     
            pMode->Operation = P3RX_TEXCOMP_OPERATION_PASS_A; // No Pass B  
            pMode->A = P3RX_TEXCOMP_ARG2;                           
            break;                                                  
            
        case D3DTOP_MODULATE:                                       
            DISPDBG((DBGLVL,"  D3DTOP_MODULATE"));                       
            pMode->Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AB;  
            break;                                                  
            
        case D3DTOP_MODULATE2X:                                     
            DISPDBG((DBGLVL,"  D3DTOP_MODULATE2X"));                     
            pMode->Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AB;  
            pMode->Scale = P3RX_TEXCOMP_OPERATION_SCALE_TWO;        
            break;                                                  
            
        case D3DTOP_MODULATE4X:                                     
            DISPDBG((DBGLVL,"  D3DTOP_MODULATE4X"));                     
            pMode->Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AB;  
            pMode->Scale = P3RX_TEXCOMP_OPERATION_SCALE_FOUR;       
            break;                                                  
            
        case D3DTOP_ADD:                                            
            DISPDBG((DBGLVL,"  D3DTOP_ADD"));                            
            pMode->Operation = P3RX_TEXCOMP_OPERATION_ADD_AB;       
            break;                                                  
            
        case D3DTOP_ADDSIGNED:                                      
            DISPDBG((DBGLVL,"  D3DTOP_ADDSIGNED"));                      
            pMode->Operation = P3RX_TEXCOMP_OPERATION_ADDSIGNED_AB; 
            break;                                                  
            
        case D3DTOP_ADDSIGNED2X:                                    
            DISPDBG((DBGLVL,"  D3DTOP_ADDSIGNED2X"));                    
            pMode->Operation = P3RX_TEXCOMP_OPERATION_ADDSIGNED_AB; 
            pMode->Scale = P3RX_TEXCOMP_OPERATION_SCALE_TWO;        
            break;                                                  
            
        case D3DTOP_SUBTRACT:                                       
            DISPDBG((DBGLVL,"  D3DTOP_SUBTRACT"));                       
            pMode->Operation = P3RX_TEXCOMP_OPERATION_SUBTRACT_AB;  
            break;                                                  
            
        case D3DTOP_ADDSMOOTH:                                      
            DISPDBG((DBGLVL,"  D3DTOP_ADDSMOOTH"));                      
            pMode->Operation = P3RX_TEXCOMP_OPERATION_ADD_AB_SUB_MODULATE_AB;
            break;                                                  
            
        case D3DTOP_BLENDDIFFUSEALPHA:                              
            DISPDBG((DBGLVL,"  D3DTOP_BLENDDIFFUSEALPHA"));              
            pMode->Operation = P3RX_TEXCOMP_OPERATION_LERP_ABI;     
            pMode->A = P3RX_TEXCOMP_ARG2;                           
            pMode->B = P3RX_TEXCOMP_ARG1;                           
            pMode->I = P3RX_TEXCOMP_I_CA;                           
            break;                                                  
            
        case D3DTOP_BLENDTEXTUREALPHA:                              
            DISPDBG((DBGLVL,"  D3DTOP_BLENDTEXTUREALPHA"));              
            pMode->Operation = P3RX_TEXCOMP_OPERATION_LERP_ABI;     
            pMode->A = P3RX_TEXCOMP_ARG2;                           
            pMode->B = P3RX_TEXCOMP_ARG1;                           
            pMode->I = ( pContext->iStageTex[iD3DStage] == 0 ) ? 
                                                        P3RX_TEXCOMP_I_T0A : 
                                                        P3RX_TEXCOMP_I_T1A; 
            DISPDBG((DBGLVL,"    alpha: Tex%dA", pContext->iStageTex[iD3DStage] ));  
            break;                                                  
            
        case D3DTOP_BLENDFACTORALPHA:                               
            DISPDBG((DBGLVL,"  D3DTOP_BLENDFACTORALPHA"));               
            pMode->Operation = P3RX_TEXCOMP_OPERATION_LERP_ABI;     
            pMode->A = P3RX_TEXCOMP_ARG2;                           
            pMode->B = P3RX_TEXCOMP_ARG1;                           
            pMode->I = P3RX_TEXCOMP_I_FA;                           
            break;                                                  
            
        case D3DTOP_BLENDCURRENTALPHA:                              
            DISPDBG((DBGLVL,"  D3DTOP_BLENDCURRENTALPHA"));              
            pMode->Operation = P3RX_TEXCOMP_OPERATION_LERP_ABI;     
            pMode->A = P3RX_TEXCOMP_ARG2;                           
            pMode->B = P3RX_TEXCOMP_ARG1;                           
            pMode->I = P3RX_TEXCOMP_I_OA;                           
            break;                                                  
            
        case D3DTOP_BLENDTEXTUREALPHAPM:                            
            DISPDBG((DBGLVL,"  D3DTOP_BLENDTEXTUREALPHAPM"));            
            pMode->Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AI_ADD_B;    
            pMode->A = P3RX_TEXCOMP_ARG2;                           
            pMode->B = P3RX_TEXCOMP_ARG1;                           
            pMode->I = ( pContext->iStageTex[iD3DStage] == 0 ) ? 
                                                           P3RX_TEXCOMP_I_T0A : 
                                                           P3RX_TEXCOMP_I_T1A; 
            DISPDBG((DBGLVL,"    alpha: Tex%dA", pContext->iStageTex[iD3DStage] ));  
            pMode->InvertI = __PERMEDIA_ENABLE;                        
            break;                                                  
            
        case D3DTOP_PREMODULATE:                                                                            
            DISPDBG((DBGLVL,"  D3DTOP_PREMODULATE"));                                                            
            // result = current_tex * next_stage_tex - ignore arguments.
            if ( ( pContext->iStageTex[iD3DStage] != -1 ) && 
                 ( pContext->iStageTex[iD3DStage+1] != -1 ) )                       
            {                                                                                               
                pMode->Arg1 = ( pContext->iStageTex[iD3DStage] == 0 ) ? 
                                                            P3RX_TEXCOMP_T0C : 
                                                            P3RX_TEXCOMP_T1C;            
                DISPDBG((DBGLVL,"    Arg1: Tex%d", pContext->iStageTex[iD3DStage] ));                                        
                pMode->Arg2 = ( pContext->iStageTex[iD3DStage+1] == 0 ) ? 
                                                            P3RX_TEXCOMP_T0C : 
                                                            P3RX_TEXCOMP_T1C;      
                DISPDBG((DBGLVL,"    Arg2: Tex%d", pContext->iStageTex[iD3DStage+1] ));                                  
            }                                                                                               
            else                                                                                            
            {                                                                                               
                // Not enough textures
                DISPDBG((ERRLVL,"** SETOP: PREMODULATE didn't have two "
                                     "textures to play with."));
                if ( bIsAlpha )                                                                             
                {                                                                                           
                    SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_ALPHA_OP_HERE );                                         
                }                                                                                           
                else                                                                                        
                {                                                                                           
                    SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_COLOR_OP_HERE );                                         
                }                                                                                           
                pMode->Arg1 = P3RX_TEXCOMP_CC;                                                              
                pMode->Arg2 = P3RX_TEXCOMP_CC;                                                              
            }                                                                                               
            pMode->Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AB;                                          
            pMode->A = P3RX_TEXCOMP_ARG2;                                                                   
            pMode->B = P3RX_TEXCOMP_ARG1;                                                                   
            break;                                                                                          
            
        case D3DTOP_MODULATEALPHA_ADDCOLOR:                         
            DISPDBG((DBGLVL,"  D3DTOP_MODULATEALPHA_ADDCOLOR"));         
            pMode->Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AI_ADD_B; 
            pMode->A = P3RX_TEXCOMP_ARG2;                           
            pMode->B = P3RX_TEXCOMP_ARG1;                           
            // I input set up by SETARG
            break;                                                  
            
        case D3DTOP_MODULATECOLOR_ADDALPHA:                         
            DISPDBG((DBGLVL,"  D3DTOP_MODULATECOLOR_ADDALPHA"));         
            pMode->Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AB_ADD_I; 
            pMode->A = P3RX_TEXCOMP_ARG2;                           
            pMode->B = P3RX_TEXCOMP_ARG1;                           
            // I input set up by SETARG
            break;                                                  
            
        case D3DTOP_MODULATEINVALPHA_ADDCOLOR:                      
            DISPDBG((DBGLVL,"  D3DTOP_MODULATEINVALPHA_ADDCOLOR"));      
            pMode->Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AI_ADD_B; 
            pMode->A = P3RX_TEXCOMP_ARG2;                           
            pMode->B = P3RX_TEXCOMP_ARG1;                           
            // I input set up by SETARG
            pMode->InvertI = 1 - pMode->InvertI;                    
            break;                                                  
            
        case D3DTOP_MODULATEINVCOLOR_ADDALPHA:                      
            DISPDBG((DBGLVL,"  D3DTOP_MODULATEINVCOLOR_ADDALPHA"));      
            pMode->Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AB_ADD_I; 
            pMode->A = P3RX_TEXCOMP_ARG2;                           
            pMode->B = P3RX_TEXCOMP_ARG1;                           
            pMode->InvertArg1 = 1 - pMode->InvertArg1;              
            // I input set up by SETARG
            break;                                                  
            
        case D3DTOP_DOTPRODUCT3:                                    
            DISPDBG((DBGLVL,"  D3DTOP_DOTPRODUCT3"));                    
            if ( iChipStageNo == 0 )                                
            {                                                       
                pMode->Operation = P3RX_TEXCOMP_OPERATION_MODULATE_SIGNED_AB;   
                // Signal that the special input to stage 1 is needed.
                pContext->bStage0DotProduct = TRUE;                         
            }                                                       
            else                                                    
            {                                                       
                // Can't do stage 1 dotproduct. Fail.
                DISPDBG((ERRLVL,"** SETOP: Can't do DOTPRODUCT3 in second stage."));
                if ( bIsAlpha )                                     
                {                                                   
                    SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_ALPHA_OP_HERE ); 
                }                                                   
                else                                                
                {                                                   
                    SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_COLOR_OP_HERE ); 
                }                                                   
                pMode->Operation = P3RX_TEXCOMP_OPERATION_PASS_A;   
            }                                                       
            break;                                                  
            
        case D3DTOP_BUMPENVMAP:                                     
        case D3DTOP_BUMPENVMAPLUMINANCE:                            
            DISPDBG((ERRLVL,"** SETOP: Unsupported operation.")); 
            if ( bIsAlpha )                                         
            {                                                       
                SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_ALPHA_OP );       
            }                                                       
            else                                                    
            {                                                       
                SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_COLOR_OP );       
            }                                                       
            break;                                                  
            
        default:                                                    
            DISPDBG((ERRLVL,"** SETOP: Unknown operation."));
            if ( bIsAlpha )                                         
            {                                                       
                SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_ALPHA_OP );         
            }                                                       
            else                                                    
            {                                                       
                SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_COLOR_OP );         
            }                                                       
            break;                                                  
    } // switch                                                              
} // SETOP

//-----------------------------------------------------------------------------
//
// SETTAOP
//
// Must be done after SETTAARG to set up DISABLE properly.
//
//-----------------------------------------------------------------------------
void 
SETTAOP(
    P3_D3DCONTEXT *pContext, 
    struct TextureApplicationMode* pMode, 
    DWORD dwOperand, 
    BOOL bIsAlpha,    
    DWORD iD3DStage, 
    DWORD iChipStageNo)
{                     
    DWORD dwInvertI, dwOperation, dwI = 0, dwA = 0;
    BOOL bOperation = FALSE,
         bI         = FALSE,
         bA         = FALSE;

    pMode->Enable = __PERMEDIA_ENABLE;                                         
    dwInvertI = __PERMEDIA_DISABLE;                             
    switch (dwOperand)                                                    
    {                                                                       
        case D3DTOP_DISABLE:                                                
            if ( bIsAlpha )                                                 
            {                                                               
                // Just pass through "current"
                dwOperation = P3RX_TEXAPP_OPERATION_PASS_A;  
                bOperation = TRUE;
                dwA = P3RX_TEXAPP_A_CA;                
                bA = TRUE;
            }                                                               
            else                                                            
            {                                                               
                DISPDBG((ERRLVL,"SETTAOP: Colour op was DISABLE "      
                             " should never have got here."));
            }                                                               
            break;                                                          
        case D3DTOP_SELECTARG1:                                             
            DISPDBG((DBGLVL,"  D3DTOP_SELECTARG1"));                             
            dwOperation = P3RX_TEXAPP_OPERATION_PASS_A;   
            bOperation = TRUE;
            break;                                                          
        case D3DTOP_SELECTARG2:                                             
            DISPDBG((DBGLVL,"  D3DTOP_SELECTARG2"));                             
            dwOperation = P3RX_TEXAPP_OPERATION_PASS_B;   
            bOperation = TRUE;
            break;                                                          
        case D3DTOP_MODULATE:                                               
            DISPDBG((DBGLVL,"  D3DTOP_MODULATE"));                               
            dwOperation = P3RX_TEXAPP_OPERATION_MODULATE_AB; 
            bOperation = TRUE;
            break;                                                          
        case D3DTOP_ADD:                                                    
            DISPDBG((DBGLVL,"  D3DTOP_ADD"));                                    
            dwOperation = P3RX_TEXAPP_OPERATION_ADD_AB;    
            bOperation = TRUE;
            break;                                                          
        case D3DTOP_BLENDDIFFUSEALPHA:                                      
            DISPDBG((DBGLVL,"  D3DTOP_BLENDDIFFUSEALPHA"));                      
            dwOperation = P3RX_TEXAPP_OPERATION_LERP_ABI;   
            bOperation = TRUE;
            dwInvertI = 1 - dwInvertI;    
            dwI = P3RX_TEXAPP_I_CA;    
            bI = TRUE;
            break;                                                          
        case D3DTOP_BLENDFACTORALPHA:                                       
            DISPDBG((DBGLVL,"  D3DTOP_BLENDFACTORALPHA"));                       
            dwOperation = P3RX_TEXAPP_OPERATION_LERP_ABI; 
            bOperation = TRUE;
            dwInvertI = 1 - dwInvertI;  
            dwI = P3RX_TEXAPP_I_KA;             
            bI = TRUE;
            break;                                                          
        case D3DTOP_BLENDCURRENTALPHA:                                      
            DISPDBG((DBGLVL,"  D3DTOP_BLENDCURRENTALPHA"));                      
            dwOperation = P3RX_TEXAPP_OPERATION_LERP_ABI;   
            bOperation = TRUE;
            dwInvertI = 1 - dwInvertI;    
            dwI = P3RX_TEXAPP_I_TA;         
            bI = TRUE;
            break;                                                          
        case D3DTOP_MODULATEALPHA_ADDCOLOR:                                 
            DISPDBG((DBGLVL,"  D3DTOP_MODULATEALPHA_ADDCOLOR"));                 
            dwOperation = P3RX_TEXAPP_OPERATION_MODULATE_BI_ADD_A; 
            bOperation = TRUE;
            // I should have been set up by SETTAARG.
            // dwI = P3RX_TEXAPP_I_TA;         
            break;                                                          
        case D3DTOP_MODULATECOLOR_ADDALPHA:                                 
            DISPDBG((DBGLVL,"  D3DTOP_MODULATECOLOR_ADDALPHA"));                 
            dwOperation = P3RX_TEXAPP_OPERATION_MODULATE_AB_ADD_I; 
            bOperation = TRUE;
            // I should have been set up by SETTAARG.
            // dwI = P3RX_TEXAPP_I_TA; 
            break;                                                          
        case D3DTOP_MODULATEINVALPHA_ADDCOLOR:                              
            DISPDBG((DBGLVL,"  D3DTOP_MODULATEINVALPHA_ADDCOLOR"));              
            dwOperation = P3RX_TEXAPP_OPERATION_MODULATE_BI_ADD_A; 
            bOperation = TRUE;
            dwInvertI = 1 - dwInvertI;   
            // I should have been set up by SETTAARG.
            // dwI = P3RX_TEXAPP_I_TA;
            break;                                                          
        case D3DTOP_MODULATE2X:                                             
        case D3DTOP_MODULATE4X:                                             
        case D3DTOP_ADDSIGNED:                                              
        case D3DTOP_ADDSIGNED2X:                                            
        case D3DTOP_SUBTRACT:                                               
        case D3DTOP_ADDSMOOTH:                                              
        case D3DTOP_BLENDTEXTUREALPHA:                                      
        case D3DTOP_BLENDTEXTUREALPHAPM:                                    
        case D3DTOP_PREMODULATE:                                            
        case D3DTOP_MODULATEINVCOLOR_ADDALPHA:                              
        case D3DTOP_DOTPRODUCT3:                                            
            DISPDBG((ERRLVL,"** SETTAOP: Unsupported operation in TA unit."));
            if ( bIsAlpha )                                                 
            {                                                               
                SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_ALPHA_OP_HERE );             
            }                                                               
            else                                                            
            {                                                               
                SET_BLEND_ERROR ( pContext,  BSF_CANT_USE_COLOR_OP_HERE );             
            }                                                               
            break;                                                          
        case D3DTOP_BUMPENVMAP:                                             
        case D3DTOP_BUMPENVMAPLUMINANCE:                                    
            DISPDBG((ERRLVL,"** SETTAOP: Unsupported operation."));
            if ( bIsAlpha )                                                 
            {                                                               
                SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_ALPHA_OP );               
            }                                                               
            else                                                            
            {                                                               
                SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_COLOR_OP );               
            }                                                               
            break;                                                          
        default:                                                            
            // What is this?. //azn
            DISPDBG((ERRLVL,"** SETTAOP: Unknown operation."));
            if ( bIsAlpha )                                                 
            {                                                               
                SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_ALPHA_OP );                 
            }                                                               
            else                                                            
            {                                                               
                SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_COLOR_OP );                 
            }                                                               
            break;                                                          
    }       

    if(bIsAlpha)
    {
        pMode->AlphaInvertI = dwInvertI;
        if (bOperation)
        {
            pMode->AlphaOperation = dwOperation;    
        }

        if (bI)
        {
            pMode->AlphaI = dwI;      
        }

        if (bA)
        {
            pMode->AlphaA = dwA;          
        }
    }
    else
    {
        pMode->ColorInvertI = dwInvertI;
        
        if (bOperation)
        {
            pMode->ColorOperation = dwOperation;    
        }

        if (bI)
        {
            pMode->ColorI = dwI;  
        }
        
        if (bA)
        {
            pMode->ColorA = dwA;          
        }
    }
} // SETTAOP

//-----------------------------------------------------------------------------
//
// _D3DDisplayWholeTSSPipe
//
// Dumps the whole TSS pipe state out to the debug stream.
// Also dumps fog, specular and alpha-blend state out.
//
//-----------------------------------------------------------------------------
void _D3DDisplayWholeTSSPipe ( P3_D3DCONTEXT* pContext, int iDebugNumber )
{
#if DBG
    int i;
    char *pszTemp, *pszTempPre, *pszTempPost;
    char *pszOp;
    char *pszArg1Pre, *pszArg1, *pszArg1Post;
    char *pszArg2Pre, *pszArg2, *pszArg2Post;
    char *pszSrc, *pszDest;
    P3_SURF_INTERNAL* pTexture;
    P3_SURF_FORMAT* pFormatSurface;

    DISPDBG((iDebugNumber,"TSS dump:"));

    #define SWITCH_ARG(prefix,opname) \
            case prefix##_##opname##: pszTemp = #opname; break

    i = 0;
    while ( ( i < 8 ) && ( TSSTATE ( i, D3DTSS_COLOROP ) != D3DTOP_DISABLE ) )
    {

        switch ( TSSTATE ( i, D3DTSS_COLOROP ) )
        {
            SWITCH_ARG ( D3DTOP,DISABLE );
            SWITCH_ARG ( D3DTOP,SELECTARG1 );
            SWITCH_ARG ( D3DTOP,SELECTARG2 );
            SWITCH_ARG ( D3DTOP,MODULATE );
            SWITCH_ARG ( D3DTOP,MODULATE2X );
            SWITCH_ARG ( D3DTOP,MODULATE4X );
            SWITCH_ARG ( D3DTOP,ADD );
            SWITCH_ARG ( D3DTOP,ADDSIGNED );
            SWITCH_ARG ( D3DTOP,ADDSIGNED2X );
            SWITCH_ARG ( D3DTOP,SUBTRACT );
            SWITCH_ARG ( D3DTOP,ADDSMOOTH );
            SWITCH_ARG ( D3DTOP,BLENDDIFFUSEALPHA );
            SWITCH_ARG ( D3DTOP,BLENDTEXTUREALPHA );
            SWITCH_ARG ( D3DTOP,BLENDFACTORALPHA );
            SWITCH_ARG ( D3DTOP,BLENDTEXTUREALPHAPM );
            SWITCH_ARG ( D3DTOP,BLENDCURRENTALPHA );
            SWITCH_ARG ( D3DTOP,PREMODULATE );
            SWITCH_ARG ( D3DTOP,MODULATEALPHA_ADDCOLOR );
            SWITCH_ARG ( D3DTOP,MODULATECOLOR_ADDALPHA );
            SWITCH_ARG ( D3DTOP,MODULATEINVALPHA_ADDCOLOR );
            SWITCH_ARG ( D3DTOP,MODULATEINVCOLOR_ADDALPHA );
            SWITCH_ARG ( D3DTOP,BUMPENVMAP );
            SWITCH_ARG ( D3DTOP,BUMPENVMAPLUMINANCE );
            SWITCH_ARG ( D3DTOP,DOTPRODUCT3 );
            default:
                pszTemp = "Unknown";
                break;
        }
        pszOp = pszTemp;

        switch ( TSSTATESELECT ( i, D3DTSS_COLORARG1 ) )
        {
            SWITCH_ARG ( D3DTA,DIFFUSE );
            SWITCH_ARG ( D3DTA,CURRENT );
            SWITCH_ARG ( D3DTA,TEXTURE );
            SWITCH_ARG ( D3DTA,TFACTOR );
            default:
                pszTemp = "Unknown";
                break;
        }
        if ( ( TSSTATE ( i, D3DTSS_COLORARG1 ) & D3DTA_ALPHAREPLICATE ) != 0 )
        {
            pszTempPost = ".A";
        }
        else
        {
            pszTempPost = ".C";
        }
        if ( ( TSSTATE ( i, D3DTSS_COLORARG1 ) & D3DTA_COMPLEMENT ) != 0 )
        {
            pszTempPre = "1-";
        }
        else
        {
            pszTempPre = "";
        }
        pszArg1Pre = pszTempPre;
        pszArg1Post = pszTempPost;
        pszArg1 = pszTemp;


        switch ( TSSTATESELECT ( i, D3DTSS_COLORARG2 ) )
        {
            SWITCH_ARG ( D3DTA,DIFFUSE );
            SWITCH_ARG ( D3DTA,CURRENT );
            SWITCH_ARG ( D3DTA,TEXTURE );
            SWITCH_ARG ( D3DTA,TFACTOR );
            default:
                pszTemp = "Unknown";
                break;
        }
        if ( ( TSSTATE ( i, D3DTSS_COLORARG2 ) & D3DTA_ALPHAREPLICATE ) != 0 )
        {
            pszTempPost = ".A";
        }
        else
        {
            pszTempPost = ".C";
        }
        if ( ( TSSTATE ( i, D3DTSS_COLORARG2 ) & D3DTA_COMPLEMENT ) != 0 )
        {
            pszTempPre = "1-";
        }
        else
        {
            pszTempPre = "";
        }
        pszArg2Pre = pszTempPre;
        pszArg2Post = pszTempPost;
        pszArg2 = pszTemp;


        DISPDBG((iDebugNumber," C%i: %s: %s%s%s, %s%s%s",
                 i, pszOp, pszArg1Pre, pszArg1, pszArg1Post, 
                 pszArg2Pre, pszArg2, pszArg2Post ));


        switch ( TSSTATE ( i, D3DTSS_ALPHAOP ) )
        {
            SWITCH_ARG ( D3DTOP,DISABLE );
            SWITCH_ARG ( D3DTOP,SELECTARG1 );
            SWITCH_ARG ( D3DTOP,SELECTARG2 );
            SWITCH_ARG ( D3DTOP,MODULATE );
            SWITCH_ARG ( D3DTOP,MODULATE2X );
            SWITCH_ARG ( D3DTOP,MODULATE4X );
            SWITCH_ARG ( D3DTOP,ADD );
            SWITCH_ARG ( D3DTOP,ADDSIGNED );
            SWITCH_ARG ( D3DTOP,ADDSIGNED2X );
            SWITCH_ARG ( D3DTOP,SUBTRACT );
            SWITCH_ARG ( D3DTOP,ADDSMOOTH );
            SWITCH_ARG ( D3DTOP,BLENDDIFFUSEALPHA );
            SWITCH_ARG ( D3DTOP,BLENDTEXTUREALPHA );
            SWITCH_ARG ( D3DTOP,BLENDFACTORALPHA );
            SWITCH_ARG ( D3DTOP,BLENDTEXTUREALPHAPM );
            SWITCH_ARG ( D3DTOP,BLENDCURRENTALPHA );
            SWITCH_ARG ( D3DTOP,PREMODULATE );
            SWITCH_ARG ( D3DTOP,MODULATEALPHA_ADDCOLOR );
            SWITCH_ARG ( D3DTOP,MODULATECOLOR_ADDALPHA );
            SWITCH_ARG ( D3DTOP,MODULATEINVALPHA_ADDCOLOR );
            SWITCH_ARG ( D3DTOP,MODULATEINVCOLOR_ADDALPHA );
            SWITCH_ARG ( D3DTOP,BUMPENVMAP );
            SWITCH_ARG ( D3DTOP,BUMPENVMAPLUMINANCE );
            SWITCH_ARG ( D3DTOP,DOTPRODUCT3 );
            default:
                pszTemp = "Unknown";
                break;
        }
        pszOp = pszTemp;


        switch ( TSSTATESELECT ( i, D3DTSS_ALPHAARG1 ) )
        {
            SWITCH_ARG ( D3DTA,DIFFUSE );
            SWITCH_ARG ( D3DTA,CURRENT );
            SWITCH_ARG ( D3DTA,TEXTURE );
            SWITCH_ARG ( D3DTA,TFACTOR );
            default:
                pszTemp = "Unknown";
                break;
        }
        if ( ( TSSTATE ( i, D3DTSS_ALPHAARG1 ) & D3DTA_ALPHAREPLICATE ) != 0 )
        {
            // Alpharep doesn't mean much in the alpha channel.
            pszTempPost = ".AR???";
        }
        else
        {
            pszTempPost = ".A";
        }
        if ( ( TSSTATE ( i, D3DTSS_ALPHAARG1 ) & D3DTA_COMPLEMENT ) != 0 )
        {
            pszTempPre = "1-";
        }
        else
        {
            pszTempPre = "";
        }
        pszArg1Pre = pszTempPre;
        pszArg1Post = pszTempPost;
        pszArg1 = pszTemp;


        switch ( TSSTATESELECT ( i, D3DTSS_ALPHAARG2 ) )
        {
            SWITCH_ARG ( D3DTA,DIFFUSE );
            SWITCH_ARG ( D3DTA,CURRENT );
            SWITCH_ARG ( D3DTA,TEXTURE );
            SWITCH_ARG ( D3DTA,TFACTOR );
            default:
                pszTemp = "Unknown";
                break;
        }
        if ( ( TSSTATE ( i, D3DTSS_ALPHAARG2 ) & D3DTA_ALPHAREPLICATE ) != 0 )
        {
            pszTempPost = ".AR???";
        }
        else
        {
            pszTempPost = ".A";
        }
        if ( ( TSSTATE ( i, D3DTSS_ALPHAARG2 ) & D3DTA_COMPLEMENT ) != 0 )
        {
            pszTempPre = "1-";
        }
        else
        {
            pszTempPre = "";
        }
        pszArg2Pre = pszTempPre;
        pszArg2Post = pszTempPost;
        pszArg2 = pszTemp;

        DISPDBG((iDebugNumber," A%i: %s: %s%s%s, %s%s%s", 
                    i, pszOp, pszArg1Pre, pszArg1, pszArg1Post, 
                       pszArg2Pre, pszArg2, pszArg2Post ));


        if ( TSSTATE ( i, D3DTSS_TEXTUREMAP ) != 0 )
        {
            char szTemp[4];
            // Setup texture 0.
            pTexture = GetSurfaceFromHandle(pContext, 
                                            TSSTATE(i, D3DTSS_TEXTUREMAP));
            if ( pTexture == NULL )
            {
                DISPDBG((iDebugNumber," Tex%i: 0x%x, TCI: %i, INVALID TEXTURE",
                         i, TSSTATE ( i, D3DTSS_TEXTUREMAP ), 
                            TSSTATE ( i, D3DTSS_TEXCOORDINDEX ) ));
            }
            else
            {
                pFormatSurface = pTexture->pFormatSurface;
                ASSERTDD ( pFormatSurface != NULL, 
                           "** _D3DDisplayWholeTSSPipe: "
                           "Surface had NULL format!" );

                // Find the filtering mode.
                szTemp[3] = '\0';
                switch ( TSSTATE ( i, D3DTSS_MINFILTER ) )
                {
                    case D3DTFN_POINT:
                        szTemp[0] = 'P';
                        break;
                    case D3DTFN_LINEAR:
                        szTemp[0] = 'L';
                        break;
                    case D3DTFN_ANISOTROPIC:
                        szTemp[0] = 'A';
                        break;
                    default:
                        szTemp[0] = '?';
                        break;
                }
                switch ( TSSTATE ( i, D3DTSS_MIPFILTER ) )
                {
                    case D3DTFP_NONE:
                        szTemp[1] = 'x';
                        break;
                    case D3DTFP_POINT:
                        szTemp[1] = 'P';
                        break;
                    case D3DTFP_LINEAR:
                        szTemp[1] = 'L';
                        break;
                    default:
                        szTemp[1] = '?';
                        break;
                }
                switch ( TSSTATE ( i, D3DTSS_MAGFILTER ) )
                {
                    case D3DTFG_POINT:
                        szTemp[2] = 'P';
                        break;
                    case D3DTFG_LINEAR:
                        szTemp[2] = 'L';
                        break;
                    case D3DTFG_FLATCUBIC:
                        szTemp[2] = 'F';
                        break;
                    case D3DTFG_GAUSSIANCUBIC:
                        szTemp[2] = 'G';
                        break;
                    case D3DTFG_ANISOTROPIC:
                        szTemp[2] = 'A';
                        break;
                    default:
                        szTemp[2] = '?';
                        break;
                }
                
                DISPDBG((iDebugNumber," Tex%i: 0x%x, TCI: %i, %s:%dx%d %s", 
                         i, TSSTATE ( i, D3DTSS_TEXTUREMAP ), 
                            TSSTATE ( i, D3DTSS_TEXCOORDINDEX ), 
                            pFormatSurface->pszStringFormat, 
                            pTexture->wWidth, 
                            pTexture->wHeight, szTemp ));
            }
        }
        else
        {
            DISPDBG((iDebugNumber," Tex%i: NULL, TCI: %i", 
                     i, TSSTATE ( i, D3DTSS_TEXCOORDINDEX ) ));
        }
        

        i++;
    }

    // Alpha-test.
    if ( pContext->RenderStates[D3DRENDERSTATE_ALPHATESTENABLE] != 0 )
    {
        switch ( pContext->RenderStates[D3DRENDERSTATE_ALPHAFUNC] )
        {
            SWITCH_ARG ( D3DCMP,NEVER );
            SWITCH_ARG ( D3DCMP,LESS );
            SWITCH_ARG ( D3DCMP,EQUAL );
            SWITCH_ARG ( D3DCMP,LESSEQUAL );
            SWITCH_ARG ( D3DCMP,GREATER );
            SWITCH_ARG ( D3DCMP,NOTEQUAL );
            SWITCH_ARG ( D3DCMP,GREATEREQUAL );
            SWITCH_ARG ( D3DCMP,ALWAYS );
            default:
                pszTemp = "Unknown";
                break;
        }
        DISPDBG((iDebugNumber,"Alpha-test: %s:0x%x.", 
                 pszTemp, pContext->RenderStates[D3DRENDERSTATE_ALPHAREF] ));
    }
    else
    {
        DISPDBG((iDebugNumber,"No alpha-test."));
    }


    // Alpha-blend.
    if ( pContext->RenderStates[D3DRENDERSTATE_BLENDENABLE] != 0 )
    {
        switch ( pContext->RenderStates[D3DRENDERSTATE_SRCBLEND] )
        {
            SWITCH_ARG ( D3DBLEND,ZERO );
            SWITCH_ARG ( D3DBLEND,ONE );
            SWITCH_ARG ( D3DBLEND,SRCCOLOR );
            SWITCH_ARG ( D3DBLEND,INVSRCCOLOR );
            SWITCH_ARG ( D3DBLEND,SRCALPHA );
            SWITCH_ARG ( D3DBLEND,INVSRCALPHA );
            SWITCH_ARG ( D3DBLEND,DESTALPHA );
            SWITCH_ARG ( D3DBLEND,INVDESTALPHA );
            SWITCH_ARG ( D3DBLEND,DESTCOLOR );
            SWITCH_ARG ( D3DBLEND,INVDESTCOLOR );
            SWITCH_ARG ( D3DBLEND,SRCALPHASAT );
            SWITCH_ARG ( D3DBLEND,BOTHSRCALPHA );
            SWITCH_ARG ( D3DBLEND,BOTHINVSRCALPHA );
            default:
                pszTemp = "Unknown";
                break;
        }
        pszSrc = pszTemp;

        switch ( pContext->RenderStates[D3DRENDERSTATE_DESTBLEND] )
        {
            SWITCH_ARG ( D3DBLEND,ZERO );
            SWITCH_ARG ( D3DBLEND,ONE );
            SWITCH_ARG ( D3DBLEND,SRCCOLOR );
            SWITCH_ARG ( D3DBLEND,INVSRCCOLOR );
            SWITCH_ARG ( D3DBLEND,SRCALPHA );
            SWITCH_ARG ( D3DBLEND,INVSRCALPHA );
            SWITCH_ARG ( D3DBLEND,DESTALPHA );
            SWITCH_ARG ( D3DBLEND,INVDESTALPHA );
            SWITCH_ARG ( D3DBLEND,DESTCOLOR );
            SWITCH_ARG ( D3DBLEND,INVDESTCOLOR );
            SWITCH_ARG ( D3DBLEND,SRCALPHASAT );
            SWITCH_ARG ( D3DBLEND,BOTHSRCALPHA );
            SWITCH_ARG ( D3DBLEND,BOTHINVSRCALPHA );
            default:
                pszTemp = "Unknown";
                break;
        }
        pszDest = pszTemp;
        DISPDBG((iDebugNumber,"Blend %s:%s", pszSrc, pszDest));
    }
    else
    {
        DISPDBG((iDebugNumber,"No alpha-blend."));
    }

    #undef SWITCH_ARG

#endif //DBG
} // _D3DDisplayWholeTSSPipe

//-----------------------------------------------------------------------------
//
// __TXT_TranslateToChipBlendMode
//
// Translates the blend mode from D3D into what the chip understands
//
//-----------------------------------------------------------------------------
void 
__TXT_TranslateToChipBlendMode( 
    P3_D3DCONTEXT *pContext, 
    TexStageState* pState,
    P3_SOFTWARECOPY* pSoftP3RX, 
    int iTSStage, 
    int iChipStageNo )
{
    struct TextureCompositeRGBAMode* pColorMode;
    struct TextureCompositeRGBAMode* pAlphaMode;
    struct TextureApplicationMode* pTAMode;

    switch(iChipStageNo)
    {
        default:
            DISPDBG((ERRLVL,"ERROR: Invalid texture stage!"));
            // Fall through and treat as #0 in order not to AV anything
        case 0:
            pColorMode = &pSoftP3RX->P3RXTextureCompositeColorMode0;
            pAlphaMode = &pSoftP3RX->P3RXTextureCompositeAlphaMode0;
            pTAMode = NULL;
            break;
        case 1:
            pColorMode = &pSoftP3RX->P3RXTextureCompositeColorMode1;
            pAlphaMode = &pSoftP3RX->P3RXTextureCompositeAlphaMode1;
            pTAMode = NULL;
            break;
        case 2:
            pColorMode = NULL;
            pAlphaMode = NULL;
            pTAMode = &pSoftP3RX->P3RXTextureApplicationMode;
            break;

    }

    DISPDBG((DBGLVL,"*** In __TXT_TranslateToChipBlendMode: "
               "Chip Stage %d, D3D TSS Stage %d", 
               iChipStageNo, iTSStage ));

    // Setup the arguments
    if ( ( iChipStageNo == 0 ) || ( iChipStageNo == 1 ) )
    {
        // Texture composite unit.
        DISPDBG((DBGLVL,"TexComp%d:", iChipStageNo ));
        DISPDBG((DBGLVL,"Arg1:" ));
        
        SETARG(pContext,
               pColorMode, 
               pState->m_dwVal[D3DTSS_COLORARG1], 
               1, 
               IS_COLOR_ARG, 
               iTSStage, 
               iChipStageNo);
               
        SETARG(pContext,
               pAlphaMode, 
               pState->m_dwVal[D3DTSS_ALPHAARG1], 
               1, 
               IS_ALPHA_ARG, 
               iTSStage, 
               iChipStageNo);

        DISPDBG((DBGLVL,"Arg2:" ));
        
        SETARG(pContext,
               pColorMode, 
               pState->m_dwVal[D3DTSS_COLORARG2], 
               2, 
               IS_COLOR_ARG, 
               iTSStage, 
               iChipStageNo);
               
        SETARG(pContext,
               pAlphaMode, 
               pState->m_dwVal[D3DTSS_ALPHAARG2], 
               2, 
               IS_ALPHA_ARG, 
               iTSStage, 
               iChipStageNo);

        DISPDBG((DBGLVL,"Op:" ));
        SETOP(pContext, 
              pColorMode, 
              pState->m_dwVal[D3DTSS_COLOROP], 
              iTSStage, 
              iChipStageNo, 
              IS_COLOR_ARG);
              
        SETOP(pContext, 
              pAlphaMode, 
              pState->m_dwVal[D3DTSS_ALPHAOP], 
              iTSStage, 
              iChipStageNo, 
              IS_ALPHA_ARG);
    }
    else if ( iChipStageNo == 2 ) 
    {
        DISPDBG((DBGLVL,"TexApp:" ));
        DISPDBG((DBGLVL,"Arg1:" ));
        
        SETTAARG_COLOR(pContext, 
                       pTAMode, 
                       pState->m_dwVal[D3DTSS_COLORARG1], 
                       1 );
                 
        if ( ( pState->m_dwVal[D3DTSS_ALPHAOP] != D3DTOP_DISABLE ) && 
             ( pState->m_dwVal[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG2 ) )
        {
            SETTAARG_ALPHA(pContext,
                           pTAMode, 
                           pState->m_dwVal[D3DTSS_ALPHAARG1], 1
                           );
        }

        DISPDBG((DBGLVL,"Arg2:" ));
        SETTAARG_COLOR(pContext, 
                       pTAMode, 
                       pState->m_dwVal[D3DTSS_COLORARG2], 
                       2 );

        if ( ( pState->m_dwVal[D3DTSS_ALPHAOP] != D3DTOP_DISABLE ) && 
             ( pState->m_dwVal[D3DTSS_ALPHAOP] != D3DTOP_SELECTARG1 ) )
        {
            SETTAARG_ALPHA(pContext, 
                           pTAMode, 
                           pState->m_dwVal[D3DTSS_ALPHAARG2], 
                           2);
        }

        DISPDBG((DBGLVL,"Op:" ));
        SETTAOP(pContext,
                pTAMode, 
                pState->m_dwVal[D3DTSS_COLOROP], 
                IS_COLOR_ARG, 
                iTSStage, 
                iChipStageNo);
                
        SETTAOP(pContext,
                pTAMode, 
                pState->m_dwVal[D3DTSS_ALPHAOP], 
                IS_ALPHA_ARG, 
                iTSStage, 
                iChipStageNo);
    } 
    else
    {
        DISPDBG(( ERRLVL,"** __TXT_TranslateToChipBlendMode: "
                         "iChipStage must be 0 to 2" ));    
    }
} // __TXT_TranslateToChipBlendMode

//-----------------------------------------------------------------------------
//
// __TXT_ValidateTextureUnitStage
//
// Validate the texture which we're trying to set up in stage iChipStage of
// the hardware, iTSStage of the D3D TSS.
//
//-----------------------------------------------------------------------------
BOOL
__TXT_ValidateTextureUnitStage(
    P3_D3DCONTEXT* pContext,
    int iChipStage, 
    int iTSStage,
    P3_SURF_INTERNAL* pTexture)
{
    DWORD dwTexHandle = 
            pContext->TextureStageState[iTSStage].m_dwVal[D3DTSS_TEXTUREMAP];
            
    if( CHECK_SURF_INTERNAL_AND_DDSURFACE_VALIDITY(pTexture) &&
        (pTexture->Location != SystemMemory)                 &&  
        (dwTexHandle != 0)                                     )
    {
        // Texture is valid. Mark pCurrentTexturep[iChipStage] to point
        // to its P3_SURF_INTERNAL structure.
        pContext->pCurrentTexture[iChipStage] = pTexture;

        DISPDBG((DBGLVL, "__TXT_ValidateTextureUnitStage: valid texture %x "
                         "(handle %d) for iChipStage= %d iTSStage= %d",
                         pTexture, dwTexHandle, iChipStage, iTSStage));                                                                                    
    }
    else
    {
        // Set texture as invalid & force texturing off
        pContext->bTextureValid = FALSE;
        pContext->pCurrentTexture[iChipStage] = NULL;
        pContext->dwDirtyFlags |= CONTEXT_DIRTY_TEXTURE;

        // Setup error if we're asked to validate the TSS setup
        SET_BLEND_ERROR ( pContext,  BSF_INVALID_TEXTURE );

        DISPDBG((WRNLVL, "__TXT_ValidateTextureUnitStage: INVALID texture %x "
                         "(handle %d) for iChipStage= %d iTSStage= %d "
                         "Location=%d",
                         pTexture, dwTexHandle, iChipStage, iTSStage,
                         (pTexture !=NULL)?pTexture->Location:0));      
    }

    return ( (BOOL)pContext->bTextureValid );
    
} // __TXT_ValidateTextureUnitStage

//-----------------------------------------------------------------------------
//
// __TXT_ConsiderSrcChromaKey
//
// Setup chromakeying for a certain texture bound to a certain stage.
// Note - "stage" is the chip stage, not the D3D stage.
//-----------------------------------------------------------------------------
static void
__TXT_ConsiderSrcChromaKey(
    P3_D3DCONTEXT *pContext, 
    P3_SURF_INTERNAL* pTexture, 
    int stage )
{
    P3_THUNKEDDATA * pThisDisplay = pContext->pThisDisplay;
    P3_SOFTWARECOPY* pSoftP3RX = &pContext->SoftCopyGlint;
    P3_DMA_DEFS();

    if ((pTexture->dwFlagsInt & DDRAWISURF_HASCKEYSRCBLT) &&
        pContext->RenderStates[D3DRENDERSTATE_COLORKEYENABLE])
    {
        DWORD LowerBound = 0x00000000;
        DWORD UpperBound = 0xFFFFFFFF;
        DWORD* pPalEntries = NULL;
        DWORD dwPalFlags = 0;

        DISPDBG((DBGLVL,"    Can Chroma Key texture stage %d", stage));

        pContext->bCanChromaKey = TRUE;

#if DX7_PALETTETEXTURE
        // Get the palette entries
        if (pTexture->pixFmt.dwFlags & DDPF_PALETTEINDEXED8)
        {
            D3DHAL_DP2UPDATEPALETTE *pPalette = NULL;
        
            pPalette = GetPaletteFromHandle(pContext,
                                            pTexture->dwPaletteHandle);
            if (pPalette)
            {
                pPalEntries = (LPDWORD)(pPalette + 1);
            }
            else
            {
                SET_BLEND_ERROR(pContext, BSF_INVALID_TEXTURE);
            }

            dwPalFlags = pTexture->dwPaletteFlags;
        }
#endif        

        // Get the correct chroma value for the texture map to send to the chip.
        Get8888ScaledChroma(pThisDisplay, 
                            pTexture->dwFlagsInt, 
                            &pTexture->pixFmt,
                            pTexture->dwCKLow,
                            pTexture->dwCKHigh,
                            &LowerBound, 
                            &UpperBound, 
                            pPalEntries,
                            dwPalFlags & DDRAWIPAL_ALPHA, 
                            FALSE);

        P3_DMA_GET_BUFFER_ENTRIES( 8);

        // Send the upper and lower bounds for the alpha-map filtering
        if( stage == 0 )
        {
            SEND_P3_DATA(TextureChromaLower0, LowerBound );
            SEND_P3_DATA(TextureChromaUpper0, UpperBound );
            pSoftP3RX->P3RXTextureFilterMode.AlphaMapEnable0 = 
                                                            __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXTextureFilterMode.AlphaMapSense0 = 
                                                    P3RX_ALPHAMAPSENSE_INRANGE;
        }
        else
        {
            ASSERTDD ( stage == 1, 
                       "** __TXT_ConsiderSrcChromaKey: stage must be 0 or 1" );
        }

        // If we are mipmapping, we need to set up texture1's chromakey as well.
        // If not, then this will be overridden when this gets called for tex1.
        SEND_P3_DATA(TextureChromaLower1, LowerBound );
        SEND_P3_DATA(TextureChromaUpper1, UpperBound );
        pSoftP3RX->P3RXTextureFilterMode.AlphaMapEnable1 = __PERMEDIA_ENABLE;
        pSoftP3RX->P3RXTextureFilterMode.AlphaMapSense1 = 
                                                    P3RX_ALPHAMAPSENSE_INRANGE;

        P3_DMA_COMMIT_BUFFER();

        pSoftP3RX->P3RXTextureFilterMode.AlphaMapFiltering = __PERMEDIA_ENABLE;
    }
    else
    {
        DISPDBG((DBGLVL,"    Can't Chroma Key texture stage %d", stage));

        if( stage == 0 )
        {
            pSoftP3RX->P3RXTextureFilterMode.AlphaMapEnable0 = 
                                                            __PERMEDIA_DISABLE;
        }
        else
        {
            ASSERTDD ( stage == 1, 
                       "** __TXT_ConsiderSrcChromaKey: stage must be 0 or 1" );
        }
        
        // If we are mipmapping, we need to set up texture1's chromakey (or 
        // lack of it) as well. If not, then this will be overridden when 
        // this gets called for tex1.
        pSoftP3RX->P3RXTextureFilterMode.AlphaMapEnable1 = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RXTextureFilterMode.AlphaMapFiltering = __PERMEDIA_DISABLE;
    }
} // __TXT_ConsiderSrcChromaKey


//-----------------------------------------------------------------------------
//
// __TXT_SetupTexture
//
// This is the new all-singing all-dancing texture setup code.
// Return is TRUE if setup succeeded, FALSE if it failed (for ValidateDevice)
// This sets up either texture 0 or texture 1, taking its wrapping, etc,
// info from iTSStage.
//
//-----------------------------------------------------------------------------
BOOL __TXT_SetupTexture (
        P3_THUNKEDDATA * pThisDisplay,
        int iTexNo,
        int iTSStage,
        P3_D3DCONTEXT* pContext,
        P3_SURF_INTERNAL* pTexture,
        P3_SOFTWARECOPY* pSoftP3RX,
        BOOL bBothTexturesValid,
        P3_MIP_BASES *pMipBases)
{
    P3_SURF_FORMAT* pFormatSurface;
    int iT0MaxLevel, iT1MaxLevel;
 
    P3_DMA_DEFS();

    ASSERTDD ( ( iTexNo >= 0 ) && ( iTexNo <= 1 ), 
               "**__TXT_SetupTexture: we only have two texture units!" );

    if ( pTexture != NULL )
    {
        pFormatSurface = pTexture->pFormatSurface;
    }
    else
    {
        // Suceeded, but should never have got here!
        DISPDBG((ERRLVL,"**__TXT_SetupTexture: should never "
                             "be called with handle of NULL"));
        return ( TRUE );
    }

    P3_DMA_GET_BUFFER();
    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    // Set up the texture-relevant things.

    switch ( iTexNo )
    {
        case 0:
        {
            // Set both bits in case we are mipmapping

            pSoftP3RX->P3RXTextureFilterMode.ForceAlphaToOne0 = 
                                            pFormatSurface->bAlpha ? 
                                                    __PERMEDIA_DISABLE : 
                                                    __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXTextureFilterMode.ForceAlphaToOne1 = 
                                            pFormatSurface->bAlpha ? 
                                                    __PERMEDIA_DISABLE : 
                                                    __PERMEDIA_ENABLE;

            // D3D UV Wrapping
            if (pContext->RenderStates[D3DRENDERSTATE_WRAP0+iTSStage] 
                                                            & D3DWRAP_U)
            {
                pSoftP3RX->P4DeltaFormatControl.WrapS = 1;
            }
            else
            {
                pSoftP3RX->P4DeltaFormatControl.WrapS = 0;
            }

            if (pContext->RenderStates[D3DRENDERSTATE_WRAP0+iTSStage] 
                                                            & D3DWRAP_V)
            {
                pSoftP3RX->P4DeltaFormatControl.WrapT = 1;
            }
            else
            {
                pSoftP3RX->P4DeltaFormatControl.WrapT = 0;
            }

            // U Wrapping
            switch (TSSTATE ( iTSStage, D3DTSS_ADDRESSU ))
            {
                case D3DTADDRESS_CLAMP:
                    pSoftP3RX->P3RXTextureCoordMode.WrapS = 
                                            __GLINT_TEXADDRESS_WRAP_CLAMP;
                    pSoftP3RX->P3RXTextureIndexMode0.WrapU = 
                                            P3RX_TEXINDEXMODE_WRAP_CLAMPEDGE;
                    break;
                case D3DTADDRESS_WRAP:
                    pSoftP3RX->P3RXTextureCoordMode.WrapS = 
                                            __GLINT_TEXADDRESS_WRAP_REPEAT;
                    pSoftP3RX->P3RXTextureIndexMode0.WrapU = 
                                            P3RX_TEXINDEXMODE_WRAP_REPEAT;
                    break;
                case D3DTADDRESS_MIRROR:
                    pSoftP3RX->P3RXTextureCoordMode.WrapS = 
                                            __GLINT_TEXADDRESS_WRAP_MIRROR;
                    pSoftP3RX->P3RXTextureIndexMode0.WrapU = 
                                            P3RX_TEXINDEXMODE_WRAP_MIRROR;
                    break;
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown ADDRESSU!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }

            // V Wrapping
            switch (TSSTATE ( iTSStage, D3DTSS_ADDRESSV ))
            {
                case D3DTADDRESS_CLAMP:
                    pSoftP3RX->P3RXTextureCoordMode.WrapT = 
                                            __GLINT_TEXADDRESS_WRAP_CLAMP;
                    pSoftP3RX->P3RXTextureIndexMode0.WrapV = 
                                            P3RX_TEXINDEXMODE_WRAP_CLAMPEDGE;
                    break;
                case D3DTADDRESS_WRAP:
                    pSoftP3RX->P3RXTextureCoordMode.WrapT = 
                                            __GLINT_TEXADDRESS_WRAP_REPEAT;
                    pSoftP3RX->P3RXTextureIndexMode0.WrapV = 
                                            P3RX_TEXINDEXMODE_WRAP_REPEAT;
                    break;
                case D3DTADDRESS_MIRROR:
                    pSoftP3RX->P3RXTextureCoordMode.WrapT = 
                                            __GLINT_TEXADDRESS_WRAP_MIRROR;
                    pSoftP3RX->P3RXTextureIndexMode0.WrapV = 
                                            P3RX_TEXINDEXMODE_WRAP_MIRROR;
                    break;
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown ADDRESSV!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }

#if DX8_3DTEXTURES
            if (pTexture->b3DTexture)
            {
                // W Wrapping
                switch (TSSTATE ( iTSStage, D3DTSS_ADDRESSW ))
                {
                    case D3DTADDRESS_CLAMP:
                        pSoftP3RX->P3RXTextureCoordMode.WrapS1 = 
                                                __GLINT_TEXADDRESS_WRAP_CLAMP;
                        pSoftP3RX->P3RXTextureIndexMode1.WrapU = 
                                            P3RX_TEXINDEXMODE_WRAP_CLAMPEDGE;
                        break;
                    
                    case D3DTADDRESS_WRAP:
                        pSoftP3RX->P3RXTextureCoordMode.WrapS1 = 
                                                __GLINT_TEXADDRESS_WRAP_REPEAT;
                        pSoftP3RX->P3RXTextureIndexMode1.WrapU = 
                                                P3RX_TEXINDEXMODE_WRAP_REPEAT;
                        break;
                    
                    case D3DTADDRESS_MIRROR:
                        pSoftP3RX->P3RXTextureCoordMode.WrapS1 = 
                                                __GLINT_TEXADDRESS_WRAP_MIRROR;
                        pSoftP3RX->P3RXTextureIndexMode1.WrapU = 
                                                P3RX_TEXINDEXMODE_WRAP_MIRROR;
                        break;
                    
                    default:
                        DISPDBG((ERRLVL,"ERROR: Unknown ADDRESSW!"));
                        SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                        break;
                }
            }
#endif // DX8_3DTEXTURES

            if(( TSSTATE( iTSStage, D3DTSS_ADDRESSU ) == D3DTADDRESS_CLAMP ) ||
               ( TSSTATE( iTSStage, D3DTSS_ADDRESSV ) == D3DTADDRESS_CLAMP ))
            {
                if( (TSSTATE( iTSStage, D3DTSS_ADDRESSU ) != D3DTADDRESS_CLAMP) ||
                    (TSSTATE( iTSStage, D3DTSS_ADDRESSV ) != D3DTADDRESS_CLAMP))
                {
                    DISPDBG((ERRLVL,"Warning: One texture coord clamped, but not "
                                "the other - can't appply TextureShift"));
                } 

                pSoftP3RX->P4DeltaFormatControl.TextureShift = 
                                                        __PERMEDIA_DISABLE;
            }
            else
            {
                pSoftP3RX->P4DeltaFormatControl.TextureShift = 
                                                        __PERMEDIA_ENABLE;
            }

            ASSERTDD ( pFormatSurface != NULL, 
                       "** SetupTextureUnitStage: logic error: "
                       "pFormatSurace is NULL" );
            switch (pFormatSurface->DeviceFormat)
            {
                case SURF_CI8:
                    pSoftP3RX->P3RXTextureReadMode0.TextureType = 
                                    P3RX_TEXREADMODE_TEXTURETYPE_8BITINDEXED;
                    break;
                    
                case SURF_YUV422:
                    pSoftP3RX->P3RXTextureReadMode0.TextureType = 
                                    P3RX_TEXREADMODE_TEXTURETYPE_422_YVYU;
                    break;
                    
                default:
                    pSoftP3RX->P3RXTextureReadMode0.TextureType = 
                                    P3RX_TEXREADMODE_TEXTURETYPE_NORMAL;
                    break;
            }
            
            // MAG Filter
            switch(TSSTATE ( iTSStage, D3DTSS_MAGFILTER ))
            {
                case D3DTFG_POINT:
                    pSoftP3RX->P3RXTextureIndexMode0.MagnificationFilter = 
                                    __GLINT_TEXTUREREAD_FILTER_NEAREST;
                    break;
                    
                case D3DTFG_LINEAR:
                    pSoftP3RX->P3RXTextureIndexMode0.MagnificationFilter = 
                                    __GLINT_TEXTUREREAD_FILTER_LINEAR;
                    break;
                    
                case D3DTFG_FLATCUBIC:
                case D3DTFG_GAUSSIANCUBIC:
                case D3DTFG_ANISOTROPIC:
                    DISPDBG((ERRLVL,"ERROR: Unsupported MAGFILTER!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_FILTER );
                    break;
                    
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown MAGFILTER!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_FILTER );
                    break;
            }

            switch(TSSTATE ( iTSStage, D3DTSS_MINFILTER ))
            {
                case D3DTFN_POINT:
                    pSoftP3RX->P3RXTextureIndexMode0.MinificationFilter = 
                                            __GLINT_TEXTUREREAD_FILTER_NEAREST;
                    break;
                    
                case D3DTFN_LINEAR:
                    pSoftP3RX->P3RXTextureIndexMode0.MinificationFilter = 
                                            __GLINT_TEXTUREREAD_FILTER_LINEAR;
                    break;
                    
                case D3DTFN_ANISOTROPIC:
                    DISPDBG((ERRLVL,"ERROR: Unsupported MINFILTER!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_FILTER );
                    break;
                    
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown MINFILTER!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_FILTER );
                    break;
            }

            switch(TSSTATE ( iTSStage, D3DTSS_MIPFILTER ))
            {
                case D3DTFP_NONE:
                    // No need to set the minification filter, it was done above
                    break;
                    
                case D3DTFP_POINT:
                    switch(TSSTATE ( iTSStage, D3DTSS_MINFILTER ))
                    {
                        case D3DTFN_POINT:
                            // Point Min, Point Mip
                            pSoftP3RX->P3RXTextureIndexMode0.MinificationFilter =
                                        __GLINT_TEXTUREREAD_FILTER_NEARMIPNEAREST;
                            break;
                        case D3DTFN_LINEAR:
                            // Linear Min, Point Mip
                            pSoftP3RX->P3RXTextureIndexMode0.MinificationFilter =
                                     __GLINT_TEXTUREREAD_FILTER_LINEARMIPNEAREST;
                            break;
                    }
                    break;
                    
                case D3DTFP_LINEAR:
                    if( bBothTexturesValid )
                    {
                        // We can only do per-poly mipmapping while 
                        // multi-texturing, so don't enable inter-map filtering.

                        // Non-fatal error - drop back to nearest 
                        // mipmap filtering.
                        SET_BLEND_ERROR ( pContext,  BS_INVALID_FILTER );

                        switch(TSSTATE ( iTSStage, D3DTSS_MINFILTER ))
                        {
                            case D3DTFN_POINT:
                                // Point Min, Point Mip
                                pSoftP3RX->P3RXTextureIndexMode0.MinificationFilter =
                                                                    __GLINT_TEXTUREREAD_FILTER_NEARMIPNEAREST;
                                break;
                            case D3DTFN_LINEAR:
                                // Linear Min, Point Mip
                                pSoftP3RX->P3RXTextureIndexMode0.MinificationFilter =
                                                                    __GLINT_TEXTUREREAD_FILTER_LINEARMIPNEAREST;
                                break;
                        }
                    }
                    else
                    {
                        // Single texture - do inter-map filtering

                        switch(TSSTATE ( iTSStage, D3DTSS_MINFILTER ))
                        {
                            case D3DTFN_POINT:
                                // Point Min, Linear Mip
                                pSoftP3RX->P3RXTextureIndexMode0.MinificationFilter =
                                                                    __GLINT_TEXTUREREAD_FILTER_NEARMIPLINEAR;
                                break;
                            case D3DTFN_LINEAR:
                                // Linear Min, Linear Mip
                                pSoftP3RX->P3RXTextureIndexMode0.MinificationFilter =
                                                                    __GLINT_TEXTUREREAD_FILTER_LINEARMIPLINEAR;
                                break;
                        }
                    }
                    break;
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown MIPFILTER!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_FILTER );
                    break;
            }

            // MipMapping
            if( (TSSTATE ( iTSStage, D3DTSS_MIPFILTER ) != D3DTFP_NONE) && 
                (pTexture->bMipMap))
            {
                int iLOD;
                INT iTexLOD;

                DISPDBG(( DBGLVL, "Multiple texture levels" ));

                // Load the mipmap levels for texture 0
                // Mip level from pMipBases->dwTex0ActMaxLevel to 
                // pTexture->iMipLevels will be mapped to base address slot
                // from pMipBases->dwTex0Mipbase to dwTex0MipMax
                ASSERTDD ( pMipBases->dwTex0MipBase == 0, 
                          "** __TXT_SetupTexture: "
                          "Texture 0 mipmap base is not 0" );
                          
                iLOD = pMipBases->dwTex0MipBase;
                iTexLOD = pMipBases->dwTex0ActMaxLevel;
                iT0MaxLevel = iTexLOD;

                while(( iTexLOD < pTexture->iMipLevels ) && 
                      ( iLOD <= (int)pMipBases->dwTex0MipMax ))
                {
                    DISPDBG((DBGLVL, "  Setting Texture Base Address %d to 0x%x", 
                                iLOD, pTexture->MipLevels[iLOD].dwOffsetFromMemoryBase));
                                
                    pSoftP3RX->P3RXTextureMapWidth[iLOD] = 
                                pTexture->MipLevels[iTexLOD].P3RXTextureMapWidth;

#if DX7_TEXMANAGEMENT
                    // If this is a driver managed texture surface, we need 
                    // to use our privately allocated mem ptr
                    if (pTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
                    {                        
                        SEND_P3_DATA_OFFSET(TextureBaseAddr0, 
                                            (DWORD)D3DTMMIPLVL_GETOFFSET(pTexture->MipLevels[iTexLOD], pThisDisplay),
                                            iLOD);
                    }
                    else
#endif
                    {
                        SEND_P3_DATA_OFFSET(TextureBaseAddr0, 
                                            pTexture->MipLevels[iTexLOD].dwOffsetFromMemoryBase, 
                                            iLOD);
                    }

                    iLOD++;
                    iTexLOD++;
                }

                // If both textures are enabled we can't do per-pixel 
                // mipmapping because that uses both sets of texcoord 
                // DDAs to generate the LOD level. So we must do per-poly 
                // mipmapping. Per-poly mipmapping can only be done in 
                // hardware on P4 - we use a Delta renderer on P3 when 
                // mipmapping with both textures enabled.

                if( bBothTexturesValid )
                {
                    DISPDBG(( DBGLVL, "Both textures valid" ));

                    // Do per-poly mipmapping in the P4 DeltaFormat unit

                    pSoftP3RX->P3RXTextureCoordMode.EnableLOD = 
                                                            __PERMEDIA_DISABLE;
                    pSoftP3RX->P3RXTextureCoordMode.EnableDY = 
                                                            __PERMEDIA_DISABLE;
                    pSoftP3RX->P4DeltaFormatControl.PerPolyMipMap = 
                                                            __PERMEDIA_ENABLE;

                    {
                        DWORD d;

                        *(float *)&d = 
                                pContext->MipMapLODBias[TEXSTAGE_0] *
                                pTexture->dwPixelPitch *
                                pTexture->wHeight;

                        SEND_P3_DATA(TextureLODScale, d);                       
                    }
                }
                else
                {
                    DISPDBG(( DBGLVL, "Single texture only" ));

                    // Do per-pixel mipmapping

                
                    pSoftP3RX->P3RXTextureCoordMode.EnableLOD = 
                                                            __PERMEDIA_ENABLE;
                    pSoftP3RX->P3RXTextureCoordMode.EnableDY = 
                                                            __PERMEDIA_ENABLE;
                    pSoftP3RX->P4DeltaFormatControl.PerPolyMipMap = 
                                                            __PERMEDIA_DISABLE;

//@@BEGIN_DDKSPLIT
#if 0
// azn this would disable "automatic" mip mapping and we would be using the
// values supplied by writing into LOD and LOD1 (d3dprim.c) - don't forget!
                    pSoftP3RX->P3RXTextureCoordMode.EnableLOD = 
                                                            __PERMEDIA_DISABLE;
                    pSoftP3RX->P3RXTextureCoordMode.EnableDY = 
                                                            __PERMEDIA_DISABLE;
                    pSoftP3RX->P4DeltaFormatControl.PerPolyMipMap = 
                                                            __PERMEDIA_ENABLE;
                    SEND_P3_DATA(TextureLODScale, 0);
#endif
//@@END_DDKSPLIT
                    {
                        float bias;
                        DWORD b;

                        bias = pContext->TextureStageState[TEXSTAGE_0].m_fVal[D3DTSS_MIPMAPLODBIAS];

                        // Convert LOD bias from float to 6.8

                        myFtoi( &b, bias * 256.0f );

                        SEND_P3_DATA(TextureLODBiasS, b);
                        SEND_P3_DATA(TextureLODBiasT, b);
                    }
                }

                pSoftP3RX->P3RXTextureIndexMode0.MipMapEnable = 
                                                            __PERMEDIA_ENABLE;
            }
            else
            {
                int iTexLOD;

                // No mipmapping.
                DISPDBG(( DBGLVL, "Single texture level" ));

                pSoftP3RX->P3RXTextureCoordMode.EnableLOD = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXTextureCoordMode.EnableDY = __PERMEDIA_DISABLE;
                pSoftP3RX->P4DeltaFormatControl.PerPolyMipMap = 
                                                            __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXTextureIndexMode0.MipMapEnable = 
                                                            __PERMEDIA_DISABLE;

                ASSERTDD ( pMipBases->dwTex0MipBase == 0, 
                          "** __TXT_SetupTexture: "
                          "Texture 0 mipmap base is not 0" );
                          
                // Use the maximum level indicated by D3DTSS_MAXMIPLEVEL
                iTexLOD = pMipBases->dwTex0ActMaxLevel;
                iT0MaxLevel = iTexLOD;

#if DX7_TEXMANAGEMENT
                // If this is a driver managed texture surface, we need 
                // to use our privately allocated mem ptr
                if (pTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
                {                        
                    SEND_P3_DATA_OFFSET(TextureBaseAddr0, 
                                        (DWORD)D3DTMMIPLVL_GETOFFSET(pTexture->MipLevels[iTexLOD], pThisDisplay),
                                        0);
                }
                else
#endif                
                {
                    SEND_P3_DATA_OFFSET(TextureBaseAddr0, 
                                        pTexture->MipLevels[iTexLOD].dwOffsetFromMemoryBase, 
                                        0);
                }

                // No mipmapping, but could be combining the caches.
                pSoftP3RX->P3RXTextureMapWidth[0] = 
                                    pTexture->MipLevels[iTexLOD].P3RXTextureMapWidth;
                pSoftP3RX->P3RXTextureMapWidth[1] = 
                                    pTexture->MipLevels[iTexLOD].P3RXTextureMapWidth;
            }

//@@BEGIN_DDKSPLIT
            // There is only one TextureCoordMode, it is possible that it is
            // not used at all
//@@END_DDKSPLIT
            // Set maximum dimension of the texture
            pSoftP3RX->P3RXTextureCoordMode.Width = pTexture->MipLevels[iT0MaxLevel].logWidth;
            pSoftP3RX->P3RXTextureCoordMode.Height = pTexture->MipLevels[iT0MaxLevel].logHeight;
#if DX7_PALETTETEXTURE
            // If it is a palette indexed texture, we simply follow the chain
            // down from the surface to its palette and pull out the LUT values
            // from the PALETTEENTRY's in the palette.
            ASSERTDD ( pFormatSurface != NULL, "** SetupTextureUnitStage: logic error: pFormatSurace is NULL" );
            if (pFormatSurface->DeviceFormat == SURF_CI8)
            {
                WAIT_FIFO(8);

                pSoftP3RX->P3RXLUTMode.Enable = __PERMEDIA_ENABLE;
                pSoftP3RX->P3RXLUTMode.InColorOrder = __PERMEDIA_ENABLE;        
                SEND_P3_DATA(LUTAddress, 0);
                SEND_P3_DATA(LUTTransfer, 0);
                SEND_P3_DATA(LUTIndex, 0);
                COPY_P3_DATA(LUTMode, pSoftP3RX->P3RXLUTMode);

                // In this case simply download the 256 entries each time the 
                // texture handle changes.
                {
                    DWORD dwCount1, dwCount2;
                    D3DHAL_DP2UPDATEPALETTE *pPalette;  // associated palette
                    LPDWORD lpColorTable;           // array of palette entries
        
                    pPalette = GetPaletteFromHandle(pContext, 
                                                    pTexture->dwPaletteHandle);
                    if (pPalette) // If palette can be found
                    {
                        lpColorTable = (LPDWORD)(pPalette + 1);
                        
                        if (pTexture->dwPaletteFlags & DDRAWIPAL_ALPHA)
                        {
                            for (dwCount1 = 0; dwCount1 < 16; dwCount1++)
                            {
                                P3_ENSURE_DX_SPACE(17);
                                WAIT_FIFO(17);
                                P3RX_HOLD_CMD(LUTData, 16);
                                for (dwCount2 = 0; dwCount2 < 16; dwCount2++)
                                {
                                    *dmaPtr++ = *lpColorTable++;
                                    CHECK_FIFO(1);
                                }
                            }
                        }
                        else
                        {
                            for (dwCount1 = 0; dwCount1 < 16; dwCount1++)
                            {
                                P3_ENSURE_DX_SPACE(17);
                                WAIT_FIFO(17);
                                P3RX_HOLD_CMD(LUTData, 16);
                                for (dwCount2 = 0; dwCount2 < 16; dwCount2++)
                                {
                                    *dmaPtr++ = CHROMA_UPPER_ALPHA(*(DWORD*)lpColorTable++);
                                    CHECK_FIFO(1);
                                }
                            }
                        }
                    }
                    else
                    {
                        DISPDBG((ERRLVL,"Palette handle is missing for CI8 surf!"));
                    }
                }

                // Make sure there is room left over for the rest of the routine
                P3_ENSURE_DX_SPACE(2);
                WAIT_FIFO(2);
                SEND_P3_DATA(LUTIndex, 0);

            }
            else
#endif // DX7_PALETTETEXTURE
            {
                // No LUT.
                P3_ENSURE_DX_SPACE(4);
                WAIT_FIFO(4);
                
                pSoftP3RX->P3RXLUTMode.Enable = __PERMEDIA_DISABLE;
                SEND_P3_DATA(LUTTransfer, __PERMEDIA_DISABLE);
                COPY_P3_DATA(LUTMode, pSoftP3RX->P3RXLUTMode)
            }

#if DX8_3DTEXTURES
            P3_ENSURE_DX_SPACE(4);
            WAIT_FIFO(4);

            if (pTexture->b3DTexture)
            {
                //
                // Set size of each 2D texture slice in texel size to TextureMapSize.
                //
                SEND_P3_DATA(TextureMapSize, pTexture->dwSliceInTexel);
            }
            else
            {
                SEND_P3_DATA(TextureMapSize, 0);
            }
#endif // DX8_3DTEXTURES

            P3_DMA_COMMIT_BUFFER();
            __TXT_ConsiderSrcChromaKey( pContext, pTexture, 0 );
            P3_DMA_GET_BUFFER();

            // Setup TextureReadMode
            pSoftP3RX->P3RXTextureReadMode0.MapBaseLevel = 
                                                    pMipBases->dwTex0MipBase;
            pSoftP3RX->P3RXTextureReadMode0.MapMaxLevel = 
                                                    pMipBases->dwTex0MipMax;
            pSoftP3RX->P3RXTextureReadMode0.Width = pTexture->MipLevels[iT0MaxLevel].logWidth;
            pSoftP3RX->P3RXTextureReadMode0.Height = pTexture->MipLevels[iT0MaxLevel].logHeight;
            pSoftP3RX->P3RXTextureReadMode0.TexelSize = pTexture->dwPixelSize;

            pSoftP3RX->P3RXTextureReadMode0.LogicalTexture = 
                                                            __PERMEDIA_DISABLE;

            // Enable stage 0
            pSoftP3RX->P3RXTextureIndexMode0.Enable = __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXTextureReadMode0.Enable = __PERMEDIA_ENABLE;

            // Never set CombineCaches - chip bug
            pSoftP3RX->P3RXTextureReadMode0.CombineCaches = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureFilterMode.CombineCaches = __PERMEDIA_DISABLE;

            // Always copy TRM0 to TRM1 in case we are combining the caches
            pSoftP3RX->P3RXTextureReadMode1 = pSoftP3RX->P3RXTextureReadMode0;

            // Enable the texture index unit 
            // (this is a bit like the the texture read)
            pSoftP3RX->P3RXTextureIndexMode0.Width = pTexture->MipLevels[iT0MaxLevel].logWidth;
            pSoftP3RX->P3RXTextureIndexMode0.Height = pTexture->MipLevels[iT0MaxLevel].logHeight;

            // Set both formats to be equal for texture 0 - this will be correct 
            // for single-texture per-pixel mipmap or non-mipmapped with a 
            // combined cache. If the second texture is valid it's setup below 
            // will set Format1 appropriately.

            ASSERTDD ( pFormatSurface != NULL, 
                       "** SetupTextureUnitStage: logic error: "
                       "pFormatSurace is NULL" );

            pSoftP3RX->P3RXTextureFilterMode.Format0 = 
                                                pFormatSurface->FilterFormat;
            pSoftP3RX->P3RXTextureFilterMode.Format1 = 
                                                pFormatSurface->FilterFormat;

#if DX8_3DTEXTURES
            if (pTexture->b3DTexture)
            {
                //
                // Enable 3D Texture registers.
                //
                pSoftP3RX->P3RX_P3DeltaMode.Texture3DEnable = __PERMEDIA_ENABLE;
                pSoftP3RX->P3RXTextureReadMode0.Texture3D = __PERMEDIA_ENABLE;
                pSoftP3RX->P3RXTextureIndexMode0.Texture3DEnable = 
                                                            __PERMEDIA_ENABLE;

                //
                // ReadMode1 and IndexMode1 should have same data as 0.
                //
                pSoftP3RX->P3RXTextureReadMode1 = pSoftP3RX->P3RXTextureReadMode0;
                pSoftP3RX->P3RXTextureIndexMode1 = pSoftP3RX->P3RXTextureIndexMode0;

                //
                // And put logDepth into IndexMode1.Width. 
                //
                pSoftP3RX->P3RXTextureIndexMode1.Width = pTexture->logDepth;
            }
            else
            {
                pSoftP3RX->P3RXTextureReadMode0.Texture3D = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXTextureIndexMode0.Texture3DEnable = 
                                                            __PERMEDIA_DISABLE;
            }
#endif // DX8_3DTEXTURES
            break;
        }

        // Texture Stage 1
        case 1:
        {
            pSoftP3RX->P3RXTextureFilterMode.ForceAlphaToOne1 = 
                                            pFormatSurface->bAlpha ? 
                                                    __PERMEDIA_DISABLE : 
                                                    __PERMEDIA_ENABLE;

            // D3D UV Wrapping
            if (pContext->RenderStates[D3DRENDERSTATE_WRAP0+iTSStage] & 
                                                                    D3DWRAP_U)
            {
                pSoftP3RX->P4DeltaFormatControl.WrapS1 = 1;
            }
            else
            {
                pSoftP3RX->P4DeltaFormatControl.WrapS1 = 0;
            }

            if (pContext->RenderStates[D3DRENDERSTATE_WRAP0+iTSStage] & 
                                                                    D3DWRAP_V)
            {
                pSoftP3RX->P4DeltaFormatControl.WrapT1 = 1;
            }
            else
            {
                pSoftP3RX->P4DeltaFormatControl.WrapT1 = 0;
            }

            // U Addressing
            switch (TSSTATE ( iTSStage, D3DTSS_ADDRESSU ))
            {
                case D3DTADDRESS_CLAMP:
                    pSoftP3RX->P3RXTextureCoordMode.WrapS1 = 
                                                __GLINT_TEXADDRESS_WRAP_CLAMP;
                    pSoftP3RX->P3RXTextureIndexMode1.WrapU = 
                                            P3RX_TEXINDEXMODE_WRAP_CLAMPEDGE;
                    break;
                    
                case D3DTADDRESS_WRAP:
                    pSoftP3RX->P3RXTextureCoordMode.WrapS1 = 
                                                __GLINT_TEXADDRESS_WRAP_REPEAT;
                    pSoftP3RX->P3RXTextureIndexMode1.WrapU = 
                                                P3RX_TEXINDEXMODE_WRAP_REPEAT;
                    break;
                    
                case D3DTADDRESS_MIRROR:
                    pSoftP3RX->P3RXTextureCoordMode.WrapS1 = 
                                                __GLINT_TEXADDRESS_WRAP_MIRROR;
                    pSoftP3RX->P3RXTextureIndexMode1.WrapU = 
                                                P3RX_TEXINDEXMODE_WRAP_MIRROR;
                    break;
                    
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown ADDRESSU!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }

            // V Addressing
            switch (TSSTATE ( iTSStage, D3DTSS_ADDRESSV ))
            {
                case D3DTADDRESS_CLAMP:
                    pSoftP3RX->P3RXTextureCoordMode.WrapT1 = 
                                                __GLINT_TEXADDRESS_WRAP_CLAMP;
                    pSoftP3RX->P3RXTextureIndexMode1.WrapV = 
                                            P3RX_TEXINDEXMODE_WRAP_CLAMPEDGE;
                    break;
                    
                case D3DTADDRESS_WRAP:
                    pSoftP3RX->P3RXTextureCoordMode.WrapT1 = 
                                                __GLINT_TEXADDRESS_WRAP_REPEAT;
                    pSoftP3RX->P3RXTextureIndexMode1.WrapV = 
                                                P3RX_TEXINDEXMODE_WRAP_REPEAT;
                    break;
                    
                case D3DTADDRESS_MIRROR:
                    pSoftP3RX->P3RXTextureCoordMode.WrapT1 = 
                                                __GLINT_TEXADDRESS_WRAP_MIRROR;
                    pSoftP3RX->P3RXTextureIndexMode1.WrapV = 
                                                P3RX_TEXINDEXMODE_WRAP_MIRROR;
                    break;
                    
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown ADDRESSV!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_STATE );
                    break;
            }

            if(( TSSTATE( iTSStage, D3DTSS_ADDRESSU ) == D3DTADDRESS_CLAMP ) ||
               ( TSSTATE( iTSStage, D3DTSS_ADDRESSV ) == D3DTADDRESS_CLAMP ))
            {
                if ((TSSTATE( iTSStage, D3DTSS_ADDRESSU ) != D3DTADDRESS_CLAMP) ||
                    (TSSTATE( iTSStage, D3DTSS_ADDRESSV ) != D3DTADDRESS_CLAMP))
                {
                    DISPDBG((ERRLVL,"Warning: One texture coord clamped, but not "
                                "the other - can't appply TextureShift"));
                }
                 
                pSoftP3RX->P4DeltaFormatControl.TextureShift1 = 
                                                            __PERMEDIA_DISABLE;
            }
            else
            {
                pSoftP3RX->P4DeltaFormatControl.TextureShift1 = 
                                                            __PERMEDIA_ENABLE;
            }

            ASSERTDD ( pFormatSurface != NULL, 
                       "** SetupTextureUnitStage: logic error: "
                       "pFormatSurace is NULL" );
            switch (pFormatSurface->DeviceFormat)
            {
                case SURF_CI8:
                    pSoftP3RX->P3RXTextureReadMode1.TextureType = 
                                    P3RX_TEXREADMODE_TEXTURETYPE_8BITINDEXED;
                    break;
                    
                case SURF_YUV422:
                    pSoftP3RX->P3RXTextureReadMode1.TextureType = 
                                    P3RX_TEXREADMODE_TEXTURETYPE_422_YVYU;
                    break;
                    
                default:
                    pSoftP3RX->P3RXTextureReadMode1.TextureType = 
                                    P3RX_TEXREADMODE_TEXTURETYPE_NORMAL;
                    break;
            }
            
            // MAG Filter
            switch(TSSTATE ( iTSStage, D3DTSS_MAGFILTER ))
            {
                case D3DTFG_POINT:
                    pSoftP3RX->P3RXTextureIndexMode1.MagnificationFilter = 
                                            __GLINT_TEXTUREREAD_FILTER_NEAREST;
                    break;
                    
                case D3DTFG_LINEAR:
                    pSoftP3RX->P3RXTextureIndexMode1.MagnificationFilter = 
                                            __GLINT_TEXTUREREAD_FILTER_LINEAR;
                    break;
                    
                case D3DTFG_FLATCUBIC:
                case D3DTFG_GAUSSIANCUBIC:
                case D3DTFG_ANISOTROPIC:
                    DISPDBG((ERRLVL,"ERROR: Unsupported MAGFILTER!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_FILTER );
                    break;
                    
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown MAGFILTER!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_FILTER );
                    break;
            }

            switch(TSSTATE ( iTSStage, D3DTSS_MINFILTER ))
            {
                case D3DTFN_POINT:
                    pSoftP3RX->P3RXTextureIndexMode1.MinificationFilter = 
                                            __GLINT_TEXTUREREAD_FILTER_NEAREST;
                    break;
                case D3DTFN_LINEAR:
                    pSoftP3RX->P3RXTextureIndexMode1.MinificationFilter = 
                                            __GLINT_TEXTUREREAD_FILTER_LINEAR;
                    break;
                case D3DTFN_ANISOTROPIC:
                    DISPDBG((ERRLVL,"ERROR: Unsupported MINFILTER!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNSUPPORTED_FILTER );
                    break;
                default:
                    DISPDBG((ERRLVL,"ERROR: Unknown MINFILTER!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_FILTER );
                    break;
            }

            switch(TSSTATE ( iTSStage, D3DTSS_MIPFILTER ))
            {
                case D3DTFP_NONE:
                    // No need to set the minification filter
                    // it was done above
                    break;
                    
                case D3DTFP_LINEAR:
                case D3DTFP_POINT:
                    if( bBothTexturesValid )
                    {
                        if ( TSSTATE ( iTSStage, D3DTSS_MIPFILTER ) == 
                                                                D3DTFP_LINEAR )
                        {
                            // Can't do trilinear with both textures 
                            // - fall back to per-poly.
                            SET_BLEND_ERROR ( pContext,  BS_INVALID_FILTER );
                        }

                        // We can only do per-poly mipmapping while 
                        // multi-texturing, so don't enable 
                        //inter-map filtering.

                        switch(TSSTATE ( iTSStage, D3DTSS_MINFILTER ))
                        {
                            case D3DTFN_POINT:
                                // Point Min, Point Mip
                                pSoftP3RX->P3RXTextureIndexMode1.MinificationFilter =
                                                                        __GLINT_TEXTUREREAD_FILTER_NEARMIPNEAREST;
                                break;
                                
                            case D3DTFN_LINEAR:
                                // Linear Min, Point Mip
                                pSoftP3RX->P3RXTextureIndexMode1.MinificationFilter =
                                                                        __GLINT_TEXTUREREAD_FILTER_LINEARMIPNEAREST;
                                break;
                        }
                    }
                    else
                    {
                        DISPDBG((ERRLVL,"** Setting up the second stage, but "
                                     "only one texture is valid"));
                    }
                    break;
                    
                default:
                    DISPDBG((ERRLVL,"ERROR: Invalid Mip filter!"));
                    SET_BLEND_ERROR ( pContext,  BSF_UNDEFINED_FILTER );
                    break;
            }

            // MipMapping
            // If the app chooses to have two mip-mapped textures or a 
            // single mip-mapped texture in stage 1 they only get 
            // per-poly mipmapping.
            if( (TSSTATE ( iTSStage, D3DTSS_MIPFILTER ) != D3DTFP_NONE) && 
                 pTexture->bMipMap )
            {
                int iLOD, iTexLOD;

                // Load the mipmap levels for texture 1
                // Mip level from pMipBases->dwTex1ActMaxLevel to
                // pTexture->iMipLevels will be mapped to base address slot
                // from pMipBases->dwTex1Mipbase to dwTex1MipMax
                iLOD = pMipBases->dwTex1MipBase;
                iTexLOD = pMipBases->dwTex1ActMaxLevel;
                iT1MaxLevel = iTexLOD;
 
                P3_ENSURE_DX_SPACE(32);
                WAIT_FIFO(32);

                while(( iTexLOD < pTexture->iMipLevels ) && 
                      ( iLOD <= (int)pMipBases->dwTex1MipMax ))
                {
                    DISPDBG((DBGLVL, "  Setting Texture Base Address %d to 0x%x", 
                                iLOD, 
                                pTexture->MipLevels[iTexLOD].dwOffsetFromMemoryBase));
                                
                    pSoftP3RX->P3RXTextureMapWidth[iLOD] = 
                                pTexture->MipLevels[iTexLOD].P3RXTextureMapWidth;

#if DX7_TEXMANAGEMENT
                    // If this is a driver managed texture surface, we need 
                    // to use our privately allocated mem ptr
                    if (pTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
                    {                        
                        SEND_P3_DATA_OFFSET(TextureBaseAddr0, 
                                            (DWORD)D3DTMMIPLVL_GETOFFSET(pTexture->MipLevels[iTexLOD], pThisDisplay),
                                            iLOD);            
                    }
                    else
#endif   
                    {
                        SEND_P3_DATA_OFFSET(TextureBaseAddr0, 
                                            pTexture->MipLevels[iTexLOD].dwOffsetFromMemoryBase, 
                                            iLOD);
                    }   
                    
                    iLOD++;
                    iTexLOD++;
                }

                pSoftP3RX->P3RXTextureCoordMode.EnableLOD = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXTextureCoordMode.EnableDY = __PERMEDIA_DISABLE;
                pSoftP3RX->P4DeltaFormatControl.PerPolyMipMap1 = 
                                                            __PERMEDIA_ENABLE;
                pSoftP3RX->P3RXTextureIndexMode1.MipMapEnable = 
                                                            __PERMEDIA_ENABLE;

                P3_ENSURE_DX_SPACE(2);
                WAIT_FIFO(2);
                {
                    DWORD d;

                    *(float *)&d = 
                            pContext->MipMapLODBias[TEXSTAGE_1] *
                            pTexture->dwPixelPitch *
                            pTexture->wHeight;

                    SEND_P3_DATA(TextureLODScale1, d);
                }
            }
            else
            {
                int iTexLOD;

                // Use the maximum level indicated by D3DTSS_MAXMIPLEVEL
                iTexLOD = pMipBases->dwTex0ActMaxLevel;
                iT1MaxLevel = iTexLOD;

                pSoftP3RX->P3RXTextureCoordMode.EnableLOD = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXTextureCoordMode.EnableDY = __PERMEDIA_DISABLE;
                pSoftP3RX->P4DeltaFormatControl.PerPolyMipMap1 = 
                                                            __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXTextureIndexMode1.MipMapEnable = 
                                                            __PERMEDIA_DISABLE;

                P3_ENSURE_DX_SPACE(2);
                WAIT_FIFO(2);

#if DX7_TEXMANAGEMENT
                    // If this is a driver managed texture surface, we need 
                    // to use our privately allocated mem ptr
                    if (pTexture->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
                    {                        
                        SEND_P3_DATA_OFFSET(TextureBaseAddr0, 
                                            (DWORD)D3DTMMIPLVL_GETOFFSET(pTexture->MipLevels[iTexLOD], pThisDisplay),
                                            pMipBases->dwTex1MipBase);            
                    }
                    else
#endif
                    {
                        SEND_P3_DATA_OFFSET(TextureBaseAddr0, 
                                            pTexture->MipLevels[iTexLOD].dwOffsetFromMemoryBase,
                                            pMipBases->dwTex1MipBase);
                    }
                    
                // No mipmapping.
                pSoftP3RX->P3RXTextureMapWidth[pMipBases->dwTex1MipBase] = 
                                    pTexture->MipLevels[iTexLOD].P3RXTextureMapWidth;
            }


            ASSERTDD ( pFormatSurface != NULL, 
                       "** SetupTextureUnitStage: logic error: "
                       "pFormatSurace is NULL" );
                       
            if (pFormatSurface->DeviceFormat == SURF_CI8)
            {
                // In the future, this will work as long as texture 0 isn't
                // palettised, or if they share the palette.
                // But that needs some restructuring - the whole LUT setup 
                // should be in a single bit of code in _D3DChangeTextureP3RX, 
                // since it is a shared resource.
                DISPDBG((ERRLVL,"** SetupTextureUnitStage: allow second texture "
                             "to use LUTs"));
                              
                // For now, fail.
                SET_BLEND_ERROR ( pContext,  BSF_TOO_MANY_PALETTES );
            }

            P3_DMA_COMMIT_BUFFER();
            __TXT_ConsiderSrcChromaKey( pContext, pTexture, 1 );
            P3_DMA_GET_BUFFER();

            // Setup TextureReadMode
            pSoftP3RX->P3RXTextureReadMode1.MapBaseLevel = 
                                                    pMipBases->dwTex1MipBase;
            pSoftP3RX->P3RXTextureReadMode1.MapMaxLevel = 
                                                    pMipBases->dwTex1MipMax;
            pSoftP3RX->P3RXTextureReadMode1.Width = pTexture->MipLevels[iT1MaxLevel].logWidth;
            pSoftP3RX->P3RXTextureReadMode1.Height = pTexture->MipLevels[iT1MaxLevel].logHeight;
            pSoftP3RX->P3RXTextureReadMode1.TexelSize = pTexture->dwPixelSize;

            pSoftP3RX->P3RXTextureReadMode1.LogicalTexture = 
                                                            __PERMEDIA_DISABLE;
            
            // Enable the texture index unit (this is a bit like the 
            // the texture read)
            pSoftP3RX->P3RXTextureIndexMode1.Width = pTexture->MipLevels[iT1MaxLevel].logWidth;
            pSoftP3RX->P3RXTextureIndexMode1.Height = pTexture->MipLevels[iT1MaxLevel].logHeight;
            ASSERTDD ( pFormatSurface != NULL, 
                       "** SetupTextureUnitStage: logic error: "
                       "pFormatSurace is NULL" );
            pSoftP3RX->P3RXTextureFilterMode.Format1 = 
                                                pFormatSurface->FilterFormat;

            // Enable stage 1
            pSoftP3RX->P3RXTextureIndexMode1.Enable = __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXTextureReadMode1.Enable = __PERMEDIA_ENABLE;

#if DX7_PALETTETEXTURE
#if 0
            // D3DValidateDeviceP3() will return error code for this case
            ASSERTDD((pFormatSurface->DeviceFormat != SURF_CI8 && 
                      pFormatSurface->DeviceFormat != SURF_CI4),
                     "Texture surface can't be palettized when using a "
                     "second map!");
#endif
#endif

            break;
        }
    }

    P3_DMA_COMMIT_BUFFER();

    return TRUE;
} // __TXT_SetupTexture

//-----------------------------------------------------------------------------
//
// __bD3DTexturesMatch
//
//
// A function to compare the two textures in two D3D stages, and determine
// if they could be satisfied by the same on-chip texture.
//
// int iStage1              D3D stage number of first texture.
// int iStage2              D3D stage number of second texture.
// *pContext                The context.
//
// result:                  TRUE if the textures match, FALSE if they don't.
//
// An ASSERT is triggered if either stage is not using a texture. In the 
// release build, the result will be TRUE, meaning that we could pack both 
// textures stages requirements into one texture (because one or both do 
// not use a texture).
//
//-----------------------------------------------------------------------------
BOOL 
__bD3DTexturesMatch ( 
    int iStage1, 
    int iStage2, 
    P3_D3DCONTEXT* pContext )
{
    ASSERTDD ( iStage1 != iStage2, 
               "** __bD3DTexturesMatch: both stages are the same "
               "- pointless comparison!" );
               
    if ( TSSTATE ( iStage1, D3DTSS_TEXTUREMAP ) == 0 )
    {
        DISPDBG((ERRLVL,"** __bD3DTexturesMatch: first considered stage's "
                     "texture is NULL"));
                      
        return ( TRUE );
    }
    else if ( TSSTATE ( iStage2, D3DTSS_TEXTUREMAP ) == 0 )
    {
        DISPDBG((ERRLVL,"** __bD3DTexturesMatch: second considered stage's "
                      "texture is NULL"));
        return ( TRUE );
    }
    else
    {
        #define CHECK_EQUALITY(name) ( TSSTATE ( iStage1, name ) == TSSTATE ( iStage2, name ) )
        if (CHECK_EQUALITY ( D3DTSS_TEXTUREMAP ) &&
            CHECK_EQUALITY ( D3DTSS_TEXCOORDINDEX ) )
        {
            // Yes, the textures have the same handle and coord set. Do 
            // some further checks.

            // If the pointers are different, or the texcoord sets are 
            // different (for bumpmapping), this is a common occurrance, 
            // and need not be flagged. However, if they are the same, 
            // but a filter mode or something like that is different,
            // it is likely to be an app bug, so flag it.

            if (
                // Should not need to check ADDRESS 
                // - should have been mirrored to ADDRESS[UV].
                CHECK_EQUALITY ( D3DTSS_ADDRESSU ) &&
                CHECK_EQUALITY ( D3DTSS_ADDRESSV ) &&
                CHECK_EQUALITY ( D3DTSS_MAGFILTER ) &&
                CHECK_EQUALITY ( D3DTSS_MINFILTER ) &&
                CHECK_EQUALITY ( D3DTSS_MIPFILTER ) )
                // I should also check all the other variables like 
                // MIPMAPLODBIAS, but they rely on mipmapping being 
                // enabled, etc, so it's more of a hassle. If an app 
                // really does manage to be this perverse, it's doing well!
            {
                // Looks good.
                return ( TRUE );
            }
            else
            {
                // Well, the texcoords agree and the handle agree, but the 
                // others don't. I bet this is an app bug - you are unlikely 
                // to do this deliberately.
                _D3DDisplayWholeTSSPipe ( pContext, WRNLVL );
                DISPDBG((ERRLVL,"** __bD3DTexturesMatch: textures agree in "
                              "handle and texcoord, but not other things - "
                              "likely app bug."));
                return ( FALSE );
            }
        }
        else
        {
            // No, different textures.
            return ( FALSE );
        }
        #undef CHECK_EQUALITY
    }
    return TRUE;
} // __bD3DTexturesMatch  

//-----------------------------------------------------------------------------
//
// _D3DChangeTextureP3RX
//
// This function does whole setup of necessary texturing state  according to
// the current renderestates and texture stage states. Disables texturing
// accordingly if this is needed.
//
//-----------------------------------------------------------------------------

void 
_D3DChangeTextureP3RX(
    P3_D3DCONTEXT* pContext)
{
    P3_SURF_INTERNAL* pTexture0 = NULL;
    P3_SURF_INTERNAL* pTexture1 = NULL;
    P3_THUNKEDDATA * pThisDisplay = pContext->pThisDisplay;
    P3_SOFTWARECOPY* pSoftP3RX = &pContext->SoftCopyGlint;
    P3_MIP_BASES mipBases;
    DWORD* pFlags = &pContext->Flags;   
    INT i, iLastChipStage;
    DWORD dwT0MipLevels, 
          dwT1MipLevels,
          dwTexAppTfactor, 
          dwTexComp0Tfactor, 
          dwTexComp1Tfactor;
    BOOL bBothTexturesValid,
         bProcessChipStage0, 
         bProcessChipStage1, 
         bProcessChipStage2,
         bAlphaBlendDouble;

    P3_DMA_DEFS();

    DBG_ENTRY(_D3DChangeTextureP3RX);  

    pContext->iTexStage[0] = -1;
    pContext->iTexStage[1] = -1;
    // This is checked against the current state at the end of the routine.
    bAlphaBlendDouble = FALSE;

    // Verify if texturing should be disabled
    if ( ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLOROP ) == D3DTOP_DISABLE ) ||
         ( ( TSSTATE ( TEXSTAGE_0, D3DTSS_TEXTUREMAP ) == 0 ) &&
           ( TSSTATE ( TEXSTAGE_1, D3DTSS_COLOROP ) == D3DTOP_DISABLE ) &&
           ( ( ( TSSTATESELECT ( TEXSTAGE_0, D3DTSS_COLORARG1 ) == D3DTA_TEXTURE ) &&
               ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLOROP ) != D3DTOP_SELECTARG2 ) ) ||
             ( ( TSSTATESELECT ( TEXSTAGE_0, D3DTSS_COLORARG2 ) == D3DTA_TEXTURE ) &&
               ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLOROP ) != D3DTOP_SELECTARG1 ) ) )
         ) )
    {
        // Stage 0 is disabled, so they just want the diffuse colour.
        // Or, the texture handle is 0 , stage 1 is D3DTOP_DISABLE and in stage 
        // 0 we are selecting an arg that is not a D3DTA_TEXTURE
       
        DISPDBG((DBGLVL, "All composite units disabled - setting diffuse colour"));
        
        P3_DMA_GET_BUFFER_ENTRIES(20);

        // Turn off texture address generation
        pSoftP3RX->P3RXTextureCoordMode.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(TextureCoordMode, pSoftP3RX->P3RXTextureCoordMode);
    
        // Turn off texture reads
        pSoftP3RX->P3RXTextureReadMode0.Enable = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RXTextureReadMode1.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(TextureReadMode0, pSoftP3RX->P3RXTextureReadMode0);
        COPY_P3_DATA(TextureReadMode1, pSoftP3RX->P3RXTextureReadMode1);
        pSoftP3RX->P3RXTextureIndexMode0.Enable = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RXTextureIndexMode1.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(TextureIndexMode0, pSoftP3RX->P3RXTextureIndexMode0);
        COPY_P3_DATA(TextureIndexMode1, pSoftP3RX->P3RXTextureIndexMode1);

        // Turn off the texture filter mode unit
        pSoftP3RX->P3RXTextureFilterMode.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(TextureFilterMode, pSoftP3RX->P3RXTextureFilterMode);
        
        // Turn off texture color mode unit
        pSoftP3RX->P3RXTextureApplicationMode.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(TextureApplicationMode, 
                     pSoftP3RX->P3RXTextureApplicationMode);

        // Not compositing
        SEND_P3_DATA(TextureCompositeMode, __PERMEDIA_DISABLE);

        *pFlags &= ~SURFACE_TEXTURING;

        pSoftP3RX->P3RXLUTMode.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(LUTMode, pSoftP3RX->P3RXLUTMode);

        // Specular texture can be enabled without texturing on
        COPY_P3_DATA(DeltaMode, pSoftP3RX->P3RX_P3DeltaMode);

        P3_DMA_COMMIT_BUFFER();
    
        // Turn off texturing in the render command
        RENDER_TEXTURE_DISABLE(pContext->RenderCommand);

        pContext->bTextureValid = TRUE;
        pContext->pCurrentTexture[0] = NULL;
        pContext->pCurrentTexture[1] = NULL;

        // Track just for debugging purpouses
        pContext->bTexDisabled = TRUE;

        bAlphaBlendDouble = FALSE;
        if ( bAlphaBlendDouble != pContext->bAlphaBlendMustDoubleSourceColour )
        {
            pContext->bAlphaBlendMustDoubleSourceColour = bAlphaBlendDouble;
            DIRTY_ALPHABLEND(pContext);
        }

        DBG_EXIT(_D3DChangeTextureP3RX,1);  
        return;
    }

    if ( TSSTATE ( TEXSTAGE_0, D3DTSS_TEXTUREMAP ) == 0 )
    if ( ( ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLORARG1 ) == D3DTA_TFACTOR ) &&
           ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLOROP ) == D3DTOP_SELECTARG1 ) ) ||
         ( ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLORARG2 ) == D3DTA_TFACTOR ) &&
           ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLOROP ) == D3DTOP_SELECTARG2 ) ) )
    {
        // This is an unusual way to set up the diffuse color : take
        // it from the the D3DTA_TFACTOR. But some apps use it.
        // we need to treat it separately for the Perm3 setup because
        // it might not be binded with any texture

        DISPDBG((DBGLVL, "Diffuse color comes from D3DTA_TFACTOR"));

        P3_DMA_GET_BUFFER_ENTRIES(30);

        // Turn off texture address generation
        pSoftP3RX->P3RXTextureCoordMode.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(TextureCoordMode, pSoftP3RX->P3RXTextureCoordMode);
    
        // Turn off texture reads
        pSoftP3RX->P3RXTextureReadMode0.Enable = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RXTextureReadMode1.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(TextureReadMode0, pSoftP3RX->P3RXTextureReadMode0);
        COPY_P3_DATA(TextureReadMode1, pSoftP3RX->P3RXTextureReadMode1);
        pSoftP3RX->P3RXTextureIndexMode0.Enable = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RXTextureIndexMode1.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(TextureIndexMode0, pSoftP3RX->P3RXTextureIndexMode0);
        COPY_P3_DATA(TextureIndexMode1, pSoftP3RX->P3RXTextureIndexMode1);

        // Turn off the texture filter mode unit
        pSoftP3RX->P3RXTextureFilterMode.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(TextureFilterMode, pSoftP3RX->P3RXTextureFilterMode);

        // Setup texture color mode unit            
        pSoftP3RX->P3RXTextureApplicationMode.Enable = __PERMEDIA_ENABLE;
        pSoftP3RX->P3RXTextureApplicationMode.ColorA = P3RX_TEXAPP_A_KC;
        pSoftP3RX->P3RXTextureApplicationMode.ColorOperation = P3RX_TEXAPP_OPERATION_PASS_A; 
        pSoftP3RX->P3RXTextureApplicationMode.AlphaA = P3RX_TEXAPP_A_KA;                   
        pSoftP3RX->P3RXTextureApplicationMode.AlphaOperation = P3RX_TEXAPP_OPERATION_PASS_A; 
                
        COPY_P3_DATA(TextureApplicationMode, 
                     pSoftP3RX->P3RXTextureApplicationMode);

        // Setup compositing

        pSoftP3RX->P3RXTextureCompositeAlphaMode0.Enable = __PERMEDIA_ENABLE;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.Arg1 = P3RX_TEXCOMP_FA;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg1 = __PERMEDIA_DISABLE; 
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.A = P3RX_TEXCOMP_ARG1;  
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.Operation = P3RX_TEXCOMP_OPERATION_PASS_A;          
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;          
        COPY_P3_DATA(TextureCompositeAlphaMode0, 
                     pSoftP3RX->P3RXTextureCompositeAlphaMode0);

        pSoftP3RX->P3RXTextureCompositeColorMode0.Enable = __PERMEDIA_ENABLE;
        pSoftP3RX->P3RXTextureCompositeColorMode0.Arg1 = P3RX_TEXCOMP_FC;
        pSoftP3RX->P3RXTextureCompositeColorMode0.InvertArg1 = __PERMEDIA_DISABLE; 
        pSoftP3RX->P3RXTextureCompositeColorMode0.A = P3RX_TEXCOMP_ARG1;  
        pSoftP3RX->P3RXTextureCompositeColorMode0.Operation = P3RX_TEXCOMP_OPERATION_PASS_A;          
        pSoftP3RX->P3RXTextureCompositeColorMode0.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;          
        COPY_P3_DATA(TextureCompositeColorMode0, 
                     pSoftP3RX->P3RXTextureCompositeColorMode0);
                     
        pSoftP3RX->P3RXTextureCompositeAlphaMode1.Enable = __PERMEDIA_DISABLE;                
        COPY_P3_DATA(TextureCompositeAlphaMode1, 
                     pSoftP3RX->P3RXTextureCompositeAlphaMode1);

        pSoftP3RX->P3RXTextureCompositeColorMode1.Enable = __PERMEDIA_DISABLE;                
        COPY_P3_DATA(TextureCompositeColorMode1, 
                     pSoftP3RX->P3RXTextureCompositeColorMode1);
                     
        SEND_P3_DATA(TextureCompositeMode, __PERMEDIA_ENABLE);

        *pFlags &= ~SURFACE_TEXTURING;

        pSoftP3RX->P3RXLUTMode.Enable = __PERMEDIA_DISABLE;
        COPY_P3_DATA(LUTMode, pSoftP3RX->P3RXLUTMode);

        // Specular texture can be enabled without texturing on
        COPY_P3_DATA(DeltaMode, pSoftP3RX->P3RX_P3DeltaMode);

        P3_DMA_COMMIT_BUFFER();

    
    
        // Turn off texturing in the render command
        // RENDER_TEXTURE_DISABLE(pContext->RenderCommand);
        RENDER_TEXTURE_ENABLE(pContext->RenderCommand);

        pContext->bTextureValid = TRUE;
        pContext->pCurrentTexture[0] = NULL;
        pContext->pCurrentTexture[1] = NULL;

        // Track just for debugging purpouses
        pContext->bTexDisabled = FALSE;

        
        DBG_EXIT(_D3DChangeTextureP3RX,1);  
        return;
    }

    // Track just for debugging purpouses
    pContext->bTexDisabled = FALSE;

    // Dump to the debugger our current TSS setup
    _D3DDisplayWholeTSSPipe(pContext, DBGLVL);

    // Deal with the textures.

    // Find the texture mappings. If D3D stage 0 uses a texture, it must 
    // always be chip texture 0 to keep the bumpmap working. Fortunately, 
    // this is the only non-orthogonal case, so everything else can cope 
    // with this restriction.
    
    for ( i = TEXSTAGE_0; i < D3DTSS_MAX; i++ )
    {
        if ( TSSTATE ( i, D3DTSS_COLOROP ) == D3DTOP_DISABLE )
        {
            // Finished processing.
            break;
        }

        // This code could be slightly optimised - if a texture is set up, 
        // but none of the relevant arguments are TEXTURE (with additional 
        // flags), then of course we don't need to set the texture up at all.
        // Normally, both arguments are "relevant", but with SELECTARG1 and 
        // SELECTARG2, one of them is not. Also, watch out for PREMODULATE - 
        // it is an implicit reference to a stage's texture.

        if (
            ( TSSTATE ( i, D3DTSS_TEXTUREMAP ) == 0 ) ||
            ( (
                ( ( TSSTATESELECT ( i, D3DTSS_COLORARG1 ) != D3DTA_TEXTURE ) || 
                  ( TSSTATE ( i, D3DTSS_COLOROP ) == D3DTOP_SELECTARG2     ) ) &&
                ( ( TSSTATESELECT ( i, D3DTSS_COLORARG2 ) != D3DTA_TEXTURE ) || 
                  ( TSSTATE ( i, D3DTSS_COLOROP ) == D3DTOP_SELECTARG1     ) ) &&
                ( ( TSSTATESELECT ( i, D3DTSS_ALPHAARG1 ) != D3DTA_TEXTURE ) || 
                  ( TSSTATE ( i, D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG2     ) ) &&
                ( ( TSSTATESELECT ( i, D3DTSS_ALPHAARG2 ) != D3DTA_TEXTURE ) || 
                  ( TSSTATE ( i, D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG1     ) )
              ) &&
              ( TSSTATE ( i, D3DTSS_COLOROP ) != D3DTOP_PREMODULATE ) &&
              ( TSSTATE ( i-1, D3DTSS_COLOROP ) != D3DTOP_PREMODULATE )
            ) )
        {
            // This D3D stage doesn't use a texture.
            pContext->iStageTex[i] = -1;
        }
        else
        {
            // Note that the below code should be put into a little loop
            // for any future devices that have more than 2 textures, otherwise
            // the code will get big, nested and crufty. But for only 2, it's
            // manageable, and slightly faster this way.

            // A texture is used - is texture 0 free?
            if ( pContext->iTexStage[0] == -1 )
            {
                // Texture 0 is free - make it this stage.
                ASSERTDD ( pContext->iTexStage[1] == -1, 
                           "** _D3DChangeTextureP3RX: pContext->iTexStage[1] "
                           "should be -1 if pContext->iTexStage[0] is" );
                pContext->iTexStage[0] = i;
                pContext->iStageTex[i] = 0;
            }
            else
            {
                // Texture 0 is assigned - see if this is the same as it.
                if ( __bD3DTexturesMatch ( i, 
                                           pContext->iTexStage[0], 
                                           pContext ) )
                {
                    // Yes, they match - no need to use texture 1.
                    pContext->iStageTex[i] = 0;
                }
                else
                {
                    // No, they don't match. Is texture 1 free?
                    if ( pContext->iTexStage[1] == -1 )
                    {
                        // Texture 1 is free - make it this stage.
                        ASSERTDD ( pContext->iTexStage[0] != -1, 
                                   "** _D3DChangeTextureP3RX: "
                                   "pContext->iTexStage[0] should not be "
                                   "-1 if pContext->iTexStage[1] is not." );
                        pContext->iTexStage[1] = i;
                        pContext->iStageTex[i] = 1;
                    }
                    else
                    {
                        // Texture 1 is assigned - see if this is the same 
                        // as it.
                        if ( __bD3DTexturesMatch ( i, 
                                                   pContext->iTexStage[1], 
                                                   pContext ) )
                        {
                            // Yes, they match - mark it.
                            pContext->iStageTex[i] = 1;
                        }
                        else
                        {
                            // No, they don't match, and both chip textures 
                            // have been assigned. Fail a ValidateDevice().
                            DISPDBG((ERRLVL,"** _D3DChangeTextureP3RX: app tried "
                                         "to use more than two textures."));
                            SET_BLEND_ERROR ( pContext,  BSF_TOO_MANY_TEXTURES );
                            pContext->iStageTex[i] = -1;
                        }
                    }
                }
            }
        }

        // A quick sanity check.
#if DBG
        if ( TSSTATE ( i, D3DTSS_TEXTUREMAP ) == 0 )
        {
            // That's fine, then.
            ASSERTDD ( pContext->iStageTex[i] == -1, 
                       "** _D3DChangeTextureP3RX: something failed with the "
                       "texture-assignment logic" );
        }
        else if ( pContext->iStageTex[i] == -1 )
        {
            // That's fine - texture may have been set up but not referenced.
        }
        else if ( pContext->iTexStage[pContext->iStageTex[i]] == -1 )
        {
            // Oops.
            DISPDBG((ERRLVL,"** _D3DChangeTextureP3RX: something failed with "
                          "the texture-assignment logic"));
        }
        else if ( pContext->iTexStage[pContext->iStageTex[i]] == i )
        {
            // That's fine, then.
        }
        else if ( __bD3DTexturesMatch ( i, 
                                        pContext->iTexStage[pContext->iStageTex[i]], 
                                        pContext ) )
        {
            // That's fine, then.
        }
        else
        {
            // Oops.
            DISPDBG((ERRLVL,"** _D3DChangeTextureP3RX: something failed with "
                          "the texture-assignment logic"));
        }
#endif // DBG
    }
    
    // And a few more gratuitous sanity checks at the end of the loop.
    ASSERTDD ( ( pContext->iTexStage[0] == -1 ) || 
               ( pContext->iStageTex[pContext->iTexStage[0]] == 0 ), 
               "** _D3DChangeTextureP3RX: something failed with the "
               "texture-assignment logic" );
               
    ASSERTDD ( ( pContext->iTexStage[1] == -1 ) || 
               ( pContext->iStageTex[pContext->iTexStage[1]] == 1 ), 
               "** _D3DChangeTextureP3RX: something failed with the "
               "texture-assignment logic" );

#if DBG
    if ( pContext->iTexStage[0] != -1 )
    {
        DISPDBG((DBGLVL, "Setting new texture0 data, Handle: 0x%x", 
                    TSSTATE ( pContext->iTexStage[0], D3DTSS_TEXTUREMAP )));
    }
    else
    {
        DISPDBG((DBGLVL, "Texture0 not used" ));
    }
    
    if ( pContext->iTexStage[1] != -1 )
    {
        DISPDBG((DBGLVL, "Setting new texture1 data, Handle: 0x%x", 
                    TSSTATE ( pContext->iTexStage[1], D3DTSS_TEXTUREMAP )));
    }
    else
    {
        DISPDBG((DBGLVL, "Texture1 not used" ));
    }
#endif //DBG
    
    // Set the texture valid flag to true.  
    // If anything resets it then the texture state is invalid.
    pContext->bTextureValid = TRUE;
    pContext->bCanChromaKey = FALSE;
    pContext->bTex0Valid = FALSE;
    pContext->bTex1Valid = FALSE;
    pContext->bStage0DotProduct = FALSE;

    // Set up the textures.
    if ( pContext->iTexStage[0] != -1 )
    {
        // Setup texture 0.
        pTexture0 = GetSurfaceFromHandle(pContext, 
                                         TSSTATE(pContext->iTexStage[0], 
                                                 D3DTSS_TEXTUREMAP) );
        if (NULL == pTexture0)
        {
            DISPDBG((ERRLVL, "ERROR: Texture Surface (0) is NULL"));
            DBG_EXIT(_D3DChangeTextureP3RX,1);  
            return;            
        }
        
#if DX7_TEXMANAGEMENT  
        if (pTexture0->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
        {
            if (!_D3D_TM_Preload_Tex_IntoVidMem(pContext, pTexture0))
            {
                return; // something bad happened !!!
            }

            _D3D_TM_TimeStampTexture(pContext->pTextureManager,
                                     pTexture0);        
        }
#endif // DX7_TEXMANAGEMENT                                                 

        pContext->bTex0Valid = 
                    __TXT_ValidateTextureUnitStage(pContext, 
                                                   0, 
                                                   pContext->iTexStage[0],
                                                   pTexture0 );
        if ( !pContext->bTex0Valid )
        {
            SET_BLEND_ERROR ( pContext,  BSF_INVALID_TEXTURE );
            // Pretend that no texture was set.
            pSoftP3RX->P3RXTextureReadMode0.Enable = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureIndexMode0.Enable = __PERMEDIA_DISABLE;
            pContext->bTex0Valid = FALSE;
            pTexture0 = NULL;
        }
    }
    else
    {
        pSoftP3RX->P3RXTextureReadMode0.Enable = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RXTextureIndexMode0.Enable = __PERMEDIA_DISABLE;
        pContext->bTex0Valid = FALSE;
        pTexture0 = NULL;
    }

    if ( pContext->iTexStage[1] != -1 )
    {
        // Setup texture 1.
        if ( pContext->iTexStage[0] == -1 )
        {
            DISPDBG((ERRLVL,"** _D3DChangeTextureP3RX: Should not be "
                          "using tex1 if tex0 not used."));
            SET_BLEND_ERROR ( pContext,  BSF_TOO_MANY_BLEND_STAGES );
        }
        
        pTexture1 = GetSurfaceFromHandle(pContext, 
                                         TSSTATE ( pContext->iTexStage[1],
                                                   D3DTSS_TEXTUREMAP ) );
        if (NULL == pTexture1)
        {
            DISPDBG((ERRLVL, "ERROR: Texture Surface (1) is NULL"));
            DBG_EXIT(_D3DChangeTextureP3RX,1);  
            return;            
        }
                                                   

#if DX7_TEXMANAGEMENT  
        if (pTexture1->dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
        {
            if (!_D3D_TM_Preload_Tex_IntoVidMem(pContext, pTexture1))
            {
                return; // something bad happened !!!
            }

            _D3D_TM_TimeStampTexture(pContext->pTextureManager,
                                     pTexture1);        
        }
#endif // DX7_TEXMANAGEMENT                                                     

        pContext->bTex1Valid = 
                    __TXT_ValidateTextureUnitStage(pContext, 
                                                   1, 
                                                   pContext->iTexStage[1], 
                                                   pTexture1 );
        if ( !pContext->bTex1Valid )
        {
            SET_BLEND_ERROR ( pContext,  BSF_INVALID_TEXTURE );
            // Pretend that no texture was set.
            pSoftP3RX->P3RXTextureReadMode1.Enable = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureIndexMode1.Enable = __PERMEDIA_DISABLE;
            pContext->bTex1Valid = FALSE;
            pTexture1 = NULL;
        }
    }
    else
    {
        pSoftP3RX->P3RXTextureReadMode1.Enable = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RXTextureIndexMode1.Enable = __PERMEDIA_DISABLE;
        pContext->bTex1Valid = FALSE;
        pTexture1 = NULL;
    }

    bBothTexturesValid = pContext->bTex0Valid && pContext->bTex1Valid;

    if( pContext->bTex0Valid )
    {
        dwT0MipLevels = pContext->TextureStageState[0].m_dwVal[D3DTSS_MAXMIPLEVEL];
#if DX7_TEXMANAGEMENT        
        if ( dwT0MipLevels < pTexture0->m_dwTexLOD)
        {
            dwT0MipLevels = pTexture0->m_dwTexLOD;
        }
#endif // DX7_TEXMANAGEMENT
        if (dwT0MipLevels > ((DWORD)(pTexture0->iMipLevels - 1))) 
        {
            // Set the actuall maximum mip level that will be used in rendering
            mipBases.dwTex0ActMaxLevel = pTexture0->iMipLevels - 1;

            dwT0MipLevels = 1;
        }
        else
        {
            // Set the actuall maximum mip level that will be used in rendering
            mipBases.dwTex0ActMaxLevel = dwT0MipLevels;

            dwT0MipLevels = pTexture0->iMipLevels - dwT0MipLevels;
        }
    }

    if( pContext->bTex1Valid )
    {
        ASSERTDD ( pContext->bTex0Valid, 
                   "** _D3DChangeTextureP3RX: tex1 should not be used "
                   "unless tex0 is used as well" );

        dwT1MipLevels = pContext->TextureStageState[1].m_dwVal[D3DTSS_MAXMIPLEVEL];
#if DX7_TEXMANAGEMENT        
        if ( dwT1MipLevels < pTexture1->m_dwTexLOD)
        {
            dwT1MipLevels = pTexture1->m_dwTexLOD;
        }
#endif // DX7_TEXMANAGEMENT        
        if (dwT1MipLevels > ((DWORD)(pTexture1->iMipLevels - 1))) 
        {
            // Set the actuall maximum mip level that will be used in rendering
            mipBases.dwTex1ActMaxLevel = pTexture1->iMipLevels - 1;

            dwT1MipLevels = 1;
        }
        else
        {
            // Set the actuall maximum mip level that will be used in rendering
            mipBases.dwTex1ActMaxLevel = dwT1MipLevels;

            dwT1MipLevels = pTexture1->iMipLevels - dwT1MipLevels;
        }

        // Enable generation of the second set of texture coordinates.
        // Strictly, we should check whether texture 0 is being used, and
        // if not move the second texture to the first (thus enabling 
        // mipmapping, etc) but that's for later.
        pSoftP3RX->P3RX_P3DeltaMode.TextureEnable1 = __PERMEDIA_ENABLE;
        pSoftP3RX->P3RX_P3DeltaControl.ShareQ = 1;
    }
    else
    {
        // Turn off generation of the second set of texture coordinates
        pSoftP3RX->P3RX_P3DeltaMode.TextureEnable1 = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RX_P3DeltaControl.ShareQ = 0;
    }

    if( bBothTexturesValid )
    {
        float totBases, baseRatio;
        DWORD t0Count, res;

        totBases = (float)dwT0MipLevels + dwT1MipLevels;

        // Adjust mip levels to fit in N - 2 slots as each texture
        // needs at least one slot.

        baseRatio = ( P3_TEX_MAP_MAX_LEVEL - 1 ) / totBases;

        // Calculate number of slots for texture 0, texture 1 then
        // gets the remainder.

        myFtoi( &res, dwT0MipLevels * baseRatio );
        t0Count = 1 + res;

        ASSERTDD( t0Count > 0, "No slots for texture 0" );
        ASSERTDD( t0Count <= P3_TEX_MAP_MAX_LEVEL, "No slots for texture 1" );

#define FIXED_ALLOC 0
#if FIXED_ALLOC
        mipBases.dwTex0MipBase = 0;
        mipBases.dwTex0MipMax  = min( dwT0MipLevels - 1, 7 );
        mipBases.dwTex1MipBase = 8;
        mipBases.dwTex1MipMax  = 8 + min( dwT1MipLevels - 1, 
                                          P3_TEX_MAP_MAX_LEVEL - 8 );
#else
        mipBases.dwTex0MipBase = 0;
        mipBases.dwTex0MipMax  = min( dwT0MipLevels - 1, t0Count - 1 );
        mipBases.dwTex1MipBase = t0Count;
        mipBases.dwTex1MipMax  = t0Count + min( dwT1MipLevels - 1, 
                                                P3_TEX_MAP_MAX_LEVEL - t0Count );
#endif
    }
    else
    {
        if( pContext->bTex0Valid )
        {
            mipBases.dwTex0MipBase = 0;
            mipBases.dwTex0MipMax  = min( dwT0MipLevels - 1, 
                                          P3_TEX_MAP_MAX_LEVEL );
            mipBases.dwTex1MipBase = 0;
            mipBases.dwTex1MipMax  = min( dwT0MipLevels - 1, 
                                          P3_TEX_MAP_MAX_LEVEL );
        }

        if( pContext->bTex1Valid )
        {
            mipBases.dwTex0MipBase = 0;
            mipBases.dwTex0MipMax  = min( dwT1MipLevels - 1, 
                                          P3_TEX_MAP_MAX_LEVEL );
            mipBases.dwTex1MipBase = 0;
            mipBases.dwTex1MipMax  = min( dwT1MipLevels - 1, 
                                          P3_TEX_MAP_MAX_LEVEL );
        }
    }

    DISPDBG(( DBGLVL, "tex0 base %d", mipBases.dwTex0MipBase ));
    DISPDBG(( DBGLVL, "tex0 max  %d", mipBases.dwTex0MipMax ));
    DISPDBG(( DBGLVL, "tex1 base %d", mipBases.dwTex1MipBase ));
    DISPDBG(( DBGLVL, "tex1 max  %d", mipBases.dwTex1MipMax ));

    // Recalculate the LOD biases for per-poly mipmapping
    pContext->MipMapLODBias[TEXSTAGE_0] =
             pow4( pContext->TextureStageState[TEXSTAGE_0].
                                                m_fVal[D3DTSS_MIPMAPLODBIAS] );

    pContext->MipMapLODBias[TEXSTAGE_1] = 
             pow4( pContext->TextureStageState[TEXSTAGE_1].
                                                m_fVal[D3DTSS_MIPMAPLODBIAS] );

    if ( pTexture0 != NULL )
    {
        __TXT_SetupTexture ( pThisDisplay, 
                             0, 
                             pContext->iTexStage[0], 
                             pContext, 
                             pTexture0, 
                             pSoftP3RX, 
                             bBothTexturesValid, 
                             &mipBases);
    }
    
    if ( pTexture1 != NULL )
    {
        __TXT_SetupTexture ( pThisDisplay, 
                             1, 
                             pContext->iTexStage[1], 
                             pContext, 
                             pTexture1, 
                             pSoftP3RX, 
                             bBothTexturesValid, 
                             &mipBases);

#if DX7_PALETTETEXTURE
        if (GET_BLEND_ERROR(pContext) == BSF_TOO_MANY_PALETTES)
        {
            if (pTexture0 && 
                (pTexture0->dwPaletteHandle == pTexture1->dwPaletteHandle)) 
            {
                RESET_BLEND_ERROR(pContext);
            }
        }
#endif
    }

    // Fix up the D3DRENDERSTATE_MODULATE case.
    if( pTexture0 != NULL )
    {
        if( pContext->Flags & SURFACE_MODULATE )
        {
            // If SURFACE_MODULATE is set then we must have seen a 
            // DX5-style texture blend
            // Note : bAlpha is true for CI8 and CI4 textures

            BOOL bSelectArg1 = pTexture0->pFormatSurface->bAlpha;

#if DX7_PALETTETEXTURE
            if( pTexture0->pixFmt.dwFlags & DDPF_PALETTEINDEXED8 )
            {
                bSelectArg1 = pTexture0->dwPaletteFlags & DDRAWIPAL_ALPHA;
            }
#endif            

            if( bSelectArg1 )
            {
                TSSTATE( pContext->iChipStage[0], D3DTSS_ALPHAOP ) = 
                                                            D3DTOP_SELECTARG1;
            }
            else
            {
                TSSTATE( pContext->iChipStage[0], D3DTSS_ALPHAOP ) = 
                                                            D3DTOP_SELECTARG2;
            }
        }
    }

    P3_DMA_GET_BUFFER();

    // Textures set up - now do the blending.

    // These might be overidden later for special blends.
    dwTexAppTfactor = pContext->RenderStates[D3DRENDERSTATE_TEXTUREFACTOR];
    dwTexComp0Tfactor = pContext->RenderStates[D3DRENDERSTATE_TEXTUREFACTOR];
    dwTexComp1Tfactor = pContext->RenderStates[D3DRENDERSTATE_TEXTUREFACTOR];

    // Detect the stage 0 & 1 bumpmap setup code.
    if (( TSSTATE ( TEXSTAGE_0, D3DTSS_TEXTUREMAP ) != 0 ) &&
        ( TSSTATE ( TEXSTAGE_1, D3DTSS_TEXTUREMAP ) != 0 ) &&
        ( TSSTATE ( TEXSTAGE_2, D3DTSS_COLOROP ) != D3DTOP_DISABLE ) )
    {
        // Looking good for a bumpmap. Now find various special cases.
        // First of all, do they want anything in the stage 2 current colour?
        if (
            ( ( ( TSSTATEINVMASK ( TEXSTAGE_2, D3DTSS_COLORARG1 ) != D3DTA_CURRENT ) &&
                ( TSSTATEINVMASK ( TEXSTAGE_2, D3DTSS_COLORARG2 ) != D3DTA_CURRENT ) ) ||
              ( ( TSSTATE ( TEXSTAGE_2, D3DTSS_COLOROP ) == D3DTOP_SELECTARG1 ) &&
                ( TSSTATEINVMASK ( TEXSTAGE_2, D3DTSS_COLORARG1 ) != D3DTA_CURRENT ) ) ||
              ( ( TSSTATE ( TEXSTAGE_2, D3DTSS_COLOROP ) == D3DTOP_SELECTARG2 ) &&
                ( TSSTATEINVMASK ( TEXSTAGE_2, D3DTSS_COLORARG2 ) != D3DTA_CURRENT ) ) ) &&

              ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLOROP ) != D3DTOP_DOTPRODUCT3 ) &&
              ( TSSTATE ( TEXSTAGE_1, D3DTSS_COLOROP ) != D3DTOP_DOTPRODUCT3 ) )
        {
            // Nope - they don't care what the current colour channel is, and
            // no dotproducts are used in stages 0 and 1 (they affect the alpha 
            // channel) so ignore what is in the colour channel - this is a 
            // bumpmap so far.

            // Now see if they want a bumpmap or an inverted bumpmap. People 
            // are so fussy.
            
            // Check first stage.
            if (( ( ( TSSTATE ( TEXSTAGE_0, D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG1 ) &&
                    ( TSSTATEALPHA ( TEXSTAGE_0, D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) ) ||
                  ( ( TSSTATE ( TEXSTAGE_0, D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG2 ) &&
                    ( TSSTATEALPHA ( TEXSTAGE_0, D3DTSS_ALPHAARG2 ) == D3DTA_TEXTURE ) ) ) &&
                ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAOP ) == D3DTOP_ADDSIGNED ) )
            {
                // First stage fine and not inverted. Check second stage.
                if (( ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == ( D3DTA_TEXTURE | D3DTA_COMPLEMENT ) ) &&
                      ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == D3DTA_CURRENT ) ) ||
                    ( ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == ( D3DTA_TEXTURE | D3DTA_COMPLEMENT ) ) &&
                      ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == D3DTA_CURRENT ) ) )
                {
                    // Fine, not inverted.
                    pContext->bBumpmapEnabled = TRUE;
                    pContext->bBumpmapInverted = FALSE;
                }
                else if (
                    ( ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == ( D3DTA_CURRENT | D3DTA_COMPLEMENT ) ) &&
                      ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == D3DTA_TEXTURE ) ) ||
                    ( ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == ( D3DTA_CURRENT | D3DTA_COMPLEMENT ) ) &&
                      ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) ) )
                {
                    // Fine, inverted.
                    pContext->bBumpmapEnabled = TRUE;
                    pContext->bBumpmapInverted = TRUE;
                }
                else
                {
                    // Nope, second stage is no good.
                    pContext->bBumpmapEnabled = FALSE;
                    pContext->bBumpmapInverted = FALSE;
                }
            }
            else if (
                ( ( ( TSSTATE ( TEXSTAGE_0, D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG1 ) &&
                    ( TSSTATEALPHA ( TEXSTAGE_0, D3DTSS_ALPHAARG1 ) == (D3DTA_TEXTURE | D3DTA_COMPLEMENT) ) ) ||
                  ( ( TSSTATE ( TEXSTAGE_0, D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG2 ) &&
                    ( TSSTATEALPHA ( TEXSTAGE_0, D3DTSS_ALPHAARG2 ) == (D3DTA_TEXTURE | D3DTA_COMPLEMENT) ) ) ) &&
                ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAOP ) == D3DTOP_ADDSIGNED ) )
            {
                // First stage fine and inverted. Check second stage.
                if (( ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) &&
                      ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == D3DTA_CURRENT ) ) ||
                    ( ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == D3DTA_TEXTURE ) &&
                      ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == D3DTA_CURRENT ) ) )
                {
                    // Fine, inverted.
                    pContext->bBumpmapEnabled = TRUE;
                    pContext->bBumpmapInverted = TRUE;
                }
                else if (
                    ( ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == ( D3DTA_CURRENT | D3DTA_COMPLEMENT ) ) &&
                      ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == ( D3DTA_TEXTURE | D3DTA_COMPLEMENT ) ) ) ||
                    ( ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == ( D3DTA_CURRENT | D3DTA_COMPLEMENT ) ) &&
                      ( TSSTATEALPHA ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == ( D3DTA_TEXTURE | D3DTA_COMPLEMENT ) ) ) )
                {
                    // Fine, not inverted.
                    pContext->bBumpmapEnabled = TRUE;
                    pContext->bBumpmapInverted = FALSE;
                }
                else
                {
                    // Nope, second stage is no good.
                    pContext->bBumpmapEnabled = FALSE;
                    pContext->bBumpmapInverted = FALSE;
                }
            }
            else
            {
                // Nope, first stage is no good.
                pContext->bBumpmapEnabled = FALSE;
                pContext->bBumpmapInverted = FALSE;
            }
        }
        else
        {
            // Could do some more checking, e.g. is all they want in the current colour
            // channel easily available from a single input, e.g. tex0.c, in which case
            // that's fine. A non-bumpmap variant also needs to sense that the first
            // stage is simply a selectarg1/2 and thus can ignore the first stage as
            // a texcomp stage.
            // But that's for later.
            pContext->bBumpmapEnabled = FALSE;
            pContext->bBumpmapInverted = FALSE;
        }

    }
    else
    {
        pContext->bBumpmapEnabled = FALSE;
        pContext->bBumpmapInverted = FALSE;
    }

    if ( pContext->bBumpmapEnabled )
    {
        DISPDBG((DBGLVL,"Enabling emboss bumpmapping"));
        // Remap stages 1 & 2 out of existence.
        pContext->iChipStage[0] = TEXSTAGE_2;
        pContext->iChipStage[1] = TEXSTAGE_3;
        pContext->iChipStage[2] = TEXSTAGE_4;
        pContext->iChipStage[3] = TEXSTAGE_5;
    }
    else
    {
        // Normal mapping.
        pContext->iChipStage[0] = TEXSTAGE_0;
        pContext->iChipStage[1] = TEXSTAGE_1;
        pContext->iChipStage[2] = TEXSTAGE_2;
        pContext->iChipStage[3] = TEXSTAGE_3;
    }

    iLastChipStage = 0;
    // Set these flags to FALSE as the stages are processed.
    bProcessChipStage0 = TRUE;
    bProcessChipStage1 = TRUE;
    bProcessChipStage2 = TRUE;

    // Turn on the basic enables.
    pSoftP3RX->P3RXTextureApplicationMode.Enable = __PERMEDIA_ENABLE;
//  pSoftP3RX->P3RXTextureApplicationMode.EnableKs = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureApplicationMode.EnableKd = __PERMEDIA_DISABLE;
    pSoftP3RX->P3RXTextureApplicationMode.MotionCompEnable = __PERMEDIA_DISABLE;


    // Handle chip stage 0.

    // Detect the very special-case glossmap+bumpmap code. There is no easy way
    // to generalise it, so the whole chunk gets checked here.
    if ( bProcessChipStage0 && bProcessChipStage1 && bProcessChipStage2 && pContext->bTex0Valid && pContext->bTex1Valid &&
        // Colour channel of stage 0 can be whatever you want.
        ( TSSTATE ( TEXSTAGE_1, D3DTSS_COLOROP ) == D3DTOP_MODULATEALPHA_ADDCOLOR ) &&  // Early-out test - nothing uses this!
        ( TSSTATE ( TEXSTAGE_0, D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG1 ) &&
        ( TSSTATE ( TEXSTAGE_0, D3DTSS_ALPHAARG1 ) == D3DTA_DIFFUSE ) &&
        ( TSSTATE ( TEXSTAGE_1, D3DTSS_COLORARG1 ) == D3DTA_CURRENT ) &&
        ( TSSTATE ( TEXSTAGE_1, D3DTSS_COLORARG2 ) == D3DTA_TEXTURE ) &&
        ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG1 ) &&
        ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) &&
        ( TSSTATE ( TEXSTAGE_2, D3DTSS_COLOROP ) == D3DTOP_SELECTARG1 ) &&
        ( TSSTATE ( TEXSTAGE_2, D3DTSS_COLORARG1 ) == D3DTA_CURRENT ) &&
        ( TSSTATE ( TEXSTAGE_2, D3DTSS_ALPHAOP ) == D3DTOP_ADDSIGNED ) &&
        ( TSSTATEINVMASK ( TEXSTAGE_2, D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) &&
        ( TSSTATEINVMASK ( TEXSTAGE_2, D3DTSS_ALPHAARG2 ) == D3DTA_CURRENT ) &&
        ( TSSTATE ( TEXSTAGE_3, D3DTSS_COLOROP ) == D3DTOP_MODULATE2X ) &&
        ( TSSTATE ( TEXSTAGE_3, D3DTSS_COLORARG1 ) == D3DTA_CURRENT ) &&
        ( TSSTATE ( TEXSTAGE_3, D3DTSS_COLORARG2 ) == (D3DTA_CURRENT | D3DTA_ALPHAREPLICATE) ) &&
        ( TSSTATE ( TEXSTAGE_3, D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG1 ) &&
        ( TSSTATE ( TEXSTAGE_3, D3DTSS_ALPHAARG1 ) == D3DTA_TFACTOR ) &&
        ( TSSTATE ( TEXSTAGE_4, D3DTSS_COLOROP ) == D3DTOP_DISABLE ) &&
        ( pContext->iStageTex[0] == 0 ) &&
        ( pContext->iStageTex[1] == 1 ) &&
        ( pContext->iStageTex[2] == 0 )
        )
    {
        int iMode;
        // OK, looks good. Check which way round the bumpmapping is being done.
        if (( TSSTATE ( TEXSTAGE_2, D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) &&
            ( TSSTATE ( TEXSTAGE_2, D3DTSS_ALPHAARG2 ) == (D3DTA_CURRENT | D3DTA_COMPLEMENT) ) )
        {
            // Standard emboss.
            iMode = 0;
        }
        else if (( TSSTATE ( TEXSTAGE_2, D3DTSS_ALPHAARG1 ) == (D3DTA_TEXTURE | D3DTA_COMPLEMENT) ) &&
                 ( TSSTATE ( TEXSTAGE_2, D3DTSS_ALPHAARG2 ) == D3DTA_CURRENT ) )
        {
            // Inverted emboss.
            iMode = 1;
        }
        else
        {
            // No good - can't do it.
            iMode = -1;
        }

        if ( iMode == -1 )
        {
            // Nope.
            SET_BLEND_ERROR ( pContext,  BSF_TOO_MANY_BLEND_STAGES );
            bProcessChipStage0 = FALSE;
            bProcessChipStage1 = FALSE;
            bProcessChipStage2 = FALSE;
            iLastChipStage = 3;
        }
        else
        {
            // Set up the colour channel of tc0.
            // Alpha channel will be overridden later.
            __TXT_TranslateToChipBlendMode(pContext, 
                                           &pContext->TextureStageState[0], 
                                           pSoftP3RX, 
                                           0, 
                                           0);

            // Pass through bump.a, maybe inverted.
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Enable = __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Operation = P3RX_TEXCOMP_OPERATION_PASS_A;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Arg1 = P3RX_TEXCOMP_HEIGHTA;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Arg2 = P3RX_TEXCOMP_CA;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.I = P3RX_TEXCOMP_I_CA;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.A = P3RX_TEXCOMP_ARG1;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.B = P3RX_TEXCOMP_ARG2;
            if ( iMode )
            {
                // Inverted bumpmap.
                pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg1 = __PERMEDIA_ENABLE;
            }
            else
            {
                // Non-inverted bumpmap.
                pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg1 = __PERMEDIA_DISABLE;
            }
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg2 = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertI = __PERMEDIA_DISABLE;

            // Do tex1.c * diff.a + current.c
            pSoftP3RX->P3RXTextureCompositeColorMode1.Enable = __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXTextureCompositeColorMode1.Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AI_ADD_B;
            pSoftP3RX->P3RXTextureCompositeColorMode1.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
            pSoftP3RX->P3RXTextureCompositeColorMode1.Arg1 = P3RX_TEXCOMP_T1C;
            pSoftP3RX->P3RXTextureCompositeColorMode1.Arg2 = P3RX_TEXCOMP_OC;
            pSoftP3RX->P3RXTextureCompositeColorMode1.I = P3RX_TEXCOMP_I_CA;
            pSoftP3RX->P3RXTextureCompositeColorMode1.A = P3RX_TEXCOMP_ARG1;
            pSoftP3RX->P3RXTextureCompositeColorMode1.B = P3RX_TEXCOMP_ARG2;
            pSoftP3RX->P3RXTextureCompositeColorMode1.InvertArg1 = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureCompositeColorMode1.InvertArg2 = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureCompositeColorMode1.InvertI = __PERMEDIA_DISABLE;

            // Pass through bump.a again.
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.Enable = __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.Operation = P3RX_TEXCOMP_OPERATION_PASS_A;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.Arg1 = P3RX_TEXCOMP_OA;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.Arg2 = P3RX_TEXCOMP_CA;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.I = P3RX_TEXCOMP_I_CA;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.A = P3RX_TEXCOMP_ARG1;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.B = P3RX_TEXCOMP_ARG2;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.InvertArg1 = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.InvertArg2 = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.InvertI = __PERMEDIA_DISABLE;

            // Do current.c * current.a, by doing B*I+A. A=black, B=current.c, I=current.a
            pSoftP3RX->P3RXTextureApplicationMode.ColorA = P3RX_TEXAPP_A_KC;
            pSoftP3RX->P3RXTextureApplicationMode.ColorB = P3RX_TEXAPP_B_TC;
            pSoftP3RX->P3RXTextureApplicationMode.ColorI = P3RX_TEXAPP_I_TA;
            pSoftP3RX->P3RXTextureApplicationMode.ColorInvertI = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureApplicationMode.ColorOperation = P3RX_TEXAPP_OPERATION_MODULATE_BI_ADD_A;
            // Set the colour channel to black (allow the alpha channel to be preserved).
            dwTexAppTfactor &= 0xff000000;

            // Alpha channel selects the constant color.
            pSoftP3RX->P3RXTextureApplicationMode.AlphaA = P3RX_TEXAPP_A_KA;
            pSoftP3RX->P3RXTextureApplicationMode.AlphaB = P3RX_TEXAPP_B_KA;
            pSoftP3RX->P3RXTextureApplicationMode.AlphaInvertI = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureApplicationMode.AlphaOperation = P3RX_TEXAPP_OPERATION_PASS_B;
            
            // Do *2 in alpha-blend unit.
            bAlphaBlendDouble = TRUE;

            // We don't actually need the remap (and it doesn't mean much),
            // but it stops erroneous errors being flagged.
            pContext->iChipStage[0] = TEXSTAGE_0;
            pContext->iChipStage[1] = TEXSTAGE_1;
            pContext->iChipStage[2] = TEXSTAGE_3;
            pContext->iChipStage[3] = TEXSTAGE_4;

            bProcessChipStage0 = FALSE;
            bProcessChipStage1 = FALSE;
            bProcessChipStage2 = FALSE;
            iLastChipStage = 3;
        }
    }



    // Detect the special-case 3-blend-unit bumpmapping mode.
    // Third stage will be set up by the standard routines - only the first
    // two are special-cased and shoehorned into TexComp0.
    if ( bProcessChipStage0 && !pContext->bBumpmapEnabled && pContext->bTex0Valid && pContext->bTex1Valid &&
        ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLOROP ) == D3DTOP_MODULATE ) &&
        ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLORARG1 ) == D3DTA_TEXTURE ) &&
        ( TSSTATE ( TEXSTAGE_0, D3DTSS_COLORARG2 ) == D3DTA_DIFFUSE ) &&
        ( TSSTATE ( TEXSTAGE_1, D3DTSS_COLOROP ) == D3DTOP_SELECTARG1 ) &&
        ( TSSTATE ( TEXSTAGE_1, D3DTSS_COLORARG1 ) == D3DTA_CURRENT ) &&

        ( TSSTATE ( TEXSTAGE_0, D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG1 ) &&
        ( TSSTATE ( TEXSTAGE_0, D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) &&
        // ( TSSTATE ( TEXSTAGE_0, D3DTSS_ALPHAARG2 ) == D3DTA_DIFFUSE ) dont care && 

        ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAOP ) == D3DTOP_ADDSIGNED ) &&
        (
          ( ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == ( D3DTA_TEXTURE | D3DTA_COMPLEMENT ) ) &&
            ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == D3DTA_CURRENT ) ) ||
          ( ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) &&
            ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == ( D3DTA_CURRENT | D3DTA_COMPLEMENT ) ) )
        ) )
    {
        // Yep, looks good. Set it up.
        ASSERTDD ( pContext->iTexStage[0] == 0, "** _D3DChangeTextureP3RX: textures not correct for special bumpmapping" );
        ASSERTDD ( pContext->iTexStage[1] == 1, "** _D3DChangeTextureP3RX: textures not correct for special bumpmapping" );

        pSoftP3RX->P3RXTextureCompositeColorMode0.Enable = __PERMEDIA_ENABLE;
        pSoftP3RX->P3RXTextureCompositeColorMode0.Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AB;
        pSoftP3RX->P3RXTextureCompositeColorMode0.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
        pSoftP3RX->P3RXTextureCompositeColorMode0.Arg1 = P3RX_TEXCOMP_T0C;
        pSoftP3RX->P3RXTextureCompositeColorMode0.Arg2 = P3RX_TEXCOMP_CC;
        pSoftP3RX->P3RXTextureCompositeColorMode0.I = P3RX_TEXCOMP_I_CA;
        pSoftP3RX->P3RXTextureCompositeColorMode0.A = P3RX_TEXCOMP_ARG1;
        pSoftP3RX->P3RXTextureCompositeColorMode0.B = P3RX_TEXCOMP_ARG2;
        pSoftP3RX->P3RXTextureCompositeColorMode0.InvertArg1 = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RXTextureCompositeColorMode0.InvertArg2 = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RXTextureCompositeColorMode0.InvertI = __PERMEDIA_DISABLE;

        pSoftP3RX->P3RXTextureCompositeAlphaMode0.Enable = __PERMEDIA_ENABLE;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.Operation = P3RX_TEXCOMP_OPERATION_PASS_A;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.Arg1 = P3RX_TEXCOMP_HEIGHTA;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.Arg2 = P3RX_TEXCOMP_CA;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.I = P3RX_TEXCOMP_I_CA;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.A = P3RX_TEXCOMP_ARG1;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.B = P3RX_TEXCOMP_ARG2;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg2 = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertI = __PERMEDIA_DISABLE;

        if ( ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) &&
             ( TSSTATE ( TEXSTAGE_1, D3DTSS_ALPHAARG2 ) == ( D3DTA_CURRENT | D3DTA_COMPLEMENT ) ) )
        {
            // Inverted bumpmap.
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg1 = __PERMEDIA_ENABLE;
        }
        else
        {
            // Normal bumpmap.
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg1 = __PERMEDIA_DISABLE;
        }

        // Done chip stage 0, TSS stage 0 & 1. Move chip stage 1 on a notch.
        pContext->iChipStage[0] = TEXSTAGE_0;
        pContext->iChipStage[1] = TEXSTAGE_2;
        pContext->iChipStage[2] = TEXSTAGE_3;
        pContext->iChipStage[3] = TEXSTAGE_4;
        iLastChipStage = 1;
        bProcessChipStage0 = FALSE;
    }

    // Detect a chipstage 0 MODULATE+ADD concatenation. Used by lightmaps.
    // This compresses two stages into texcomp0. The alpha channel has
    // two modes - either one of the two stages just does a selectarg1 (current),
    // and the other gets set up as normal, or (for specular stuff) they
    // both do ADDSIGNED (cur, cur), in which case it's special-cased.
    if ( bProcessChipStage0 && pContext->bBumpmapEnabled &&
        ( TSSTATE ( pContext->iChipStage[0], D3DTSS_COLOROP ) == D3DTOP_MODULATE ) &&
        ( TSSTATE ( pContext->iChipStage[0], D3DTSS_COLORARG1 ) == ( D3DTA_CURRENT | D3DTA_ALPHAREPLICATE ) ) &&
        ( TSSTATE ( pContext->iChipStage[0], D3DTSS_COLORARG2 ) == D3DTA_DIFFUSE ) &&
        ( ( ( TSSTATE ( pContext->iChipStage[1], D3DTSS_COLOROP ) == D3DTOP_ADD ) &&
            ( TSSTATE ( pContext->iChipStage[1], D3DTSS_COLORARG1 ) == D3DTA_CURRENT ) &&
            ( TSSTATE ( pContext->iChipStage[1], D3DTSS_COLORARG2 ) == D3DTA_TEXTURE ) ) ||
          ( ( TSSTATE ( pContext->iChipStage[1], D3DTSS_COLOROP ) == D3DTOP_SELECTARG1 ) &&
            ( TSSTATE ( pContext->iChipStage[1], D3DTSS_COLORARG1 ) == D3DTA_CURRENT ) ) ) )
    {
        // Colour channel is correct and can be squashed down to one stage.
        // Check that the alpha channel is OK.
        int bOK;
        if (( ( TSSTATE ( pContext->iChipStage[0], D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG1 ) &&
              ( TSSTATE ( pContext->iChipStage[0], D3DTSS_ALPHAARG1 ) == D3DTA_CURRENT ) ) ||
            ( ( TSSTATE ( pContext->iChipStage[0], D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG2 ) &&
              ( TSSTATE ( pContext->iChipStage[0], D3DTSS_ALPHAARG2 ) == D3DTA_CURRENT ) ) )
        {
            // Stage 0 is set to pass-through - set up texcomp0 as stage 1.
            // Colour channel will be overridden later.
            __TXT_TranslateToChipBlendMode(pContext, 
                                           &pContext->TextureStageState[pContext->iChipStage[1]], 
                                           pSoftP3RX, 
                                           pContext->iChipStage[1], 
                                           0);
            bOK = TRUE;
        }
        else if (( ( TSSTATE ( pContext->iChipStage[1], D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG1 ) &&
                   ( TSSTATE ( pContext->iChipStage[1], D3DTSS_ALPHAARG1 ) == D3DTA_CURRENT ) ) ||
                 ( ( TSSTATE ( pContext->iChipStage[1], D3DTSS_ALPHAOP ) == D3DTOP_SELECTARG2 ) &&
                   ( TSSTATE ( pContext->iChipStage[1], D3DTSS_ALPHAARG2 ) == D3DTA_CURRENT ) ) )
        {
            // Stage 1 is set to pass-through - set up texcomp0 as stage 0.
            // Colour channel will be overridden later.
            __TXT_TranslateToChipBlendMode(pContext, 
                                           &pContext->TextureStageState[pContext->iChipStage[0]], 
                                           pSoftP3RX, 
                                           pContext->iChipStage[0], 
                                           0);
            bOK = TRUE;
        }
        else if (( TSSTATE ( pContext->iChipStage[0], D3DTSS_ALPHAOP ) == D3DTOP_ADDSIGNED ) &&
                 ( TSSTATE ( pContext->iChipStage[0], D3DTSS_ALPHAARG1 ) == D3DTA_CURRENT ) &&
                 ( TSSTATE ( pContext->iChipStage[0], D3DTSS_ALPHAARG2 ) == D3DTA_CURRENT ) &&
                 ( TSSTATE ( pContext->iChipStage[1], D3DTSS_ALPHAOP ) == D3DTOP_ADDSIGNED ) &&
                 ( TSSTATE ( pContext->iChipStage[1], D3DTSS_ALPHAARG1 ) == D3DTA_CURRENT ) &&
                 ( TSSTATE ( pContext->iChipStage[1], D3DTSS_ALPHAARG2 ) == D3DTA_CURRENT ) )
        {
            // Set up to do ( 4 * cur.a - 1.5 ), or rather 4 * ( cur.a - 0.375 )
            dwTexComp0Tfactor = 0x60606060;     // All channels set to (0.375)
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Enable = __PERMEDIA_ENABLE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Operation = P3RX_TEXCOMP_OPERATION_SUBTRACT_AB;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Scale = P3RX_TEXCOMP_OPERATION_SCALE_FOUR;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Arg1 = P3RX_TEXCOMP_HEIGHTA;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Arg2 = P3RX_TEXCOMP_FA;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.I = P3RX_TEXCOMP_I_CA;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.A = P3RX_TEXCOMP_ARG1;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.B = P3RX_TEXCOMP_ARG2;
            if ( pContext->bBumpmapInverted )
            {
                pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg1 = __PERMEDIA_ENABLE;
            }
            else
            {
                pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg1 = __PERMEDIA_DISABLE;
            }
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg2 = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertI = __PERMEDIA_DISABLE;
            bOK = TRUE;
        }
        else
        {
            bOK = FALSE;
        }

        if ( bOK )
        {
            // OK, the alpha channel is fine - set up the colour channel now.
            pSoftP3RX->P3RXTextureCompositeColorMode0.Enable = __PERMEDIA_ENABLE;
            if ( TSSTATE ( pContext->iChipStage[1], D3DTSS_COLOROP ) == D3DTOP_ADD )
            {
                // Yes, this is the ((diff.c*cur.a)+tex.c) case.
                pSoftP3RX->P3RXTextureCompositeColorMode0.Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AI_ADD_B;
                pSoftP3RX->P3RXTextureCompositeColorMode0.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
                pSoftP3RX->P3RXTextureCompositeColorMode0.Arg1 = P3RX_TEXCOMP_CC;
                if ( pContext->iStageTex[pContext->iChipStage[1]] == 0 )
                {
                    pSoftP3RX->P3RXTextureCompositeColorMode0.Arg2 = P3RX_TEXCOMP_T0C;
                }
                else
                {
                    pSoftP3RX->P3RXTextureCompositeColorMode0.Arg2 = P3RX_TEXCOMP_T1C;
                }
                pSoftP3RX->P3RXTextureCompositeColorMode0.I = P3RX_TEXCOMP_I_HA;
                pSoftP3RX->P3RXTextureCompositeColorMode0.A = P3RX_TEXCOMP_ARG1;
                pSoftP3RX->P3RXTextureCompositeColorMode0.B = P3RX_TEXCOMP_ARG2;
                pSoftP3RX->P3RXTextureCompositeColorMode0.InvertArg1 = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXTextureCompositeColorMode0.InvertArg2 = __PERMEDIA_DISABLE;
                if ( pContext->bBumpmapInverted )
                {
                    pSoftP3RX->P3RXTextureCompositeColorMode0.InvertI = __PERMEDIA_ENABLE;
                }
                else
                {
                    pSoftP3RX->P3RXTextureCompositeColorMode0.InvertI = __PERMEDIA_DISABLE;
                }
            }
            else
            {
                // Yes, this is just the (diff.c*cur.a) case.
                pSoftP3RX->P3RXTextureCompositeColorMode0.Operation = P3RX_TEXCOMP_OPERATION_MODULATE_AB;
                pSoftP3RX->P3RXTextureCompositeColorMode0.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
                pSoftP3RX->P3RXTextureCompositeColorMode0.Arg1 = P3RX_TEXCOMP_CC;
                pSoftP3RX->P3RXTextureCompositeColorMode0.Arg2 = P3RX_TEXCOMP_HEIGHTA;
                pSoftP3RX->P3RXTextureCompositeColorMode0.I = P3RX_TEXCOMP_I_OA;
                pSoftP3RX->P3RXTextureCompositeColorMode0.A = P3RX_TEXCOMP_ARG1;
                pSoftP3RX->P3RXTextureCompositeColorMode0.B = P3RX_TEXCOMP_ARG2;
                pSoftP3RX->P3RXTextureCompositeColorMode0.InvertArg1 = __PERMEDIA_DISABLE;
                pSoftP3RX->P3RXTextureCompositeColorMode0.InvertArg2 = __PERMEDIA_DISABLE;
                if ( pContext->bBumpmapInverted )
                {
                    pSoftP3RX->P3RXTextureCompositeColorMode0.InvertI = __PERMEDIA_ENABLE;
                }
                else
                {
                    pSoftP3RX->P3RXTextureCompositeColorMode0.InvertI = __PERMEDIA_DISABLE;
                }
            }

            // Done chip stage 0, TSS stage 0 & 1. Move chip stage 1 on a notch.
            pContext->iChipStage[1]++;
            pContext->iChipStage[2]++;
            pContext->iChipStage[3]++;
            iLastChipStage = 1;
            bProcessChipStage0 = FALSE;
        }
    }


    if ( TSSTATE ( pContext->iChipStage[0], D3DTSS_COLOROP ) == D3DTOP_DISABLE )
    {
        // Nothing more to do.
        bProcessChipStage0 = FALSE;
        bProcessChipStage1 = FALSE;
        bProcessChipStage2 = FALSE;
    }

    if ( pContext->iStageTex[pContext->iChipStage[0]] == -1 )
    {
        // This stage has no texture - is anyone trying to use it?
        if (( TSSTATESELECT ( pContext->iChipStage[0], D3DTSS_COLORARG1 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[0], D3DTSS_COLOROP ) != D3DTOP_SELECTARG2 ) ||
            ( TSSTATESELECT ( pContext->iChipStage[0], D3DTSS_COLORARG2 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[0], D3DTSS_COLOROP ) != D3DTOP_SELECTARG1 ) ||
            ( TSSTATESELECT ( pContext->iChipStage[0], D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[0], D3DTSS_ALPHAOP ) != D3DTOP_SELECTARG2 ) ||
            ( TSSTATESELECT ( pContext->iChipStage[0], D3DTSS_ALPHAARG2 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[0], D3DTSS_ALPHAOP ) != D3DTOP_SELECTARG1 ) )
        {
            // Panic! In future, we should feed white to the argument using the TFACTOR thing,
            // but for now just disable the rest of the pipeline.
            bProcessChipStage0 = FALSE;
            bProcessChipStage1 = FALSE;
            bProcessChipStage2 = FALSE;
        }
    }

    if ( bProcessChipStage0 )
    {
        // Set up stage 0
        DISPDBG((DBGLVL,"Texture Stage 0 is valid - setting it up"));
        __TXT_TranslateToChipBlendMode(pContext, 
                                       &pContext->TextureStageState[pContext->iChipStage[0]], 
                                       pSoftP3RX, 
                                       pContext->iChipStage[0], 
                                       0);
        iLastChipStage = 1;
        bProcessChipStage0 = FALSE;
    }


    // Handle chip stage 1.


    if ( TSSTATE ( pContext->iChipStage[1], D3DTSS_COLOROP ) == D3DTOP_DISABLE )
    {
        // Nothing more to do.
        bProcessChipStage1 = FALSE;
        bProcessChipStage2 = FALSE;
    }

    if ( pContext->iStageTex[pContext->iChipStage[1]] == -1 )
    {
        // This stage has no texture - is anyone trying to use it?
        if (( TSSTATESELECT ( pContext->iChipStage[1], D3DTSS_COLORARG1 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[1], D3DTSS_COLOROP ) != D3DTOP_SELECTARG2 ) ||
            ( TSSTATESELECT ( pContext->iChipStage[1], D3DTSS_COLORARG2 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[1], D3DTSS_COLOROP ) != D3DTOP_SELECTARG1 ) ||
            ( TSSTATESELECT ( pContext->iChipStage[1], D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[1], D3DTSS_ALPHAOP ) != D3DTOP_SELECTARG2 ) ||
            ( TSSTATESELECT ( pContext->iChipStage[1], D3DTSS_ALPHAARG2 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[1], D3DTSS_ALPHAOP ) != D3DTOP_SELECTARG1 ) )
        {
            // Panic! In future, we should feed white to the argument using the TFACTOR thing,
            // but for now just disable the rest of the pipeline.
            bProcessChipStage1 = FALSE;
            bProcessChipStage2 = FALSE;
        }
    }


    if ( bProcessChipStage1 )
    {
        // Set up stage 1
        DISPDBG((DBGLVL,"Texture Stage 1 is valid - setting it up"));
        __TXT_TranslateToChipBlendMode(pContext, 
                                       &pContext->TextureStageState[pContext->iChipStage[1]],
                                       pSoftP3RX, 
                                       pContext->iChipStage[1], 
                                       1);

        iLastChipStage = 2;
        bProcessChipStage1 = FALSE;
    }



    // Handle chip stage 2.


    if ( TSSTATE ( pContext->iChipStage[2], D3DTSS_COLOROP ) == D3DTOP_DISABLE )
    {
        // Nothing more to do.
        bProcessChipStage2 = FALSE;
    }

    if ( pContext->iStageTex[pContext->iChipStage[2]] == -1 )
    {
        // This stage has no texture - is anyone trying to use it?
        if (( TSSTATESELECT ( pContext->iChipStage[2], D3DTSS_COLORARG1 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[2], D3DTSS_COLOROP ) != D3DTOP_SELECTARG2 ) ||
            ( TSSTATESELECT ( pContext->iChipStage[2], D3DTSS_COLORARG2 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[2], D3DTSS_COLOROP ) != D3DTOP_SELECTARG1 ) ||
            ( TSSTATESELECT ( pContext->iChipStage[2], D3DTSS_ALPHAARG1 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[2], D3DTSS_ALPHAOP ) != D3DTOP_SELECTARG2 ) ||
            ( TSSTATESELECT ( pContext->iChipStage[2], D3DTSS_ALPHAARG2 ) == D3DTA_TEXTURE ) && ( TSSTATE ( pContext->iChipStage[2], D3DTSS_ALPHAOP ) != D3DTOP_SELECTARG1 ) )
        {
            // Panic! In future, we should feed white to the argument using the TFACTOR thing,
            // but for now just disable the rest of the pipeline.
            bProcessChipStage2 = FALSE;
        }
    }

    if ( bProcessChipStage2 )
    {
        // Set up chip stage 2 - texapp.
        DISPDBG((DBGLVL,"Texture Stage 2 is valid - setting it up"));
        DISPDBG((ERRLVL,"** _D3DChangeTextureP3RX: Cool - an app is using the "
                     "TexApp unit - tell someone!"));
        __TXT_TranslateToChipBlendMode(pContext, 
                                       &pContext->TextureStageState[pContext->iChipStage[2]],
                                       pSoftP3RX, 
                                       pContext->iChipStage[2], 
                                       2);
        iLastChipStage = 3;
        bProcessChipStage2 = FALSE;
    }

    // This must be last.
    if ( TSSTATE ( pContext->iChipStage[3], D3DTSS_COLOROP ) != D3DTOP_DISABLE )
    {
        // Oops - ran out of stages to set up.
        SET_BLEND_ERROR ( pContext,  BSF_TOO_MANY_BLEND_STAGES );
        iLastChipStage = 3;
    }

    switch ( iLastChipStage )
    {
        case 0:
            DISPDBG((DBGLVL,"Texture Composite 0 is disabled"));
            // This should have been caught ages ago.
            pSoftP3RX->P3RXTextureCompositeColorMode0.Arg2 = P3RX_TEXCOMP_CC;
            pSoftP3RX->P3RXTextureCompositeColorMode0.InvertArg2 = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureCompositeColorMode0.A = P3RX_TEXCOMP_ARG2;
            pSoftP3RX->P3RXTextureCompositeColorMode0.Operation = P3RX_TEXCOMP_OPERATION_PASS_A;
            pSoftP3RX->P3RXTextureCompositeColorMode0.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
            pSoftP3RX->P3RXTextureCompositeColorMode0.Enable = __PERMEDIA_ENABLE;
            
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Arg2 = P3RX_TEXCOMP_CA;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.InvertArg1 = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.A = P3RX_TEXCOMP_ARG2;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Operation = P3RX_TEXCOMP_OPERATION_PASS_A;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode0.Enable = __PERMEDIA_ENABLE;
            // fall through
        case 1:
            DISPDBG((DBGLVL,"Texture Composite 1 is disabled"));
            // Make sure the second stage passes the texel that the first stage generated
            if ( pContext->bStage0DotProduct )
            {
                // First stage was a dot-product - do the summing (even in the alpha channel).
                pSoftP3RX->P3RXTextureCompositeColorMode1.Arg2 = P3RX_TEXCOMP_SUM;
                pSoftP3RX->P3RXTextureCompositeAlphaMode1.Arg2 = P3RX_TEXCOMP_SUM;
            }
            else
            {
                pSoftP3RX->P3RXTextureCompositeColorMode1.Arg2 = P3RX_TEXCOMP_OC;
                pSoftP3RX->P3RXTextureCompositeAlphaMode1.Arg2 = P3RX_TEXCOMP_OA;
            }
            pSoftP3RX->P3RXTextureCompositeColorMode1.InvertArg2 = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureCompositeColorMode1.A = P3RX_TEXCOMP_ARG2;
            pSoftP3RX->P3RXTextureCompositeColorMode1.Operation = P3RX_TEXCOMP_OPERATION_PASS_A;
            pSoftP3RX->P3RXTextureCompositeColorMode1.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
            pSoftP3RX->P3RXTextureCompositeColorMode1.Enable = __PERMEDIA_ENABLE;
            
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.InvertArg2 = __PERMEDIA_DISABLE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.A = P3RX_TEXCOMP_ARG2;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.Operation = P3RX_TEXCOMP_OPERATION_PASS_A;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.Scale = P3RX_TEXCOMP_OPERATION_SCALE_ONE;
            pSoftP3RX->P3RXTextureCompositeAlphaMode1.Enable = __PERMEDIA_ENABLE;
            // fall through
        case 2:
            // Texapp to passthrough.
            DISPDBG((DBGLVL,"Texture Application is disabled"));
            pSoftP3RX->P3RXTextureApplicationMode.ColorB = P3RX_TEXAPP_B_TC;
            pSoftP3RX->P3RXTextureApplicationMode.ColorOperation = P3RX_TEXAPP_OPERATION_PASS_B;
            pSoftP3RX->P3RXTextureApplicationMode.ColorInvertI = __PERMEDIA_DISABLE;

            pSoftP3RX->P3RXTextureApplicationMode.AlphaB = P3RX_TEXAPP_B_TC;
            pSoftP3RX->P3RXTextureApplicationMode.AlphaOperation = P3RX_TEXAPP_OPERATION_PASS_B;
            pSoftP3RX->P3RXTextureApplicationMode.AlphaInvertI = __PERMEDIA_DISABLE;
            // fall through
        case 3:
            // Nothing else in the pipeline to disable.
            // fall through
            break;
        default:
            DISPDBG((ERRLVL,"** _D3DChangeTextureP3RX: iLastChipStage was > 3 - oops."));
            break;
    }


    // Set up the alpha-map filtering to reflect the single/multi/mip-mapped texturing status
    // All the other colour-key stuff has already been set up.
    if( pContext->bCanChromaKey )
    {
        ASSERTDD ( pTexture0 != NULL, "** _D3DChangeTextureP3RX: pTexture was NULL" );
        if( pTexture0->bMipMap )
        {
            pSoftP3RX->P3RXTextureFilterMode.AlphaMapFilterLimit0 = 4;
            pSoftP3RX->P3RXTextureFilterMode.AlphaMapFilterLimit1 = 4;
            if ( pContext->bTex0Valid )
            {
                // Filter mode is irrelevant - this just works!
                pSoftP3RX->P3RXTextureFilterMode.AlphaMapFilterLimit01 = 7;
            }
            else
            {
                DISPDBG((ERRLVL,"** _D3DChangeTextureP3RX: Trying to mipmap without a valid texture."));
                pSoftP3RX->P3RXTextureFilterMode.AlphaMapFilterLimit01 = 8;
            }
            ASSERTDD ( !pContext->bTex1Valid, "** _D3DChangeTextureP3RX: Trying to mipmap with too many textures." );
        }
        else
        {
            // No mipmapping.
            if ( pContext->bTex0Valid )
            {
                // Don't care about filter mode - this just works.
                pSoftP3RX->P3RXTextureFilterMode.AlphaMapFilterLimit0 = 7;
            }
            else
            {
                pSoftP3RX->P3RXTextureFilterMode.AlphaMapFilterLimit0 = 4;
            }
            if ( pContext->bTex1Valid )
            {
                // Don't care about filter mode - this just works.
                pSoftP3RX->P3RXTextureFilterMode.AlphaMapFilterLimit1 = 7;
            }
            else
            {
                pSoftP3RX->P3RXTextureFilterMode.AlphaMapFilterLimit1 = 4;
            }
        }
    }

    // Enable Texture Address calculation
    pSoftP3RX->P3RXTextureCoordMode.Enable = __PERMEDIA_ENABLE;

    // Enable filtering
    pSoftP3RX->P3RXTextureFilterMode.Enable = __PERMEDIA_ENABLE;

//  // Enable Texel color generation
//  pSoftP3RX->P3RXTextureApplicationMode.Enable = __PERMEDIA_ENABLE;

    // Do we need to share the texture coordinates ?
    if ( pContext->bTex0Valid && pContext->bTex1Valid &&
        ( TSSTATE ( pContext->iTexStage[0], D3DTSS_TEXCOORDINDEX ) ==
          TSSTATE ( pContext->iTexStage[1], D3DTSS_TEXCOORDINDEX ) ) )
    {
        pSoftP3RX->P3RX_P3DeltaControl.ShareS = __PERMEDIA_ENABLE;
        pSoftP3RX->P3RX_P3DeltaControl.ShareT = __PERMEDIA_ENABLE;
    }
    else
    {
        pSoftP3RX->P3RX_P3DeltaControl.ShareS = __PERMEDIA_DISABLE;
        pSoftP3RX->P3RX_P3DeltaControl.ShareT = __PERMEDIA_DISABLE;
    }

    P3_ENSURE_DX_SPACE((P3_LOD_LEVELS*2));
    WAIT_FIFO((P3_LOD_LEVELS*2));
    for (i = 0; i < P3_LOD_LEVELS; i++)
    {
        COPY_P3_DATA_OFFSET(TextureMapWidth0, pSoftP3RX->P3RXTextureMapWidth[i], i);
    }

    if ( ( GET_BLEND_ERROR(pContext) & BLEND_STATUS_FATAL_FLAG ) != 0 )
    {
        // Got a fatal blend error - signal it to the user.

        DISPDBG((ERRLVL,"** _D3DChangeTextureP3RX: invalid blend mode"));
        
        _D3DDisplayWholeTSSPipe ( pContext, WRNLVL );

        // And make sure this is re-evaluated next time we render,
        // so that this (probably very munged) invalid setup doesn't cripple
        // any subsequent valid renderstates.
        DIRTY_EVERYTHING(pContext);
    }


    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);
    SEND_P3_DATA(TextureCompositeMode, __PERMEDIA_ENABLE);
    COPY_P3_DATA(TextureFilterMode, pSoftP3RX->P3RXTextureFilterMode);

    COPY_P3_DATA(TextureApplicationMode, pSoftP3RX->P3RXTextureApplicationMode);
    COPY_P3_DATA(TextureCoordMode, pSoftP3RX->P3RXTextureCoordMode);
    COPY_P3_DATA(DeltaControl, pSoftP3RX->P3RX_P3DeltaControl);

    // Copy the current TFACTOR values.
    SEND_P3_DATA ( TextureEnvColor, FORMAT_8888_32BIT_BGR(dwTexAppTfactor) );
    SEND_P3_DATA ( TextureCompositeFactor0, FORMAT_8888_32BIT_BGR(dwTexComp0Tfactor) );
    SEND_P3_DATA ( TextureCompositeFactor1, FORMAT_8888_32BIT_BGR(dwTexComp1Tfactor) );
    DISPDBG((DBGLVL,"Current TFACTOR values. %x %x %x",
                    dwTexAppTfactor,
                    dwTexComp0Tfactor,
                    dwTexComp1Tfactor));

    COPY_P3_DATA(DeltaMode, pSoftP3RX->P3RX_P3DeltaMode);

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    COPY_P3_DATA(TextureCompositeColorMode0, pSoftP3RX->P3RXTextureCompositeColorMode0);
    COPY_P3_DATA(TextureCompositeColorMode1, pSoftP3RX->P3RXTextureCompositeColorMode1);
    COPY_P3_DATA(TextureCompositeAlphaMode0, pSoftP3RX->P3RXTextureCompositeAlphaMode0);
    COPY_P3_DATA(TextureCompositeAlphaMode1, pSoftP3RX->P3RXTextureCompositeAlphaMode1);

    COPY_P3_DATA(TextureReadMode1, pSoftP3RX->P3RXTextureReadMode1);
    COPY_P3_DATA(TextureIndexMode1, pSoftP3RX->P3RXTextureIndexMode1);

    COPY_P3_DATA(TextureReadMode0, pSoftP3RX->P3RXTextureReadMode0);
    COPY_P3_DATA(TextureIndexMode0, pSoftP3RX->P3RXTextureIndexMode0);

    // Make sure the texture cache is invalidated
    P3RX_INVALIDATECACHE(__PERMEDIA_ENABLE, __PERMEDIA_DISABLE);
    
    SEND_P3_DATA(LOD, 0);
    SEND_P3_DATA(LOD1, 0);

    {
        struct LodRange range;

        // Clear down whole register

        *(DWORD *)&range = 0;

        // Each of the Min and Max LODs are in 4.8 format. We only deal 
        // with integer LODs in the range (0, N) so we just compute the 
        // upper value N and shift it up 8 bits.

        range.Min = 0;
        range.Max = ( mipBases.dwTex0MipMax - mipBases.dwTex0MipBase ) << 8;
        COPY_P3_DATA( LodRange0, range );

        range.Min = 0;
        range.Max = ( mipBases.dwTex1MipMax - mipBases.dwTex1MipBase ) << 8;
        COPY_P3_DATA( LodRange1, range );
    }

    *pFlags |= SURFACE_TEXTURING;

    // Turn texturing on in the render command
    RENDER_TEXTURE_ENABLE(pContext->RenderCommand);
 
    P3_DMA_COMMIT_BUFFER();

    // See if the alpha-blend unit needs to be updated.
    if ( bAlphaBlendDouble != pContext->bAlphaBlendMustDoubleSourceColour )
    {
        pContext->bAlphaBlendMustDoubleSourceColour = bAlphaBlendDouble;
        DIRTY_ALPHABLEND(pContext);
    }

    DBG_EXIT(_D3DChangeTextureP3RX,0);  
    
} // _D3DChangeTextureP3RX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\ddblt.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: ddblt.c
*
* Content: DirectDraw Blt callback implementation for blts and clears
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "tag.h"
#include "dma.h"

//-----------------------------------------------------------------------------
//
// _DD_BLT_P3Clear
//
//-----------------------------------------------------------------------------
VOID 
_DD_BLT_P3Clear(
    P3_THUNKEDDATA* pThisDisplay,
    RECTL *rDest,
    DWORD   ClearValue,
    BOOL    bDisableFastFill,
    BOOL    bIsZBuffer,
    FLATPTR pDestfpVidMem,
    DWORD   dwDestPatchMode,
    DWORD   dwDestPixelPitch,
    DWORD   dwDestBitDepth
    )
{
    DWORD   renderData, pixelSize, pixelScale; 
    BOOL    bFastFillOperation = TRUE;
    DWORD   dwOperation;
    P3_DMA_DEFS();
    
    P3_DMA_GET_BUFFER_ENTRIES(18);

    if(bDisableFastFill)
    {
        bFastFillOperation = FALSE;
    }
    
    switch(dwDestBitDepth)
    {
    case 16:
        ClearValue &= 0xFFFF;
        ClearValue |= ClearValue << 16;
        pixelSize = 1;
        pixelScale = 1;
        break;

    case 8:
        ClearValue &= 0xFF;
        ClearValue |= ClearValue << 8;
        ClearValue |= ClearValue << 16;
        pixelSize = 2;
        pixelScale = 1;
        break;

    case 32:
        if( bFastFillOperation )
        {
            // Do the operation as 16 bit due to FBWrite bug

            pixelSize = 1;
            pixelScale = 2;
        }
        else
        {
            pixelSize = 0;
            pixelScale = 1;
        }
        break;

    default:
        DISPDBG((ERRLVL,"ERROR: Invalid depth for surface during clear!"));
        // Treat as a  16bpp just as fallback though this should never happen
        ClearValue &= 0xFFFF;
        ClearValue |= ClearValue << 16;
        pixelSize = 1;
        pixelScale = 1;        
        break;
    }
    
    SEND_P3_DATA(PixelSize, pixelSize );

    SEND_P3_DATA(FBWriteBufferAddr0, 
                    (DWORD)(pDestfpVidMem - 
                            pThisDisplay->dwScreenFlatAddr) );
                            
    SEND_P3_DATA(FBWriteBufferWidth0, 
                    pixelScale * dwDestPixelPitch );
                    
    SEND_P3_DATA(FBWriteBufferOffset0, 
                    (rDest->top << 16) | pixelScale * ((rDest->left & 0xFFFF)));

    SEND_P3_DATA(FBDestReadBufferAddr0, 
                    (DWORD)(pDestfpVidMem - 
                            pThisDisplay->dwScreenFlatAddr) );
                            
    SEND_P3_DATA(FBDestReadBufferWidth0, 
                    pixelScale * dwDestPixelPitch );
                    
    SEND_P3_DATA(FBDestReadBufferOffset0, 
                    (rDest->top << 16) | pixelScale * ((rDest->left & 0xFFFF)));

    SEND_P3_DATA(RectanglePosition, 0);

    dwOperation = P3RX_RENDER2D_OPERATION( P3RX_RENDER2D_OPERATION_NORMAL );

    SEND_P3_DATA(FBWriteMode, 
                 P3RX_FBWRITEMODE_WRITEENABLE(__PERMEDIA_ENABLE) |
                 P3RX_FBWRITEMODE_LAYOUT0(dwDestPatchMode));

    P3_DMA_COMMIT_BUFFER();
    P3_DMA_GET_BUFFER_ENTRIES(18);

    if( bFastFillOperation )
    {
        DWORD shift = 0;

        SEND_P3_DATA(FBBlockColor, ClearValue);
        
        renderData =  P3RX_RENDER2D_WIDTH( pixelScale * (( rDest->right - rDest->left ) & 0xfff ))
                    | P3RX_RENDER2D_HEIGHT((( rDest->bottom - rDest->top ) & 0xfff ) >> shift )
                    | P3RX_RENDER2D_SPANOPERATION( P3RX_RENDER2D_SPAN_CONSTANT )
                    | P3RX_RENDER2D_INCREASINGX( __PERMEDIA_ENABLE )
                    | P3RX_RENDER2D_INCREASINGY( __PERMEDIA_ENABLE )
                    | dwOperation;
                    
        SEND_P3_DATA(Render2D, renderData);
    }
    else
    {
        SEND_P3_DATA(ConstantColor, ClearValue);
        SEND_P3_DATA(DitherMode, __PERMEDIA_DISABLE);

        SEND_P3_DATA(ColorDDAMode, 
                     P3RX_COLORDDA_ENABLE(__PERMEDIA_ENABLE) |
                     P3RX_COLORDDA_SHADING(P3RX_COLORDDA_FLATSHADE));

        renderData =  P3RX_RENDER2D_WIDTH(( rDest->right - rDest->left ) & 0xfff )
                | P3RX_RENDER2D_HEIGHT(0)
                | P3RX_RENDER2D_SPANOPERATION( P3RX_RENDER2D_SPAN_CONSTANT )
                | P3RX_RENDER2D_INCREASINGX( __PERMEDIA_ENABLE )
                | P3RX_RENDER2D_INCREASINGY( __PERMEDIA_ENABLE );
        
        SEND_P3_DATA(Render2D, renderData);
        
        SEND_P3_DATA(Count, rDest->bottom - rDest->top );
        SEND_P3_DATA(Render, __RENDER_TRAPEZOID_PRIMITIVE);

        SEND_P3_DATA(ColorDDAMode, __PERMEDIA_DISABLE);
    }

    P3_DMA_COMMIT_BUFFER();
} // _DD_BLT_P3Clear

//-----------------------------------------------------------------------------
//
// _DD_BLT_P3ClearDD
//
// Does a DDraw surface clear
//
//-----------------------------------------------------------------------------
VOID 
_DD_BLT_P3ClearDD(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatDest,
    RECTL *rDest,
    DWORD   ClearValue,
    BOOL    bDisableFastFill,
    BOOL    bIsZBuffer
    )
{
    _DD_BLT_P3Clear(pThisDisplay,
                    rDest,
                    ClearValue,
                    bDisableFastFill,
                    bIsZBuffer,
                    pDest->lpGbl->fpVidMem,
                    P3RX_LAYOUT_LINEAR,
                    DDSurf_GetPixelPitch(pDest),
                    DDSurf_BitDepth(pDest)
                    );

} // _DD_BLT_P3ClearDD

#if DX7_TEXMANAGEMENT
//-----------------------------------------------------------------------------
//
// _DD_BLT_P3ClearManagedSurf
//
// Does a clear of a managed surface. Supports all color depths
//
// PixelSize-----surface color depth
// rDest---------rectangle for colorfill in dest. surface 
// fpVidMem------pointer to fill
// lPitch--------Surface Pitch
// dwColor-------color for fill
//
//-----------------------------------------------------------------------------

VOID 
_DD_BLT_P3ClearManagedSurf(DWORD   PixelSize,
                  RECTL     *rDest, 
                  FLATPTR   fpVidMem, 
                  LONG      lPitch,
                  DWORD     dwColor)
{
    BYTE* pDestStart;
    LONG i;
    LONG lByteWidth = rDest->right - rDest->left;
    LONG lHeight = rDest->bottom - rDest->top;

    // Calculate the start pointer for the dest
    pDestStart   = (BYTE*)(fpVidMem + (rDest->top * lPitch));

    // Clear depending on depth
    switch (PixelSize) 
    {
            
        case __GLINT_8BITPIXEL:
            pDestStart += rDest->left;
            while (--lHeight >= 0) 
            {
                for (i = 0; i < lByteWidth ; i++)
                    pDestStart[i] = (BYTE)dwColor;
                pDestStart += lPitch;
            }
            break;
            
        case __GLINT_16BITPIXEL:
            pDestStart += rDest->left*2;
            while (--lHeight >= 0) 
            {
                LPWORD  lpWord=(LPWORD)pDestStart;
                for (i = 0; i < lByteWidth ; i++)
                    lpWord[i] = (WORD)dwColor;
                pDestStart += lPitch;
            }
            break;

        case __GLINT_24BITPIXEL:
            dwColor &= 0xFFFFFF;
            dwColor |= ((dwColor & 0xFF) << 24);
            
        default: // 32 bits!
            pDestStart += rDest->left*4;
            while (--lHeight >= 0) 
            {
                LPDWORD lpDWord = (LPDWORD)pDestStart;
                for (i = 0; i < lByteWidth; i++)
                    lpDWord[i] = (WORD)dwColor;
                pDestStart += lPitch;
            }
            break;
    }
} // _DD_BLT_P3ClearManagedSurf
#endif // DX7_TEXMANAGEMENT

#if DX8_MULTISAMPLING || DX7_ANTIALIAS
//-----------------------------------------------------------------------------
//
// _DD_BLT_P3Clear_AA
//
//-----------------------------------------------------------------------------
VOID _DD_BLT_P3Clear_AA(
    P3_THUNKEDDATA* pThisDisplay,
    RECTL *rDest,
    DWORD   dwSurfaceOffset,
    DWORD   ClearValue,
    BOOL bDisableFastFill,
    DWORD   dwDestPatchMode,
    DWORD   dwDestPixelPitch,
    DWORD   dwDestBitDepth,
    DDSCAPS DestDdsCaps)
{
    DWORD   renderData, pixelSize, pixelScale; 
    BOOL    bFastFillOperation = TRUE;
    P3_DMA_DEFS();
    
    P3_DMA_GET_BUFFER();
    P3_ENSURE_DX_SPACE(32);

    WAIT_FIFO(32); 

    if (bDisableFastFill)
    {
        bFastFillOperation = FALSE;
    }

    switch(dwDestBitDepth)
    {
        case 16:
            ClearValue &= 0xFFFF;
            ClearValue |= ClearValue << 16;
            pixelSize = 1;
            pixelScale = 1;
            break;

        case 8:
            ClearValue &= 0xFF;
            ClearValue |= ClearValue << 8;
            ClearValue |= ClearValue << 16;
            pixelSize = 2;
            pixelScale = 1;
            break;

       case 32:
            // 32 bit Z-buffer can be used for 16 bit antialiased render buffer
            if( bFastFillOperation )
            {
                // Do the operation as 16 bit due to FBWrite bug

                pixelSize = 1;
                pixelScale = 2;
            }
            else
            {
                pixelSize = 0;
                pixelScale = 1;
            }
            break;
        default:
            DISPDBG((ERRLVL,"ERROR: Invalid depth for surface during clear!"));
            // Treat as a  16bpp just as fallback            
            ClearValue &= 0xFFFF;
            ClearValue |= ClearValue << 16;
            pixelSize = 1;
            pixelScale = 1;
            break;
    }

    SEND_P3_DATA(PixelSize, pixelSize);

    SEND_P3_DATA(FBWriteBufferAddr0, dwSurfaceOffset);
    SEND_P3_DATA(FBWriteBufferWidth0, pixelScale * (dwDestPixelPitch * 2));
    SEND_P3_DATA(FBWriteBufferOffset0, (rDest->top << 16) | 
                                       pixelScale * ((rDest->left & 0xFFFF)));

    SEND_P3_DATA(FBDestReadBufferAddr0, dwSurfaceOffset );
    SEND_P3_DATA(FBDestReadBufferWidth0, pixelScale * dwDestPixelPitch );
    SEND_P3_DATA(FBDestReadBufferOffset0, (rDest->top << 16) | 
                                          pixelScale * ((rDest->left & 0xFFFF)));

    SEND_P3_DATA(RectanglePosition, 0);

    SEND_P3_DATA(FBWriteMode, P3RX_FBWRITEMODE_WRITEENABLE(__PERMEDIA_ENABLE) |
                        P3RX_FBWRITEMODE_LAYOUT0(dwDestPatchMode));

    if( bFastFillOperation )
    {
        SEND_P3_DATA(FBBlockColor, ClearValue);

        renderData =  P3RX_RENDER2D_WIDTH( pixelScale * (( rDest->right - rDest->left ) & 0xfff ))
                    | P3RX_RENDER2D_HEIGHT(( rDest->bottom - rDest->top ) & 0xfff )
                    | P3RX_RENDER2D_INCREASINGX( __PERMEDIA_ENABLE )
                    | P3RX_RENDER2D_INCREASINGY( __PERMEDIA_ENABLE );

        SEND_P3_DATA(Render2D, renderData);
    }
    else
    {
        SEND_P3_DATA(ConstantColor, ClearValue);
        SEND_P3_DATA(DitherMode, __PERMEDIA_DISABLE);

        SEND_P3_DATA(ColorDDAMode, P3RX_COLORDDA_ENABLE(__PERMEDIA_ENABLE) |
                                    P3RX_COLORDDA_SHADING(P3RX_COLORDDA_FLATSHADE));

        renderData =  P3RX_RENDER2D_WIDTH(( rDest->right - rDest->left ) & 0xfff )
                        | P3RX_RENDER2D_HEIGHT(0)
                        | P3RX_RENDER2D_INCREASINGX( __PERMEDIA_ENABLE )
                        | P3RX_RENDER2D_SPANOPERATION( P3RX_RENDER2D_SPAN_CONSTANT )
                        | P3RX_RENDER2D_INCREASINGY( __PERMEDIA_ENABLE );
            
        SEND_P3_DATA(Render2D, renderData);
        
        SEND_P3_DATA(Count, rDest->bottom - rDest->top );
        SEND_P3_DATA(Render, __RENDER_TRAPEZOID_PRIMITIVE);

        SEND_P3_DATA(ColorDDAMode, __PERMEDIA_DISABLE);
    }

    P3_DMA_COMMIT_BUFFER();
} // _DD_BLT_P3Clear_AA

//-----------------------------------------------------------------------------
//
// _DD_BLT_P3Clear_AA_DD
//
//-----------------------------------------------------------------------------
VOID _DD_BLT_P3Clear_AA_DD(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatDest,
    RECTL *rDest,
    DWORD   dwSurfaceOffset,
    DWORD   ClearValue,
    BOOL bDisableFastFill)
{
    _DD_BLT_P3Clear_AA(pThisDisplay,
                       rDest,
                       dwSurfaceOffset,
                       ClearValue,
                       bDisableFastFill,
                       P3RX_LAYOUT_LINEAR,
                       DDSurf_GetPixelPitch(pDest),
                       DDSurf_BitDepth(pDest),
                       pDest->ddsCaps
                       );
                       
} // _DD_BLT_P3Clear_AA_DD
#endif // DX8_MULTISAMPLING || DX7_ANTIALIAS

#if DX7_TEXMANAGEMENT
//-----------------------------------------------------------------------------
//
// _DD_BLT_SysMemToSysMemCopy
//
// Does a copy from System memory to System memory (either from or to an
// AGP surface, or any other system memory surface)
//
//-----------------------------------------------------------------------------
VOID 
_DD_BLT_SysMemToSysMemCopy(FLATPTR     fpSrcVidMem,
                           LONG        lSrcPitch,
                           DWORD       dwSrcBitCount,
                           FLATPTR     fpDstVidMem,
                           LONG        lDstPitch, 
                           DWORD       dwDstBitCount,
                           RECTL*      rSource,
                           RECTL*      rDest)
{
    BYTE* pSourceStart;
    BYTE* pDestStart;
    BYTE  pixSource;
    BYTE* pNewDest;
    BYTE* pNewSource;

    // Computing these from the smaller of Dest and Src as it is safer 
    // (we might touch invalid memory if for any weird reason we're 
    // asked to do a stretch blt here!)
    LONG lByteWidth = min(rDest->right - rDest->left,
                          rSource->right - rSource->left);
    LONG lHeight = min(rDest->bottom - rDest->top,
                       rSource->bottom - rSource->top);
    
    if (0 == fpSrcVidMem || 0 == fpDstVidMem)
    {
        DISPDBG((WRNLVL, "DDraw:_DD_BLT_SysMemToSysMemCopy "
                         "unexpected 0 fpVidMem"));
        return;
    }
    // Calculate the start pointer for the source and the dest
    pSourceStart = (BYTE*)(fpSrcVidMem + (rSource->top * lSrcPitch));
    pDestStart   = (BYTE*)(fpDstVidMem + (rDest->top * lDstPitch));

    // The simple 8, 16 or 32 bit copy
    pSourceStart += rSource->left * (dwSrcBitCount >> 3);
    pDestStart += rDest->left * (dwDstBitCount >> 3);
    lByteWidth *= (dwSrcBitCount >> 3);

    _try
    {
        while (--lHeight >= 0) 
        {
            memcpy(pDestStart, pSourceStart, lByteWidth);
            pDestStart += lDstPitch;
            pSourceStart += lSrcPitch;
        };
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // Perm3 driver doesn't need to do anything special
        DISPDBG((ERRLVL, "Perm3 caused exception at line %u of file %s",
                         __LINE__,__FILE__));
    }

} // _DD_BLT_SysMemToSysMemCopy 

#endif // DX7_TEXMANAGEMENT

//-----------------------------------------------------------------------------
//
// _DD_BLT_FixRectlOrigin
//
// Fix blt coords in case some are negative. If the area is completly NULL 
// (coordinate-wise) then return FALSE, signaling there is nothing to be
// blitted.
//
//-----------------------------------------------------------------------------
BOOL _DD_BLT_FixRectlOrigin(char *pszPlace, RECTL *rSrc, RECTL *rDest)
{
    if ((rSrc->top < 0 && rSrc->bottom < 0) || 
        (rSrc->left < 0 && rSrc->right < 0))
    {
        // There is nothing to be blitted
        return FALSE;
    }

    if (rSrc->top   < 0 || 
        rSrc->left  < 0 || 
        rDest->top  < 0 || 
        rDest->left < 0) 
    {
        DISPDBG((DBGLVL, "Dodgy blt coords:"));
        DISPDBG((DBGLVL, "  src([%d, %d], [%d, %d]", 
                         rSrc->left, rSrc->top, 
                         rSrc->right, rSrc->bottom));
        DISPDBG((DBGLVL, "  dst([%d, %d], [%d, %d]", 
                         rDest->left, rDest->top, 
                         rDest->right, rDest->bottom));
    }

    if (rSrc->top < 0) 
    {
        rDest->top -= rSrc->top;
        rSrc->top = 0;
    }
    
    if (rSrc->left < 0) 
    {
        rDest->left -= rSrc->left;
        rSrc->left = 0;
    }

    DISPDBG((DBGLVL, "%s from (%d, %d) to (%d,%d) (%d, %d)", 
                     pszPlace,
                     rSrc->left, rSrc->top,
                     rDest->left, rDest->top, 
                     rDest->right, rDest->bottom));

    return TRUE; // Blt is valid
                     
} // _DD_BLT_FixRectlOrigin

//-----------------------------------------------------------------------------
//
// _DD_BLT_GetBltDirection
//
// Determine the direction of the blt
//  ==1 => increasing-x && increasing-y
//  ==0 => decreasing-x && decreasing-y
//
// Also, the boolean pbBlocking determines if there is a potential clash 
// because of common scan lines.
//
//-----------------------------------------------------------------------------
DWORD
_DD_BLT_GetBltDirection(    
    FLATPTR pSrcfpVidMem,
    FLATPTR pDestfpVidMem,
    RECTL *rSrc,
    RECTL *rDest,
    BOOL  *pbBlocking)
{    
    DWORD dwRenderDirection;

    *pbBlocking = FALSE;
    
    if( pDestfpVidMem != pSrcfpVidMem )
    {
        // Not the same surface, so always render downwards.
        dwRenderDirection = 1;
    }
    else
    {
        // Same surface - must choose render direction.
        if(rSrc->top < rDest->top)
        {
            dwRenderDirection = 0;
        }
        else if(rSrc->top > rDest->top)
        {
            dwRenderDirection = 1;
        }
        else // y1 == y2
        {
            if(rSrc->left < rDest->left)
            {
                dwRenderDirection = 0;
            }
            else
            {
                dwRenderDirection = 1;
            }

            // It was found that this condition doesn't guarantee clean blits             
            // therefore we need to do a blocking 2D blit 
            *pbBlocking = TRUE;
        }
    }

    return dwRenderDirection;
    
} // _DD_BLT_GetBltDirection

//-----------------------------------------------------------------------------
//
// _DD_BLT_P3CopyBlt
//
// Perform a Copy blt between the specified surfaces.
//
//-----------------------------------------------------------------------------
VOID _DD_BLT_P3CopyBlt(
    P3_THUNKEDDATA* pThisDisplay,
    FLATPTR pSrcfpVidMem,
    FLATPTR pDestfpVidMem,
    DWORD dwSrcChipPatchMode,
    DWORD dwDestChipPatchMode,
    DWORD dwSrcPitch,
    DWORD dwDestPitch,
    DWORD dwSrcOffset,
    DWORD dwDestOffset,
    DWORD dwDestPixelSize,
    RECTL *rSrc,
    RECTL *rDest)
{
    DWORD   renderData;
    LONG    rSrctop, rSrcleft, rDesttop, rDestleft;
    DWORD   dwSourceOffset;
    BOOL    bBlocking;
    DWORD   dwRenderDirection;

    P3_DMA_DEFS();

    // Beacuse of a bug in RL we sometimes have to fiddle with these values
    rSrctop = rSrc->top;
    rSrcleft = rSrc->left;
    rDesttop = rDest->top;
    rDestleft = rDest->left;

    // Fix coords origin
    if (!_DD_BLT_FixRectlOrigin("_DD_BLT_P3CopyBlt", rSrc, rDest))
    {
        // Nothing to be blitted
        return;
    }

    // Determine the direction of the blt
    dwRenderDirection = _DD_BLT_GetBltDirection(pSrcfpVidMem, 
                                                 pDestfpVidMem,
                                                 rSrc,
                                                 rDest,
                                                 &bBlocking);

    P3_DMA_GET_BUFFER();

    P3_ENSURE_DX_SPACE(40);

    WAIT_FIFO(20); 

    SEND_P3_DATA(PixelSize, (2 - dwDestPixelSize));

    SEND_P3_DATA(FBWriteBufferAddr0, dwDestOffset);
    SEND_P3_DATA(FBWriteBufferWidth0, dwDestPitch);
    SEND_P3_DATA(FBWriteBufferOffset0, 0);
    
    SEND_P3_DATA(FBSourceReadBufferAddr, dwSrcOffset);
    SEND_P3_DATA(FBSourceReadBufferWidth, dwSrcPitch);
    
    dwSourceOffset = (( rSrc->top - rDest->top ) << 16 ) | 
                     (( rSrc->left - rDest->left ) & 0xffff );
                     
    SEND_P3_DATA(FBSourceReadBufferOffset, dwSourceOffset);
    
    SEND_P3_DATA(FBDestReadMode, 
                            P3RX_FBDESTREAD_READENABLE(__PERMEDIA_DISABLE));

    SEND_P3_DATA(FBSourceReadMode, 
                            P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_ENABLE) |
                            P3RX_FBSOURCEREAD_LAYOUT(dwSrcChipPatchMode) |
                            P3RX_FBSOURCEREAD_BLOCKING( bBlocking ));

    SEND_P3_DATA(FBWriteMode, 
                            P3RX_FBWRITEMODE_WRITEENABLE(__PERMEDIA_ENABLE) |
                            P3RX_FBWRITEMODE_LAYOUT0(dwDestChipPatchMode));

    WAIT_FIFO(20); 

    SEND_P3_DATA(RectanglePosition, P3RX_RECTANGLEPOSITION_Y(rDest->top) |
                                    P3RX_RECTANGLEPOSITION_X(rDest->left));

    renderData =  P3RX_RENDER2D_WIDTH(( rDest->right - rDest->left ) & 0xfff )
                | P3RX_RENDER2D_HEIGHT(( rDest->bottom - rDest->top ) & 0xfff )
                | P3RX_RENDER2D_FBREADSOURCEENABLE(__PERMEDIA_ENABLE)
                | P3RX_RENDER2D_SPANOPERATION( P3RX_RENDER2D_SPAN_VARIABLE )
                | P3RX_RENDER2D_INCREASINGX( dwRenderDirection )
                | P3RX_RENDER2D_INCREASINGY( dwRenderDirection );
                
    SEND_P3_DATA(Render2D, renderData);

    // Put back the values if we changed them.
    rSrc->top = rSrctop;
    rSrc->left = rSrcleft;
    rDest->top = rDesttop;
    rDest->left = rDestleft;

    P3_DMA_COMMIT_BUFFER();
} // _DD_BLT_P3CopyBlt


//-----------------------------------------------------------------------------
//
// _DD_BLT_P3CopyBltDD
//
// Perform a Copy blt between the specified Ddraw surfaces.
//
//-----------------------------------------------------------------------------
VOID _DD_BLT_P3CopyBltDD(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pSource,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatSource, 
    P3_SURF_FORMAT* pFormatDest,
    RECTL *rSrc,
    RECTL *rDest)
{
    _DD_BLT_P3CopyBlt(pThisDisplay,
                      pSource->lpGbl->fpVidMem,
                      pDest->lpGbl->fpVidMem,
                      P3RX_LAYOUT_LINEAR, // src
                      P3RX_LAYOUT_LINEAR, // dst
                      DDSurf_GetPixelPitch(pSource),
                      DDSurf_GetPixelPitch(pDest),
                      DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pSource),
                      DDSurf_SurfaceOffsetFromMemoryBase(pThisDisplay, pDest),
                      DDSurf_GetChipPixelSize(pDest),
                      rSrc,
                      rDest);

} // _DD_BLT_P3CopyBltDD
 
//-----------------------------------------------------------------------------
//
// DdBlt
//
// Performs a bit-block transfer.
//
// DdBlt can be optionally implemented in DirectDraw drivers.
//
// Before performing the bit block transfer, the driver should ensure that a 
// flip involving the destination surface is not in progress. If the destination 
// surface is involved in a flip, the driver should set ddRVal to 
// DDERR_WASSTILLDRAWING and return DDHAL_DRIVER_HANDLED.
//
// The driver should check dwFlags to determine the type of blt operation to 
// perform. The driver should not check for flags that are undocumented.
//
// Parameters
//
//      lpBlt 
//          Points to the DD_BLTDATA structure that contains the information 
//          required for the driver to perform the blt. 
//
//          .lpDD 
//              Points to a DD_DIRECTDRAW_GLOBAL structure that describes the 
//              DirectDraw object. 
//          .lpDDDestSurface 
//              Points to the DD_SURFACE_LOCAL structure that describes the 
//              surface on which to blt. 
//          .rDest 
//              Points to a RECTL structure that specifies the upper left and 
//              lower right points of a rectangle on the destination surface. 
//              These points define the area in which the blt should occur and 
//              its position on the destination surface
//          .lpDDSrcSurface 
//              Points to a DD_SURFACE_LOCAL structure that describes the 
//              source surface. 
//          .rSrc 
//              Points to a RECTL structure that specifies the upper left and 
//              lower right points of a rectangle on the source surface. These 
//              points define the area of the source blt data and its position 
//              on the source surface. 
//          .dwFlags 
//              Specify the type of blt operation to perform and which 
//              associated structure members have valid data that the driver 
//              should use. This member is a bit-wise OR of any of the following 
//              flags: 
//
//              DDBLT_AFLAGS 
//                  This flag is not yet used as of DirectX 7.0. Indicates to 
//                  the driver that the dwAFlags and ddrgbaScaleFactors members 
//                  in this structure are valid. This flag is always set if the 
//                  DD_BLTDATA structure is passed to the driver from the 
//                  DdAlphaBlt callback. Otherwise this flag is zero. If this 
//                  flag is set, the DDBLT_ROTATIONANGLE and DDBLT_ROP flags 
//                  will be zero. 
//              DDBLT_ASYNC 
//                  Do this blt asynchronously through the FIFO in the order 
//                  received. If no room exists in the hardware FIFO, the driver 
//                  should fail the call and return immediately. 
//              DDBLT_COLORFILL 
//                  Use the dwFillColor member in the DDBLTFX structure as the 
//                  RGB color with which to fill the destination rectangle on 
//                  the destination surface. 
//              DDBLT_DDFX 
//                  Use the dwDDFX member in the DDBLTFX structure to determine 
//                  the effects to use for the blt. 
//              DDBLT_DDROPS 
//                  This is reserved for system use and should be ignored by the 
//                  driver. The driver should also ignore the dwDDROPS member of 
//                  the DDBLTFX structure. 
//              DDBLT_KEYDESTOVERRIDE 
//                  Use the dckDestColorkey member in the DDBLTFX structure as 
//                  the color key for the destination surface. If an override 
//                  is not being set, then dckDestColorkey does not contain the 
//                  color key. The driver should test the surface itself. 
//              DDBLT_KEYSRCOVERRIDE 
//                  Use the dckSrcColorkey member in the DDBLTFX structure as 
//                  the color key for the source surface. If an override is 
//                  not being set, then dckDestColorkey does not contain the 
//                  color key. The driver should test the surface itself. 
//              DDBLT_ROP 
//                  Use the dwROP member in the DDBLTFX structure for the 
//                  raster operation for this blt. Currently, the only ROP 
//                  passed to the driver is SRCCOPY. This ROP is the same as 
//                  defined in the Win32 API. See the Platform SDK for details.
//              DDBLT_ROTATIONANGLE 
//                  This is not supported on Windows 2000 and should be ignored 
//                  by the driver. 
//
//          .dwROPFlags 
//              This is unused on Windows 2000 and should be ignored by the 
//              driver. 
//          .bltFX 
//              Specifies a DDBLTFX structure that contains override 
//              information for more complex blt operations. For example, the 
//              dwFillColor field is used for solid color fills, and the 
//              ddckSrcColorKey and ddckDestColorKey fields are used for 
//              color key blts. The driver can determine which members of 
//              bltFX contain valid data by looking at the dwFlags member of 
//              the DD_BLTDATA structure. Note that the DDBLTFX_NOTEARING, 
//              DDBLTFX_MIRRORLEFTRIGHT, and DDBLTFX_MIRRORUPDOWN flags are 
//              unsupported on Windows 2000 and will never be passed to the 
//              driver. See the Platform SDK for DDBLTFX documentation. 
//          .ddRVal 
//              This is the location in which the driver writes the return 
//              value of the DdBlt callback. A return code of DD_OK indicates 
//              success. 
//          .Blt 
//              This is unused on Windows 2000. 
//          .IsClipped 
//              Indicates whether this is a clipped blt. On Windows 2000, 
//              this member is always FALSE, indicating that the blt is 
//              unclipped. 
//          .rOrigDest 
//              This member is unused for Windows 2000. Specifies a RECTL 
//              structure that defines the unclipped destination rectangle. 
//              This member is valid only if IsClipped is TRUE. 
//          .rOrigSrc 
//              This member is unused for Windows 2000. Specifies a RECTL 
//              structure that defines the unclipped source rectangle. This 
//              member is valid only if IsClipped is TRUE. 
//          .dwRectCnt 
//              This member is unused for Windows 2000. Specifies the number 
//              of destination rectangles to which prDestRects points. This 
//              member is valid only if IsClipped is TRUE. 
//          .prDestRects 
//              This member is unused for Windows 2000. Points to an array of 
//              RECTL structures that describe of destination rectangles. This 
//              member is valid only if IsClipped is TRUE. 
//          .dwAFlags 
//              This member is only valid if the DDBLT_AFLAGS flag is set in 
//              the dwFlags member of this structure. This member specifies 
//              operation flags used only by the DdAlphaBlt callback (which 
//              is not yet implemented as of DirectX 7.0). This member is a 
//              bit-wise OR of any of the following flags: 
//
//              DDABLT_BILINEARFLITER 
//                  Enable bilinear filtering of the source pixels during a 
//                  stretch blit. By default, no filtering is performed. 
//                  Instead, a nearest neighbor source pixel is copied to a 
//                  destination pixel 
//              DDABLT_NOBLEND 
//                  Write the source pixel values to the destination surface 
//                  without blending. The pixels are converted from the source 
//                  pixel format to the destination format, but no color 
//                  keying, alpha blending, or RGBA scaling is performed. In 
//                  the case of a fill operation (where the lpDDSrcSurface 
//                  member is NULL), the lpDDRGBAScaleFactors member of this 
//                  structure points to the source alpha and color components 
//                  that are to be converted to the destination pixel format 
//                  and are used to fill the destination. A blit operation is 
//                  performed if a valid source surface is specified, but in 
//                  this case, lpDDRGBAScaleFactors must be NULL or the call 
//                  will fail. This flag cannot be used in conjunction with 
//                  the DDBLT_KEYSRC and DDBLT_KEYDEST flags. 
//              DDABLT_SRCOVERDEST 
//                  If set, this flag indicates that the operation originated 
//                  from the application's AlphaBlt method. If the call was 
//                  originated by the application's Blt method, this flag is 
//                  not set. Drivers that have a unified DdBlt and DdAlphaBlt 
//                  callback can use this flag to distinguish between the two 
//                  application method calls. 
//
//          .ddrgbaScaleFactors 
//              This member is only valid if the DDBLT_AFLAGS flag is set in 
//              the dwFlags member of this structure. DDARGB structure that 
//              contains the RGBA-scaling factors used to scale the color and 
//              alpha components of each source pixel before it is composited 
//              to the destination surface. 
//
//-----------------------------------------------------------------------------
DWORD CALLBACK 
DdBlt( 
    LPDDHAL_BLTDATA lpBlt )
{
    RECTL   rSrc;
    RECTL   rDest;
    DWORD   dwFlags;
    BYTE    rop;
    LPDDRAWI_DDRAWSURFACE_LCL  pSrcLcl;
    LPDDRAWI_DDRAWSURFACE_LCL  pDestLcl;
    LPDDRAWI_DDRAWSURFACE_GBL  pSrcGbl;
    LPDDRAWI_DDRAWSURFACE_GBL  pDestGbl;
    P3_SURF_FORMAT* pFormatSource;
    P3_SURF_FORMAT* pFormatDest;
    P3_THUNKEDDATA* pThisDisplay;
    HRESULT ddrval = DD_OK;
    BOOL bOverlapStretch = FALSE;

    DBG_CB_ENTRY(DdBlt);

    pDestLcl = lpBlt->lpDDDestSurface;
    pSrcLcl = lpBlt->lpDDSrcSurface;
        
    GET_THUNKEDDATA(pThisDisplay, lpBlt->lpDD);

    VALIDATE_MODE_AND_STATE(pThisDisplay);

    pDestGbl = pDestLcl->lpGbl;
    pFormatDest = _DD_SUR_GetSurfaceFormat(pDestLcl);

    DISPDBG((DBGLVL, "Dest Surface:"));
    DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pDestLcl);

    dwFlags = lpBlt->dwFlags;

    STOP_SOFTWARE_CURSOR(pThisDisplay);

    ddrval = _DX_QueryFlipStatus(pThisDisplay, pDestGbl->fpVidMem, TRUE);
    if( FAILED( ddrval ) )
    {
        lpBlt->ddRVal = ddrval;
        START_SOFTWARE_CURSOR(pThisDisplay);
        DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);        
        return DDHAL_DRIVER_HANDLED;
    }

    //
    // If async, then only work if bltter isn't busy
    //
    if( dwFlags & DDBLT_ASYNC )
    {
        if(DRAW_ENGINE_BUSY(pThisDisplay))
        {
            DISPDBG((WRNLVL, "ASYNC Blit Failed" ));
            lpBlt->ddRVal = DDERR_WASSTILLDRAWING;
            START_SOFTWARE_CURSOR(pThisDisplay);
            DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);            
            return DDHAL_DRIVER_HANDLED;
        }
#if DBG
        else
        {
            DISPDBG((DBGLVL, "ASYNC Blit Succeeded!"));
        }
#endif
        
    }

    //
    // copy src/dest rects
    //
    rSrc = lpBlt->rSrc;
    rDest = lpBlt->rDest;
    
    rop = (BYTE) (lpBlt->bltFX.dwROP >> 16);

    // Switch to DirectDraw context
    DDRAW_OPERATION(pContext, pThisDisplay);

    if (dwFlags & DDBLT_ROP)
    {
        if (rop == (SRCCOPY >> 16))
        {

            DISPDBG((DBGLVL,"DDBLT_ROP:  SRCCOPY"));
            if (pSrcLcl != NULL) 
            {
                pSrcGbl = pSrcLcl->lpGbl;
                pFormatSource = _DD_SUR_GetSurfaceFormat(pSrcLcl);

                DISPDBG((DBGLVL, "Source Surface:"));
                DBGDUMP_DDRAWSURFACE_LCL(DBGLVL, pSrcLcl);
            }
            else 
            {
                START_SOFTWARE_CURSOR(pThisDisplay);
                DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);                
                return DDHAL_DRIVER_NOTHANDLED;
            }

#if DX7_TEXMANAGEMENT
            if ((pSrcLcl->lpSurfMore->ddsCapsEx.dwCaps2 & 
                                    DDSCAPS2_TEXTUREMANAGE) ||
                (pDestLcl->lpSurfMore->ddsCapsEx.dwCaps2 & 
                                    DDSCAPS2_TEXTUREMANAGE) )
            {
                // Managed source surface cases 
                // (Including managed destination surfaces case)
                if (pSrcLcl->lpSurfMore->ddsCapsEx.dwCaps2 & 
                            DDSCAPS2_TEXTUREMANAGE)
                {
                    if ((pDestLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) ||
                        (pDestLcl->lpSurfMore->ddsCapsEx.dwCaps2 & 
                                            DDSCAPS2_TEXTUREMANAGE)         )
                    {
                        //-------------------------------------------------
                        // Do the Managed surf -> sysmem | managed surf blt
                        //-------------------------------------------------    

                        // make sure we'll reload the vidmem copy of the dest surf
                        if (pDestLcl->lpSurfMore->ddsCapsEx.dwCaps2 & 
                                                DDSCAPS2_TEXTUREMANAGE)         
                        {
                            _D3D_TM_MarkDDSurfaceAsDirty(pThisDisplay, 
                                                         pDestLcl, 
                                                         TRUE);                        
                        }

                        _DD_BLT_SysMemToSysMemCopy(
                                    pSrcGbl->fpVidMem,
                                    pSrcGbl->lPitch,
                                    DDSurf_BitDepth(pSrcLcl),  
                                    pDestGbl->fpVidMem,
                                    pDestGbl->lPitch,  
                                    DDSurf_BitDepth(pDestLcl),  
                                    &rSrc,
                                    &rDest);
                                    
                    }
                    else if ((pDestLcl->ddsCaps.dwCaps & DDSCAPS_LOCALVIDMEM))
                    {
                        //-------------------------------------------------
                        // Do the Managed surf -> vidmem surf blt
                        //-------------------------------------------------                  

                        // This might be optimized by doing a vidmem->vidmem 
                        // when the source managed texture has a vidmem copy

                        _DD_P3Download(pThisDisplay,
                                       pSrcGbl->fpVidMem,
                                       pDestGbl->fpVidMem,
                                       P3RX_LAYOUT_LINEAR,
                                       P3RX_LAYOUT_LINEAR,
                                       pSrcGbl->lPitch,
                                       pDestGbl->lPitch,                                                             
                                       DDSurf_GetPixelPitch(pDestLcl),
                                       DDSurf_GetChipPixelSize(pDestLcl),
                                       &rSrc,
                                       &rDest);                                                                                 
                    }
                    
                    else            
                    {
                        DISPDBG((ERRLVL,"Src-managed Tex DdBlt"
                                        " variation unimplemented!"));
                    }                   
                    
                    goto Blt32Done;                    
                }
            
                // Managed destination surface cases
                if (pDestLcl->lpSurfMore->ddsCapsEx.dwCaps2 & 
                            DDSCAPS2_TEXTUREMANAGE)
                {                
                    if (pSrcLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                    {
                        //-------------------------------------------------
                        // Do the sysmem surf -> managed surf blt
                        //-------------------------------------------------    

                        // make sure we'll reload the vidmem copy of the dest surf
                        _D3D_TM_MarkDDSurfaceAsDirty(pThisDisplay, 
                                                     pDestLcl, 
                                                     TRUE);

                        _DD_BLT_SysMemToSysMemCopy(
                                    pSrcGbl->fpVidMem,
                                    pSrcGbl->lPitch,
                                    DDSurf_BitDepth(pSrcLcl),
                                    pDestGbl->fpVidMem,
                                    pDestGbl->lPitch,
                                    DDSurf_BitDepth(pDestLcl),
                                    &rSrc, 
                                    &rDest);

                        goto Blt32Done;
                    }
                    else if (pSrcLcl->ddsCaps.dwCaps & DDSCAPS_LOCALVIDMEM)             
                    {
                        //-------------------------------------------------
                        // Do the vidmem surf -> Managed surf blt
                        //-------------------------------------------------                                  

                        // make sure we'll reload the 
                        // vidmem copy of the dest surf
                        _D3D_TM_MarkDDSurfaceAsDirty(pThisDisplay, 
                                                     pDestLcl, 
                                                     TRUE);

                        // Do slow mem mapped framebuffer blt into sysmem
                        // The source surface lives in video mem so we need to get a
                        // "real" sysmem address for it:                    
                        _DD_BLT_SysMemToSysMemCopy(
                                    DDSURF_GETPOINTER(pSrcGbl, pThisDisplay),
                                    pSrcGbl->lPitch,
                                    DDSurf_BitDepth(pSrcLcl),  
                                    pDestGbl->fpVidMem,
                                    pDestGbl->lPitch,  
                                    DDSurf_BitDepth(pDestLcl), 
                                    &rSrc,
                                    &rDest);
                    }                    
                    else            
                    {
                        DISPDBG((ERRLVL,"Dest-managed Tex DdBlt"
                                        " variation unimplemented!"));
                    }                                    

                    
                }
                
                goto Blt32Done;

            }
#endif // DX7_TEXMANAGEMENT

            // Invalid cases...
            if ((pFormatSource->DeviceFormat == SURF_YUV422) && 
                (pFormatDest->DeviceFormat == SURF_CI8))
            {
                DISPDBG((ERRLVL,"Can't do this blit!"));
                START_SOFTWARE_CURSOR(pThisDisplay);
                lpBlt->ddRVal = DDERR_UNSUPPORTED;
                DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);                
                return DDHAL_DRIVER_NOTHANDLED;
            }

            // Operation is System -> Video memory blit, as a texture 
            // download or an image download.
            if (!(dwFlags & DDBLT_KEYDESTOVERRIDE) &&
                (pSrcLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) && 
                (pDestLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
            {
                DISPDBG((DBGLVL,"Being Asked to do SYSMEM->VIDMEM Blit"));

                if (rop != (SRCCOPY >> 16)) 
                {
                    DISPDBG((DBGLVL,"Being asked for non-copy ROP, refusing"));
                    lpBlt->ddRVal = DDERR_NORASTEROPHW;

                    START_SOFTWARE_CURSOR(pThisDisplay);
                    DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);                    
                    return DDHAL_DRIVER_NOTHANDLED;
                }

                DISPDBG((DBGLVL,"Doing image download"));

                _DD_P3DownloadDD(pThisDisplay, 
                           pSrcLcl, 
                           pDestLcl, 
                           pFormatSource, 
                           pFormatDest, 
                           &rSrc, 
                           &rDest);
                           
                goto Blt32Done;
            } 

            // Check for overlapping stretch blits.
            // Are the surfaces the same?
            if (pDestLcl->lpGbl->fpVidMem == pSrcLcl->lpGbl->fpVidMem)
            {
                // Do they overlap?
                if ((!((rSrc.bottom < rDest.top) || (rSrc.top > rDest.bottom))) &&
                    (!((rSrc.right < rDest.left) || (rSrc.left > rDest.right)))   )
                {
                    // Are they of different source and dest sizes?
                    if ( ((rSrc.right - rSrc.left) != (rDest.right - rDest.left)) || 
                         ((rSrc.bottom - rSrc.top) != (rDest.bottom - rDest.top)) )
                    {
                        bOverlapStretch = TRUE;
                    }
                }
            }

            // Is it a transparent blit?
            if ( ( dwFlags & DDBLT_KEYSRCOVERRIDE  ) || 
                 ( dwFlags & DDBLT_KEYDESTOVERRIDE ) )
            {
                DISPDBG((DBGLVL,"DDBLT_KEYSRCOVERRIDE"));

                if (rop != (SRCCOPY >> 16)) 
                {
                    lpBlt->ddRVal = DDERR_NORASTEROPHW;
                    START_SOFTWARE_CURSOR(pThisDisplay);
                    DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);                    
                    return DDHAL_DRIVER_NOTHANDLED;
                }

                // If the surface sizes don't match, then we are stretching.
                // If the surfaces are flipped then do it this was for now...
                if (((rSrc.right - rSrc.left) != (rDest.right - rDest.left) || 
                     (rSrc.bottom - rSrc.top) != (rDest.bottom - rDest.top) ) ||
                    ((dwFlags & DDBLT_DDFX) && 
                     ((lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN) ||
                      (lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT)) ) )
                {
                    if (!bOverlapStretch)
                    {
                        // Use generic rout.
                        _DD_P3BltStretchSrcChDstCh_DD(pThisDisplay, 
                                                      pSrcLcl, 
                                                      pDestLcl, 
                                                      pFormatSource, 
                                                      pFormatDest, 
                                                      lpBlt, 
                                                      &rSrc, 
                                                      &rDest);
                    }
                    else
                    {
                        // Stretched overlapped blits (DCT case)
                        _DD_P3BltStretchSrcChDstChOverlap(pThisDisplay, 
                                                          pSrcLcl, 
                                                          pDestLcl, 
                                                          pFormatSource,
                                                          pFormatDest, 
                                                          lpBlt, 
                                                          &rSrc, 
                                                          &rDest);
                    }
                }
                else if ( dwFlags & DDBLT_KEYDESTOVERRIDE )
                {
                    if ((pSrcLcl->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                        (pDestLcl->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
                    {
                        DISPDBG((DBGLVL,"Being Asked to do SYSMEM->VIDMEM "
                                   "Blit with DestKey"));

                        if (rop != (SRCCOPY >> 16)) 
                        {   
                            DISPDBG((DBGLVL,"Being asked for non-copy "
                                       "ROP, refusing"));
                            lpBlt->ddRVal = DDERR_NORASTEROPHW;

                            START_SOFTWARE_CURSOR(pThisDisplay);
                            DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);                            
                            return DDHAL_DRIVER_NOTHANDLED;
                        }

                        // A download routine that does destination colorkey.
                        _DD_P3DownloadDstCh(pThisDisplay, 
                                        pSrcLcl, 
                                        pDestLcl, 
                                        pFormatSource, 
                                        pFormatDest, 
                                        lpBlt, 
                                        &rSrc, 
                                        &rDest);
                    }
                    else
                    {
                        _DD_P3BltStretchSrcChDstCh_DD(pThisDisplay, 
                                                      pSrcLcl, 
                                                      pDestLcl, 
                                                      pFormatSource, 
                                                      pFormatDest, 
                                                      lpBlt, 
                                                      &rSrc, 
                                                      &rDest);
                    }
                }
                else
                {
                    if (DDSurf_IsAGP(pSrcLcl))
                    {
                        // Need this rout if we are in 
                        // AGP memory because this textures
                        _DD_P3BltStretchSrcChDstCh_DD(pThisDisplay, 
                                                      pSrcLcl, 
                                                      pDestLcl, 
                                                      pFormatSource, 
                                                      pFormatDest, 
                                                      lpBlt, 
                                                      &rSrc, 
                                                      &rDest);
                    }
                    else
                    {
                        // Only source keying, and no stretching.
                        _DD_P3BltSourceChroma(pThisDisplay, 
                                              pSrcLcl, 
                                              pDestLcl, 
                                              pFormatSource, 
                                              pFormatDest, 
                                              lpBlt, 
                                              &rSrc, 
                                              &rDest);
                    }
                }
                goto Blt32Done;
            }
            else
            { 
                // If the surface sizes don't match, then we are stretching.
                // If the surfaces are flipped then do it this was for now...
                if (((rSrc.right - rSrc.left) != (rDest.right - rDest.left) || 
                    (rSrc.bottom - rSrc.top) != (rDest.bottom - rDest.top)) ||
                      ((lpBlt->dwFlags & DDBLT_DDFX) && 
                      ((lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORUPDOWN)         || 
                       (lpBlt->bltFX.dwDDFX & DDBLTFX_MIRRORLEFTRIGHT))))
                {
                    // Is a stretch blit
                    DISPDBG((DBGLVL,"DDBLT_ROP: STRETCHCOPYBLT OR "
                                    "MIRROR OR BOTH"));
                            
                    // Can't rop during a stretch blit.
                    if (rop != (SRCCOPY >> 16)) 
                    {
                        lpBlt->ddRVal = DDERR_NORASTEROPHW;
                        START_SOFTWARE_CURSOR(pThisDisplay);
                        DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);                        
                        return DDHAL_DRIVER_NOTHANDLED;
                    }

                    // Do the stretch
                    if (!bOverlapStretch)
                    {
                        // Use the generic rout ATM.
                        _DD_P3BltStretchSrcChDstCh_DD(pThisDisplay, 
                                                      pSrcLcl, 
                                                      pDestLcl, 
                                                      pFormatSource, 
                                                      pFormatDest, 
                                                      lpBlt, 
                                                      &rSrc, 
                                                      &rDest);
                    }
                    else
                    {
                        // DCT case - Stretched overlapped blits
                        _DD_P3BltStretchSrcChDstChOverlap(pThisDisplay, 
                                                          pSrcLcl, 
                                                          pDestLcl, 
                                                          pFormatSource, 
                                                          pFormatDest, 
                                                          lpBlt, 
                                                          &rSrc, 
                                                          &rDest);
                    }
                }
                else    // ! Stretching
                {
                    // Must be a standard blit.
                    DISPDBG((DBGLVL,"DDBLT_ROP:  COPYBLT"));
                    DISPDBG((DBGLVL,"Standard Copy Blit"));

                    // If the source is in AGP, use a texturing blitter.

                    if ((DDSurf_IsAGP(pSrcLcl)) || 
                        ((pFormatSource->DeviceFormat == SURF_YUV422) &&
                         (pFormatDest->DeviceFormat != SURF_YUV422)))
                    {
                        _DD_P3BltStretchSrcChDstCh_DD(pThisDisplay, 
                                                      pSrcLcl, 
                                                      pDestLcl, 
                                                      pFormatSource, 
                                                      pFormatDest, 
                                                      lpBlt, 
                                                      &rSrc, 
                                                      &rDest);
                    }
                    else
                    {
                        // A standard, boring blit.
                        // Call the correct CopyBlt Function.

                        _DD_BLT_P3CopyBltDD(pThisDisplay, 
                                            pSrcLcl, 
                                            pDestLcl, 
                                            pFormatSource, 
                                            pFormatDest, 
                                            &rSrc, 
                                            &rDest);
                    }
                }
                goto Blt32Done;
            }
        }
        else if ((rop == (BLACKNESS >> 16)) || (rop == (WHITENESS >> 16)))
        {
            DWORD color;

            DISPDBG((DBGLVL,"DDBLT_ROP:  BLACKNESS or WHITENESS"));
            
            if (rop == (BLACKNESS >> 16))
            {
                color = 0;
            }
            else
            {
                color = 0xffffffff;
            }
            
            _DD_BLT_P3ClearDD(pThisDisplay, 
                        pDestLcl, 
                        pFormatDest, 
                        &rDest, 
                        color, 
                        FALSE, 
                        FALSE);
        }
        else if ((rop & 7) != ((rop >> 4) & 7))
        {
            lpBlt->ddRVal = DDERR_NORASTEROPHW;

            START_SOFTWARE_CURSOR(pThisDisplay);
            DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);            
            return DDHAL_DRIVER_NOTHANDLED;
        }
        else
        {
            DISPDBG((WRNLVL,"P3 BLT case not found!"));

            START_SOFTWARE_CURSOR(pThisDisplay);
            DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);            
            return DDHAL_DRIVER_NOTHANDLED;
        }
    }
    else if (dwFlags & DDBLT_COLORFILL)
    {
        DISPDBG((DBGLVL,"DDBLT_COLORFILL(P3): Color=0x%x", 
                        lpBlt->bltFX.dwFillColor));
#if DX7_TEXMANAGEMENT                        
        // If clearing a driver managed texture, clear just the sysmem copy
        if (pDestLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_TEXTUREMANAGE)
        {
            _DD_BLT_P3ClearManagedSurf(DDSurf_GetChipPixelSize(pDestLcl),
                                       &rDest, 
                                       pDestGbl->fpVidMem, 
                                       pDestGbl->lPitch,
                                       lpBlt->bltFX.dwFillColor);

            _D3D_TM_MarkDDSurfaceAsDirty(pThisDisplay, 
                                         pDestLcl, 
                                         TRUE);
        }
        else
#endif // DX7_TEXMANAGEMENT          
        {
            _DD_BLT_P3ClearDD(pThisDisplay, 
                        pDestLcl, 
                        pFormatDest, 
                        &rDest, 
                        lpBlt->bltFX.dwFillColor, 
                        FALSE, 
                        FALSE);
        }
    }
    else if (dwFlags & DDBLT_DEPTHFILL || 
             ((dwFlags & DDBLT_COLORFILL) && 
              (pDestLcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER)))
    {
        DISPDBG((DBGLVL,"DDBLT_DEPTHFILL(P3):  Value=0x%x", 
                        lpBlt->bltFX.dwFillColor));

        _DD_BLT_P3ClearDD(pThisDisplay, 
                    pDestLcl, 
                    pFormatDest, 
                    &rDest, 
                    lpBlt->bltFX.dwFillColor, 
                    TRUE, 
                    TRUE);
    }
    else
    {
        START_SOFTWARE_CURSOR(pThisDisplay);
        DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);        
        return DDHAL_DRIVER_NOTHANDLED;
    }


Blt32Done:

    if ((pDestLcl->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) ||
        (pDestLcl->ddsCaps.dwCaps & DDSCAPS_FRONTBUFFER))
    {
        P3_DMA_DEFS();
        DISPDBG((DBGLVL,"Flushing DMA due to primary target in DDRAW"));
        P3_DMA_GET_BUFFER();
        P3_DMA_FLUSH_BUFFER();
    }

    START_SOFTWARE_CURSOR(pThisDisplay);

    lpBlt->ddRVal = DD_OK;
    
    DBG_CB_EXIT(DdBlt,lpBlt->ddRVal);    
    
    return DDHAL_DRIVER_HANDLED;

} // DdBlt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\video\ms\3dlabs\perm3\disp\dx\dddownld.c ===
/******************************Module*Header**********************************\
*
*                           **************************
*                           * DirectDraw SAMPLE CODE *
*                           **************************
*
* Module Name: dddownld.c
*
* Content: DirectDraw Blt implementation for sysmem-vidmem blts and clears
*
* Copyright (c) 1994-1999 3Dlabs Inc. Ltd. All rights reserved.
* Copyright (c) 1995-2003 Microsoft Corporation.  All rights reserved.
\*****************************************************************************/

#include "glint.h"
#include "dma.h"
#include "tag.h"

#define UNROLL_COUNT    8   // Number of iterations of transfer in an unrolled loop
#define P3_BLOCK_SIZE      (UNROLL_COUNT * 8)  // # of unrolled loops .
#define GAMMA_BLOCK_SIZE   (UNROLL_COUNT * 2)  // # of unrolled loops .
#define BLOCK_SIZE         (DWORD)((TLCHIP_GAMMA)?GAMMA_BLOCK_SIZE:P3_BLOCK_SIZE)

#define TAGGED_SIZE ((BLOCK_SIZE - 1) << 16)


#define UNROLLED()                  \
    MEMORY_BARRIER();               \
    dmaPtr[0] = pCurrentLine[0];    \
    ulTotalImageDWORDs--;           \
    MEMORY_BARRIER();               \
    dmaPtr[1] = pCurrentLine[1];    \
    ulTotalImageDWORDs--;           \
    MEMORY_BARRIER();               \
    dmaPtr[2] = pCurrentLine[2];    \
    ulTotalImageDWORDs--;           \
    MEMORY_BARRIER();               \
    dmaPtr[3] = pCurrentLine[3];    \
    ulTotalImageDWORDs--;           \
    MEMORY_BARRIER();               \
    dmaPtr[4] = pCurrentLine[4];    \
    ulTotalImageDWORDs--;           \
    MEMORY_BARRIER();               \
    dmaPtr[5] = pCurrentLine[5];    \
    ulTotalImageDWORDs--;           \
    MEMORY_BARRIER();               \
    dmaPtr[6] = pCurrentLine[6];    \
    ulTotalImageDWORDs--;           \
    MEMORY_BARRIER();               \
    dmaPtr[7] = pCurrentLine[7];    \
    ulTotalImageDWORDs--;           \
    MEMORY_BARRIER();               \
    dmaPtr += UNROLL_COUNT;         \
    CHECK_FIFO(UNROLL_COUNT);       \
    pCurrentLine += UNROLL_COUNT;


//-----------------------------------------------------------------------------
//
// _DD_P3Download
//
//
// Function to do an image download to the rectangular region.
// Uses the packed bit on Permedia to do the packing for us.  
//
//-----------------------------------------------------------------------------
void 
_DD_P3Download(
    P3_THUNKEDDATA* pThisDisplay,
    FLATPTR pSrcfpVidMem,
    FLATPTR pDestfpVidMem,    
    DWORD dwSrcChipPatchMode,
    DWORD dwDestChipPatchMode,  
    DWORD dwSrcPitch,
    DWORD dwDestPitch,   
    DWORD dwDestPixelPitch,  
    DWORD dwDestPixelSize,
    RECTL* rSrc,
    RECTL* rDest)
{
    // Work out pixel offset into the framestore of the rendered surface
    ULONG ulSCRoundedUpDWords;
    ULONG ulSCWholeDWords, ulSCDWordsCnt, ulSCExtraBytes;
    ULONG ulTotalImageDWORDs;
    DWORD SrcOffset; 
    DWORD DstOffset; 
    ULONG ulImageLines;
    ULONG count;
    ULONG renderData;
    DWORD dwDownloadTag;
    int rDestleft, rDesttop, rSrcleft, rSrctop;
    RECTL rNewDest;
    P3_DMA_DEFS();
               
    // Because of a bug in RL we sometimes have to fiddle with these values
    rSrctop = rSrc->top;
    rSrcleft = rSrc->left;
    rDesttop = rDest->top;
    rDestleft = rDest->left;

    // Fix coords origin
    if(!_DD_BLT_FixRectlOrigin("_DD_P3Download", rSrc, rDest))
    {
        // Nothing to be blitted
        return;
    }    
    
       
    SrcOffset = (DWORD)(rSrc->left << dwDestPixelSize) + 
                                    (rSrc->top * dwSrcPitch);
    DstOffset = (DWORD)(rDest->left << dwDestPixelSize) + 
                                    (rDest->top * dwDestPitch);

    ulSCRoundedUpDWords = rDest->right - rDest->left;
    ulImageLines = rDest->bottom - rDest->top;

    P3_DMA_GET_BUFFER();
    P3_ENSURE_DX_SPACE(16);
    WAIT_FIFO(16);

    SEND_P3_DATA(FBWriteBufferAddr0, 
                        (DWORD)(pDestfpVidMem - 
                                   pThisDisplay->dwScreenFlatAddr) );
                                
    SEND_P3_DATA(FBWriteBufferWidth0, dwDestPixelPitch);
    SEND_P3_DATA(FBWriteBufferOffset0, 
                                        (rDest->top << 16) | 
                                        (rDest->left & 0xFFFF));

    SEND_P3_DATA(LogicalOpMode, 7);

    SEND_P3_DATA(PixelSize, (2 - dwDestPixelSize));

    SEND_P3_DATA(FBWriteMode, 
                    P3RX_FBWRITEMODE_WRITEENABLE(__PERMEDIA_ENABLE) |
                    P3RX_FBWRITEMODE_LAYOUT0(P3RX_LAYOUT_LINEAR));
                    
    SEND_P3_DATA(FBDestReadMode, 
                    P3RX_FBDESTREAD_READENABLE(__PERMEDIA_DISABLE) |
                    P3RX_FBDESTREAD_LAYOUT0(P3RX_LAYOUT_LINEAR));

    dwDownloadTag = Color_Tag;

    rNewDest = *rDest;

    DISPDBG((DBGLVL, "Image download %dx%d", ulSCRoundedUpDWords, ulImageLines));

    // ulSCWholeDWords is the number of whole DWORDs along each scanline
    // ulSCExtraBytes  is the number of extra BYTEs at the end of each scanline
    // ulSCRoundedUpDWords is the size of each scanline rounded up to DWORDs
    if (dwDestPixelSize != __GLINT_32BITPIXEL) 
    {
        if (dwDestPixelSize == __GLINT_8BITPIXEL) 
        {
            ulSCExtraBytes  = ulSCRoundedUpDWords & 3;
            ulSCWholeDWords = ulSCRoundedUpDWords >> 2;
            ulSCRoundedUpDWords = (ulSCRoundedUpDWords + 3) >> 2; 

            if (dwDownloadTag != Color_Tag)
            {
                rNewDest.right = rNewDest.left + (ulSCRoundedUpDWords << 2);
            }
        }
        else 
        {
            ulSCExtraBytes  = (ulSCRoundedUpDWords & 1) << 1;
            ulSCWholeDWords = ulSCRoundedUpDWords >> 1;
            ulSCRoundedUpDWords = (ulSCRoundedUpDWords + 1) >> 1;

            if (dwDownloadTag != Color_Tag)
            {
                rNewDest.right = rNewDest.left + (ulSCRoundedUpDWords << 1);
            }
        }
    }
    else
    {
        ulSCExtraBytes = 0;
        ulSCWholeDWords = ulSCRoundedUpDWords;
    }

    // Calc the total number of image DWORDs to send to GPU
    ulTotalImageDWORDs = ulImageLines * ulSCWholeDWords;

    P3_ENSURE_DX_SPACE(20);
    WAIT_FIFO(20);        

    SEND_P3_DATA(FBSourceReadMode, 
                      P3RX_FBSOURCEREAD_READENABLE(__PERMEDIA_DISABLE) |
                      P3RX_FBSOURCEREAD_LAYOUT(dwSrcChipPatchMode));

    SEND_P3_DATA(RectanglePosition, 0);

    if (dwDownloadTag == Color_Tag)
    {
        renderData =  P3RX_RENDER2D_WIDTH((rNewDest.right - rNewDest.left) & 0xfff )
                    | P3RX_RENDER2D_HEIGHT((rNewDest.bottom - rNewDest.top ) & 0xfff )
                    | P3RX_RENDER2D_OPERATION( P3RX_RENDER2D_OPERATION_SYNC_ON_HOST_DATA )
                    | P3RX_RENDER2D_SPANOPERATION( P3RX_RENDER2D_SPAN_VARIABLE )
                    | P3RX_RENDER2D_INCREASINGX( __PERMEDIA_ENABLE )
                    | P3RX_RENDER2D_INCREASINGY( __PERMEDIA_ENABLE );
        SEND_P3_DATA(Render2D, renderData);
    }
    else
    {
        // Don't use spans for the unpacking scheme, but use the 2D Setup
        // unit to do the work of setting up the destination
        SEND_P3_DATA(ScissorMinXY, 0);
        SEND_P3_DATA(ScissorMaxXY, P3RX_SCISSOR_X_Y(rDest->right, rDest->bottom));
        SEND_P3_DATA(ScissorMode, P3RX_SCISSORMODE_USER(__PERMEDIA_ENABLE));
        
        renderData =  P3RX_RENDER2D_WIDTH( (rNewDest.right - rNewDest.left) & 0xfff )
                    | P3RX_RENDER2D_HEIGHT( 0 )
                    | P3RX_RENDER2D_OPERATION( P3RX_RENDER2D_OPERATION_SYNC_ON_HOST_DATA )
                    | P3RX_RENDER2D_INCREASINGX( __PERMEDIA_ENABLE )
                    | P3RX_RENDER2D_INCREASINGY( __PERMEDIA_ENABLE );
        SEND_P3_DATA(Render2D, renderData);

        SEND_P3_DATA(Count, rDest->bottom - rDest->top );
        SEND_P3_DATA(Render, __RENDER_TRAPEZOID_PRIMITIVE | __RENDER_SYNC_ON_HOST_DATA);
    }

    P3_ENSURE_DX_SPACE(32);
    WAIT_FIFO(32);

    __try
    {
        BYTE *pSurfaceData = (BYTE *)pSrcfpVidMem + SrcOffset;
        UNALIGNED DWORD *pCurrentLine = (DWORD *)pSurfaceData;
        
        while (ulImageLines-- > 0)
        {
            DISPDBG((DBGLVL, "Image download lines %d", ulImageLines));

            // Initialize the number of DWORDs counter
            ulSCDWordsCnt = ulSCWholeDWords;

            // Send the texels in DWORDS
            while (ulSCDWordsCnt >= BLOCK_SIZE)
            {
                P3_ENSURE_DX_SPACE(BLOCK_SIZE + 1);
                WAIT_FIFO(BLOCK_SIZE + 1);
                ADD_FUNNY_DWORD(TAGGED_SIZE | dwDownloadTag);

                for (count = BLOCK_SIZE / UNROLL_COUNT; count; count--)
                {
                    DISPDBG((DBGLVL, "Image download count %d", count));
                    UNROLLED();
                }
                ulSCDWordsCnt -= BLOCK_SIZE;
            }

            // Finish off the rest of the whole DWORDs on the scanline
            if (ulSCDWordsCnt) 
            {
                P3_ENSURE_DX_SPACE(ulSCDWordsCnt + 1);
                WAIT_FIFO(ulSCDWordsCnt + 1);
                ADD_FUNNY_DWORD(((ulSCDWordsCnt - 1) << 16) | dwDownloadTag);

                for (count = 0; count < ulSCDWordsCnt; count++, pCurrentLine++) 
                {
                    ADD_FUNNY_DWORD(*pCurrentLine);
                    ulTotalImageDWORDs--;
                }
            }

            // Finish off the extra bytes at the end of the scanline
            if (ulSCExtraBytes) 
            {
                DWORD dwTemp;

                P3_ENSURE_DX_SPACE(1 + 1);   // 1 tag + 1 data DWORD
                WAIT_FIFO(1 + 1);
                ADD_FUNNY_DWORD(dwDownloadTag);

                memcpy(&dwTemp, pCurrentLine, ulSCExtraBytes);
                ADD_FUNNY_DWORD(dwTemp);
                ulTotalImageDWORDs--;
            }

            pSurfaceData += dwSrcPitch;
            pCurrentLine = (DWORD*)pSurfaceData;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        DISPDBG((ERRLVL, "Perm3 caused exception at line %u of file %s",
                         __LINE__,__FILE__));
        // Send enough DWORDs to the GPU to avoid deadlock
        for (count = 0; count < ulTotalImageDWORDs; count++)
        {
            ADD_FUNNY_DWORD(dwDownloadTag);
            ADD_FUNNY_DWORD(0);                 // Dummy pixel data
        }
    }

    P3_ENSURE_DX_SPACE(4);
    WAIT_FIFO(4);

    SEND_P3_DATA(WaitForCompletion, 0);
    SEND_P3_DATA(ScissorMode, __PERMEDIA_DISABLE);

    // Put back the values if we changed them.
    rSrc->top = rSrctop;
    rSrc->left = rSrcleft;
    rDest->top = rDesttop;
    rDest->left = rDestleft;

    P3_DMA_COMMIT_BUFFER();

}  // _DD_P3Download 

//-----------------------------------------------------------------------------
//
// _DD_P3DownloadDD
//
//
// Function to do an image download to the rectangular region.
// Uses the packed bit on Permedia to do the packing for us.  
//
//-----------------------------------------------------------------------------
void 
_DD_P3DownloadDD(
    P3_THUNKEDDATA* pThisDisplay,
    LPDDRAWI_DDRAWSURFACE_LCL pSource,
    LPDDRAWI_DDRAWSURFACE_LCL pDest,
    P3_SURF_FORMAT* pFormatSource, 
    P3_SURF_FORMAT* pFormatDest,
    RECTL* rSrc,
    RECTL* rDest)
{
    _DD_P3Download(pThisDisplay,
                   pSource->lpGbl->fpVidMem,
                   pDest->lpGbl->fpVidMem,
                   P3RX_LAYOUT_LINEAR, // src
                   P3RX_LAYOUT_LINEAR, // dst,
                   pSource->lpGbl->lPitch,
                   pDest->lpGbl->lPitch,                   
                   DDSurf_