 where we are constructing a response.
        //

        if (OutputToken == NULL)
        {
            D_DebugLog((DEB_ERROR,"Trying to initialize a context with no output token! %ws, line %d\n", THIS_FILE, __LINE__));
            Status = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        if (UseNullSession)
        {
            Status = KerbBuildNullSessionApRequest(
                        &Request,
                        &RequestSize
                        );
        }
        else if (GetServerTgt)
        {
            D_DebugLog((DEB_TRACE, "Building TGT request for "));
            D_KerbPrintKdcName((DEB_TRACE, TargetInternalName));

            if (((ContextRequirements & ISC_REQ_MUTUAL_AUTH) != 0) &&
                (!ARGUMENT_PRESENT(TargetName) || TargetName->Length == 0))
            {
                D_DebugLog((DEB_ERROR, "Client wanted mutual auth, but did not supply target name\n"));
                Status = SEC_E_UNSUPPORTED_FUNCTION;
                goto Cleanup;
            }

            Status = KerbBuildTgtRequest(
                            TargetInternalName,
                            &TargetDomainName,
                            &ContextAttribs,
                            &Request,
                            &RequestSize
                            );

            D_DebugLog((DEB_TRACE_U2U, "SpInitLsaModeContext built TGT request %#x\n", Status));

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        else
        {
            D_DebugLog((DEB_TRACE_CTXT2,"Building AP request for connection oriented context\n"));

            Status = KerbBuildApRequest(
                        LogonSession,
                        Credential,
                        CredManCredentials,
                        TicketCacheEntry,
                        ErrorMessage,
                        ContextAttribs,
                        &ContextFlags,
                        &Request,
                        &RequestSize,
                        &Nonce,
                        &AuthenticatorTime,
                        &SubSessionKey,
                        pChannelBindings
                        );
            //
            // Set the receive nonce to be the nonce, as the code below
            // expects it to be valid.
            //

            ReceiveNonce = Nonce;
        }

        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to build AP request: 0x%x\n. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        if (OutputToken == NULL)
        {
            Status = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        //
        // Return the AP request in the output buffer.
        //

        if ((ContextRequirements & ISC_REQ_ALLOCATE_MEMORY) == 0)
        {
            if (OutputToken->cbBuffer < RequestSize)
            {
                ULONG ErrorData[3];

                ErrorData[0] = RequestSize;
                ErrorData[1] = OutputToken->cbBuffer;
                ErrorData[2] = ClientProcess;


                D_DebugLog((DEB_ERROR,"Output token is too small - sent in %d, needed %d. %ws, line %d\n",
                    OutputToken->cbBuffer,RequestSize, THIS_FILE, __LINE__ ));
                OutputToken->cbBuffer = RequestSize;
                Status = STATUS_BUFFER_TOO_SMALL;

                KerbReportNtstatus(
                    KERBEVT_INSUFFICIENT_TOKEN_SIZE,
                    Status,
                    NULL,
                    0,
                    ErrorData,
                    3
                    );

                goto Cleanup;

            }
            RtlCopyMemory(
                OutputToken->pvBuffer,
                Request,
                RequestSize
                );
        }
        else
        {
            OutputToken->pvBuffer = Request;
            if (OutputToken->pvBuffer == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            *ContextAttributes |= ISC_RET_ALLOCATED_MEMORY;

            //
            // Set this to NULL so it won't be freed by us on cleanup.
            //

            Request = NULL;
        }

        OutputToken->cbBuffer = RequestSize;
    }
    else
    {
        //
        // All we do here is allocate a nonce for use in the context.
        //

        Nonce = KerbAllocateNonce();
        if (OutputToken != NULL)
        {
            OutputToken->cbBuffer = 0;
        }
    }

    //////////////////////////////////////////////////////////////////////
    //
    // If we haven't yet created a context, created one now. If we have,
    // update the context with the latest status.
    //
    /////////////////////////////////////////////////////////////////////

    //
    // Allocate a client context, if we don't already have one
    //

    if (Context == NULL)
    {
        Status = KerbCreateClientContext(
                    LogonSession,
                    Credential,
                    CredManCredentials,
                    TicketCacheEntry,
                    TargetName,
                    Nonce,
                    &AuthenticatorTime,
                    ContextFlags,
                    ContextAttribs,
                    &SubSessionKey,
                    &Context,
                    &ContextLifetime
                    );

        //CredManCredentials = NULL;
    }
    else
    {
        Status = KerbUpdateClientContext(
                    Context,
                    TicketCacheEntry,
                    Nonce,
                    &AuthenticatorTime,
                    ReceiveNonce,
                    ContextFlags,
                    ContextAttribs,
                    &SubSessionKey,
                    &ContextLifetime
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to create client context: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Keep track of network service session keys to detect whether network
    // logon session is for local network service
    //

    if (RtlEqualLuid(&LogonId, &LocalSystemLuid))
    {
        FILETIME CurTime = {0};
        GetSystemTimeAsFileTime(&CurTime);

        //
        // use 2 times KerbGlobalSkewTime as ticket life time
        //

        KerbGetTime(*((TimeStamp*) &CurTime)) += 2 * KerbGetTime(KerbGlobalSkewTime);

        Status = KerbCreateSKeyEntry(&SubSessionKey, &CurTime);
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to create session key entry: 0x%x. %ws, line %d\n",
                Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }
    }

    //
    // Hold on to the ticket for later use
    //

    KerbWriteLockContexts();
    if ((Context->TicketCacheEntry == NULL) && (TicketCacheEntry != NULL))
    {
        KerbReferenceTicketCacheEntry(TicketCacheEntry);
        Context->TicketCacheEntry = TicketCacheEntry;
    }
    ClientProcess = Context->ClientProcess;
    KerbUnlockContexts();

    //
    // update the context with the marshalled target info.
    //

    if( NT_SUCCESS(Status) && pbMarshalledTargetInfo )
    {
        if( Context->pbMarshalledTargetInfo == NULL )
        {
            Context->pbMarshalledTargetInfo = pbMarshalledTargetInfo;
            Context->cbMarshalledTargetInfo = cbMarshalledTargetInfo;
            pbMarshalledTargetInfo = NULL;
        }
    }

    //
    // Return the correct flags
    //

    *NewContextHandle = KerbGetContextHandle(Context);

    *ContextAttributes |= ContextFlags;

    KerbUtcTimeToLocalTime(
        ExpirationTime,
        &ContextLifetime
        );

    //
    // If mutual authentication was requested, ask for a continuation
    //

    if (((ContextFlags & ( ISC_RET_USED_DCE_STYLE |
                          ISC_RET_DATAGRAM |
                          ISC_RET_MUTUAL_AUTH )) != 0) ||
         GetServerTgt )
    {
        Status = SEC_I_CONTINUE_NEEDED;
    }

Cleanup:

    // Adjust for the new meaning of delegate/delegate-if-safe if they got munged somehow.

    if (ClientAskedForDelegateIfSafe && (*ContextAttributes & ISC_RET_DELEGATE))
    {
        (*ContextAttributes) &= ~ISC_RET_DELEGATE;
        (*ContextAttributes) |= ISC_RET_DELEGATE_IF_SAFE;
    }
    else if ((ClientAskedForDelegate) && (*ContextAttributes & ISC_RET_DELEGATE_IF_SAFE))
    {
        (*ContextAttributes) &= ~ISC_RET_DELEGATE_IF_SAFE;
        (*ContextAttributes) |= ISC_RET_DELEGATE;
    }

    if ( Status == STATUS_WRONG_PASSWORD )
    {
        //
        // don't leak WRONG_PASSWORD to the caller.
        //

        Status = STATUS_LOGON_FAILURE;
    }

    if( KerbEventTraceFlag ) // Event Trace: KerbInitSecurityContextEnd {Status, CredSource, DomainName, UserName, Target, (ExtErr), (Klininfo)}
    {
        PCWSTR TraceStrings[] =
            {
            L"CredMan",
            L"Supplied",
            L"Context",
            L"LogonSession",
            L"None"
        };
        enum { TSTR_CREDMAN = 0, TSTR_SUPPLIED, TSTR_CONTEXT, TSTR_LOGONSESSION, TSTR_NONE };
        UNICODE_STRING UNICODE_NONE = { 4*sizeof(WCHAR), 4*sizeof(WCHAR), L"NONE" };

        UNICODE_STRING CredSource;
        PUNICODE_STRING trace_DomainName, trace_UserName, trace_target;

        trace_target = (Context != NULL) ? &Context->ServerPrincipalName : &UNICODE_NONE;

        if( Context != NULL && Context->CredManCredentials != NULL )
        {
            RtlInitUnicodeString( &CredSource, TraceStrings[TSTR_CREDMAN] );
            trace_DomainName = &Context->CredManCredentials->SuppliedCredentials->DomainName;
            trace_UserName   = &Context->CredManCredentials->SuppliedCredentials->UserName;
        }
        else if( Credential != NULL && Credential->SuppliedCredentials != NULL )
        {
            RtlInitUnicodeString( &CredSource, TraceStrings[TSTR_SUPPLIED] );
            trace_DomainName = &Credential->SuppliedCredentials->DomainName;
            trace_UserName   = &Credential->SuppliedCredentials->UserName;
        }
        else if( Context != NULL )
        {
            RtlInitUnicodeString( &CredSource, TraceStrings[TSTR_CONTEXT] );
            trace_DomainName = &Context->ClientRealm;
            trace_UserName   = &Context->ClientName;
        }
        else if( LogonSession != NULL )
        {
            RtlInitUnicodeString( &CredSource, TraceStrings[TSTR_LOGONSESSION] );
            trace_DomainName = &LogonSession->PrimaryCredentials.DomainName;
            trace_UserName   = &LogonSession->PrimaryCredentials.UserName;
        }
            else
        {
            RtlInitUnicodeString( &CredSource, TraceStrings[TSTR_NONE] );
            trace_DomainName = &UNICODE_NONE;
            trace_UserName   = &UNICODE_NONE;
        }

        INSERT_ULONG_INTO_MOF(           Status,           InitSCTraceInfo.MofData, 0 );
        INSERT_UNICODE_STRING_INTO_MOF(  CredSource,       InitSCTraceInfo.MofData, 1 );
        INSERT_UNICODE_STRING_INTO_MOF( *trace_DomainName, InitSCTraceInfo.MofData, 3 );
        INSERT_UNICODE_STRING_INTO_MOF( *trace_UserName,   InitSCTraceInfo.MofData, 5 );
        INSERT_UNICODE_STRING_INTO_MOF( *trace_target,     InitSCTraceInfo.MofData, 7 );
        InitSCTraceInfo.EventTrace.Size = sizeof(EVENT_TRACE_HEADER) + 9*sizeof(MOF_FIELD);

        //Check for extended error
        if( pExtendedError != NULL )
        {
            INSERT_ULONG_INTO_MOF( pExtendedError->status,   InitSCTraceInfo.MofData, 9 );
            INSERT_ULONG_INTO_MOF( pExtendedError->klininfo, InitSCTraceInfo.MofData, 10 );
            InitSCTraceInfo.EventTrace.Size += 2*sizeof(MOF_FIELD);
        }

        // Set trace parameters
        InitSCTraceInfo.EventTrace.Guid       = KerbInitSCGuid;
        InitSCTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_END;
        InitSCTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;

        TraceEvent(
            KerbTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&InitSCTraceInfo
        );
    }

    //
    // If we allocated a context, unlink it now
    //

    if (Context != NULL)
    {
        if (!NT_SUCCESS(Status))
        {
            //
            // Only unlink the context if we just created it
            //

            if (ContextHandle == 0)
            {
                KerbReferenceContextByPointer(
                    Context,
                    TRUE
                    );
                KerbDereferenceContext(Context);
            }
            else
            {
                //
                // Set the context to an invalid state.
                //

                KerbWriteLockContexts();
                Context->ContextState = InvalidState;
                KerbUnlockContexts();
            }
        }
        else
        {
            KerbWriteLockContexts();
            if (Status == STATUS_SUCCESS)
            {
                Context->ContextState = AuthenticatedState;
            }
            else if (!GetServerTgt)
            {
                Context->ContextState = ApRequestSentState;
            }
            else
            {
                Context->ContextState = TgtRequestSentState;

                //
                // mark the context as user2user
                //

                Context->ContextAttributes |= KERB_CONTEXT_USER_TO_USER;
                DebugLog((DEB_TRACE_U2U, "SpInitLsaModeContext (TGT in TGT reply) USER2USER-OUTBOUND set\n"));
            }
            KerbUnlockContexts();
        }
        KerbDereferenceContext(Context);
    }

    if ((Status == STATUS_SUCCESS) ||
        ((Status == SEC_I_CONTINUE_NEEDED) && ((ContextFlags & ISC_RET_DATAGRAM) != 0)))
    {
        NTSTATUS TempStatus;

        //
        // On real success we map the context to the callers address
        // space.
        //

        TempStatus = KerbMapContext(
                        Context,
                        MappedContext,
                        ContextData
                        );

        D_DebugLog((DEB_TRACE, "SpInitLsaModeContext called KerbMapContext ContextAttributes %#x, %#x\n", Context->ContextAttributes, TempStatus));

        if (!NT_SUCCESS(TempStatus))
        {
            Status = TempStatus;
        }

        //
        // Update the skew time with a success
        //

        KerbUpdateSkewTime(FALSE);
    }

    if (NULL != CredManCredentials)
    {
        KerbDereferenceCredmanCred(
            CredManCredentials,
            &LogonSession->CredmanCredentials
            );
    }

    if( pbMarshalledTargetInfo )
    {
        LocalFree( pbMarshalledTargetInfo );
    }

    if (TgtReply != NULL)
    {
        KerbFreeData(KERB_TGT_REPLY_PDU, TgtReply);
    }

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession( LogonSession );
    }

    if (Credential != NULL)
    {
        KerbDereferenceCredential( Credential );
    }

    if (TicketCacheEntry != NULL)
    {
        KerbDereferenceTicketCacheEntry( TicketCacheEntry );
    }

    if ( SpnCacheEntry != NULL ) 
    {
        KerbDereferenceSpnCacheEntry( SpnCacheEntry );
    }

    KerbFreeKerbError( ErrorMessage );
    if (NULL != pExtendedError)
    {
       KerbFree(pExtendedError);
    }

    if (ErrorData != NULL)
    {
       MIDL_user_free(ErrorData);
    }
    if (Request != NULL)
    {
        KerbFree(Request);
    }
    if (Reply != NULL)
    {
        KerbFree(Reply);
    }

    KerbFreeKey(&SubSessionKey);

    KerbFreeString( &TargetDomainName );
    KerbFreeKdcName( &TargetInternalName );

    D_DebugLog((DEB_TRACE_LEAKS, "SpInitLsaModeContext returned 0x%x, Context 0x%x, Pid 0x%x\n",KerbMapKerbNtStatusToNtStatus(Status), *NewContextHandle, ClientProcess));
    D_DebugLog((DEB_TRACE_API, "SpInitLsaModeContext returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}


NTSTATUS NTAPI
SpApplyControlToken(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc ControlToken
    )
{
    NTSTATUS Status = STATUS_NOT_SUPPORTED;
    D_DebugLog((DEB_TRACE_API,"SpApplyControlToken Called\n"));
    D_DebugLog((DEB_TRACE_API,"SpApplyControlToken returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));
    return(KerbMapKerbNtStatusToNtStatus(Status));
}


#ifndef WIN32_CHICAGO //we don't do server side stuff
//+-------------------------------------------------------------------------
//
//  Function:   SpAcceptLsaModeContext
//
//  Synopsis:   Kerberos support routine for AcceptSecurityContext call.
//              This routine accepts an AP request message from a client
//              and verifies that it is a valid ticket. If mutual
//              authentication is desired an AP reply is generated to
//              send back to the client.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
SpAcceptLsaModeContext(
    IN OPTIONAL LSA_SEC_HANDLE CredentialHandle,
    IN OPTIONAL LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc InputBuffers,
    IN ULONG ContextRequirements,
    IN ULONG TargetDataRep,
    OUT PLSA_SEC_HANDLE NewContextHandle,
    OUT PSecBufferDesc OutputBuffers,
    OUT PULONG ContextAttributes,
    OUT PTimeStamp ExpirationTime,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData
    )
{
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_CREDENTIAL Credential = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS LastStatus = STATUS_SUCCESS;
    PKERB_AP_REQUEST Request = NULL;
    PUCHAR Reply = NULL;
    PSecBuffer InputToken = NULL;
    PSecBuffer OutputToken = NULL;
    ULONG Index;
    ULONG ReplySize;
    LUID LogonId;
    PKERB_ENCRYPTED_TICKET InternalTicket = NULL;
    PKERB_AUTHENTICATOR InternalAuthenticator = NULL;
    KERB_ENCRYPTION_KEY SessionKey;
    KERB_ENCRYPTION_KEY TicketKey;
    KERB_ENCRYPTION_KEY ServerKey;
    PKERB_CONTEXT Context = NULL;
    TimeStamp ContextLifetime;
    HANDLE TokenHandle = 0;
    ULONG ContextFlags = 0;
    ULONG ContextAttribs = KERB_CONTEXT_INBOUND;
    ULONG NegotiationInfo = SECPKG_NEGOTIATION_COMPLETE;
    ULONG Nonce = 0;
    ULONG ReceiveNonce = 0;
    BOOLEAN UseSuppliedCreds = FALSE;
    ULONG_PTR LocalCredentialHandle = 0;
    PSID UserSid = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_CONTEXT_STATE ContextState = InvalidState;
    UNICODE_STRING ServiceDomain = {0};
    UNICODE_STRING ClientName = {0};
    UNICODE_STRING ClientDomain = {0};
    UNICODE_STRING ClientNetbiosDomain = {0};
    UNICODE_STRING WorkstationName = {0};
    BOOLEAN IsTgtRequest = FALSE;
    ULONG ClientProcess = 0;
    PSEC_CHANNEL_BINDINGS pChannelBindings = NULL;
    PS4U_DELEGATION_INFO S4UDelegationInfo = NULL;
    PLSA_ADT_STRING_LIST TransittedServices = NULL;

    KERB_ACCEPTSC_INFO AcceptSCTraceInfo;

    D_DebugLog((DEB_TRACE_API, "SpAcceptLsaModeContext 0x%x called\n", ContextHandle));

    if ( KerbEventTraceFlag ) // Event Trace: KerbAcceptSecurityContextStart {No Data}
    {
        AcceptSCTraceInfo.EventTrace.Guid       = KerbAcceptSCGuid;
        AcceptSCTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_START;
        AcceptSCTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID;
        AcceptSCTraceInfo.EventTrace.Size       = sizeof (EVENT_TRACE_HEADER);

        TraceEvent(
            KerbTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&AcceptSCTraceInfo
            );
    }

    //
    // Initialize the outputs.
    //

    *ContextAttributes = 0;
    *NewContextHandle = 0;
    *ExpirationTime = KerbGlobalHasNeverTime;
    *MappedContext = FALSE;
    ContextData->pvBuffer = NULL;
    ContextData->cbBuffer = 0;

    RtlZeroMemory(
        &SessionKey,
        sizeof(KERB_ENCRYPTION_KEY)
        );
    TicketKey = SessionKey;
    ServerKey = TicketKey;

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_INVALID_SERVER_STATE;
        goto Cleanup;
    }

    //
    // First locate the Input token.
    //

    for (Index = 0; Index < InputBuffers->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(InputBuffers->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            InputToken = &InputBuffers->pBuffers[Index];
            Status = LsaFunctions->MapBuffer(InputToken,InputToken);
            break;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to map Input token: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Check to see if we were passed channel bindings
    //

    for ( Index = 0; Index < InputBuffers->cBuffers; Index++ )
    {
        if( BUFFERTYPE(InputBuffers->pBuffers[Index]) == SECBUFFER_CHANNEL_BINDINGS )
        {
            Status = LsaFunctions->MapBuffer(
                &InputBuffers->pBuffers[Index],
                &InputBuffers->pBuffers[Index]
                );

            if( !NT_SUCCESS(Status) )
            {
                goto Cleanup;
            }

            pChannelBindings = (PSEC_CHANNEL_BINDINGS) InputBuffers->pBuffers[Index].pvBuffer;

            Status = KerbValidateChannelBindings(pChannelBindings,
                                                 InputBuffers->pBuffers[Index].cbBuffer);

            if (!NT_SUCCESS(Status))
            {
                pChannelBindings = NULL;
                goto Cleanup;
            }

            break;
        }
    }

    //
    // Locate the output token
    //

    for (Index = 0; Index < OutputBuffers->cBuffers ; Index++ )
    {
        if (BUFFERTYPE(OutputBuffers->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            OutputToken = &OutputBuffers->pBuffers[Index];
            Status = LsaFunctions->MapBuffer(OutputToken,OutputToken);
            break;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to map output token: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // If the context handle is no NULL we are finalizing a context
    //

    if (ContextHandle != 0)
    {
        if (InputToken == NULL)
        {
            D_DebugLog((DEB_ERROR,"Trying to complete a context with no input token! %ws, line %d\n", THIS_FILE, __LINE__));
            Status = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        //
        // First reference the context.
        //

        Status = KerbReferenceContext(
                    ContextHandle,
                    FALSE,       // don't unlink
                    &Context
                    );
        if (Context == NULL)
        {
            D_DebugLog((DEB_ERROR,"Failed to reference context 0x%x. %ws, line %d\n",ContextHandle, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        //
        // Check the mode of the context to make sure we can finalize it.
        //

        KerbReadLockContexts();

        ContextState = Context->ContextState;
        if (((ContextState != ApReplySentState) &&
             (ContextState != TgtReplySentState) &&
             (ContextState != ErrorMessageSentState)) ||
            ((Context->ContextAttributes & KERB_CONTEXT_INBOUND) == 0))
        {
            D_DebugLog((DEB_ERROR,"Invalid context state: %d. %ws, line %d\n",
                Context->ContextState, THIS_FILE, __LINE__));
            Status = STATUS_INVALID_HANDLE;
            KerbUnlockContexts();
            goto Cleanup;
        }

        if ((Context->ContextAttributes & KERB_CONTEXT_USED_SUPPLIED_CREDS) != 0)
        {
            UseSuppliedCreds = TRUE;
        }

        ContextFlags = Context->ContextFlags;
        LogonId = Context->LogonId;
        LocalCredentialHandle = Context->CredentialHandle;
        ClientProcess = Context->ClientProcess;
        KerbUnlockContexts();
    }

    if (CredentialHandle != 0)
    {
        if ((LocalCredentialHandle != 0) && (CredentialHandle != LocalCredentialHandle))
        {
            D_DebugLog((DEB_ERROR,"Different cred handle passsed to subsequent call to AcceptSecurityContext: 0x%x instead of 0x%x. %ws, line %d\n",
                CredentialHandle, LocalCredentialHandle, THIS_FILE, __LINE__ ));
            Status = STATUS_WRONG_CREDENTIAL_HANDLE;
            goto Cleanup;
        }
    }
    else
    {
        CredentialHandle = LocalCredentialHandle;
    }
    //
    // If we are finalizing a context, do that here
    //

    if (ContextState == ApReplySentState)
    {
        //
        // If we are doing datgram, then the finalize is actually an AP request
        //

        if ((ContextFlags & ISC_RET_DATAGRAM) != 0)
        {
            //
            // Get the logon session
            //

            LogonSession = KerbReferenceLogonSession( &LogonId, FALSE );
            if (LogonSession == NULL)
            {
                Status = STATUS_NO_SUCH_LOGON_SESSION;
                goto Cleanup;
            }

            //
            // If we are using supplied creds, get the credentials. Copy
            // out the domain name so we can use it to verify the PAC.
            //

            Status = KerbReferenceCredential(
                            LocalCredentialHandle,
                            KERB_CRED_INBOUND,
                            FALSE,                   // don't dereference
                            &Credential
                            );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            if (UseSuppliedCreds)
            {
                KerbReadLockLogonSessions(LogonSession);
                Status = KerbDuplicateString(
                            &ServiceDomain,
                            &Credential->SuppliedCredentials->DomainName
                            );
                KerbUnlockLogonSessions(LogonSession);
            }
            else
            {
                KerbReadLockLogonSessions(LogonSession);
                Status = KerbDuplicateString(
                            &ServiceDomain,
                            &LogonSession->PrimaryCredentials.DomainName
                            );
                KerbUnlockLogonSessions(LogonSession);
            }
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            //
            // Verify the AP request
            //

            Status = KerbVerifyApRequest(
                        Context,
                        (PUCHAR) InputToken->pvBuffer,
                        InputToken->cbBuffer,
                        LogonSession,
                        Credential,
                        UseSuppliedCreds,
                        ((ContextRequirements & ASC_REQ_ALLOW_CONTEXT_REPLAY) == 0),
                        &Request,
                        &InternalTicket,
                        &InternalAuthenticator,
                        &SessionKey,
                        &TicketKey,
                        &ServerKey,
                        &ContextFlags,
                        &ContextAttribs,
                        &KerbErr,
                        pChannelBindings
                        );

            //
            // We don't allow user-to-user recovery with datagram
            //

            if ((Status == STATUS_REPARSE_OBJECT) // this is a TGT request
                || ((Status == SEC_E_NO_CREDENTIALS) && (KerbErr == KRB_AP_ERR_USER_TO_USER_REQUIRED)))
            {
                DebugLog((DEB_ERROR, "Won't allow user2user with Datagram. %ws, line %d\n", THIS_FILE, __LINE__));
                Status = SEC_E_INVALID_TOKEN;
                KerbErr = KRB_AP_ERR_MSG_TYPE;
                goto ErrorReturn;
            }

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "Failed to verify AP request: 0x%x. %ws, line %d\n", Status, THIS_FILE, __LINE__));

                //
                // Let the skew tracker know about the failure
                //

                if (KerbErr == KRB_AP_ERR_SKEW)
                {
                    KerbUpdateSkewTime(TRUE);
                }

                //
                // Go to ErrorReturn so we can return an error message
                //

                goto ErrorReturn;
            }

            //
            // Turn on the flag if it was called for
            //

            if ((ContextRequirements & ASC_REQ_ALLOW_CONTEXT_REPLAY) != 0)
            {
                ContextFlags |= ASC_RET_ALLOW_CONTEXT_REPLAY;
            }

            //
            // Record the success
            //

            KerbUpdateSkewTime(FALSE);

            //
            // Check if the caller wants to allow null sessions
            //

            if (((ContextFlags & ISC_RET_NULL_SESSION) != 0) &&
                ((ContextRequirements & ASC_REQ_ALLOW_NULL_SESSION) == 0))
            {
                D_DebugLog((DEB_ERROR,"Received null session but not allowed. %ws, line %d\n", THIS_FILE, __LINE__));
                Status = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }

            //
            // Save away the ReceiveNonce if it was provided
            //

            if ((InternalAuthenticator!= NULL) &&
                ((InternalAuthenticator->bit_mask & KERB_AUTHENTICATOR_sequence_number_present) != 0))
            {

                //
                // If the number is unsigned, convert it as unsigned. Otherwise
                // convert as signed.
                //

                if (ASN1intxisuint32(&InternalAuthenticator->KERB_AUTHENTICATOR_sequence_number))
                {
                    ReceiveNonce = ASN1intx2uint32(&InternalAuthenticator->KERB_AUTHENTICATOR_sequence_number);
                }
                else
                {
                    ReceiveNonce = (ULONG) ASN1intx2int32(&InternalAuthenticator->KERB_AUTHENTICATOR_sequence_number);
                }
            }
            else
            {
                ReceiveNonce = 0;
            }

            //
            // Authentication succeeded, so build a token
            //

#ifdef DBG
            InterlockedIncrement(&Token);  // make sure we audit all token creation.
#endif

            Status = KerbCreateTokenFromTicket(
                        &LogonId, 
                        Request,
                        InternalTicket,
                        InternalAuthenticator,
                        ContextFlags,
                        &ServerKey,
                        &ServiceDomain,
                        &SessionKey,
                        &LogonId,
                        &UserSid,
                        &TokenHandle,
                        &ClientName,
                        &ClientDomain,
                        &ClientNetbiosDomain,
                        &S4UDelegationInfo
                        );

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"Failed to create token from ticket: 0x%x. %ws, line %d\n",
                    Status, THIS_FILE, __LINE__));
                goto Cleanup;
            }

            Status = KerbUpdateServerContext(
                        Context,
                        InternalTicket,
                        Request,
                        &SessionKey,
                        &LogonId,
                        &UserSid,
                        ContextFlags,
                        ContextAttribs,
                        NegotiationInfo,
                        Nonce,
                        ReceiveNonce,
                        &TokenHandle,
                        &ClientName,
                        &ClientDomain,
                        &ClientNetbiosDomain,
                        &ContextLifetime
                        );

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"Failed to create server context: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
                goto Cleanup;
            }
        }
        else
        {
            //
            // Now unpack the AP reply
            //
            Status = KerbVerifyApReply(
                        Context,
                        (PUCHAR) InputToken->pvBuffer,
                        InputToken->cbBuffer,
                        &Nonce
                        );
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"Failed to verify AP reply: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
                goto Cleanup;
            }

            //
            // We're done - we finalized.
            //

            Status = STATUS_SUCCESS;

            if (OutputToken != NULL)
            {
                OutputToken->cbBuffer = 0;
            }
        }

        KerbReadLockContexts();
        *ContextAttributes = KerbMapContextFlags(Context->ContextFlags);

        KerbUtcTimeToLocalTime(
            ExpirationTime,
            &Context->Lifetime
        );

        if (OutputToken != NULL)
        {
            OutputToken->cbBuffer = 0;
        }

        *NewContextHandle = ContextHandle;
        KerbUnlockContexts();

        goto Cleanup;  // datagram and finalized contexts exit here.
    }

    //
    // Get the associated credential
    //

    Status = KerbReferenceCredential(
                    CredentialHandle,
                    KERB_CRED_INBOUND,
                    FALSE,
                    &Credential
                    );

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_WARN,"Failed to locate credential 0x%x\n",Status));
        goto Cleanup;
    }

    //
    // Get the logon id from the credentials so we can locate the
    // logon session.
    //

    LogonId = Credential->LogonId;

    //
    // Get the logon session
    //

    LogonSession = KerbReferenceLogonSession( &LogonId, FALSE );
    if (LogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    KerbReadLockLogonSessions(LogonSession);
    if ((Credential->CredentialFlags & KERB_CRED_LOCAL_ACCOUNT) != 0)
    {
        D_DebugLog((DEB_WARN, "Trying to use a local logon session with Kerberos\n"));
        KerbUnlockLogonSessions(LogonSession);
        Status = SEC_E_NO_CREDENTIALS;
        goto Cleanup;
    }

    if (Credential->SuppliedCredentials != NULL)
    {
        UseSuppliedCreds = TRUE;
        ContextAttribs |= KERB_CONTEXT_USED_SUPPLIED_CREDS;
        Status = KerbDuplicateString(
                    &ServiceDomain,
                    &Credential->SuppliedCredentials->DomainName
                    );

    }
    else
    {
        Status = KerbDuplicateString(
                    &ServiceDomain,
                    &LogonSession->PrimaryCredentials.DomainName
                    );
    }

#if DBG
    D_DebugLog((DEB_TRACE_CTXT, "SpAcceptLsaModeContext: Accepting context for %wZ\\%wZ\n",
        &LogonSession->PrimaryCredentials.DomainName,
        &LogonSession->PrimaryCredentials.UserName ));
#endif
    KerbUnlockLogonSessions(LogonSession);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If datagram was requested, note it now. There is no input
    // buffer on the first call using datagram.
    //

    if ((ContextRequirements & ASC_REQ_DATAGRAM) != 0)
    {
        D_DebugLog((DEB_TRACE_CTXT2, "Accepting datagram first call\n"));

        //
        // Verify that there is no input token or it is small. RPC passes
        // in two bytes for the DEC package that we can ignore.
        //

        if ((InputToken != NULL) &&
            (InputToken->cbBuffer > 4))
        {
            D_DebugLog((DEB_WARN, "Non null input token passed to AcceptSecurityContext for datagram\n"));
            Status = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        ContextFlags |= ISC_RET_DATAGRAM;
        ReceiveNonce = 0;

        //
        // Build a server context
        //

        Status = KerbCreateEmptyContext(
                    Credential,
                    ContextFlags,
                    ContextAttribs,
                    NegotiationInfo,
                    &LogonId,
                    &Context,
                    &ContextLifetime
                    );

        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to create server context: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        if (OutputToken != NULL)
        {
            OutputToken->cbBuffer = 0;
        }
    }
    else
    {
        D_DebugLog((DEB_TRACE_CTXT2, "Accepting connection first call\n"));

        //
        // Unmarshall the AP request
        //

        if ((InputToken == NULL) ||
            (InputToken->cbBuffer == 0))
        {
            D_DebugLog((DEB_WARN, "Null input token passed to AcceptSecurityContext for datagram\n"));
            Status = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }

        //
        // Verify the AP request
        //

        Status = KerbVerifyApRequest(
                    Context,
                    (PUCHAR) InputToken->pvBuffer,
                    InputToken->cbBuffer,
                    LogonSession,
                    Credential,
                    UseSuppliedCreds,
                    ((ContextRequirements & ASC_REQ_ALLOW_CONTEXT_REPLAY) == 0),
                    &Request,
                    &InternalTicket,
                    &InternalAuthenticator,
                    &SessionKey,
                    &TicketKey,
                    &ServerKey,
                    &ContextFlags,
                    &ContextAttribs,
                    &KerbErr,
                    pChannelBindings
                    );

        if (!NT_SUCCESS(Status))
        {
            //
            // Track time skew errors
            //

            if ((KerbErr == KRB_AP_ERR_SKEW) ||
                (KerbErr == KRB_AP_ERR_TKT_NYV))
            {
                KerbUpdateSkewTime(TRUE);
            }

            DebugLog((DEB_WARN, "Failed to verify AP request (need u2u? %s): %#x. %ws, line %d\n",
                KerbErr == KRB_AP_ERR_USER_TO_USER_REQUIRED ? "true" : "false",
                Status, THIS_FILE, __LINE__));

            goto ErrorReturn;
        }

        ContextFlags |= ISC_RET_CONNECTION;

        //
        // Check if this was a user-to-user tgt request. If so, then
        // there was no AP request
        //

        if (Status == STATUS_REPARSE_OBJECT)
        {
            IsTgtRequest = TRUE;

            Status = KerbHandleTgtRequest(
                        LogonSession,
                        Credential,
                        UseSuppliedCreds,
                        (PUCHAR) InputToken->pvBuffer,
                        InputToken->cbBuffer,
                        ContextRequirements,
                        OutputToken,
                        &LogonId,
                        ContextAttributes,
                        &Context,
                        &ContextLifetime,
                        &KerbErr
                        );

            if (!NT_SUCCESS(Status))
            {
                goto ErrorReturn;
            }

            ContextFlags |= ISC_RET_USE_SESSION_KEY;

            D_DebugLog((DEB_TRACE_U2U, "SpAcceptLsaModeContext handled TGT request and use_session_key set, ContextAttributes %#x\n", Context->ContextAttributes));
        }
        else // not a user-to-user request
        {
            //
            // Track successful time if this wasn't an error recovery
            //

            if (ContextState != ErrorMessageSentState)
            {
                KerbUpdateSkewTime(FALSE);
            }
            if ((InternalAuthenticator != NULL) &&
                (InternalAuthenticator->bit_mask & KERB_AUTHENTICATOR_sequence_number_present))
            {
                //
                // If the number is unsigned, convert it as unsigned. Otherwise
                // convert as signed.
                //

                if (ASN1intxisuint32(&InternalAuthenticator->KERB_AUTHENTICATOR_sequence_number))
                {
                    ReceiveNonce = ASN1intx2uint32(&InternalAuthenticator->KERB_AUTHENTICATOR_sequence_number);
                }
                else
                {
                    ReceiveNonce = (ULONG) ASN1intx2int32(&InternalAuthenticator->KERB_AUTHENTICATOR_sequence_number);
                }
            }
            else
            {
                ReceiveNonce = 0;
            }

            //
            // Initialize the opposite direction nonce to the same value
            //

            Nonce = ReceiveNonce;

            //
            // Turn on the flag if it was called for
            //

            if ((ContextRequirements & ASC_REQ_ALLOW_CONTEXT_REPLAY) != 0)
            {
                ContextFlags |= ASC_RET_ALLOW_CONTEXT_REPLAY;
            }

            //
            // Check if the caller wants to allow null sessions
            //

            if (((ContextFlags & ISC_RET_NULL_SESSION) != 0) &&
                ((ContextRequirements & ASC_REQ_ALLOW_NULL_SESSION) == 0))
            {
                D_DebugLog((DEB_ERROR,"Received null session but not allowed. %ws, line %d\n", THIS_FILE, __LINE__));
                Status = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }

            //
            // Authentication succeeded, so build a token
            //
            D_DebugLog((DEB_TRACE_CTXT2, "AcceptLsaModeContext: Creating token from ticket\n"));
#ifdef DBG
            InterlockedIncrement(&Token); // make sure we audit all token creation
#endif

            Status = KerbCreateTokenFromTicket(
                        &LogonId, 
                        Request,
                        InternalTicket,
                        InternalAuthenticator,
                        ContextFlags,
                        &ServerKey,
                        &ServiceDomain,
                        &SessionKey,
                        &LogonId,
                        &UserSid,
                        &TokenHandle,
                        &ClientName,
                        &ClientDomain,
                        &ClientNetbiosDomain,
                        &S4UDelegationInfo
                        );

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"Failed to create token from ticket: 0x%x. %ws, line %d\n",
                    Status, THIS_FILE, __LINE__));
                goto Cleanup;
            }

            //
            // If the caller wants mutual authentication, build an AP reply
            //

            if (((ContextFlags & ISC_RET_MUTUAL_AUTH) != 0) ||
                ((ContextFlags & ISC_RET_USED_DCE_STYLE) != 0))
            {
                //
                // We require an output token in this case.
                //

                if (OutputToken == NULL)
                {
                    Status = SEC_E_INVALID_TOKEN;
                    DebugLog((DEB_ERROR,"SpAcceptLsaModeContext encountered null output token\n"));
                    goto Cleanup;
                }

                //
                // Build the reply message
                //

                D_DebugLog((DEB_TRACE_CTXT2,"SpAcceptLsaModeContext: Building AP reply\n"));
                Status = KerbBuildApReply(
                            InternalAuthenticator,
                            Request,
                            ContextFlags,
                            ContextAttribs,
                            &TicketKey,
                            &SessionKey,
                            &Nonce,
                            &Reply,
                            &ReplySize
                            );

                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR,"Failed to build AP reply: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
                    goto Cleanup;
                }

                if (OutputToken == NULL)
                {
                    D_DebugLog((DEB_ERROR,"Output token missing. %ws, line %d\n", THIS_FILE, __LINE__));
                    Status  = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

                //
                // Return the AP reply in the output buffer.
                //

                if ((ContextRequirements & ISC_REQ_ALLOCATE_MEMORY) == 0)
                {
                    if (OutputToken->cbBuffer < ReplySize)
                    {
                        ULONG ErrorData[3];

                        ErrorData[0] = ReplySize;
                        ErrorData[1] = OutputToken->cbBuffer;
                        ErrorData[2] = ClientProcess;


                        D_DebugLog((DEB_ERROR,"Output token is too small - sent in %d, needed %d. %ws, line %d\n",
                            OutputToken->cbBuffer,ReplySize, THIS_FILE, __LINE__ ));
                        OutputToken->cbBuffer = ReplySize;
                        Status = STATUS_BUFFER_TOO_SMALL;

                        KerbReportNtstatus(
                            KERBEVT_INSUFFICIENT_TOKEN_SIZE,
                            Status,
                            NULL,
                            0,
                            ErrorData,
                            3
                            );

                        goto Cleanup;
                    }

                    RtlCopyMemory(
                        OutputToken->pvBuffer,
                        Reply,
                        ReplySize
                        );
                }
                else
                {
                    OutputToken->pvBuffer = Reply;
                    Reply = NULL;
                    *ContextAttributes |= ASC_RET_ALLOCATED_MEMORY;
                }

                OutputToken->cbBuffer = ReplySize;
            }
            else
            {
                if (OutputToken != NULL)
                {
                    OutputToken->cbBuffer = 0;
                }
            }

            //
            // Build a server context if we don't already have one.
            //

            //
            // Turn on the flag if it was called for
            //

            if ((ContextRequirements & ASC_REQ_ALLOW_CONTEXT_REPLAY) != 0)
            {
                ContextFlags |= ASC_RET_ALLOW_CONTEXT_REPLAY;
            }

            if (Context == NULL)
            {
                Status = KerbCreateServerContext(
                            LogonSession,
                            Credential,
                            InternalTicket,
                            Request,
                            &SessionKey,
                            &LogonId,
                            &UserSid,
                            ContextFlags,
                            ContextAttribs,
                            NegotiationInfo,
                            Nonce,
                            ReceiveNonce,
                            &TokenHandle,
                            &ClientName,
                            &ClientDomain,
                            &ClientNetbiosDomain,
                            &Context,
                            &ContextLifetime
                            );
            }
            else
            {
                //
                // Update an existing context
                //

                Status = KerbUpdateServerContext(
                            Context,
                            InternalTicket,
                            Request,
                            &SessionKey,
                            &LogonId,
                            &UserSid,
                            ContextFlags,
                            ContextAttribs,
                            NegotiationInfo,
                            Nonce,
                            ReceiveNonce,
                            &TokenHandle,
                            &ClientName,
                            &ClientDomain,
                            &ClientNetbiosDomain,
                            &ContextLifetime
                            );
            }

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"Failed to create or update server context: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
                goto Cleanup;
            }
        } // not a TGT request
    } // not datagram
    *NewContextHandle = KerbGetContextHandle(Context);
    KerbUtcTimeToLocalTime(
        ExpirationTime,
        &ContextLifetime
        );

#if DBG
    KerbReadLockContexts();
    ClientProcess = Context->ClientProcess;
    KerbUnlockContexts();
#endif // DBG

    *ContextAttributes |= KerbMapContextFlags(ContextFlags);

    if (IsTgtRequest || (((ContextFlags & ISC_RET_USED_DCE_STYLE) != 0) ||
        ((ContextFlags & ISC_RET_DATAGRAM) != 0)))
    {
        Status = SEC_I_CONTINUE_NEEDED;
    }

    goto Cleanup;

ErrorReturn:

    //
    // Generate a KERB_ERROR message if necessary, meaning that there was
    // an authentication failure.
    //

    if ((OutputToken != NULL ) &&
        (!KERB_SUCCESS(KerbErr) ||
         ((ContextRequirements & ASC_REQ_EXTENDED_ERROR) != 0) ||
         ((ContextFlags & ISC_RET_EXTENDED_ERROR) != 0)))
    {
        NTSTATUS TempStatus;
        PBYTE ErrorMessage = NULL;
        ULONG ErrorMessageSize;
        PBYTE ErrorData = NULL;
        ULONG ErrorDataSize = 0;


        //
        // Check whether it is an error we want the client to retry on.
        // For datagram, we can't handle this.
        //

        if (ContextRequirements & ASC_REQ_DATAGRAM)
        {
            goto Cleanup;
        }
        if (!(((ContextRequirements & ASC_REQ_EXTENDED_ERROR) != 0) ||
              (KerbErr == KRB_AP_ERR_USER_TO_USER_REQUIRED) ||
              (KerbErr == KRB_AP_ERR_SKEW) ||
              (KerbErr == KRB_AP_ERR_TKT_NYV) ||
              (KerbErr == KRB_AP_ERR_TKT_EXPIRED) ||
              (KerbErr == KRB_AP_ERR_MODIFIED) ))
        {
            goto Cleanup;
        }

        //
        // Create an empty context that can be used later
        //

        if (Context == NULL)
        {
            TempStatus = KerbCreateEmptyContext(
                            Credential,
                            ContextFlags,
                            ContextAttribs,
                            NegotiationInfo,
                            &LogonId,
                            &Context,
                            &ContextLifetime
                            );
            if (!NT_SUCCESS(TempStatus))
            {
                goto Cleanup;
            }
        }

        //
        // if the error code is one with error data, build the error data
        //

        switch ((UINT_PTR) KerbErr)
        {
        case (UINT_PTR) KRB_AP_ERR_USER_TO_USER_REQUIRED:
            NTSTATUS TempStatus;

            //
            // KerbBuildTgtErrorReply shall fail if neither TGTs nor longer secrets are available
            //

            TempStatus = KerbBuildTgtErrorReply(
                            LogonSession,
                            Credential,
                            UseSuppliedCreds,
                            Context,
                            &ErrorDataSize,
                            &ErrorData
                            );

            D_DebugLog((DEB_TRACE_U2U, "SpAcceptLsaModeContext called KerbBuildTgtErrorReply %#x\n", TempStatus));

            if (TempStatus == STATUS_USER2USER_REQUIRED)
            {
                KerbErr = KRB_AP_ERR_NO_TGT;
            }
            else if (!NT_SUCCESS(TempStatus))
            {
                D_DebugLog((DEB_ERROR, "Failed to build tgt error reply: 0x%x. Ignoring. %ws, line %d\n", TempStatus, THIS_FILE, __LINE__));
            }

            break;
        case (UINT_PTR) KDC_ERR_NONE:
            //
            // In this case, return the KRB_ERR_GENERIC and the NTSTATUS code
            // in the error data
            //
            KerbErr = KRB_ERR_GENERIC;
            ErrorData = (PUCHAR) &Status;
            ErrorDataSize = sizeof(ULONG);
            break;
        }

        TempStatus = KerbBuildGssErrorMessage(
                        KerbErr,
                        ErrorData,
                        ErrorDataSize,
                        Context,
                        &ErrorMessageSize,
                        &ErrorMessage
                        );

        if ((ErrorData != NULL) && (ErrorData != (PUCHAR) &Status))
        {
            MIDL_user_free(ErrorData);
        }

        if (!NT_SUCCESS(TempStatus))
        {
            goto Cleanup;
        }

        if ((ContextRequirements & ISC_REQ_ALLOCATE_MEMORY) == 0)
        {
            if (OutputToken->cbBuffer < ErrorMessageSize)
            {
                D_DebugLog((DEB_ERROR,"Output token is too small - sent in %d, needed %d. %ws, line %d\n",
                    OutputToken->cbBuffer,ErrorMessageSize, THIS_FILE, __LINE__ ));
                MIDL_user_free(ErrorMessage);
                goto Cleanup;
            }
            else
            {
                DsysAssert(OutputToken->pvBuffer != NULL);
                RtlCopyMemory(
                    OutputToken->pvBuffer,
                    ErrorMessage,
                    ErrorMessageSize
                    );
                OutputToken->cbBuffer = ErrorMessageSize;
                MIDL_user_free(ErrorMessage);
            }
        }
        else
        {
            DsysAssert(OutputToken->pvBuffer == NULL);
            OutputToken->cbBuffer = ErrorMessageSize;
            OutputToken->pvBuffer = ErrorMessage;
            ErrorMessage = NULL;
            *ContextAttributes |= ASC_RET_ALLOCATED_MEMORY;
        }
        *ContextAttributes |= ASC_RET_EXTENDED_ERROR;

        *NewContextHandle = KerbGetContextHandle(Context);
        KerbUtcTimeToLocalTime(
            ExpirationTime,
            &ContextLifetime
            );
        *ContextAttributes |= KerbMapContextFlags(ContextFlags);

        LastStatus = Status;

        //
        // now it is time to mark the context as user2user
        //

        if (KerbErr == KRB_AP_ERR_USER_TO_USER_REQUIRED)
        {
            DebugLog((DEB_TRACE_U2U, "SpInitLsaModeContext (TGT in error reply) USER2USER-INBOUND set\n"));

            KerbWriteLockContexts()
            Context->ContextAttributes |= KERB_CONTEXT_USER_TO_USER;
            KerbUnlockContexts();
        }

        Status = SEC_I_CONTINUE_NEEDED;
    }

Cleanup:
    if( KerbEventTraceFlag ) // Event Trace: KerbAcceptSecurityContextEnd {Status, CredSource, DomainName, UserName, Target, (ExtError), (klininfo)}
    {

    PCWSTR TraceStrings[] =
        {
        L"CredMan",
        L"Supplied",
        L"Context",
        L"LogonSession",
        L"None"
    };
    enum { TSTR_CREDMAN = 0, TSTR_SUPPLIED, TSTR_CONTEXT, TSTR_LOGONSESSION, TSTR_NONE };
    UNICODE_STRING UNICODE_NONE = { 4*sizeof(WCHAR), 4*sizeof(WCHAR), L"NONE" };

    UNICODE_STRING CredSource;
    PUNICODE_STRING trace_DomainName, trace_UserName, trace_target;

    trace_target = (Context!=NULL) ? &Context->ServerPrincipalName : &UNICODE_NONE;

    if( Context != NULL && Context->CredManCredentials != NULL )
    {
        RtlInitUnicodeString( &CredSource, TraceStrings[TSTR_CREDMAN] );
        trace_DomainName = &Context->CredManCredentials->SuppliedCredentials->DomainName;
        trace_UserName   = &Context->CredManCredentials->SuppliedCredentials->UserName;
    }
    else if( Credential != NULL && Credential->SuppliedCredentials != NULL )
    {
        RtlInitUnicodeString( &CredSource, TraceStrings[TSTR_SUPPLIED] );
        trace_DomainName = &Credential->SuppliedCredentials->DomainName;
        trace_UserName   = &Credential->SuppliedCredentials->UserName;
    }
    else if( Context != NULL )
    {
        RtlInitUnicodeString( &CredSource, TraceStrings[TSTR_CONTEXT] );
        trace_DomainName = &Context->ClientRealm;
        trace_UserName   = &Context->ClientName;
    }
    else if( LogonSession != NULL )
    {
        RtlInitUnicodeString( &CredSource, TraceStrings[TSTR_LOGONSESSION] );
        trace_DomainName = &LogonSession->PrimaryCredentials.DomainName;
        trace_UserName   = &LogonSession->PrimaryCredentials.UserName;
    }
    else
    {
        RtlInitUnicodeString( &CredSource, TraceStrings[TSTR_NONE] );
        trace_DomainName = &UNICODE_NONE;
        trace_UserName   = &UNICODE_NONE;
    }

    INSERT_ULONG_INTO_MOF(           Status,           AcceptSCTraceInfo.MofData, 0 );
    INSERT_UNICODE_STRING_INTO_MOF(  CredSource,       AcceptSCTraceInfo.MofData, 1 );
    INSERT_UNICODE_STRING_INTO_MOF( *trace_DomainName, AcceptSCTraceInfo.MofData, 3 );
    INSERT_UNICODE_STRING_INTO_MOF( *trace_UserName,   AcceptSCTraceInfo.MofData, 5 );
    INSERT_UNICODE_STRING_INTO_MOF( *trace_target,     AcceptSCTraceInfo.MofData, 7 );
    AcceptSCTraceInfo.EventTrace.Size = sizeof(EVENT_TRACE_HEADER) + 9*sizeof(MOF_FIELD);

    // Set trace parameters
    AcceptSCTraceInfo.EventTrace.Guid       = KerbAcceptSCGuid;
    AcceptSCTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_END;
    AcceptSCTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;

    TraceEvent(
        KerbTraceLoggerHandle,
        (PEVENT_TRACE_HEADER)&AcceptSCTraceInfo
        );
    }

    if ((InternalTicket != NULL) &&
        ((InternalTicket->bit_mask & KERB_ENCRYPTED_TICKET_client_addresses_present) != 0))

    {
        (VOID) KerbGetClientNetbiosAddress(
                    &WorkstationName,
                    InternalTicket->KERB_ENCRYPTED_TICKET_client_addresses
                    );
    }

    //
    // First, handle auditing
    //
    if (Status == STATUS_SUCCESS)
    {
        //
        // The following generates a successful audit event.
        // A new field (logon GUID) was added to this audit event.
        //
        // In order to send this new field to LSA, we had two options:
        //   1) add new function (AuditLogonEx) to LSA dispatch table
        //   2) define a private (LsaI) function to do the job
        //
        // option#2 was chosen because the logon GUID is a Kerberos only
        // feature.
        //

        if (S4UDelegationInfo)
        {
            TransittedServices = (PLSA_ADT_STRING_LIST)KerbAllocate(
                                    sizeof(LSA_ADT_STRING_LIST) +
                                    sizeof(LSA_ADT_STRING_LIST_ENTRY) * S4UDelegationInfo->TransitedListSize);

            if (TransittedServices)
            {
                PLSA_ADT_STRING_LIST_ENTRY Entry;

                Entry = (PLSA_ADT_STRING_LIST_ENTRY)&TransittedServices[1];

                TransittedServices->cStrings = S4UDelegationInfo->TransitedListSize;
                TransittedServices->Strings = Entry;

                for (ULONG i = 0; i < S4UDelegationInfo->TransitedListSize; i++)
                {
                    Entry->Flags = 0;
                    Entry->String.Length = S4UDelegationInfo->S4UTransitedServices[i].Length;
                    Entry->String.MaximumLength = S4UDelegationInfo->S4UTransitedServices[i].MaximumLength;
                    Entry->String.Buffer = S4UDelegationInfo->S4UTransitedServices[i].Buffer;
                    Entry++;
                }
            }
        }

        DsysAssert(Context);


        (void) KerbAuditLogon(
                    Status,
                    Status,
                    Context,
                    &WorkstationName,
                    &LogonId,
                    TransittedServices
                    );

#ifdef DBG
        InterlockedIncrement(&Audits);
#endif

    }
    else if (!NT_SUCCESS(Status) || (LastStatus != STATUS_SUCCESS))
    {
        PUNICODE_STRING Wks = ((WorkstationName.Length) ? &WorkstationName : NULL);

        if (Context != NULL)
        {
            LsaFunctions->AuditLogon(
                STATUS_LOGON_FAILURE,
                (LastStatus != STATUS_SUCCESS) ? LastStatus : Status,
                &Context->ClientName,
                &Context->ClientRealm,
                Wks,
                NULL,                   // no sid instead of a bogus one
                Network,
                &KerberosSource,
                &LogonId
                );
        }
        else
        {
            UNICODE_STRING EmptyString = NULL_UNICODE_STRING;

            LsaFunctions->AuditLogon(
                (LastStatus != STATUS_SUCCESS) ? LastStatus : Status,
                STATUS_SUCCESS,
                &EmptyString,
                &EmptyString,
                Wks,
                NULL,
                Network,
                &KerberosSource,
                &LogonId
                );
        }
    }

    if (Context != NULL)
    {
        if (!NT_SUCCESS(Status))
        {
            //
            // Only unlink the context if we just created it.
            //

            if (ContextHandle == 0)
            {
                KerbReferenceContextByPointer(
                    Context,
                    TRUE
                    );
                KerbDereferenceContext(Context);
            }
            else
            {
                //
                // Set the context to an invalid state.
                //

                KerbWriteLockContexts();
                Context->ContextState = InvalidState;
                KerbUnlockContexts();
            }
        }
        else
        {
            KerbWriteLockContexts();
            if (Status == STATUS_SUCCESS)
            {
                Context->ContextState = AuthenticatedState;
            }
            else
            {
                if ((*ContextAttributes & ASC_RET_EXTENDED_ERROR) != 0)
                {
                    Context->ContextState = ErrorMessageSentState;
                }
                else if (!IsTgtRequest)
                {
                    Context->ContextState = ApReplySentState;
                }
                else
                {
                    //
                    // else the HandleTgtRequest set the state
                    //

                    DsysAssert(Context->ContextState == TgtReplySentState);
                }
            }
            KerbUnlockContexts();
        }
        KerbDereferenceContext(Context);
    }

    if (Status == STATUS_SUCCESS)
    {
        //
        // On real success we map the context to the callers address
        // space.
        //

        Status = KerbMapContext(
                    Context,
                    MappedContext,
                    ContextData
                    );

        DebugLog((DEB_TRACE, "SpAcceptLsaModeContext called KerbMapContext ContextAttributes %#x, %#x\n", Context->ContextAttributes, Status));
    }

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession( LogonSession );
    }

    if (Credential != NULL)
    {
        KerbDereferenceCredential( Credential );
    }

    if (InternalTicket != NULL)
    {
        KerbFreeTicket( InternalTicket );
    }
    if (InternalAuthenticator != NULL)
    {
        KerbFreeAuthenticator(InternalAuthenticator);
    }
    if (Request != NULL)
    {
        KerbFreeApRequest(Request);
    }

    if (Reply != NULL)
    {
        KerbFree(Reply);
    }
    KerbFreeKey(&SessionKey);
    KerbFreeKey(&ServerKey);

    if (UserSid != NULL)
    {
        KerbFree(UserSid);
    }

    //
    // If there was a problem with the context or AP reply, the TokenHandle
    // will not be reset to NULL.  If it is NULL, close it so we don't leak
    //

    if ( TokenHandle != NULL )
    {
        D_DebugLog(( DEB_TRACE, "Closing token handle because context creation failed (%x)\n",
                        Status ));

        NtClose( TokenHandle );
    }

    //
    // Update performance counter
    //

#ifndef WIN32_CHICAGO
    if (ContextHandle == 0)
    {
        I_SamIIncrementPerformanceCounter(KerbServerContextCounter);
    }
#endif // WIN32_CHICAGO

    KerbFreeKey(&TicketKey);
    KerbFreeString(&ServiceDomain);
    KerbFreeString(&ClientDomain);
    KerbFreeString(&ClientNetbiosDomain);
    KerbFreeString(&ClientName);
    KerbFreeString(&WorkstationName);

    if (TransittedServices)
    {
        KerbFree(TransittedServices);
    }

    if (S4UDelegationInfo)
    {
#if DBG
        D_DebugLog((DEB_TRACE_S4U, "SpAcceptLsaModeContext target %wZ\n", &S4UDelegationInfo->S4U2proxyTarget)); 
        
        for ( ULONG i = 0; i < S4UDelegationInfo->TransitedListSize; i++ )
        {        
            D_DebugLog((DEB_TRACE_S4U, "SpAcceptLsaModeContext ts %#x: %wZ\n", i, &S4UDelegationInfo->S4UTransitedServices[i]));   
        }
#endif // DBG

        MIDL_user_free(S4UDelegationInfo);
    }

    D_DebugLog((DEB_TRACE_LEAKS,"SpAcceptLsaModeContext returned 0x%x, Context 0x%x, Pid 0x%x\n",KerbMapKerbNtStatusToNtStatus(Status), *NewContextHandle, ClientProcess));
    D_DebugLog((DEB_TRACE_API, "SpAcceptLsaModeContext (%p) returned 0x%x\n", Context, KerbMapKerbNtStatusToNtStatus(Status))); // fester

    return (KerbMapKerbNtStatusToNtStatus(Status));
}
#endif WIN32_CHICAGO //we don't do server side stuff
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\credman.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        credman.h
//
// Contents:    Structures and prototyps for accessing credential manager
//
//
// History:     23-Feb-2000   Created         Jeffspel
//
//------------------------------------------------------------------------

#ifndef __CREDMAN_H__
#define __CREDMGR_H__

VOID
KerbFreeCredmanList(KERBEROS_LIST CredmanList);

VOID
KerbDereferenceCredmanCred(
    IN PKERB_CREDMAN_CRED Cred,
    IN PKERBEROS_LIST CredmanList
    );

VOID
KerbLogCredmanError(
    IN PKERB_CREDMAN_CRED Cred,
    IN NTSTATUS Status
    );



NTSTATUS
KerbInitPrimaryCreds(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PUNICODE_STRING UserString,
    IN PUNICODE_STRING DomainString,
    IN PUNICODE_STRING PrincipalName,
    IN PUNICODE_STRING PasswordString,    // either the password or if pin
    IN BOOLEAN PubKeyCreds,
    IN OPTIONAL PCERT_CONTEXT pCertContext,
    OUT PKERB_PRIMARY_CREDENTIAL * PrimaryCreds
    );

NTSTATUS
CredpExtractMarshalledTargetInfo(
    IN  PUNICODE_STRING TargetServerName,
    OUT CREDENTIAL_TARGET_INFORMATIONW **pTargetInfo
    );

VOID
KerbReferenceCredmanCred(
    IN PKERB_CREDMAN_CRED Cred,
    IN PKERB_LOGON_SESSION LogonSession,
    IN BOOLEAN Unlink
    );

NTSTATUS
KerbAddCredmanCredToLogonSession(
    IN PKERB_LOGON_SESSION pLogonSession,
    IN PKERB_PRIMARY_CREDENTIAL CredToMatch,
    IN ULONG AdditionalCredFlags,
    IN OUT PKERB_CREDMAN_CRED *NewCred
    );

NTSTATUS
KerbRetrieveOWF(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL    Credential,
    IN PKERB_CREDMAN_CRED  CredmanCred,
    IN PUNICODE_STRING     CredTargetName,
    IN OUT PKERB_QUERY_SUPPLEMENTAL_CREDS_RESPONSE * Response,
    IN OUT PULONG         ResponseSize
    );

NTSTATUS
KerbCheckUserNameForCert(
    IN PLUID ClientLogonId,
    IN BOOLEAN fImpersonateClient,
    IN UNICODE_STRING *pUserName,
    OUT PCERT_CONTEXT *ppCertContext
    );

NTSTATUS
KerbConvertCertCredential(
    IN PKERB_LOGON_SESSION LogonSession,
    IN LPCWSTR MarshalledCredential,
    IN PUNICODE_STRING TargetName,
    IN OUT PKERB_PRIMARY_CREDENTIAL * PrimaryCredential
    );

NTSTATUS
KerbTicklePackage(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PUNICODE_STRING CredentialBlob
    );


NTSTATUS
KerbAddCertCredToPrimaryCredential(
    IN PKERB_LOGON_SESSION pLogonSession,
    IN PUNICODE_STRING pTargetName,
    IN PCERT_CONTEXT pCertContext,
    IN PUNICODE_STRING pPin,
    IN ULONG CredFlags,
    IN OUT PKERB_PRIMARY_CREDENTIAL *ppCredMgrCred);

NTSTATUS
KerbCheckCredMgrForGivenTarget(
    IN PKERB_LOGON_SESSION pLogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN PUNICODE_STRING SuppliedTargetName,
    IN PKERB_INTERNAL_NAME pTargetName,
    IN ULONG TargetInfoFlags,
    IN PUNICODE_STRING pTargetDomainName,
    IN PUNICODE_STRING pTargetForestName,
    IN OUT PKERB_CREDMAN_CRED *CredmanCred,
    IN OUT PBYTE *pbMarshalledTargetInfo,
    IN OUT ULONG *cbMarshalledTargetInfo
    );

VOID
KerbNotifyCredentialManager(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CHANGEPASSWORD_REQUEST ChangeRequest,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING RealmName
    );

NTSTATUS
KerbProcessUserNameCredential(
    IN  PUNICODE_STRING MarshalledUserName,
    OUT PUNICODE_STRING UserName,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING Password
    );



#define RAS_CREDENTIAL  0x1

#endif // __CREDMAN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\credmgr.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        credmgr.cxx
//
// Contents:    Code for managing credentials list for the Kerberos package
//
//
// History:     17-April-1996   Created         MikeSw
//              26-Sep-1998   ChandanS
//                            Added more debugging support etc.
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#define CREDMGR_ALLOCATE
#include <kerbp.h>
#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitCredentialList
//
//  Synopsis:   Initializes the Credentials list
//
//  Effects:    allocates a resources
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, other error codes
//              on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbInitCredentialList(
    VOID
    )
{
    NTSTATUS Status;


    Status = KerbInitializeList( &KerbCredentialList, CRED_MGR_LOCK_ENUM );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    KerberosCredentialsInitialized = TRUE;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KerbFreeList( &KerbCredentialList);

    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeCredentialList
//
//  Synopsis:   Frees the credentials list
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeCredentialList(
    VOID
    )
{
    PKERB_CREDENTIAL Credential;


    if (KerberosCredentialsInitialized)
    {
        KerbLockList(&KerbCredentialList);

        //
        // Go through the list of logon sessions and dereferences them all
        //

        while (!IsListEmpty(&KerbCredentialList.List))
        {
            Credential = CONTAINING_RECORD(
                            KerbCredentialList.List.Flink,
                            KERB_CREDENTIAL,
                            ListEntry.Next
                            );

            KerbReferenceListEntry(
                &KerbCredentialList,
                &Credential->ListEntry,
                TRUE
                );

            KerbDereferenceCredential(Credential);

        }

        KerbFreeList(&KerbCredentialList);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbAllocateCredential
//
//  Synopsis:   Allocates a credential structure
//
//  Effects:    Allocates a credential, but does not add it to the
//              list of credentials
//
//  Arguments:  NewCredential - receives a new credential allocated
//                  with KerbAllocate
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//              STATUS_INSUFFICIENT_RESOURCES if the allocation fails
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbAllocateCredential(
    PKERB_CREDENTIAL * NewCredential
    )
{
    PKERB_CREDENTIAL Credential;
    SECPKG_CALL_INFO CallInfo;
    NTSTATUS Status = STATUS_SUCCESS;

    *NewCredential = NULL;

    if (!LsaFunctions->GetCallInfo(&CallInfo))
    {
        D_DebugLog((DEB_ERROR,"Failed to get call info. %ws, line %d\n",
            THIS_FILE, __LINE__));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Credential = (PKERB_CREDENTIAL) KerbAllocate(
                        sizeof(KERB_CREDENTIAL) );

    if (Credential == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Credential->ClientProcess = CallInfo.ProcessId;

    KerbInitializeListEntry(
        &Credential->ListEntry
        );
    //
    // Set the references to 1 since we are returning a pointer to the
    // logon session
    //

    Credential->HandleCount = 1;

    *NewCredential = Credential;

Cleanup:
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInsertCredential
//
//  Synopsis:   Inserts a logon session into the list of logon sessions
//
//  Effects:    bumps reference count on logon session
//
//  Arguments:  Credential - Credential to insert
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS always
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbInsertCredential(
    IN PKERB_CREDENTIAL Credential
    )
{

    //
    // insert entry at tail of list.
    // reason: entries at the head are more likely to have _TGT flag set
    // and, those are the ones we want to satisfy from cache for repeat
    // high stress offenders...
    //

    Credential->CredentialTag = KERB_CREDENTIAL_TAG_ACTIVE;

    KerbInsertListEntryTail(
        &Credential->ListEntry,
        &KerbCredentialList
        );

    return(STATUS_SUCCESS);
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbFreePrimaryCredentials
//
//  Synopsis:   frees a primary credentials structure
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbFreePrimaryCredentials(
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    IN BOOLEAN FreeBaseStructure
    )
{
    if (Credentials != NULL)
    {
        KerbFreeString(&Credentials->DomainName);
        KerbFreeString(&Credentials->OldDomainName);
        KerbFreeString(&Credentials->UserName);
        KerbFreeString(&Credentials->OldUserName);

        RtlZeroMemory( &Credentials->OldHashPassword, sizeof(Credentials->OldHashPassword) );
        if (Credentials->ClearPassword.Buffer != NULL)
        {
            RtlZeroMemory(
                Credentials->ClearPassword.Buffer,
                Credentials->ClearPassword.Length
                );
            KerbFreeString(&Credentials->ClearPassword);
            RtlZeroMemory(&Credentials->ClearPassword, sizeof(Credentials->ClearPassword));
        }
        if (Credentials->Passwords != NULL)
        {
            KerbFreeStoredCred(Credentials->Passwords);
        }
        if (Credentials->OldPasswords != NULL)
        {
            KerbFreeStoredCred(Credentials->OldPasswords);
        }
        KerbPurgeTicketCache(&Credentials->ServerTicketCache);
        KerbPurgeTicketCache(&Credentials->AuthenticationTicketCache);

        KerbFreePKCreds(Credentials->PublicKeyCreds, FALSE);
        Credentials->PublicKeyCreds = NULL;

        if (FreeBaseStructure)
        {
            KerbFree(Credentials);
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeCredential
//
//  Synopsis:   Frees a credential structure and all contained data
//
//  Effects:
//
//  Arguments:  Credential - The credential to free.
//
//  Requires:   This credential must be unlinked
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbFreeCredential(
    IN PKERB_CREDENTIAL Credential
    )
{

    Credential->CredentialTag = KERB_CREDENTIAL_TAG_DELETE;

    if (Credential->SuppliedCredentials != NULL)
    {
        KerbFreePrimaryCredentials(Credential->SuppliedCredentials, TRUE);
    }
    DsysAssert(Credential->ListEntry.Next.Flink == NULL);
    KerbFreeString(&Credential->CredentialName);

    KerbFree(Credential);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetTicketForCredential
//
//  Synopsis:   Obtains a TGT for a credential if it doesn't already
//              have one.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbGetTicketForCredential(
    IN OPTIONAL PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN OPTIONAL PUNICODE_STRING SuppRealm
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_LOGON_SESSION LocalLogonSession = NULL;
    BOOLEAN GetRestrictedTgt = FALSE;
    PKERB_TICKET_CACHE_ENTRY Tgt = NULL;
    BOOLEAN PrimaryLogonSessionCredential = FALSE;

    //
    // We've got to make a determination w.r.t. whether this
    // is an attempt to renew our primary credential.
    // This will affect our logon session flags.
    //


    if (!ARGUMENT_PRESENT(LogonSession))
    {
      LocalLogonSession = KerbReferenceLogonSession(
                              &Credential->LogonId,
                              FALSE                   // don't unlink
                              );
      if (LocalLogonSession == NULL)
      {
          Status = STATUS_NO_SUCH_LOGON_SESSION;
          goto Cleanup;
      }

    }
    else
    {
        LocalLogonSession = LogonSession;
    }


    //
    // Here we make the assumption that if we didn't get a credential
    // and we also got a logon session, then we're dealing w/ the
    // logon session's primary credential
    //                                                                    f
    if ((ARGUMENT_PRESENT(Credential)) &&
        (Credential->SuppliedCredentials == NULL) &&
        (!ARGUMENT_PRESENT(CredManCredentials)))

    {
        PrimaryLogonSessionCredential = TRUE;
        D_DebugLog((DEB_TRACE_CRED, "Getting Credentials for primary logon session - %x\n", LogonSession));
    }
    else
    {
        D_DebugLog((DEB_TRACE_CRED, "Got a credential && a logon session\n"));
    }

    Status = KerbGetTicketGrantingTicket(
                LocalLogonSession,
                Credential,
                CredManCredentials,
                SuppRealm,
                &Tgt,
                NULL            // don't return credential key
                );


    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;

    }

    KerbWriteLockLogonSessions(LocalLogonSession);

    //
    // Clear the logon deferred bit for the logon session, if set
    // Note:  This will only be cleared as a result of refreshing
    // logon session's primary cred tgt
    //
    if (PrimaryLogonSessionCredential &&
       ((LocalLogonSession->LogonSessionFlags & KERB_LOGON_DEFERRED) != 0))
    {
        LocalLogonSession->LogonSessionFlags &= ~KERB_LOGON_DEFERRED;
    }

    //
    // If we have a credential, be sure to set the TGT_avail bit for
    // those credentials.
    //
    if (ARGUMENT_PRESENT(Credential))
    {
        Credential->CredentialFlags |= KERB_CRED_TGT_AVAIL;
        if ((Credential->CredentialFlags & KERB_CRED_RESTRICTED) != 0)
        {
            GetRestrictedTgt = TRUE;
        }
    }

    if (ARGUMENT_PRESENT(CredManCredentials))
    {
        CredManCredentials->CredentialFlags |= KERB_CRED_TGT_AVAIL;
    }

    KerbUnlockLogonSessions(LocalLogonSession);

#ifdef RESTRICTED_TOKEN
    if (GetRestrictedTgt)
    {
        Status = KerbGetRestrictedTgtForCredential(
                    LocalLogonSession,
                    Credential
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to get restricted TGT for credential: 0x%x\n",Status));

            KerbRemoveTicketCacheEntry(Tgt);

            goto Cleanup;
        }
    }

#endif

Cleanup:

    //
    // Reset the bits if we failed
    //

    if (LocalLogonSession  && !NT_SUCCESS(Status))
    {
        KerbWriteLockLogonSessions(LocalLogonSession);

        //
        // Don't touch logon session flag, unless we're
        // dealing w/ our own logon session.   This means
        // we don't have a TGT for our initial logon session,
        // See RefreshTgt() -- only place we supply logon session
        //
        if (PrimaryLogonSessionCredential)
        {
            LocalLogonSession->LogonSessionFlags |= KERB_LOGON_DEFERRED;
            D_DebugLog((DEB_TRACE_CRED, "Toggling ON logon deferred bit for logon session %x\n", LogonSession));
        }

        //
        // Or, we expected it to be there with our (supplied) credential
        //
        if (ARGUMENT_PRESENT(Credential))
        {
            Credential->CredentialFlags &= ~KERB_CRED_TGT_AVAIL;
        }

        KerbUnlockLogonSessions(LocalLogonSession);
    }

    if (!ARGUMENT_PRESENT(LogonSession) && (LocalLogonSession != NULL))
    {
        KerbDereferenceLogonSession(LocalLogonSession);
    }
    if (Tgt != NULL)
    {
        KerbDereferenceTicketCacheEntry(
            Tgt
            );

    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceCredential
//
//  Synopsis:   Locates a logon session from the logon ID and references it
//
//  Effects:    Increments reference count and possible unlinks it from list
//
//  Arguments:  LogonId - LogonId of logon session to locate
//              RequiredFlags - Flags required
//              RemoveFromList - If TRUE, logon session will be delinked
//              Credential - Receives the referenced credential
//
//  Requires:
//
//  Returns:    NT status codes
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbReferenceCredential(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN ULONG RequiredFlags,
    IN BOOLEAN RemoveFromList,
    OUT PKERB_CREDENTIAL * Credential
    )
{
    PKERB_CREDENTIAL LocalCredential = NULL;
    BOOLEAN Found = FALSE;
    SECPKG_CALL_INFO CallInfo;
    BOOLEAN LocalRemoveFromList = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;

    ULONG DereferenceCount;

    *Credential = NULL;

    if(LsaFunctions->GetCallInfo(&CallInfo))
    {
        DereferenceCount = CallInfo.CallCount;
    } else {
        ASSERT((STATUS_INTERNAL_ERROR == STATUS_SUCCESS));
        return STATUS_INTERNAL_ERROR;
    }

    if( CallInfo.Attributes & SECPKG_CALL_CLEANUP )
    {
        CallInfo.Attributes |= SECPKG_CALL_IS_TCB;
        DebugLog((DEB_TRACE, "CredHandle %p leaked by ProcessId %x Deref count: %x\n",
                    CredentialHandle, CallInfo.ProcessId, DereferenceCount));
    }

    KerbLockList(&KerbCredentialList);

    //
    // Go through the list of logon sessions looking for the correct
    // LUID
    //

    __try {
        LocalCredential = (PKERB_CREDENTIAL)CredentialHandle;

        while( LocalCredential->CredentialTag == KERB_CREDENTIAL_TAG_ACTIVE )
        {
            if (((CallInfo.Attributes & SECPKG_CALL_IS_TCB) == 0) &&
                (LocalCredential->ClientProcess != CallInfo.ProcessId) )
            {
                D_DebugLog((DEB_ERROR,"Trying to reference a credential from another process! %ws, line %d\n", THIS_FILE, __LINE__));
                // FESTER
                D_DebugLog((DEB_ERROR, "Cred - %x \nClient process - %d  Call info Pid - %d\n", LocalCredential, LocalCredential->ClientProcess, CallInfo.ProcessId));
                Found = FALSE;
                Status = STATUS_PRIVILEGE_NOT_HELD;
                break;
            }

            KerbReferenceListEntry(
                    &KerbCredentialList,
                    &LocalCredential->ListEntry,
                    FALSE                   // don't remove
                    );

            Found = TRUE;
            break;
        }

    } __except (EXCEPTION_EXECUTE_HANDLER)
    {
        D_DebugLog((DEB_ERROR, "Trying to reference invalid credential %ws, line %d\n", THIS_FILE, __LINE__));
        Found = FALSE;
    }

    if (!Found)
    {
        LocalCredential = NULL;
        Status = STATUS_INVALID_HANDLE;
    }
    else
    {
        //
        // get TGTs in order to normalize supplied UPN credentials for non TCB callers
        //

        if ((RequiredFlags & KERB_CRED_INBOUND) 
            && LocalCredential->SuppliedCredentials 
            && (LocalCredential->SuppliedCredentials->DomainName.Length == 0)
            && ((CallInfo.Attributes & SECPKG_CALL_IS_TCB) == 0))
        {
            DebugLog((DEB_TRACE_CRED, "KerbReferenceCredential trying to normalize UPN %wZ, RequiredFlags %#x\n", &LocalCredential->SuppliedCredentials->UserName, RequiredFlags));
            RequiredFlags |= KERB_CRED_TGT_AVAIL;       
        }

        //
        // In some cases, we need to get a TGT here - but not for the S4U cases.
        //

        ULONG MissingFlags = RequiredFlags - (LocalCredential->CredentialFlags & RequiredFlags);

        if (MissingFlags != 0)
        {
            D_DebugLog((DEB_TRACE, "Credential %p is missing flags: needs %x\n",
                Credential,
                MissingFlags));

            if ((MissingFlags &= KERB_CRED_TGT_AVAIL) != 0)
            {
                if (( LocalCredential->CredentialFlags & (KERB_CRED_S4U_REQUIRED | KERB_CRED_LOCAL_ACCOUNT )) == 0)
                {
                    DsysAssert(!RemoveFromList);

                    KerbUnlockList(&KerbCredentialList);

                    D_DebugLog((DEB_TRACE_CRED,"Getting missing TGT for credential %x\n", LocalCredential));

                    Status = KerbGetTicketForCredential(
                                        NULL,
                                        LocalCredential,
                                        NULL,
                                        NULL
                                        );

                    KerbLockList(&KerbCredentialList);
                }

            }
            else
            {
                Status = SEC_E_NO_CREDENTIALS;
            }
        }

        if (NT_SUCCESS(Status))
        {
            //
            // Since there may be multiple outstanding handles using this
            // structure we don't want to really remove it from the list unless
            // the last one releases it.
            //

            if (RemoveFromList)
            {
                ASSERT( DereferenceCount != 0 );
                ASSERT ( (DereferenceCount <= LocalCredential->HandleCount) );

                if( DereferenceCount > LocalCredential->HandleCount ) {
                    LocalCredential->HandleCount = 0;
                } else {
                    LocalCredential->HandleCount -= DereferenceCount;
                }

                if (LocalCredential->HandleCount == 0)
                {
                    LocalRemoveFromList = TRUE;
                }
            }

            KerbReferenceListEntry(
                &KerbCredentialList,
                &LocalCredential->ListEntry,
                LocalRemoveFromList
                );

            KerbDereferenceCredential(LocalCredential);
        }
        else
        {
            //
            // Remove the earlier reference
            //

            KerbDereferenceCredential(LocalCredential);
            LocalCredential = NULL;
        }


        *Credential = LocalCredential;
    }

    KerbUnlockList(&KerbCredentialList);
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceCredential
//
//  Synopsis:   Dereferences a logon session - if reference count goes
//              to zero it frees the logon session
//
//  Effects:    decrements reference count
//
//  Arguments:  Credential - Logon session to dereference
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbDereferenceCredential(
    IN PKERB_CREDENTIAL Credential
    )
{
    if (KerbDereferenceListEntry(
            &Credential->ListEntry,
            &KerbCredentialList
            ) )
    {
        KerbFreeCredential(Credential);
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbPurgeCredentials
//
//  Synopsis:   Purges the list of credentials associated with a logon session
//              by dereferencing and unlinking them.
//
//  Effects:    Unlinks all credential on the list
//
//  Arguments:  CredentialList - List of credentials to purge
//
//  Requires:
//
//  Returns:    none
//
//  Notes:  No longer used, as some system processes hold cred handles long
//          after logons go away.  Leads to refcounting disasters.
//
//
//--------------------------------------------------------------------------
/*

VOID
KerbPurgeCredentials(
    IN PLIST_ENTRY CredentialList
    )
{
    PKERB_CREDENTIAL Credential;

    KerbLockList(&KerbCredentialList);
    while (!IsListEmpty(CredentialList))
    {
        Credential = CONTAINING_RECORD(
                        CredentialList->Flink,
                        KERB_CREDENTIAL,
                        NextForThisLogonSession
                        );


        //
        // Remove it from the credential list
        //

        //RemoveEntryList(&Credential->NextForThisLogonSession);
        Credential->HandleCount = 0;

        //
        // Reference it to unlink it and then dereference it
        //

        KerbReferenceListEntry(
            &KerbCredentialList,
            &Credential->ListEntry,
            TRUE
            );

        KerbDereferenceCredential(Credential);

    }
    KerbUnlockList(&KerbCredentialList);

} */


//+-------------------------------------------------------------------------
//
//  Function:   KerbLocateCredential
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
PKERB_CREDENTIAL
KerbLocateCredential(
    IN PLUID LogonId,
    IN ULONG CredentialUseFlags,
    IN PKERB_PRIMARY_CREDENTIAL SuppliedCredentials,
    IN ULONG CredentialFlags,
    IN PUNICODE_STRING CredentialName
    )
{
    PLIST_ENTRY ListEntry;
    PKERB_CREDENTIAL Credential = NULL;
    BOOLEAN Found = FALSE;
    SECPKG_CALL_INFO CallInfo;
    NT_OWF_PASSWORD HashPassword;
    
    if( SuppliedCredentials != NULL )
    {
        if ( SuppliedCredentials->ClearPassword.Buffer != NULL )
        {
            RtlCalculateNtOwfPassword(
                    &SuppliedCredentials->ClearPassword,
                    &HashPassword
                    );
        } 
        else 
        {
            ZeroMemory( &HashPassword, sizeof(HashPassword) );
        }
    }


    //
    // Match both flags
    //

    CredentialUseFlags |= CredentialFlags;

    if(!LsaFunctions->GetCallInfo(&CallInfo))
    {

        D_DebugLog((DEB_ERROR,"Failed to get client info:. %ws, line %d\n",
            THIS_FILE, __LINE__));
        return(NULL);
    }


    KerbLockList(&KerbCredentialList);

    //
    // Go through the list of logon sessions looking for the correct
    // LUID
    //

    for (ListEntry = KerbCredentialList.List.Flink ;
         ListEntry !=  &KerbCredentialList.List ;
         ListEntry = ListEntry->Flink )
    {
        Credential = CONTAINING_RECORD(ListEntry, KERB_CREDENTIAL, ListEntry.Next);

        if( (Credential->ClientProcess != CallInfo.ProcessId) )
        {
            continue;
        }

        if ( (Credential->CredentialFlags & KERB_CRED_MATCH_FLAGS) != CredentialUseFlags)
        {
            continue;
        }

        if(!RtlEqualLuid(
                &Credential->LogonId,
                LogonId
                ))
        {
            continue;
        }

        if(!RtlEqualUnicodeString(
                CredentialName,
                &Credential->CredentialName,
                FALSE
                ))
        {
            continue;
        }

        if( SuppliedCredentials != NULL )
        {
            //
            // credentials supplied, but candidate didn't have creds.  continue search.
            //

            if( Credential->SuppliedCredentials == NULL )
            {
                continue;
            }


            if(!RtlEqualUnicodeString(
                        &SuppliedCredentials->UserName,
                        &Credential->SuppliedCredentials->UserName,
                        FALSE
                        ))
            {
                if(!RtlEqualUnicodeString(
                            &SuppliedCredentials->UserName,
                            &Credential->SuppliedCredentials->OldUserName,
                            FALSE
                            ))
                {
                    continue;
                }
            }

            //
            // note: both candidate and input SuppliedCredentials ClearPassword
            // is actually encrypted via KerbHidePassword().
            //

            if(!RtlEqualMemory(
                        &HashPassword,
                        &Credential->SuppliedCredentials->OldHashPassword,
                        sizeof(HashPassword)
                        ))
            {
                continue;
            }


            //
            // optimize for UPN case:
            // check as typed versus as stored/updated first,
            // then check as typed versus as typed in original cred build.
            //

            if(!RtlEqualUnicodeString(
                        &SuppliedCredentials->DomainName,
                        &Credential->SuppliedCredentials->DomainName,
                        FALSE
                        ))
            {
                if(!RtlEqualUnicodeString(
                            &SuppliedCredentials->DomainName,
                            &Credential->SuppliedCredentials->OldDomainName,
                            FALSE
                            ))
                {
                    continue;
                }
            }


            if ((SuppliedCredentials->PublicKeyCreds != NULL) &&
                (Credential->SuppliedCredentials->PublicKeyCreds != NULL))
            {   

                //
                // note: both candidate and input SuppliedCredentials Pin
                // is actually encrypted via KerbHidePassword().
                //

                if(!RtlEqualUnicodeString(
                        &SuppliedCredentials->PublicKeyCreds->Pin,
                        &Credential->SuppliedCredentials->PublicKeyCreds->Pin,
                        FALSE
                        ))
                {
                    continue;
                }

                if (!KerbComparePublicKeyCreds(
                        SuppliedCredentials->PublicKeyCreds,
                        Credential->SuppliedCredentials->PublicKeyCreds
                        ))
                {
                    continue;
                }


            }


        } else {

            //
            // credentials not supplied, but candidate has creds.  continue search
            //

            if( Credential->SuppliedCredentials != NULL )
            {
                continue;
            }

        }

        KerbReferenceListEntry(
                    &KerbCredentialList,
                    &Credential->ListEntry,
                    FALSE
                    );

        Credential->HandleCount++;
        Found = TRUE;
        break;

    }

    KerbUnlockList(&KerbCredentialList);

    if (!Found)
    {
        Credential = NULL;
    }
    return(Credential);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateCredential
//
//  Synopsis:   Creates a new credential and links it to the credential list
//              and the list for this logon session
//
//  Effects:
//
//  Arguments:  LogonId - LogonId for this logon session
//              LogonSession - LogonSession for the client
//              CredentialUseFlags - Flags indicating if the credential is
//                      inbound or outbound
//              SuppliedCredentials - (Optionally) supplied credentials to store
//                      in the credentials. If these are present, there need
//                      not be a password on the logon session. The field is
//                      zeroed when the primary creds are stuck in the
//                      credential structure.
//              CredentialFlags - Flags about how credentials are to be
//                      used, such as to not use a PAC or to use a null
//                      session.
//              NewCredential - Receives new credential, referenced and linked
//              ExpirationTime - Receives credential expiration time
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success,
//              STATUS_INSUFFICIENT_RESOURCES on allocation failure
//
//  Notes:      Readers and writers of this credential must hold the
//              credential lock
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCreateCredential(
    IN PLUID LogonId,
    IN PKERB_LOGON_SESSION LogonSession,
    IN ULONG CredentialUseFlags,
    IN PKERB_PRIMARY_CREDENTIAL * SuppliedCredentials,
    IN ULONG CredentialFlags,
    IN PUNICODE_STRING CredentialName,
    OUT PKERB_CREDENTIAL * NewCredential,
    OUT PTimeStamp ExpirationTime
    )
{
    NTSTATUS Status;
    PKERB_CREDENTIAL Credential = NULL;
    ULONG LogonSessionFlags = 0;
    UNICODE_STRING ServiceRealm = NULL_UNICODE_STRING;
    BOOLEAN FoundKdc = FALSE;

    //
    // Make sure the flags are valid
    //

    if (( CredentialUseFlags == 0) ||
        ((CredentialUseFlags & ~SECPKG_CRED_BOTH) != 0))
    {
        D_DebugLog((DEB_ERROR,"Invalid credential use flags: 0x%x. %ws, line %d\n",CredentialUseFlags, THIS_FILE, __LINE__));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Check to see if we already have a credential for this situation
    //

    Credential = KerbLocateCredential(
                    LogonId,
                    CredentialUseFlags,
                    *SuppliedCredentials,
                    CredentialFlags,
                    CredentialName
                    );

    if (Credential != NULL)
    {
        KerbReadLockLogonSessions(LogonSession);

        *ExpirationTime = LogonSession->Lifetime;

        KerbUnlockLogonSessions(LogonSession);

        *NewCredential = Credential;
        return(STATUS_SUCCESS);
    }

    Status = KerbAllocateCredential(&Credential);
    if (!NT_SUCCESS(Status))
    {
         goto Cleanup;
    }

    Credential->LogonId = *LogonId;

    //
    // Make sure the logon session is valid for acquiring credentials
    //

    KerbReadLockLogonSessions(LogonSession);

    LogonSessionFlags = LogonSession->LogonSessionFlags;
    *ExpirationTime = LogonSession->Lifetime;

    KerbUnlockLogonSessions(LogonSession);

    Credential->SuppliedCredentials = *SuppliedCredentials;
    *SuppliedCredentials = NULL;

    Credential->CredentialName = *CredentialName;
    CredentialName->Buffer = NULL;

    Credential->CredentialFlags = CredentialUseFlags | CredentialFlags;

    if (( CredentialUseFlags & KERB_CRED_BOTH ) == 0)
    {
        D_DebugLog((DEB_ERROR,"Invalid credential use flags: 0x%x. %ws, line %d\n",CredentialUseFlags, THIS_FILE, __LINE__));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Evaluate the outbound credential cases.  We may need to do S4U.
    //
    if (( Credential->SuppliedCredentials == NULL ) &&
       (( CredentialFlags & KERB_CRED_NULL_SESSION) == 0))
    {
        if (( CredentialUseFlags & KERB_CRED_OUTBOUND) != 0)
        {
            if (( LogonSessionFlags & KERB_LOGON_S4U_REQUIRED ) != 0)
            {
                //
                // This logon session was created w/o the capabilities of
                // going "off box".  In this case, we need to fail this transaction
                //
                if (( LogonSessionFlags & KERB_LOGON_DELEGATE_OK ) == 0)
                {
                    DebugLog((DEB_TRACE_CRED, "Cant go off box w/ non-fwdble logon session & no supp creds\n"));
                    Status = SEC_E_NO_CREDENTIALS;
                    goto Cleanup;
                }
                else
                {
                    //
                    // All others are OK for leaving the machine.  Mark this cred
                    // as an S4U cred, then get the heck out of here.
                    //
                    DebugLog((DEB_TRACE_CRED, "Acquiring cred, S4U required\n"));
                    Credential->CredentialFlags |= KERB_CRED_S4U_REQUIRED;
                }
            }
            else if (( LogonSessionFlags & KERB_LOGON_LOCAL_ONLY ) != 0)
            {
                //
                // Local logon session - we can only use these w/o supplied creds
                // if we use credman.
                //
                Credential->CredentialFlags |= KERB_CRED_LOCAL_ACCOUNT;

            }
            else if (( LogonSessionFlags & KERB_LOGON_DEFERRED ) != 0)
            {
                //
                // I don't believe we'll hit this case anymore, as all "non pwd" logon sessions
                // should be using S4U, unless they're local.
                //
                if (( LogonSessionFlags & KERB_LOGON_NO_PASSWORD ) != 0 )
                {
                    DebugLog((DEB_TRACE_CRED,"Trying to acquire cred handle w/ no supplied creds for ls (%p) no pass or TGT\n", LogonSession));
                    Status = SEC_E_NO_CREDENTIALS;
                    goto Cleanup;
                }

            }
            else if (( LogonSessionFlags & KERB_LOGON_DEFERRED ) == 0)
            {
                //
                // Normal case, where we have a TGT
                //
                Credential->CredentialFlags |= KERB_CRED_TGT_AVAIL;
            }
            else
            {
                //
                // Generic case, where we don't have a TGT for a domain logon,
                // but we have info for a TGT. Assert until we verify we're not missing
                // anything important - Contact Todds
                //
                DebugLog((DEB_ERROR, "Missing case for session FLAGs %x\n", LogonSessionFlags));
            }
        }

        if (( CredentialUseFlags & KERB_CRED_INBOUND) != 0)
        {
            if (( LogonSessionFlags & KERB_LOGON_DEFERRED ) == 0)
            {
                Credential->CredentialFlags |= KERB_CRED_TGT_AVAIL;
            }
            else
            {
                if ((LogonSessionFlags & (KERB_LOGON_NO_PASSWORD | KERB_LOGON_LOCAL_ONLY)) != 0)
                {
                    D_DebugLog((DEB_WARN, "Trying to get inbound cred with no supplied creds, no pwd or tgt, or local only\n"));
                    Status = SEC_E_NO_CREDENTIALS;
                    goto Cleanup;
                }

                KerbReadLockLogonSessions(LogonSession);
                Status = KerbDuplicateString(
                                &ServiceRealm,
                                &LogonSession->PrimaryCredentials.DomainName
                                );

                KerbUnlockLogonSessions(LogonSession);

                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                //
                // If there was no domain name, then assume there is a KDC.
                //
                if (ServiceRealm.Length == 0)
                {
                    FoundKdc = TRUE;
                }

                if (!FoundKdc)
                {
                    //
                    // If we are a DC, or f this domain is our worksatation
                    // domain, check to see if
                    // we have a DNS name. If we do, then at one point we were
                    // part of an NT5 domain. Otherwise call DsGetDCName to see
                    // if there is a KDC around
                    //

                    if ((KerbGlobalRole == KerbRoleDomainController) ||
                        KerbIsThisOurDomain(
                            &ServiceRealm
                            ))
                    {
                        FoundKdc = TRUE;
                    }
                }

                //
                // If we haven't found one yet, try looking for a KDC in
                // this domain
                //

                if (!FoundKdc)
                {
                    PKERB_BINDING_CACHE_ENTRY BindingHandle = NULL;

                    DsysAssert(ServiceRealm.MaximumLength >= ServiceRealm.Length + sizeof(WCHAR));
                    DsysAssert(ServiceRealm.Buffer[ServiceRealm.Length/sizeof(WCHAR)] == L'\0');

                    Status = KerbGetKdcBinding(
                                &ServiceRealm,
                                NULL,           // no account name
                                0,              // no desired flags,
                                FALSE,          // don't call kadmin
                                FALSE,
                                &BindingHandle
                                );
                    if (NT_SUCCESS(Status))
                    {
                        FoundKdc = TRUE;
                        KerbDereferenceBindingCacheEntry(BindingHandle);
                    }

                }
                if (!FoundKdc)
                {
                    D_DebugLog((DEB_ERROR,"Didn't find KDC for domain %wZ. %ws, line %d\n",
                                &ServiceRealm, THIS_FILE, __LINE__ ));
                    Status = SEC_E_NO_AUTHENTICATING_AUTHORITY;
                    goto Cleanup;
                }
            }
        }

    }
    else
    {
        //
        // In this case, we have supplied credentials.
        //
        D_DebugLog((DEB_TRACE, "Got supplied credentials\n"));
    }





    //
    // Insert the credential into the list of credentials
    //

    KerbInsertCredential(Credential);

    //
    // Notice: the order of acquiring these locks is important.
    //

    *NewCredential = Credential;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (Credential != NULL)
        {
            //
            // Make sure we haven't linked this one yet.
            //

            DsysAssert(Credential->ListEntry.ReferenceCount == 1);
            KerbFreeCredential(Credential);
        }

        //
        // Map the error if necessary. Normally STATUS_OBJECT_NAME_NOT_FOUND
        // gets mapped to SEC_E_UNKNOWN_TARGET, but this is an invalid
        // status to return from AcquireCredentialsHandle, so instead
        // return SEC_E_NO_CREDENTIALS.
        //

        if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
        {
            Status = SEC_E_NO_CREDENTIALS;
        }
    }
    KerbFreeString(&ServiceRealm);
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\credapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        credapi.cxx
//
// Contents:    Code for credentials APIs for the Kerberos package
//
//
// History:     16-April-1996   Created         MikeSw
//              26-Sep-1998   ChandanS
//                            Added more debugging support etc.
//
//------------------------------------------------------------------------


#include <kerb.hxx>
#include <kerbp.h>

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

#define FILENO FILENO_CREDAPI

//+-------------------------------------------------------------------------
//
//  Function:   KerbCopyClientString
//
//  Synopsis:   Copies a string from the client and if necessary converts
//              from ansi to unicode
//
//  Effects:    allocates output with either KerbAllocate (unicode)
//              or RtlAnsiStringToUnicodeString
//
//  Arguments:  StringPointer - address of string in client process
//              StringLength - Lenght (in characters) of string
//              AnsiString - if TRUE, string is ansi
//              LocalString - receives allocated string
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCopyClientString(
    IN PVOID StringPointer,
    IN ULONG StringLength,
    IN BOOLEAN AnsiString,
    OUT PUNICODE_STRING LocalString,
    IN ULONG MaxLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PVOID LocalBuffer = NULL;
    ULONG CharSize = sizeof(WCHAR);

    if (AnsiString)
    {
        CharSize = sizeof(CHAR);
    }

    if (StringLength > MaxLength)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    LocalBuffer = KerbAllocate(StringLength * CharSize);
    if (LocalBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = LsaFunctions->CopyFromClientBuffer(
                NULL,
                StringLength * CharSize,
                LocalBuffer,
                StringPointer
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (AnsiString)
    {
        ANSI_STRING TempString;
        UNICODE_STRING TempOutputString = {0};

        TempString.Buffer = (PCHAR) LocalBuffer;
        TempString.MaximumLength = TempString.Length = (USHORT) StringLength;

        Status = RtlAnsiStringToUnicodeString(
                    &TempOutputString,
                    &TempString,
                    TRUE                // allocate destination
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        *LocalString = TempOutputString;
    }
    else
    {
        LocalString->Buffer = (LPWSTR) LocalBuffer;
        LocalString->Length = (USHORT) StringLength * sizeof(WCHAR);
        LocalString->MaximumLength = LocalString->Length;
        LocalBuffer = NULL;
    }

Cleanup:
    if (LocalBuffer)
    {
        KerbFree(LocalBuffer);
    }
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitPrimaryCreds
//
//  Synopsis:   Allocates and initializes a PKERB_PRIMARY_CREDENTIAL
//              structure.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitPrimaryCreds(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PUNICODE_STRING UserString,
    IN PUNICODE_STRING DomainString,
    IN OPTIONAL PUNICODE_STRING PrincipalName,
    IN PUNICODE_STRING PasswordString,    // either the password or if pin
    IN BOOLEAN PubKeyCreds,
    IN OPTIONAL PCERT_CONTEXT pCertContext,
    OUT PKERB_PRIMARY_CREDENTIAL * PrimaryCreds
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUCHAR Where;
    PKERB_PRIMARY_CREDENTIAL NewCreds = NULL;
    KERBEROS_MACHINE_ROLE Role;



    // allocate the primary cred structure
    NewCreds = (PKERB_PRIMARY_CREDENTIAL) KerbAllocate(sizeof(KERB_PRIMARY_CREDENTIAL));
    if (NewCreds == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    KerbInitTicketCache(
        &NewCreds->ServerTicketCache
        );
    KerbInitTicketCache(
        &NewCreds->AuthenticationTicketCache
        );

    KerbInitTicketCache(
        &NewCreds->S4UTicketCache
        );


    //
    // Fill in the fields
    //

    Status = KerbDuplicateString(
                &NewCreds->UserName,
                UserString
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = KerbDuplicateString(
                &NewCreds->OldUserName,
                UserString
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbDuplicateString(
                &NewCreds->DomainName,
                DomainString
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = KerbDuplicateString(
                &NewCreds->OldDomainName,
                DomainString
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    if (!PubKeyCreds)
    {
        if (PasswordString->Buffer != NULL)
        {
            Status = KerbDuplicatePassword(
                        &NewCreds->ClearPassword,
                        PasswordString
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
            KerbHidePassword(
                &NewCreds->ClearPassword
                );

            RtlCalculateNtOwfPassword(
                        &NewCreds->ClearPassword,
                        &NewCreds->OldHashPassword
                        );
        }


        if (PasswordString->Buffer != NULL)
        {
            Status = KerbBuildPasswordList(
                        PasswordString,
                        UserString,
                        DomainString,
                        NULL,               // no supplied salt
                        NULL,               // no old password list
                        PrincipalName,
                        UserAccount,
                        PRIMARY_CRED_CLEAR_PASSWORD,
                        &NewCreds->Passwords
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        else
        {
            ULONG PasswordSize;
            ULONG Index;

            //
            // Compute the size of the passwords, which are assumed to be
            // marshalled in order.
            //

            if (LogonSession->PrimaryCredentials.Passwords != NULL)
            {
                PasswordSize = sizeof(KERB_STORED_CREDENTIAL) - sizeof(KERB_KEY_DATA) * ANYSIZE_ARRAY +
                                LogonSession->PrimaryCredentials.Passwords->CredentialCount * sizeof(KERB_KEY_DATA);

                for (Index = 0; Index < LogonSession->PrimaryCredentials.Passwords->CredentialCount ; Index++ )
                {
                    PasswordSize += LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.length;
                }

                NewCreds->Passwords = (PKERB_STORED_CREDENTIAL) KerbAllocate(PasswordSize);

                if (NewCreds->Passwords == NULL)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }
                NewCreds->Passwords->Revision = KERB_PRIMARY_CRED_REVISION;
                NewCreds->Passwords->Flags = 0;
                NewCreds->Passwords->OldCredentialCount = 0;

                //
                // Zero the salt so we don't accidentally re-use it.
                //

                RtlInitUnicodeString(
                    &NewCreds->Passwords->DefaultSalt,
                    NULL
                    );


                NewCreds->Passwords->CredentialCount = LogonSession->PrimaryCredentials.Passwords->CredentialCount;

                Where = (PUCHAR) &NewCreds->Passwords->Credentials[NewCreds->Passwords->CredentialCount];

                //
                // Copy all the old passwords.
                //


                for (Index = 0;
                     Index < (USHORT) (NewCreds->Passwords->CredentialCount) ;
                     Index++ )
                {
                    RtlInitUnicodeString(
                        &NewCreds->Passwords->Credentials[Index].Salt,
                        NULL
                        );
                    NewCreds->Passwords->Credentials[Index].Key =
                        LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key;
                    NewCreds->Passwords->Credentials[Index].Key.keyvalue.value = Where;
                    RtlCopyMemory(
                        Where,
                        LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.value,
                        LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.length
                        );
                    Where += LogonSession->PrimaryCredentials.Passwords->Credentials[Index].Key.keyvalue.length;

                }

            }
            else
            {
                D_DebugLog((DEB_ERROR,"Didn't supply enough credentials - no password available. %ws, line %d\n", THIS_FILE, __LINE__));
                Status = SEC_E_NO_CREDENTIALS;
                goto Cleanup;
            }
        }
    }
    else
    {
        // allocate the memory for the public key creds
        NewCreds->PublicKeyCreds  = (PKERB_PUBLIC_KEY_CREDENTIALS) KerbAllocate(sizeof(KERB_PUBLIC_KEY_CREDENTIALS));
        if (NULL == NewCreds->PublicKeyCreds)
        {
            D_DebugLog((DEB_ERROR,"Couldn't allocate public key creds\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }


        // the password is now considered the pin for the smartcard
        if (NULL == pCertContext)
        {
            D_DebugLog((DEB_ERROR,"Didn't supply enough credentials - no cert context available. %ws, line %d\n", THIS_FILE, __LINE__));
            Status = SEC_E_NO_CREDENTIALS;
            goto Cleanup;
        }

        (NewCreds->PublicKeyCreds)->CertContext = CertDuplicateCertificateContext(pCertContext);
        if (NULL == (NewCreds->PublicKeyCreds)->CertContext)
        {
            Status = STATUS_UNSUCCESSFUL;
            goto Cleanup;
        }

        if (PasswordString->Buffer != NULL)
        {
            Status = KerbDuplicatePassword(
                        &NewCreds->PublicKeyCreds->Pin,
                        PasswordString
                        );

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            KerbHidePassword(
                &NewCreds->PublicKeyCreds->Pin
                );
        }
        

        //
        // For non-joined machines, we have to make an assumption about the "best"
        // domain to try when we're getting a TGT.  Normally, UPNs are cracked at
        // the workstation's realm.  In this case, we formulate a guess from the DN
        // portion of the subject name.
        //
        // W/o this information, we should fail right here and log an event.
        //
        Role = KerbGetGlobalRole();

        if (Role == KerbRoleRealmlessWksta)
        {
            if (!KerbRetrieveDomainFromDn(
                        pCertContext,
                        &((NewCreds->PublicKeyCreds)->AlternateDomainName)
                        ))
            {
                Status = STATUS_INVALID_ACCOUNT_NAME;
                goto Cleanup;
            }

        }
    }

    *PrimaryCreds = NewCreds;
    NewCreds = NULL;
    Status = STATUS_SUCCESS;

Cleanup:
    if (NewCreds != NULL)
    {
        KerbFreePrimaryCredentials( NewCreds, TRUE );
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCaptureSuppliedCreds
//
//  Synopsis:   Captures a SEC_WINNT_AUTH_IDENTITY structure from
//              the client
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session that supplies the missing
//                      elements of the supplied creds.
//              AuthorizationData - Client address of auth data
//              SuppliedCreds - Returns constructed credentials, NULL for
//                      null session credentials.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCaptureSuppliedCreds(
    IN PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PVOID AuthorizationData,
    IN OPTIONAL PUNICODE_STRING PrincipalName,
    OUT PKERB_PRIMARY_CREDENTIAL * SuppliedCreds,
    OUT PULONG Flags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSEC_WINNT_AUTH_IDENTITY_EXW IdentityEx = NULL;
    SEC_WINNT_AUTH_IDENTITY_W LocalIdentity = {0};
    PSEC_WINNT_AUTH_IDENTITY_W AuthIdentity = NULL;
    PSEC_WINNT_AUTH_IDENTITY_W Credentials = NULL;
    BOOLEAN LogonSessionsLocked = FALSE;
    UNICODE_STRING UserString = {0};
    UNICODE_STRING DomainString = {0};
    UNICODE_STRING PasswordString = {0};
    BOOLEAN AnsiCreds = FALSE;
    BOOLEAN Marshalled = FALSE;
    ULONG CredSize;
    ULONG CredentialSize = 0;
    ULONG Offset = 0;
    PCERT_CONTEXT CertContext = NULL;
    BOOLEAN fSuppliedCertCred = FALSE;
    LUID    SystemLogonId = SYSTEM_LUID;

    // WOW64
    SEC_WINNT_AUTH_IDENTITY32 Cred32 = {0};
    SEC_WINNT_AUTH_IDENTITY_EX32 CredEx32 = {0};
    HANDLE TokenHandle = NULL;
    ULONG CallInfoAttributes = 0;

#if _WIN64
    SECPKG_CALL_INFO CallInfo;

    LsaFunctions->GetCallInfo( &CallInfo );
    CallInfoAttributes = CallInfo.Attributes;
#endif

    *SuppliedCreds = NULL;
    *Flags = 0;



    if (ARGUMENT_PRESENT(AuthorizationData))
    {
       SafeAllocaAllocate(IdentityEx, sizeof(SEC_WINNT_AUTH_IDENTITY_EXW));

       if (IdentityEx != NULL)
       {
          // We're being called from a WOW client!  Wow!
          if (CallInfoAttributes & SECPKG_CALL_WOWCLIENT)
          {
             Status = LsaFunctions->CopyFromClientBuffer(
                           NULL,
                           sizeof(Cred32),
                           IdentityEx,
                           AuthorizationData
                           );

             if (!NT_SUCCESS(Status))
             {
                D_DebugLog((DEB_ERROR, "Failed to capture WOW64 supplied cred structure - %x\n", Status));
                goto Cleanup;
             }
             else
             {
                RtlCopyMemory(&Cred32, IdentityEx, sizeof(Cred32));
             }
          }
          else
          {
              Status =  LsaFunctions->CopyFromClientBuffer(
                                           NULL,
                                           sizeof(SEC_WINNT_AUTH_IDENTITY),
                                           IdentityEx,
                                           AuthorizationData
                                           );

              if (!NT_SUCCESS(Status))
              {
                  D_DebugLog((DEB_ERROR, "Failed to copy auth data from %p client address: 0x%x. KLIN(%x)\n",
                          AuthorizationData, Status, KLIN(FILENO, __LINE__ )));
                  goto Cleanup;
              }
          }
       }
       else
       {
          Status = STATUS_INSUFFICIENT_RESOURCES;
          D_DebugLog((DEB_ERROR, "KLIN(%x) - Failed allocate\n", KLIN(FILENO, __LINE__)));
          goto Cleanup;
       }

       //
       // Check for extended structures
       //

       if (IdentityEx->Version == SEC_WINNT_AUTH_IDENTITY_VERSION)
       {
          if (CallInfoAttributes & SECPKG_CALL_WOWCLIENT)
          {
             Status = LsaFunctions->CopyFromClientBuffer(
                                       NULL,
                                       sizeof(CredEx32),
                                       &CredEx32,
                                       AuthorizationData
                                       );

             if (NT_SUCCESS(Status))
             {
                IdentityEx->Version = CredEx32.Version;
                IdentityEx->Length = (CredEx32.Length < sizeof(SEC_WINNT_AUTH_IDENTITY_EX) ?
                                      (ULONG) sizeof(SEC_WINNT_AUTH_IDENTITY_EX) : CredEx32.Length);

                IdentityEx->UserLength = CredEx32.UserLength;
                IdentityEx->User = (PWSTR) UlongToPtr(CredEx32.User);
                IdentityEx->DomainLength = CredEx32.DomainLength ;
                IdentityEx->Domain = (PWSTR) UlongToPtr( CredEx32.Domain );
                IdentityEx->PasswordLength = CredEx32.PasswordLength ;
                IdentityEx->Password = (PWSTR) UlongToPtr( CredEx32.Password );
                IdentityEx->Flags = CredEx32.Flags ;
                IdentityEx->PackageListLength = CredEx32.PackageListLength ;
                IdentityEx->PackageList = (PWSTR) UlongToPtr( CredEx32.PackageList );
             }
             else
             {
                  D_DebugLog((DEB_ERROR, "Failed to capture WOW64 supplied credEX structure - %x\n", Status));
                  goto Cleanup;
             }
          }
          else // not WOW64
          {

             Status = LsaFunctions->CopyFromClientBuffer(
                                     NULL,
                                     sizeof(SEC_WINNT_AUTH_IDENTITY_EXW),
                                     IdentityEx,
                                     AuthorizationData
                                     );

              if (!NT_SUCCESS(Status))
              {
                   D_DebugLog((DEB_ERROR, "Failed to capture supplied EX structure - %x\n", Status));
                   goto Cleanup;
              }
          }

          AuthIdentity = (PSEC_WINNT_AUTH_IDENTITY) &IdentityEx->User ;
          CredSize = IdentityEx->Length ;
          Offset = FIELD_OFFSET(SEC_WINNT_AUTH_IDENTITY_EXW, User);
       }
       else // not Extended version
       {
          AuthIdentity = (PSEC_WINNT_AUTH_IDENTITY) IdentityEx ;
          if (CallInfoAttributes & SECPKG_CALL_WOWCLIENT)
          {
             AuthIdentity->User = (PWSTR) UlongToPtr(Cred32.User);
             AuthIdentity->UserLength = Cred32.UserLength;
             AuthIdentity->Domain = (PWSTR) UlongToPtr(Cred32.Domain);
             AuthIdentity->DomainLength = Cred32.DomainLength ;
             AuthIdentity->Password = (PWSTR) UlongToPtr(Cred32.Password);
             AuthIdentity->PasswordLength = Cred32.PasswordLength ;
             AuthIdentity->Flags = Cred32.Flags ;
          }
          CredSize = sizeof(SEC_WINNT_AUTH_IDENTITY_W);
       }



       //
       // Check for the no-pac flag
       //

       if ((AuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_ONLY) != 0)
       {
          //
          // This may mean that we need to get a new TGT even though
          // we really just need to drop the PAC from an existing one.
          // This could cause problems in the smart card case
          // MMS 6/1/98
          //

          *Flags |= KERB_CRED_NO_PAC;
       }

       //
       // Check for ANSI structures.
       //

       if ((AuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI) != 0)
       {
          AnsiCreds = TRUE;

          //
          // Turn off the marshalled flag because we don't support marshalling
          // with ansi.
          //

          AuthIdentity->Flags &= ~SEC_WINNT_AUTH_IDENTITY_MARSHALLED;
       }
       else if ((AuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE) == 0)
       {
          Status = STATUS_INVALID_PARAMETER;
          goto Cleanup;
       }

       //
       // Check to see if this is a null session request.
       //

       if ((AuthIdentity->UserLength == 0) &&
           (AuthIdentity->DomainLength == 0) &&
           (AuthIdentity->PasswordLength == 0) )
       {
          if ((AuthIdentity->User != NULL)  &&
              (AuthIdentity->Domain != NULL)  &&
              (AuthIdentity->Password != NULL) )
          {
             //
             // Return NULL credentials in this case.
             //

             *Flags |= KERB_CRED_NULL_SESSION;
             Status = STATUS_SUCCESS;
             goto Cleanup;
          }

          if ((AuthIdentity->User == NULL)  &&
              (AuthIdentity->Domain == NULL)  &&
              (AuthIdentity->Password == NULL) &&
              (*Flags == 0))
           {
               //
               // Use default credentials
               //

               Status = STATUS_SUCCESS;
               D_DebugLog((DEB_TRACE_CRED, "Using default credentials\n"));
               goto Cleanup;
          }
       }

       //
       // If the identity is marshalled, copy it all at once.
       //

       if ((AuthIdentity->Flags & SEC_WINNT_AUTH_IDENTITY_MARSHALLED) != 0)
       {
          ULONG_PTR EndOfCreds;
          Marshalled = TRUE;

          //
          // Check for validity of the sizes.
          //

          if(
            // may be a marshalled username cred > UNLEN
            (AuthIdentity->UserLength > 0xFFFC) ||  // MAX_USHORT - NULL
            (AuthIdentity->DomainLength > DNS_MAX_NAME_LENGTH) ||
            (AuthIdentity->PasswordLength > PWLEN))
          {
             D_DebugLog((DEB_ERROR, "Either UserLength, DomainLength pr PasswordLength in supplied credentials has invalid length. %ws, line %d\n", THIS_FILE, __LINE__));
             Status = STATUS_INVALID_PARAMETER;
             goto Cleanup;
          }

          //
          // The callers can set the length of field to n chars, but they
          // will really occupy n+1 chars (null-terminator).
          //

          CredentialSize = CredSize +
             (  AuthIdentity->UserLength +
                AuthIdentity->DomainLength +
                AuthIdentity->PasswordLength +
                (((AuthIdentity->User != NULL) ? 1 : 0) +
                 ((AuthIdentity->Domain != NULL) ? 1 : 0) +
                 ((AuthIdentity->Password != NULL) ? 1 : 0)) ) * (ULONG) sizeof(WCHAR);

          EndOfCreds = (ULONG_PTR) AuthorizationData + CredentialSize;

          //
          // Verify that all the offsets are valid and no overflow will happen
          //

          ULONG_PTR TmpUser = (ULONG_PTR) AuthIdentity->User;

          if ((TmpUser != NULL) &&
              ( (TmpUser < (ULONG_PTR) AuthorizationData) ||
                (TmpUser > EndOfCreds) ||
                ((TmpUser + (AuthIdentity->UserLength) * sizeof(WCHAR)) > EndOfCreds ) ||
                ((TmpUser + (AuthIdentity->UserLength * sizeof(WCHAR))) < TmpUser)))
          {
             D_DebugLog((DEB_ERROR, "Username in supplied credentials has invalid pointer or length. %ws, line %d\n", THIS_FILE, __LINE__));
             Status = STATUS_INVALID_PARAMETER;
             goto Cleanup;
          }

          ULONG_PTR TmpDomain = (ULONG_PTR) AuthIdentity->Domain;

          if ((TmpDomain != NULL) &&
              ( (TmpDomain < (ULONG_PTR) AuthorizationData) ||
                (TmpDomain > EndOfCreds) ||
                ((TmpDomain + (AuthIdentity->DomainLength) * sizeof(WCHAR)) > EndOfCreds ) ||
                ((TmpDomain + (AuthIdentity->DomainLength * sizeof(WCHAR))) < TmpDomain)))
          {
             D_DebugLog((DEB_ERROR, "Domainname in supplied credentials has invalid pointer or length. %ws, line %d\n", THIS_FILE, __LINE__));
             Status = STATUS_INVALID_PARAMETER;
             goto Cleanup;
          }

          ULONG_PTR TmpPassword = (ULONG_PTR) AuthIdentity->Password;

          if ((TmpPassword != NULL) &&
              ( (TmpPassword < (ULONG_PTR) AuthorizationData) ||
                (TmpPassword > EndOfCreds) ||
                ((TmpPassword + (AuthIdentity->PasswordLength) * sizeof(WCHAR)) > EndOfCreds ) ||
                ((TmpPassword + (AuthIdentity->PasswordLength * sizeof(WCHAR))) < TmpPassword)))
          {
             D_DebugLog((DEB_ERROR, "Password in supplied credentials has invalid pointer or length. %ws, line %d\n", THIS_FILE, __LINE__));
             Status = STATUS_INVALID_PARAMETER;
             goto Cleanup;
          }

          //
          // Allocate a chunk of memory for the credentials
          //

          SafeAllocaAllocate(Credentials, CredentialSize - Offset);

          if (Credentials == NULL)
          {
             Status = STATUS_INSUFFICIENT_RESOURCES;
             goto Cleanup;
          }

          RtlCopyMemory(
             Credentials,
             AuthIdentity,
             sizeof(SEC_WINNT_AUTH_IDENTITY_W)
             );

          //
          // Copy the credentials from the client
          //

          Status = LsaFunctions->CopyFromClientBuffer(
             NULL,
             CredentialSize - (Offset + sizeof(SEC_WINNT_AUTH_IDENTITY_W)),
             (PUCHAR) Credentials + sizeof(SEC_WINNT_AUTH_IDENTITY_W),
             (PUCHAR) AuthorizationData + Offset + sizeof(SEC_WINNT_AUTH_IDENTITY_W)
             );
          if (!NT_SUCCESS(Status))
          {
             D_DebugLog((DEB_ERROR, "Failed to copy whole auth identity: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
             goto Cleanup;
          }

          //
          // Now convert all the offsets to pointers.
          //

          if (Credentials->User != NULL)
          {
             Credentials->User = (LPWSTR) RtlOffsetToPointer(
                Credentials->User,
                (PUCHAR) Credentials - (PUCHAR) AuthorizationData - Offset
                );
             UserString.Buffer = Credentials->User;
             UserString.Length = UserString.MaximumLength =
                (USHORT) Credentials->UserLength * sizeof(WCHAR);
          }

          if (Credentials->Domain != NULL)
          {
             Credentials->Domain = (LPWSTR) RtlOffsetToPointer(
                Credentials->Domain,
                (PUCHAR) Credentials - (PUCHAR) AuthorizationData - Offset
                );
             DomainString.Buffer = Credentials->Domain;
             DomainString.Length = DomainString.MaximumLength = (USHORT) Credentials->DomainLength * sizeof(WCHAR);
          }

          if (Credentials->Password != NULL)
          {
             Credentials->Password = (LPWSTR) RtlOffsetToPointer(
                Credentials->Password,
                (PUCHAR) Credentials - (PUCHAR) AuthorizationData - Offset
                );
             PasswordString.Buffer = Credentials->Password;
             PasswordString.Length = PasswordString.MaximumLength = (USHORT)
             Credentials->PasswordLength * sizeof(WCHAR);

          }

       }
       else
       {
          //
          // Here we need to copy the pointer individually
          //

          if (AuthIdentity->User != NULL)
          {
             Status = KerbCopyClientString(
                AuthIdentity->User,
                AuthIdentity->UserLength,
                AnsiCreds,
                &UserString,
                AuthIdentity->UserLength // may be marshalled username > UNLEN
                );

             if (!NT_SUCCESS(Status))
             {
                D_DebugLog((DEB_ERROR, "Failed to copy client user name. %ws, line %d\n", THIS_FILE, __LINE__));
                goto Cleanup;
             }
          }

          if (AuthIdentity->Domain != NULL)
          {
             Status = KerbCopyClientString(
                AuthIdentity->Domain,
                AuthIdentity->DomainLength,
                AnsiCreds,
                &DomainString,
                DNS_MAX_NAME_LENGTH
                );
             if (!NT_SUCCESS(Status))
             {
                D_DebugLog((DEB_ERROR, "Failed to copy client Domain name. %ws, line %d\n", THIS_FILE, __LINE__));
                goto Cleanup;
             }
          }

          if (AuthIdentity->Password != NULL)
          {
             Status = KerbCopyClientString(
                AuthIdentity->Password,
                AuthIdentity->PasswordLength,
                AnsiCreds,
                &PasswordString,
                PWLEN
                );

             if (!NT_SUCCESS(Status))
             {
                D_DebugLog((DEB_ERROR, "Failed to copy client Password name. %ws, line %d\n", THIS_FILE, __LINE__));
                goto Cleanup;
             }
          }

          Credentials = AuthIdentity;
       }

    }
    else
    {
       Credentials = &LocalIdentity;
       RtlZeroMemory(
          Credentials,
          sizeof(SEC_WINNT_AUTH_IDENTITY_W)
          );

    }

    //
    // Now build the supplied credentials.
    //

    DsysAssert( !LogonSessionsLocked );
    KerbReadLockLogonSessions(LogonSession);
    LogonSessionsLocked = TRUE;

    //
    // Compute the size of the new credentials
    //


    //
    // If a field is not present, use the field from the logon session
    //

    if (Credentials->User == NULL)
    {
        UserString = LogonSession->PrimaryCredentials.UserName;
    }

    D_DebugLog((DEB_TRACE_CRED, "Using user %wZ\n", &UserString));

    if (Credentials->Domain == NULL)
    {
        ULONG Index;
        BOOLEAN Upn = FALSE;

        //
        // if it's a UPN and domain was NULL, supply an empty domain
        // rather than filling in the default.
        //

        for( Index = 0 ; Index < (UserString.Length/sizeof(WCHAR)) ; Index++ )
        {
            if( UserString.Buffer[ Index ] == L'@' )
            {
                Upn = TRUE;
                break;
            }
        }

        if( !Upn )
        {
            DomainString = LogonSession->PrimaryCredentials.DomainName;
        } else {
            RtlInitUnicodeString( &DomainString, L"" );
        }
    }
    else
    {
        if ((DomainString.Length > sizeof(WCHAR)) &&
            (DomainString.Buffer[-1 + DomainString.Length / sizeof(WCHAR)] == L'.') )
        {
            DomainString.Length -= sizeof(WCHAR);
        }
    }
    D_DebugLog((DEB_TRACE_CRED, "Using domain %wZ\n", &DomainString));

    //
    // Special case when no password is supplied, so its copied from 
    // the logon session.
    //
    if (Credentials->Password == NULL)
    {
        //
        // The password stored in the logon session is not a string
        // so don't copy it here.
        //

        PasswordString.Buffer = NULL;
        PasswordString.Length = 0;

        //
        // Special case hack for some apps using NTLM hack of machinename$.
        // This allows us to use default creds after they've been changed, and
        // is a one-off piece of functionality for .Net - make a better sol'n
        // with credential reworking in Longhorn.
        //
        if (  RtlEqualLuid( &LogonSession->LogonId, &SystemLogonId ) &&
              RtlEqualUnicodeString( &KerbGlobalMachineServiceName, &UserString, TRUE ))
        {  
            D_DebugLog((DEB_TRACE_CRED, "Getting cred handle for LS$ special case\n"));
            *Flags |=  KERB_CRED_LS_DEFAULT;
        }  
    }

    //
    // Check if the user name holds a cert context thumbprint
    //

    Status = KerbCheckUserNameForCert(
                    &LogonSession->LogonId,
                    FALSE,
                    &UserString,
                    &CertContext
                    );

    if (NT_SUCCESS(Status))
    {
        if (NULL != CertContext)
        {
            fSuppliedCertCred = TRUE;
        }
    }
    else
    {
        goto Cleanup;
    }

    if (fSuppliedCertCred)
    {
        //
        // Generate the PK credentials for a smart card cert
        //
        Status = KerbAddCertCredToPrimaryCredential(
                    LogonSession,
                    PrincipalName,
                    CertContext,
                    &PasswordString,
                    CONTEXT_INITIALIZED_WITH_ACH,
                    SuppliedCreds
                    );
        if (NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
    else
    {
        // setup the primary creds structure
        Status = KerbInitPrimaryCreds(
                    LogonSession,
                    &UserString,
                    &DomainString,
                    PrincipalName,
                    &PasswordString,
                    FALSE,
                    NULL,
                    SuppliedCreds);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }

Cleanup:
    if (NULL != CertContext)
    {
        CertFreeCertificateContext(CertContext);
    }

    if (LogonSessionsLocked)
    {
        KerbUnlockLogonSessions(LogonSession);
    }

    //
    // Zero the password
    //

    if (PasswordString.Buffer != NULL)
    {
        RtlSecureZeroMemory(
            PasswordString.Buffer,
            PasswordString.Length
            );

    }
    if (AuthIdentity != NULL)
    {
        if (AnsiCreds)
        {
            if ((AuthIdentity->Password != NULL) && (PasswordString.Buffer != NULL))
            {
                RtlSecureZeroMemory(
                    PasswordString.Buffer,
                    PasswordString.Length
                    );
                RtlFreeUnicodeString(&PasswordString);
            }
            if ((AuthIdentity->User != NULL) && (UserString.Buffer != NULL))
            {
                RtlFreeUnicodeString(&UserString);
            }
            if ((AuthIdentity->Domain != NULL) && (DomainString.Buffer != NULL))
            {
                RtlFreeUnicodeString(&DomainString);
            }
        }
        else if (!Marshalled)
        {
            if ((AuthIdentity->Password != NULL) && (PasswordString.Buffer != NULL))
            {
                KerbFree(PasswordString.Buffer);
            }
            if ((AuthIdentity->User != NULL) && (UserString.Buffer != NULL))
            {
                KerbFree(UserString.Buffer);
            }
            if ((AuthIdentity->Domain != NULL) && (DomainString.Buffer != NULL))
            {
                KerbFree(DomainString.Buffer);
            }

        }
    }

    if ((Credentials != NULL)
        && (Credentials != AuthIdentity)
        && (Credentials != &LocalIdentity))
    {
        SafeAllocaFree(Credentials);
    }

    SafeAllocaFree(IdentityEx);

    if ( TokenHandle != NULL )
    {
        CloseHandle( TokenHandle );
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   SpAcceptCredentials
//
//  Synopsis:   This routine is called after another package has logged
//              a user on.  The other package provides a user name and
//              password and the Kerberos package will create a logon
//              session for this user.
//
//  Effects:    Creates a logon session
//
//  Arguments:  LogonType - Type of logon, such as network or interactive
//              Accountname - Name of the account that logged on
//              PrimaryCredentials - Primary Credentials for the account,
//                  containing a domain name, password, SID, etc.
//              SupplementalCredentials - Kerberos-Specific blob of
//                  supplemental Credentials.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
SpAcceptCredentials(
    IN SECURITY_LOGON_TYPE LogonType,
    IN PUNICODE_STRING AccountName,
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN PSECPKG_SUPPLEMENTAL_CRED SupplementalCredentials
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_LOGON_SESSION LogonSession = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;
    PUNICODE_STRING RealmName;
    PUNICODE_STRING UserName;
    UNICODE_STRING TempRealm = {0};
    UNICODE_STRING TempUser = {0};
    PKERB_MIT_REALM MitRealm = NULL;
    BOOLEAN UsedAlternateName = FALSE;
    LUID SystemLogonId = SYSTEM_LUID;
    LUID NetworkServiceLogonId = NETWORKSERVICE_LUID;   

    D_DebugLog((DEB_TRACE_API, "SpAcceptCredentials called\n"));

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_INVALID_SERVER_STATE;
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE_CRED, 
        "SpAcceptCredentials accepting credentials for %#x:%#x, flag %#x, "
        "logon type %#x, %wZ\\%wZ or %wZ at %wZ\n",
        PrimaryCredentials->LogonId.HighPart, PrimaryCredentials->LogonId.LowPart,
        PrimaryCredentials->Flags,
        LogonType,
        &PrimaryCredentials->DomainName,
        &PrimaryCredentials->DownlevelName,
        &PrimaryCredentials->Upn,
        &PrimaryCredentials->DnsDomainName));

    LogonSession = KerbReferenceLogonSession(
                        &PrimaryCredentials->LogonId,
                        FALSE                           // don't unlink
                        );

    //
    // If this is an update, locate the credentials & update the password
    //

    if ((PrimaryCredentials->Flags & PRIMARY_CRED_UPDATE) != 0)
    {
        KERB_ACCOUNT_TYPE AccountType;
        LUID SystemLuid = SYSTEM_LUID;

        if (LogonSession == NULL)
        {
            goto Cleanup;
        }

        if(RtlEqualLuid(&PrimaryCredentials->LogonId, &SystemLuid))
        {
            AccountType = MachineAccount;
        } else {
            AccountType = UserAccount;
        }

        KerbWriteLockLogonSessions(LogonSession);
        Status = KerbChangeCredentialsPassword(
                    &LogonSession->PrimaryCredentials,
                    &PrimaryCredentials->Password,
                    NULL,                               // no etype info
                    AccountType,
                    PrimaryCredentials->Flags
                    );

        if(NT_SUCCESS(Status))
        {
            if( AccountType == MachineAccount )
            {
                LogonSession->LogonSessionFlags &= ~(KERB_LOGON_LOCAL_ONLY | KERB_LOGON_NO_PASSWORD);
            }
        }

        KerbUnlockLogonSessions(LogonSession);

        goto Cleanup;

    }

    //
    // This is not an update.  If we got a Logon session back from the
    // reference call, bail out now.  This is an extra call because we
    // are doing an MIT logon
    //

    if ( LogonSession )
    {
        if (RtlEqualLuid(&PrimaryCredentials->LogonId, &SystemLogonId))
        {
           D_DebugLog(( DEB_ERROR, "Somebody created a logon session for machine account\n"));
        }

        D_DebugLog(( DEB_TRACE_CRED, "Skipping AcceptCred for %wZ\\%wZ (%x:%x)\n",
                &PrimaryCredentials->DomainName,
                &PrimaryCredentials->DownlevelName,
                PrimaryCredentials->LogonId.HighPart,
                PrimaryCredentials->LogonId.LowPart ));

        goto Cleanup;

    }

    //
    // Check to see if the domain is an alias for another realm.
    //

    if (RtlEqualLuid(&PrimaryCredentials->LogonId, &SystemLogonId)
        || RtlEqualLuid(&PrimaryCredentials->LogonId, &NetworkServiceLogonId))
    {
        KerbGlobalReadLock();
        if (KerbLookupMitRealm(
                        &KerbGlobalDnsDomainName,
                        &MitRealm,
                        &UsedAlternateName))
         {

            KerbErr = KerbConvertKdcNameToString(
                        &TempUser,
                        KerbGlobalMitMachineServiceName,
                        NULL
                        );
            KerbGlobalReleaseLock();

            if (!KERB_SUCCESS(KerbErr))
            {
                Status = KerbMapKerbError(KerbErr);
                goto Cleanup;
            }
            UserName = &TempUser;

            RealmName = &MitRealm->RealmName;
        }
        else
        {
            KerbGlobalReleaseLock();
            UserName = &PrimaryCredentials->DownlevelName;
            Status = KerbGetOurDomainName(
                        &TempRealm
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
            if (TempRealm.Length != 0)
            {
                RealmName = &TempRealm;
            }
            else
            {   
                RealmName = &PrimaryCredentials->DomainName;
            }
        }
    }
    else
    {
        if (PrimaryCredentials->Upn.Length != 0)
        {
            // UPNs can't have a realm in credential.
            RealmName = &TempRealm;
            UserName = &PrimaryCredentials->Upn;
        }
        else
        {
            RealmName = &PrimaryCredentials->DomainName;
            UserName = &PrimaryCredentials->DownlevelName;
        }
    }

    Status = KerbCreateLogonSession(
                &PrimaryCredentials->LogonId,
                UserName,
                RealmName,
                &PrimaryCredentials->Password,
                &PrimaryCredentials->OldPassword,
                PrimaryCredentials->Flags,
                LogonType == NewCredentials ? KERB_LOGON_NEW_CREDENTIALS : 0,
                FALSE,
                &LogonSession
                );


    if (!NT_SUCCESS(Status))
    {
        //
        //  If we know about the logon session, that is o.k. because we
        // probably handled the logon.
        //

        if (Status == STATUS_OBJECT_NAME_EXISTS)
        {
            Status = STATUS_SUCCESS;
            if (RtlEqualLuid(&PrimaryCredentials->LogonId,&SystemLogonId))
            {
               D_DebugLog(( DEB_ERROR, "Somebody called AcquireCredentialsHandle before AcceptCredentials completed.\n"));
            }
        }
        goto Cleanup;
    }


Cleanup:

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }
    KerbFreeString(&TempRealm);
    KerbFreeString(&TempUser);

    D_DebugLog((DEB_TRACE_API, "SpAcceptCredentials returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}


//+-------------------------------------------------------------------------
//
//  Function:   SpAcquireCredentialsHandle
//
//  Synopsis:   Contains Kerberos Code for AcquireCredentialsHandle which
//              creates a Credential associated with a logon session.
//
//  Effects:    Creates a KERB_CREDENTIAL
//
//  Arguments:  PrincipalName - Name of logon session for which to create credential
//              CredentialUseFlags - Flags indicating whether the Credentials
//                  is for inbound or outbound use.
//              LogonId - The logon ID of logon session for which to create
//                  a credential.
//              AuthorizationData - Unused blob of Kerberos-specific data
//              GetKeyFunction - Unused function to retrieve a session key
//              GetKeyArgument - Argument for GetKeyFunction
//              CredentialHandle - Receives handle to new credential
//              ExpirationTime - Receives expiration time for credential
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpAcquireCredentialsHandle(
    IN OPTIONAL PUNICODE_STRING PrincipalName,
    IN ULONG CredentialUseFlags,
    IN OPTIONAL PLUID LogonId,
    IN PVOID AuthorizationData,
    IN PVOID GetKeyFunction,
    IN PVOID GetKeyArgument,
    OUT PLSA_SEC_HANDLE CredentialHandle,
    OUT PTimeStamp ExpirationTime
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonIdToUse = NULL;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_CREDENTIAL Credential = NULL;
    PKERB_PRIMARY_CREDENTIAL SuppliedCreds = NULL;
    UNICODE_STRING CapturedPrincipalName = {0};
    ULONG CredentialFlags = 0;
    LUID SystemLogonId = SYSTEM_LUID;
    LUID AnonymousLogonId = ANONYMOUS_LOGON_LUID;
    LUID LocalServiceLogonId = LOCALSERVICE_LUID;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    BOOLEAN                      Impersonating = FALSE;
    HANDLE                       hProcess = NULL;

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_INVALID_SERVER_STATE;
        ClientInfo.ProcessID = 0;
        goto Cleanup;
    }

    //
    // Kerberos does not support acquiring Credentials handle by name
    // so first locate the logon session to use.
    //

    //
    // First get information about the caller.
    //

    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR, "Failed to get client information: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }
    else if ((ClientInfo.ClientFlags & SECPKG_CLIENT_THREAD_TERMINATED) != 0)
    {
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }


    //
    // If the caller supplied a logon ID they must have the TCB privilege
    //

    if (ARGUMENT_PRESENT(LogonId) && ((LogonId->LowPart != 0) || (LogonId->HighPart != 0)))
    {
        if (!ClientInfo.HasTcbPrivilege)
        {
            Status = STATUS_PRIVILEGE_NOT_HELD;
            goto Cleanup;
        }
        LogonIdToUse = LogonId;
    }
    else
    {
        //
        // Use the callers logon id.
        //

        LogonIdToUse = &ClientInfo.LogonId;

    }

    ImpersonationLevel = ClientInfo.ImpersonationLevel;
    Impersonating = ClientInfo.Impersonating;
    hProcess = (HANDLE) LongToHandle(ClientInfo.ProcessID);


    D_DebugLog((DEB_TRACE_API, "SpAcquireCredentialsHandle for pid 0x%x, luid (%x:%x) called\n", ClientInfo.ProcessID,
                ((LogonIdToUse==NULL) ? 0xffffffff : LogonIdToUse->HighPart),
                ((LogonIdToUse==NULL) ? 0xffffffff : LogonIdToUse->LowPart)));

    //
    // Now try to reference the logon session with this logon id.
    //

    LogonSession = KerbReferenceLogonSession(
                        LogonIdToUse,
                        FALSE           // don't unlink
                        );

    if (LogonSession == NULL)
    {

        //
        // Enforce that the caller has > Impersonation level token.
        // This is because we don't have an S4U Logon session, which is
        // the only way we can try for S4UProxy w/o having TCB.
        //
        if (ClientInfo.ImpersonationLevel <= SecurityIdentification)
        {
            DebugLog((DEB_ERROR, "Trying to acquire credentials with an token no better than SecurityIdentification\n"));
            Status = SEC_E_NO_CREDENTIALS;
            goto Cleanup;
        }           

        //
        // If we're getting called from anonymous, local service, or deferred
        // local system logon, fail here.  Additionally, if we're missing a given
        // logon session, && we're not impersonating, then there's something
        // wrong as processes need to have a logon session that we should have
        // been informed of.
        //
        if ((( RtlEqualLuid(LogonIdToUse,&SystemLogonId) ) ||
            ( RtlEqualLuid(LogonIdToUse, &AnonymousLogonId) ) ||
            ( RtlEqualLuid(LogonIdToUse, &LocalServiceLogonId) ) ||
             !Impersonating ) && AuthorizationData == NULL)

        {
           D_DebugLog((DEB_TRACE_CRED,
               "SpAcquireCredentialsHandle called for unknown logon session %#x:%#x, Impersonating ? %s, AuthorizationData %p\n",
                LogonIdToUse->HighPart, LogonIdToUse->LowPart, Impersonating ? "true" : "false", AuthorizationData));
           Status = STATUS_NO_SUCH_LOGON_SESSION;
           goto Cleanup;
        }

        //
        // This is a logon session that we don't know about - rather than creating
        // a dummy logon session for "every ASC", we let the lsa keep track,
        // then we create a new one, if needed.
        //
        Status = KerbCreateDummyLogonSession(
                        LogonIdToUse,
                        &LogonSession,
                        ImpersonationLevel,
                        Impersonating,
                        hProcess
                        );

        if (!NT_SUCCESS( Status ))
        {
            Status = STATUS_NO_SUCH_LOGON_SESSION;
            goto Cleanup;
        }
    }
    else if (ClientInfo.ImpersonationLevel <= SecurityIdentification)
    {
        D_DebugLog((DEB_TRACE_CRED, "Got identify token on ls %p\n", LogonSession)); 

        //
        // If we have supplied authorization data, fail the request in the "old"
        // way - e.g. we only allow logon sessions originating from S4USelf to
        // be used with an identify level token.  This is the way things behaved
        // in previous releases.
        //
        KerbReadLockLogonSessions(LogonSession);
        if ( AuthorizationData != NULL  ||
           (( LogonSession->LogonSessionFlags & KERB_LOGON_S4U_SESSION ) == 0))
        {
            DebugLog((DEB_ERROR, "ACH called w identify + !s4u or w pvauth\n"));
            KerbUnlockLogonSessions(LogonSession);
            Status = SEC_E_NO_CREDENTIALS;
            goto Cleanup;
        }
        KerbUnlockLogonSessions(LogonSession);    
    }
                                                  

#if DBG
    KerbReadLockLogonSessions(LogonSession);
    D_DebugLog((DEB_TRACE_CTXT, "SpAcquireCredHandle: Acquiring creds for %wZ\\%wZ\n",
        &LogonSession->PrimaryCredentials.DomainName,
        &LogonSession->PrimaryCredentials.UserName ));
    KerbUnlockLogonSessions(LogonSession);
#endif

    //
    // Check for supplied Credentials
    //

    if (ARGUMENT_PRESENT(AuthorizationData))
    {
         Status = KerbCaptureSuppliedCreds(
                    LogonSession,
                    AuthorizationData,
                    PrincipalName,
                    &SuppliedCreds,
                    &CredentialFlags
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "Failed to capture auth data: 0x%x. %ws, line %d\n", Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        if ((SuppliedCreds == NULL) && RtlEqualLuid(LogonIdToUse, &AnonymousLogonId))
        {
            D_DebugLog((DEB_ERROR, "SpAcquireCredentialsHandle can not have anonymous with no explicit creds: %ws, line %d\n", THIS_FILE, __LINE__));
            Status = STATUS_NO_SUCH_LOGON_SESSION;
            goto Cleanup;
        }
    }

    //
    // if there was a supplied principal name, put it into the credential
    //

    if (ARGUMENT_PRESENT(PrincipalName) && (PrincipalName->Length != 0))
    {
        Status = KerbDuplicateString(
                    &CapturedPrincipalName,
                    PrincipalName
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }


    
    //
    // We found the logon session. Good. Now create a new Credentials.
    //


    Status = KerbCreateCredential(
                LogonIdToUse,
                LogonSession,
                CredentialUseFlags,
                &SuppliedCreds,
                CredentialFlags,
                &CapturedPrincipalName,
                &Credential,
                ExpirationTime
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_WARN,"Failed to create credential: 0x%x\n",Status));
        goto Cleanup;
    }

    CapturedPrincipalName.Buffer = NULL;


    //
    // If the client is a restricted token, observe that here
    // Note:  This has been punted to Blackcomb
#ifdef RESTRICTED_TOKEN
    if (ClientInfo.Restricted)
    {
        Credential->CredentialFlags |= KERB_CRED_RESTRICTED;
        D_DebugLog((DEB_TRACE_API,"Adding token restrictions\n"));

        //
        // We don't let restricted processes accept connections
        //
        if ((CredentialUseFlags & SECPKG_CRED_INBOUND) != 0)
        {
            DebugLog((DEB_ERROR,"Restricted token trying to acquire inbound credentials - denied\n"));
            Status = STATUS_ACCESS_DENIED;
            goto Cleanup;
        }

        Status = KerbAddRestrictionsToCredential(
                    LogonSession,
                    Credential
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to add restrictions to credential: 0x%x\n",Status));
            goto Cleanup;
        }
    }

#endif

    *CredentialHandle = KerbGetCredentialHandle(Credential);

    KerbUtcTimeToLocalTime(
        ExpirationTime,
        ExpirationTime
        );

    D_DebugLog((DEB_TRACE_API, "SpAcquireCredentialsHandle returning success, handle = 0x%x\n",*CredentialHandle));

Cleanup:
    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }
    if (Credential != NULL)
    {
        KerbDereferenceCredential(Credential);
    }
    if (SuppliedCreds != NULL)
    {
        KerbFreePrimaryCredentials( SuppliedCreds, TRUE );
    }

    KerbFreeString(&CapturedPrincipalName);

    D_DebugLog((DEB_TRACE_API, "SpAcquireCredentialsHandle for pid 0x%x, luid (%x:%x) returned 0x%x\n",
        ClientInfo.ProcessID,
        ((LogonIdToUse==NULL) ? 0xffffffff : LogonIdToUse->HighPart),
        ((LogonIdToUse == NULL) ? 0xffffffff : LogonIdToUse->LowPart), KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}


//+-------------------------------------------------------------------------
//
//  Function:   SpFreeCredentialsHandle
//
//  Synopsis:   Frees a credential created by AcquireCredentialsHandle.
//
//  Effects:    Unlinks the credential from the global list and the list
//              for this client.
//
//  Arguments:  CredentialHandle - Handle to the credential to free
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success,
//              SEC_E_INVALID_HANDLE if the handle is not valid
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpFreeCredentialsHandle(
    IN LSA_SEC_HANDLE CredentialHandle
    )
{
    NTSTATUS Status;
    PKERB_CREDENTIAL Credential;

    D_DebugLog((DEB_TRACE_API,"SpFreeCredentialsHandle 0x%x called\n",CredentialHandle));

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_INVALID_SERVER_STATE;
        goto Cleanup;
    }

    Status = KerbReferenceCredential(
                    CredentialHandle,
                    0,                          // no flags
                    TRUE,                       // unlink handle
                    &Credential
                    );

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"SpFreeCredentialsHandle: Failed to reference credential 0x%0x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Now dereference the credential. If nobody else is using this credential
    // currently it will be freed.
    //

    KerbDereferenceCredential(Credential);
    Status = STATUS_SUCCESS;

Cleanup:

    D_DebugLog((DEB_TRACE_API, "SpFreeCredentialsHandle returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}



//+-------------------------------------------------------------------------
//
//  Function:   SpQueryCredentialsAttributes
//
//  Synopsis:   Returns attributes of a credential
//
//  Effects:    allocate memory in client address space
//
//  Arguments:  CredentialHandle - handle to query
//              CredentialAttribute - Attribute to query:
//                      SECPKG_CRED_ATTR_NAMES - returns credential name
//              Buffer - points to structure in client's address space
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
SpQueryCredentialsAttributes(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN ULONG CredentialAttribute,
    IN OUT PVOID Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CREDENTIAL Credential = NULL;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_PRIMARY_CREDENTIAL PrimaryCredentials;
    LUID LogonId;
    UNICODE_STRING FullServiceName = { 0 } ;
    SecPkgCredentials_NamesW Names;

#if _WIN64
    SECPKG_CALL_INFO CallInfo;
#endif

    Names.sUserName = NULL;

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_INVALID_SERVER_STATE;
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE_API,"SpQueryCredentialsAttributes Called\n"));


    Status = KerbReferenceCredential(
                    CredentialHandle,
                    0,                          // no flags
                    FALSE,                       // don't unlink
                    &Credential
                    );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

#if _WIN64
    if(!LsaFunctions->GetCallInfo( &CallInfo ))
    {
        Status = STATUS_INTERNAL_ERROR;
        DebugLog((DEB_ERROR, "SpQueryCredentialsAttributes, failed to get callinfo 0x%lx\n", Status));
        goto Cleanup;
    }
#endif

    //
    // The logon id of the credential is constant, so it is o.k.
    // to use it without locking the credential
    //

    LogonId = Credential->LogonId;

    //
    // Get the associated logon session to get the name
    //

    LogonSession = KerbReferenceLogonSession(
                        &LogonId,
                        FALSE           // don't unlink
                        );
    if (LogonSession == NULL)
    {
        DebugLog((DEB_ERROR,"Failed to locate logon session for Credential. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = SEC_E_NO_CREDENTIALS;
        goto Cleanup;

    }

    if (CredentialAttribute != SECPKG_CRED_ATTR_NAMES)
    {
        D_DebugLog((DEB_WARN, "Asked for illegal info level in QueryCredAttr: %d\n",
                CredentialAttribute));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    KerbReadLockLogonSessions(LogonSession);

    //
    // Figure out which credentials to use
    //

    if (Credential->SuppliedCredentials != NULL)
    {
        PrimaryCredentials = Credential->SuppliedCredentials;
    }
    else
    {
        PrimaryCredentials = &LogonSession->PrimaryCredentials;
    }
    //
    // Build the full service name
    //


    if (!KERB_SUCCESS(KerbBuildEmailName(
                &PrimaryCredentials->DomainName,
                &PrimaryCredentials->UserName,
                &FullServiceName
                )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }


    KerbUnlockLogonSessions(LogonSession);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Allocate memory in the client's address space
    //

    Status = LsaFunctions->AllocateClientBuffer(
                NULL,
                FullServiceName.MaximumLength,
                (PVOID *) &Names.sUserName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Copy the string there
    //

    Status = LsaFunctions->CopyToClientBuffer(
                NULL,
                FullServiceName.MaximumLength,
                Names.sUserName,
                FullServiceName.Buffer
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Now copy the address of the string there
    //

#if _WIN64

    if( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT )
    {
        Status = LsaFunctions->CopyToClientBuffer(
                    NULL,
                    sizeof(ULONG),
                    Buffer,
                    &Names
                    );
    } else {

        Status = LsaFunctions->CopyToClientBuffer(
                    NULL,
                    sizeof(Names),
                    Buffer,
                    &Names
                    );
    }

#else

    Status = LsaFunctions->CopyToClientBuffer(
                NULL,
                sizeof(Names),
                Buffer,
                &Names
                );
#endif

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

Cleanup:

    if (Credential != NULL)
    {
        KerbDereferenceCredential(Credential);
    }
    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }
    KerbFreeString(
        &FullServiceName
        );

    if (!NT_SUCCESS(Status))
    {
        if (Names.sUserName != NULL)
        {
            (VOID) LsaFunctions->FreeClientBuffer(
                        NULL,
                        Names.sUserName
                        );
        }
    }

    D_DebugLog((DEB_TRACE_API, "SpQueryCredentialsAttribute returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}


NTSTATUS NTAPI
SpSaveCredentials(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN PSecBuffer Credentials
    )
{
    NTSTATUS Status = STATUS_NOT_SUPPORTED;
    D_DebugLog((DEB_TRACE_API,"SpSaveCredentials Called\n"));
    D_DebugLog((DEB_TRACE_API,"SpSaveCredentials returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));
    return(KerbMapKerbNtStatusToNtStatus(Status));
}


NTSTATUS NTAPI
SpGetCredentials(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN OUT PSecBuffer Credentials
    )
{
    NTSTATUS Status = STATUS_NOT_SUPPORTED;
    D_DebugLog((DEB_TRACE_API,"SpGetCredentials Called\n"));
    D_DebugLog((DEB_TRACE_API,"SpGetCredentials returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));
    return(KerbMapKerbNtStatusToNtStatus(Status));
}


NTSTATUS NTAPI
SpDeleteCredentials(
    IN LSA_SEC_HANDLE CredentialHandle,
    IN PSecBuffer Key
    )
{
    NTSTATUS Status = STATUS_NOT_SUPPORTED;
    D_DebugLog((DEB_TRACE_API,"SpDeleteCredentials Called\n"));
    D_DebugLog((DEB_TRACE_API,"SpDeleteCredentials returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));
    return(KerbMapKerbNtStatusToNtStatus(Status));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\ctxtmgr.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ctxtmgr.h
//
// Contents:    Structures and prototyps for Kerberos context list
//
//
// History:     17-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __CTXTMGR_H__
#define __CTXTMGR_H__

//
// All global variables declared as EXTERN will be allocated in the file
// that defines CTXTMGR_ALLOCATE
//
#ifdef EXTERN
#undef EXTERN
#endif

#ifdef CTXTMGR_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

#ifdef WIN32_CHICAGO
EXTERN CRITICAL_SECTION KerbContextResource;
#else // WIN32_CHICAGO
EXTERN SAFE_RESOURCE KerbContextResource;
#endif // WIN32_CHICAGO

#define     KERB_USERLIST_COUNT         (16)    // count of lists

EXTERN KERBEROS_LIST KerbContextList[ KERB_USERLIST_COUNT ];
EXTERN BOOLEAN KerberosContextsInitialized;

#define KerbGetContextHandle(_Context_) ((LSA_SEC_HANDLE)(_Context_))

//
// Context flags - these are attributes of a context and are stored in
// the ContextAttributes field of a KERB_CONTEXT.
//

#define KERB_CONTEXT_MAPPED                     0x1
#define KERB_CONTEXT_OUTBOUND                   0x2
#define KERB_CONTEXT_INBOUND                    0x4
#define KERB_CONTEXT_USED_SUPPLIED_CREDS        0x8
#define KERB_CONTEXT_USER_TO_USER               0x10
#define KERB_CONTEXT_REQ_SERVER_NAME            0x20
#define KERB_CONTEXT_REQ_SERVER_REALM           0x40
#define KERB_CONTEXT_IMPORTED                   0x80
#define KERB_CONTEXT_EXPORTED                   0x100
#define KERB_CONTEXT_USING_CREDMAN              0x200



//
// NOTICE: The logon session resource, credential resource, and context
// resource must all be acquired carefully to prevent deadlock. They
// can only be acquired in this order:
//
// 1. Logon Sessions
// 2. Credentials
// 3. Contexts
//

#if DBG
#ifdef WIN32_CHICAGO
#define KerbWriteLockContexts() \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Write locking Contexts\n")); \
    EnterCriticalSection(&KerbContextResource); \
    KerbGlobalContextsLocked = GetCurrentThreadId(); \
}
#define KerbReadLockContexts() \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Read locking Contexts\n")); \
    EnterCriticalSection(&KerbContextResource); \
    KerbGlobalContextsLocked = GetCurrentThreadId(); \
}
#define KerbUnlockContexts() \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Unlocking Contexts\n")); \
    KerbGlobalContextsLocked = 0; \
    LeaveCriticalSection(&KerbContextResource); \
}
#else // WIN32_CHICAGO
#define KerbWriteLockContexts() \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Write locking Contexts\n")); \
    SafeAcquireResourceExclusive(&KerbContextResource,TRUE); \
    KerbGlobalContextsLocked = GetCurrentThreadId(); \
}
#define KerbReadLockContexts() \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Read locking Contexts\n")); \
    SafeAcquireResourceShared(&KerbContextResource, TRUE); \
    KerbGlobalContextsLocked = GetCurrentThreadId(); \
}
#define KerbUnlockContexts() \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Unlocking Contexts\n")); \
    KerbGlobalContextsLocked = 0; \
    SafeReleaseResource(&KerbContextResource); \
}
#endif // WIN32_CHICAGO
#else
#ifdef WIN32_CHICAGO
#define KerbWriteLockContexts() \
    EnterCriticalSection(&KerbContextResource)
#define KerbReadLockContexts() \
    EnterCriticalSection(&KerbContextResource)
#define KerbUnlockContexts() \
    LeaveCriticalSection(&KerbContextResource)
#else // WIN32_CHICAGO
#define KerbWriteLockContexts() \
    SafeAcquireResourceExclusive(&KerbContextResource,TRUE);
#define KerbReadLockContexts() \
    SafeAcquireResourceShared(&KerbContextResource, TRUE);
#define KerbUnlockContexts() \
    SafeReleaseResource(&KerbContextResource);
#endif // WIN32_CHICAGO
#endif

NTSTATUS
KerbInitContextList(
    VOID
    );

VOID
KerbFreeContextList(
    VOID
    );


NTSTATUS
KerbAllocateContext(
    PKERB_CONTEXT * NewContext
    );

NTSTATUS
KerbInsertContext(
    IN PKERB_CONTEXT Context
    );


SECURITY_STATUS
KerbReferenceContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN BOOLEAN RemoveFromList,
    OUT PKERB_CONTEXT * FoundContext
    );


VOID
KerbDereferenceContext(
    IN PKERB_CONTEXT Context
    );


VOID
KerbReferenceContextByPointer(
    IN PKERB_CONTEXT Context,
    IN BOOLEAN RemoveFromList
    );


NTSTATUS
KerbCreateClientContext(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN OPTIONAL PKERB_TICKET_CACHE_ENTRY TicketCacheEntry,
    IN OPTIONAL PUNICODE_STRING TargetName,
    IN ULONG Nonce,
    IN PTimeStamp pAuthenticatorTime,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    IN OPTIONAL PKERB_ENCRYPTION_KEY SubSessionKey,
    OUT PKERB_CONTEXT * NewContext,
    OUT PTimeStamp ContextLifetime
    );

NTSTATUS
KerbCreateServerContext(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN PKERB_ENCRYPTED_TICKET InternalTicket,
    IN PKERB_AP_REQUEST ApRequest,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN PLUID LogonId,
    IN OUT PSID * UserSid,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    IN ULONG NegotiationInfo,
    IN ULONG Nonce,
    IN ULONG ReceiveNonce,
    IN OUT PHANDLE TokenHandle,
    IN PUNICODE_STRING ClientName,
    IN PUNICODE_STRING ClientDomain,
    IN PUNICODE_STRING ClientNetbiosDomain,
    OUT PKERB_CONTEXT * NewContext,
    OUT PTimeStamp ContextLifetime
    );

NTSTATUS
KerbUpdateServerContext(
    IN PKERB_CONTEXT Context,
    IN PKERB_ENCRYPTED_TICKET InternalTicket,
    IN PKERB_AP_REQUEST ApRequest,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN PLUID LogonId,
    IN OUT PSID * UserSid,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    IN ULONG NegotiationInfo,
    IN ULONG Nonce,
    IN ULONG ReceiveNonce,
    IN OUT PHANDLE TokenHandle,
    IN PUNICODE_STRING ClientName,
    IN PUNICODE_STRING ClientDomain,
    IN PUNICODE_STRING ClientNetbiosDomain,
    OUT PTimeStamp ContextLifetime
    );

NTSTATUS
KerbCreateEmptyContext(
    IN PKERB_CREDENTIAL Credential,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    IN ULONG NegotiationInfo,
    IN PLUID LogonId,
    OUT PKERB_CONTEXT * NewContext,
    OUT PTimeStamp ContextLifetime
    );



NTSTATUS
KerbMapContext(
    IN PKERB_CONTEXT Context,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData
    );

NTSTATUS
KerbCreateUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBuffer MarshalledContext,
    OUT PKERB_CONTEXT * NewContext
    );

SECURITY_STATUS
KerbReferenceContextByLsaHandle(
    IN LSA_SEC_HANDLE ContextHandle,
    IN BOOLEAN RemoveFromList,
    OUT PKERB_CONTEXT * FoundContext
    );

NTSTATUS
KerbUpdateClientContext(
    IN PKERB_CONTEXT Context,
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry,
    IN ULONG Nonce,
    IN PTimeStamp pAuthenticatorTime,
    IN ULONG ReceiveNonce,
    IN ULONG ContextFlags,
    IN ULONG ContextAttribs,
    IN OPTIONAL PKERB_ENCRYPTION_KEY SubSessionKey,
    OUT PTimeStamp ContextLifetime
    );

NTSTATUS
KerbCreateSKeyEntry(
    IN KERB_ENCRYPTION_KEY* pSessionKey,
    IN FILETIME* pExpireTime
    );

VOID
KerbDeleteSKeyEntry(
    IN OPTIONAL KERB_ENCRYPTION_KEY* pKey
    );

NTSTATUS
KerbDoesSKeyExist(
    IN KERB_ENCRYPTION_KEY* pKey,
    OUT BOOLEAN* pbExist
    );

NTSTATUS
KerbEqualKey(
    IN KERB_ENCRYPTION_KEY* pKeyFoo,
    IN KERB_ENCRYPTION_KEY* pKeyBar,
    OUT BOOLEAN* pbEqual
    );

VOID
KerbTrimSKeyList(
    VOID
    );

VOID
KerbSKeyListCleanupCallback(
    IN VOID* pContext,
    IN BOOLEAN bTimeOut
    );

NTSTATUS
KerbCreateSKeyTimer(
    VOID
    );

VOID
KerbFreeSKeyTimer(
    VOID
    );

VOID
KerbFreeSKeyEntry(
    IN KERB_SESSION_KEY_ENTRY* pSKeyEntry
    );

NTSTATUS
KerbProcessTargetNames(
    IN PUNICODE_STRING TargetName,
    IN OPTIONAL PUNICODE_STRING SuppTargetName,
    IN ULONG Flags,
    IN OUT PULONG ProcessFlags,
    OUT PKERB_INTERNAL_NAME * FinalTarget,
    OUT PUNICODE_STRING TargetRealm,
    OUT OPTIONAL PKERB_SPN_CACHE_ENTRY * SpnCacheEntry
    );

#define KERB_CRACK_NAME_USE_WKSTA_REALM         0x1
#define KERB_CRACK_NAME_REALM_SUPPLIED          0x2

#endif // __CTXTMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\ctxtmgr.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ctxtmgr.cxx
//
// Contents:    Code for managing contexts list for the Kerberos package
//
//
// History:     17-April-1996   Created         MikeSw
//              26-Sep-1998   ChandanS
//                            Added more debugging support etc.
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#define CTXTMGR_ALLOCATE
#include <kerbp.h>
#include "userapi.h"
#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

ULONG
HandleToListIndex(
    ULONG_PTR ContextHandle
    );

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitContextList
//
//  Synopsis:   Initializes the contexts list
//
//  Effects:    allocates a resources
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, other error codes
//              on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbInitContextList(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Index = 0;

    __try {
        SafeInitializeResource( &KerbContextResource, CONTEXT_RESOURCE_LOCK_ENUM );
    } __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for(Index = 0 ; Index < KERB_USERLIST_COUNT ; Index++)
    {
        Status = KerbInitializeList( &KerbContextList[Index], CONTEXT_LIST_LOCK_ENUM );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    KerberosContextsInitialized = TRUE;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        ULONG i;

        SafeDeleteResource( &KerbContextResource );

        for( i = 0 ; i < Index ; i++ )
        {
            KerbFreeList( &KerbContextList[i] );
        }
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeContextList
//
//  Synopsis:   Frees the contexts list
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeContextList(
    VOID
    )
{
#if 0
    PKERB_CONTEXT Context;

    if (KerberosContextsInitialized)
    {
        KerbLockList(&KerbContextList);

        //
        // Go through the list of logon sessions and dereferences them all
        //

        while (!IsListEmpty(&KerbContextList.List))
        {
            Context = CONTAINING_RECORD(
                            KerbContextList.List.Flink,
                            KERB_CONTEXT,
                            ListEntry.Next
                            );

            KerbReferenceListEntry(
                &KerbContextList,
                &Context->ListEntry,
                TRUE
                );

            KerbDereferenceContext(Context);

        }

        KerbFreeList(&KerbContextList);
    }
#endif

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbAllocateContext
//
//  Synopsis:   Allocates a Context structure
//
//  Effects:    Allocates a Context, but does not add it to the
//              list of Contexts
//
//  Arguments:  NewContext - receives a new Context allocated
//                  with KerbAllocate
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//              STATUS_INSUFFICIENT_RESOURCES if the allocation fails
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbAllocateContext(
    OUT PKERB_CONTEXT * NewContext,
    IN BOOLEAN UserMode
    )
{
    PKERB_CONTEXT Context;
    SECPKG_CALL_INFO CallInfo = {0};

    //
    // Get the client process ID if we are running in the LSA
    //

    if (!UserMode)
    {
        if (!LsaFunctions->GetCallInfo(&CallInfo))
        {
            D_DebugLog((DEB_ERROR,"Failed to get call info\n. %ws, line %d\n",
                THIS_FILE, __LINE__));
            DsysAssert(FALSE);
            return(STATUS_INSUFFICIENT_RESOURCES);
        }
    }

    Context = (PKERB_CONTEXT) KerbAllocate(
                        sizeof(KERB_CONTEXT) );

    if (Context == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Context->ClientProcess = CallInfo.ProcessId;
    Context->ContextState = IdleState;

    //
    // Set the references to 1 since we are returning a pointer to the
    // logon session
    //

    KerbInitializeListEntry(
        &Context->ListEntry
        );


    *NewContext = Context;
    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInsertContext
//
//  Synopsis:   Inserts a logon session into the list of logon sessions
//
//  Effects:    bumps reference count on logon session
//
//  Arguments:  Context - Context to insert
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS always
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbInsertContext(
    IN PKERB_CONTEXT Context
    )
{
    ULONG ListIndex;

    ListIndex = HandleToListIndex( Context->LsaContextHandle );

    Context->ContextTag = KERB_CONTEXT_TAG_ACTIVE;

    KerbInsertListEntry(
        &Context->ListEntry,
        &KerbContextList[ListIndex]
        );

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceContext
//
//  Synopsis:   Locates a context context handleand references it
//
//  Effects:    Increments reference count and possible unlinks it from list
//
//  Arguments:  ContextHandle - Handle of context to reference.
//              RemoveFromList - If TRUE, context will be delinked.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS
KerbReferenceContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN BOOLEAN RemoveFromList,
    OUT PKERB_CONTEXT * FoundContext
    )
{
    PKERB_CONTEXT Context = NULL;
    BOOLEAN Found = FALSE;
    SECPKG_CLIENT_INFO ClientInfo;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ListIndex = 0;
    BOOLEAN ListLocked = FALSE;

    if (KerberosState == KerberosLsaMode)
    {
        Status = LsaFunctions->GetClientInfo(&ClientInfo);
        if (!NT_SUCCESS(Status))
        {
            SECPKG_CALL_INFO CallInfo;
            //
            // Check to see if the call is terminating. If so, give it
            // TCB privilege because it is really the LSA doing this.
            //

            if (LsaFunctions->GetCallInfo(&CallInfo))
            {
                if ((CallInfo.Attributes & SECPKG_CALL_CLEANUP) != 0)
                {
                    Status = STATUS_SUCCESS;
                    RtlZeroMemory(
                        &ClientInfo,
                        sizeof(SECPKG_CLIENT_INFO)
                        );
                    ClientInfo.HasTcbPrivilege = TRUE;
                }

            }
            if (!NT_SUCCESS(Status))
            {
                D_DebugLog((DEB_ERROR, "Failed to get client info: 0x%x. %ws, line %d\n", Status, THIS_FILE, __LINE__));
                *FoundContext = NULL ;
                return(Status);
            }
        }

    }
    else
    {
        ClientInfo.HasTcbPrivilege = FALSE ;
        ClientInfo.ProcessID = GetCurrentProcessId();
    }

    //
    // Go through the list of logon sessions looking for the correct
    // context
    //

    Context = (PKERB_CONTEXT)ContextHandle;

    while ( Context->ContextTag == KERB_CONTEXT_TAG_ACTIVE )
    {
        ListIndex = HandleToListIndex( Context->LsaContextHandle );
        KerbLockList(&KerbContextList[ListIndex]);
        ListLocked = TRUE;

        //
        // Make sure that if we aren't trying to remove it we are
        // from the correct process.
        //

        if (!ClientInfo.HasTcbPrivilege &&
            (Context->ClientProcess != ClientInfo.ProcessID) &&
            (KerberosState == KerberosLsaMode))
        {
            D_DebugLog((DEB_ERROR, "Trying to reference a context from another process! %ws, line %d\n", THIS_FILE, __LINE__));
            Found = FALSE;
            break;
        }

        //
        // If the context is expired, don't allow it to be referenced.
        //

        if (KerbGlobalEnforceTime && !RemoveFromList)
        {
            TimeStamp CurrentTime;
            TimeStamp ContextExpires;
            GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
            ContextExpires = Context->Lifetime;
            if (KerbGetTime(ContextExpires) < KerbGetTime(CurrentTime))
            {
                D_DebugLog((DEB_WARN, "Trying to reference expired context\n"));
                Found = FALSE;
                Status = SEC_E_CONTEXT_EXPIRED;
                break;
            }
        }

        KerbReferenceListEntry(
            &KerbContextList[ ListIndex ],
            &Context->ListEntry,
            RemoveFromList
            );

        Found = TRUE;
        break;
    }

    if ( ListLocked )
    {
        KerbUnlockList(&KerbContextList[ListIndex]);
    }

    if (!Found)
    {
        Context = NULL;
    }

    *FoundContext = Context ;

    if ( Context )
    {
        return Status;
    }
    else if (NT_SUCCESS(Status))
    {
        return SEC_E_INVALID_HANDLE ;
    }
    else
    {
        return Status;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceContextByLsaHandle
//
//  Synopsis:   Locates a context by lsa context handle and references it
//
//  Effects:    Increments reference count and possible unlinks it from list
//
//  Arguments:  ContextHandle - Lsa Handle of context to reference.
//              RemoveFromList - If TRUE, context will be delinked.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS
KerbReferenceContextByLsaHandle(
    IN LSA_SEC_HANDLE ContextHandle,
    IN BOOLEAN RemoveFromList,
    OUT PKERB_CONTEXT *FoundContext
    )
{
    PLIST_ENTRY ListEntry;
    PKERB_CONTEXT Context = NULL;
    BOOLEAN Found = FALSE;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ListIndex;

    ListIndex = HandleToListIndex( ContextHandle );

    KerbLockList(&KerbContextList[ListIndex]);


    //
    // Go through the list of logon sessions looking for the correct
    // context
    //

    for (ListEntry = KerbContextList[ListIndex].List.Flink ;
         ListEntry !=  &KerbContextList[ListIndex].List ;
         ListEntry = ListEntry->Flink )
    {
        Context = CONTAINING_RECORD(ListEntry, KERB_CONTEXT, ListEntry.Next);
        if (ContextHandle == Context->LsaContextHandle)
        {

            //
            // Make sure that if we aren't trying to remove it we are
            // from the correct process.
            //

            //
            // If the context is expired, don't allow it to be referenced.
            //

            if (KerbGlobalEnforceTime && !RemoveFromList )
            {
                TimeStamp CurrentTime;
                TimeStamp ContextExpires;
                GetSystemTimeAsFileTime((PFILETIME)  &CurrentTime );
                ContextExpires = Context->Lifetime;
                if (KerbGetTime(ContextExpires) < KerbGetTime(CurrentTime))
                {
                    D_DebugLog((DEB_WARN, "Trying to reference expired context\n"));
                    Found = FALSE;
                    Status = SEC_E_CONTEXT_EXPIRED;
                    break;
                }
            }


            KerbReferenceListEntry(
                &KerbContextList[ListIndex],
                &Context->ListEntry,
                RemoveFromList
                );


            Found = TRUE;
            break;
        }

    }


    KerbUnlockList(&KerbContextList[ListIndex]);

    if (!Found)
    {
        Context = NULL;
    }
    *FoundContext = Context ;

    if ( Context )
    {
        return Status;
    }
    else if (NT_SUCCESS(Status))
    {
        return SEC_E_INVALID_HANDLE ;
    }
    else
    {
        return Status;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceContextByPointer
//
//  Synopsis:   References a context by the context pointer itself.
//
//  Effects:    Increments reference count and possible unlinks it from list
//
//  Arguments:  Context - The context to reference.
//              RemoveFromList - If TRUE, context will be delinked
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbReferenceContextByPointer(
    IN PKERB_CONTEXT Context,
    IN BOOLEAN RemoveFromList
    )
{
    ULONG ListIndex;

    ListIndex = HandleToListIndex( Context->LsaContextHandle );

    KerbLockList(&KerbContextList[ListIndex]);

    KerbReferenceListEntry(
        &KerbContextList[ListIndex],
        &Context->ListEntry,
        RemoveFromList
        );

    KerbUnlockList(&KerbContextList[ListIndex]);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeContext
//
//  Synopsis:   Frees a context that is unlinked
//
//  Effects:    frees all storage associated with the context
//
//  Arguments:  Context - context to free
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbFreeContext(
    IN PKERB_CONTEXT Context
    )
{

#ifndef WIN32_CHICAGO
    if (Context->TokenHandle != NULL)
    {
        NtClose(Context->TokenHandle);
    }
#endif // WIN32_CHICAGO
    Context->ContextTag = KERB_CONTEXT_TAG_DELETE;

    KerbFreeKey(&Context->SessionKey);
    KerbFreeKey(&Context->TicketKey);
    if (Context->TicketCacheEntry != NULL)
    {
        KerbDereferenceTicketCacheEntry(Context->TicketCacheEntry);
    }
    if (Context->UserSid != NULL)
    {
        KerbFree(Context->UserSid);
    }

    KerbFreeString(&Context->ClientName);
    KerbFreeString(&Context->ClientRealm);
    KerbFreeString(&Context->ClientDnsRealm);
    KerbFreeString(&Context->ClientPrincipalName);
    KerbFreeString(&Context->ServerPrincipalName);

    if( Context->pbMarshalledTargetInfo )
    {
        KerbFree( Context->pbMarshalledTargetInfo );
    }

    KerbFree(Context);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceContext
//
//  Synopsis:   Dereferences a logon session - if reference count goes
//              to zero it frees the logon session
//
//  Effects:    decrements reference count
//
//  Arguments:  Context - Logon session to dereference
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbDereferenceContext(
    IN PKERB_CONTEXT Context
    )
{
    ULONG ListIndex;

    ListIndex = HandleToListIndex( Context->LsaContextHandle );

    if (KerbDereferenceListEntry(
            &Context->ListEntry,
            &KerbContextList[ListIndex]
            ) )
    {
        KerbFreeContext(Context);
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateEmptyContext
//
//  Synopsis:   Creates a context for the server of a datagram authentication
//              session. Since there is no input message, all the fields
//              are initialized to zero.
//
//  Effects:    Allocates and links a context.
//
//  Arguments:  Credential - Credential to hang this context off of
//              ContextFlags - Flags for the context
//              LogonId = LogonId of the creating logon session
//              NewContext - receives referenced context pointer,
//              ContextLifetime - Lifetime for the context.
//
//  Requires:
//
//  Returns:    NTSTATUS code
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCreateEmptyContext(
    IN PKERB_CREDENTIAL Credential,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    IN ULONG NegotitationInfo,
    IN PLUID LogonId,
    OUT PKERB_CONTEXT * NewContext,
    OUT PTimeStamp ContextLifetime
    )
{
    NTSTATUS Status;
    PKERB_CONTEXT Context = NULL;

    Status = KerbAllocateContext( &Context, FALSE );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Context->CredentialHandle = KerbGetCredentialHandle(Credential);
    Context->ContextFlags = ContextFlags;
    Context->ContextAttributes = ContextAttributes;
    Context->Lifetime = KerbGlobalWillNeverTime;
    Context->CredManCredentials = NULL;
    Context->NegotiationInfo = NegotitationInfo;
    GetSystemTimeAsFileTime((PFILETIME)
                                   &(Context->StartTime)
                                   );

    Context->LogonId = *LogonId;
    *ContextLifetime = Context->Lifetime;


    Status = KerbInsertContext(
                Context
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to insert context: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    *NewContext = Context;


Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (Context != NULL)
        {
            KerbFreeContext(Context);
        }
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateClientContext
//
//  Synopsis:   Creates a context for the client of an authentication
//              session.
//
//  Effects:    Allocates and links a context.
//
//  Arguments:  LogonSession - Logon session to lock when accessing the credential
//              Credential - Credential to hang this context off of
//              TicketCacheEntry - Ticket around which to build this context
//              TargetName - target name supplied by client.
//              Nonce - Nonce used in AP request
//              SubSessionKey - subsession key to use, if present
//              ContextFlags - Flags passed in by client for authentication
//                      options.
//              NewContext - receives referenced context pointer,
//              ContextLifetime - Lifetime for the context.
//
//  Requires:
//
//  Returns:    NTSTATUS code
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCreateClientContext(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN OPTIONAL PKERB_TICKET_CACHE_ENTRY TicketCacheEntry,
    IN OPTIONAL PUNICODE_STRING TargetName,
    IN ULONG Nonce,
    IN PTimeStamp pAuthenticatorTime,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    IN OPTIONAL PKERB_ENCRYPTION_KEY SubSessionKey,
    OUT PKERB_CONTEXT * NewContext,
    OUT PTimeStamp ContextLifetime
    )
{
    NTSTATUS Status;
    PKERB_CONTEXT Context = NULL;

    Status = KerbAllocateContext( &Context, FALSE );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    if (ARGUMENT_PRESENT(TicketCacheEntry))
    {
        //
        // If we are doing datagram, reference the cache entry and
        // store a pointer to it in the context. The ticket cache cannot be
        // read locked at this point because the call to acquire a write
        // lock will block.
        //

        if ((ContextFlags & ISC_RET_DATAGRAM) != 0)
        {

            KerbReferenceTicketCacheEntry(TicketCacheEntry);
            Context->TicketCacheEntry = TicketCacheEntry;
        }

        KerbReadLockTicketCache();

        //
        // Duplicate the session key into the context
        //

        if (ARGUMENT_PRESENT(SubSessionKey) && (SubSessionKey->keyvalue.value != NULL))
        {
            if (!KERB_SUCCESS(KerbDuplicateKey(
                    &Context->SessionKey,
                    SubSessionKey
                    )))
            {
                KerbUnlockTicketCache();
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
        }
        else
        {
            //
            // For datagram, create a key
            //

            if ((ContextFlags & ISC_RET_DATAGRAM) != 0)
            {
                KERBERR KerbErr;

                SECPKG_CALL_INFO CallInfo;

                if (!LsaFunctions->GetCallInfo(&CallInfo))
                {
                    D_DebugLog((DEB_ERROR,"Failed to get client info: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    KerbUnlockTicketCache();
                    goto Cleanup;
                }


                //
                // If we are configured for strong encryption & we have said to
                // use it for datagram or this is an inprocess caller, then create
                // a strong key.
                //


                D_DebugLog((DEB_TRACE_CTXT,"Making exportable key for datagram client context\n"));
                if ( KerbGlobalUseStrongEncryptionForDatagram ||
                    (CallInfo.Attributes & SECPKG_CALL_IN_PROC))
                {
                    KerbErr = KerbMakeKey(
                                TicketCacheEntry->SessionKey.keytype,
                                &Context->SessionKey
                                );
                }
                else
                {
                    KerbErr = KerbMakeExportableKey(
                                TicketCacheEntry->SessionKey.keytype,
                                &Context->SessionKey
                                );
                }

                if (!KERB_SUCCESS(KerbErr))
                {
                    Status = KerbMapKerbError(KerbErr);
                    KerbUnlockTicketCache();
                    goto Cleanup;
                }

            }
            else
            {
                if (!KERB_SUCCESS(KerbDuplicateKey(
                        &Context->SessionKey,
                        &TicketCacheEntry->SessionKey
                        )))
                {
                    KerbUnlockTicketCache();
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }
            }
        }
        if (!KERB_SUCCESS(KerbDuplicateKey(
                &Context->TicketKey,
                &TicketCacheEntry->SessionKey
                )))
        {
            KerbUnlockTicketCache();
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Get the client's realm
        //

        Status = KerbDuplicateString(
                   &Context->ClientRealm,
                   &TicketCacheEntry->DomainName);
        if (!NT_SUCCESS(Status))
        {
            KerbUnlockTicketCache();
            goto Cleanup;
        }

        //
        // Get the client's name.
        //

        if (!KERB_SUCCESS(KerbConvertKdcNameToString(
                             &Context->ClientName,
                             TicketCacheEntry->ClientName,
                             NULL)))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            KerbUnlockTicketCache();
            goto Cleanup;
        }


        Context->Lifetime = TicketCacheEntry->EndTime;
        Context->StartTime = TicketCacheEntry->StartTime;
        Context->RenewTime = TicketCacheEntry->RenewUntil;
        Context->EncryptionType = TicketCacheEntry->Ticket.encrypted_part.encryption_type;
        KerbUnlockTicketCache();

    }
    else
    {

        Context->Lifetime = KerbGlobalWillNeverTime;
        Context->RenewTime = KerbGlobalWillNeverTime;

        GetSystemTimeAsFileTime((PFILETIME)
                                   &(Context->StartTime)
                                   );

        Context->EncryptionType = KERB_ETYPE_NULL;
    }

    Context->Nonce = Nonce;
    Context->AuthenticatorTime = *pAuthenticatorTime;

    //
    // For now, until the server sends us a separate nonce, use the one
    // we generated for receiving data
    //

    Context->ReceiveNonce = Nonce;

    Context->CredentialHandle = KerbGetCredentialHandle(Credential);

    //KerbReadLockLogonSessions(LogonSession); // FESTER:  Needed??
    if (ARGUMENT_PRESENT(CredManCredentials))
    {
        Context->ContextAttributes |= KERB_CONTEXT_USING_CREDMAN;
        Context->CredManCredentials = CredManCredentials; // don't ref, as we don't use it..
    }
    else if ((Credential->SuppliedCredentials != NULL))
    {
        Context->ContextAttributes |= KERB_CONTEXT_USED_SUPPLIED_CREDS;
    }
    //KerbUnlockLogonSessions(LogonSession);

    Context->ContextFlags = ContextFlags;
    Context->ContextAttributes = KERB_CONTEXT_OUTBOUND | ContextAttributes;


    //
    // if the caller supplied a target name, stash it in the context
    //

    if (ARGUMENT_PRESENT(TargetName))
    {
        Status = KerbDuplicateString(
            &Context->ServerPrincipalName,
            TargetName
            );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }


    *ContextLifetime = Context->Lifetime;

    Status = KerbInsertContext(
                Context
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to insert context: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    *NewContext = Context;


Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (Context != NULL)
        {
            KerbFreeContext(Context);
        }
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbUpdateServerContext
//
//  Synopsis:   Creates a context for the server of an authentication
//              session.
//
//  Effects:    Allocates and links a context.
//
//  Arguments:  Context - Context to update
//              InternalTicket - Ticket used to create this context.
//              SessionKey - Session key from the ticket.
//              LogonId - Logon ID of the context
//              UserSid - User's sid, held onto by context
//              ContextFlags - SSPI Flags for this context
//              ContextAttributes - Internal attributes of context
//              TokenHandle - Handle the token for this context
//              ContextLifetime - Lifetime for the context.
//
//  Requires:
//
//  Returns:    NTSTATUS code
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbUpdateServerContext(
    IN PKERB_CONTEXT Context,
    IN PKERB_ENCRYPTED_TICKET InternalTicket,
    IN PKERB_AP_REQUEST ApRequest,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN PLUID LogonId,
    IN PSID * UserSid,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    IN ULONG NegotiationInfo,
    IN ULONG Nonce,
    IN ULONG ReceiveNonce,
    IN OUT PHANDLE TokenHandle,
    IN PUNICODE_STRING ClientName,
    IN PUNICODE_STRING ClientDomain,
    IN PUNICODE_STRING ClientNetbiosDomain,
    OUT PTimeStamp ContextLifetime
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    KerbWriteLockContexts();

    if (!KERB_SUCCESS(KerbDuplicateKey(
                        &Context->SessionKey,
                        SessionKey
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // If this was not a null session and there is a ticket available,
    // pull interesting information out of the ticket
    //

    if (ARGUMENT_PRESENT(InternalTicket))
    {
        KerbConvertGeneralizedTimeToLargeInt(
            &Context->Lifetime,
            &InternalTicket->endtime,
            0
            );

        if (InternalTicket->bit_mask & KERB_ENCRYPTED_TICKET_renew_until_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &Context->RenewTime,
                &InternalTicket->KERB_ENCRYPTED_TICKET_renew_until,
                0
                );
        }

        //
        // Stick the client name in the context
        //

        Context->ClientName = *ClientName;
        RtlInitUnicodeString(
            ClientName,
            NULL
            );

        Context->ClientRealm = *ClientNetbiosDomain;
        RtlInitUnicodeString(
            ClientNetbiosDomain,
            NULL
            );


        Context->ClientDnsRealm = *ClientDomain;
        RtlInitUnicodeString(
            ClientDomain,
            NULL
            );  

        if (!KERB_SUCCESS(KerbDuplicateKey(
                &Context->TicketKey,
                &InternalTicket->key)))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Copy the principal names from the ticket
        //

        if (!KERB_SUCCESS(KerbConvertPrincipalNameToFullServiceString(
                &Context->ClientPrincipalName,
                &InternalTicket->client_name,
                InternalTicket->client_realm
                )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        if (!KERB_SUCCESS(KerbConvertPrincipalNameToFullServiceString(
                &Context->ServerPrincipalName,
                &ApRequest->ticket.server_name,
                ApRequest->ticket.realm
                )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }
    else
    {
        Context->Lifetime = KerbGlobalWillNeverTime;
        Context->RenewTime = KerbGlobalWillNeverTime;
        Context->EncryptionType = KERB_ETYPE_NULL;
    }

    //
    // If we generated a nonce to send to the client, use it. Otherwise use
    // the receive nonce from the AP req.
    //

    if (Nonce != 0)
    {
        Context->Nonce = Nonce;
    }
    else
    {
        Context->Nonce = ReceiveNonce;
    }

    Context->ReceiveNonce = ReceiveNonce;

    Context->LogonId = *LogonId;
    Context->ContextFlags |= ContextFlags;
    Context->TokenHandle = *TokenHandle;
    Context->UserSid = *UserSid;

    //
    // Noted we wipe out the previous ContextAttributes here, not sure why
    //

    D_DebugLog((DEB_TRACE, "KerbUpdateServerContext ContextAttributes was %#x, now %#x\n",  Context->ContextAttributes, ContextAttributes | KERB_CONTEXT_INBOUND));

    Context->ContextAttributes = KERB_CONTEXT_INBOUND;
    Context->ContextAttributes |= ContextAttributes;

    Context->NegotiationInfo = NegotiationInfo;
    *ContextLifetime = Context->Lifetime;

    //
    // Null the token handle so the caller does not free it
    //

    *TokenHandle = NULL;
    *UserSid = NULL;

Cleanup:
    KerbUnlockContexts();
    return (Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateServerContext
//
//  Synopsis:   Creates a context for the server of an authentication
//              session.
//
//  Effects:    Allocates and links a context.
//
//  Arguments:  LogonSession - Logon session to lock when accessing the credential
//              Credential - Credential to hang this context off of
//              InternalTicket - Ticket used to create this context.
//              SessionKey - Session key from the ticket.
//              LogonId - Logon ID of the context
//              UserSid - User's SID, held on to in context.
//              ContextFlags - SSPI Flags for this context
//              ContextAttributes - Internal attributes of context
//              TokenHandle - Handle the token for this context
//              NewContext - receives referenced context pointer
//              ContextLifetime - Lifetime for the context.
//
//  Requires:
//
//  Returns:    NTSTATUS code
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCreateServerContext(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_ENCRYPTED_TICKET InternalTicket,
    IN PKERB_AP_REQUEST ApRequest,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN PLUID LogonId,
    IN PSID * UserSid,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    IN ULONG NegotiationInfo,
    IN ULONG Nonce,
    IN ULONG ReceiveNonce,
    IN OUT PHANDLE TokenHandle,
    IN PUNICODE_STRING ClientName,
    IN PUNICODE_STRING ClientDomain,
    IN PUNICODE_STRING ClientNetbiosDomain,
    OUT PKERB_CONTEXT * NewContext,
    OUT PTimeStamp ContextLifetime
    )
{
    NTSTATUS Status;
    PKERB_CONTEXT Context = NULL;


    Status = KerbAllocateContext( &Context, FALSE );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    if (!KERB_SUCCESS(KerbDuplicateKey(
                        &Context->SessionKey,
                        SessionKey
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // If this wasn't a null session, stick the info from the ticket into
    // the context.
    //

    if (ARGUMENT_PRESENT(InternalTicket))
    {
        KerbConvertGeneralizedTimeToLargeInt(
            &Context->Lifetime,
            &InternalTicket->endtime,
            0
            );
        if (InternalTicket->bit_mask & KERB_ENCRYPTED_TICKET_renew_until_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &Context->RenewTime,
                &InternalTicket->KERB_ENCRYPTED_TICKET_renew_until,
                0
                );

        }

        if (InternalTicket->bit_mask & KERB_ENCRYPTED_TICKET_starttime_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &Context->StartTime,
                &InternalTicket->starttime,
                0
                );

        }
        else // use current time
        {
           GetSystemTimeAsFileTime((PFILETIME)
                             &(Context->StartTime)
                             );
        }


        Context->ClientName = *ClientName;
        RtlInitUnicodeString(
            ClientName,
            NULL
            );
        Context->ClientRealm = *ClientNetbiosDomain;
        RtlInitUnicodeString(
            ClientNetbiosDomain,
            NULL
            );

        Context->ClientDnsRealm = *ClientDomain;
        RtlInitUnicodeString(
             ClientDomain,
             NULL
             ); 


        if (!KERB_SUCCESS(KerbDuplicateKey(
                &Context->TicketKey,
                &InternalTicket->key)))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Copy the principal names from the ticket
        //

        if (!KERB_SUCCESS(KerbConvertPrincipalNameToFullServiceString(
                &Context->ClientPrincipalName,
                &InternalTicket->client_name,
                InternalTicket->client_realm
                )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        if (!KERB_SUCCESS(KerbConvertPrincipalNameToFullServiceString(
                &Context->ServerPrincipalName,
                &ApRequest->ticket.server_name,
                ApRequest->ticket.realm
                )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }
    else
    {
        Context->Lifetime = KerbGlobalWillNeverTime;
        Context->RenewTime = KerbGlobalWillNeverTime;

        GetSystemTimeAsFileTime((PFILETIME)
                                   &(Context->StartTime)
                                   );

        Context->EncryptionType = KERB_ETYPE_NULL;
    }

    //
    // If we generated a nonce to send to the client, use it. Otherwise use
    // the receive nonce from the AP req.
    //

//    if (Nonce != 0)
//    {
        Context->Nonce = Nonce;
//    }
//    else
//    {
//        Context->Nonce = ReceiveNonce;
//    }

    Context->ReceiveNonce = ReceiveNonce;
    Context->CredentialHandle = KerbGetCredentialHandle(Credential);
    Context->LogonId = *LogonId;
    Context->ContextFlags = ContextFlags;
    Context->TokenHandle = *TokenHandle;
    Context->UserSid = *UserSid;
    Context->NegotiationInfo = NegotiationInfo;
    //
    // Null the token handle so the caller does not free it
    //

    *TokenHandle = NULL;
    *UserSid = NULL;

    Context->ContextAttributes = KERB_CONTEXT_INBOUND;
    Context->ContextAttributes |= ContextAttributes;

    KerbReadLockLogonSessions(LogonSession);
    if (Credential->SuppliedCredentials != NULL)
    {
        Context->ContextAttributes |= KERB_CONTEXT_USED_SUPPLIED_CREDS;
    }


    KerbUnlockLogonSessions(LogonSession);

    *ContextLifetime = Context->Lifetime;

    Status = KerbInsertContext(
                Context
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to insert context: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    *NewContext = Context;


Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (Context != NULL)
        {
            KerbFreeContext(Context);
        }
    }
return(Status);
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbMapContext
//
//  Synopsis:   Maps a context to the caller's address space
//
//  Effects:
//
//  Arguments:  Context - The context to map
//              CopyToken - If TRUE, duplicate token to client
//              MappedContext - Set to TRUE on success
//              ContextData - Receives a buffer in the LSA's address space
//                      with the mapped context.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMapContext(
    IN PKERB_CONTEXT Context,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData
    )
{
    NTSTATUS Status ;
    PKERB_PACKED_CONTEXT PackedContext = NULL ;
    ULONG ContextSize ;
    PUCHAR CopyTo ;
    ULONG CurrentOffset ;

    KerbWriteLockContexts();

    //
    // If we already mapped the context don't try to do it again. We may
    // be able to map user-mode contexts multiple times, though.
    //

    if (KerberosState == KerberosLsaMode)
    {
        if ((Context->ContextAttributes & KERB_CONTEXT_MAPPED) != 0)
        {
            KerbUnlockContexts();
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

        Context->ContextAttributes |= KERB_CONTEXT_MAPPED;
    }


    ContextSize = sizeof(KERB_PACKED_CONTEXT) +
                        ROUND_UP_COUNT(Context->ClientName.Length, ALIGN_LPDWORD) +
                        ROUND_UP_COUNT(Context->ClientRealm.Length, ALIGN_LPDWORD) +
                        ROUND_UP_COUNT(Context->SessionKey.keyvalue.length, ALIGN_LPDWORD) +
                        ROUND_UP_COUNT(Context->cbMarshalledTargetInfo, ALIGN_LPDWORD) ;

    PackedContext = (PKERB_PACKED_CONTEXT) KerbAllocate( ContextSize );

    if (PackedContext == NULL)
    {
        Context->ContextAttributes &= ~(KERB_CONTEXT_MAPPED);

        KerbUnlockContexts();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    CurrentOffset = sizeof( KERB_PACKED_CONTEXT );
    CopyTo = (PUCHAR) ( PackedContext + 1 );

    PackedContext->ContextType = KERB_PACKED_CONTEXT_MAP ;
    PackedContext->Pad = 0 ;
    PackedContext->Lifetime = Context->Lifetime ;
    PackedContext->RenewTime = Context->RenewTime ;
    PackedContext->StartTime = Context->StartTime;

    PackedContext->ClientName.Length = Context->ClientName.Length ;
    PackedContext->ClientName.MaximumLength = Context->ClientName.Length ;
    PackedContext->ClientName.Buffer = CurrentOffset ;

    RtlCopyMemory(
        CopyTo,
        Context->ClientName.Buffer,
        Context->ClientName.Length );

    CurrentOffset += ROUND_UP_COUNT(Context->ClientName.Length, ALIGN_LPDWORD) ;
    CopyTo += ROUND_UP_COUNT(Context->ClientName.Length, ALIGN_LPDWORD) ;

    PackedContext->ClientRealm.Length = Context->ClientRealm.Length ;
    PackedContext->ClientRealm.MaximumLength = Context->ClientRealm.Length ;
    PackedContext->ClientRealm.Buffer = CurrentOffset ;

    RtlCopyMemory(
        CopyTo,
        Context->ClientRealm.Buffer,
        Context->ClientRealm.Length );

    CurrentOffset += ROUND_UP_COUNT(Context->ClientRealm.Length, ALIGN_LPDWORD);
    CopyTo += ROUND_UP_COUNT(Context->ClientRealm.Length, ALIGN_LPDWORD) ;

    PackedContext->LsaContextHandle = (ULONG) Context->LsaContextHandle ;
    PackedContext->LogonId = Context->LogonId ;

    PackedContext->CredentialHandle = 0 ;
    PackedContext->SessionKeyType = Context->SessionKey.keytype ;
    PackedContext->SessionKeyOffset = CurrentOffset ;
    PackedContext->SessionKeyLength = Context->SessionKey.keyvalue.length ;

    RtlCopyMemory(
        CopyTo,
        Context->SessionKey.keyvalue.value,
        Context->SessionKey.keyvalue.length );

    CurrentOffset += ROUND_UP_COUNT(PackedContext->SessionKeyLength, ALIGN_LPDWORD) ;
    CopyTo += ROUND_UP_COUNT(PackedContext->SessionKeyLength, ALIGN_LPDWORD);

    if( Context->pbMarshalledTargetInfo )
    {
        PackedContext->MarshalledTargetInfo = CurrentOffset;
        PackedContext->MarshalledTargetInfoLength = Context->cbMarshalledTargetInfo;

        RtlCopyMemory(
            CopyTo,
            Context->pbMarshalledTargetInfo,
            Context->cbMarshalledTargetInfo );

        CurrentOffset += ROUND_UP_COUNT(PackedContext->MarshalledTargetInfoLength, ALIGN_LPDWORD);
        CopyTo += ROUND_UP_COUNT(PackedContext->MarshalledTargetInfoLength, ALIGN_LPDWORD);
    }

    PackedContext->Nonce = Context->Nonce ;
    PackedContext->ReceiveNonce = Context->ReceiveNonce ;
    PackedContext->ContextFlags = Context->ContextFlags ;
    PackedContext->ContextAttributes = Context->ContextAttributes ;
    PackedContext->EncryptionType = Context->EncryptionType ;

    KerbUnlockContexts();

    //
    // If there is a token in the context, copy it also
    //

#ifndef WIN32_CHICAGO
    if ((KerberosState == KerberosLsaMode)  && (Context->TokenHandle != NULL))
    {
        HANDLE duplicateHandle;

        Status = LsaFunctions->DuplicateHandle(
                    Context->TokenHandle,
                    &duplicateHandle
                    );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to duplicate handle: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        PackedContext->TokenHandle = HandleToUlong(duplicateHandle);
        NtClose(Context->TokenHandle);
        Context->TokenHandle = NULL;
    }
    else
    {
         PackedContext->TokenHandle = NULL;
    }
#endif // WIN32_CHICAGO


    ContextData->pvBuffer = PackedContext;
    ContextData->cbBuffer = ContextSize;


    *MappedContext = TRUE;


    Status = STATUS_SUCCESS;

Cleanup:


    if (!NT_SUCCESS(Status))
    {
        if (PackedContext != NULL)
        {
            KerbFree(PackedContext);
        }
    }

    return(Status);
}
#if 0
NTSTATUS
KerbMapContext(
    IN PKERB_CONTEXT Context,
    OUT PBOOLEAN MappedContext,
    OUT PSecBuffer ContextData
    )
{
    NTSTATUS Status;
    PKERB_CONTEXT PackedContext = NULL;
    ULONG ContextSize;

    KerbWriteLockContexts();

    //
    // If we already mapped the context don't try to do it again. We may
    // be able to map user-mode contexts multiple times, though.
    //

    if (KerberosState == KerberosLsaMode)
    {
        if ((Context->ContextAttributes & KERB_CONTEXT_MAPPED) != 0)
        {
            KerbUnlockContexts();
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

        Context->ContextAttributes |= KERB_CONTEXT_MAPPED;
    }


    ContextSize = sizeof(KERB_CONTEXT) +
                        Context->ClientName.Length +
                        Context->ClientRealm.Length +
                        Context->SessionKey.keyvalue.length;

    PackedContext = (PKERB_CONTEXT) KerbAllocate(ContextSize);

    if (PackedContext == NULL)
    {
        KerbUnlockContexts();
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    RtlCopyMemory(
        PackedContext,
        Context,
        sizeof(KERB_CONTEXT)
        );

    PackedContext->ClientName.Buffer = (LPWSTR) sizeof(KERB_CONTEXT);
    RtlCopyMemory(
        PackedContext+1,
        Context->ClientName.Buffer,
        Context->ClientName.Length
        );
    PackedContext->ClientName.MaximumLength = PackedContext->ClientName.Length;


    PackedContext->ClientRealm.Buffer = (LPWSTR) (sizeof(KERB_CONTEXT) + PackedContext->ClientName.Length);
    RtlCopyMemory(
        (PUCHAR) PackedContext + (UINT_PTR) PackedContext->ClientRealm.Buffer,
        Context->ClientRealm.Buffer,
        Context->ClientRealm.Length
        );
    PackedContext->ClientRealm.MaximumLength = PackedContext->ClientRealm.Length;

    RtlZeroMemory(
        &PackedContext->TicketKey,
        sizeof(KERB_ENCRYPTION_KEY)
        );
    RtlZeroMemory(
        &PackedContext->ClientPrincipalName,
        sizeof(UNICODE_STRING)
        );

    RtlZeroMemory(
        &PackedContext->ServerPrincipalName,
        sizeof(UNICODE_STRING)
        );

    //
    // Pack in the session key
    //

    PackedContext->SessionKey.keyvalue.value = (PUCHAR) PackedContext->ClientRealm.Buffer + PackedContext->ClientRealm.MaximumLength;

    RtlCopyMemory(
        PackedContext->SessionKey.keyvalue.value + (UINT_PTR) PackedContext,
        Context->SessionKey.keyvalue.value,
        Context->SessionKey.keyvalue.length
        );

    KerbUnlockContexts();

    //
    // If there is a token in the context, copy it also
    //

#ifndef WIN32_CHICAGO
    if ((KerberosState == KerberosLsaMode)  && (Context->TokenHandle != NULL))
    {
        Status = LsaFunctions->DuplicateHandle(
                    Context->TokenHandle,
                    &PackedContext->TokenHandle
                    );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to duplicate handle: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }
        NtClose(Context->TokenHandle);
        Context->TokenHandle = NULL;
    }
    else
    {
         PackedContext->TokenHandle = NULL;
    }
#endif // WIN32_CHICAGO


    ContextData->pvBuffer = PackedContext;
    ContextData->cbBuffer = ContextSize;


    *MappedContext = TRUE;


    Status = STATUS_SUCCESS;

Cleanup:


    if (!NT_SUCCESS(Status))
    {
        if (PackedContext != NULL)
        {
            KerbFree(PackedContext);
        }
    }

    return(Status);

}
#endif


#ifndef WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   KerbGetTokenUser
//
//  Synopsis:   Returns user field from a token
//
//  Effects:    allocates memory with LocalAlloc
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetTokenUser(
    HANDLE Token,
    PTOKEN_USER * pTokenUser
    )
{
    PTOKEN_USER LocalTokenUser = NULL;
    NTSTATUS Status;
    ULONG TokenUserSize = 0;

    //
    // Query the token user.  First pass in NULL to get back the
    // required size.
    //

    Status = NtQueryInformationToken(
                Token,
                TokenUser,
                NULL,
                0,
                &TokenUserSize
                );

    if (Status != STATUS_BUFFER_TOO_SMALL)
    {
        DsysAssert(Status != STATUS_SUCCESS);
        return(Status);
    }

    //
    // Now allocate the required ammount of memory and try again.
    //

    LocalTokenUser = (PTOKEN_USER) LocalAlloc(0,TokenUserSize);
    if (LocalTokenUser == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    Status = NtQueryInformationToken(
                Token,
                TokenUser,
                LocalTokenUser,
                TokenUserSize,
                &TokenUserSize
                );

    if (NT_SUCCESS(Status))
    {
        *pTokenUser = LocalTokenUser;
    }
    else
    {
        LocalFree(LocalTokenUser);
    }
    return(Status);
}
#endif // WIN32_CHICAGO



#ifndef WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateTokenDacl
//
//  Synopsis:   Modifies DACL on the context token to grant access to the
//              the caller.
//
//  Effects:
//
//  Arguments:  Token - Token to modify
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCreateTokenDacl(
    HANDLE Token
    )
{
    NTSTATUS Status;
    PTOKEN_USER ProcessTokenUser = NULL;
    PTOKEN_USER ThreadTokenUser = NULL;
    PTOKEN_USER ImpersonationTokenUser = NULL;
    HANDLE ProcessToken = NULL;
    HANDLE ImpersonationToken = NULL;
    BOOL fInsertImpersonatingUser = FALSE;
    ULONG AclLength;
    PACL NewDacl = NULL;
    SECURITY_DESCRIPTOR SecurityDescriptor;

    //
    // it's possible that the current thread is impersonating a user.
    // if that's the case, get it's token user, and revert to insure we
    // can open the process token.
    //

    Status = NtOpenThreadToken(
                            NtCurrentThread(),
                            TOKEN_QUERY | TOKEN_IMPERSONATE,
                            TRUE,
                            &ImpersonationToken
                            );

    if( NT_SUCCESS(Status) )
    {
        //
        // stop impersonating.
        //

        RevertToSelf();

        //
        // get the token user for the impersonating user.
        //

        Status = KerbGetTokenUser(
                    ImpersonationToken,
                    &ImpersonationTokenUser
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Open the process token to find out the user sid
    //

    Status = NtOpenProcessToken(
                NtCurrentProcess(),
                TOKEN_QUERY,
                &ProcessToken
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbGetTokenUser(
                ProcessToken,
                &ProcessTokenUser
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Now get the token user for the thread.
    //
    Status = KerbGetTokenUser(
                Token,
                &ThreadTokenUser
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    AclLength = 4 * sizeof( ACCESS_ALLOWED_ACE ) - 4 * sizeof( ULONG ) +
                RtlLengthSid( ProcessTokenUser->User.Sid ) +
                RtlLengthSid( ThreadTokenUser->User.Sid ) +
                RtlLengthSid( KerbGlobalLocalSystemSid ) +
                RtlLengthSid( KerbGlobalAliasAdminsSid ) +
                sizeof( ACL );

    //
    // determine if we need to add impersonation token sid onto the token Dacl.
    //

    if( ImpersonationTokenUser &&
        !RtlEqualSid( ImpersonationTokenUser->User.Sid, ProcessTokenUser->User.Sid ) &&
        !RtlEqualSid( ImpersonationTokenUser->User.Sid, ThreadTokenUser->User.Sid )
        )
    {
        AclLength += (sizeof(ACCESS_ALLOWED_ACE) - sizeof( ULONG )) +
                RtlLengthSid( ImpersonationTokenUser->User.Sid );

        fInsertImpersonatingUser = TRUE;
    }

    NewDacl = (PACL) LocalAlloc(0, AclLength );

    if (NewDacl == NULL) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = RtlCreateAcl( NewDacl, AclLength, ACL_REVISION2 );
    DsysAssert(NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 ProcessTokenUser->User.Sid
                 );
    DsysAssert( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 ThreadTokenUser->User.Sid
                 );
    DsysAssert( NT_SUCCESS( Status ));

    if( fInsertImpersonatingUser )
    {
        Status = RtlAddAccessAllowedAce (
                     NewDacl,
                     ACL_REVISION2,
                     TOKEN_ALL_ACCESS,
                     ImpersonationTokenUser->User.Sid
                     );
        DsysAssert( NT_SUCCESS( Status ));
    }

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 KerbGlobalAliasAdminsSid
                 );
    DsysAssert( NT_SUCCESS( Status ));

    Status = RtlAddAccessAllowedAce (
                 NewDacl,
                 ACL_REVISION2,
                 TOKEN_ALL_ACCESS,
                 KerbGlobalLocalSystemSid
                 );
    DsysAssert( NT_SUCCESS( Status ));

    Status = RtlCreateSecurityDescriptor (
                 &SecurityDescriptor,
                 SECURITY_DESCRIPTOR_REVISION
                 );
    DsysAssert( NT_SUCCESS( Status ));

    Status = RtlSetDaclSecurityDescriptor(
                 &SecurityDescriptor,
                 TRUE,
                 NewDacl,
                 FALSE
                 );

    DsysAssert( NT_SUCCESS( Status ));

    Status = NtSetSecurityObject(
                 Token,
                 DACL_SECURITY_INFORMATION,
                 &SecurityDescriptor
                 );

    DsysAssert( NT_SUCCESS( Status ));


Cleanup:

    if( ImpersonationToken != NULL ) {

        //
        // put the thread token back if we were impersonating.
        //

        SetThreadToken( NULL, ImpersonationToken );
        NtClose( ImpersonationToken );
    }

    if (ThreadTokenUser != NULL) {
        LocalFree( ThreadTokenUser );
    }

    if (ProcessTokenUser != NULL) {
        LocalFree( ProcessTokenUser );
    }

    if (ImpersonationTokenUser != NULL) {
        LocalFree( ImpersonationTokenUser );
    }

    if (NewDacl != NULL) {
        LocalFree( NewDacl );
    }

    if (ProcessToken != NULL)
    {
        NtClose(ProcessToken);
    }

    return( Status );
}
#endif // WIN32_CHICAGO


//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateUserModeContext
//
//  Synopsis:   Creates a user-mode context to support impersonation and
//              message integrity and privacy
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBuffer MarshalledContext,
    OUT PKERB_CONTEXT * NewContext
    )
{
    NTSTATUS Status;
    PKERB_CONTEXT Context = NULL;
    PKERB_PACKED_CONTEXT PackedContext ;
    UNICODE_STRING String ;
    KERB_ENCRYPTION_KEY Key ;


    if (MarshalledContext->cbBuffer < sizeof(KERB_PACKED_CONTEXT))
    {
        D_DebugLog((DEB_ERROR,"Invalid buffer size for marshalled context: was 0x%x, needed 0x%x. %ws, line %d\n",
            MarshalledContext->cbBuffer, sizeof(KERB_CONTEXT), THIS_FILE, __LINE__));
        return(STATUS_INVALID_PARAMETER);
    }

    PackedContext = (PKERB_PACKED_CONTEXT) MarshalledContext->pvBuffer;


    Status = KerbAllocateContext( &Context, TRUE );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Context->Lifetime = PackedContext->Lifetime ;
    Context->RenewTime = PackedContext->RenewTime ;
    Context->StartTime = PackedContext->StartTime;

    String.Length = PackedContext->ClientName.Length ;
    String.MaximumLength = PackedContext->ClientName.MaximumLength ;
    String.Buffer = (PWSTR)((PUCHAR) PackedContext + PackedContext->ClientName.Buffer );

    Status = KerbDuplicateString(
                &Context->ClientName,
                &String );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Cleanup ;
    }

    String.Length = PackedContext->ClientRealm.Length ;
    String.MaximumLength = PackedContext->ClientRealm.MaximumLength ;
    String.Buffer = (PWSTR)((PUCHAR) PackedContext + PackedContext->ClientRealm.Buffer );

    Status = KerbDuplicateString(
                &Context->ClientRealm,
                &String );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Cleanup ;
    }

    Context->LogonId = PackedContext->LogonId ;
    Context->TokenHandle = (HANDLE) ULongToPtr(PackedContext->TokenHandle);
    Context->CredentialHandle = NULL ;
    Context->Nonce = PackedContext->Nonce ;
    Context->ReceiveNonce = PackedContext->ReceiveNonce ;
    Context->ContextFlags = PackedContext->ContextFlags ;
    Context->ContextAttributes = PackedContext->ContextAttributes ;
    Context->EncryptionType = PackedContext->EncryptionType ;

    Key.keytype = PackedContext->SessionKeyType ;
    Key.keyvalue.value = (PUCHAR) ((PUCHAR) PackedContext + PackedContext->SessionKeyOffset );
    Key.keyvalue.length = PackedContext->SessionKeyLength ;

    if (!KERB_SUCCESS(KerbDuplicateKey(
            &Context->SessionKey,
            &Key)))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    //
    // Null out string buffers that aren't meant to be copied.
    //

    Context->ClientPrincipalName.Buffer = NULL;
    Context->ServerPrincipalName.Buffer = NULL;
    Context->TicketKey.keyvalue.value = NULL;
    Context->UserSid = NULL;
    Context->TicketCacheEntry = NULL;


    //
    // Modify the DACL on the token to grant access to the caller
    //

#ifndef WIN32_CHICAGO
    if (Context->TokenHandle != NULL)
    {
        Status = KerbCreateTokenDacl(
                    Context->TokenHandle
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
#endif // WIN32_CHICAGO
    //
    // We didn't copy the ticket here, so don't store the entry
    //

    Context->TicketCacheEntry = NULL;

    KerbInitializeListEntry(
        &Context->ListEntry
        );


    if ( ContextHandle != 0 )
    {
        Context->LsaContextHandle = ContextHandle;
    } else {
        Context->LsaContextHandle = (ULONG_PTR)Context;
    }

    Context->cbMarshalledTargetInfo = PackedContext->MarshalledTargetInfoLength;
    if (PackedContext->MarshalledTargetInfo)
    {
        Context->pbMarshalledTargetInfo = (PUCHAR) KerbAllocate( Context->cbMarshalledTargetInfo );
        if (Context->pbMarshalledTargetInfo == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            Context->pbMarshalledTargetInfo,
            (PUCHAR) PackedContext + PackedContext->MarshalledTargetInfo,
            Context->cbMarshalledTargetInfo
            );

    } else {
        Context->pbMarshalledTargetInfo = NULL;
    }


    Status = KerbInsertContext(
                Context
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to insert context: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    *NewContext = Context;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (Context != NULL)
        {
            KerbFreeContext(Context);
        }
    }
    return(Status);

}

#if 0
NTSTATUS
KerbCreateUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBuffer MarshalledContext,
    OUT PKERB_CONTEXT * NewContext
    )
{
    NTSTATUS Status;
    PKERB_CONTEXT Context = NULL;
    PKERB_CONTEXT LsaContext;

    if (MarshalledContext->cbBuffer < sizeof(KERB_CONTEXT))
    {
        D_DebugLog((DEB_ERROR,"Invalid buffer size for marshalled context: was 0x%x, needed 0x%x. %ws, line %d\n",
            MarshalledContext->cbBuffer, sizeof(KERB_CONTEXT), THIS_FILE, __LINE__));
        return(STATUS_INVALID_PARAMETER);
    }

    LsaContext = (PKERB_CONTEXT) MarshalledContext->pvBuffer;

    //
    // Normalize the client name.
    //

    LsaContext->ClientName.Buffer = (LPWSTR) ((PUCHAR) LsaContext->ClientName.Buffer + (UINT_PTR) LsaContext);
    LsaContext->ClientRealm.Buffer = (LPWSTR) ((PUCHAR) LsaContext->ClientRealm.Buffer + (UINT_PTR) LsaContext);
    LsaContext->SessionKey.keyvalue.value = (PUCHAR) LsaContext->SessionKey.keyvalue.value + (UINT_PTR) LsaContext;

    Status = KerbAllocateContext( &Context, TRUE );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *Context = *LsaContext;

    //
    // Null out string buffers that aren't meant to be copied.
    //

    Context->ClientName.Buffer = NULL;
    Context->ClientRealm.Buffer = NULL;
    Context->SessionKey.keyvalue.value = NULL;
    Context->UserSid = NULL;
    Context->TicketCacheEntry = NULL;


    //
    // Modify the DACL on the token to grant access to the caller
    //

#ifndef WIN32_CHICAGO
    if (Context->TokenHandle != NULL)
    {
        Status = KerbCreateTokenDacl(
                    Context->TokenHandle
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
#endif // WIN32_CHICAGO
    //
    // We didn't copy the ticket here, so don't store the entry
    //

    Context->TicketCacheEntry = NULL;

    KerbInitializeListEntry(
        &Context->ListEntry
        );

    Context->LsaContextHandle = ContextHandle;

    Status = KerbDuplicateString(
                    &Context->ClientName,
                    &LsaContext->ClientName
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbDuplicateString(
                    &Context->ClientRealm,
                    &LsaContext->ClientRealm
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbDuplicateKey(
            &Context->SessionKey,
            &LsaContext->SessionKey)))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = KerbInsertContext(
                Context
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to insert context: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    *NewContext = Context;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (Context != NULL)
        {
            KerbFreeContext(Context);
        }
    }
    return(Status);

}
#endif


//+-------------------------------------------------------------------------
//
//  Function:   KerbUpdateClientContext
//
//  Synopsis:   updates context with latest info
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbUpdateClientContext(
    IN PKERB_CONTEXT Context,
    IN OPTIONAL PKERB_TICKET_CACHE_ENTRY TicketCacheEntry,
    IN ULONG Nonce,
    IN PTimeStamp pAuthenticatorTime,
    IN ULONG ReceiveNonce,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    IN OPTIONAL PKERB_ENCRYPTION_KEY SubSessionKey,
    OUT PTimeStamp ContextLifetime
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (ARGUMENT_PRESENT(TicketCacheEntry))
    {
        KerbReadLockTicketCache();
    }

    KerbWriteLockContexts();

    if (ARGUMENT_PRESENT(TicketCacheEntry))
    {
        //
        // Duplicate the session key into the context
        //

        KerbFreeKey(
            &Context->SessionKey
            );

        if (ARGUMENT_PRESENT(SubSessionKey) && (SubSessionKey->keyvalue.value != NULL))
        {
            if (!KERB_SUCCESS(KerbDuplicateKey(
                    &Context->SessionKey,
                    SubSessionKey
                    )))
            {
                KerbUnlockTicketCache();
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
        }
        else
        {
            if (!KERB_SUCCESS(KerbDuplicateKey(
                    &Context->SessionKey,
                    &TicketCacheEntry->SessionKey
                    )))
            {
                KerbUnlockTicketCache();
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
        }

        KerbFreeKey(
            &Context->TicketKey
            );

        if (!KERB_SUCCESS(KerbDuplicateKey(
                &Context->TicketKey,
                &TicketCacheEntry->SessionKey
                )))
        {
            KerbUnlockTicketCache();
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Context->Lifetime = TicketCacheEntry->EndTime;
        Context->RenewTime = TicketCacheEntry->RenewUntil;
        Context->EncryptionType = TicketCacheEntry->Ticket.encrypted_part.encryption_type;
        KerbUnlockTicketCache();
    }
    else
    {

        Context->Lifetime = KerbGlobalWillNeverTime;
        Context->RenewTime = KerbGlobalWillNeverTime;
        Context->EncryptionType = KERB_ETYPE_NULL;
    }

    Context->Nonce = Nonce;
    Context->AuthenticatorTime = *pAuthenticatorTime;

    //
    // If the server sent us a nonce for receiving data, use it. Otherwise use
    // the nonce we generated.
    //

//    if (ReceiveNonce != 0)
//    {
        Context->ReceiveNonce = ReceiveNonce;
//    }
//    else
//    {
//        Context->ReceiveNonce = Nonce;
//    }

    //
    // delegation flags are not additive, turn it off before updating it
    //

    Context->ContextFlags &= ~(ISC_RET_DELEGATE_IF_SAFE | ISC_RET_DELEGATE);

    Context->ContextFlags |= ContextFlags;


    Context->ContextAttributes |= KERB_CONTEXT_OUTBOUND | ContextAttributes;

    *ContextLifetime = Context->Lifetime;

Cleanup:
    KerbUnlockContexts();
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function: KerbCreateSKeyEntry
//
//  Synopsis: Create a session key entry
//
//  Effects:
//
//  Arguments: pSessionKey - session key that is used, mostly SubKey
//             pExpireTime - time that the session key expires
//
//  Requires: Memory allocator must zero out memory because KerbFreeSKeyEntry
//            relies on that behavior
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateSKeyEntry(
    IN KERB_ENCRYPTION_KEY* pSessionKey,
    IN FILETIME* pExpireTime
    )
{
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    KERB_SESSION_KEY_ENTRY* pSessionKeyEntry = NULL;

    if (!pSessionKey || !pExpireTime)
    {
        return STATUS_INVALID_PARAMETER;
    }

    pSessionKeyEntry = (KERB_SESSION_KEY_ENTRY*) KerbAllocate(sizeof(KERB_SESSION_KEY_ENTRY));

    if (!pSessionKeyEntry)
    {
        return STATUS_NO_MEMORY;
    }

    pSessionKeyEntry->ExpireTime = *pExpireTime;
    InitializeListHead(&pSessionKeyEntry->ListEntry); // so that un-linking always works

    NtStatus = KerbMapKerbError(
        KerbDuplicateKey(
            &pSessionKeyEntry->SessionKey,
            pSessionKey
            ));

    if (NT_SUCCESS(NtStatus))
    {
        if (SafeAcquireResourceExclusive(&KerbSKeyLock, TRUE))
        {
#if DBG
            ULONG cSKeyEntries = 0;

            if (NT_SUCCESS(NtStatus))
            {
                cSKeyEntries = InterlockedIncrement(&KerbcSKeyEntries);
            }

            DebugLog((DEB_TRACE_LOOPBACK,
                "KerbInsertSKey, status 0x%x, keyexpire %#x:%#x, total %d keys\n",
                NtStatus,
                pSessionKeyEntry->ExpireTime.dwHighDateTime,
                pSessionKeyEntry->ExpireTime.dwLowDateTime,
                cSKeyEntries));

#endif
            InsertHeadList(&KerbSKeyList, &pSessionKeyEntry->ListEntry);
            pSessionKeyEntry = NULL;
            SafeReleaseResource(&KerbSKeyLock);
        }
        else
        {
            NtStatus = STATUS_UNSUCCESSFUL;
        }
    }

    if (pSessionKeyEntry)
    {
        KerbFreeSKeyEntry(pSessionKeyEntry);
    }

    return NtStatus;
}

//+-------------------------------------------------------------------------
//
//  Function: KerbDoesSKeyExist
//
//  Synopsis: check whether a session key entry exists the session key list
//
//  Effects:
//
//  Arguments: pKey - key to be located
//             pbExist - whether session key entry exists
//
//  Requires:
//
//  Returns: If an entry is found, ppSKeyEntry points to the entry
//           that contains pKey hence should be non null
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbDoesSKeyExist(
    IN KERB_ENCRYPTION_KEY* pKey,
    OUT BOOLEAN* pbExist
    )
{
    FILETIME CurrentTime = {0};
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;

    if (!pKey || !pbExist)
    {
        return STATUS_INVALID_PARAMETER;
    }

    *pbExist = FALSE;

    GetSystemTimeAsFileTime(&CurrentTime);

    DebugLog((DEB_TRACE_LOOPBACK, "KerbDoesSKeyExist, curtime %#x:%#x\n", CurrentTime.dwHighDateTime, CurrentTime.dwLowDateTime));

    if (SafeAcquireResourceShared(&KerbSKeyLock, TRUE))
    {
        NtStatus = STATUS_SUCCESS;

        for (LIST_ENTRY* pListEntry = KerbSKeyList.Flink;
             NT_SUCCESS(NtStatus) && pListEntry != &KerbSKeyList;
             pListEntry = pListEntry->Flink)
        {
           KERB_SESSION_KEY_ENTRY* pSKeyEntry = CONTAINING_RECORD(pListEntry, KERB_SESSION_KEY_ENTRY, ListEntry);

           //
           // only keys that have not expired are checked
           //

           if (KerbGetTime(* (TimeStamp*)&pSKeyEntry->ExpireTime) > KerbGetTime(* (TimeStamp*)&CurrentTime))
           {
               BOOLEAN bEqual = FALSE;

               NtStatus = KerbEqualKey(&pSKeyEntry->SessionKey, pKey, &bEqual);

               if (NT_SUCCESS(NtStatus) && bEqual)
               {
                   //
                   // found it
                   //

                   DebugLog((DEB_TRACE_LOOPBACK, "KerbDoesSKeyExist, keyexpire %#x:%#x found\n", pSKeyEntry->ExpireTime.dwHighDateTime, pSKeyEntry->ExpireTime.dwLowDateTime));

                   *pbExist = TRUE;

                   break;
               }
           }
        }

        SafeReleaseResource(&KerbSKeyLock);
    }

    return NtStatus;
}

//+-------------------------------------------------------------------------
//
//  Function: KerbDeleteSKeyEntry
//
//  Synopsis: remove a session key entry if it exists
//
//  Effects:
//
//  Arguments: pKey - key to be delete
//
//  Requires:
//
//  Returns: None
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbDeleteSKeyEntry(
    IN OPTIONAL KERB_ENCRYPTION_KEY* pKey
    )
{
    if (pKey)
    {
        if (SafeAcquireResourceExclusive(&KerbSKeyLock, TRUE))
        {
            NTSTATUS NtStatus = STATUS_SUCCESS;

            for (LIST_ENTRY* pListEntry = KerbSKeyList.Flink;
                 NT_SUCCESS(NtStatus) && pListEntry != &KerbSKeyList;
                 pListEntry = pListEntry->Flink)
            {
                BOOLEAN bEqual = FALSE;

                KERB_SESSION_KEY_ENTRY* pSKeyEntry = CONTAINING_RECORD(pListEntry, KERB_SESSION_KEY_ENTRY, ListEntry);

                NtStatus = KerbEqualKey(&pSKeyEntry->SessionKey, pKey, &bEqual);

                if (NT_SUCCESS(NtStatus) && bEqual)
                {
                    KerbFreeSKeyEntry(pSKeyEntry);
                    break;
                }
            }

            SafeReleaseResource(&KerbSKeyLock);
        }
    }
}

//+-----------------------------------------------------------------------
//
// Function: KerbEqualKey
//
// Synopsis: Compare two keys
//
// Effects:
//
// Arguments: pKeyFoo - one key
//            pKeyBar - the other key
//
// Returns: NTSTATUS
//
// History:
//
//------------------------------------------------------------------------

NTSTATUS
KerbEqualKey(
    IN KERB_ENCRYPTION_KEY* pKeyFoo,
    IN KERB_ENCRYPTION_KEY* pKeyBar,
    OUT BOOLEAN* pbEqual
    )
{
    if (!pKeyFoo || !pKeyBar || !pbEqual)
    {
        return STATUS_INVALID_PARAMETER;
    }

    *pbEqual = (pKeyFoo->keytype == pKeyBar->keytype) &&
             (pKeyFoo->keyvalue.length == pKeyBar->keyvalue.length) &&
             (pKeyFoo->keyvalue.length == RtlCompareMemory(pKeyFoo->keyvalue.value, pKeyBar->keyvalue.value, pKeyFoo->keyvalue.length));

    return STATUS_SUCCESS;
}

//+-------------------------------------------------------------------------
//
//  Function: KerbTrimSKeyList
//
//  Synopsis: Release session key entries that have expired
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbTrimSKeyList(
    VOID
    )
{
    FILETIME CurrentTime = {0};
    BOOLEAN bCleanUpNeeded = FALSE;

    GetSystemTimeAsFileTime(&CurrentTime);

    DebugLog((DEB_TRACE_LOOPBACK, "KerbTrimSKeyList, curtime %#x:%#x\n", CurrentTime.dwHighDateTime, CurrentTime.dwLowDateTime));

    if (SafeAcquireResourceShared(&KerbSKeyLock, TRUE))
    {
        for (LIST_ENTRY* pListEntry = KerbSKeyList.Flink;
             pListEntry != &KerbSKeyList;
             pListEntry = pListEntry->Flink)
        {
           KERB_SESSION_KEY_ENTRY* pSKeyEntry = CONTAINING_RECORD(pListEntry, KERB_SESSION_KEY_ENTRY, ListEntry);

           if (KerbGetTime(* (TimeStamp*)&pSKeyEntry->ExpireTime) <= KerbGetTime(* (TimeStamp*)&CurrentTime))
           {
               bCleanUpNeeded = TRUE;
               break;
           }
        }

        if (bCleanUpNeeded)
        {
            SafeConvertSharedToExclusive(&KerbSKeyLock);

            for (LIST_ENTRY* pListEntry = KerbSKeyList.Flink;
                 pListEntry != &KerbSKeyList;
                 /* updating pListEntry inside the loop */)
            {
               KERB_SESSION_KEY_ENTRY* pSKeyEntry = CONTAINING_RECORD(pListEntry, KERB_SESSION_KEY_ENTRY, ListEntry);

               //
               //  Update next link before pListEntry is deleted
               //

               pListEntry = pListEntry->Flink;

               //
               // only delete keys that expired
               //

               if (KerbGetTime(* (TimeStamp*)&pSKeyEntry->ExpireTime) <= KerbGetTime(* (TimeStamp*)&CurrentTime))
               {
                   KerbFreeSKeyEntry(pSKeyEntry);
               }
            }
        }

        SafeReleaseResource(&KerbSKeyLock);
    }
}

//+-------------------------------------------------------------------------
//
//  Function: KerbSKeyListCleanupCallback
//
//  Synopsis: Clean up network service session key list
//
//  Effects:
//
//  Arguments: pContext - the context parameter, see RtlCreateTimer
//             bTimeOut - whether a timeout has occurred
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbSKeyListCleanupCallback(
    IN VOID* pContext,
    IN BOOLEAN bTimeOut
    )
{
    DebugLog((DEB_TRACE_LOOPBACK, "KerbSKeyListCleanupCallback is called\n"));

    KerbTrimSKeyList();
}

//+-------------------------------------------------------------------------
//
//  Function: KerbFreeSKeyEntry
//
//  Synopsis: Free a session key entry
//
//  Effects:
//
//  Arguments: pSKeyEntry - session key entry to free
//
//  Requires: pSKeyEntry->ListEntry must have been initialized properly
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeSKeyEntry(
    IN KERB_SESSION_KEY_ENTRY* pSKeyEntry
    )
{
    if (pSKeyEntry)
    {
        if (!IsListEmpty(&pSKeyEntry->ListEntry)) // make sure this entry has been linked
        {
            RemoveEntryList(&pSKeyEntry->ListEntry);

#if DBG
            LONG cSKeyEntries = 0;

            cSKeyEntries = InterlockedDecrement(&KerbcSKeyEntries);

            DebugLog((DEB_TRACE_LOOPBACK, "KerbFreeSKeyEntry, keyexpire %#x:%#x, %d keys left\n",
                pSKeyEntry->ExpireTime.dwHighDateTime,
                pSKeyEntry->ExpireTime.dwLowDateTime,
                cSKeyEntries));
#endif
        }

        KerbFreeKey(&pSKeyEntry->SessionKey);

        KerbFree(pSKeyEntry);
    }
}

//+-------------------------------------------------------------------------
//
//  Function: KerbCreateSKeyTimer
//
//  Synopsis: Create a timer and set the callback to clean up the session
//            key list
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateSKeyTimer(
    VOID
    )
{
    NTSTATUS NtStatus;
    HANDLE hTimer = NULL;

    KerbhSKeyTimerQueue = NULL;

    NtStatus = RtlCreateTimerQueue(&KerbhSKeyTimerQueue);

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = RtlCreateTimer(
                        KerbhSKeyTimerQueue,
                        &hTimer,
                        KerbSKeyListCleanupCallback,
                        NULL,  //  no context
                        KERB_DEFAULT_SKEWTIME * 60 * 1000,   // 5 min
                        KERB_DEFAULT_SKEWTIME * KERB_SKLIST_CALLBACK_FEQ * 60 * 1000,    // 50 min
                        0
                        );
    }

    return NtStatus;
}

//+-------------------------------------------------------------------------
//
//  Function: KerbFreeSKeyTimer
//
//  Synopsis: Free network service key list timer queue
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeSKeyTimer(
    VOID
    )
{
    if (KerbhSKeyTimerQueue)
    {
        RtlDeleteTimerQueue(KerbhSKeyTimerQueue);
        KerbhSKeyTimerQueue = NULL;
    }
}

ULONG
HandleToListIndex(
    ULONG_PTR ContextHandle
    )
{
    ASSERT( (KERB_USERLIST_COUNT != 0) );
    ASSERT( (KERB_USERLIST_COUNT & 1) == 0 );

    ULONG Number ;
    ULONG Hash;
    ULONG HashFinal;

    Number       = (ULONG)ContextHandle;

    Hash         = Number;
    Hash        += Number >> 8;
    Hash        += Number >> 16;
    Hash        += Number >> 24;

    HashFinal    = Hash;
    HashFinal   += Hash >> 4;

    //
    // insure power of two if not one.
    //

    return ( HashFinal & (KERB_USERLIST_COUNT-1) ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\gssapi.h ===
/*
 * Copyright 1993 by OpenVision Technologies, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appears in all copies and
 * that both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of OpenVision not be used
 * in advertising or publicity pertaining to distribution of the software
 * without specific, written prior permission. OpenVision makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef _GSSAPI_H_
#define _GSSAPI_H_

/*
 * Determine platform-dependent configuration.
 */

#define GSS_SIZEOF_INT 4
#define GSS_SIZEOF_LONG 4
#define GSS_SIZEOF_SHORT 2


#include <stddef.h>

/*
#include <sys/types.h>

/*
 * The following type must be defined as the smallest natural unsigned integer
 * supported by the platform that has at least 32 bits of precision.
 */
#if (GSS_SIZEOF_SHORT == 4)
typedef unsigned short gss_uint32;
#elif (GSS_SIZEOF_INT == 4)
typedef unsigned int gss_uint32;
#elif (GSS_SIZEOF_LONG == 4)
typedef unsigned long gss_uint32;
#endif

#ifdef  OM_STRING
/*
 * We have included the xom.h header file.  Use the definition for
 * OM_object identifier.
 */
typedef OM_object_identifier    gss_OID_desc, *gss_OID;
#else   /* OM_STRING */
/*
 * We can't use X/Open definitions, so roll our own.
 */
typedef gss_uint32      OM_uint32;

typedef struct gss_OID_desc_struct {
      OM_uint32 length;
      void      SEC_FAR *elements;
} gss_OID_desc, SEC_FAR *gss_OID;
#endif  /* OM_STRING */

#endif /* _GSSAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\gssutil.cxx ===
/*
 * Copyright 1993 by OpenVision Technologies, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appears in all copies and
 * that both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of OpenVision not be used
 * in advertising or publicity pertaining to distribution of the software
 * without specific, written prior permission. OpenVision makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#include <kerb.hxx>
#include <kerbp.h>
#include "gssapiP.h"
// #include <memory.h>

#define VALID_INT_BITS    0x7fffffff


/* XXXX this code currently makes the assumption that a mech oid will
   never be longer than 127 bytes.  This assumption is not inherent in
   the interfaces, so the code can be fixed if the OSI namespace
   balloons unexpectedly. */

/* Each token looks like this:

0x60                            tag for APPLICATION 0, SEQUENCE
                                        (constructed, definite-length)
        <length>                possible multiple bytes, need to parse/generate
        0x06                    tag for OBJECT IDENTIFIER
                <moid_length>   compile-time constant string (assume 1 byte)
                <moid_bytes>    compile-time constant string
        <inner_bytes>           the ANY containing the application token
                                        bytes 0,1 are the token type
                                        bytes 2,n are the token data

For the purposes of this abstraction, the token "header" consists of
the sequence tag and length octets, the mech OID DER encoding, and the
first two inner bytes, which indicate the token type.  The token
"body" consists of everything else.

*/

int
der_length_size(
    int length
    )
{
   if (length < (1<<7))
      return(1);
   else if (length < (1<<8))
      return(2);
   else if (length < (1<<16))
      return(3);
   else if (length < (1<<24))
      return(4);
   else
      return(5);

}

void
der_write_length(
     unsigned char **buf,
     int length
     )
{
   if (length < (1<<7)) {
      *(*buf)++ = (unsigned char) length;
   } else {
      *(*buf)++ = (unsigned char) (der_length_size(length)+127);

      if (length >= (1<<24))
         *(*buf)++ = (unsigned char) (length>>24);
      if (length >= (1<<16))
         *(*buf)++ = (unsigned char) ((length>>16)&0xff);
      if (length >= (1<<8))
         *(*buf)++ = (unsigned char) ((length>>8)&0xff);
      *(*buf)++ = (unsigned char) (length&0xff);
   }
}

/* returns decoded length, or < 0 on failure.  Advances buf and
   decrements bufsize */

int
der_read_length(
     unsigned char **buf,
     int *bufsize
     )
{
   unsigned char sf;
   int ret;

   if (*bufsize < 1)
      return(-1);
   sf = *(*buf)++;
   (*bufsize)--;
   if (sf & 0x80) {
      if ((sf &= 0x7f) > ((*bufsize)-1))
         return(-1);
      if (sf > sizeof(int))
          return (-1);
      ret = 0;
      for (; sf; sf--) {
         ret = (ret<<8) + (*(*buf)++);
         (*bufsize)--;
      }
   } else {
      ret = sf;
   }

   return(ret);
}

/* returns the length of a token, given the mech oid and the body size */

int
g_token_size(
     gss_OID mech,
     unsigned int body_size
     )
{
   /* set body_size to sequence contents size */
   body_size += 4 + (int) mech->length;         /* NEED overflow check */
   return(1 + der_length_size(body_size) + body_size);
}

/* fills in a buffer with the token header.  The buffer is assumed to
   be the right size.  buf is advanced past the token header */

void
g_make_token_header(
     gss_OID mech,
     int body_size,
     unsigned char **buf,
     int tok_type
     )
{
   *(*buf)++ = 0x60;
   der_write_length(buf, 4 + mech->length + body_size);
   *(*buf)++ = 0x06;
   *(*buf)++ = (unsigned char) mech->length;
   TWRITE_STR(*buf, mech->elements, ((int) mech->length));
   *(*buf)++ = (unsigned char) ((tok_type>>8)&0xff);
   *(*buf)++ = (unsigned char) (tok_type&0xff);
}

/* given a buffer containing a token, reads and verifies the token,
   leaving buf advanced past the token header, and setting body_size
   to the number of remaining bytes */

int
g_verify_token_header(
     gss_OID mech,
     int *body_size,
     unsigned char **buf,
     int tok_type,
     int toksize
     )
{
   int seqsize;
   gss_OID_desc toid;

   if ((toksize-=1) < 0)
      return(0);
   if (*(*buf)++ != 0x60)
      return(0);

   if ((seqsize = der_read_length(buf, &toksize)) < 0)
      return(0);

   if (seqsize != toksize)
      return(0);

   if ((toksize-=1) < 0)
      return(0);
   if (*(*buf)++ != 0x06)
      return(0);

   if ((toksize-=1) < 0)
      return(0);
   toid.length = *(*buf)++;

   if ((toid.length & VALID_INT_BITS) != toid.length) /* Overflow??? */
      return(0);
   if ((toksize-= (int) toid.length) < 0)
      return(0);
   toid.elements = *buf;
   (*buf)+=toid.length;

   if (! g_OID_equal(&toid, mech))
      return(0);

   if ((toksize-=2) < 0)
      return(0);

   if ((*(*buf)++ != ((tok_type>>8)&0xff)) ||
       (*(*buf)++ != (tok_type&0xff)))
      return(0);

   *body_size = toksize;

   return(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\gssapip.h ===
/*
 * Copyright 1993 by OpenVision Technologies, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appears in all copies and
 * that both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of OpenVision not be used
 * in advertising or publicity pertaining to distribution of the software
 * without specific, written prior permission. OpenVision makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
 */

#ifndef __GSSAPIP_H__
#define __GSSAPIP_H__

#include "gssapi.h"


/** helper macros **/

#define g_OID_equal(o1,o2) \
   (((o1)->length == (o2)->length) && \
    (memcmp((o1)->elements,(o2)->elements,(int) (o1)->length) == 0))

#define TWRITE_STR(ptr, str, len) \
   memcpy((ptr), (char *) (str), (len)); \
   (ptr) += (len);


/** helper functions **/

int
g_token_size(
    gss_OID      mech,
    unsigned int body_size
    );

void
g_make_token_header(
    gss_OID         mech,
    int             body_size,
    unsigned char **buf,
    int             tok_type
    );

int
g_verify_token_header(
    gss_OID         mech,
    int            *body_size,
    unsigned char **buf,
    int             tok_type,
    int             toksize
    );

int
der_read_length(
     unsigned char **buf,
     int *bufsize
     );

#endif /* __GSSAPIP_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\kerbdbg.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbdbg.h
//
// Contents:    Debug information for Kerberos package
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __KERBDBG_H__
#define __KERBDBG_H__

//
//  NOTE:  DO not remove RETAIL_LOG_SUPPORT from sources,
//  or you'll be busted in DBG builds.
//

#ifdef RETAIL_LOG_SUPPORT

#ifndef WIN32_CHICAGO
DECLARE_DEBUG2(Kerb);
#undef DebugLog
#define DebugLog(_x_)           KerbDebugPrint _x_

#define IF_DEBUG(Function)      if (KerbInfoLevel & (DEB_ ## Function))


#endif // WIN32_CHICAGO

#define WSZ_KERBDEBUGLEVEL      L"KerbDebugLevel"
#define WSZ_FILELOG             L"LogToFile"

VOID
KerbWatchKerbParamKey(PVOID, BOOLEAN);

#define KerbPrintKdcName(Level, Name)  KerbPrintKdcNameEx(KerbInfoLevel, (Level), (Name))


#define DEB_TRACE_API           0x00000008
#undef  DEB_TRACE_CRED
#define DEB_TRACE_CRED          0x00000010
#define DEB_TRACE_CTXT          0x00000020
#define DEB_TRACE_LSESS         0x00000040
#define DEB_TRACE_TCACHE        0x00000080
#define DEB_TRACE_LOGON         0x00000100
#define DEB_TRACE_KDC           0x00000200
#define DEB_TRACE_CTXT2         0x00000400
#define DEB_TRACE_TIME          0x00000800
#define DEB_TRACE_USER          0x00001000
#define DEB_TRACE_LEAKS         0x00002000
#define DEB_TRACE_SOCK          0x00004000
#define DEB_TRACE_SPN_CACHE     0x00008000
#define DEB_S4U_ERROR           0x00010000
#define DEB_TRACE_S4U           0x00020000
#define DEB_TRACE_BND_CACHE     0x00040000
#define DEB_TRACE_LOOPBACK      0x00080000
#define DEB_TRACE_TKT_RENEWAL   0x00100000
#define DEB_TRACE_U2U           0x00200000
#define DEB_TRACE_REFERRAL      0x00400000

#define DEB_DISABLE_SPN_CACHE   0x10000000 // disable SPN cache
#define DEB_DISABLE_BND_CACHE   0x20000000 // disable BND cache

#undef DEB_TRACE_LOCKS
#define DEB_TRACE_LOCKS         0x01000000
#define DEB_USE_LOG_FILE        0x02000000

//  For extended errors
#define DEB_USE_EXT_ERRORS      0x10000000

#define EXT_ERROR_ON(s)         (s & DEB_USE_EXT_ERRORS)


#ifndef WIN32_CHICAGO
VOID
KerbInitializeDebugging(
    VOID
    );
#endif // WIN32_CHICAGO


#else // RETAIL_LOG_SUPPORT

#define DebugLog(_x_)
#define IF_DEBUG(Function)              if (FALSE)
#define KerbInitializeDebugging()
#define KerbPrintKdcName(Level, Name)
#define KerbWatchKerbParamKey()
#define EXT_ERROR_ON(s)                 FALSE


#endif // RETAIL_LOG_SUPPORT

#if DBG

#define D_DebugLog(_x_)          DebugLog(_x_) // don't use all debug spew in retail builds
#define D_KerbPrintKdcName(_x_)  KerbPrintKdcName _x_
#else
#define D_KerbPrintKdcName(_x_)
#define D_DebugLog(_x_)
#endif



#endif // __KERBDBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\kerberos.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerberos.cxx
//
// Contents:    main entrypoints for the Kerberos security package
//
//
// History:     16-April-1996 Created         MikeSw
//              26-Sep-1998   ChandanS
//                            Added more debugging support etc.
//
//------------------------------------------------------------------------


#include <kerb.hxx>
#define KERBP_ALLOCATE
#include <kerbp.h>
#include <userapi.h>
#include <safeboot.h>
#include <wow64t.h>

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
HANDLE g_hParamEvent = NULL;
HKEY   g_hKeyParams = NULL;
#endif

#if DBG
extern LIST_ENTRY GlobalTicketList;
#endif


//
// Flags for initialization progress in SpInitialize
//

#define KERB_INIT_EVENTS                0x00000001
#define KERB_INIT_KDC_DATA              0x00000002
#define KERB_INIT_OPEN_POLICY           0x00000004
#define KERB_INIT_COMPUTER_NAME         0x00000008
#define KERB_INIT_SCAVENGER             0x00000010
#define KERB_INIT_LOGON_SESSION         0x00000020
#define KERB_INIT_TICKET                0x00000040
#define KERB_INIT_DOMAIN_NAME           0x00000100
#define KERB_INIT_CRED_LIST             0x00000200
#define KERB_INIT_CONTEXT_LIST          0x00000400
#define KERB_INIT_TICKET_CACHE          0x00000800
#define KERB_INIT_BINDING_CACHE         0x00001000
#define KERB_INIT_SPN_CACHE             0x00002000
#define KERB_INIT_S4U_CACHE             0x00004000
#define KERB_INIT_MIT                   0x00008000
#define KERB_INIT_PKINIT                0x00010000
#define KERB_INIT_SOCKETS               0x00020000
#define KERB_INIT_DOMAIN_CHANGE         0x00040000
#define KERB_INIT_NS_LOOKBACK_DETECTION 0x00080000
#define KERB_INIT_NS_TIMER              0x00100000

#ifndef WIN32_CHICAGO
#ifdef RETAIL_LOG_SUPPORT

DEFINE_DEBUG2(Kerb);
extern DWORD KSuppInfoLevel; // needed to adjust values for common2 dir
HANDLE g_hWait = NULL;

DEBUG_KEY   KerbDebugKeys[] = { {DEB_ERROR,         "Error"},
                                {DEB_WARN,          "Warn"},
                                {DEB_TRACE,         "Trace"},
                                {DEB_TRACE_API,     "API"},
                                {DEB_TRACE_CRED,    "Cred"},
                                {DEB_TRACE_CTXT,    "Ctxt"},
                                {DEB_TRACE_LSESS,   "LSess"},
                                {DEB_TRACE_LOGON,   "Logon"},
                                {DEB_TRACE_KDC,     "KDC"},
                                {DEB_TRACE_CTXT2,   "Ctxt2"},
                                {DEB_TRACE_TIME,    "Time"},
                                {DEB_TRACE_LOCKS,   "Locks"},
                                {DEB_TRACE_LEAKS,   "Leaks"},
                                {DEB_TRACE_SPN_CACHE, "SPN"},
                                {DEB_S4U_ERROR,       "S4uErr"},
                                {DEB_TRACE_S4U,       "S4u"},
                                {DEB_TRACE_BND_CACHE, "Bnd"},
                                {DEB_TRACE_LOOPBACK,  "LoopBack"},
                                {DEB_TRACE_TKT_RENEWAL, "Renew"},
                                {DEB_TRACE_U2U,         "U2U"},
                                {DEB_TRACE_REFERRAL,    "Refer"},
                                {0,                  NULL},
                              };

VOID
KerbInitializeDebugging(
    VOID
    )
{
    KerbInitDebug(KerbDebugKeys);
}

#endif // RETAIL_LOG_SUPPORT

////////////////////////////////////////////////////////////////////
//
//  Name:       KerbGetKerbRegParams
//
//  Synopsis:   Gets the debug paramaters from the registry
//
//  Arguments:  HKEY to HKLM/System/CCS/LSA/Kerberos/Parameters
//
//  Notes:      Sets KerbInfolevel for debug spew
//
//
void
KerbGetKerbRegParams(HKEY ParamKey)
{

    DWORD       cbType, Value, cbSize;
    DWORD       dwErr;

#ifdef RETAIL_LOG_SUPPORT

    cbSize = sizeof(Value);
    Value = KerbInfoLevel;

    dwErr = RegQueryValueExW(
                ParamKey,
                WSZ_KERBDEBUGLEVEL,
                NULL,
                &cbType,
                (LPBYTE)&Value,
                &cbSize
                );

    if (dwErr != ERROR_SUCCESS || cbType != REG_DWORD)
    {
        if (dwErr ==  ERROR_FILE_NOT_FOUND)
        {
            // no registry value is present, don't want info
            // so reset to defaults
#if DBG
            KSuppInfoLevel = KerbInfoLevel = DEB_ERROR;
#else // fre
            KSuppInfoLevel = KerbInfoLevel = 0;
#endif
        }else{
            D_DebugLog((DEB_WARN, "Failed to query DebugLevel: 0x%x\n", dwErr));
        }
    }

    KSuppInfoLevel = KerbInfoLevel = Value;

    cbSize = sizeof(Value);

    dwErr = RegQueryValueExW(
               ParamKey,
               WSZ_FILELOG,
               NULL,
               &cbType,
               (LPBYTE)&Value,
               &cbSize
               );

    if (dwErr == ERROR_SUCCESS)
    {
       KerbSetLoggingOption((BOOL) Value);
    }
    else if (dwErr == ERROR_FILE_NOT_FOUND)
    {
       KerbSetLoggingOption(FALSE);
    }


#endif // RETAIL_LOG_SUPPORT

    cbSize = sizeof(Value);

    dwErr = RegQueryValueExW(
               ParamKey,
               KERB_PARAMETER_RETRY_PDC,
               NULL,
               &cbType,
               (LPBYTE)&Value,
               &cbSize
               );

    if (dwErr == ERROR_SUCCESS)
    {
        if ( Value != 0 )
        {
            KerbGlobalRetryPdc = TRUE;
        }
        else
        {
            KerbGlobalRetryPdc = FALSE;
        }
    }
    else if (dwErr == ERROR_FILE_NOT_FOUND)
    {
        KerbGlobalRetryPdc = FALSE;
    }

    //
    // Bug 356539: configuration key to regulate whether clients request
    //             addresses in tickets
    //

    cbSize = sizeof(Value);

    dwErr = RegQueryValueExW(
               ParamKey,
               KERB_PARAMETER_CLIENT_IP_ADDRESSES,
               NULL,
               &cbType,
               (LPBYTE)&Value,
               &cbSize
               );

    if (dwErr == ERROR_SUCCESS)
    {
        if ( Value != 0 )
        {
            KerbGlobalUseClientIpAddresses = TRUE;
        }
        else
        {
            KerbGlobalUseClientIpAddresses = FALSE;
        }
    }
    else if (dwErr == ERROR_FILE_NOT_FOUND)
    {
        KerbGlobalUseClientIpAddresses = KERB_DEFAULT_CLIENT_IP_ADDRESSES;
    }

    //
    // Bug 353767: configuration key to regulate the TGT renewal interval
    //

    cbSize = sizeof(Value);

    dwErr = RegQueryValueExW(
               ParamKey,
               KERB_PARAMETER_TGT_RENEWAL_TIME,
               NULL,
               &cbType,
               (LPBYTE)&Value,
               &cbSize
               );

    if (dwErr == ERROR_SUCCESS)
    {
        KerbGlobalTgtRenewalTime = Value;
    }
    else if (dwErr == ERROR_FILE_NOT_FOUND)
    {
        KerbGlobalTgtRenewalTime = KERB_DEFAULT_TGT_RENEWAL_TIME;
    }

    cbSize = sizeof(Value);

    dwErr = RegQueryValueExW(
               ParamKey,
               KERB_PARAMETER_LOG_LEVEL,
               NULL,
               &cbType,
               (LPBYTE)&Value,
               &cbSize
               );

    if (dwErr == ERROR_SUCCESS)
    {
        KerbGlobalLoggingLevel = Value;
    }
    else if (dwErr == ERROR_FILE_NOT_FOUND)
    {
        KerbGlobalLoggingLevel = KERB_DEFAULT_LOGLEVEL;
    }

    cbSize = sizeof(Value);

    dwErr = RegQueryValueExW(
               ParamKey,
               KERB_PARAMETER_ALLOW_TGT_SESSION_KEY,
               NULL,
               &cbType,
               (LPBYTE)&Value,
               &cbSize
               );

    if (dwErr == ERROR_SUCCESS)
    {
        KerbGlobalAllowTgtSessionKey = ( Value != 0 );
    }
    else if (dwErr == ERROR_FILE_NOT_FOUND)
    {
        KerbGlobalAllowTgtSessionKey = KERB_DEFAULT_ALLOW_TGT_SESSION_KEY;
    }

    dwErr = RegQueryValueExW(
               ParamKey,
               KERB_PARAMETER_MAX_TICKETS,
               NULL,
               &cbType,
               (LPBYTE)&Value,
               &cbSize
               );

    if ( dwErr == ERROR_SUCCESS && cbType == REG_DWORD )
    {
        KerbGlobalMaxTickets = Value;
    }
    else if (dwErr == ERROR_FILE_NOT_FOUND)
    {
        KerbGlobalMaxTickets = KERB_TICKET_COLLECTOR_THRESHHOLD;
    } 

    return;
}


////////////////////////////////////////////////////////////////////
//
//  Name:       KerbWaitCleanup
//
//  Synopsis:   Cleans up wait from KerbWatchParamKey()
//
//  Arguments:  <none>
//
//  Notes:      .
//
void
KerbWaitCleanup()
{

    NTSTATUS Status = STATUS_SUCCESS;

    if (NULL != g_hWait) {
        Status = RtlDeregisterWait(g_hWait);
        if (NT_SUCCESS(Status) && NULL != g_hParamEvent ) {
            CloseHandle(g_hParamEvent);
        }
    }
}


////////////////////////////////////////////////////////////////////
//
//  Name:       KerbWatchParamKey
//
//  Synopsis:   Sets RegNotifyChangeKeyValue() on param key, initializes
//              debug level, then utilizes thread pool to wait on
//              changes to this registry key.  Enables dynamic debug
//              level changes, as this function will also be callback
//              if registry key modified.
//
//  Arguments:  pCtxt is actually a HANDLE to an event.  This event
//              will be triggered when key is modified.
//
//  Notes:      .
//
VOID
KerbWatchKerbParamKey(PVOID    pCtxt,
                  BOOLEAN  fWaitStatus)
{
    NTSTATUS    Status;
    LONG        lRes = ERROR_SUCCESS;

    if (NULL == g_hKeyParams)  // first time we've been called.
    {
        lRes = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    KERB_PARAMETER_PATH,
                    0,
                    KEY_READ,
                    &g_hKeyParams);

        if ( lRes == ERROR_FILE_NOT_FOUND )
        {
            HKEY KerbKey;

            lRes = RegOpenKeyEx(
                       HKEY_LOCAL_MACHINE,
                       KERB_PATH,
                       0,
                       KEY_CREATE_SUB_KEY,
                       &KerbKey
                       );

            if ( lRes == ERROR_SUCCESS )
            {
                lRes = RegCreateKeyExW(
                           KerbKey,
                           L"Parameters",
                           0,
                           NULL,
                           0,
                           KEY_READ,
                           NULL,
                           &g_hKeyParams,
                           NULL
                           );

                 RegCloseKey( KerbKey );
            }
        }

        if (ERROR_SUCCESS != lRes)
        {
            D_DebugLog((DEB_WARN,"Failed to open kerberos key: 0x%x\n", lRes));
            goto Reregister;
        }
    }

    if (NULL != g_hWait)
    {
        Status = RtlDeregisterWait(g_hWait);
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_WARN, "Failed to Deregister wait on registry key: 0x%x\n", Status));
            goto Reregister;
        }
    }

    lRes = RegNotifyChangeKeyValue(
                g_hKeyParams,
                FALSE,
                REG_NOTIFY_CHANGE_LAST_SET,
                (HANDLE) pCtxt,
                TRUE);

    if (ERROR_SUCCESS != lRes)
    {
        D_DebugLog((DEB_ERROR,"Debug RegNotify setup failed: 0x%x\n", lRes));
        // we're tanked now. No further notifications, so get this one
    }

    KerbGetKerbRegParams(g_hKeyParams);

Reregister:

    Status = RtlRegisterWait(&g_hWait,
                             (HANDLE) pCtxt,
                             KerbWatchKerbParamKey,
                             (HANDLE) pCtxt,
                             INFINITE,
                             WT_EXECUTEINPERSISTENTIOTHREAD|
                             WT_EXECUTEONLYONCE);
}

NTSTATUS NTAPI
SpCleanup(
    DWORD dwProgress
    );


BOOL
DllMain(
    HINSTANCE Module,
    ULONG Reason,
    PVOID Context
    )
{
    if ( Reason == DLL_PROCESS_ATTACH )
    {
        DisableThreadLibraryCalls( Module );
#ifdef RETAIL_LOG_SUPPORT
        KerbInitializeDebugging();
#endif

#if DBG
        if ( !NT_SUCCESS( SafeLockInit( KERB_MAX_LOCK_ENUM, TRUE ))) {

            return FALSE;
        }
#endif
    }
    else if ( Reason == DLL_PROCESS_DETACH )
    {
#if RETAIL_LOG_SUPPORT
        KerbUnloadDebug();
#endif
        KerbWaitCleanup();

#if DBG
        SafeLockCleanup();
#endif
    }

    return TRUE ;
}


//+-------------------------------------------------------------------------
//
//  Function:   SpLsaModeInitialize
//
//  Synopsis:   This function is called by the LSA when this DLL is loaded.
//              It returns security package function tables for all
//              security packages in the DLL.
//
//  Effects:
//
//  Arguments:  LsaVersion - Version number of the LSA
//              PackageVersion - Returns version number of the package
//              Tables - Returns array of function tables for the package
//              TableCount - Returns number of entries in array of
//                      function tables.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpLsaModeInitialize(
    IN ULONG LsaVersion,
    OUT PULONG PackageVersion,
    OUT PSECPKG_FUNCTION_TABLE * Tables,
    OUT PULONG TableCount
    )
{
    g_hParamEvent = CreateEvent(NULL,
                           FALSE,
                           FALSE,
                           NULL);

    if (NULL == g_hParamEvent)
    {
        D_DebugLog((DEB_WARN, "CreateEvent for ParamEvent failed - 0x%x\n", GetLastError()));

    } else {

        KerbWatchKerbParamKey(g_hParamEvent, FALSE);
    }

    if (LsaVersion != SECPKG_INTERFACE_VERSION)
    {
        D_DebugLog((DEB_ERROR,"Invalid LSA version: %d. %ws, line %d\n",LsaVersion, THIS_FILE, __LINE__));
        return(STATUS_INVALID_PARAMETER);
    }

    KerberosFunctionTable.InitializePackage = NULL;;
    KerberosFunctionTable.LogonUser = NULL;
    KerberosFunctionTable.CallPackage = LsaApCallPackage;
    KerberosFunctionTable.LogonTerminated = LsaApLogonTerminated;
    KerberosFunctionTable.CallPackageUntrusted = LsaApCallPackageUntrusted;
    KerberosFunctionTable.LogonUserEx2 = LsaApLogonUserEx2;
    KerberosFunctionTable.Initialize = SpInitialize;
    KerberosFunctionTable.Shutdown = SpShutdown;
    KerberosFunctionTable.GetInfo = SpGetInfo;
    KerberosFunctionTable.AcceptCredentials = SpAcceptCredentials;
    KerberosFunctionTable.AcquireCredentialsHandle = SpAcquireCredentialsHandle;
    KerberosFunctionTable.FreeCredentialsHandle = SpFreeCredentialsHandle;
    KerberosFunctionTable.QueryCredentialsAttributes = SpQueryCredentialsAttributes;
    KerberosFunctionTable.SaveCredentials = SpSaveCredentials;
    KerberosFunctionTable.GetCredentials = SpGetCredentials;
    KerberosFunctionTable.DeleteCredentials = SpDeleteCredentials;
    KerberosFunctionTable.InitLsaModeContext = SpInitLsaModeContext;
    KerberosFunctionTable.AcceptLsaModeContext = SpAcceptLsaModeContext;
    KerberosFunctionTable.DeleteContext = SpDeleteContext;
    KerberosFunctionTable.ApplyControlToken = SpApplyControlToken;
    KerberosFunctionTable.GetUserInfo = SpGetUserInfo;
    KerberosFunctionTable.GetExtendedInformation = SpGetExtendedInformation;
    KerberosFunctionTable.QueryContextAttributes = SpQueryLsaModeContextAttributes;
    KerberosFunctionTable.CallPackagePassthrough = LsaApCallPackagePassthrough;


    *PackageVersion = SECPKG_INTERFACE_VERSION;

    *TableCount = 1;
    *Tables = &KerberosFunctionTable;

    // initialize event tracing (a/k/a WMI tracing, software tracing)
    KerbInitializeTrace();

    SafeAllocaInitialize(SAFEALLOCA_USE_DEFAULT,
                         SAFEALLOCA_USE_DEFAULT,
                         KerbAllocate,
                         KerbFree);

    return(STATUS_SUCCESS);
}
#endif // WIN32_CHICAGO


//+-------------------------------------------------------------------------
//
//  Function:   SpInitialize
//
//  Synopsis:   Initializes the Kerberos package
//
//  Effects:
//
//  Arguments:  PackageId - Contains ID for this package assigned by LSA
//              Parameters - Contains machine-specific information
//              FunctionTable - Contains table of LSA helper routines
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
SpInitialize(
    IN ULONG_PTR PackageId,
    IN PSECPKG_PARAMETERS Parameters,
    IN PLSA_SECPKG_FUNCTION_TABLE FunctionTable
    )
{
    NTSTATUS Status;
    UNICODE_STRING TempUnicodeString;
    DWORD dwProgress = 0;

#if DBG
    Status = SafeLockInit( KERB_MAX_LOCK_ENUM, TRUE );

    if ( !NT_SUCCESS( Status )) {

        return Status;
    }
#endif

#if DBG
    InitializeListHead( &GlobalTicketList );
#endif

#ifndef WIN32_CHICAGO

    WCHAR SafeBootEnvVar[sizeof(SAFEBOOT_MINIMAL_STR_W) + sizeof(WCHAR)];

    __try
    {
        SafeInitializeResource(&KerberosGlobalResource, GLOBAL_RESOURCE_LOCK_ENUM);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

#endif // WIN32_CHICAGO

    KerberosPackageId = PackageId;
    LsaFunctions = FunctionTable;

#ifndef WIN32_CHICAGO
    KerberosState = KerberosLsaMode;
#else // WIN32_CHICAGO
    KerberosState = KerberosUserMode;
#endif // WIN32_CHICAGO


    RtlInitUnicodeString(
        &KerbPackageName,
        MICROSOFT_KERBEROS_NAME_W
        );

#ifndef WIN32_CHICAGO

    // Check if we are in safe boot.

    //
    // Does environment variable exist
    //

    RtlZeroMemory( SafeBootEnvVar, sizeof( SafeBootEnvVar ) );

    KerbGlobalSafeModeBootOptionPresent = FALSE;

    if ( GetEnvironmentVariable(L"SAFEBOOT_OPTION", SafeBootEnvVar, sizeof(SafeBootEnvVar)/sizeof(SafeBootEnvVar[0]) ) )
    {
        if ( !wcscmp( SafeBootEnvVar, SAFEBOOT_MINIMAL_STR_W ) )
        {
            KerbGlobalSafeModeBootOptionPresent = TRUE;
        }
    }

#endif // WIN32_CHICAGO

    Status = KerbInitializeEvents();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    dwProgress |= KERB_INIT_EVENTS;

    //
    // Init data for the kdc calling routine
    //

#ifndef WIN32_CHICAGO

    Status = KerbInitKdcData();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    dwProgress |= KERB_INIT_KDC_DATA;

    //
    // init global LSA policy handle.
    //

    Status = LsaIOpenPolicyTrusted(
                &KerbGlobalPolicyHandle
                );

    if(!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    dwProgress |= KERB_INIT_OPEN_POLICY;

#endif // WIN32_CHICAGO

    //
    // Get our global role
    //

    if ((Parameters->MachineState & SECPKG_STATE_DOMAIN_CONTROLLER) != 0)
    {
        //
        // We will behave like a member workstation/server until the DS
        // says we are ready to act as a DC
        //

        KerbGlobalRole = KerbRoleWorkstation;
    }
    else if ((Parameters->MachineState & SECPKG_STATE_WORKSTATION) != 0)
    {
        KerbGlobalRole = KerbRoleWorkstation;
    }
    else
    {
        KerbGlobalRole = KerbRoleStandalone;
    }

    //
    // Fill in various useful constants
    //

    KerbSetTime(&KerbGlobalWillNeverTime, MAXTIMEQUADPART);
    KerbSetTime(&KerbGlobalHasNeverTime, 0);

    //
    // compute blank password hashes.
    //

    Status = RtlCalculateLmOwfPassword( "", &KerbGlobalNullLmOwfPassword );
    ASSERT( NT_SUCCESS(Status) );

    RtlInitUnicodeString(&TempUnicodeString, NULL);
    Status = RtlCalculateNtOwfPassword(&TempUnicodeString,
                                       &KerbGlobalNullNtOwfPassword);
    ASSERT( NT_SUCCESS(Status) );

    RtlInitUnicodeString(
        &KerbGlobalKdcServiceName,
        KDC_PRINCIPAL_NAME
        );

    //
    // At some point we may want to read the registry here to
    // find out whether we need to enforce times, currently times
    // are always enforced.
    //

    KerbGlobalEnforceTime = FALSE;
    KerbGlobalMachineNameChanged = FALSE;

    //
    // Get the machine Name
    //

    Status = KerbSetComputerName();


    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog((DEB_ERROR,"KerbSetComputerName failed\n"));
        goto Cleanup;
    }

    dwProgress |= KERB_INIT_COMPUTER_NAME;

    //
    // Initialize the scavenger
    //

    Status = KerbInitializeScavenger();

    if ( !NT_SUCCESS( Status )) {

        D_DebugLog((DEB_ERROR,"KerbInitializeScavengerFailed\n"));
        goto Cleanup;
    }

    dwProgress |= KERB_INIT_SCAVENGER;

    //
    // Initialize the logon session list. This has to be done because
    // KerbSetDomainName will try to acess the logon session list
    //

    Status = KerbInitLogonSessionList();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize logon session list: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

    dwProgress |= KERB_INIT_LOGON_SESSION;

    Status = KerbInitLoopbackDetection();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize network service loopback detection: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

    dwProgress |= KERB_INIT_NS_LOOKBACK_DETECTION;

    Status = KerbCreateSKeyTimer();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize network service session key list timer: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

    dwProgress |= KERB_INIT_NS_TIMER;

    Status = KerbInitTicketHandling();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize ticket handling: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    dwProgress |= KERB_INIT_TICKET;


    //
    // Update all global structures referencing the domain name
    //

    Status = KerbSetDomainName(
                &Parameters->DomainName,
                &Parameters->DnsDomainName,
                Parameters->DomainSid,
                Parameters->DomainGuid
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    dwProgress |= KERB_INIT_DOMAIN_NAME;

    //
    // Initialize the internal Kerberos lists
    //


    Status = KerbInitCredentialList();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize credential list: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

    dwProgress |= KERB_INIT_CRED_LIST;

    Status = KerbInitContextList();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize context list: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

    dwProgress |= KERB_INIT_CONTEXT_LIST;

    Status = KerbInitTicketCaching();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize ticket cache: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;

    }

    dwProgress |= KERB_INIT_TICKET_CACHE;

    Status = KerbInitBindingCache();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize binding cache: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    dwProgress |= KERB_INIT_BINDING_CACHE;

    Status = KerbInitSpnCache();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize SPN cache: 0x%x. %ws, line %d\n",
                  Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    dwProgress |= KERB_INIT_SPN_CACHE;

    Status = KerbInitS4UCache();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize SPN cache: 0x%x. %ws, line %d\n",
                  Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    dwProgress |= KERB_INIT_S4U_CACHE;

    Status = KerbInitializeMitRealmList();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize MIT realm list: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

    dwProgress |= KERB_INIT_MIT;

    Status = KerbInitUdpStatistics();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize UdpStats: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }



#ifndef WIN32_CHICAGO

    Status = KerbInitializePkinit();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize PKINT: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    dwProgress |= KERB_INIT_PKINIT;

#endif // WIN32_CHICAGO

    Status = KerbInitializeSockets(
                MAKEWORD(1,1),          // we want version 1.1
                1,                      // we need at least 1 socket
                &KerbGlobalNoTcpUdp
                );

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to initialize sockets: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    dwProgress |= KERB_INIT_SOCKETS;

#ifndef WIN32_CHICAGO

    Status = KerbRegisterForDomainChange();
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR, "Failed to register for domain change notification: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    dwProgress |= KERB_INIT_DOMAIN_CHANGE;

    //
    // Check to see if there is a CSP registered for replacing the StringToKey calculation
    //
    CheckForOutsideStringToKey();


    //
    // See if there are any "join hints" to process
    //
    ReadInitialDcRecord(
       &KerbGlobalInitialDcRecord,
       &KerbGlobalInitialDcAddressType,
       &KerbGlobalInitialDcFlags
       );


    KerbGlobalRunningServer = KerbRunningServer();


#endif // WIN32_CHICAGO

    KerbGlobalInitialized = TRUE;

Cleanup:

    //
    // If we failed to initialize, shutdown
    //

    if (!NT_SUCCESS(Status))
    {
        SpCleanup(dwProgress);
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   SpCleanup
//
//  Synopsis:   Function to shutdown the Kerberos package.
//
//  Effects:    Forces the freeing of all credentials, contexts and
//              logon sessions and frees all global data
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:
//
//  Notes:      STATUS_SUCCESS in all cases
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
SpCleanup(
    DWORD dwProgress
    )
{
    KerbGlobalInitialized = FALSE;

    if (dwProgress & KERB_INIT_SCAVENGER)
    {
        KerbShutdownScavenger();
    }

#ifndef WIN32_CHICAGO

    if (dwProgress & KERB_INIT_DOMAIN_CHANGE)
    {
        KerbUnregisterForDomainChange();
    }

#endif // WIN32_CHICAGO

    if (dwProgress & KERB_INIT_LOGON_SESSION)
    {
        KerbFreeLogonSessionList();
    }

    if (dwProgress & KERB_INIT_NS_LOOKBACK_DETECTION)
    {
        KerbFreeSKeyListAndLock();
    }

    if (dwProgress & KERB_INIT_NS_TIMER)
    {
        KerbFreeSKeyTimer();
    }

    if (dwProgress & KERB_INIT_CONTEXT_LIST)
    {
        KerbFreeContextList();
    }

    if (dwProgress & KERB_INIT_TICKET_CACHE)
    {
        KerbFreeTicketCache();
    }

    // if (dwProgress & KERB_INIT_CRED_LIST)
    // {
    //     KerbFreeCredentialList();
    // }

    KerbFreeString(&KerbGlobalDomainName);
    KerbFreeString(&KerbGlobalDnsDomainName);
    KerbFreeString(&KerbGlobalMachineName);
    KerbFreeString((PUNICODE_STRING) &KerbGlobalKerbMachineName);
    KerbFreeString(&KerbGlobalMachineServiceName);
    KerbFreeKdcName(&KerbGlobalMitMachineServiceName);

    if (dwProgress & KERB_INIT_TICKET)
    {
        KerbCleanupTicketHandling();
    }

#ifndef WIN32_CHICAGO

    if (KerbGlobalPolicyHandle != NULL)
    {
        ASSERT(dwProgress & KERB_INIT_OPEN_POLICY);

        LsarClose( &KerbGlobalPolicyHandle );
        KerbGlobalPolicyHandle = NULL;
    }

    if (KerbGlobalDomainSid != NULL)
    {
        KerbFree(KerbGlobalDomainSid);
    }

#endif // WIN32_CHICAGO

    if (dwProgress & KERB_INIT_SOCKETS)
    {
        KerbCleanupSockets();
    }

    if (dwProgress & KERB_INIT_BINDING_CACHE)
    {
        KerbCleanupBindingCache(TRUE);
    }

    if (dwProgress & KERB_INIT_MIT)
    {
        KerbUninitializeMitRealmList();
    }

#ifndef WIN32_CHICAGO

    if (dwProgress & KERB_INIT_KDC_DATA)
    {
        KerbFreeKdcData();
    }

//    RtlDeleteResource(&KerberosGlobalResource);

#endif // WIN32_CHICGAO

    if (dwProgress & KERB_INIT_EVENTS)
    {
        KerbShutdownEvents();
    }

    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------------
//
//  Function:   SpShutdown
//
//  Synopsis:   Exported function to shutdown the Kerberos package.
//
//  Effects:    Forces the freeing of all credentials, contexts and
//              logon sessions and frees all global data
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:
//
//  Notes:      STATUS_SUCCESS in all cases
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpShutdown(
    VOID
    )
{
#if 0
    SpCleanup(0);
#endif
    return(STATUS_SUCCESS);
}


#ifndef WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   SpGetInfo
//
//  Synopsis:   Returns information about the package
//
//  Effects:    returns pointers to global data
//
//  Arguments:  PackageInfo - Receives kerberos package information
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS in all cases
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpGetInfo(
    OUT PSecPkgInfo PackageInfo
    )
{
    PackageInfo->wVersion = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
    PackageInfo->wRPCID = RPC_C_AUTHN_GSS_KERBEROS;
    PackageInfo->fCapabilities = KERBEROS_CAPABILITIES;
    PackageInfo->cbMaxToken       = KerbGlobalMaxTokenSize;
    PackageInfo->Name             = KERBEROS_PACKAGE_NAME;
    PackageInfo->Comment          = KERBEROS_PACKAGE_COMMENT;
    return(STATUS_SUCCESS);
}



//+-------------------------------------------------------------------------
//
//  Function:   SpGetExtendedInformation
//
//  Synopsis:   returns additional information about the package
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
SpGetExtendedInformation(
    IN  SECPKG_EXTENDED_INFORMATION_CLASS Class,
    OUT PSECPKG_EXTENDED_INFORMATION * ppInformation
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PSECPKG_EXTENDED_INFORMATION Information = NULL ;
    PSECPKG_SERIALIZED_OID SerializedOid;
    ULONG Size ;

    switch(Class) {
    case SecpkgGssInfo:
        DsysAssert(gss_mech_krb5_new->length >= 2);
        DsysAssert(gss_mech_krb5_new->length < 127);

        //
        // We need to leave space for the oid and the BER header, which is
        // 0x6 and then the length of the oid.
        //

        Information = (PSECPKG_EXTENDED_INFORMATION)
                            KerbAllocate(sizeof(SECPKG_EXTENDED_INFORMATION) +
                            gss_mech_krb5_new->length - 2);
        if (Information == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Information->Class = SecpkgGssInfo;
        Information->Info.GssInfo.EncodedIdLength = gss_mech_krb5_new->length + 2;
        Information->Info.GssInfo.EncodedId[0] = 0x6;   // BER OID type
        Information->Info.GssInfo.EncodedId[1] = (UCHAR) gss_mech_krb5_new->length;
        RtlCopyMemory(
            &Information->Info.GssInfo.EncodedId[2],
            gss_mech_krb5_new->elements,
            gss_mech_krb5_new->length
            );

            *ppInformation = Information;
            Information = NULL;
        break;
    case SecpkgContextThunks:
        //
        // Note - we don't need to add any space for the thunks as there
        // is only one, and the structure has space for one. If any more
        // thunks are added, we will need to add space for those.
        //

        Information = (PSECPKG_EXTENDED_INFORMATION)
                            KerbAllocate(sizeof(SECPKG_EXTENDED_INFORMATION));
        if (Information == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        Information->Class = SecpkgContextThunks;
        Information->Info.ContextThunks.InfoLevelCount = 1;
        Information->Info.ContextThunks.Levels[0] = SECPKG_ATTR_NATIVE_NAMES;
        *ppInformation = Information;
        Information = NULL;
        break;

    case SecpkgWowClientDll:

        //
        // This indicates that we're smart enough to handle wow client processes
        //

        Information = (PSECPKG_EXTENDED_INFORMATION)
                            KerbAllocate( sizeof( SECPKG_EXTENDED_INFORMATION ) +
                                          (MAX_PATH * sizeof(WCHAR) ) );

        if ( Information == NULL )
        {
            Status = STATUS_INSUFFICIENT_RESOURCES ;
            goto Cleanup ;
        }

        Information->Class = SecpkgWowClientDll ;
        Information->Info.WowClientDll.WowClientDllPath.Buffer = (PWSTR) (Information + 1);
        Size = ExpandEnvironmentStrings(
                    L"%SystemRoot%\\" WOW64_SYSTEM_DIRECTORY_U L"\\Kerberos.DLL",
                    Information->Info.WowClientDll.WowClientDllPath.Buffer,
                    MAX_PATH );
        Information->Info.WowClientDll.WowClientDllPath.Length = (USHORT) (Size * sizeof(WCHAR));
        Information->Info.WowClientDll.WowClientDllPath.MaximumLength = (USHORT) ((Size + 1) * sizeof(WCHAR) );
        *ppInformation = Information ;
        Information = NULL ;

        break;

    case SecpkgExtraOids:
        Size = sizeof( SECPKG_EXTENDED_INFORMATION ) +
                2 * sizeof( SECPKG_SERIALIZED_OID ) ;

        Information = (PSECPKG_EXTENDED_INFORMATION)
                            KerbAllocate( Size );


        if ( Information == NULL )
        {
            Status = STATUS_INSUFFICIENT_RESOURCES ;
            goto Cleanup ;
        }
        Information->Class = SecpkgExtraOids ;
        Information->Info.ExtraOids.OidCount = 2 ;

        SerializedOid = Information->Info.ExtraOids.Oids;

        SerializedOid->OidLength = gss_mech_krb5_spnego->length + 2;
        SerializedOid->OidAttributes = SECPKG_CRED_BOTH ;
        SerializedOid->OidValue[ 0 ] = 0x06 ; // BER OID type
        SerializedOid->OidValue[ 1 ] = (UCHAR) gss_mech_krb5_spnego->length;
        RtlCopyMemory(
            &SerializedOid->OidValue[2],
            gss_mech_krb5_spnego->elements,
            gss_mech_krb5_spnego->length
            );

        SerializedOid++ ;

        SerializedOid->OidLength = gss_mech_krb5_u2u->length + 2;
        SerializedOid->OidAttributes = SECPKG_CRED_INBOUND ;
        SerializedOid->OidValue[ 0 ] = 0x06 ; // BER OID type
        SerializedOid->OidValue[ 1 ] = (UCHAR) gss_mech_krb5_u2u->length;
        RtlCopyMemory(
            &SerializedOid->OidValue[2],
            gss_mech_krb5_u2u->elements,
            gss_mech_krb5_u2u->length
            );

        *ppInformation = Information ;
        Information = NULL ;
        break;

    default:
        return(STATUS_INVALID_INFO_CLASS);
    }
Cleanup:
    if (Information != NULL)
    {
        KerbFree(Information);
    }
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   LsaApInitializePackage
//
//  Synopsis:   Obsolete pacakge initialize function, supported for
//              compatibility only. This function has no effect.
//
//  Effects:    none
//
//  Arguments:
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS always
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
LsaApInitializePackage(
    IN ULONG AuthenticationPackageId,
    IN PLSA_DISPATCH_TABLE LsaDispatchTable,
    IN PLSA_STRING Database OPTIONAL,
    IN PLSA_STRING Confidentiality OPTIONAL,
    OUT PLSA_STRING *AuthenticationPackageName
    )
{
    return(STATUS_SUCCESS);
}

BOOLEAN
KerbIsInitialized(
    VOID
    )
{
    return KerbGlobalInitialized;
}

NTSTATUS
KerbKdcCallBack(
    VOID
    )
{
    PKERB_BINDING_CACHE_ENTRY CacheEntry = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    KerbGlobalWriteLock();

    KerbGlobalRole = KerbRoleDomainController;

    Status = KerbLoadKdc();


    //
    // Purge the binding cache of entries for this domain
    //

    CacheEntry = KerbLocateBindingCacheEntry(
                    &KerbGlobalDnsDomainName,
                    0,
                    TRUE
                    );
    if (CacheEntry != NULL)
    {
        KerbDereferenceBindingCacheEntry(CacheEntry);
    }
    CacheEntry = KerbLocateBindingCacheEntry(
                    &KerbGlobalDomainName,
                    0,
                    TRUE
                    );
    if (CacheEntry != NULL)
    {
        KerbDereferenceBindingCacheEntry(CacheEntry);
    }

    //
    // PurgeSpnCache, because we may now have "better" state,
    // e.g. right after DCPromo our SPNs may not have replicated.
    // For DCs, we can not even care about the spncache.
    //
    KerbCleanupSpnCache();
    KerbSetTimeInMinutes(&KerbGlobalSpnCacheTimeout, 0);

    KerbGlobalReleaseLock();

    return Status;
}


VOID
FreAssert(
    IN BOOL Expression,
    IN CHAR * String
    )
{
    static BOOL KdPresenceChecked = FALSE;
    static BOOL KdPresent = FALSE;

    if ( !Expression )
    {
        //
        // Kernel debugger is either present or not,
        // this can not change without a reboot
        //

        if ( !KdPresenceChecked )
        {
            SYSTEM_KERNEL_DEBUGGER_INFORMATION KdInfo ;
            NTSTATUS Status ;

            Status = NtQuerySystemInformation(
                        SystemKernelDebuggerInformation,
                        &KdInfo,
                        sizeof( KdInfo ),
                        NULL );

            if ( NT_SUCCESS( Status ) &&
                 KdInfo.KernelDebuggerEnabled )
            {
                KdPresent = TRUE;
            }

            //
            // Set this variable to TRUE last in order to make this routine threadsafe
            //

            KdPresenceChecked = TRUE;
        }

        if ( KdPresent || IsDebuggerPresent())
        {
            OutputDebugStringA( String );
            OutputDebugStringA( "\n" );
            DebugBreak();
        }
    }
}

#endif // WIN32_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\kerblist.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerblist.h
//
// Contents:    structure and protypes needed for generic Kerberos lists
//
//
// History:     16-Apr-1996     MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __KERBLIST_H__
#define __KERBLIST_H__


//
// Generic list entry structure allowing common code for inserting
// logon sessions, credentials, and contexts.
//

#if DBG
#define KerbInitializeList( a, b ) KerbSafeInitializeList( a, b )
#else
#define KerbInitializeList( a, b ) KerbSafeInitializeList( a )
#endif

NTSTATUS
KerbSafeInitializeList(
    IN PKERBEROS_LIST List
#if DBG
    ,
    IN DWORD Enum
#endif
    );

VOID
KerbFreeList(
    IN PKERBEROS_LIST List
    );

VOID
KerbInsertListEntry(
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN PKERBEROS_LIST List
    );

VOID
KerbInsertListEntryTail(
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN PKERBEROS_LIST List
    );

VOID
KerbReferenceListEntry(
    IN PKERBEROS_LIST List,
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN BOOLEAN RemoveFromList
    );

BOOLEAN
KerbDereferenceListEntry(
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN PKERBEROS_LIST List
    );


VOID
KerbInitializeListEntry(
    IN OUT PKERBEROS_LIST_ENTRY ListEntry
    );

VOID
KerbValidateListEx(
    IN PKERBEROS_LIST List
    );

#if DBG
#define KerbValidateList(_List_) KerbValidateListEx(_List_)
#else
#define KerbValidateList(_List_)
#endif // DBG


#define KerbLockList(_List_) SafeEnterCriticalSection(&(_List_)->Lock)
#define KerbUnlockList(_List_) SafeLeaveCriticalSection(&(_List_)->Lock)

#endif // __KERBLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\kerbdefs.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbdefs.h
//
// Contents:    defines for all internal Kerberos lists
//
//
// History:     03-May-1999     ChandanS          Created
//
//------------------------------------------------------------------------

#ifndef __KERBDEFS_H__
#define __KERBDEFS_H__

#ifdef __cplusplus
extern "C" {
#endif
#include <safelock.h>
#ifdef __cplusplus
}
#endif

//
// All Kerberos list structures are defined here
//

typedef struct _KERBEROS_LIST {
    LIST_ENTRY List;
    SAFE_CRITICAL_SECTION Lock;
} KERBEROS_LIST, *PKERBEROS_LIST;

typedef struct _KERBEROS_LIST_ENTRY {
    LIST_ENTRY Next;
    ULONG ReferenceCount;
} KERBEROS_LIST_ENTRY, *PKERBEROS_LIST_ENTRY;


//
// NOTE:  If you add members to this struct, be sure to
// modify KerbDuplicateTicketCacheEntry!!!!
//

typedef struct _KERB_TICKET_CACHE_ENTRY {
    KERBEROS_LIST_ENTRY ListEntry;
    volatile LONG Linked;
    PKERB_INTERNAL_NAME ServiceName;
    PKERB_INTERNAL_NAME TargetName;
    UNICODE_STRING DomainName;
    UNICODE_STRING TargetDomainName;
    UNICODE_STRING AltTargetDomainName;
    UNICODE_STRING ClientDomainName;
    PKERB_INTERNAL_NAME ClientName;
    PKERB_INTERNAL_NAME AltClientName;
    ULONG TicketFlags;
    ULONG CacheFlags;
    KERB_ENCRYPTION_KEY SessionKey;
    KERB_ENCRYPTION_KEY CredentialKey; // used for pkiint only.
    TimeStamp StartTime;
    TimeStamp EndTime;
    TimeStamp RenewUntil;
    KERB_TICKET Ticket;
    TimeStamp TimeSkew;
    LUID EvidenceLogonId;
    void * ScavengerHandle;
#if DBG
    LIST_ENTRY GlobalListEntry;
#endif
} KERB_TICKET_CACHE_ENTRY, *PKERB_TICKET_CACHE_ENTRY;

typedef struct _KERB_TICKET_CACHE {
    LIST_ENTRY CacheEntries;
    TimeStamp  LastCleanup;
} KERB_TICKET_CACHE, *PKERB_TICKET_CACHE;


//
// Smartcard flags
//
#define CSP_DATA_INITIALIZED                        0x01
#define CSP_DATA_REUSED                             0x02

//
// Context flags used to determine pin caching behavior.
//
#define CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS     0x10
#define CONTEXT_INITIALIZED_WITH_ACH                0x20

typedef struct _KERB_PUBLIC_KEY_CREDENTIALS {
    UNICODE_STRING Pin;
    UNICODE_STRING AlternateDomainName;
    PCCERT_CONTEXT CertContext;
    ULONG_PTR KerbHProv;
    ULONG InitializationInfo;
    ULONG CspDataLength;
    BYTE CspData[1];
} KERB_PUBLIC_KEY_CREDENTIALS, *PKERB_PUBLIC_KEY_CREDENTIALS;

typedef struct _KERB_PRIMARY_CREDENTIAL {
    UNICODE_STRING UserName;
    UNICODE_STRING DomainName;
    UNICODE_STRING ClearPassword;           // this is only present until a ticket has been obtained.

    UNICODE_STRING OldUserName;             // original user name in explicit
    UNICODE_STRING OldDomainName;           // original domain name in explicit cred
    NT_OWF_PASSWORD OldHashPassword;        // hash of encrypted ClearPassword

    PKERB_STORED_CREDENTIAL Passwords;
    PKERB_STORED_CREDENTIAL OldPasswords;
    KERB_TICKET_CACHE ServerTicketCache;
    KERB_TICKET_CACHE S4UTicketCache;
    KERB_TICKET_CACHE AuthenticationTicketCache;
    PKERB_PUBLIC_KEY_CREDENTIALS PublicKeyCreds;
} KERB_PRIMARY_CREDENTIAL, *PKERB_PRIMARY_CREDENTIAL;

typedef struct _KERB_EXTRA_CRED {
    KERBEROS_LIST_ENTRY ListEntry;
    volatile LONG Linked;
    UNICODE_STRING cName;
    UNICODE_STRING cRealm;
    PKERB_STORED_CREDENTIAL Passwords;
    PKERB_STORED_CREDENTIAL OldPasswords;
} KERB_EXTRA_CRED, *PKERB_EXTRA_CRED;

typedef struct _EXTRA_CRED_LIST {
    KERBEROS_LIST   CredList;
    ULONG           Count;
} EXTRA_CRED_LIST, *PEXTRA_CRED_LIST;

typedef struct _KERB_LOGON_SESSION {
    KERBEROS_LIST_ENTRY ListEntry;
    KERBEROS_LIST CredmanCredentials;
    LUID LogonId;                               // constant
    TimeStamp Lifetime;
    SAFE_CRITICAL_SECTION Lock;
    KERB_PRIMARY_CREDENTIAL PrimaryCredentials;
    EXTRA_CRED_LIST ExtraCredentials;
    ULONG LogonSessionFlags;
    void* TaskHandle;
} KERB_LOGON_SESSION, *PKERB_LOGON_SESSION;


#define KERB_CREDENTIAL_TAG_ACTIVE (ULONG)'AdrC'
#define KERB_CREDENTIAL_TAG_DELETE (ULONG)'DdrC'

typedef struct _KERB_CREDENTIAL {
    KERBEROS_LIST_ENTRY ListEntry;
    ULONG HandleCount;
    LUID LogonId;                               // constant
    TimeStamp Lifetime;
    UNICODE_STRING CredentialName;
    ULONG CredentialFlags;
    ULONG ClientProcess;                        // constant
    PKERB_PRIMARY_CREDENTIAL SuppliedCredentials;
    PKERB_AUTHORIZATION_DATA AuthData;
    ULONG CredentialTag;
} KERB_CREDENTIAL, *PKERB_CREDENTIAL;

typedef struct _KERB_CREDMAN_CRED {
    KERBEROS_LIST_ENTRY ListEntry;
    ULONG CredentialFlags;
    UNICODE_STRING CredmanUserName;  // added since TGT information can overwrite primary credentials...
    UNICODE_STRING CredmanDomainName;
    PKERB_PRIMARY_CREDENTIAL SuppliedCredentials;
} KERB_CREDMAN_CRED, *PKERB_CREDMAN_CRED;


typedef enum _KERB_CONTEXT_STATE {
    IdleState,
    TgtRequestSentState,
    TgtReplySentState,
    ApRequestSentState,
    ApReplySentState,
    AuthenticatedState,
    ErrorMessageSentState,
    InvalidState
} KERB_CONTEXT_STATE, *PKERB_CONTEXT_STATE;


#define KERB_CONTEXT_TAG_ACTIVE (ULONG)'AxtC'
#define KERB_CONTEXT_TAG_DELETE (ULONG)'DxtC'

typedef struct _KERB_CONTEXT {
    KERBEROS_LIST_ENTRY ListEntry;
    TimeStamp Lifetime;             // end time/expiration time
    TimeStamp RenewTime;            // time to renew until
    TimeStamp StartTime;
    UNICODE_STRING ClientName;
    UNICODE_STRING ClientRealm;
    UNICODE_STRING ClientDnsRealm;
    union {
        ULONG ClientProcess;
        LSA_SEC_HANDLE LsaContextHandle;
    };
    LUID LogonId;
    HANDLE TokenHandle;
    ULONG_PTR CredentialHandle;
    KERB_ENCRYPTION_KEY SessionKey;
    ULONG Nonce;
    ULONG ReceiveNonce;
    ULONG ContextFlags;
    ULONG ContextAttributes;
    ULONG NegotiationInfo;
    ULONG EncryptionType;
    PSID UserSid;
    KERB_CONTEXT_STATE ContextState;
    ULONG Retries;
    KERB_ENCRYPTION_KEY TicketKey;
    PKERB_TICKET_CACHE_ENTRY TicketCacheEntry;  // for clients, is ticket to server, for servers, is TGT used in user-to-user
    UNICODE_STRING ClientPrincipalName;
    UNICODE_STRING ServerPrincipalName;
    PKERB_CREDMAN_CRED CredManCredentials;

    //
    // marshalled target info for DFS/RDR.
    //

    PBYTE pbMarshalledTargetInfo;
    ULONG cbMarshalledTargetInfo;

    TimeStamp AuthenticatorTime;

    ULONG ContextTag;
} KERB_CONTEXT, *PKERB_CONTEXT;

typedef struct _KERB_PACKED_CONTEXT {
    ULONG   ContextType ;               // Indicates the type of the context
    ULONG   Pad;                        // Pad data
    TimeStamp Lifetime;                 // Matches basic context above
    TimeStamp RenewTime ;
    TimeStamp StartTime;
    UNICODE_STRING32 ClientName ;
    UNICODE_STRING32 ClientRealm ;
    ULONG LsaContextHandle ;
    LUID LogonId ;
    ULONG TokenHandle ;
    ULONG CredentialHandle ;
    ULONG SessionKeyType ;
    ULONG SessionKeyOffset ;
    ULONG SessionKeyLength ;
    ULONG Nonce ;
    ULONG ReceiveNonce ;
    ULONG ContextFlags ;
    ULONG ContextAttributes ;
    ULONG EncryptionType ;
    KERB_CONTEXT_STATE ContextState ;
    ULONG Retries ;
    ULONG MarshalledTargetInfo; // offset
    ULONG MarshalledTargetInfoLength;
} KERB_PACKED_CONTEXT, * PKERB_PACKED_CONTEXT;

typedef struct _KERB_SESSION_KEY_ENTRY {
    LIST_ENTRY ListEntry;
    KERB_ENCRYPTION_KEY SessionKey;
    FILETIME ExpireTime;                   // time when SessionKey expires
} KERB_SESSION_KEY_ENTRY, * PKERB_SESSION_KEY_ENTRY;

#define KERB_PACKED_CONTEXT_MAP     0
#define KERB_PACKED_CONTEXT_EXPORT  1

//
// The order of this enum is the order in which locks
// must be acquired.  Violating this order will result
// in asserts firing in debug builds.
//
// Do not change the order of this enum without first verifying
// thoroughly that the change is safe.
//

typedef enum {

    //
    // No-dependency locks
    //

    LS_LIST_LOCK_ENUM = 0,        // (LSLS)
    LOCAL_LOOPBACK_SKEY_LOCK = 0, // (LLBK)
    HOST_2_REALM_LIST_LOCK = 0,   // (H2RL)

    //
    // Locks with dependencies
    //

    CRED_MGR_LOCK_ENUM = 1,       // (CRED)
    LOGON_SESSION_LOCK_ENUM,      // (LOGO)
    CONTEXT_LIST_LOCK_ENUM,       // (CLIS) --- LOGO
    LS_EXTRACRED_LOCK_ENUM,       // (LSXC) --- LOGO
    LS_CREDMAN_LOCK_ENUM,         // (LSCM) --- LOGO
    TICKET_CACHE_LOCK_ENUM,       // (TICK) --- CRED LOGO CLIS LSXC LSCM
    GLOBAL_RESOURCE_LOCK_ENUM,    // (GLOB) --- LOGO
    MIT_REALM_LIST_LOCK_ENUM,     // (MITR) --- GLOB
    BINDING_CACHE_LOCK_ENUM,      // (BNDC) --- GLOB
    SPN_CACHE_LOCK_ENUM,          // (SPNC) --- GLOB
    CONTEXT_RESOURCE_LOCK_ENUM,   // (CRES) --- TICK LSXC
    S4U_CACHE_LOCK_ENUM,          // (S4UC) --- TICK
    DISABLED_SPNS_LOCK_ENUM,      // (DISA) --- TICK
    KERB_SKEW_STATE_LOCK_ENUM,    // (SKEW) --- TICK
    KDC_DATA_LOCK_ENUM,           // (KDLK) --- LOGO LSCM

    KERB_MAX_LOCK_ENUM,

} KERB_LOCK_ENUM;

#endif // __KERBDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\kerbfunc.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1994
//
// File:        kerbfunc.h
//
// Contents:    prototypes for Kerberos export functions
//
//
// History:     21-Jan-94   MikeSw      Created
//
//------------------------------------------------------------------------

#ifndef __KERBFUNC_H__
#define __KERBFUNC_H__

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus
SpInitializeFn                  SpInitialize;
SpGetInfoFn                     SpGetInfo;


LSA_AP_LOGON_USER_EX2           LsaApLogonUserEx2;

SpAcceptCredentialsFn           SpAcceptCredentials;
SpAcquireCredentialsHandleFn    SpAcquireCredentialsHandle;
SpFreeCredentialsHandleFn       SpFreeCredentialsHandle;
SpQueryCredentialsAttributesFn  SpQueryCredentialsAttributes;
SpSaveCredentialsFn             SpSaveCredentials;
SpGetCredentialsFn              SpGetCredentials;
SpDeleteCredentialsFn           SpDeleteCredentials;

SpInitLsaModeContextFn          SpInitLsaModeContext;
SpDeleteContextFn               SpDeleteContext;
SpAcceptLsaModeContextFn        SpAcceptLsaModeContext;

LSA_AP_LOGON_TERMINATED         LsaApLogonTerminated;
SpApplyControlTokenFn           SpApplyControlToken;
LSA_AP_CALL_PACKAGE             LsaApCallPackage;
LSA_AP_CALL_PACKAGE             LsaApCallPackageUntrusted;
LSA_AP_CALL_PACKAGE_PASSTHROUGH LsaApCallPackagePassthrough;
SpShutdownFn                    SpShutdown;
SpGetUserInfoFn                 SpGetUserInfo;
SpQueryContextAttributesFn      SpQueryLsaModeContextAttributes;

SpInstanceInitFn                SpInstanceInit;
SpInitUserModeContextFn         SpInitUserModeContext;
SpMakeSignatureFn               SpMakeSignature;
SpVerifySignatureFn             SpVerifySignature;
SpSealMessageFn                 SpSealMessage;
SpUnsealMessageFn               SpUnsealMessage;
SpGetContextTokenFn             SpGetContextToken;
SpQueryContextAttributesFn      SpQueryContextAttributes;
SpDeleteContextFn               SpDeleteUserModeContext;
SpCompleteAuthTokenFn           SpCompleteAuthToken;
SpFormatCredentialsFn           SpFormatCredentials;
SpMarshallSupplementalCredsFn   SpMarshallSupplementalCreds;
SpExportSecurityContextFn       SpExportSecurityContext;
SpImportSecurityContextFn       SpImportSecurityContext;
SpGetExtendedInformationFn      SpGetExtendedInformation;


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __KERBFUNC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\kerblist.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerblist.cxx
//
// Contents:    Common list code for the Kerberos package
//
//
// History:     16-April-1996   Created         MikeSw
//              26-Sep-1998   ChandanS
//                            Added more debugging support etc.
//              03-May-1999   ChandanS
//                            Changes from code review
//
//------------------------------------------------------------------------


#include <kerb.hxx>
#include <kerbp.h>

#if DBG
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeList
//
//  Synopsis:   Initializes a kerberos list by initializing the lock
//              and the list entry.
//
//  Effects:
//
//  Arguments:  List - List to initialize
//              Enum - lock's ordinal number for safe locking
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success or errors from
//              RtlInitializeResources
//
//  Notes:
//
//
//--------------------------------------------------------------------------

#if DBG
NTSTATUS
KerbSafeInitializeList(
    IN PKERBEROS_LIST List,
    IN DWORD Enum
    )
#else
NTSTATUS
KerbSafeInitializeList(
    IN PKERBEROS_LIST List
    )
#endif
{
    NTSTATUS Status = STATUS_SUCCESS;

    InitializeListHead(&List->List);

    Status = SafeInitializeCriticalSection(
                &List->Lock,
                Enum
                );

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeList
//
//  Synopsis:   Frees a kerberos list by deleting the associated
//              critical section.
//
//  Effects:    List - the list to free.
//
//  Arguments:
//
//  Requires:
//
//  Returns:    none
//
//  Notes:      The list must be empty before freeing it.
//
//
//--------------------------------------------------------------------------



VOID
KerbFreeList(
    IN PKERBEROS_LIST List
    )
{
    //
    // Make sure the list is empty first
    //

//    if (IsListEmpty(&List->List))
//    {
//        RtlDeleteCriticalSection(&List->Lock);
//    }
//    else
//    {
//        DsysAssert(FALSE);
//    }

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeListEntry
//
//  Synopsis:   Initializes a newly created list entry for later
//              insertion onto the list.
//
//  Effects:    The reference count is set to one and the links are set
//              to NULL.
//
//  Arguments:  ListEntry - the list entry to initialize
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbInitializeListEntry(
    IN OUT PKERBEROS_LIST_ENTRY ListEntry
    )
{
    ListEntry->ReferenceCount = 1;
    ListEntry->Next.Flink = ListEntry->Next.Blink = NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInsertListEntry
//
//  Synopsis:   Inserts an entry into a kerberos list
//
//  Effects:    increments the reference count on the entry - if the
//              list entry was formly referenced it remains referenced.
//
//  Arguments:  ListEntry - the entry to insert
//              List - the list in which to insert the ListEntry
//
//  Requires:
//
//  Returns:    nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbInsertListEntry(
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN PKERBEROS_LIST List
    )
{
    ListEntry->ReferenceCount++;

    SafeEnterCriticalSection(&List->Lock);

    KerbValidateList(List);

    InsertHeadList(
        &List->List,
        &ListEntry->Next
        );

    KerbValidateList(List);


    SafeLeaveCriticalSection(&List->Lock);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInsertListEntryTail
//
//  Synopsis:   Inserts an entry into a kerberos list at the end
//
//  Effects:    increments the reference count on the entry - if the
//              list entry was formly referenced it remains referenced.
//
//  Arguments:  ListEntry - the entry to insert
//              List - the list in which to insert the ListEntry
//
//  Requires:
//
//  Returns:    nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbInsertListEntryTail(
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN PKERBEROS_LIST List
    )
{
    ListEntry->ReferenceCount++;

    SafeEnterCriticalSection(&List->Lock);

    KerbValidateList(List);

    InsertTailList(
        &List->List,
        &ListEntry->Next
        );

    KerbValidateList(List);

    SafeLeaveCriticalSection(&List->Lock);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceListEntry
//
//  Synopsis:   References a list entry. If the flag RemoveFromList
//              has been specified, the entry is unlinked from the
//              list.
//
//  Effects:    bumps the reference count on the entry (unless it is
//              being removed from the list)
//
//  Arguments:
//
//  Requires:   The list must be locked when calling this routine
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbReferenceListEntry(
    IN PKERBEROS_LIST List,
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN BOOLEAN RemoveFromList
    )
{
    KerbValidateList(List);


    //
    // If it has already been removed from the list
    // don't do it again.
    //

    if (RemoveFromList && ((ListEntry->Next.Flink != NULL) &&
                           (ListEntry->Next.Blink != NULL)))
    {
        RemoveEntryList(&ListEntry->Next);
        ListEntry->Next.Flink = NULL;
        ListEntry->Next.Blink = NULL;
    }
    else if ((ListEntry->Next.Flink !=NULL) && (ListEntry->Next.Blink != NULL))
    {
        RemoveEntryList( &ListEntry->Next );
        InsertHeadList(
            &List->List,
            &ListEntry->Next
            );

        ListEntry->ReferenceCount++;
    }
    else
    {
        //
        // This is valid since several callers may have gotten a valid list
        // entry and may want to delete it indepenently for whatever reason.
        //

        ListEntry->ReferenceCount++;
    }

    KerbValidateList(List);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceListEntry
//
//  Synopsis:   Dereferences a list entry and returns a flag indicating
//              whether the entry should be freed.
//
//  Effects:    decrements reference count on list entry
//
//  Arguments:  ListEntry - the list entry to dereference
//              List - the list containing the list entry
//
//  Requires:
//
//  Returns:    TRUE - the list entry should be freed
//              FALSE - the list entry is still referenced
//
//  Notes:
//
//
//--------------------------------------------------------------------------


BOOLEAN
KerbDereferenceListEntry(
    IN PKERBEROS_LIST_ENTRY ListEntry,
    IN PKERBEROS_LIST List
    )
{
    BOOLEAN DeleteEntry = FALSE;

    SafeEnterCriticalSection(&List->Lock);
    KerbValidateList(List);

    ListEntry->ReferenceCount -= 1;
    if (ListEntry->ReferenceCount == 0)
    {
        DeleteEntry = TRUE;
    }

    KerbValidateList(List);

    SafeLeaveCriticalSection(&List->Lock);
    return(DeleteEntry);
}


#if DBG
//+-------------------------------------------------------------------------
//
//  Function:   KerbValidateListEx
//
//  Synopsis:   Validates that a list is valid
//
//  Effects:    traverses a list to make sure it is has no loops
//
//  Arguments:  List - The list to validate
//
//  Requires:
//
//  Returns:    none
//
//  Notes:      This routine assumes there are less than 50000 entries
//              in the list.
//
//
//--------------------------------------------------------------------------

VOID
KerbValidateListEx(
    IN PKERBEROS_LIST List
    )
{
    ULONG Entries = 0;
    PLIST_ENTRY ListEntry;

    for (ListEntry = List->List.Flink ;
         ListEntry != &List->List ;
         ListEntry = ListEntry->Flink )
    {
        if (++Entries > 50000) {
            DebugLog((DEB_ERROR,"List 0x%x is looping - more than 50,000 entries found. %ws, line %d\n", List, THIS_FILE, __LINE__));
            DbgBreakPoint();
            break;
        }
    }

}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\kerbp.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbp.h
//
// Contents:    global include file for Kerberos security package
//
//
// History:     16-April-1996       Created     MikeSw
//
//------------------------------------------------------------------------

#ifndef __KERBP_H__
#define __KERBP_H__

//
// All global variables declared as EXTERN will be allocated in the file
// that defines KERBP_ALLOCATE
//

//
// Don't change the order of this enumeration, unless you also change rpcutil.cxx
//

typedef enum _KERBEROS_MACHINE_ROLE {
    KerbRoleRealmlessWksta,
    KerbRoleStandalone,
    KerbRoleWorkstation,
    KerbRoleDomainController
} KERBEROS_MACHINE_ROLE, *PKERBEROS_MACHINE_ROLE;


typedef enum _KERBEROS_STATE {
    KerberosLsaMode = 1,
    KerberosUserMode
} KERBEROS_STATE, *PKERBEROS_STATE;

#define ISC_REQ_DELEGATE_IF_SAFE ISC_REQ_RESERVED1
#define ISC_RET_DELEGATE_IF_SAFE ISC_RET_RESERVED1

#include "kerbdbg.h"
#include "kerbdefs.h"
#include "kerblist.h"
#include "spncache.h"
#include "kerbs4u.h"
#include "bndcache.h"
#include "kerbtick.h"
#include "kerbutil.h"
#include "kerblist.h"
#include "kerbscav.h"
#include "tktcache.h"
#include "logonses.h"
#include "credmgr.h"
#include "ctxtmgr.h"
#include "kerbfunc.h"
#include "logonapi.h"
#include "krbtoken.h"
#include "rpcutil.h"
#include "timesync.h"
#ifndef WIN32_CHICAGO
#include "pkauth.h"
#include "tktlogon.h"
#include "userlist.h"
#endif // WIN32_CHICAGO
#include "mitutil.h"
#include "krbevent.h"
#include "credman.h"

#ifdef WIN32_CHICAGO
#include <kerbstub.h>
#include <debug.h>
#endif // WIN32_CHICAGO

#ifdef _WIN64
#include "kerbwow.h"
#endif // _WIN64

//
// Macros for package information
//

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef KERBP_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif // KERBP_ALLOCATE

//

#define KERBEROS_CAPABILITIES ( SECPKG_FLAG_INTEGRITY | \
                                SECPKG_FLAG_PRIVACY | \
                                SECPKG_FLAG_TOKEN_ONLY | \
                                SECPKG_FLAG_DATAGRAM | \
                                SECPKG_FLAG_CONNECTION | \
                                SECPKG_FLAG_MULTI_REQUIRED | \
                                SECPKG_FLAG_EXTENDED_ERROR | \
                                SECPKG_FLAG_IMPERSONATION | \
                                SECPKG_FLAG_ACCEPT_WIN32_NAME | \
                                SECPKG_FLAG_NEGOTIABLE | \
                                SECPKG_FLAG_GSS_COMPATIBLE | \
                                SECPKG_FLAG_LOGON | \
                                SECPKG_FLAG_MUTUAL_AUTH | \
                                SECPKG_FLAG_DELEGATION | \
                                SECPKG_FLAG_READONLY_WITH_CHECKSUM )

#define KERBEROS_MAX_TOKEN 12000
#ifdef WIN32_CHICAGO
#define KERBEROS_PACKAGE_NAME "Kerberos"
#define KERBEROS_PACKAGE_COMMENT "Microsoft Kerberos V1.0"
#else
#define KERBEROS_PACKAGE_NAME L"Kerberos"
#define KERBEROS_PACKAGE_COMMENT L"Microsoft Kerberos V1.0"
#endif

#define NETLOGON_STARTED_EVENT L"\\NETLOGON_SERVICE_STARTED"

//
// Global state variables
//

EXTERN PLSA_SECPKG_FUNCTION_TABLE LsaFunctions;
EXTERN PSECPKG_DLL_FUNCTIONS UserFunctions;

EXTERN SECPKG_FUNCTION_TABLE KerberosFunctionTable;
EXTERN SECPKG_USER_FUNCTION_TABLE KerberosUserFunctionTable;

EXTERN ULONG_PTR KerberosPackageId;
EXTERN BOOLEAN KerbGlobalInitialized;
EXTERN UNICODE_STRING KerbGlobalMachineName;
EXTERN STRING KerbGlobalKerbMachineName;
EXTERN UNICODE_STRING KerbGlobalKdcServiceName;
EXTERN UNICODE_STRING KerbPackageName;
EXTERN BOOLEAN KerbKdcStarted;
EXTERN BOOLEAN KerbAfdStarted;
EXTERN BOOLEAN KerbNetlogonStarted;
EXTERN BOOLEAN KerbGlobalDomainIsPreNT5;
EXTERN HMODULE KerbKdcHandle;
EXTERN PKDC_VERIFY_PAC_ROUTINE KerbKdcVerifyPac;
EXTERN PKDC_GET_TICKET_ROUTINE KerbKdcGetTicket;
EXTERN PKDC_GET_TICKET_ROUTINE KerbKdcChangePassword;
EXTERN PKDC_FREE_MEMORY_ROUTINE KerbKdcFreeMemory;
EXTERN BOOLEAN KerbGlobalEnforceTime;
EXTERN BOOLEAN KerbGlobalMachineNameChanged;
#ifndef WIN32_CHICAGO
EXTERN BOOLEAN KerbGlobalSafeModeBootOptionPresent;
#endif // WIN32_CHICAGO


//
// Registry driven globals (see Kerberos\readme.txt for details on these)
//

EXTERN ULONG KerbGlobalKdcWaitTime;
EXTERN ULONG KerbGlobalKdcCallTimeout;
EXTERN ULONG KerbGlobalKdcCallBackoff;
EXTERN ULONG KerbGlobalKdcSendRetries;
EXTERN ULONG KerbGlobalMaxDatagramSize;
EXTERN ULONG KerbGlobalDefaultPreauthEtype;
EXTERN ULONG KerbGlobalMaxReferralCount;
EXTERN ULONG KerbGlobalMaxTokenSize;
EXTERN ULONG KerbGlobalKdcOptions;
EXTERN BOOLEAN KerbGlobalUseStrongEncryptionForDatagram;
EXTERN BOOLEAN KerbGlobalRetryPdc;
EXTERN BOOLEAN KerbGlobalRunningServer;
EXTERN TimeStamp KerbGlobalFarKdcTimeout;
EXTERN TimeStamp KerbGlobalNearKdcTimeout;
EXTERN TimeStamp KerbGlobalSkewTime;
EXTERN TimeStamp KerbGlobalSpnCacheTimeout;
EXTERN TimeStamp KerbGlobalS4UCacheTimeout;
EXTERN TimeStamp KerbGlobalS4UTicketLifetime;
EXTERN BOOLEAN KerbGlobalCacheS4UTicket;
EXTERN BOOLEAN KerbGlobalUseClientIpAddresses;
EXTERN DWORD KerbGlobalTgtRenewalTime;


#ifndef WIN32_CHICAGO
EXTERN ULONG KerbGlobalLoggingLevel;
#endif // WIN32_CHICAGO

//
// Globals used for handling domain change or that are affected by domain
// change
//

#ifndef WIN32_CHICAGO
#define KerbGlobalReadLock() SafeAcquireResourceShared(&KerberosGlobalResource, TRUE)
#define KerbGlobalWriteLock() SafeAcquireResourceExclusive(&KerberosGlobalResource, TRUE)
#define KerbGlobalReleaseLock() SafeReleaseResource(&KerberosGlobalResource)
EXTERN SAFE_RESOURCE KerberosGlobalResource;
EXTERN PSID KerbGlobalDomainSid;
#else // WIN32_CHICAGO
#define KerbGlobalReadLock()
#define KerbGlobalWriteLock()
#define KerbGlobalReleaseLock()

#endif // WIN32_CHICAGO

EXTERN UNICODE_STRING KerbGlobalDomainName;
EXTERN UNICODE_STRING KerbGlobalDnsDomainName;
EXTERN PKERB_INTERNAL_NAME KerbGlobalMitMachineServiceName;
EXTERN UNICODE_STRING KerbGlobalMachineServiceName;
EXTERN KERBEROS_MACHINE_ROLE KerbGlobalRole;
EXTERN UNICODE_STRING KerbGlobalInitialDcRecord;
EXTERN ULONG KerbGlobalInitialDcFlags;
EXTERN ULONG KerbGlobalInitialDcAddressType;
EXTERN PSOCKADDR_IN KerbGlobalIpAddresses;    // also protected by same lock
EXTERN BOOLEAN KerbGlobalNoTcpUdp;            // also protected by same lock
EXTERN ULONG KerbGlobalIpAddressCount;        // also protected by same lock
EXTERN BOOLEAN KerbGlobalIpAddressesInitialized;        // also protected by same lock
EXTERN BOOLEAN KerbGlobalAllowTgtSessionKey;
EXTERN LONG KerbGlobalMaxTickets;

EXTERN LPWSTR g_lpLastLock;
EXTERN ULONG  g_uLine;

//
// The capabilities of the security package
//

#ifdef WIN32_CHICAGO
EXTERN ULONG KerbGlobalCapabilities;
#endif // WIN32_CHICAGO

#if DBG
EXTERN ULONG KerbGlobalLogonSessionsLocked;
EXTERN ULONG KerbGlobalCredentialsLocked;
EXTERN ULONG KerbGlobalContextsLocked;
#endif
//
// Useful globals
//

EXTERN TimeStamp KerbGlobalWillNeverTime;
EXTERN TimeStamp KerbGlobalHasNeverTime;


EXTERN KERBEROS_STATE KerberosState;

//
// handle to LSA policy -- trusted.
//

EXTERN LSAPR_HANDLE KerbGlobalPolicyHandle;

//
// SAM and Domain handles for validation interface.
//

EXTERN SAMPR_HANDLE KerbGlobalSamHandle;
EXTERN SAMPR_HANDLE KerbGlobalDomainHandle;

//
// Null copies of Lanman and NT OWF password.
//

EXTERN LM_OWF_PASSWORD KerbGlobalNullLmOwfPassword;
EXTERN NT_OWF_PASSWORD KerbGlobalNullNtOwfPassword;


//
// Useful macros
//

//
// Macro to return the type field of a SecBuffer
//

#define BUFFERTYPE(_x_) ((_x_).BufferType & ~SECBUFFER_ATTRMASK)

//
// Time to wait for the KDC to start, in seconds
//


#endif // __KERBP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\kerbpass.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbpass.cxx
//
// Contents:    Code for changing the Kerberos password on a KDC
//
//
// History:     17-October-1998         MikeSw  Created
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>
#include <kerbpass.h>

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[] = TEXT(__FILE__);
#endif

#define FILENO FILENO_KERBPASS


#ifndef WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   KerbUpdateLogonSessionPasswords
//
//  Synopsis:   If the caller of this API is changing the password
//              of its own account, update the passwords.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbUpdateLogonSessionPasswords(
    IN PKERB_LOGON_SESSION TempLogonSession,
    IN PUNICODE_STRING NewPassword
    )
{
    NTSTATUS Status;
    SECPKG_CLIENT_INFO ClientInfo;
    PKERB_LOGON_SESSION LogonSession = NULL;
    BOOLEAN LockHeld = FALSE;

    //
    // Get the logon session for the caller so we can compare the name of
    // the account of the changed password to the name of the account of the
    // caller.
    //

    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    LogonSession = KerbReferenceLogonSession(
                        &ClientInfo.LogonId,
                        FALSE                   // don't remove
                        );

    if (LogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Now compare the names
    //

    DsysAssert( !LockHeld );
    KerbWriteLockLogonSessions(
        LogonSession
        );
    KerbReadLockLogonSessions(
        TempLogonSession
        );
    LockHeld = TRUE;

    if (RtlEqualUnicodeString(
            &LogonSession->PrimaryCredentials.UserName,
            &TempLogonSession->PrimaryCredentials.UserName,
            TRUE) &&                    // case insensitive
        RtlEqualUnicodeString(
            &LogonSession->PrimaryCredentials.DomainName,
            &TempLogonSession->PrimaryCredentials.DomainName,
            TRUE))                      // case insensitive
    {
        Status = KerbChangeCredentialsPassword(
                    &LogonSession->PrimaryCredentials,
                    NewPassword,
                    NULL,               // no etype info
                    UserAccount,
                    PRIMARY_CRED_CLEAR_PASSWORD
                    );

        if (NT_SUCCESS(Status))
        {
            SECPKG_PRIMARY_CRED PrimaryCredentials = {0};

            PrimaryCredentials.LogonId = ClientInfo.LogonId;
            PrimaryCredentials.Password = *NewPassword;
            PrimaryCredentials.Flags = PRIMARY_CRED_UPDATE | PRIMARY_CRED_CLEAR_PASSWORD;

            //
            // Update all the other packages
            //

            KerbUnlockLogonSessions(TempLogonSession);
            KerbUnlockLogonSessions(LogonSession);
            LockHeld = FALSE;

            (VOID) LsaFunctions->UpdateCredentials(
                        &PrimaryCredentials,
                        NULL        // no supplemental credentials
                        );
        }
    }
Cleanup:
    if (LockHeld)
    {
        KerbUnlockLogonSessions(TempLogonSession);
        KerbUnlockLogonSessions(LogonSession);
    }

    return(Status);
}

#endif // WIN32_CHICAGO



#ifndef WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   KerbGetKpasswdTicket
//
//  Synopsis:   Gets a ticket for the kpasswd/changepw service in the
//              realm of the logon session.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbGetKpasswdTicket(
    IN PKERB_LOGON_SESSION LogonSession,
    OUT PKERB_TICKET_CACHE_ENTRY * KpasswdTicket,
    OUT PUNICODE_STRING ClientRealm,
    OUT PKERB_INTERNAL_NAME * ClientName
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_INTERNAL_NAME KpasswdName = NULL;
    UNICODE_STRING CorrectRealm = {0};
    ULONG RetryCount = KERB_CLIENT_REFERRAL_MAX;
    BOOLEAN MitLogon;

    RtlInitUnicodeString(
        ClientRealm,
        NULL
        );

    //
    // Build the service name for the ticket
    //

    Status = KerbBuildKpasswdName(
                &KpasswdName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // We don't know exactly what realm to change the password on. If the
    // client presesnted a UPN, we may need to chase that down first.
    // This is similar code to KerbGetTicketGrantingTicket.
    //

    //
    // We start off assuming that the domain name is the domain name
    // supplied by the client.
    //

    KerbReadLockLogonSessions( LogonSession );

    Status = KerbGetClientNameAndRealm(
                &LogonSession->LogonId,
                &LogonSession->PrimaryCredentials,
                FALSE,
                NULL,
                &MitLogon,
                FALSE,                                  // default to wksta realm for UPN
                ClientName,
                ClientRealm
                );

    KerbUnlockLogonSessions( LogonSession );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

GetTicketRestart:

    //
    // Try to get the ticket now.
    //

    Status = KerbGetAuthenticationTicket(
                LogonSession,
                NULL,                   // credential
                NULL,
                TRUE,
                KpasswdName,
                ClientRealm,
                *ClientName,
                KERB_GET_AUTH_TICKET_NO_CANONICALIZE,  // no name canonicalization
                0,                      // no cache flags
                KpasswdTicket,
                NULL,                   // no credential key,
                &CorrectRealm
                );

    //
    // If it failed but gave us another realm to try, go there
    //

    if (!NT_SUCCESS(Status) && (CorrectRealm.Length != 0))
    {
        if (--RetryCount != 0)
        {
            KerbFreeString(ClientRealm);
            *ClientRealm = CorrectRealm;
            CorrectRealm.Buffer = NULL;

            goto GetTicketRestart;
        }
    }
Cleanup:
    KerbFreeKdcName( &KpasswdName );
    KerbFreeString(&CorrectRealm);

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildKerbPriv
//
//  Synopsis:   Builds a kerb-priv message with none of the optional
//              fields.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbBuildKerbPriv(
    IN PBYTE Data,
    IN ULONG DataSize,
    IN PKERB_ENCRYPTION_KEY Key,
    IN OPTIONAL PULONG Nonce,
    OUT PKERB_MESSAGE_BUFFER PrivMessage
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_PRIV_MESSAGE Priv = {0};
    KERB_ENCRYPTED_PRIV PrivBody = {0};
    KERB_MESSAGE_BUFFER PackedBody = {0};
    PKERB_HOST_ADDRESSES Addresses = NULL;
    PKERB_HOST_ADDRESSES OurAddress = NULL;

    Status = KerbBuildHostAddresses(
                TRUE,
                TRUE,
                &Addresses
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Look for the first IP address in the list
    //

    OurAddress = Addresses;
    while (OurAddress != NULL)
    {
        if (OurAddress->value.address_type == KERB_ADDRTYPE_INET)
        {
            break;
        }
        OurAddress = OurAddress->next;
    }

    if (OurAddress == NULL)
    {
        DebugLog((DEB_ERROR,"No IP addresses. %ws, line %d\n",THIS_FILE, __LINE__));
        Status = STATUS_NO_IP_ADDRESSES;
        goto Cleanup;
    }

    //
    // Get the client address
    //

    PrivBody.user_data.length = (int) DataSize;
    PrivBody.user_data.value = Data;

    PrivBody.sender_address.addr_type = OurAddress->value.address_type;
    PrivBody.sender_address.address.length = OurAddress->value.address.length;
    PrivBody.sender_address.address.value = OurAddress->value.address.value;

    if (ARGUMENT_PRESENT(Nonce))
    {
        PrivBody.KERB_ENCRYPTED_PRIV_sequence_number = (int) *Nonce;
        PrivBody.bit_mask |= KERB_ENCRYPTED_PRIV_sequence_number_present;
    }

    //
    // Now pack the priv_body
    //

    KerbErr = KerbPackData(
                &PrivBody,
                KERB_ENCRYPTED_PRIV_PDU,
                &PackedBody.BufferSize,
                &PackedBody.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Now encrypt the body
    //

    KerbErr = KerbAllocateEncryptionBufferWrapper(
                Key->keytype,
                PackedBody.BufferSize,
                &Priv.encrypted_part.cipher_text.length,
                &Priv.encrypted_part.cipher_text.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    KerbErr = KerbEncryptDataEx(
                &Priv.encrypted_part,
                PackedBody.BufferSize,
                PackedBody.Buffer,
                KERB_NO_KEY_VERSION,
                KERB_PRIV_SALT,
                Key
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Finally, pack the outer priv message.
    //

    Priv.version = KERBEROS_VERSION;
    Priv.message_type = KRB_PRIV;

    KerbErr = KerbPackData(
                &Priv,
                KERB_PRIV_MESSAGE_PDU,
                &PrivMessage->BufferSize,
                &PrivMessage->Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

Cleanup:
    KerbFreeHostAddresses(Addresses);
    if (Priv.encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(Priv.encrypted_part.cipher_text.value);
    }
    if (PackedBody.Buffer != NULL)
    {
        MIDL_user_free(PackedBody.Buffer);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildKpasswdRequest
//
//  Synopsis:   Builds a kpasswd request - build the AP REQ, KERB_PRIV,
//              and then combines them in the request.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbBuildKpasswdRequest(
    IN PKERB_TICKET_CACHE_ENTRY KpasswdTicket,
    IN PUNICODE_STRING ClientRealm,
    IN PUNICODE_STRING NewPassword,
    OUT PKERB_MESSAGE_BUFFER RequestMessage,
    OUT PKERB_ENCRYPTION_KEY SessionKey,
    OUT PULONG Nonce
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_MESSAGE_BUFFER ApRequest = {0};
    KERB_MESSAGE_BUFFER PrivMessage = {0};
    PKERB_KPASSWD_REQ KpasswdRequest;
    KERBERR KerbErr = KDC_ERR_NONE;
    STRING AnsiPassword = {0};

    RtlZeroMemory(
        SessionKey,
        sizeof(KERB_ENCRYPTION_KEY)
        );

    *Nonce = KerbAllocateNonce();

    //
    // Make a sub-session key for the AP request and for encrypting
    // the KERB_PRIV message.
    //

    KerbErr = KerbMakeKey(
                KpasswdTicket->SessionKey.keytype,
                SessionKey
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Build the AP request first
    //

    KerbReadLockTicketCache();

    KerbErr = KerbCreateApRequest(
                KpasswdTicket->ClientName,
                &KpasswdTicket->ClientDomainName,
                &KpasswdTicket->SessionKey,
                SessionKey,
                *Nonce,
                NULL,                       // authenticatortime on AP request - mutual auth???
                &KpasswdTicket->Ticket,
                0,                      // no ap options
                NULL,                   // no checksum
                &KpasswdTicket->TimeSkew,
                FALSE,                  // not a KDC request
                &ApRequest.BufferSize,
                &ApRequest.Buffer
                );

    KerbUnlockTicketCache();

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to create AP request for kpasswd: 0x%x, %ws line %d\n",
            KerbErr, THIS_FILE, __LINE__ ));

        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // convert the password to UTF-8
    //

    KerbErr = KerbUnicodeStringToKerbString(
                &AnsiPassword,
                NewPassword
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Build the kerb_priv message
    //

    Status = KerbBuildKerbPriv(
                (PUCHAR) AnsiPassword.Buffer,
                AnsiPassword.Length,
                SessionKey,
                Nonce,
                &PrivMessage
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to build Kerb-priv: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Now build the request itself.
    //

    RequestMessage->BufferSize = PrivMessage.BufferSize + ApRequest.BufferSize +
                        FIELD_OFFSET(KERB_KPASSWD_REQ,Data);
    RequestMessage->Buffer = (PBYTE) MIDL_user_allocate(RequestMessage->BufferSize);
    if (RequestMessage->Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    KpasswdRequest = (PKERB_KPASSWD_REQ) RequestMessage->Buffer;
    SET_SHORT(KpasswdRequest->MessageLength, (USHORT) RequestMessage->BufferSize);
    SET_SHORT(KpasswdRequest->Version, KERB_KPASSWD_VERSION);
    SET_SHORT(KpasswdRequest->ApReqLength, (USHORT) ApRequest.BufferSize);

    RtlCopyMemory(
        KpasswdRequest->Data,
        ApRequest.Buffer,
        ApRequest.BufferSize
        );
    RtlCopyMemory(
        (PBYTE) KpasswdRequest->Data + ApRequest.BufferSize,
        PrivMessage.Buffer,
        PrivMessage.BufferSize
        );

Cleanup:
    if (PrivMessage.Buffer != NULL)
    {
        MIDL_user_free(PrivMessage.Buffer);
    }
    if (ApRequest.Buffer != NULL)
    {
        MIDL_user_free(ApRequest.Buffer);
    }
    RtlEraseUnicodeString((PUNICODE_STRING) &AnsiPassword);
    KerbFreeString((PUNICODE_STRING) &AnsiPassword);

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildSetPasswordRequest
//
//  Synopsis:   Builds a kpasswd request to set a password - build the
//              AP REQ, KERB_PRIV,
//              and then combines them in the request.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbBuildSetPasswordRequest(
    IN PKERB_TICKET_CACHE_ENTRY KpasswdTicket,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm,
    IN PUNICODE_STRING NewPassword,
    OUT PKERB_MESSAGE_BUFFER RequestMessage,
    OUT PKERB_ENCRYPTION_KEY SessionKey,
    OUT PULONG Nonce
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_MESSAGE_BUFFER ApRequest = {0};
    KERB_MESSAGE_BUFFER PrivMessage = {0};
    KERB_MESSAGE_BUFFER EncodedData = {0};
    PKERB_KPASSWD_REQ KpasswdRequest;
    KERBERR KerbErr = KDC_ERR_NONE;
    STRING AnsiPassword = {0};
    KERB_CHANGE_PASSWORD_DATA ChangeData = {0};

    RtlZeroMemory(
        SessionKey,
        sizeof(KERB_ENCRYPTION_KEY)
        );

    *Nonce = KerbAllocateNonce();


    //
    // Build the encoded data
    //
    //
    // convert the password to UTF-8
    //

    KerbErr = KerbUnicodeStringToKerbString(
                &AnsiPassword,
                NewPassword
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }


    ChangeData.new_password.value = (PUCHAR) AnsiPassword.Buffer;
    ChangeData.new_password.length = AnsiPassword.Length;

    //
    // Convert the names
    //

    KerbErr = KerbConvertUnicodeStringToRealm(
                &ChangeData.target_realm,
                ClientRealm
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    KerbErr = KerbConvertKdcNameToPrincipalName(
                &ChangeData.target_name,
                ClientName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }


    ChangeData.bit_mask = target_name_present | target_realm_present;

    //
    // Asn.1 encode the data for sending
    //

    KerbErr = KerbPackData(
                &ChangeData,
                KERB_CHANGE_PASSWORD_DATA_PDU,
                &EncodedData.BufferSize,
                &EncodedData.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to pack kerb change password data: 0x%xx, file %ws, line %d\n",
            KerbErr,
            THIS_FILE,
            __LINE__
            ));

        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Make a sub-session key for the AP request and for encrypting
    // the KERB_PRIV message.
    //

    KerbErr = KerbMakeKey(
                KpasswdTicket->SessionKey.keytype,
                SessionKey
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }


    //
    // Build the AP request first
    //

    KerbReadLockTicketCache();

    KerbErr = KerbCreateApRequest(
                KpasswdTicket->ClientName,
                &KpasswdTicket->ClientDomainName,
                &KpasswdTicket->SessionKey,
                SessionKey,
                *Nonce,
                NULL,                      // authenticatortime on AP request - mutual auth???
                &KpasswdTicket->Ticket,
                0,                      // no ap options
                NULL,                   // no checksum
                &KpasswdTicket->TimeSkew,
                FALSE,                  // not a KDC request
                &ApRequest.BufferSize,
                &ApRequest.Buffer
                );

    KerbUnlockTicketCache();

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to create AP request for kpasswd: 0x%x, %ws line %d\n",
            KerbErr, THIS_FILE, __LINE__ ));

        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }


    //
    // Build the kerb_priv message
    //

    Status = KerbBuildKerbPriv(
                EncodedData.Buffer,
                EncodedData.BufferSize,
                SessionKey,
                Nonce,
                &PrivMessage
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to build Kerb-priv: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Now build the request itself.
    //

    RequestMessage->BufferSize = PrivMessage.BufferSize + ApRequest.BufferSize +
                        FIELD_OFFSET(KERB_KPASSWD_REQ,Data);
    RequestMessage->Buffer = (PBYTE) MIDL_user_allocate(RequestMessage->BufferSize);
    if (RequestMessage->Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    KpasswdRequest = (PKERB_KPASSWD_REQ) RequestMessage->Buffer;
    SET_SHORT(KpasswdRequest->MessageLength, (USHORT) RequestMessage->BufferSize);

    //
    // Use the special version for setting passwords
    //

    SET_SHORT(KpasswdRequest->Version, KERB_KPASSWD_SET_VERSION);
    SET_SHORT(KpasswdRequest->ApReqLength, (USHORT) ApRequest.BufferSize);

    RtlCopyMemory(
        KpasswdRequest->Data,
        ApRequest.Buffer,
        ApRequest.BufferSize
        );
    RtlCopyMemory(
        (PBYTE) KpasswdRequest->Data + ApRequest.BufferSize,
        PrivMessage.Buffer,
        PrivMessage.BufferSize
        );

Cleanup:
    if (PrivMessage.Buffer != NULL)
    {
        MIDL_user_free(PrivMessage.Buffer);
    }
    if (ApRequest.Buffer != NULL)
    {
        MIDL_user_free(ApRequest.Buffer);
    }
    if (EncodedData.Buffer != NULL)
    {
        MIDL_user_free(EncodedData.Buffer);
    }
    RtlEraseUnicodeString((PUNICODE_STRING) &AnsiPassword);
    KerbFreeString((PUNICODE_STRING) &AnsiPassword);

    KerbFreeRealm(&ChangeData.target_realm);
    KerbFreePrincipalName(
        &ChangeData.target_name
        );

    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifyPrivMessage
//
//  Synopsis:   Verifies that a priv message is correct and returns the
//              user data from the message.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbVerifyPrivMessage(
    IN PKERB_PRIV_MESSAGE PrivMessage,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    OUT PKERB_MESSAGE_BUFFER PrivData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_ENCRYPTED_PRIV PrivBody = NULL;

    //
    // Now decrypt the KERB_PRIV message
    //

    if (PrivMessage->version != KERBEROS_VERSION)
    {
        DebugLog((DEB_ERROR,"Bad version in kpasswd priv message: %d, %ws, line %d\n",
            PrivMessage->version, THIS_FILE, __LINE__ ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (PrivMessage->message_type != KRB_PRIV)
    {
        DebugLog((DEB_ERROR,"Bad message type in kpasswd priv message: %d, %ws, line %d\n",
            PrivMessage->message_type, THIS_FILE, __LINE__ ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    KerbErr = KerbDecryptDataEx(
                &PrivMessage->encrypted_part,
                SessionKey,
                KERB_PRIV_SALT,
                (PULONG) &PrivMessage->encrypted_part.cipher_text.length,
                PrivMessage->encrypted_part.cipher_text.value
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to decrypt priv message from kpasswd: 0x%x, %ws, line %d\n",
            KerbErr, THIS_FILE, __LINE__));
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Now decode the kerb priv body
    //

    KerbErr = KerbUnpackData(
                PrivMessage->encrypted_part.cipher_text.value,
                (ULONG) PrivMessage->encrypted_part.cipher_text.length,
                KERB_ENCRYPTED_PRIV_PDU,
                (PVOID *) &PrivBody
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to unpack priv body from kpasswd: 0x%x, %ws, line %d\n",
            KerbErr, THIS_FILE, __LINE__));
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // There is nothing in the body we want to verify (although other clients
    // verify the sender's address).
    //

    if (PrivBody->user_data.length != 0)
    {
        PrivData->BufferSize = PrivBody->user_data.length;
        PrivData->Buffer = (PBYTE) MIDL_user_allocate(PrivData->BufferSize);
        if (PrivData->Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            PrivData->Buffer,
            PrivBody->user_data.value,
            PrivBody->user_data.length
            );
    }
Cleanup:

    if (PrivBody != NULL)
    {
        KerbFreeData(
            KERB_ENCRYPTED_PRIV_PDU,
            PrivBody
            );
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbHandleKpasswdReply
//
//  Synopsis:   Unpacks the reply from the kpasswd service and converts
//              the error to an NT status code
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbHandleKpasswdReply(
    IN PKERB_TICKET_CACHE_ENTRY KpasswdTicket,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN PKERB_MESSAGE_BUFFER ReplyMessage
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_KPASSWD_REP KpasswdReply;
    PKERB_ERROR ErrorMessage = NULL;
    PKERB_AP_REPLY ApReply = NULL;
    PKERB_ENCRYPTED_AP_REPLY ApReplyBody = NULL;
    PKERB_PRIV_MESSAGE PrivMessage = NULL;
    KERB_MESSAGE_BUFFER PrivData = {0};
    USHORT ResultCode = 0;

    //
    // First check to see if this is a reply
    //

    if (ReplyMessage->BufferSize > sizeof(KERB_KPASSWD_REP))
    {
        USHORT Version;
        USHORT Length;
        KpasswdReply = (PKERB_KPASSWD_REP) ReplyMessage->Buffer;
        GET_SHORT(Version, KpasswdReply->Version );
        GET_SHORT(Length, KpasswdReply->MessageLength);

        //
        // Verify these values are correct
        //

        if ((Version != KERB_KPASSWD_VERSION) ||
            (Length != (USHORT) ReplyMessage->BufferSize))
        {
            //
            // It must be a kerb_error message, so unpack it.
            //

            KerbErr = KerbUnpackKerbError(
                        ReplyMessage->Buffer,
                        ReplyMessage->BufferSize,
                        &ErrorMessage
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                Status = KerbMapKerbError(KerbErr);
                goto Cleanup;
            }
        }
        else
        {
            USHORT ApRepLength;
            ULONG PrivLength;

            //
            // It is a well formed kpasswd reply, so unpack that
            //

            GET_SHORT(ApRepLength, KpasswdReply->ApRepLength);
            if (ApRepLength > ReplyMessage->BufferSize - FIELD_OFFSET(KERB_KPASSWD_REP,Data))
            {
                DebugLog((DEB_ERROR,"ApReq length in kpasswd rep is wrong: %d vs %d, %ws, line %d\n",
                    ApRepLength,
                    FIELD_OFFSET(KERB_KPASSWD_REP,Data), THIS_FILE, __LINE__
                    ));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;

            }

            //
            // Now unpack the AP reply
            //

            Status = KerbUnpackApReply(
                        KpasswdReply->Data,
                        ApRepLength,
                        &ApReply
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                Status = KerbMapKerbError(KerbErr);
                goto Cleanup;
            }

            //
            // Now try to unpack the remainder as  KERB_PRIV. If that fails,
            // try it as a KERB_ERROR
            //

            PrivLength = ReplyMessage->BufferSize - (ApRepLength + FIELD_OFFSET(KERB_KPASSWD_REP,Data));

            KerbErr = KerbUnpackData(
                        (PBYTE) KpasswdReply->Data + ApRepLength,
                        PrivLength,
                        KERB_PRIV_MESSAGE_PDU,
                        (PVOID *) &PrivMessage
                        );

            //
            // If that didn't work, try it as a kerb error message
            //

            if (!KERB_SUCCESS(KerbErr))
            {
                KerbErr = KerbUnpackKerbError(
                            (PBYTE) KpasswdReply->Data + ApRepLength,
                            PrivLength,
                            &ErrorMessage
                            );
                if (!KERB_SUCCESS(KerbErr))
                {
                    DebugLog((DEB_ERROR,"Failed to unpack data from kpasswd rep: 0x%x, %ws line %d\n",
                        KerbErr, THIS_FILE, __LINE__ ));

                    Status = KerbMapKerbError(KerbErr);
                    goto Cleanup;
                }
            }

        }
    }

    //
    // If we have an AP reply, verify it
    //

    if (ApReply != NULL)
    {
        KerbReadLockTicketCache();

        KerbErr = KerbDecryptDataEx(
                    &ApReply->encrypted_part,
                    &KpasswdTicket->SessionKey,
                    KERB_AP_REP_SALT,
                    (PULONG) &ApReply->encrypted_part.cipher_text.length,
                    ApReply->encrypted_part.cipher_text.value
                    );
        KerbUnlockTicketCache();

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR, "Failed to decrypt AP reply: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
            if (KerbErr == KRB_ERR_GENERIC)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                Status = STATUS_LOGON_FAILURE;
            }
            goto Cleanup;
        }

        //
        // Decode the contents now
        //

        if (!KERB_SUCCESS(KerbUnpackApReplyBody(
                            ApReply->encrypted_part.cipher_text.value,
                            ApReply->encrypted_part.cipher_text.length,
                            &ApReplyBody)))
        {
            DebugLog((DEB_ERROR, "Failed to unpack AP reply body. %ws, line %d\n", THIS_FILE, __LINE__));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }

    //
    // If we got a priv-message, verify it
    //

    if (PrivMessage != NULL)
    {
        Status = KerbVerifyPrivMessage(
                    PrivMessage,
                    SessionKey,
                    &PrivData
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to verify priv message while changing password: 0x%x. %ws, line %d\n",
                Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        if (PrivData.BufferSize >= sizeof(USHORT))
        {
            GET_SHORT(ResultCode, PrivData.Buffer);
        }
    }
    else
    {
        //
        // Process the error message
        //

        if (ErrorMessage == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        // TBD:  Extended errors, client side
        KerbReportKerbError(
            NULL,
            NULL,
            NULL,
            NULL,
            KLIN(FILENO, __LINE__),
            ErrorMessage,
            ErrorMessage->error_code,
            NULL,
            FALSE
            );

        Status = KerbMapKerbError(ErrorMessage->error_code);

        if ((ErrorMessage->bit_mask & error_data_present) != 0)
        {
            if (ErrorMessage->error_data.length >= sizeof(USHORT))
            {
                GET_SHORT(ResultCode, ErrorMessage->error_data.value);
            }
        }

    }

    //
    // Convert the result code & status into a real status
    //

    if (NT_SUCCESS(Status) || (Status == STATUS_INSUFFICIENT_RESOURCES))
    {
        switch(ResultCode) {
        case KERB_KPASSWD_SUCCESS:
            Status = STATUS_SUCCESS;
            break;
        case KERB_KPASSWD_MALFORMED:
            Status = STATUS_INVALID_PARAMETER;
            break;
        case KERB_KPASSWD_ERROR:
            Status = STATUS_UNSUCCESSFUL;
            break;
        case KERB_KPASSWD_AUTHENTICATION:
            Status = STATUS_MUTUAL_AUTHENTICATION_FAILED;
            break;
        case KERB_KPASSWD_POLICY:
            Status = STATUS_PASSWORD_RESTRICTION;
            break;
        case KERB_KPASSWD_AUTHORIZATION:
            Status = STATUS_ACCESS_DENIED;
            break;
        default:
            Status = STATUS_UNSUCCESSFUL;

        }
    }

Cleanup:

    if (ErrorMessage != NULL)
    {
        KerbFreeKerbError(ErrorMessage);
    }
    if (ApReplyBody != NULL)
    {
        KerbFreeApReplyBody(ApReplyBody);
    }
    if (ApReply != NULL)
    {
        KerbFreeApReply(ApReply);
    }

    if (PrivData.Buffer != NULL)
    {
        MIDL_user_free(PrivData.Buffer);
    }

    if (PrivMessage != NULL)
    {
        KerbFreeData(
            KERB_PRIV_MESSAGE_PDU,
            PrivMessage
            );
    }

    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbChangePassword
//
//  Synopsis:   Uses the kerberos change password protocol to change
//              a password. It is called through the LsaCallAuthenticationPackage
//              interface
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbChangePassword(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )
{
    PKERB_CHANGEPASSWORD_REQUEST ChangePasswordRequest = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PSECURITY_SEED_AND_LENGTH SeedAndLength;
    UCHAR Seed;
    LUID DummyLogonId = {0};
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_TICKET_CACHE_ENTRY KpasswdTicket = NULL;
    PKERB_INTERNAL_NAME ClientName = NULL;
    UNICODE_STRING  ValidatedAccountName;
    UNICODE_STRING  ValidatedDomainName;
    LPWSTR          ValidatedOldPasswordBuffer;
    LPWSTR          ValidatedNewPasswordBuffer;
    UNICODE_STRING RealmName = {0};
    KERB_MESSAGE_BUFFER KpasswdRequest = {0};
    KERB_MESSAGE_BUFFER KpasswdReply = {0};
    KERB_ENCRYPTION_KEY SessionKey = {0};
    ULONG Nonce = 0;
    BOOLEAN PasswordBufferValidated = FALSE;
    BOOLEAN CalledPDC = FALSE;
    ULONG StructureSize = sizeof(KERB_CHANGEPASSWORD_REQUEST);

    KERB_CHANGEPASS_INFO ChangePassTraceInfo;
    if( KerbEventTraceFlag ) // Event Trace: KerbChangePasswordStart {No Data}
    {
        ChangePassTraceInfo.EventTrace.Guid       = KerbChangePassGuid;
    ChangePassTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_START;
    ChangePassTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID;
    ChangePassTraceInfo.EventTrace.Size       = sizeof(EVENT_TRACE_HEADER);

    TraceEvent( KerbTraceLoggerHandle, (PEVENT_TRACE_HEADER)&ChangePassTraceInfo );
    }

    *ReturnBufferSize = 0;
    *ProtocolReturnBuffer = NULL;
    *ProtocolStatus = STATUS_PENDING;

#if _WIN64

    SECPKG_CALL_INFO              CallInfo;

    if(!LsaFunctions->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        StructureSize = sizeof(KERB_CHANGEPASSWORD_REQUEST_WOW64);
    }

#endif  // _WIN64


    //
    // Sanity checks.
    //

    if ( SubmitBufferSize < StructureSize )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    ChangePasswordRequest = (PKERB_CHANGEPASSWORD_REQUEST) ProtocolSubmitBuffer;

    ASSERT( ChangePasswordRequest->MessageType == KerbChangePasswordMessage );

#if _WIN64

    KERB_CHANGEPASSWORD_REQUEST LocalChangePasswordRequest;

    //
    // Thunk 32-bit pointers if this is a WOW caller
    //

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        PKERB_CHANGEPASSWORD_REQUEST_WOW64 ChangePasswordRequestWOW =
            (PKERB_CHANGEPASSWORD_REQUEST_WOW64) ChangePasswordRequest;

        LocalChangePasswordRequest.MessageType   = ChangePasswordRequest->MessageType;
        LocalChangePasswordRequest.Impersonating = ChangePasswordRequest->Impersonating;

        UNICODE_STRING_FROM_WOW_STRING(&LocalChangePasswordRequest.DomainName,
                                       &ChangePasswordRequestWOW->DomainName);

        UNICODE_STRING_FROM_WOW_STRING(&LocalChangePasswordRequest.AccountName,
                                       &ChangePasswordRequestWOW->AccountName);

        UNICODE_STRING_FROM_WOW_STRING(&LocalChangePasswordRequest.OldPassword,
                                       &ChangePasswordRequestWOW->OldPassword);

        UNICODE_STRING_FROM_WOW_STRING(&LocalChangePasswordRequest.NewPassword,
                                       &ChangePasswordRequestWOW->NewPassword);

        ChangePasswordRequest = &LocalChangePasswordRequest;
    }

#endif  // _WIN64

    RELOCATE_ONE( &ChangePasswordRequest->DomainName );
    RELOCATE_ONE( &ChangePasswordRequest->AccountName );
    RELOCATE_ONE_ENCODED( &ChangePasswordRequest->OldPassword );
    RELOCATE_ONE_ENCODED( &ChangePasswordRequest->NewPassword );

    //
    // save away copies of validated buffers to check later.
    //

    RtlCopyMemory( &ValidatedDomainName, &ChangePasswordRequest->DomainName, sizeof(ValidatedDomainName) );
    RtlCopyMemory( &ValidatedAccountName, &ChangePasswordRequest->AccountName, sizeof(ValidatedAccountName) );

    ValidatedOldPasswordBuffer = ChangePasswordRequest->OldPassword.Buffer;
    ValidatedNewPasswordBuffer = ChangePasswordRequest->NewPassword.Buffer;

    SeedAndLength = (PSECURITY_SEED_AND_LENGTH) &ChangePasswordRequest->OldPassword.Length;
    Seed = SeedAndLength->Seed;
    SeedAndLength->Seed = 0;

    //
    // Check to see if the OldPassword will run over the buffer for the New
    // Password
    //

    if ((ChangePasswordRequest->OldPassword.Buffer +
        (ChangePasswordRequest->OldPassword.Length/sizeof(WCHAR)) )>
        ChangePasswordRequest->NewPassword.Buffer)
    {
        Status = STATUS_ILL_FORMED_PASSWORD;
        goto Cleanup;
    }

    if (Seed != 0) {

        __try {
            RtlRunDecodeUnicodeString(
                Seed,
                &ChangePasswordRequest->OldPassword
                );

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_ILL_FORMED_PASSWORD;
            goto Cleanup;
        }
    }

    SeedAndLength = (PSECURITY_SEED_AND_LENGTH) &ChangePasswordRequest->NewPassword.Length;
    Seed = SeedAndLength->Seed;
    SeedAndLength->Seed = 0;

    if (Seed != 0) {

        __try {
            RtlRunDecodeUnicodeString(
                Seed,
                &ChangePasswordRequest->NewPassword
                );

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_ILL_FORMED_PASSWORD;
            goto Cleanup;
        }
    }

    //
    // sanity check that we didn't whack over buffers.
    //

    if( !RtlCompareMemory(
                        &ValidatedDomainName,
                        &ChangePasswordRequest->DomainName,
                        sizeof(ValidatedDomainName)
                        )
                        ||
        !RtlCompareMemory(
                        &ValidatedAccountName,
                        &ChangePasswordRequest->AccountName,
                        sizeof(ValidatedAccountName)
                        )
                        ||
        (ValidatedOldPasswordBuffer != ChangePasswordRequest->OldPassword.Buffer)
                        ||
        (ValidatedNewPasswordBuffer != ChangePasswordRequest->NewPassword.Buffer)
                        ) {

            Status= STATUS_INVALID_PARAMETER;
            goto Cleanup;
    }

    //
    // Validate IN params, to not exceed  KERB_MAX_UNICODE_STRING, as we add a NULL
    // to UNICODE buffers when we're duping strings.
    //
    if (ChangePasswordRequest->OldPassword.Length > KERB_MAX_UNICODE_STRING ||
        ChangePasswordRequest->NewPassword.Length > KERB_MAX_UNICODE_STRING ||
        ChangePasswordRequest->AccountName.Length > KERB_MAX_UNICODE_STRING ||
        ChangePasswordRequest->DomainName.Length > KERB_MAX_UNICODE_STRING)
    {
        Status = STATUS_NAME_TOO_LONG;
        goto Cleanup;
    }


    PasswordBufferValidated = TRUE;

    //
    // The protocol requires a ticket to the kadmin/changepw service. We
    // need to create a logon session to use the KerbGetAuthenticationTicket
    // routine.
    //

    Status = NtAllocateLocallyUniqueId( &DummyLogonId );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to allocate locally unique ID: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    Status = KerbCreateLogonSession(
                &DummyLogonId,
                &ChangePasswordRequest->AccountName,
                &ChangePasswordRequest->DomainName,
                &ChangePasswordRequest->OldPassword,
                NULL,                       // no old password
                PRIMARY_CRED_CLEAR_PASSWORD,
                0,
                FALSE,
                &LogonSession
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }




    //
    // Now get a ticket for the kpasswd service
    //

    Status = KerbGetKpasswdTicket(
                LogonSession,
                &KpasswdTicket,
                &RealmName,
                &ClientName
                );


    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = KerbBuildKpasswdRequest(
                KpasswdTicket,
                &RealmName,
                &ChangePasswordRequest->NewPassword,
                &KpasswdRequest,
                &SessionKey,
                &Nonce
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to build kpasswd request: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Call the KDC
    //

    Status = KerbMakeSocketCall(
                &RealmName,
                NULL,           // no account name
                FALSE,          // don't call PDC
                FALSE,          // don't use TCP
                TRUE,
                &KpasswdRequest,
                &KpasswdReply,
                NULL, // no optional binding cache info
                0,    // no additonal flags
                &CalledPDC
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to call kpasswd service: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

    //
    // Unpack the reply and return the error from it.
    //

    Status = KerbHandleKpasswdReply(
                KpasswdTicket,
                &SessionKey,
                &KpasswdReply
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN,"Change password reply failed: 0x%x, %ws, line %d\n",
                  Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

    //
    // Update the password in the logon session, if need be.
    //

    Status = KerbUpdateLogonSessionPasswords(
                LogonSession,
                &ChangePasswordRequest->NewPassword
                );

    if (!NT_SUCCESS(Status))
    {
        //
        // In some cases, we may not know about the caller's logon session
        // (*e.g. anonymous caller).  In that case, its normal not to know
        // the logon session - don't fail.
        //
        if (Status == STATUS_NO_SUCH_LOGON_SESSION)
        {
            Status = STATUS_SUCCESS;
        }
        else
        {
            D_DebugLog((DEB_ERROR, "KerbUPdateLogonSEssionPasswords failed %x\n", Status));
        }

        goto Cleanup;
    }
    else
    {
        //
        // Update credential manager password
        //
        KerbNotifyCredentialManager(
                LogonSession,
                ChangePasswordRequest,
                ClientName,
                &RealmName
                );
    }

Cleanup:
    if( KerbEventTraceFlag ) // Event Trace: KerbChangePasswordEnd {Status, AccountName, DomainName}
    {
    INSERT_ULONG_INTO_MOF( Status, ChangePassTraceInfo.MofData, 0 );
    ChangePassTraceInfo.EventTrace.Size = sizeof(EVENT_TRACE_HEADER) + 1*sizeof(MOF_FIELD);

    if( ChangePasswordRequest != NULL )
    {
        INSERT_UNICODE_STRING_INTO_MOF( ChangePasswordRequest->AccountName,  ChangePassTraceInfo.MofData, 1 );
        INSERT_UNICODE_STRING_INTO_MOF( ChangePasswordRequest->DomainName, ChangePassTraceInfo.MofData, 3 );
        ChangePassTraceInfo.EventTrace.Size += 4*sizeof(MOF_FIELD);
    }

    ChangePassTraceInfo.EventTrace.Guid       = KerbChangePassGuid;
    ChangePassTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_END;
    ChangePassTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;

    TraceEvent( KerbTraceLoggerHandle, (PEVENT_TRACE_HEADER) &ChangePassTraceInfo );
    }

    KerbFreeString(&RealmName);

    KerbFreeKdcName(&ClientName);

    if (KpasswdTicket != NULL)
    {
        KerbDereferenceTicketCacheEntry( KpasswdTicket );
    }

    if (LogonSession != NULL)
    {
        KerbReferenceLogonSessionByPointer(
            LogonSession,
            TRUE                        // Pull from list
            );
        KerbDereferenceLogonSession( LogonSession );
        KerbDereferenceLogonSession( LogonSession );
    }

    //
    // Don't let the password stay in the page file.
    //

    if ( PasswordBufferValidated ) {
        RtlEraseUnicodeString( &ChangePasswordRequest->OldPassword );
        RtlEraseUnicodeString( &ChangePasswordRequest->NewPassword );
    }

    if (KpasswdRequest.Buffer != NULL)
    {
        MIDL_user_free(KpasswdRequest.Buffer);
    }

    if (KpasswdReply.Buffer != NULL)
    {
        MIDL_user_free(KpasswdReply.Buffer);
    }

    if (SessionKey.keyvalue.value != NULL)
    {
        MIDL_user_free(SessionKey.keyvalue.value);
    }

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbSetPasswordEx
//
//  Synopsis:   Uses the kerberos set password protocol to set an account
//              password. It uses the identity of the caller to authenticate
//              the request. It is called through the
//              LsaCallAuthenticationPackage interface
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbSetPassword(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferSize,
    OUT PNTSTATUS ProtocolStatus
    )
{
    PKERB_SETPASSWORD_EX_REQUEST SetPasswordRequest = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PSECURITY_SEED_AND_LENGTH SeedAndLength;
    UCHAR Seed;
    LUID DummyLogonId = {0};
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_CREDENTIAL Credential = NULL;
    PKERB_TICKET_CACHE_ENTRY KpasswdTicket = NULL;
    KERB_PRIMARY_CREDENTIAL PrimaryCreds = {0};
    KERB_MESSAGE_BUFFER KpasswdRequest = {0};
    KERB_MESSAGE_BUFFER KpasswdReply = {0};
    KERB_ENCRYPTION_KEY SessionKey = {0};
    ULONG Nonce = 0;
    BOOLEAN PasswordBufferValidated = FALSE;
    BOOLEAN CalledPDC = FALSE;
    BOOLEAN SuppliedCreds = FALSE;
    SECPKG_CLIENT_INFO ClientInfo;
    PKERB_INTERNAL_NAME KpasswdName = NULL;
    PKERB_INTERNAL_NAME ClientName = NULL;
    PKERB_BINDING_CACHE_ENTRY OptionalBindingHandle = NULL;
    UNICODE_STRING ClientRealm = {0};
    PLUID LogonId;
    ULONG StructureSize   = sizeof(KERB_SETPASSWORD_REQUEST);
    ULONG StructureSizeEx = sizeof(KERB_SETPASSWORD_EX_REQUEST);

    KERB_SETPASS_INFO SetPassTraceInfo;
    if( KerbEventTraceFlag ) // Event Trace: KerbSetPasswordStart {No Data}
    {
        SetPassTraceInfo.EventTrace.Guid       = KerbSetPassGuid;
        SetPassTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_START;
        SetPassTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID;
        SetPassTraceInfo.EventTrace.Size       = sizeof(EVENT_TRACE_HEADER);
        TraceEvent( KerbTraceLoggerHandle, (PEVENT_TRACE_HEADER)&SetPassTraceInfo );
    }

    *ReturnBufferSize = 0;
    *ProtocolReturnBuffer = NULL;
    *ProtocolStatus = STATUS_PENDING;

    SetPasswordRequest = (PKERB_SETPASSWORD_EX_REQUEST) ProtocolSubmitBuffer;

    ASSERT( (SetPasswordRequest->MessageType == KerbSetPasswordExMessage
            || SetPasswordRequest->MessageType == KerbSetPasswordMessage) );

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    if (!LsaFunctions->GetCallInfo(&CallInfo))
    {
        goto Cleanup;
    }

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        //
        // These levels are not supported for WOW
        //

        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

#endif  // _WIN64

    //
    // Sanity checks.
    //

    if (SubmitBufferSize < StructureSize)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (SetPasswordRequest->MessageType == KerbSetPasswordExMessage)
    {
        if (SubmitBufferSize < StructureSizeEx)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        NULL_RELOCATE_ONE( &SetPasswordRequest->KdcAddress );
        NULL_RELOCATE_ONE( &SetPasswordRequest->ClientName );
        NULL_RELOCATE_ONE( &SetPasswordRequest->ClientRealm );
    }

    //
    // Note: although the struct members may be different, the type
    // remains the same between EX and normal version of SETPASSWORD_REQUEST
    // structure.
    //

    RELOCATE_ONE( &SetPasswordRequest->AccountRealm );
    RELOCATE_ONE( &SetPasswordRequest->AccountName );
    RELOCATE_ONE_ENCODED( &SetPasswordRequest->Password );

    SeedAndLength = (PSECURITY_SEED_AND_LENGTH) &SetPasswordRequest->Password.Length;
    Seed = SeedAndLength->Seed;
    SeedAndLength->Seed = 0;

    if (Seed != 0) {

        __try {
            RtlRunDecodeUnicodeString(
                Seed,
                &SetPasswordRequest->Password
                );

        } __except (EXCEPTION_EXECUTE_HANDLER) {
            Status = STATUS_ILL_FORMED_PASSWORD;
            goto Cleanup;
        }
    }

    if (SetPasswordRequest->AccountName.Length > KERB_MAX_UNICODE_STRING ||
        SetPasswordRequest->AccountRealm.Length > KERB_MAX_UNICODE_STRING ||
        SetPasswordRequest->Password.Length > KERB_MAX_UNICODE_STRING)
    {
        Status = STATUS_NAME_TOO_LONG;
        goto Cleanup;
    }

    if (SetPasswordRequest->MessageType == KerbSetPasswordExMessage)
    {
        if(SetPasswordRequest->ClientRealm.Length > KERB_MAX_UNICODE_STRING ||
           SetPasswordRequest->ClientName.Length > KERB_MAX_UNICODE_STRING ||
           SetPasswordRequest->KdcAddress.Length > KERB_MAX_UNICODE_STRING )
        {
            Status = STATUS_NAME_TOO_LONG;
            goto Cleanup;
        }
    }

    PasswordBufferValidated = TRUE;

    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( (SetPasswordRequest->Flags & KERB_SETPASS_USE_LOGONID) != 0)
    {
        //
        // Verify the caller has TCB privilege if they want access to someone
        // elses ticket cache.
        //

        if (!ClientInfo.HasTcbPrivilege)
        {
            Status = STATUS_PRIVILEGE_NOT_HELD;
            goto Cleanup;
        }

        LogonId = &SetPasswordRequest->LogonId;
    }
    else if ( (SetPasswordRequest->Flags & KERB_SETPASS_USE_CREDHANDLE) != 0)
    {
        //
        // Get the associated credential
        //

        Status = KerbReferenceCredential(
                        SetPasswordRequest->CredentialsHandle.dwUpper,
                        KERB_CRED_OUTBOUND | KERB_CRED_TGT_AVAIL,
                        FALSE,
                        &Credential);

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN,"Failed to locate credential: 0x%x\n",Status));
            goto Cleanup;
        }

        //
        // Get the logon id from the credentials so we can locate the
        // logon session.
        //
        SuppliedCreds = TRUE;
        DummyLogonId = Credential->LogonId;
        LogonId = &DummyLogonId;
    }
    else
    {
        LogonId = &ClientInfo.LogonId;
    }

    //
    // The protocol requires a ticket to the kadmin/changepw service. We
    // need to get the caller's logon session to use to get this
    // ticket.
    //


    LogonSession = KerbReferenceLogonSession(
                    LogonId,
                    FALSE                       // don't unlink
                    );

    if (LogonSession == NULL)
    {
        DebugLog((DEB_ERROR,"Can't locate caller's logon session\n"));
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Now get a ticket for the kpasswd service
    //

    Status = KerbBuildKpasswdName(
                &KpasswdName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = KerbGetServiceTicket(
                LogonSession,
                Credential,             // no credential
                NULL,
                KpasswdName,
                &SetPasswordRequest->AccountRealm,
                NULL,
                TRUE,                   // don't do name canonicalization
                0,                      // no ticket options
                0,                      // no encryption type
                NULL,                   // no error message
                NULL,                   // no authorizatoin data,
                NULL,                   // no tgt reply
                &KpasswdTicket,
                NULL                    // don't return logon guid
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Parse the names to get the real kerberos names
    //


    PrimaryCreds.UserName = SetPasswordRequest->AccountName;
    PrimaryCreds.DomainName = SetPasswordRequest->AccountRealm;

    Status = KerbGetClientNameAndRealm(
                LogonId,
                &PrimaryCreds,
                SuppliedCreds,
                NULL,
                NULL,
                FALSE,                                  // default to wksta realm for UPN
                &ClientName,
                &ClientRealm
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to get client name and realm: 0x%x file %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Build the set password request
    //

    Status = KerbBuildSetPasswordRequest(
                KpasswdTicket,
                ClientName,
                &ClientRealm,
                &SetPasswordRequest->Password,
                &KpasswdRequest,
                &SessionKey,
                &Nonce
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to build kpasswd request: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Here we may possibly need to set the target KDC
    // This KDC is not gaurenteed to succeeed, and retry logic
    // will occur on a failed SetPwd request..
    //
    if (SetPasswordRequest->MessageType == KerbSetPasswordExMessage
        && SetPasswordRequest->KdcAddress.Buffer != NULL)
    {
        OptionalBindingHandle = (PKERB_BINDING_CACHE_ENTRY)
                                  KerbAllocate(sizeof(KERB_BINDING_CACHE_ENTRY));

        if (NULL == OptionalBindingHandle)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        OptionalBindingHandle->AddressType = SetPasswordRequest->KdcAddressType;

        RtlCopyMemory(
           &(OptionalBindingHandle->KdcAddress),
           &(SetPasswordRequest->KdcAddress),
           sizeof(UNICODE_STRING)
           );

        RtlCopyMemory(
           &(OptionalBindingHandle->RealmName),
           &(SetPasswordRequest->AccountRealm),
           sizeof(UNICODE_STRING)
           );
    }

    //
    // Call the KDC
    //

    Status = KerbMakeSocketCall(
                &ClientRealm,
                NULL,           // no account name
                FALSE,          // don't call PDC
                FALSE,          // don't use TCP
                TRUE,
                &KpasswdRequest,
                &KpasswdReply,
                OptionalBindingHandle,
                0, // no additional flags
                &CalledPDC
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to call kpasswd service: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

    //
    // Unpack the reply and return the error from it.
    //

    Status = KerbHandleKpasswdReply(
                KpasswdTicket,
                &SessionKey,
                &KpasswdReply
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN,"Change password reply failed: 0x%x, %ws, line %d\n",
                Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

Cleanup:

    if( KerbEventTraceFlag ) // Event Trace: KerbSetPasswordEnd {Status, AccountName, AccountRealm, (ClientName), (ClientRealm), (KdcAddress)}
    {
        INSERT_ULONG_INTO_MOF( Status, SetPassTraceInfo.MofData, 0 );
        SetPassTraceInfo.EventTrace.Size = sizeof(EVENT_TRACE_HEADER) + 1*sizeof(MOF_FIELD);

        if( SetPasswordRequest != NULL )
        {
            INSERT_UNICODE_STRING_INTO_MOF(SetPasswordRequest->AccountName, SetPassTraceInfo.MofData, 1);
            INSERT_UNICODE_STRING_INTO_MOF(SetPasswordRequest->AccountRealm, SetPassTraceInfo.MofData, 3);

            SetPassTraceInfo.EventTrace.Size += 4 * sizeof(MOF_FIELD);

            if (SetPasswordRequest->MessageType == KerbSetPasswordExMessage)
            {
                INSERT_UNICODE_STRING_INTO_MOF(SetPasswordRequest->ClientName,  SetPassTraceInfo.MofData, 5);
                INSERT_UNICODE_STRING_INTO_MOF(SetPasswordRequest->ClientRealm, SetPassTraceInfo.MofData, 7);
                INSERT_UNICODE_STRING_INTO_MOF(SetPasswordRequest->KdcAddress,  SetPassTraceInfo.MofData, 9);

                SetPassTraceInfo.EventTrace.Size += 6 * sizeof(MOF_FIELD);
            }
        }

        SetPassTraceInfo.EventTrace.Guid       = KerbSetPassGuid;
        SetPassTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_END;
        SetPassTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;

        TraceEvent( KerbTraceLoggerHandle, (PEVENT_TRACE_HEADER) &SetPassTraceInfo );
    }

    KerbFreeKdcName( &KpasswdName );
    KerbFreeKdcName( &ClientName );
    KerbFreeString( &ClientRealm );
    KerbFreeKey( &SessionKey );

    if (KpasswdTicket != NULL)
    {
        KerbDereferenceTicketCacheEntry( KpasswdTicket );
    }

    if (Credential != NULL)
    {
        KerbDereferenceCredential(Credential);
    }

    if (NULL != OptionalBindingHandle)
    {
       KerbFree(OptionalBindingHandle);
    }

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession( LogonSession );
    }

    //
    // Don't let the password stay in the page file.
    //

    if ( PasswordBufferValidated )
    {
        RtlEraseUnicodeString( &SetPasswordRequest->Password );
    }

    if (KpasswdRequest.Buffer != NULL)
    {
        MIDL_user_free(KpasswdRequest.Buffer);
    }

    if (KpasswdReply.Buffer != NULL)
    {
        MIDL_user_free(KpasswdReply.Buffer);
    }

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);
}


#endif // WIN32_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\kerbs4u.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2000
//
// File:        kerbs4u.h
//
// Contents:    Structures and prototyps for Service4User protocol
//
//
// History:     13 - March - 2000   Created         Todds
//
//------------------------------------------------------------------------

#ifndef __KERBS4U_H__
#define __KERBS4U_H__

//
// Flags for the S4U cache
//
#define S4UCACHE_S4U_AVAILABLE      0x0100
#define S4UCACHE_S4U_UNAVAILABLE    0x1000
#define S4UCACHE_TIMEOUT            0x4000


typedef struct _KERB_S4UCACHE_DATA {
    KERBEROS_LIST_ENTRY     ListEntry;
    volatile LONG           Linked;
    LUID                    LogonId;
    ULONG                   CacheState;
    TimeStamp               CacheEndtime;
} KERB_S4UCACHE_DATA, *PKERB_S4UCACHE_DATA;

//
// Flags for the S4U ticket cache lookup
//
#define S4UTICKETCACHE_FOR_EVIDENCE 0x1
#define S4UTICKETCACHE_USEALTNAME   0x2
#define S4UTICKETCACHE_MATCH_ALL    0x4


NTSTATUS
KerbGetCallingLuid(
    IN OUT PLUID CallingLuid,
    IN OPTIONAL HANDLE hProcess
    );


NTSTATUS
KerbInitS4UCache();

BOOLEAN
KerbAllowedForS4UProxy( IN PLUID LogonId );

NTSTATUS
KerbScheduleS4UCleanup();


NTSTATUS
KerbGetS4UProxyEvidence(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_INTERNAL_NAME TargetName,
    IN ULONG ClientProcess,
    IN OUT PKERB_LOGON_SESSION * CallerLogonSession,
    IN OUT PKERB_TICKET_CACHE_ENTRY * TicketCacheEntry
    );

NTSTATUS
KerbS4UToSelfLogon(
        IN PVOID ProtocolSubmitBuffer,
        IN PVOID ClientBufferBase,
        IN ULONG SubmitBufferSize,
        OUT PKERB_LOGON_SESSION * NewLogonSession,
        OUT PLUID LogonId,
        OUT PKERB_TICKET_CACHE_ENTRY * WorkstationTicket,
        OUT PKERB_INTERNAL_NAME * S4UClientName,
        OUT PUNICODE_STRING S4UClientRealm,
        OUT PLUID AlternateLuid
        );

NTSTATUS
KerbGetServiceTicketByS4UProxy(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_LOGON_SESSION CallerLogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN PKERB_TICKET_CACHE_ENTRY EvidenceTicketCacheEntry,
    IN PKERB_INTERNAL_NAME TargetName,
    IN PUNICODE_STRING TargetDomainName,
    IN OPTIONAL PKERB_SPN_CACHE_ENTRY SpnCacheEntry,
    IN ULONG Flags,
    IN OPTIONAL ULONG TicketOptions,
    IN OPTIONAL ULONG EncryptionType,
    IN OPTIONAL PKERB_ERROR ErrorMessage,
    IN OPTIONAL PKERB_AUTHORIZATION_DATA AuthorizationData,
    IN OPTIONAL PKERB_TGT_REPLY TgtReply,
    OUT PKERB_TICKET_CACHE_ENTRY * NewCacheEntry,
    OUT LPGUID pLogonGuid OPTIONAL
    );



#endif // __KERBS4U_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\kerbtick.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:   kerbtick.h
//
//  Contents:   Structures for ticket request and creation
//
//  Classes:
//
//  Functions:
//
//  History:    22-April-1996   Created         MikeSw
//
//----------------------------------------------------------------------------

#ifndef __KERBTICK_H__
#define __KERBTICK_H__

//
// Macros used for building tickets
//

#define KERB_ENCRYPT_SIZE(_x_) (sizeof(KERB_ENCRYPTED_DATA) - 1 + (_x_))

//
// Structures used for AP (authentication protocol) exchanges with a server
//

//#define KERB_AP_INTEGRITY   0x80000000  // Integrity Request
//#define KERB_AP_PRIVACY     0x40000000  // Privacy
//#define KERB_AP_THREE_LEG   0x20000000  // Mutual Auth 3-leg
//#define KERB_AP_RETURN_EE   0x10000000  // Return extended error info
//#define KERB_AP_USE_SKEY    0x00000002  // Use session key
//#define KERB_AP_MUTUAL_REQ  0x00000004

//
// Structure used to store GSS checksum
//

typedef struct _KERB_GSS_CHECKSUM {
    ULONG BindLength;
    ULONG BindHash[4];
    ULONG GssFlags;
    USHORT Delegation;
    USHORT DelegationLength;
    UCHAR DelegationInfo[ANYSIZE_ARRAY];
} KERB_GSS_CHECKSUM, *PKERB_GSS_CHECKSUM;

#define GSS_C_DELEG_FLAG        0x01
#define GSS_C_MUTUAL_FLAG       0x02
#define GSS_C_REPLAY_FLAG       0x04
#define GSS_C_SEQUENCE_FLAG     0x08
#define GSS_C_CONF_FLAG         0x10
#define GSS_C_INTEG_FLAG        0x20
#define GSS_C_ANON_FLAG         0x40
#define GSS_C_DCE_STYLE         0x1000
#define GSS_C_IDENTIFY_FLAG     0x2000
#define GSS_C_EXTENDED_ERROR_FLAG 0x4000

#define GSS_CHECKSUM_TYPE       0x8003
#define GSS_CHECKSUM_SIZE       24

// This was added due to sizeof() byte alignment issues on
// the KREB_GSS_CHECKSUM structure.
#define GSS_DELEGATE_CHECKSUM_SIZE 28

//
// KerbGetTgsTicket retry flags
//

#define KERB_MIT_NO_CANONICALIZE_RETRY 0x00000001  // for MIT no canonicalize retry case and usage of host to realm mappings
#define KERB_RETRY_WITH_NEW_TGT        0x00000002
#define KERB_RETRY_DISABLE_S4U         0x00000004  // Turn off S4U
#define KERB_RETRY_NO_S4UMATCH         0x00000008  // cache this SPN as not avail. for S4U

//
// Default flags for use in ticket requests
//

#define KERB_DEFAULT_TICKET_FLAGS (KERB_KDC_OPTIONS_forwardable | \
                                        KERB_KDC_OPTIONS_renewable | \
                                        KERB_KDC_OPTIONS_renewable_ok | \
                                        KERB_KDC_OPTIONS_name_canonicalize )


//
// These flags don't have to be in the TGT in order to be honored.  Reg.
// configurable.
//
#define KERB_ADDITIONAL_KDC_OPTIONS     (KERB_KDC_OPTIONS_name_canonicalize)


NTSTATUS
KerbGetReferralNames(
    IN PKERB_ENCRYPTED_KDC_REPLY KdcReply,
    IN PKERB_INTERNAL_NAME OriginalTargetName,
    OUT PUNICODE_STRING ReferralRealm
    );

NTSTATUS
KerbMITGetMachineDomain(
    IN PKERB_INTERNAL_NAME TargetName,
    IN OUT PUNICODE_STRING TargetDomainName,
    IN OUT PKERB_TICKET_CACHE_ENTRY *TicketGrantingTicket
    );

NTSTATUS
KerbGetTgtForService(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN OPTIONAL PUNICODE_STRING SuppRealm,
    IN PUNICODE_STRING TargetDomain,
    IN ULONG TargetFlags,
    OUT PKERB_TICKET_CACHE_ENTRY * NewCacheEntry,
    OUT PBOOLEAN CrossRealm
    );

NTSTATUS
KerbGetTgsTicket(
    IN PUNICODE_STRING ClientRealm,
    IN PKERB_TICKET_CACHE_ENTRY TicketGrantingTicket,
    IN PKERB_INTERNAL_NAME TargetName,
    IN ULONG Flags,
    IN OPTIONAL ULONG TicketOptions,
    IN OPTIONAL ULONG EncryptionType,
    IN OPTIONAL PKERB_AUTHORIZATION_DATA AuthorizationData,
    IN OPTIONAL PKERB_PA_DATA_LIST PADataList,
    IN OPTIONAL PKERB_TGT_REPLY TgtReply,
    IN OPTIONAL PKERB_TICKET EvidenceTicket,
    IN OPTIONAL PTimeStamp OptionalEndTime,
    OUT PKERB_KDC_REPLY * KdcReply,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody,
    OUT PULONG pRetryFlags
    );

NTSTATUS
KerbGetServiceTicket(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN PKERB_INTERNAL_NAME TargetName,
    IN PUNICODE_STRING TargetDomainName,
    IN OPTIONAL PKERB_SPN_CACHE_ENTRY SpnCacheEntry,
    IN ULONG Flags,
    IN OPTIONAL ULONG TicketOptions,
    IN OPTIONAL ULONG EncryptionType,
    IN OPTIONAL PKERB_ERROR ErrorMessage,
    IN OPTIONAL PKERB_AUTHORIZATION_DATA AuthorizationData,
    IN OPTIONAL PKERB_TGT_REPLY TgtReply,
    OUT PKERB_TICKET_CACHE_ENTRY * NewCacheEntry,
    OUT LPGUID pLogonGuid OPTIONAL
    );

#define KERB_GET_TICKET_NO_CACHE                0x1
#define KERB_GET_TICKET_NO_CANONICALIZE         0x2
#define KERB_TARGET_DID_ALTNAME_LOOKUP          0x8

#define KERB_TARGET_USED_SPN_CACHE              0x1000
#define KERB_TARGET_UNKNOWN_SPN                 0x2000
#define KERB_MIT_REALM_USED                     0x4000
#define KERB_TARGET_REFERRAL                    0x8000
#define KERB_TARGET_SPN_NO_PROXY                0x10000

BOOL
KerbHaveKeyMaterials(
    IN OPTIONAL PKERB_LOGON_SESSION LogonSession,
    IN PKERB_PRIMARY_CREDENTIAL PrimaryCred
    );

NTSTATUS
KerbBuildApRequest(
    IN PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry,
    IN OPTIONAL PKERB_ERROR ErrorMessage,
    IN ULONG ContextAttributes,
    IN OUT PULONG ContextFlags,
    OUT PUCHAR * MarshalledApRequest,
    OUT PULONG ApRequestSize,
    OUT PULONG Nonce,
    OUT OPTIONAL PTimeStamp pAuthenticatorTime,
    OUT PKERB_ENCRYPTION_KEY SubSessionKey,
    IN PSEC_CHANNEL_BINDINGS pChannelBindings
    );

NTSTATUS
KerbBuildNullSessionApRequest(
    OUT PUCHAR * MarshalledApRequest,
    OUT PULONG ApRequestSize
    );

KERBERR
KerbCreateApRequest(
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN PKERB_ENCRYPTION_KEY SubSessionKey,
    IN ULONG Nonce,
    OUT OPTIONAL PTimeStamp pAuthenticatorTime,
    IN PKERB_TICKET ServiceTicket,
    IN ULONG ApOptions,
    IN OPTIONAL PKERB_CHECKSUM GssChecksum,
    IN OPTIONAL PTimeStamp ServerSkewTime,
    IN BOOLEAN KdcRequest,
    OUT PULONG RequestSize,
    OUT PUCHAR * Request
    );

NTSTATUS
KerbVerifyApRequest(
    IN OPTIONAL PKERB_CONTEXT Context,
    IN PUCHAR RequestMessage,
    IN ULONG RequestSize,
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN BOOLEAN UseSuppliedCreds,
    IN BOOLEAN CheckForReplay,
    OUT PKERB_AP_REQUEST  * ApRequest,
    OUT PKERB_ENCRYPTED_TICKET * NewTicket,
    OUT PKERB_AUTHENTICATOR * NewAuthenticator,
    OUT PKERB_ENCRYPTION_KEY SessionKey,
    OUT PKERB_ENCRYPTION_KEY TicketKey,
    OUT PKERB_ENCRYPTION_KEY ServerKey,
    OUT PULONG ContextFlags,
    OUT PULONG ContextAttributes,
    OUT PKERBERR KerbError,
    IN PSEC_CHANNEL_BINDINGS pChannelBindings
    );

NTSTATUS
KerbComputeGssBindHash(
    IN PSEC_CHANNEL_BINDINGS pChannelBindings,
    OUT PUCHAR HashBuffer
    );

//
// From credapi.cxx
//

NTSTATUS
KerbCaptureSuppliedCreds(
    IN PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PVOID AuthorizationData,
    IN OPTIONAL PUNICODE_STRING PrincipalName,
    OUT PKERB_PRIMARY_CREDENTIAL * SuppliedCreds,
    OUT PULONG Flags
    );

NTSTATUS
KerbBuildApReply(
    IN PKERB_AUTHENTICATOR InternalAuthenticator,
    IN PKERB_AP_REQUEST Request,
    IN ULONG ContextFlags,
    IN ULONG ContextAtributes,
    IN PKERB_ENCRYPTION_KEY TicketKey,
    IN OUT PKERB_ENCRYPTION_KEY SessionKey,
    OUT PULONG Nonce,
    OUT PUCHAR * NewReply,
    OUT PULONG NewReplySize
    );

NTSTATUS
KerbBuildThirdLegApReply(
    IN PKERB_CONTEXT Context,
    IN ULONG ReceiveNonce,
    OUT PUCHAR * NewReply,
    OUT PULONG NewReplySize
    );

BOOLEAN
KerbKerbTimeEqual(
    PKERB_TIME pt1,
    PKERB_TIME pt2
    );

NTSTATUS
KerbVerifyApReply(
    IN PKERB_CONTEXT Context,
    IN PUCHAR PackedReply,
    IN ULONG PackedReplySize,
    OUT PULONG ReceiveNonce
    );

NTSTATUS
KerbInitTicketHandling(
    VOID
    );

NTSTATUS
KerbInitGlobalVariables(
    VOID
    );

VOID
KerbCleanupTicketHandling(
    VOID
    );

NTSTATUS
KerbMakeSocketCall(
    IN PUNICODE_STRING RealmName,
    IN OPTIONAL PUNICODE_STRING AccountName,
    IN BOOLEAN CallPDC,
    IN BOOLEAN UseTcp,
    IN BOOLEAN CallKpasswd,
    IN PKERB_MESSAGE_BUFFER RequestMessage,
    IN PKERB_MESSAGE_BUFFER ReplyMessage,
    IN OPTIONAL PKERB_BINDING_CACHE_ENTRY OptionalBindingHandle,
    IN ULONG AdditionalFlags,
    OUT PBOOLEAN CalledPDC
    );

NTSTATUS
KerbHandleTgtRequest(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN BOOLEAN UseSuppliedCreds,
    IN PUCHAR RequestMessage,
    IN ULONG RequestSize,
    IN ULONG ContextRequirements,
    IN PSecBuffer OutputToken,
    IN PLUID LogonId,
    OUT PULONG ContextAttributes,
    OUT PKERB_CONTEXT * Context,
    OUT PTimeStamp ContextLifetime,
    OUT PKERBERR ReturnedError
    );

NTSTATUS
KerbBuildTgtRequest(
    IN PKERB_INTERNAL_NAME TargetName,
    IN PUNICODE_STRING TargetRealm,
    OUT PULONG ContextAttributes,
    OUT PUCHAR * MarshalladTgtRequest,
    OUT PULONG TgtRequestSize
    );

NTSTATUS
KerbUnpackTgtReply(
    IN PKERB_CONTEXT Context,
    IN PUCHAR ReplyMessage,
    IN ULONG ReplySize,
    OUT PKERB_INTERNAL_NAME * TargetName,
    OUT PUNICODE_STRING TargetRealm,
    OUT PKERB_TGT_REPLY * Reply
    );

NTSTATUS
KerbBuildTgtErrorReply(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credentials,
    IN BOOLEAN UseSuppliedCreds,
    IN OUT PKERB_CONTEXT Context,
    OUT PULONG ReplySize,
    OUT PBYTE * Reply
    );

NTSTATUS
KerbBuildKerbCred(
    IN OPTIONAL PKERB_TICKET_CACHE_ENTRY Ticket,
    IN PKERB_TICKET_CACHE_ENTRY DelegationTicket,
    OUT PUCHAR * MarshalledKerbCred,
    OUT PULONG KerbCredSize
    );

#endif // __KERBTICK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\kerbtrace.cxx ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    kerbtrace.cxx

Abstract:

    Set up event tracing for Kerberos

Author:

    15 June 2000  t-ryanj     (* largely stolen from kdctrace.cxx *)

Revision History:

--*/


#include <kerb.hxx>
#include <wmistr.h>
#define INITGUID
#include "kerbdbg.h"

#define RESOURCE_NAME       __TEXT("MOF_RESOURCE")  // kerberos.mof => kerberos.bmf => MOF_RESOURCE
#define IMAGE_PATH          __TEXT("kerberos.dll")

BOOLEAN          KerbEventTraceFlag = FALSE;
TRACEHANDLE      KerbTraceRegistrationHandle = (TRACEHANDLE) 0;
TRACEHANDLE      KerbTraceLoggerHandle = (TRACEHANDLE) 0;


ULONG
KerbTraceControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    );

TRACE_GUID_REGISTRATION KerbTraceGuids[] =
{
    { &KerbLogonGuid,      NULL },
    { &KerbInitSCGuid,     NULL },
    { &KerbAcceptSCGuid,   NULL },
    { &KerbSetPassGuid,    NULL },
    { &KerbChangePassGuid, NULL }
};

#define KerbGuidCount (sizeof(KerbTraceGuids) / sizeof(TRACE_GUID_REGISTRATION))

ULONG
KerbInitializeTrace(
    VOID
    )
{
    ULONG status;
    HMODULE hModule;
    TCHAR FileName[MAX_PATH+1];
    DWORD nLen = 0;

    hModule = GetModuleHandle(IMAGE_PATH);
    if (hModule != NULL) {
        nLen = GetModuleFileName(hModule, FileName, MAX_PATH);
    }
    if (nLen == 0) {
        lstrcpy(FileName, IMAGE_PATH);
    }

    status = RegisterTraceGuids(
                KerbTraceControlCallback,
                NULL,
                &KerbControlGuid,
                KerbGuidCount,
                KerbTraceGuids,
                (LPCWSTR) FileName,
                (LPCWSTR) RESOURCE_NAME,
                &KerbTraceRegistrationHandle);


    if (status != ERROR_SUCCESS) {
        DebugLog((DEB_ERROR,"Trace registration failed with %x\n",status));
    }
    return status;
}


ULONG
KerbTraceControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
{
    ULONG Status;
    ULONG RetSize;

    Status = ERROR_SUCCESS;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
            KerbTraceLoggerHandle =
                GetTraceLoggerHandle(Buffer);
            KerbEventTraceFlag = TRUE;
            RetSize = 0;
            break;
        }

        case WMI_DISABLE_EVENTS:
        {
            KerbEventTraceFlag = FALSE;
            RetSize = 0;
            KerbTraceLoggerHandle = (TRACEHANDLE) 0;
            break;
        }
        default:
        {
            RetSize = 0;
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

    }

    *InOutBufferSize = RetSize;
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\kerbpass.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbpass.cxx
//
// Contents:    Code for changing the Kerberos password on a KDC
//
//
// History:     17-October-1998         MikeSw  Created
//
//------------------------------------------------------------------------

#ifndef __KERBPASS_H__
#define __KERBPASS_H__

#include <kpasswd.h>

NTSTATUS NTAPI
KerbChangePassword(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbSetPassword(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

#endif // __KERBPASS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\kerbs4u.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 2001
//
// File:        kerbs4u.cxx
//
// Contents:    Code for doing S4UToSelf() logon.
//
//
// History:     14-March-2001   Created         Todds
//
//------------------------------------------------------------------------
#include <kerb.hxx>
#include <kerbp.h>
#include <kerbs4u.h>

extern "C"
{
#include <md5.h>
}

#ifdef DEBUG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

#define FILENO FILENO_S4U

//
// Used for ticket leak detection.
//
#if DBG
EXTERN LIST_ENTRY GlobalTicketList;
#endif

EXTERN LONG GlobalTicketListSize;


KERBEROS_LIST   KerbS4UCache;

#define KerbLockS4UCache( )    SafeEnterCriticalSection( &KerbS4UCache.Lock )
#define KerbUnlockS4UCache( )    SafeLeaveCriticalSection( &KerbS4UCache.Lock )


//
// S4U Cache management functions.
//

NTSTATUS
KerbInitS4UCache()
{
    NTSTATUS Status;

    Status = KerbInitializeList(&KerbS4UCache, S4U_CACHE_LOCK_ENUM);
    if (NT_SUCCESS( Status ))
    {
        Status = KerbScheduleS4UCleanup();
    }             

    return Status;
}

VOID
KerbReferenceS4UCacheEntry(
    IN PKERB_S4UCACHE_DATA CacheEntry
    )
{
    DsysAssert(CacheEntry->ListEntry.ReferenceCount != 0);
    InterlockedIncrement( (LONG *)&CacheEntry->ListEntry.ReferenceCount );
}

VOID
KerbFreeS4UCacheEntry(
    IN PKERB_S4UCACHE_DATA CacheEntry
    )
{
    if (ARGUMENT_PRESENT(CacheEntry))
    {
        KerbFree(CacheEntry);
    }
}


VOID
KerbDereferenceS4UCacheEntry(
    IN PKERB_S4UCACHE_DATA CacheEntry
    )
{
    DsysAssert(CacheEntry->ListEntry.ReferenceCount != 0);

    if ( 0 == InterlockedDecrement( (LONG *)&CacheEntry->ListEntry.ReferenceCount ))
    {
        KerbFreeS4UCacheEntry(CacheEntry);
    }

    return;
}

VOID
KerbInsertS4UCacheEntry(
    IN PKERB_S4UCACHE_DATA CacheEntry
    )
{

    if ( !InterlockedCompareExchange(
              &CacheEntry->Linked,
              (LONG)TRUE,
              (LONG)FALSE ))
    {
        InterlockedIncrement( (LONG *)&CacheEntry->ListEntry.ReferenceCount );
        KerbLockS4UCache();

        InsertHeadList(
            &KerbS4UCache.List,
            &CacheEntry->ListEntry.Next
            );

        KerbUnlockS4UCache();
    }

}




VOID
KerbRemoveS4UCacheEntry(
    IN PKERB_S4UCACHE_DATA CacheEntry
    )
{
    //
    // An entry can only be unlinked from the cache once
    //

    if ( InterlockedCompareExchange(
             &CacheEntry->Linked,
             (LONG)FALSE,
             (LONG)TRUE ))
    {
        DsysAssert(CacheEntry->ListEntry.ReferenceCount != 0);

        KerbLockS4UCache();

        RemoveEntryList(&CacheEntry->ListEntry.Next);

        KerbUnlockS4UCache();

        KerbDereferenceS4UCacheEntry(CacheEntry);

    }
}



PKERB_S4UCACHE_DATA
KerbLocateS4UCacheEntry(
    IN     PLUID LogonId,
    IN OUT PULONG CacheState
    )
{
    PKERB_S4UCACHE_DATA Entry = NULL;
    PLIST_ENTRY ListEntry = NULL;
    TimeStamp CurrentTime;
    BOOLEAN Found = FALSE;

    *CacheState = 0;

    KerbLockS4UCache();
    for (ListEntry = KerbS4UCache.List.Flink ;
        ListEntry !=  &KerbS4UCache.List ;
        ListEntry = ListEntry->Flink )
    {

        Entry = CONTAINING_RECORD(ListEntry, KERB_S4UCACHE_DATA, ListEntry.Next);

        if (RtlEqualLuid(LogonId, &Entry->LogonId))
        {
            KerbReferenceS4UCacheEntry(Entry);
            *CacheState = Entry->CacheState;

            GetSystemTimeAsFileTime( (PFILETIME) &CurrentTime );
            if ( KerbGetTime( CurrentTime ) > KerbGetTime( Entry->CacheEndtime ))
            {
                *CacheState = S4UCACHE_TIMEOUT;
            }

            Found = TRUE;
            break;
        }

    }
    KerbUnlockS4UCache();

    if ( !Found )
    {
        Entry = NULL;
    }

    return Entry;

}



//+-------------------------------------------------------------------------
//
//  Function:   CacheMatch
//
//  Synopsis:   Checks for a S4U Ticket cache match based on flags. Inline function, mainly
//              provided for readability.
//
//  Effects:
//
//
//  Requires:
//
//  Returns:    The referenced cache entry or NULL if it was not found.
//
//  Notes:      If an invalid entry is found it may be dereferenced
//
//
//--------------------------------------------------------------------------


BOOLEAN
CacheMatch(
    IN PKERB_TICKET_CACHE_ENTRY Entry,
    IN PLUID LogonId,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm,
    IN PKERB_INTERNAL_NAME AltClientName,
    IN ULONG LookupFlags,
    IN OUT BOOLEAN *Remove
    )
{

    BOOLEAN fRet = FALSE;
    *Remove = FALSE;

    //
    // We must use a ticket which is relative to the calling
    // security context.
    //
    if (!RtlEqualLuid(LogonId, &Entry->EvidenceLogonId))
    {
        DebugLog((DEB_ERROR, "Cache miss due to luid\n"));
        return FALSE;
    }
    
    if (KerbTicketIsExpiring(Entry, TRUE ))
    {  
        *Remove = TRUE;
        return FALSE;
    } 

    switch (LookupFlags)
    {
    case S4UTICKETCACHE_FOR_EVIDENCE:
        
        //
        // All tickets in the S4U cache are "for evidence",
        // unless they're not forwardable..
        //
        return ((Entry->TicketFlags & KERB_TICKET_FLAGS_forwardable) != 0);

    case S4UTICKETCACHE_MATCH_ALL:
        
        //
        // This is used when caching a new S4U ticket.  In that case, all of the 
        // fields must match.
        //
        DsysAssert(ARGUMENT_PRESENT(ClientName));
        DsysAssert(ARGUMENT_PRESENT(ClientRealm));

        //
        // Tickets obtained due ASC created network logons are only used for
        // evidence, not for S4U.
        //
        if (( Entry->CacheFlags & KERB_TICKET_CACHE_ASC_TICKET ) != 0)
        {
            return FALSE;
        }

        fRet = RtlEqualUnicodeString(ClientRealm, &Entry->ClientDomainName, TRUE);
        
        if (fRet)
        {
            fRet = KerbEqualKdcNames(ClientName, Entry->ClientName);
        }

        if (fRet & (ARGUMENT_PRESENT(AltClientName)))
        {
            fRet = KerbEqualKdcNames(ClientName, Entry->AltClientName);
        }

        break;

    case S4UTICKETCACHE_USEALTNAME:

        //
        // Here, we check for a UPN match on a ticket that's 
        // been "normalized" through a previous S4USelf logon.
        //
        DsysAssert(ARGUMENT_PRESENT(AltClientName));
        
        //
        // Tickets obtained due ASC created network logons are only used for
        // evidence, not for S4U.
        //

        if (( Entry->CacheFlags & KERB_TICKET_CACHE_ASC_TICKET ) != 0)
        {
            return FALSE;
        }
        
        fRet = KerbEqualKdcNames(AltClientName, Entry->AltClientName);
        
        break;

    default:


        //
        // The default, literally.  This is a simple cName / Crealm match used
        // on S4USelf tickets.
        //
        
        //
        // Tickets obtained due ASC created network logons are only used for
        // evidence, not for S4U.
        //
        if (( Entry->CacheFlags & KERB_TICKET_CACHE_ASC_TICKET ) != 0)
        {
            return FALSE;
        }
        
        fRet = (KerbEqualKdcNames(ClientName, Entry->ClientName) &
                RtlEqualUnicodeString(ClientRealm, &Entry->ClientDomainName, TRUE));

        break;
    }

    return fRet;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbLocateS4UTicketCacheEntry
//
//  Synopsis:   References a ticket cache entry by name
//
//  Effects:    Increments the reference count on the ticket cache entry
//
//  Arguments:  TicketCache - the ticket cache to search
//              FullServiceName - Optionally contains full service name
//                      of target, including domain name. If it is NULL,
//                      then the first element in the list is returned.
//              RealmName - Realm of service name. If length is zero, is not
//                      used for comparison.
//
//  Requires:
//
//  Returns:    The referenced cache entry or NULL if it was not found.
//
//  Notes:      If an invalid entry is found it may be dereferenced
//
//
//--------------------------------------------------------------------------

PKERB_TICKET_CACHE_ENTRY
KerbLocateS4UTicketCacheEntry(
    IN PKERB_TICKET_CACHE TicketCache,
    IN PLUID    LogonIdToMatch,
    IN OPTIONAL PKERB_INTERNAL_NAME ClientName,
    IN OPTIONAL PUNICODE_STRING ClientRealm,
    IN OPTIONAL PKERB_INTERNAL_NAME AltClientName,
    IN ULONG    LookupFlags
    )
{
    PLIST_ENTRY ListEntry;
    PKERB_TICKET_CACHE_ENTRY CacheEntry = NULL;
    BOOLEAN Found = FALSE;
    BOOLEAN Remove = FALSE;
    BOOLEAN CleanupNeeded = FALSE;
    BOOLEAN Timeout = FALSE;
    TimeStamp CurrentTime;
    TimeStamp CutoffTime;

    GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
    
    KerbReadLockTicketCache();
    
    KerbSetTime(&CutoffTime, KerbGetTime(TicketCache->LastCleanup) + KerbGetTime(KerbGlobalS4UTicketLifetime));
    Timeout = (KerbGetTime(CurrentTime) < KerbGetTime(CutoffTime));
    
    //
    // Go through the ticket cache looking for the correct entry
    //

    for (ListEntry = TicketCache->CacheEntries.Flink ;
         ListEntry !=  &TicketCache->CacheEntries ;
         ListEntry = ListEntry->Flink )
    {
        CacheEntry = CONTAINING_RECORD(ListEntry, KERB_TICKET_CACHE_ENTRY, ListEntry.Next);

        if ( CacheMatch(
                CacheEntry,
                LogonIdToMatch,
                ClientName,
                ClientRealm,
                AltClientName,
                LookupFlags,
                &Remove
                ) )
        {
            KerbReferenceTicketCacheEntry(CacheEntry);
            Found = TRUE;
            break;
        }
        
        //
        // If we detect expired tickets, cleanup the cache.  Only do this
        // every 15 minutes, though, so we don't end up with a bunch of 
        // contention on the ticketcache resource in stress conditions.
        //
        if ( Remove ) 
        {
            CleanupNeeded = Timeout;
        }
    }

    KerbUnlockTicketCache();

    if (!Found)
    {
        CacheEntry = NULL;
    }

    //
    // We cleanup here to avoid having to always take the write lock.
    //
    if ( CleanupNeeded )
    {
        KerbAgeTickets( TicketCache );
        DebugLog((DEB_TRACE_S4U, "Cleanup needed\n"));
    }

    return(CacheEntry);
}


NTSTATUS
KerbGetCallingLuid(
    IN OUT PLUID CallingLuid,
    IN OPTIONAL HANDLE hProcess
    )
{

    NTSTATUS            Status, TokenStatus;
    SECPKG_CLIENT_INFO  ClientInfo;
    CLIENT_ID           ClientId;
    OBJECT_ATTRIBUTES   Obja;
    HANDLE              hClientProcess =  NULL;
    HANDLE              hToken = NULL;
    HANDLE              ImpersonationToken = NULL;
    TOKEN_STATISTICS    TokenStats;
    DWORD               TokenStatsSize = sizeof(TokenStats);

    if (!ARGUMENT_PRESENT(hProcess))
    {
        Status = LsaFunctions->GetClientInfo( &ClientInfo );

        if (!NT_SUCCESS( Status ))
        {
            return ( Status );
        }
        else if ((ClientInfo.ClientFlags & SECPKG_CLIENT_THREAD_TERMINATED) != 0)
        {
            return STATUS_ACCESS_DENIED;
        }

        ClientId.UniqueProcess = (HANDLE)LongToHandle(ClientInfo.ProcessID);
        ClientId.UniqueThread = (HANDLE)NULL;
    }
    else
    {
        ClientId.UniqueProcess = hProcess;
        ClientId.UniqueThread = (HANDLE)NULL;
    }


    //
    // If we're called by an in-proc lsass caller, we could be impersonating.
    // Revert, to make sure we're ok to do the below operation.
    //
    TokenStatus = NtOpenThreadToken(
                               NtCurrentThread(),
                               TOKEN_QUERY | TOKEN_IMPERSONATE,
                               TRUE,
                               &ImpersonationToken
                               );

    if( NT_SUCCESS(TokenStatus) )
    {
        //
        // stop impersonating.
        //
        RevertToSelf();
    }


    InitializeObjectAttributes(
        &Obja,
        NULL,
        0,
        NULL,
        NULL
        );


    Status = NtOpenProcess(
                 &hClientProcess,
                 (ACCESS_MASK)PROCESS_QUERY_INFORMATION,
                 &Obja,
                 &ClientId
                 );

    if (NT_SUCCESS( Status ))
    {

        Status = NtOpenProcessToken(
                    hClientProcess,
                    TOKEN_QUERY,
                    &hToken
                    );

        if (NT_SUCCESS( Status ) )
        {

            Status = NtQueryInformationToken(
                            hToken,
                            TokenStatistics,
                            &TokenStats,
                            TokenStatsSize,
                            &TokenStatsSize
                            );

            if (NT_SUCCESS( Status ))
            {
                RtlCopyLuid(
                    CallingLuid,
                    &(TokenStats.AuthenticationId)
                    );
            }

            NtClose( hToken );
        }

        NtClose( hClientProcess );
    }

    if (!NT_SUCCESS( Status ))
    {
        D_DebugLog((DEB_ERROR, "Failed to get LUID\n"));
    }

    if( ImpersonationToken != NULL )
    {
        //
        // put the thread token back if we were impersonating.
        //
        SetThreadToken( NULL, ImpersonationToken );
        NtClose( ImpersonationToken );
    }

    return ( Status );

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeS4UCacheData
//
//  Synopsis:  Check the S4UCACHE_DATA to see if we can do S4U for this target.
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session of the service doing the
//                             S4U request
//
//  Requires:   You must hold the logon session lock.
//
//  Returns:
//
//  Notes:
//
//
//+-------------------------------------------------------------------------

NTSTATUS
KerbInitializeS4UCacheData(
    IN OUT PKERB_S4UCACHE_DATA *CacheData,
    IN PLUID LogonId,
    IN ULONG CacheFlags
    )
{   
    PKERB_S4UCACHE_DATA LocalData = NULL;
    TimeStamp CurrentTime;

    *CacheData = NULL;
    LocalData = (PKERB_S4UCACHE_DATA) KerbAllocate(sizeof(KERB_S4UCACHE_DATA));
    if ( NULL == LocalData )
    {
        return STATUS_NO_MEMORY;
    }

    RtlCopyLuid(
        &LocalData->LogonId,
        LogonId
        );

    LocalData->CacheState = CacheFlags;
   
    GetSystemTimeAsFileTime( (PFILETIME) &CurrentTime );
    KerbSetTime(&LocalData->CacheEndtime, KerbGetTime(CurrentTime) + KerbGetTime( KerbGlobalS4UCacheTimeout ));
    KerbInsertS4UCacheEntry(LocalData);

    *CacheData = LocalData;
    LocalData = NULL;    
    return STATUS_SUCCESS;
}





//+-------------------------------------------------------------------------
//
//  Function:   KerbUpdateS4UCacheData
//
//  Synopsis:  Update the S4UCACHE_DATA
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session of the service doing the
//                             S4U request
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//+-------------------------------------------------------------------------

NTSTATUS
KerbUpdateS4UCacheData(
    IN PKERB_LOGON_SESSION LogonSession,
    IN ULONG               Flags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    TimeStamp         CurrentTime;

    PKERB_S4UCACHE_DATA CacheData = NULL;
    ULONG               CacheFlags = 0;

    KerbLockS4UCache();
    CacheData = KerbLocateS4UCacheEntry(
                    &LogonSession->LogonId,
                    &CacheFlags
                    );

    if ( CacheData != NULL )
    {   
        D_DebugLog((DEB_TRACE_S4U, "Updating existing entry %p - %x\n", CacheData, Flags));
        CacheData->CacheState = Flags;
        GetSystemTimeAsFileTime( (PFILETIME) &CurrentTime );
        KerbSetTime(&CacheData->CacheEndtime, KerbGetTime(CurrentTime) + KerbGetTime( KerbGlobalS4UCacheTimeout ));
        KerbDereferenceS4UCacheEntry(CacheData);
    }
    else
    {
        //
        // We don't have one for this logon ID.  Create one.
        //
        Status = KerbInitializeS4UCacheData(
                        &CacheData,
                        &LogonSession->LogonId,
                        Flags
                        );
    }

    KerbUnlockS4UCache();

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbCacheS4UTicket
//
//  Synopsis:   Ensures that the ticket we got back from the KDC actually has
//              the information we requested, then caches it.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      This function performs a quick correctness test only before
//              caching the S4U Ticket.
//              We don't want to take the extra hit to decrypt this
//              ticket to get "real" name, as We'll do that later, when
//              we build the token (krbtoken.cxx)  Later, we should see if
//              there's a better way to do this.
//
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbCacheS4UTicket(
    IN PKERB_LOGON_SESSION CallerLogonSession,
    IN PKERB_KDC_REPLY KdcReply,
    IN PKERB_ENCRYPTED_KDC_REPLY KdcReplyBody,
    IN PKERB_INTERNAL_NAME OurTargetName,
    IN PKERB_INTERNAL_NAME S4UClientName,
    IN OPTIONAL PKERB_INTERNAL_NAME AltS4UClientName,
    IN PUNICODE_STRING S4UClientRealm,
    IN ULONG CacheFlags,
    IN OPTIONAL PKERB_TICKET_CACHE TicketCache,
    OUT PKERB_TICKET_CACHE_ENTRY * NewCacheEntry
    )
{
    NTSTATUS Status = STATUS_LOGON_FAILURE;
    KERBERR  KerbErr;
    BOOLEAN  Result = FALSE;
    PKERB_TICKET_CACHE_ENTRY CacheEntry = NULL;
    PKERB_TICKET_CACHE_ENTRY OldCacheEntry = NULL;


    *NewCacheEntry = NULL;


    CacheEntry = (PKERB_TICKET_CACHE_ENTRY) KerbAllocate(sizeof(KERB_TICKET_CACHE_ENTRY));
    if (CacheEntry == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    CacheEntry->ListEntry.ReferenceCount = 1;


#if DBG
    if ( CacheEntry ) {

        KerbWriteLockTicketCache();
        InsertHeadList(
            &GlobalTicketList,
            &CacheEntry->GlobalListEntry
            );
        
        KerbUnlockTicketCache();
    }

#endif

    InterlockedIncrement( &GlobalTicketListSize );

    //
    // Check Client identity  - if any of these *don't* match, it means our KDC 
    // doesn't understand the protocol, and is just giving us a ticket to ourselves,
    // from ourselves - e.g. sname = us, cname = us.  
    //
    // If the KDC understands S4U, then sname = us, but cname = client name.  Same
    // goes for the crealm and the target name.
    //
    KerbErr = KerbCompareKdcNameToPrincipalName(
                    &KdcReply->client_name,
                    S4UClientName,
                    &Result
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    else if (!Result)
    {
        KerbReadLockLogonSessions(CallerLogonSession);  
        
        //
        // Hmm.. Is this the caller logon cname?
        //
        if (KerbCompareStringToPrincipalName(
                        &KdcReply->client_name,
                        &CallerLogonSession->PrimaryCredentials.UserName
                        ))
        {
            Status = STATUS_NO_S4U_PROT_SUPPORT;   
        }
        else
        {
            Status = STATUS_LOGON_FAILURE;
        }                                 
        
        KerbUnlockLogonSessions(CallerLogonSession);
        DebugLog((DEB_ERROR, "S4UClient name != Reply Client name %x\n", Status));
        goto Cleanup;                                                             
    }

    KerbErr = KerbCompareUnicodeRealmToKerbRealm(
                &KdcReply->client_realm,
                S4UClientRealm,
                &Result
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    else if (!Result)
    {
        KerbReadLockLogonSessions(CallerLogonSession);

        KerbErr = KerbCompareUnicodeRealmToKerbRealm(
                &KdcReply->client_realm,
                &CallerLogonSession->PrimaryCredentials.DomainName,
                &Result
                );

        KerbUnlockLogonSessions(CallerLogonSession);

        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Status = (Result ? STATUS_NO_S4U_PROT_SUPPORT : STATUS_LOGON_FAILURE);
        DebugLog((DEB_ERROR, "S4UClient REALM != Reply Client REALM %x\n", Status));
        goto Cleanup;
    }

    //
    // Check target name.
    //
    KerbErr = KerbCompareKdcNameToPrincipalName(
                    &KdcReply->ticket.server_name,
                    OurTargetName,
                    &Result
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    else if (!Result)
    {
        DebugLog((DEB_ERROR, "ServerName != TargetName\n"));
        Status = STATUS_NO_S4U_PROT_SUPPORT;
        goto Cleanup;
    }

    CacheEntry->TicketFlags = KerbConvertFlagsToUlong(&KdcReplyBody->flags);


    if (KdcReplyBody->bit_mask & KERB_ENCRYPTED_KDC_REPLY_starttime_present)
    {
        KerbConvertGeneralizedTimeToLargeInt(
            &CacheEntry->StartTime,
            &KdcReplyBody->KERB_ENCRYPTED_KDC_REPLY_starttime,
            NULL
            );
    }
    else
    {
        KerbConvertGeneralizedTimeToLargeInt(
            &CacheEntry->StartTime,
            &KdcReplyBody->authtime,
            NULL
            );
    }

    KerbConvertGeneralizedTimeToLargeInt(
            &CacheEntry->EndTime,
            &KdcReplyBody->endtime,
            NULL
            );


    if (KdcReplyBody->bit_mask & KERB_ENCRYPTED_KDC_REPLY_renew_until_present)
    {
        KerbConvertGeneralizedTimeToLargeInt(
            &CacheEntry->RenewUntil,
            &KdcReplyBody->KERB_ENCRYPTED_KDC_REPLY_renew_until,
            NULL
            );
    }

    //
    // Time skew check ?
    //

    Status = KerbDuplicateKdcName(
                &CacheEntry->TargetName,
                S4UClientName
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbDuplicateStringEx(
                    &CacheEntry->ClientDomainName,
                    S4UClientRealm,
                    FALSE
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = KerbDuplicateKdcName(
                &CacheEntry->ClientName,
                S4UClientName
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (ARGUMENT_PRESENT( AltS4UClientName ))
    {
        Status = KerbDuplicateKdcName(
                &CacheEntry->AltClientName,
                S4UClientName
                );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // ServiceName is unused for S4U but other spots in Kerberos expect it
    // to be non-NULL.  Dupe the ClientName into it as the best match.
    //

    Status = KerbDuplicateKdcName(
                &CacheEntry->ServiceName,
                OurTargetName
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbDuplicateTicket(
                    &CacheEntry->Ticket,
                    &KdcReply->ticket
                    )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    CacheEntry->EvidenceLogonId = CallerLogonSession->LogonId;
    CacheEntry->CacheFlags = CacheFlags | KERB_TICKET_CACHE_S4U_TICKET;
    
    if (ARGUMENT_PRESENT(TicketCache))
    {
        //
        // Before we insert this ticket we want to remove any
        // previous instances of tickets to the same service.
        //
        OldCacheEntry = KerbLocateS4UTicketCacheEntry(
                            TicketCache,
                            &CallerLogonSession->LogonId,
                            S4UClientName,
                            S4UClientRealm,
                            AltS4UClientName,
                            S4UTICKETCACHE_MATCH_ALL
                            );

        if (OldCacheEntry != NULL)
        {
            D_DebugLog((DEB_TRACE_S4U, "Removing S4U Cache Entry - %p\n", OldCacheEntry));
            KerbRemoveTicketCacheEntry( OldCacheEntry );
            KerbDereferenceTicketCacheEntry( OldCacheEntry );
        }

        KerbInsertTicketCacheEntry(
            TicketCache,
            CacheEntry
            );
    }

    *NewCacheEntry = CacheEntry;
    CacheEntry = NULL;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (NULL != CacheEntry)
        {
            KerbDereferenceTicketCacheEntry(CacheEntry);
        }
    }

    return(Status);
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbGetS4UClientRealm
//
//  Synopsis:   Gets the client realm for a given UPN
//
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session of the service doing the
//                             S4U request
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetS4UClientRealm(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_INTERNAL_NAME * S4UClientName,
    IN OUT PUNICODE_STRING S4UTargetRealm
    // TBD:  Place for credential handle?
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    PKERB_INTERNAL_NAME KdcServiceKdcName = NULL;
    PKERB_INTERNAL_NAME ClientName = NULL;
    UNICODE_STRING ClientRealm = {0};
    UNICODE_STRING CorrectRealm = {0};
    ULONG RetryCount = KERB_CLIENT_REFERRAL_MAX;
    ULONG RequestFlags = 0;
    BOOLEAN MitRealmLogon = FALSE;
    PKERB_TICKET_CACHE_ENTRY    TicketCacheEntry = NULL;


    RtlInitUnicodeString(
      S4UTargetRealm,
      NULL
      );

    //
    // Use our server credentials to start off the AS_REQ process.
    // We may get a referral elsewhere, however.
    //

    Status = KerbGetClientNameAndRealm(
                 NULL,
                 &LogonSession->PrimaryCredentials,
                 FALSE,
                 NULL,
                 &MitRealmLogon,
                 TRUE,
                 &ClientName,
                 &ClientRealm
                 );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to get client name & realm: 0x%x, %ws line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

GetTicketRestart:

    D_DebugLog((DEB_TRACE_S4U, "KerbGetS4UClientRealm GetTicketRestart ClientRealm %wZ\n", &ClientRealm));

    KerbErr = KerbBuildFullServiceKdcName(
                 &ClientRealm,
                 &KerbGlobalKdcServiceName,
                 KRB_NT_SRV_INST,
                 &KdcServiceKdcName
                 );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = KerbGetAuthenticationTicket(
                 LogonSession,
                 NULL,
                 NULL,
                 FALSE,       // no preauth..
                 KdcServiceKdcName,
                 &ClientRealm,
                 (*S4UClientName),
                 RequestFlags,
                 KERB_TICKET_CACHE_PRIMARY_TGT,
                 &TicketCacheEntry,
                 NULL,
                 &CorrectRealm
                 );
    //
    // If it failed but gave us another realm to try, go there
    //

    if (!NT_SUCCESS(Status) && (CorrectRealm.Length != 0))
    {
        if (--RetryCount != 0)
        {
           KerbFreeKdcName(&KdcServiceKdcName);
           KerbFreeString(&ClientRealm);
           ClientRealm = CorrectRealm;
           CorrectRealm.Buffer = NULL;
           goto GetTicketRestart;
        }
        else
        {
           // Tbd:  Log error here?  Max referrals reached..
           goto Cleanup;
        }

     }


    //
    // If we get STATUS_WRONG_PASSWORD, we succeeded in finding the
    // client realm.  Otherwise, we're hosed.  As the password we used
    // is bogus, we should never succeed, btw...
    //

    if (Status == STATUS_WRONG_PASSWORD)
    {
        *S4UTargetRealm = ClientRealm;
        Status = STATUS_SUCCESS;
    }




Cleanup:


    // if we succeeded, we got the correct realm,
    // and we need to pass that back to caller
    if (!NT_SUCCESS(Status))
    {
        KerbFreeString(&ClientRealm);
    }

    KerbFreeKdcName(&KdcServiceKdcName);
    KerbFreeKdcName(&ClientName);

    if (NULL != TicketCacheEntry)
    {
        KerbRemoveTicketCacheEntry(TicketCacheEntry);
        KerbDereferenceTicketCacheEntry(TicketCacheEntry);
    }


    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbPackAndSignS4UPreauthData
//
//  Synopsis:   Attempt to gets TGT for an S4U client for name
//              location purposes.
//
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session of the service doing the
//                             S4U request
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbSignAndPackS4UPreauthData(
    IN OUT PKERB_PA_DATA_LIST * PreAuthData,
    IN PKERB_TICKET_CACHE_ENTRY TicketGrantingTicket,
    IN PKERB_PA_FOR_USER S4UPreauth
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR  KerbErr;

    PKERB_PA_DATA_LIST ListElement = NULL;
    unsigned char  Hash[MD5DIGESTLEN];

    *PreAuthData = NULL;
    S4UPreauth->cksum.checksum.value = Hash;

    Status = KerbHashS4UPreauth(
                    S4UPreauth,
                    &TicketGrantingTicket->SessionKey,
                    KERB_CHECKSUM_HMAC_MD5,
                    &S4UPreauth->cksum
                    );

    if ( !NT_SUCCESS(Status) )
    {
        goto Cleanup;
    }


    ListElement = (PKERB_PA_DATA_LIST) KerbAllocate(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }


    KerbErr = KerbPackData(
                    S4UPreauth,
                    KERB_PA_FOR_USER_PDU,
                    (PULONG) &ListElement->value.preauth_data.length,
                    (PUCHAR *) &ListElement->value.preauth_data.value
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }



    ListElement->value.preauth_data_type = KRB5_PADATA_FOR_USER;
    ListElement->next = NULL;

    *PreAuthData = ListElement;
    ListElement = NULL;

Cleanup:

    if (ListElement)
    {
        KerbFreePreAuthData(ListElement);
    }


    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildS4UPreauth
//
//  Synopsis:   Attempt to gets TGT for an S4U client for name
//              location purposes.
//
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session of the service doing the
//                             S4U request
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KerbBuildS4UPreauth(
    IN OUT PKERB_PA_FOR_USER S4UPreauth,
    IN PKERB_INTERNAL_NAME S4UClientName,
    IN PUNICODE_STRING S4UClientRealm,
    IN OPTIONAL PKERB_MESSAGE_BUFFER AuthorizationData
    )
{
    KERBERR KerbErr;
    LPSTR PackageName = MICROSOFT_KERBEROS_NAME_A;

    KerbErr = KerbConvertKdcNameToPrincipalName(
                    &S4UPreauth->userName,
                    S4UClientName
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    KerbErr = KerbConvertUnicodeStringToRealm(
                            &S4UPreauth->userRealm,
                            S4UClientRealm
                            );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }

    if (ARGUMENT_PRESENT(AuthorizationData))
    {
        S4UPreauth->authorization_data.value = AuthorizationData->Buffer;
        S4UPreauth->authorization_data.length = AuthorizationData->BufferSize;
        S4UPreauth->bit_mask |= KERB_PA_FOR_USER_authorization_data_present;
    }


    S4UPreauth->authentication_package = PackageName;

Cleanup:

    return KerbErr;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetTgtToS4URealm
//
//  Synopsis:   We need a TGT to the client realm under the caller's cred's
//              so we can make a S4U TGS_REQ.
//
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session of the service doing the
//                             S4U request
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbGetTgtToS4URealm(
    IN PKERB_LOGON_SESSION CallerLogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN PUNICODE_STRING S4UClientRealm,
    IN OUT PKERB_TICKET_CACHE_ENTRY * S4UTgt,
    IN ULONG Flags,
    IN ULONG TicketOptions,
    IN ULONG EncryptionType
    )
{
    NTSTATUS    Status;
    ULONG       RetryFlags = 0;
    BOOLEAN     CrossRealm = FALSE;
    BOOLEAN     TicketCacheLocked = FALSE, LogonSessionsLocked = FALSE;

    PKERB_TICKET_CACHE_ENTRY    TicketGrantingTicket = NULL;
    PKERB_TICKET_CACHE_ENTRY    LastTgt = NULL;
    PKERB_TICKET_CACHE_ENTRY    TicketCacheEntry = NULL;
    PKERB_KDC_REPLY             KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY   KdcReplyBody = NULL;
    PKERB_INTERNAL_NAME         TargetTgtKdcName = NULL;
    UNICODE_STRING              ClientRealm = NULL_UNICODE_STRING;
    PKERB_PRIMARY_CREDENTIAL    PrimaryCredentials = NULL;

    *S4UTgt = NULL;



    KerbReadLockLogonSessions(CallerLogonSession);
    LogonSessionsLocked = TRUE;

    if ((Credential != NULL) && (Credential->SuppliedCredentials != NULL))
    {
        PrimaryCredentials = Credential->SuppliedCredentials;
    }
    else
    {   
        PrimaryCredentials = &CallerLogonSession->PrimaryCredentials;
    }


    
    Status = KerbGetTgtForService(
                    CallerLogonSession,
                    Credential,
                    NULL,
                    NULL,
                    S4UClientRealm,
                    0,
                    &TicketGrantingTicket,
                    &CrossRealm
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If this isn't cross realm, then we've got a TGT to the realm.
    // return it and bail.
    //
    if (!CrossRealm)
    {
        *S4UTgt = TicketGrantingTicket;
        TicketGrantingTicket = NULL;
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbBuildFullServiceKdcName(
            S4UClientRealm,
            &KerbGlobalKdcServiceName,
            KRB_NT_SRV_INST,
            &TargetTgtKdcName
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Copy out the client realm name which is used when obtaining the ticket
    //

    Status = KerbDuplicateString(
                &ClientRealm,
                &PrimaryCredentials->DomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (LogonSessionsLocked)
    {
        KerbUnlockLogonSessions(CallerLogonSession);
        LogonSessionsLocked = FALSE;
    }


    //
    // Do some referral chasing to get our ticket grantin ticket.
    //
    while (!RtlEqualUnicodeString(
                S4UClientRealm,
                &TicketGrantingTicket->TargetDomainName,
                TRUE ))
    {

        //
        // If we just got two TGTs for the same domain, then we must have
        // gotten as far as we can. Chances our our RealTargetRealm is a
        // variation of what the KDC hands out.
        //
        // Typically, this call handles the Netbios / DNS case, where the
        // TGT we're looking for (netbios form) is one we just got back.
        //
        if ((LastTgt != NULL) &&
             RtlEqualUnicodeString(
                &LastTgt->TargetDomainName,
                &TicketGrantingTicket->TargetDomainName,
                TRUE ))
        {
            if (TicketCacheLocked)
            {
                KerbUnlockTicketCache();
                TicketCacheLocked = FALSE;
            }

            KerbSetTicketCacheEntryTarget(
                S4UClientRealm,
                LastTgt
                );

            D_DebugLog((DEB_TRACE_CTXT, "Got two TGTs for same realm (%wZ), bailing out of referral loop\n",
                &LastTgt->TargetDomainName));
            break;
        }

        D_DebugLog((DEB_TRACE_CTXT, "Getting referral TGT for \n"));
        D_KerbPrintKdcName((DEB_TRACE_CTXT, TargetTgtKdcName));
        D_KerbPrintKdcName((DEB_TRACE_CTXT, TicketGrantingTicket->ServiceName));

        if (TicketCacheLocked)
        {
            KerbUnlockTicketCache();
            TicketCacheLocked = FALSE;
        }

        //
        // Cleanup old state
        //

        KerbFreeTgsReply(KdcReply);
        KerbFreeKdcReplyBody(KdcReplyBody);
        KdcReply = NULL;
        KdcReplyBody = NULL;


        Status = KerbGetTgsTicket(
                    &ClientRealm,
                    TicketGrantingTicket,
                    TargetTgtKdcName,
                    FALSE,
                    TicketOptions,
                    EncryptionType,
                    NULL,
                    NULL,                       // no PA data here.
                    NULL,                       // no tgt reply since target is krbtgt
                    NULL,
                    NULL,                       // let kdc determine end time
                    &KdcReply,
                    &KdcReplyBody,
                    &RetryFlags
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN,"Failed to get TGS ticket for service 0x%x :",
                Status ));
            KerbPrintKdcName(DEB_WARN, TargetTgtKdcName);
            DebugLog((DEB_WARN, "%ws, line %d\n", THIS_FILE, __LINE__));

            //
            // We want to map cross-domain failures to failures indicating
            // that a KDC could not be found. This means that for Kerberos
            // logons, the negotiate code will retry with a different package
            //

            // if (Status == STATUS_NO_TRUST_SAM_ACCOUNT)
            // {
            //     Status = STATUS_NO_LOGON_SERVERS;
            // }
            goto Cleanup;
        }

        //
        // Now we have a ticket - Cache it
        //
        DsysAssert( !LogonSessionsLocked );
        KerbWriteLockLogonSessions(CallerLogonSession);
        LogonSessionsLocked = TRUE;

        Status = KerbCreateTicketCacheEntry(
                    KdcReply,
                    KdcReplyBody,
                    NULL,                               // no target name
                    NULL,                               // no targe realm
                    0,                                  // no flags
                    &CallerLogonSession->PrimaryCredentials.AuthenticationTicketCache,
                    NULL,                               // no credential key
                    &TicketCacheEntry
                    );

        KerbUnlockLogonSessions(CallerLogonSession);
        LogonSessionsLocked = FALSE;


        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if (LastTgt != NULL)
        {
            KerbDereferenceTicketCacheEntry(LastTgt);
            LastTgt = NULL;
        }
        LastTgt = TicketGrantingTicket;
        TicketGrantingTicket = TicketCacheEntry;
        TicketCacheEntry = NULL;

        DsysAssert( !TicketCacheLocked );
        KerbReadLockTicketCache();
        TicketCacheLocked = TRUE;


    }     // ** WHILE **


    *S4UTgt = TicketGrantingTicket;
    TicketGrantingTicket = NULL;

Cleanup:

    if (TicketCacheLocked)
    {
        KerbUnlockTicketCache();
    }

    if (LogonSessionsLocked)
    {
        KerbUnlockLogonSessions(CallerLogonSession);
    }

    KerbFreeTgsReply( KdcReply );
    KerbFreeKdcReplyBody( KdcReplyBody );
    KerbFreeKdcName( &TargetTgtKdcName );

    if (TicketGrantingTicket != NULL)
    {
        KerbDereferenceTicketCacheEntry(TicketGrantingTicket);
    }

    if (LastTgt != NULL)
    {
        KerbDereferenceTicketCacheEntry(LastTgt);
    }

    KerbFreeString( &ClientRealm );
    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbGetS4UTargetName
//
//  Synopsis:   Attempt to gets target for TGS_REQ
//
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session of the service doing the
//                             S4U request
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//----------------------------------


NTSTATUS
KerbGetS4UTargetName(
    IN OUT PKERB_INTERNAL_NAME * NewTarget,
    IN PKERB_PRIMARY_CREDENTIAL Cred,
    IN PLUID CallerLuid,
    IN OUT PBOOLEAN Upn
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT      i;
    BOOLEAN     Found = FALSE;

    PKERB_INTERNAL_NAME FinalTarget = NULL;
    LUID                System = SYSTEM_LUID;
    LUID                NetworkService = NETWORKSERVICE_LUID;

    *NewTarget = NULL;
    *Upn = FALSE;


    if (RtlEqualLuid(&System, CallerLuid) ||
        RtlEqualLuid(&NetworkService, CallerLuid))
    {
        KerbGlobalReadLock();

        Status = KerbDuplicateKdcName(
                        NewTarget,
                        KerbGlobalMitMachineServiceName
                        );

        KerbGlobalReleaseLock();
        goto cleanup;
    }



    //
    // This is a non-system caller.  We'll want to use a UPN for the
    // target name - do we have a UPN in the primary credential?  If not,
    // fake one up based on the "implicit" UPN.
    //
    if (Cred->DomainName.Length == 0)
    {
        //
        // Better have an @ sign in the user name, or we're through.
        //
        for (i=0;i < Cred->UserName.Length ;i++)
        {
            if (Cred->UserName.Buffer[i] == L'@')
            {
                Found = TRUE;
                break;
            }
        }

        if (!Found)
        {
            Status = SEC_E_NO_CREDENTIALS;
            D_DebugLog((DEB_ERROR, "Invalid user name for S4u\n"));
            goto cleanup;
        }

        FinalTarget = (PKERB_INTERNAL_NAME) MIDL_user_allocate(
                                                KERB_INTERNAL_NAME_SIZE(1) +
                                                Cred->UserName.MaximumLength
                                                );

        if (FinalTarget == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        FinalTarget->NameCount = 1;
        FinalTarget->NameType = KRB_NT_ENTERPRISE_PRINCIPAL;

        Status = KerbDuplicateString(
                    &FinalTarget->Names[0],
                    &Cred->UserName
                    );

        if (!NT_SUCCESS(Status))
        {
            goto cleanup;
        }

        

    }
    else
    {
        //
        // Craft a UPN out of thin air :)
        //
        PWSTR Offset;

        FinalTarget = (PKERB_INTERNAL_NAME) MIDL_user_allocate(
                                                KERB_INTERNAL_NAME_SIZE(1) +
                                                Cred->UserName.Length +
                                                Cred->DomainName.Length +
                                                (2*sizeof(WCHAR))
                                                );

        if (FinalTarget == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        FinalTarget->NameCount = 1;
        FinalTarget->NameType = KRB_NT_ENTERPRISE_PRINCIPAL;
        FinalTarget->Names[0].Length =  Cred->UserName.Length +
                                        Cred->DomainName.Length +
                                        sizeof(WCHAR);

        FinalTarget->Names[0].MaximumLength =  Cred->UserName.Length +
                                               Cred->DomainName.Length +
                                               (2*sizeof(WCHAR));


        FinalTarget->Names[0].Buffer = (PWSTR) RtlOffsetToPointer(FinalTarget, sizeof(KERB_INTERNAL_NAME));

        RtlCopyMemory(
            FinalTarget->Names[0].Buffer,
            Cred->UserName.Buffer,
            Cred->UserName.Length
            );

        Offset = (PWSTR) FinalTarget->Names[0].Buffer + (Cred->UserName.Length/sizeof(WCHAR));

        (*Offset) = L'@';
        Offset++;

        RtlCopyMemory(
            Offset,
            Cred->DomainName.Buffer,
            Cred->DomainName.Length
            );
    }

    *Upn = TRUE;
    *NewTarget = FinalTarget;

cleanup:

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbGetS4UServiceTicket
//
//  Synopsis:   Gets an s4uself service ticket.
//
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session of the service doing the
//                             S4U request
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetS4USelfServiceTicket(
    IN PKERB_LOGON_SESSION CallerLogonSession,
    IN PKERB_LOGON_SESSION NewLogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN PKERB_INTERNAL_NAME S4UClientName,
    IN PKERB_INTERNAL_NAME AltS4UClientName,
    IN PUNICODE_STRING S4UClientRealm,
    IN OUT PKERB_TICKET_CACHE_ENTRY * S4UTicket,
    IN ULONG Flags,
    IN ULONG TicketOptions,
    IN ULONG EncryptionType,
    IN OPTIONAL PKERB_MESSAGE_BUFFER AdditionalAuthData
    )
{
    NTSTATUS                    Status;
    PKERB_TICKET_CACHE_ENTRY    TicketCacheEntry = NULL;
    PKERB_TICKET_CACHE_ENTRY    TicketGrantingTicket = NULL;
    PKERB_TICKET_CACHE_ENTRY    LastTgt = NULL;
    PKERB_KDC_REPLY             KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY   KdcReplyBody = NULL;
    PKERB_PA_DATA_LIST          S4UPaDataList = NULL;
    BOOLEAN                     LogonSessionsLocked = FALSE;
    ULONG S4UEvidenceTicketCacheFlags = 0;
    KERB_ENCRYPTION_KEY U2UServerSKey = {0};
    KERB_TGT_REPLY FakeTgtReply = {0};
    PKERB_TICKET_CACHE_ENTRY pRealTicketGrantingTicket = NULL;
    UNICODE_STRING NoTargetName = {0};

    PKERB_INTERNAL_NAME RealTargetName = NULL;
    PKERB_INTERNAL_NAME TargetName = NULL;

    UNICODE_STRING RealTargetRealm = NULL_UNICODE_STRING;
    PKERB_INTERNAL_NAME TargetTgtKdcName = NULL;
    PKERB_PRIMARY_CREDENTIAL PrimaryCredentials = NULL;
    BOOLEAN UsedCredentials = FALSE, Upn = FALSE;
    UNICODE_STRING ClientRealm = NULL_UNICODE_STRING;
    BOOLEAN CacheTicket = KerbGlobalCacheS4UTicket;
    ULONG ReferralCount = 0;
    ULONG RetryFlags = 0;
    PLUID CallingLogonId;
    KERB_PA_FOR_USER S4UPreAuth = {0};
    BOOLEAN fMITRetryAlreadyMade = FALSE;
    BOOLEAN TgtRetryMade = FALSE;
    TimeStamp RequestBodyEndTime;

    GetSystemTimeAsFileTime((PFILETIME) &RequestBodyEndTime);
    RequestBodyEndTime.QuadPart += KerbGetTime(KerbGlobalS4UTicketLifetime);

    //
    // Check to see if the credential has any primary credentials
    //

TGTRetry:

    DsysAssert( !LogonSessionsLocked );
    KerbReadLockLogonSessions(CallerLogonSession);
    LogonSessionsLocked = TRUE;

    if ((Credential != NULL) && (Credential->SuppliedCredentials != NULL))
    {
        PrimaryCredentials = Credential->SuppliedCredentials;
        UsedCredentials = TRUE;
        CallingLogonId = &Credential->LogonId;
    }
    else
    {
        PrimaryCredentials = &CallerLogonSession->PrimaryCredentials;
        CallingLogonId = &CallerLogonSession->LogonId;
    }

    Status = KerbGetS4UTargetName(
                &TargetName,
                PrimaryCredentials,
                CallingLogonId,
                &Upn
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if ((Flags & (KERB_GET_TICKET_NO_CACHE | KERB_TARGET_DID_ALTNAME_LOOKUP)) == 0)
    {
        TicketCacheEntry = KerbLocateS4UTicketCacheEntry(
                                &PrimaryCredentials->S4UTicketCache,
                                CallingLogonId,
                                S4UClientName,
                                S4UClientRealm,
                                NULL,
                                0
                                );
    }
    else if (( Flags & KERB_GET_TICKET_NO_CACHE ) != 0 )
    {
        CacheTicket = FALSE;
    }

    if (TicketCacheEntry != NULL)
    {
        ULONG TicketFlags;
        ULONG CacheTicketFlags;
        ULONG CacheEncryptionType;

        //
        // Check if the flags are present
        //

        KerbReadLockTicketCache();
        CacheTicketFlags = TicketCacheEntry->TicketFlags;
        CacheEncryptionType = TicketCacheEntry->Ticket.encrypted_part.encryption_type;
        KerbUnlockTicketCache();

        TicketFlags = KerbConvertKdcOptionsToTicketFlags(TicketOptions);

        if (((CacheTicketFlags & TicketFlags) != TicketFlags) ||
            ((EncryptionType != 0) && (CacheEncryptionType != EncryptionType)))

        {
            KerbDereferenceTicketCacheEntry(TicketCacheEntry);
            TicketCacheEntry = NULL;
        }
        else
        {
            //
            // Check the ticket time
            //

            if (KerbTicketIsExpiring(TicketCacheEntry, TRUE))
            {
                KerbDereferenceTicketCacheEntry(TicketCacheEntry);
                TicketCacheEntry = NULL;
            }
            else
            {
                goto SuccessOut;
            }
        }
    }

    if ( LogonSessionsLocked )
    {
        KerbUnlockLogonSessions(CallerLogonSession);
        LogonSessionsLocked = FALSE;
    }


    //
    // Get a krbtgt/S4URealm ticket
    //

    D_DebugLog((DEB_TRACE_S4U, "KerbGetS4UServiceTicket calling KerbGetTgtToS4URealm ClientRealm %wZ\n", S4UClientRealm));

    Status = KerbGetTgtToS4URealm(
                    CallerLogonSession,
                    Credential,
                    S4UClientRealm,
                    &TicketGrantingTicket,
                    0,          // tbd:  support for these options?
                    0,
                    EncryptionType
                    );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "KerbGetS4UServiceTicket cannot get S4U Tgt - %x\n", Status));
        goto Cleanup;
    }

    //
    // Build the preauth for our TGS req
    //

    Status = KerbBuildS4UPreauth(
                &S4UPreAuth,
                S4UClientName,
                S4UClientRealm,
                AdditionalAuthData
                );

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR, "KerbBuildS4UPreauth failed - %x\n",Status));
        goto Cleanup;
    }

    //
    // Pack and sign the preauth based on the session key in the ticketgranting
    // ticket - we'll need to do this now, and for final TGS_REQ
    //
    Status = KerbSignAndPackS4UPreauthData(
                &S4UPaDataList,
                TicketGrantingTicket,
                &S4UPreAuth
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "FAILED to sign S4u preauth (%p) %x\n", TicketGrantingTicket, Status));
        DsysAssert(FALSE);
        goto Cleanup;
    }

    //
    // Copy out the client realm name which is used when obtaining the ticket
    //

    KerbReadLockLogonSessions(CallerLogonSession);
    LogonSessionsLocked = TRUE;

    Status = KerbDuplicateString(
                &ClientRealm,
                &PrimaryCredentials->DomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    DsysAssert( LogonSessionsLocked );
    KerbUnlockLogonSessions(CallerLogonSession);
    LogonSessionsLocked = FALSE;

ReferralRestart:

    //
    // This is our first S4U TGS_REQ.  We'll eventually transit back to our
    // realm. Note:  If we get back a referral, the KDC reply is a TGT to
    // another realm, so keep trying, but be sure to use that TGT.
    //

    if (RtlEqualUnicodeString(
                &ClientRealm,
                &TicketGrantingTicket->TargetDomainName,
                TRUE) &&
        (NULL == PrimaryCredentials->Passwords)) // user2user required
    {
        BOOLEAN CrossRealm = FALSE;


        //
        // below call requires ls lock be held...
        //
        KerbReadLockLogonSessions( CallerLogonSession );
        Status = KerbGetTgtForService(
                 CallerLogonSession,
                 Credential,
                 NULL,       // no credman cred
                 & PrimaryCredentials->DomainName, // supplied realm
                 &NoTargetName,
                 KERB_TICKET_CACHE_PRIMARY_TGT,
                 &pRealTicketGrantingTicket,
                 &CrossRealm
                 );

        KerbUnlockLogonSessions( CallerLogonSession );

        if (NT_SUCCESS(Status))
        {
            ASSERT(pRealTicketGrantingTicket);

            if (CrossRealm)
            {
                Status = STATUS_INTERNAL_ERROR;
                DebugLog((DEB_ERROR, "KerbGetS4UServiceTicket KLIN(%#x) got unexpected cross realm TGT\n", KLIN(FILENO, __LINE__)));
            }
            else
            {
                FakeTgtReply.version = KERBEROS_VERSION;
                FakeTgtReply.message_type = KRB_TGT_REP;

                FakeTgtReply.ticket = pRealTicketGrantingTicket->Ticket;
            }
        }

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "KerbGetS4UServiceTicket KLIN(%#x) failed to get tgt\n", KLIN(FILENO, __LINE__)));
            goto Cleanup;
        }
    }

    D_DebugLog((DEB_TRACE, "KerbGetS4UServiceTicket KLIN(%#x) calling KerbGetTgsTicket (ReferralRestart)\n", KLIN(FILENO, __LINE__)));

    Status = KerbGetTgsTicket(
                    &ClientRealm,
                    TicketGrantingTicket,
                    TargetName,
                    Flags,
                    TicketOptions,
                    EncryptionType,
                    NULL,
                    S4UPaDataList,
                    pRealTicketGrantingTicket ? &FakeTgtReply : NULL,
                    NULL,
                    &RequestBodyEndTime,
                    &KdcReply,
                    &KdcReplyBody,
                    &RetryFlags
                    );

    if (STATUS_USER2USER_REQUIRED == Status)
    {
        Status = STATUS_SUCCESS;

        if (!pRealTicketGrantingTicket)
        {
            BOOLEAN CrossRealm = FALSE;

            KerbReadLockLogonSessions( CallerLogonSession );
            Status = KerbGetTgtForService(
                        CallerLogonSession,
                        Credential,
                        NULL,       // no credman cred
                        & PrimaryCredentials->DomainName, // supplied realm
                        &NoTargetName,
                        KERB_TICKET_CACHE_PRIMARY_TGT,
                        &pRealTicketGrantingTicket,
                        &CrossRealm
                        );

            KerbUnlockLogonSessions( CallerLogonSession );


            if (NT_SUCCESS(Status) )
            {
                ASSERT(pRealTicketGrantingTicket);

                if (!CrossRealm)
                {
                    FakeTgtReply.version = KERBEROS_VERSION;
                    FakeTgtReply.message_type = KRB_TGT_REP;

                    FakeTgtReply.ticket = pRealTicketGrantingTicket->Ticket;
                }
                else
                {
                    Status = STATUS_INTERNAL_ERROR;
                    DebugLog((DEB_ERROR, "KerbGetS4UServiceTicket KLIN(%#x) got unexpected cross realm TGT\n", KLIN(FILENO, __LINE__)));
                }
            }

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "KerbGetS4UServiceTicket KLIN(%#x) failed to get tgt\n", KLIN(FILENO, __LINE__)));
                goto Cleanup;
            }
        }

        if (NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_TRACE_U2U, "KerbGetS4UServiceTicket KLIN(%#x) calling KerbGetTgsTicket\n", KLIN(FILENO, __LINE__)));

            Status = KerbGetTgsTicket(
                        &ClientRealm,
                        TicketGrantingTicket,
                        TargetName,
                        FALSE,
                        TicketOptions,
                        EncryptionType,
                        NULL,
                        S4UPaDataList,
                        &FakeTgtReply,
                        NULL,
                        &RequestBodyEndTime,
                        &KdcReply,
                        &KdcReplyBody,
                        &RetryFlags
                        );
        }

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "KerbGetS4UServiceTicket failed to get TGS ticket for service vis u2u 0x%x\n", Status));
            goto Cleanup;
        }
    }

    if (NT_SUCCESS(Status) && pRealTicketGrantingTicket)
    {
        KerbReadLockTicketCache();
        KerbDuplicateKey(&U2UServerSKey, &(pRealTicketGrantingTicket->SessionKey));
        S4UEvidenceTicketCacheFlags |= KERB_TICKET_CACHE_TKT_ENC_IN_SKEY;
        KerbUnlockTicketCache();
    }

    //
    // We're done w/ S4UTgt.  Deref, and check
    // for errors
    //

    if (TicketGrantingTicket != NULL)
    {
        //
        // Check for bad option TGT purging
        //

        if (((RetryFlags & KERB_RETRY_WITH_NEW_TGT) != 0) && !TgtRetryMade)
        {
            DebugLog((DEB_WARN, "Doing TGT retry - %p\n", TicketGrantingTicket));

            //
            // Unlink && purge bad tgt
            //

            KerbRemoveTicketCacheEntry(TicketGrantingTicket);
            KerbDereferenceTicketCacheEntry(TicketGrantingTicket); // free from list
            TgtRetryMade = TRUE;
            TicketGrantingTicket = NULL;
            goto TGTRetry;
        }

        KerbDereferenceTicketCacheEntry(TicketGrantingTicket);
        TicketGrantingTicket = NULL;
    }

    if (!NT_SUCCESS(Status))
    {
        //
        // Check for the MIT retry case
        // TBD:  Clean this "code" up...
        //

        if (((RetryFlags & KERB_MIT_NO_CANONICALIZE_RETRY) != 0)
            && (!fMITRetryAlreadyMade))
        {
            Status = KerbMITGetMachineDomain(
                            TargetName,
                            S4UClientRealm,
                            &TicketGrantingTicket
                            );

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"Failed Query policy information %ws, line %d\n", THIS_FILE, __LINE__));
                goto Cleanup;
            }

            fMITRetryAlreadyMade = TRUE;

            goto TGTRetry;
        }

        DebugLog((DEB_WARN, "Failed to get TGS ticket for service 0x%x : \n", Status));
        KerbPrintKdcName(DEB_WARN, TargetName);
        DebugLog((DEB_WARN, "%ws, line %d\n", THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Check for referral info in the name
    // Should be there if S4Urealm != Our Realm

    Status = KerbGetReferralNames(
                KdcReplyBody,
                TargetName,
                &RealTargetRealm
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If this is not a referral ticket, just cache it and return
    // the cache entry.
    //

    if (RealTargetRealm.Length == 0)
    {
        //
        // Now we have a ticket - lets cache it
        //

        KerbWriteLockLogonSessions(CallerLogonSession);

        Status = KerbCacheS4UTicket(
                        CallerLogonSession,
                        KdcReply,
                        KdcReplyBody,
                        TargetName,
                        S4UClientName,
                        AltS4UClientName,
                        S4UClientRealm,
                        S4UEvidenceTicketCacheFlags,
                        CacheTicket ? &PrimaryCredentials->S4UTicketCache : NULL,
                        &TicketCacheEntry
                        );

        KerbUnlockLogonSessions(CallerLogonSession);

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // We're done, so get out of here.
        //

        goto SuccessOut;
    }

    //
    // The server referred us to another domain. Get the service's full
    // name from the ticket and try to find a TGT in that domain.
    //

    Status = KerbDuplicateKdcName(
                    &RealTargetName,
                    TargetName
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE_CTXT, "KerbGetS4UServiceTicket got referral ticket for service "));
    D_KerbPrintKdcName((DEB_TRACE_CTXT, TargetName));
    D_DebugLog((DEB_TRACE_CTXT, "in realm %wZ ", &RealTargetRealm));


    //
    // Turn the KDC reply (xrealm tgt w/ s4u pac) into something we can use,
    // but *don't* cache it.
    //

    Status = KerbCreateTicketCacheEntry(
                    KdcReply,
                    KdcReplyBody,
                    NULL,                               // no target name
                    NULL,
                    0,                                  // no flags
                    NULL,                               // don't cache
                    NULL,                               // no credential key
                    &TicketCacheEntry
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    TicketGrantingTicket = TicketCacheEntry;
    TicketCacheEntry = NULL;

    //
    // cleanup
    //

    KerbFreeTgsReply(KdcReply);
    KerbFreeKdcReplyBody(KdcReplyBody);
    KdcReply = NULL;
    KdcReplyBody = NULL;

    //
    // Now we are in a case where we have a realm to aim for and a TGT. While
    // we don't have a TGT for the target realm, get one.
    //

    if (!KERB_SUCCESS(KerbBuildFullServiceKdcName(
                &RealTargetRealm,
                &KerbGlobalKdcServiceName,
                KRB_NT_SRV_INST,
                &TargetTgtKdcName
                )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Referral chasing code block - very important to get right
    // If we know the "real" target realm, eg. from GC, then
    // we'll walk trusts until we hit "real" target realm.
    //
    while (!RtlEqualUnicodeString(
                &RealTargetRealm,
                &TicketGrantingTicket->TargetDomainName,
                TRUE))
    {
        //
        // If we just got two TGTs for the same domain, then we must have
        // gotten as far as we can. Chances our our RealTargetRealm is a
        // variation of what the KDC hands out.
        //
        D_DebugLog((DEB_TRACE_CTXT, "RealTargetRealm %wZ\n", &RealTargetRealm));
        D_DebugLog((DEB_TRACE_CTXT, "TGT %wZ\n",  &TicketGrantingTicket->TargetDomainName));

        if ((LastTgt != NULL) &&
             RtlEqualUnicodeString(
                &LastTgt->TargetDomainName,
                &TicketGrantingTicket->TargetDomainName,
                TRUE ))
        {
            KerbSetTicketCacheEntryTarget(
                &RealTargetRealm,
                LastTgt
                );

            D_DebugLog((DEB_TRACE_CTXT, "Got two TGTs for same realm (%wZ), S4U\n",
                &LastTgt->TargetDomainName));
            break;
        }

        D_DebugLog((DEB_TRACE_CTXT, "KerbGetS4UServiceTicket getting referral TGT for TargetTgtKdcName "));
        D_KerbPrintKdcName((DEB_TRACE_CTXT, TargetTgtKdcName));

        //
        // Cleanup old state
        //

        KerbFreeTgsReply(KdcReply);
        KerbFreeKdcReplyBody(KdcReplyBody);
        KdcReply = NULL;
        KdcReplyBody = NULL;

        Status = KerbGetTgsTicket(
                    &ClientRealm,
                    TicketGrantingTicket,
                    TargetTgtKdcName,
                    FALSE,
                    TicketOptions,
                    EncryptionType,
                    NULL,
                    NULL,
                    NULL,                       // no tgt reply since target is krbtgt
                    NULL,
                    &RequestBodyEndTime,
                    &KdcReply,
                    &KdcReplyBody,
                    &RetryFlags
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN, "KerbGetTgsTicket failed to get TGS ticket for service 0x%x :", Status));
            KerbPrintKdcName(DEB_WARN, TargetTgtKdcName);
            DebugLog((DEB_WARN, "%ws, line %d\n", THIS_FILE, __LINE__));

            //
            // We want to map cross-domain failures to failures indicating
            // that a KDC could not be found. This means that for Kerberos
            // logons, the negotiate code will retry with a different package
            //

            // if (Status == STATUS_NO_TRUST_SAM_ACCOUNT)
            // {
            //     Status = STATUS_NO_LOGON_SERVERS;
            // }
            goto Cleanup;
        }

        //
        // Now we have a ticket - don't cache it, however, as it has the
        // user's PAC, and shouldn't be re-used later.
        //

        Status = KerbCreateTicketCacheEntry(
                    KdcReply,
                    KdcReplyBody,
                    NULL,
                    NULL,
                    0,                                  // no flags
                    NULL,
                    NULL,                               // no credential key
                    &TicketCacheEntry
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if (LastTgt != NULL)
        {
            KerbDereferenceTicketCacheEntry(LastTgt);
            LastTgt = NULL;
        }
        LastTgt = TicketGrantingTicket;
        TicketGrantingTicket = TicketCacheEntry;
        TicketCacheEntry = NULL;
    }     // ** WHILE **

    //
    // Now we must have a TGT to our service's domain. Get a ticket
    // to the service.
    //

    //
    // Cleanup old state
    //

    KerbFreeTgsReply(KdcReply);
    KerbFreeKdcReplyBody(KdcReplyBody);
    KerbFreePreAuthData(S4UPaDataList);
    KdcReply = NULL;
    KdcReplyBody = NULL;
    S4UPaDataList = NULL;

    //
    // Pack and sign the preauth based on the session key in the ticketgranting
    // ticket
    //

    Status = KerbSignAndPackS4UPreauthData(
                &S4UPaDataList,
                TicketGrantingTicket,
                &S4UPreAuth
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Error signing S4u preauth (%p) %x\n", TicketGrantingTicket, Status));
        DsysAssert(FALSE);
        goto Cleanup;
    }

    if (NULL != PrimaryCredentials->Passwords)   // no user2user
    {
        D_DebugLog((DEB_TRACE, "KerbGetS4UServiceTicket xForest final calling KerbGetTgsTicket\n"));

        Status = KerbGetTgsTicket(
                    &ClientRealm,
                    TicketGrantingTicket,
                    TargetName,
                    FALSE,
                    TicketOptions,
                    EncryptionType,
                    NULL,
                    S4UPaDataList,
                    NULL,
                    NULL,
                    &RequestBodyEndTime,
                    &KdcReply,
                    &KdcReplyBody,
                    &RetryFlags
                    );
    }

    if ((NULL == PrimaryCredentials->Passwords) || (STATUS_USER2USER_REQUIRED == Status))
    {
        BOOLEAN CrossRealm = FALSE;

        if (!pRealTicketGrantingTicket)
        {

            KerbReadLockLogonSessions( CallerLogonSession );
            Status = KerbGetTgtForService(
                        CallerLogonSession,
                        Credential,
                        NULL,       // no credman cred
                        & PrimaryCredentials->DomainName, // supplied realm
                        &NoTargetName,
                        KERB_TICKET_CACHE_PRIMARY_TGT,
                        &pRealTicketGrantingTicket,
                        &CrossRealm
                        );

            KerbUnlockLogonSessions( CallerLogonSession );

            if (NT_SUCCESS(Status))
            {
                ASSERT(pRealTicketGrantingTicket);

                if (CrossRealm)
                {
                    Status = STATUS_INTERNAL_ERROR;
                    DebugLog((DEB_ERROR, "KerbGetS4UServiceTicket got unexpected cross realm TGT\n"));
                }
                else
                {
                    FakeTgtReply.version = KERBEROS_VERSION;
                    FakeTgtReply.message_type = KRB_TGT_REP;

                    FakeTgtReply.ticket = pRealTicketGrantingTicket->Ticket;
                }
            }
        }

        if (NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_TRACE_U2U, "KerbGetS4UServiceTicket xForest final u2u calling KerbGetTgsTicket\n"));

            Status = KerbGetTgsTicket(
                        &ClientRealm,
                        TicketGrantingTicket,
                        TargetName,
                        FALSE,
                        TicketOptions,
                        EncryptionType,
                        NULL,
                        S4UPaDataList,
                        &FakeTgtReply,
                        NULL,
                        &RequestBodyEndTime,
                        &KdcReply,
                        &KdcReplyBody,
                        &RetryFlags
                        );
        }

        if (NT_SUCCESS(Status))
        {
            ASSERT((S4UEvidenceTicketCacheFlags & KERB_TICKET_CACHE_TKT_ENC_IN_SKEY) == 0);

            KerbReadLockTicketCache();
            KerbDuplicateKey(&U2UServerSKey, &(pRealTicketGrantingTicket->SessionKey));
            S4UEvidenceTicketCacheFlags |= KERB_TICKET_CACHE_TKT_ENC_IN_SKEY;
            KerbUnlockTicketCache();
        }

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "KerbGetS4UServiceTicket failed to get TGS ticket for service vis u2u 0x%x\n", Status));
            goto Cleanup;
        }
    }
    else if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN,"Failed to get TGS ticket for service 0x%x ",
            Status ));
        KerbPrintKdcName(DEB_WARN, RealTargetName);
        DebugLog((DEB_WARN, "%ws, line %d\n", THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Now that we are in the domain to which we were referred, check for referral
    // info in the name
    //

    KerbFreeString(&RealTargetRealm);
    Status = KerbGetReferralNames(
                KdcReplyBody,
                RealTargetName,
                &RealTargetRealm
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // If this is not a referral ticket, just cache it and return
    // the cache entry.
    //

    if (RealTargetRealm.Length != 0)
    {
        //
        // To prevent loops, we limit the number of referral we'll take
        //

        if (ReferralCount > KerbGlobalMaxReferralCount)
        {
            DebugLog((DEB_ERROR, "KerbGetS4UServiceTicket Maximum referral count exceeded for name: "));
            KerbPrintKdcName(DEB_ERROR, RealTargetName);
            Status = STATUS_MAX_REFERRALS_EXCEEDED;
            goto Cleanup;
        }

        ReferralCount++;

        //
        // Don't cache the interdomain TGT, as it has PAC info in it.
        //

        Status = KerbCreateTicketCacheEntry(
                    KdcReply,
                    KdcReplyBody,
                    NULL,                       // no target name
                    NULL,                       // no target realm
                    0,                          // no flags
                    NULL,                       // don't cache
                    NULL,                       // no credential key
                    &TicketCacheEntry
                    );
        //
        // Cleanup old state
        //

        KerbFreeTgsReply(KdcReply);
        KerbFreeKdcReplyBody(KdcReplyBody);
        KerbFreePreAuthData(S4UPaDataList);
        KdcReply = NULL;
        KdcReplyBody = NULL;
        S4UPaDataList = NULL;

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }



        if (LastTgt != NULL)
        {
            KerbDereferenceTicketCacheEntry(LastTgt);
            LastTgt = NULL;
        }

        LastTgt = TicketGrantingTicket;
        TicketGrantingTicket = TicketCacheEntry;
        TicketCacheEntry = NULL;

        D_DebugLog((DEB_TRACE_CTXT, "KerbGetS4UServiceTicket restart referral: %wZ", &RealTargetRealm));

        Status = KerbSignAndPackS4UPreauthData(
                        &S4UPaDataList,
                        TicketGrantingTicket,
                        &S4UPreAuth
                        );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "Error signing S4u preauth (%p) %x\n", TicketGrantingTicket, Status));
            DsysAssert(FALSE);
            goto Cleanup;
        }

        goto ReferralRestart;
    }

    //
    // Now we have a ticket - lets cache it
    //

    //
    // Before doing anything, verify that the client name on the ticket
    // is equal to the client name requested during the S4u
    //

    KerbWriteLockLogonSessions(CallerLogonSession);

    Status = KerbCacheS4UTicket(
                    CallerLogonSession,
                    KdcReply,
                    KdcReplyBody,
                    TargetName,
                    S4UClientName,
                    AltS4UClientName,
                    S4UClientRealm,
                    S4UEvidenceTicketCacheFlags,
                    CacheTicket ? &PrimaryCredentials->S4UTicketCache : NULL,
                    &TicketCacheEntry
                    );

    KerbUnlockLogonSessions(CallerLogonSession);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

SuccessOut:

    if (TicketCacheEntry && (S4UEvidenceTicketCacheFlags & KERB_TICKET_CACHE_TKT_ENC_IN_SKEY))
    {
        KerbWriteLockTicketCache();

        ASSERT(TicketCacheEntry->CacheFlags & KERB_TICKET_CACHE_TKT_ENC_IN_SKEY);

        KerbFreeKey(&(TicketCacheEntry->SessionKey));
        DebugLog((DEB_TRACE_U2U, "KerbGetS4UServiceTicket returning u2u SKEY\n"));

        KerbDuplicateKey(&TicketCacheEntry->SessionKey, &U2UServerSKey);

        KerbUnlockTicketCache();
    }

    *S4UTicket = TicketCacheEntry;
    TicketCacheEntry = NULL;

Cleanup:

    KerbFreeTgsReply( KdcReply );
    KerbFreeKdcReplyBody( KdcReplyBody );
    KerbFreeKdcName( &TargetTgtKdcName );
    KerbFreeString( &RealTargetRealm );
    KerbFreeKdcName(&RealTargetName);
    KerbFreeKdcName(&TargetName);
    KerbFreePrincipalName(&S4UPreAuth.userName);
    KerbFreeRealm(&S4UPreAuth.userRealm);
    KerbFreePreAuthData(S4UPaDataList);

    if (pRealTicketGrantingTicket)
    {
        KerbDereferenceTicketCacheEntry(pRealTicketGrantingTicket);
    }

    if (LogonSessionsLocked)
    {
        KerbUnlockLogonSessions(CallerLogonSession);
    }

    KerbFreeString(&RealTargetRealm);

    //
    // We never cache TGTs in this routine
    // so it's just a blob of memory
    //

    if (TicketGrantingTicket != NULL)
    {
        KerbDereferenceTicketCacheEntry(TicketGrantingTicket);
    }
    if (LastTgt != NULL)
    {
        KerbDereferenceTicketCacheEntry(LastTgt);
    }

    //
    // If we still have a pointer to the ticket cache entry, free it now.
    //

    if (TicketCacheEntry != NULL)
    {
        KerbRemoveTicketCacheEntry( TicketCacheEntry );
        KerbDereferenceTicketCacheEntry(TicketCacheEntry);
    }

    KerbFreeString(&ClientRealm);
    KerbFreeKey(&U2UServerSKey);

    return (Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbPrepareEvidenceTicket
//
//  Synopsis:   Decrypts a ticket w/ key1, and encrypts it w/ key2
//
//  Effects:
//
//  Arguments:  DecryptKey - key used to decrypt ticket
//              EncryptionKey - key used to re-encrypt ticket
//              Ticket - the ticket to decrypt / re-encrypt
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbPrepareEvidenceTicket(
    IN PKERB_ENCRYPTION_KEY DecryptKey,
    IN PKERB_ENCRYPTION_KEY EncryptionKey,
    IN OUT PKERB_TICKET Ticket
    )
{
    KERBERR KerbErr;
    NTSTATUS Status = STATUS_LOGON_FAILURE;
    PUCHAR EncryptedPart = NULL;
    ULONG EncryptSize;


    SafeAllocaAllocate( EncryptedPart, Ticket->encrypted_part.cipher_text.length );
    if (EncryptedPart == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    EncryptSize = Ticket->encrypted_part.cipher_text.length;
    KerbErr = KerbDecryptDataEx(
                &Ticket->encrypted_part,
                DecryptKey,
                KERB_TICKET_SALT,
                &EncryptSize,
                EncryptedPart
                );

    if (!KERB_SUCCESS( KerbErr ))
    {
        goto Cleanup;
    }


    //
    // Free up the old encrypted_part.
    //
    if ( Ticket->encrypted_part.cipher_text.value != NULL )
    {
        MIDL_user_free( Ticket->encrypted_part.cipher_text.value );
        Ticket->encrypted_part.cipher_text.value = NULL;
        Ticket->encrypted_part.cipher_text.length = 0;
    }

    //
    // allocate sufficient space for the encrypted data.
    //
    KerbErr = KerbAllocateEncryptionBufferWrapper(
                    EncryptionKey->keytype,
                    EncryptSize,
                    &Ticket->encrypted_part.cipher_text.length,
                    &Ticket->encrypted_part.cipher_text.value
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }


    KerbErr = KerbEncryptDataEx(
                    &Ticket->encrypted_part,
                    EncryptSize,
                    EncryptedPart,
                    KERB_NO_KEY_VERSION,
                    KERB_TICKET_SALT,
                    EncryptionKey
                    );


    if (!KERB_SUCCESS( KerbErr ))
    {
        goto Cleanup;
    }

    Status = STATUS_SUCCESS;

Cleanup:

    if ( !KERB_SUCCESS(KerbErr) &&
       ( Ticket->encrypted_part.cipher_text.value != NULL) )
    {
        MIDL_user_free( Ticket->encrypted_part.cipher_text.value );
        Ticket->encrypted_part.cipher_text.value = NULL;
        Ticket->encrypted_part.cipher_text.length = 0;
    }

    SafeAllocaFree( EncryptedPart );
    return Status;

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetTicketByS4UProxy
//
//  Synopsis:   Gets a ticket to a service and handles cross-domain referrals
//
//  Effects:
//
//  Arguments:  LogonSession - the logon session to use for ticket caching
//                      and the identity of the caller.
//              TargetName - Name of the target for which to obtain a ticket.
//              TargetDomainName - Domain name of target
//              Flags - Flags about the request
//              TicketOptions - KDC options flags
//              EncryptionType - optional Requested encryption type
//              ErrorMessage - Error message from an AP request containing hints
//                      for next ticket.
//              AuthorizationData - Optional authorization data to stick
//                      in the ticket.
//              TgtReply - TGT to use for getting a ticket with enc_tkt_in_skey
//              TicketCacheEntry - Receives a referenced ticket cache entry.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetServiceTicketByS4UProxy(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_LOGON_SESSION CallerLogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN PKERB_TICKET_CACHE_ENTRY EvidenceTicketCacheEntry,
    IN PKERB_INTERNAL_NAME TargetName,
    IN PUNICODE_STRING TargetDomainName,
    IN OPTIONAL PKERB_SPN_CACHE_ENTRY SpnCacheEntry,
    IN ULONG Flags,
    IN OPTIONAL ULONG TicketOptions,
    IN OPTIONAL ULONG EncryptionType,
    IN OPTIONAL PKERB_ERROR ErrorMessage,
    IN OPTIONAL PKERB_AUTHORIZATION_DATA AuthorizationData,
    IN OPTIONAL PKERB_TGT_REPLY TgtReply,
    OUT PKERB_TICKET_CACHE_ENTRY * NewCacheEntry,
    OUT LPGUID pLogonGuid OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_TICKET_CACHE_ENTRY TicketCacheEntry = NULL;
    PKERB_TICKET_CACHE_ENTRY TicketGrantingTicket = NULL;
    PKERB_TICKET_CACHE_ENTRY PrimaryTgt = NULL;
    PKERB_TICKET_CACHE_ENTRY LastTgt = NULL;
    PKERB_KDC_REPLY KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY KdcReplyBody = NULL;
    KERB_TICKET EvidenceTicket = {0};
    PKERB_ENCRYPTION_KEY DecryptKey = NULL;
    BOOLEAN LogonSessionsLocked = FALSE;
    BOOLEAN TicketCacheLocked = FALSE;
    PKERB_INTERNAL_NAME RealTargetName = NULL;
    UNICODE_STRING RealTargetRealm = NULL_UNICODE_STRING;
    UNICODE_STRING SpnTargetRealm = NULL_UNICODE_STRING;
    PKERB_INTERNAL_NAME TargetTgtKdcName = NULL;
    PKERB_PRIMARY_CREDENTIAL ProxyServerCreds = NULL;
    PKERB_PRIMARY_CREDENTIAL PrimaryCreds = NULL;
    UNICODE_STRING ClientRealm = NULL_UNICODE_STRING;
    BOOLEAN CacheTicket = TRUE;
    ULONG ReferralCount = 0;
    ULONG RetryFlags = 0;
    ULONG S4UFlags = S4UCACHE_S4U_AVAILABLE;
    BOOLEAN CacheBasedFailure = FALSE, Update = FALSE;
    TimeStamp RequestBodyEndTime;

    GetSystemTimeAsFileTime((PFILETIME) &RequestBodyEndTime);
    RequestBodyEndTime.QuadPart += KerbGetTime(KerbGlobalS4UTicketLifetime);



    //
    // Get our credentials - TBD: Fester: Supplied creds irrelevant?
    //

    DsysAssert( !LogonSessionsLocked );
    KerbReadLockLogonSessions( LogonSession );
    PrimaryCreds = &LogonSession->PrimaryCredentials;
    LogonSessionsLocked = TRUE;

    ProxyServerCreds = &CallerLogonSession->PrimaryCredentials;

    //
    // Make sure the name is not zero length
    //

    if ((TargetName->NameCount == 0) ||
        (TargetName->Names[0].Length == 0))
    {
        D_DebugLog((DEB_ERROR,"Kdc GetServiceTicket: trying to crack zero length name.\n"));
        Status = SEC_E_TARGET_UNKNOWN;
        goto Cleanup;
    }

    
    //
    // First check the ticket cache for this logon session. We don't look
    // for the target principal name because we can't be assured that this
    // is a valid principal name for the target. If we are doing user-to-
    // user, don't use the cache because the tgt key may have changed
    //


    if ((TgtReply == NULL) && ((Flags & KERB_GET_TICKET_NO_CACHE) == 0))
    {
        TicketCacheEntry = KerbLocateTicketCacheEntry(
                                &PrimaryCreds->ServerTicketCache,
                                TargetName,
                                TargetDomainName
                                );
    }
    else
    {
        //
        // We don't want to cache user-to-user tickets
        //

        CacheTicket = FALSE;
    }

    if (TicketCacheEntry != NULL)
    {
        //
        // If we were given an error message that indicated a bad password
        // throw away the cached ticket
        //

        if (ARGUMENT_PRESENT(ErrorMessage) && ((KERBERR) ErrorMessage->error_code == KRB_AP_ERR_MODIFIED))
        {
            KerbRemoveTicketCacheEntry(TicketCacheEntry);
            KerbDereferenceTicketCacheEntry(TicketCacheEntry);
            TicketCacheEntry = NULL;
        }
        else
        {
            ULONG TicketFlags;
            ULONG CacheTicketFlags;
            ULONG CacheEncryptionType;

            //
            // Check if the flags are present
            //

            KerbReadLockTicketCache();
            CacheTicketFlags = TicketCacheEntry->TicketFlags;
            CacheEncryptionType = TicketCacheEntry->Ticket.encrypted_part.encryption_type;
            KerbUnlockTicketCache();

            TicketFlags = KerbConvertKdcOptionsToTicketFlags(TicketOptions);

            if (((CacheTicketFlags & TicketFlags) != TicketFlags) ||
                ((EncryptionType != 0) && (CacheEncryptionType != EncryptionType)))

            {
                KerbDereferenceTicketCacheEntry(TicketCacheEntry);
                TicketCacheEntry = NULL;
            }
            else
            {
                //
                // Check the ticket time
                //

                if (KerbTicketIsExpiring(TicketCacheEntry, TRUE))
                {
                    KerbDereferenceTicketCacheEntry(TicketCacheEntry);
                    TicketCacheEntry = NULL;
                }
                else
                {
                    *NewCacheEntry = TicketCacheEntry;
                    D_DebugLog((DEB_TRACE_S4U,"Found S4U ticket cache entry %x\n", TicketCacheEntry));
                    D_KerbPrintKdcName((DEB_TRACE_S4U, TicketCacheEntry->TargetName));
                    D_DebugLog((DEB_TRACE_S4U,"Realm - %wZ\n", &TicketCacheEntry->DomainName));
                    TicketCacheEntry = NULL;
                    goto Cleanup;
                }
            }
        }
    }

    
    //
    // Determine the state of the SPNCache using information in the credential.
    // Only do this if we've not been handed 
    //
    if ( ARGUMENT_PRESENT(SpnCacheEntry) && TargetDomainName->Buffer == NULL )
    {      
        Status = KerbGetSpnCacheStatus(
                    SpnCacheEntry,
                    ProxyServerCreds,
                    &SpnTargetRealm
                    );


        if (NT_SUCCESS( Status ))
        {
            KerbFreeString(&RealTargetRealm);                       
            RealTargetRealm = SpnTargetRealm;                      
            RtlZeroMemory(&SpnTargetRealm, sizeof(UNICODE_STRING));
    
            D_DebugLog((DEB_TRACE_SPN_CACHE, "Found SPN cache entry - %wZ\n", &RealTargetRealm));
            D_KerbPrintKdcName((DEB_TRACE_SPN_CACHE, TargetName));
        }
        else if ( Status != STATUS_NO_MATCH )
        {
            D_DebugLog((DEB_TRACE_SPN_CACHE, "KerbGetSpnCacheStatus failed %x\n", Status));
            D_DebugLog((DEB_TRACE_SPN_CACHE,  "TargetName: \n"));
            D_KerbPrintKdcName((DEB_TRACE_SPN_CACHE, TargetName));

            CacheBasedFailure = TRUE;
            goto Cleanup;
        }

        Status = STATUS_SUCCESS;
    }        


    //
    // If the caller wanted any special options, don't cache this ticket.
    //

    if ((TicketOptions != 0) || (EncryptionType != 0) || ((Flags & KERB_GET_TICKET_NO_CACHE) != 0))
    {
        CacheTicket = FALSE;
    }

    DsysAssert( LogonSessionsLocked );
    KerbUnlockLogonSessions(LogonSession);
    LogonSessionsLocked = FALSE;

    //
    // No cached entry was found so go ahead and call the KDC to
    // get the ticket.
    //

    //
    // First call always starts w/ TGT to our domain.  This allows us to
    // determine if we've met the requirements of the S4U logon, e.g. is the
    // target name appropriate?
    //

    KerbReadLockLogonSessions( CallerLogonSession );

    

    PrimaryTgt = KerbLocateTicketCacheEntryByRealm(
                    &ProxyServerCreds->AuthenticationTicketCache,
                    NULL,
                    KERB_TICKET_CACHE_PRIMARY_TGT
                    );

    KerbUnlockLogonSessions( CallerLogonSession );

    if ( NULL == PrimaryTgt )
    {
        Status = KerbGetTicketGrantingTicket(
                        CallerLogonSession,
                        NULL,
                        NULL,
                        NULL,
                        &PrimaryTgt,
                        NULL            // don't return credential key
                        );

        if (!NT_SUCCESS( Status ))
        {
            D_DebugLog((DEB_ERROR, "Failed to get primary TGT from logon session\n"));
            goto Cleanup;
        }
    }

    //
    // Copy out the client realm name which is used when obtaining the ticket
    //

    Status = KerbDuplicateString(
                &ClientRealm,
                &ProxyServerCreds->DomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Prepare the evidence ticket.
    //

    if (!KERB_SUCCESS( KerbDuplicateTicket(
                            &EvidenceTicket,
                            &EvidenceTicketCacheEntry->Ticket
                            )))
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Now its's time to make the request.
    //

    D_DebugLog((DEB_TRACE_S4U, "KerbGetServiceTicketByS4UProxy EvidenceTicketCacheEntry %p\n", EvidenceTicketCacheEntry));

    Status = KerbGetTgsTicket(
                    &ClientRealm,
                    PrimaryTgt,
                    TargetName,
                    Flags,
                    TicketOptions,
                    EncryptionType,
                    NULL,
                    NULL,                           // no pa data
                    TgtReply,                       // This is for the service directly, so use TGT
                    &EvidenceTicket,
                    &RequestBodyEndTime,
                    &KdcReply,
                    &KdcReplyBody,
                    &RetryFlags
                    );

    if (!NT_SUCCESS( Status ))
    {
        DebugLog((DEB_WARN, "Failed S4Uproxy request %x(%x) \n", Status, RetryFlags));
        goto Cleanup;
    }

    //
    // Check for referral info in the name
    //

    Status = KerbGetReferralNames(
                KdcReplyBody,
                TargetName,
                &RealTargetRealm
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If this is not a referral ticket, just cache it and return
    // the cache entry.
    //

    if ( RealTargetRealm.Length == 0 )
    {
        //
        // Now we have a ticket - lets cache it
        //

        KerbReadLockLogonSessions(LogonSession);

        Status = KerbCreateTicketCacheEntry(
                    KdcReply,
                    KdcReplyBody,
                    TargetName,
                    TargetDomainName,
                    0,
                    CacheTicket ? &PrimaryCreds->ServerTicketCache : NULL,
                    NULL,                               // no credential key
                    &TicketCacheEntry
                    );

        KerbUnlockLogonSessions( LogonSession );

        if (!NT_SUCCESS( Status ))
        {
            goto Cleanup;
        }

        *NewCacheEntry = TicketCacheEntry;
        TicketCacheEntry = NULL;
        Update = TRUE;

        //
        // We're done, so get out of here.
        //

        goto Cleanup;
    }

    //
    // REFERRAL -   The service we're talking to does not live in the caller's
    //              account domain.
    //

    //
    //  Get the real target name
    //
    Status = KerbDuplicateKdcName(
                    &RealTargetName,
                    TargetName
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE_S4U, "Got referral ticket for service \n"));
    D_KerbPrintKdcName((DEB_TRACE_S4U,TargetName));
    D_DebugLog((DEB_TRACE_S4U, "in realm \n"));
    D_KerbPrintKdcName((DEB_TRACE_S4U,RealTargetName));

    //
    // Generate a ticket cache entry for the interdomain
    // TGT accompanying this KdcReply.
    //
    Status = KerbCreateTicketCacheEntry(
                    KdcReply,
                    KdcReplyBody,
                    NULL,                       // no target name
                    NULL,                       // no target realm
                    0,                          // no flags
                    NULL,                       // don't cache this one.
                    NULL,                       // don't copy cred key
                    &TicketCacheEntry
                    );

    if (!NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }

    //
    // We've got a new TGT from the referral.
    // Create a plaintext version of our evidence ticket, and
    // use the session key from the TGT to create an encrypted ticket.
    //
    KerbDereferenceTicketCacheEntry(PrimaryTgt);
    TicketGrantingTicket = TicketCacheEntry;
    TicketCacheEntry = NULL;


    KerbReadLockLogonSessions( CallerLogonSession );

    DecryptKey = KerbGetKeyFromList(
                    CallerLogonSession->PrimaryCredentials.Passwords,
                    TicketGrantingTicket->SessionKey.keytype
                    );

    KerbUnlockLogonSessions( CallerLogonSession );

    if ( DecryptKey == NULL )
    {
        DebugLog((DEB_ERROR, "Could not find a key to decrypt evidence ticket\n"));
        goto Cleanup;
    }

    Status = KerbPrepareEvidenceTicket(
                    DecryptKey,
                    &TicketGrantingTicket->SessionKey,
                    &EvidenceTicket
                    );

    if ( Status == STATUS_LOGON_FAILURE )
    {
        //
        // Old Key?
        //
        KerbReadLockLogonSessions( CallerLogonSession );

        if (CallerLogonSession->PrimaryCredentials.OldPasswords != NULL)
        {
            DecryptKey = KerbGetKeyFromList(
                            CallerLogonSession->PrimaryCredentials.OldPasswords,
                            TicketGrantingTicket->SessionKey.keytype
                            );

            if (DecryptKey != NULL )
            {
                Status = KerbPrepareEvidenceTicket(
                            DecryptKey,
                            &TicketGrantingTicket->SessionKey,
                            &EvidenceTicket
                            );
            }

        }

        KerbUnlockLogonSessions( CallerLogonSession );
    }

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR, "Failed to prepare evidence ticket\n"));
        goto Cleanup;
    }

    DecryptKey = &TicketGrantingTicket->SessionKey;

    //
    // Now we are in a case where we have a realm to aim for and a TGT. While
    // we don't have a TGT for the target realm, get one.
    //

ReferralRestart:

    if (!KERB_SUCCESS(KerbBuildFullServiceKdcName(
                &RealTargetRealm,
                &KerbGlobalKdcServiceName,
                KRB_NT_SRV_INST,
                &TargetTgtKdcName
                )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    DsysAssert(!TicketCacheLocked);
    KerbReadLockTicketCache();
    TicketCacheLocked = TRUE;

    //
    // Referral chasing code block - very important to get right
    // If we know the "real" target realm, eg. from GC, then
    // we'll walk trusts until we hit "real" target realm.
    //
    while (!RtlEqualUnicodeString(
                &RealTargetRealm,
                &TicketGrantingTicket->TargetDomainName,
                TRUE ))
    {

        //
        // If we just got two TGTs for the same domain, then we must have
        // gotten as far as we can. Chances our our RealTargetRealm is a
        // variation of what the KDC hands out.
        //

        if ((LastTgt != NULL) &&
             RtlEqualUnicodeString(
                &LastTgt->TargetDomainName,
                &TicketGrantingTicket->TargetDomainName,
                TRUE ))
        {

            KerbUnlockTicketCache();

            KerbSetTicketCacheEntryTarget(
                &RealTargetRealm,
                LastTgt
                );

            KerbReadLockTicketCache();
            TicketCacheLocked = TRUE;
            D_DebugLog((DEB_ERROR, "Got two TGTs for same realm (%wZ), bailing out of referral loop\n",
                &LastTgt->TargetDomainName));
            break;
        }

        D_DebugLog((DEB_TRACE_S4U, "Getting referral TGT for \n"));
        D_KerbPrintKdcName((DEB_TRACE_S4U, TargetTgtKdcName));
        D_KerbPrintKdcName((DEB_TRACE_S4U, TicketGrantingTicket->ServiceName));

        KerbUnlockTicketCache();
        TicketCacheLocked = FALSE;

        //
        // Cleanup old state
        //

        KerbFreeTgsReply(KdcReply);
        KerbFreeKdcReplyBody(KdcReplyBody);
        KdcReply = NULL;
        KdcReplyBody = NULL;


        Status = KerbGetTgsTicket(
                    &ClientRealm,
                    TicketGrantingTicket,
                    TargetTgtKdcName,
                    FALSE,
                    TicketOptions,
                    EncryptionType,
                    AuthorizationData,
                    NULL,                       // no pa data
                    NULL,                       // no tgt reply since target is krbtgt
                    &EvidenceTicket,
                    NULL,
                    &KdcReply,
                    &KdcReplyBody,
                    &RetryFlags
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN,"Failed to get TGS ticket for service 0x%x :",
                Status ));
            KerbPrintKdcName(DEB_WARN, TargetTgtKdcName );
            DebugLog((DEB_WARN, "%ws, line %d\n", THIS_FILE, __LINE__));

            goto Cleanup;
        }

        KerbReadLockLogonSessions(LogonSession);
        LogonSessionsLocked = TRUE;

        Status = KerbCreateTicketCacheEntry(
                    KdcReply,
                    KdcReplyBody,
                    NULL,                               // no target name
                    NULL,                               // no targe realm
                    0,                                  // no flags
                    NULL,                               // no cache
                    NULL,                               // no cred key
                    &TicketCacheEntry
                    );

        KerbUnlockLogonSessions(LogonSession);
        LogonSessionsLocked = FALSE;

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if (LastTgt != NULL)
        {
            KerbDereferenceTicketCacheEntry(LastTgt);
            LastTgt = NULL;
        }
        LastTgt = TicketGrantingTicket;
        TicketGrantingTicket = TicketCacheEntry;
        TicketCacheEntry = NULL;

        Status = KerbPrepareEvidenceTicket(
                    DecryptKey,
                    &TicketGrantingTicket->SessionKey,
                    &EvidenceTicket
                    );

        if (!NT_SUCCESS( Status ))
        {
            D_DebugLog((DEB_ERROR, "Failed to prepare evidence ticket\n"));
            goto Cleanup;
        }

        DecryptKey = &TicketGrantingTicket->SessionKey;

        KerbReadLockTicketCache();
        TicketCacheLocked = TRUE;
    }     // ** WHILE **

    DsysAssert(TicketCacheLocked);
    KerbUnlockTicketCache();
    TicketCacheLocked = FALSE;

    //
    // Now we must have a TGT to the destination domain. Get a ticket
    // to the service.
    //

    //
    // Cleanup old state
    //

    KerbFreeTgsReply(KdcReply);
    KerbFreeKdcReplyBody(KdcReplyBody);
    KdcReply = NULL;
    KdcReplyBody = NULL;
    RetryFlags = 0;

    Status = KerbGetTgsTicket(
                &ClientRealm,
                TicketGrantingTicket,
                RealTargetName,
                FALSE,
                TicketOptions,
                EncryptionType,
                AuthorizationData,
                NULL,                           // no pa data
                TgtReply,
                &EvidenceTicket,
                &RequestBodyEndTime,
                &KdcReply,
                &KdcReplyBody,
                &RetryFlags
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN,"Failed to get TGS S4U ticket for service 0x%x ",
            Status ));
        KerbPrintKdcName(DEB_WARN, RealTargetName);
        DebugLog((DEB_WARN, "%ws, line %d\n", THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Now that we are in the domain to which we were referred, check for referral
    // info in the name
    //

    KerbFreeString(&RealTargetRealm);
    Status = KerbGetReferralNames(
                KdcReplyBody,
                RealTargetName,
                &RealTargetRealm
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If this is not a referral ticket, just cache it and return
    // the cache entry.
    //
    if (RealTargetRealm.Length != 0)
    {
        //
        // To prevent loops, we limit the number of referral we'll take
        //


        if (ReferralCount > KerbGlobalMaxReferralCount)
        {
            D_DebugLog((DEB_ERROR,"Maximum referral count exceeded for name: "));
            D_KerbPrintKdcName((DEB_ERROR,RealTargetName));
            Status = STATUS_MAX_REFERRALS_EXCEEDED;
            goto Cleanup;
        }

        ReferralCount++;

        Status = KerbCreateTicketCacheEntry(
                    KdcReply,
                    KdcReplyBody,
                    NULL,                       // no target name
                    NULL,                       // no target realm
                    0,                          // no flags
                    NULL,                       // no cache
                    NULL,                       // no cred key
                    &TicketCacheEntry
                    );

        //
        // Cleanup old state
        //

        KerbFreeTgsReply(KdcReply);
        KerbFreeKdcReplyBody(KdcReplyBody);
        KdcReply = NULL;
        KdcReplyBody = NULL;

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if (LastTgt != NULL)
        {
            KerbDereferenceTicketCacheEntry(LastTgt);
            LastTgt = NULL;
        }

        LastTgt = TicketGrantingTicket;
        TicketGrantingTicket = TicketCacheEntry;
        TicketCacheEntry = NULL;

        Status = KerbPrepareEvidenceTicket(
                    DecryptKey,
                    &TicketGrantingTicket->SessionKey,
                    &EvidenceTicket
                    );

        if (!NT_SUCCESS( Status ))
        {
            DebugLog((DEB_ERROR, "Failed to prepare evidence ticket %x\n", Status));
            goto Cleanup;
        }

        DecryptKey = &TicketGrantingTicket->SessionKey;

        D_DebugLog((DEB_TRACE_S4U, "Restart referral:%wZ", &RealTargetRealm));
        goto ReferralRestart;
    }

    KerbReadLockLogonSessions(LogonSession);
    LogonSessionsLocked = TRUE;


    //
    //  We've got our S4U service ticket.  Cache it.
    //


    Status = KerbCreateTicketCacheEntry(
                KdcReply,
                KdcReplyBody,
                TargetName,
                TargetDomainName,
                0,                                      // no flags
                CacheTicket ? &PrimaryCreds->ServerTicketCache : NULL,
                NULL,                                   // no cred key
                &TicketCacheEntry
                );

    KerbUnlockLogonSessions(LogonSession);
    LogonSessionsLocked = FALSE;

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE_S4U, "Got the S4U ticket (%p)\n", TicketCacheEntry));

    *NewCacheEntry = TicketCacheEntry;
    TicketCacheEntry = NULL;
    Update = TRUE;

Cleanup:

    //
    // Bad or unlocatable SPN -- Don't update if we got the value from the cache, though.
    //
    if (( TargetName->NameType == KRB_NT_SRV_INST ) &&
        ( NT_SUCCESS(Status) || Status == STATUS_NO_TRUST_SAM_ACCOUNT ) &&
        ( !CacheBasedFailure ))
    {
        NTSTATUS Tmp;
        ULONG UpdateValue = KERB_SPN_UNKNOWN;
        PUNICODE_STRING Realm = NULL;

        if ( NT_SUCCESS( Status ))
        {
            Realm = &(*NewCacheEntry)->TargetDomainName;
            UpdateValue = KERB_SPN_KNOWN;
        } 
        
        Tmp = KerbUpdateSpnCacheEntry(
                    SpnCacheEntry,
                    TargetName,
                    ProxyServerCreds,
                    UpdateValue,
                    Realm
                    );    
        
    }

    //
    // Update the S4U cache
    //
    if (( RetryFlags & ( KERB_RETRY_DISABLE_S4U | KERB_RETRY_NO_S4UMATCH)) != 0)
    {
        S4UFlags = ((RetryFlags & KERB_RETRY_DISABLE_S4U) ? 
                        S4UCACHE_S4U_UNAVAILABLE : S4UCACHE_S4U_AVAILABLE );

        //
        // Allow downgrade to NTLM.
        //
        Status = SEC_E_NO_CREDENTIALS;
        Update = TRUE;
    }

    if ( Update )
    {
        KerbUpdateS4UCacheData(
            CallerLogonSession,
            S4UFlags
            ); 
    }

    KerbFreeTgsReply( KdcReply );
    KerbFreeKdcReplyBody( KdcReplyBody );
    KerbFreeKdcName( &TargetTgtKdcName );
    KerbFreeString( &RealTargetRealm );
    KerbFreeKdcName(&RealTargetName);
    KerbFreeString( &SpnTargetRealm);

    KerbFreeDuplicatedTicket( &EvidenceTicket );

    if (TicketCacheLocked)
    {
        KerbUnlockTicketCache();
    }

    if (LogonSessionsLocked)
    {
        KerbUnlockLogonSessions(LogonSession);
    }

    KerbFreeString(&RealTargetRealm);


    if (TicketGrantingTicket != NULL)
    {
        if (Status == STATUS_WRONG_PASSWORD)
        {
            KerbRemoveTicketCacheEntry(
                TicketGrantingTicket
                );
        }
        KerbDereferenceTicketCacheEntry(TicketGrantingTicket);
    }
    if (LastTgt != NULL)
    {
        KerbDereferenceTicketCacheEntry(LastTgt);
        LastTgt = NULL;
    }

    KerbFreeString(&ClientRealm);

    //
    // If we still have a pointer to the ticket cache entry, free it now.
    //

    if (TicketCacheEntry != NULL)
    {
        KerbRemoveTicketCacheEntry( TicketCacheEntry );
        KerbDereferenceTicketCacheEntry(TicketCacheEntry);
    }
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateS4ULogonSession
//
//  Synopsis:   Creates a logon session to accompany the S4ULogon.
//
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbCreateS4ULogonSession(
    IN PKERB_INTERNAL_NAME S4UClientName,
    IN PUNICODE_STRING S4UClientRealm,
    IN PLUID pLuid,
    IN OUT PKERB_LOGON_SESSION * LogonSession
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING S4UClient = {0};

    *LogonSession = NULL;

    if (!KERB_SUCCESS( KerbConvertKdcNameToString(
                            &S4UClient,
                            S4UClientName,
                            NULL
                            )) )
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = KerbCreateLogonSession(
                    pLuid,
                    &S4UClient,
                    S4UClientRealm,
                    NULL,
                    NULL,
                    0,
                    KERB_LOGON_S4U_SESSION,
                    FALSE,
                    LogonSession
                    );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "KerbCreateLogonSession failed %x %ws, line %d\n", Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

Cleanup:

    KerbFreeString(&S4UClient);
    return Status;

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbS4UToSelfLogon
//
//  Synopsis:   Attempt to gets TGT for an S4U client for name
//              location purposes.
//
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session of the service doing the
//                             S4U request
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbS4UToSelfLogon(
        IN PVOID ProtocolSubmitBuffer,
        IN PVOID ClientBufferBase,
        IN ULONG SubmitBufferSize,
        OUT PKERB_LOGON_SESSION * NewLogonSession,
        OUT PLUID LogonId,
        OUT PKERB_TICKET_CACHE_ENTRY * WorkstationTicket,
        OUT PKERB_INTERNAL_NAME * S4UClientName,
        OUT PUNICODE_STRING S4UClientRealm,
        OUT PLUID AlternateLuid
        )
{
    NTSTATUS Status;

    PKERB_S4U_LOGON          LogonInfo = NULL;
    PKERB_LOGON_SESSION      CallerLogonSession = NULL;
    PKERB_TICKET_CACHE_ENTRY Duplicate = NULL;
    SECPKG_CLIENT_INFO       ClientInfo;
    PKERB_INTERNAL_NAME      AltClientName = NULL;

    ULONG       Flags = KERB_CRACK_NAME_USE_WKSTA_REALM, ProcessFlags = 0;
    LUID        LocalService = LOCALSERVICE_LUID;
    LUID        CallerLuid = SYSTEM_LUID;
    LUID        NetworkService = NETWORKSERVICE_LUID;

    PKERB_TICKET_CACHE_ENTRY LocalTicket = NULL;

    UNICODE_STRING DummyRealm = {0};


    *NewLogonSession = NULL;
    *WorkstationTicket = NULL;
    *S4UClientName = NULL;

    RtlInitUnicodeString(
        S4UClientRealm,
        NULL
        );

    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to get client information: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }
    else if ((ClientInfo.ClientFlags & SECPKG_CLIENT_THREAD_TERMINATED) != 0)
    {
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // TBD:  Is this correct?  Local service LUIDs have no network creds,
    // so we've got to fail S4U to Self.
    // (OR - Do we use local system?)
    // NETWORK uses local system luid, so we're ok w/ that
    //

    if (RtlEqualLuid(&LocalService, &ClientInfo.LogonId))
    {
        D_DebugLog((DEB_ERROR, "Failing S4U due to LocalService\n"));
        Status = SEC_E_NO_CREDENTIALS;
        goto Cleanup;
    }
    else if (!RtlEqualLuid(&NetworkService, &ClientInfo.LogonId))
    {
        RtlCopyLuid(&CallerLuid, &ClientInfo.LogonId);
    }

    //
    // Use this LUID for decrypting S4U Service ticket
    //
    RtlCopyLuid(AlternateLuid, &CallerLuid);


    LogonInfo = (PKERB_S4U_LOGON) ProtocolSubmitBuffer;
    RELOCATE_ONE(&LogonInfo->ClientUpn);
    NULL_RELOCATE_ONE(&LogonInfo->ClientRealm);

    //
    // Make sure we have enough room to add a NULL to the end of the UPN
    //
    if (LogonInfo->ClientUpn.Length > KERB_MAX_UNICODE_STRING)
    {
        Status = STATUS_NAME_TOO_LONG;
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE_S4U, "KerbS4UToSelfLogon ClientUpn %wZ, ClientRealm %wZ, Flags %#x\n",
                &LogonInfo->ClientUpn, &LogonInfo->ClientRealm, LogonInfo->Flags));       
 
    Status = KerbProcessTargetNames(
                    &LogonInfo->ClientUpn,
                    NULL,
                    Flags,
                    &ProcessFlags,
                    S4UClientName,
                    &DummyRealm,
                    NULL
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    CallerLogonSession = KerbReferenceLogonSession(
                            &ClientInfo.LogonId,
                            FALSE
                            );

    if (NULL == CallerLogonSession)
    {
        D_DebugLog((DEB_ERROR, "Failed to locate caller's logon session - %x\n", ClientInfo.LogonId));
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // First, we need to get the client's realm from the UPN
    //

    if (LogonInfo->ClientRealm.Length == 0)
    {
        //
        // Make sure that our processed name is correct type - don't accept
        // NT4 style names as user names.
        //
        AltClientName = (*S4UClientName);

        if ( AltClientName->NameType != KRB_NT_ENTERPRISE_PRINCIPAL )
        {
            DebugLog((DEB_ERROR, "Wrong name type passed to S4U (%x)\n", AltClientName->NameType));
            Status = STATUS_INVALID_ACCOUNT_NAME;
            goto Cleanup;
        }


        Flags |= KERB_TARGET_DID_ALTNAME_LOOKUP;

        //
        // pre-empt burning a TGT request to find caller realm,
        // if we find it in our cache.
        //
        KerbReadLockLogonSessions( CallerLogonSession );
        LocalTicket = KerbLocateS4UTicketCacheEntry(
                                &CallerLogonSession->PrimaryCredentials.S4UTicketCache,
                                &ClientInfo.LogonId,
                                NULL,
                                NULL,
                                AltClientName,
                                S4UTICKETCACHE_USEALTNAME
                                );
        KerbUnlockLogonSessions( CallerLogonSession );

        if ( LocalTicket == NULL )
        {
            Status = KerbGetS4UClientRealm(
                        CallerLogonSession,
                        S4UClientName,
                        S4UClientRealm
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        else
        {
            //
            // Found the s4u ticket in the callers s4u cache - get the info
            // we need from it.
            //

            Status = KerbDuplicateString(
                        S4UClientRealm,
                        &LocalTicket->ClientDomainName
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
    }
    else
    {
        Status = KerbDuplicateString(
                    S4UClientRealm,
                    &LogonInfo->ClientRealm
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Allocate a locally unique ID for this logon session. We will
    // create it in the LSA just before returning.
    //

    Status = NtAllocateLocallyUniqueId( LogonId );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbCreateS4ULogonSession(
                    (*S4UClientName),
                    S4UClientRealm,
                    LogonId,
                    NewLogonSession
                    );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to create logon session 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    if ( LocalTicket == NULL )
    {
        Status = KerbGetS4USelfServiceTicket(
                        CallerLogonSession,
                        (*NewLogonSession),
                        NULL, // tbd: need to put credential here?
                        (*S4UClientName),
                        AltClientName,
                        S4UClientRealm,
                        WorkstationTicket,
                        0, // no flags
                        0, // no ticketoptions
                        0, // no enctype
                        NULL // auth data
                        );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
    else
    {
        *WorkstationTicket = LocalTicket;
        LocalTicket = NULL;
    }

    KerbWriteLockLogonSessions( (*NewLogonSession) );
    //
    // Is this going to be a "delegatable" logon session?
    //
    if (((*WorkstationTicket)->TicketFlags & KERB_TICKET_FLAGS_forwardable) != 0)
    {
        (*NewLogonSession)->LogonSessionFlags |= KERB_LOGON_DELEGATE_OK;
    }

#if DBG

    else
    {
        D_DebugLog((DEB_TRACE_S4U, "Created non-delegatable logon session via s4u logon\n"));
    }

#endif

    Status = KerbDuplicateTicketCacheEntry(
                (*WorkstationTicket),
                &Duplicate
                );

    if (!NT_SUCCESS(Status))
    {
        KerbUnlockLogonSessions((*NewLogonSession));
        goto Cleanup;
    }

    KerbInsertTicketCacheEntry(
            &((*NewLogonSession)->PrimaryCredentials.S4UTicketCache),
            Duplicate
            );

    KerbDereferenceTicketCacheEntry( Duplicate );
    KerbUnlockLogonSessions((*NewLogonSession));

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        //
        // TBD:  Negative cache here, based on client name
        //
        KerbFreeString(S4UClientRealm);
        KerbFreeKdcName(S4UClientName);
        *S4UClientName = NULL;

    }

    KerbFreeString( &DummyRealm );

    if ( LocalTicket != NULL )
    {
        KerbDereferenceTicketCacheEntry( LocalTicket );
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetS4UProxyEvidence
//
//  Synopsis:   Get our evidence ticket from the logonsession.  Its either a
//              service ticket (for ASC logon sessions), or a S4UToSelf request
//              if we don't have a service ticket.
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session of the service doing the
//                             S4U request
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetS4UProxyEvidence(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_INTERNAL_NAME TargetName,
    IN ULONG ClientProcess,
    IN OUT PKERB_LOGON_SESSION * CallingLogonSession,
    IN OUT PKERB_TICKET_CACHE_ENTRY * TicketCacheEntry
    )
{
    NTSTATUS Status;
    ULONG Flags = KERB_CRACK_NAME_USE_WKSTA_REALM, ProcessFlags = 0;
    ULONG LogonSessionFlags;
    BOOLEAN  LogonSessionLocked = FALSE;
    UNICODE_STRING TmpRealm = {0};
    LUID LogonId;
    PKERB_TICKET_CACHE_ENTRY NewCacheEntry = NULL;
    PKERB_INTERNAL_NAME ClientName = NULL;
    PKERB_LOGON_SESSION CallerLogonSession = NULL;

    *TicketCacheEntry = NULL;
    *CallingLogonSession = NULL;

    Status = KerbGetCallingLuid(
                &LogonId,
                ((HANDLE) LongToHandle(ClientProcess))
                );

    if (!NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }

    if (!KerbAllowedForS4UProxy( &LogonId ))
    {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // Get caller's logon session.
    //

    CallerLogonSession = KerbReferenceLogonSession(
                            &LogonId,
                            FALSE
                            );

    if (NULL == CallerLogonSession)
    {
        DsysAssert( FALSE );
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    KerbReadLockLogonSessions( LogonSession );
    LogonSessionFlags = LogonSession->LogonSessionFlags;

    NewCacheEntry = KerbLocateS4UTicketCacheEntry(
                            &LogonSession->PrimaryCredentials.S4UTicketCache,
                            &LogonId,
                            NULL,       // just get the ticket used for S4U.
                            NULL,
                            NULL,
                            S4UTICKETCACHE_FOR_EVIDENCE
                            );   

    KerbUnlockLogonSessions( LogonSession );

    if ( NewCacheEntry == NULL )
    {
        //
        // What's this?  An ASC logon sessoin w/o a ticket?
        //

        if (( LogonSessionFlags & KERB_LOGON_DELEGATE_OK ) == 0 )
        {
            DebugLog((DEB_ERROR, "Non Fwdable logon session used in S4u\n"));
            Status = STATUS_NO_SUCH_LOGON_SESSION;
            goto Cleanup; // right thing?  Or fall through?
        }

        DsysAssert( !LogonSessionLocked );
        KerbReadLockLogonSessions( LogonSession );
        LogonSessionLocked = TRUE;

        Status = KerbProcessTargetNames(
                        &LogonSession->PrimaryCredentials.UserName,
                        NULL,
                        Flags,
                        &ProcessFlags,
                        &ClientName,
                        &TmpRealm, 
                        NULL
                        );

        if (!NT_SUCCESS( Status ))
        {
            goto Cleanup;
        }

        KerbFreeString( &TmpRealm );

        Status = KerbDuplicateString(
                        &TmpRealm,
                        &LogonSession->PrimaryCredentials.DomainName
                        );

        if (!NT_SUCCESS( Status ))
        {
            goto Cleanup;
        }

        DsysAssert( LogonSessionLocked );
        KerbUnlockLogonSessions( LogonSession );
        LogonSessionLocked = FALSE;

        Status = KerbGetS4USelfServiceTicket(
                        CallerLogonSession,
                        LogonSession,
                        NULL,
                        ClientName,
                        NULL,           // no alt client name
                        &TmpRealm,
                        &NewCacheEntry,
                        0,
                        0,
                        0,
                        NULL
                        );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "KerbGetS4UProxyEvidence failed to get S4U ticket - %x\n", Status));
            goto Cleanup;
        }

        ASSERT(NewCacheEntry);

        if (NewCacheEntry->CacheFlags & KERB_TICKET_CACHE_TKT_ENC_IN_SKEY)
        {
            DebugLog((DEB_ERROR, "KerbGetS4UProxyEvidence does not allow u2u evidence key\n"));
            Status = SEC_E_NO_CREDENTIALS;
            goto Cleanup;
        }
        if ((NewCacheEntry->TicketFlags & KERB_TICKET_FLAGS_forwardable) == 0)
        {
            KerbWriteLockLogonSessions( LogonSession );
            LogonSession->LogonSessionFlags &= ~KERB_LOGON_DELEGATE_OK;
            KerbUnlockLogonSessions( LogonSession );

            DebugLog((DEB_TRACE_S4U, "KerbGetS4UProxyEvidence created non-delegatable logon session via s4u logon\n"));
            Status = SEC_E_NO_CREDENTIALS;
            goto Cleanup;
        }

        PKERB_TICKET_CACHE_ENTRY Duplicate;
        Status = KerbDuplicateTicketCacheEntry(
                        NewCacheEntry,
                        &Duplicate
                        );

        if (!NT_SUCCESS( Status ))
        {
            goto Cleanup;
        }

        KerbWriteLockLogonSessions ( LogonSession );
        LogonSession->LogonSessionFlags |= KERB_LOGON_DELEGATE_OK;

        KerbInsertTicketCacheEntry(
                &LogonSession->PrimaryCredentials.S4UTicketCache,
                Duplicate
                );

        KerbUnlockLogonSessions( LogonSession );

        KerbDereferenceTicketCacheEntry( Duplicate );
        Duplicate = NULL;
    }
    //
    // don't allow TKT encrypted in SKEY as evidence ticket for S4UProxy
    //
    else if (NewCacheEntry->CacheFlags & KERB_TICKET_CACHE_TKT_ENC_IN_SKEY)
    {
        DebugLog((DEB_ERROR, "KerbGetS4UProxyEvidence does not allow evidence ticket encrypted in SKEY\n"));
        Status = SEC_E_NO_CREDENTIALS;
        goto Cleanup;
    }

    *CallingLogonSession = CallerLogonSession;
    CallerLogonSession = NULL;

    *TicketCacheEntry = NewCacheEntry;
    NewCacheEntry = NULL;

Cleanup:

    if (NewCacheEntry)
    {
        KerbDereferenceTicketCacheEntry(NewCacheEntry);
    }

    if ( CallerLogonSession != NULL )
    {
        KerbDereferenceLogonSession( CallerLogonSession );
    }

    if ( LogonSessionLocked )
    {
        KerbUnlockLogonSessions( LogonSession );
    }

    KerbFreeKdcName( &ClientName );
    KerbFreeString( &TmpRealm );

    return Status;
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbS4UQueryWorker
//
//  Synopsis:   Handles a S4U Query
//
//  Effects:
//
//  Arguments:  TaskHandle - handle to the task (for rescheduling, etc.)
//              TaskItem   - task context
//
//  Requires:
//
//  Returns:    Nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------

void
KerbS4UCleanupWorker(
    void * TaskHandle,
    void * TaskItem
    )
{
    PKERB_S4UCACHE_DATA Entry = NULL;
    PLIST_ENTRY ListEntry = NULL;
    TimeStamp CurrentTime;

    
    GetSystemTimeAsFileTime( (PFILETIME) &CurrentTime );       
    KerbLockS4UCache();
    for (ListEntry = KerbS4UCache.List.Flink ;
         ListEntry !=  &KerbS4UCache.List ;
         ListEntry = ListEntry->Flink )
    {
        Entry = CONTAINING_RECORD(ListEntry, KERB_S4UCACHE_DATA, ListEntry.Next);
        
        if ( KerbGetTime( CurrentTime ) > KerbGetTime( Entry->CacheEndtime ))
        {
            ListEntry = ListEntry->Blink;
            D_DebugLog(( DEB_TRACE_S4U, "Aging out %p\n", Entry ));
            KerbRemoveS4UCacheEntry(Entry);

        } 

#if DBG
        else
        {
            D_DebugLog(( DEB_TRACE_S4U, "NOT aging %p\n", Entry));
        }
#endif

    }


    KerbUnlockS4UCache();

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbS4UQueryWorker
//
//  Synopsis:   Handles a S4U Query
//
//  Effects:
//
//  Arguments:  TaskHandle - handle to the task (for rescheduling, etc.)
//              TaskItem   - task context
//
//  Requires:
//
//  Returns:    Nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------

void
KerbS4UQueryWorker(
    void * TaskHandle,
    void * TaskItem
    )
{

    NTSTATUS                    Status = STATUS_SUCCESS;
    PKERB_LOGON_SESSION         LogonSession = (PKERB_LOGON_SESSION) TaskItem;
    PKERB_INTERNAL_NAME         TargetName = NULL;
    PKERB_TICKET_CACHE_ENTRY    ServiceTicket = NULL;
    PKERB_TICKET_CACHE_ENTRY    S4UTicket = NULL;
    PKERB_TICKET_CACHE_ENTRY    Tgt = NULL;
    UNICODE_STRING              TargetRealm = NULL_UNICODE_STRING;
    UNICODE_STRING              TempName = NULL_UNICODE_STRING;
    BOOLEAN                     LogonSessionLocked = FALSE, Upn = FALSE, CrossRealm = FALSE;
    KERB_TGT_REPLY              TgtReply ={0};
    PKERB_ENCRYPTION_KEY        EncryptKey = NULL;

    //
    // Get a service ticket to ourselves.  This will be used in the proxy
    // request.
    //

#if DBG
    SYSTEMTIME st;
    GetLocalTime(&st);
    DebugLog((DEB_TRACE_S4U, "Firing off S4UQuery worker LS %p\n", LogonSession));
    DebugLog((DEB_TRACE_S4U, "Current time: %02d:%02d:%02d\n", (ULONG)st.wHour, (ULONG)st.wMinute, (ULONG)st.wSecond));
#endif


    KerbReferenceLogonSessionByPointer(LogonSession, FALSE);
    KerbWriteLockLogonSessions( LogonSession );
    LogonSessionLocked = TRUE;
    


    Status = KerbGetS4UTargetName(
                &TargetName,
                &LogonSession->PrimaryCredentials,
                &LogonSession->LogonId,
                &Upn
                );

    if (!NT_SUCCESS( Status ))
    {   
        goto Cleanup;
    }


    Status = KerbDuplicateStringEx(
                &TargetRealm,
                &LogonSession->PrimaryCredentials.DomainName,
                FALSE
                );

    KerbUnlockLogonSessions( LogonSession );
    LogonSessionLocked = FALSE;

    if (!NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }


    //
    // Targetting a UPN usually requires U2U.  Get our TGT.
    //
    if ( Upn )
    { 
        KerbReadLockLogonSessions( LogonSession );

        Status = KerbGetTgtForService(
                    LogonSession,
                    NULL,
                    NULL,
                    NULL,
                    &TempName,  // no target realm
                    KERB_TICKET_CACHE_PRIMARY_TGT,
                    &Tgt,
                    &CrossRealm
                    );

        KerbUnlockLogonSessions( LogonSession );
                
        if (!NT_SUCCESS(Status) || CrossRealm )
        {
            DebugLog((DEB_ERROR, "KerbBuildTgtReply failed to get TGT, CrossRealm ? %s\n", CrossRealm ? "true" : "false"));
            Status = STATUS_USER2USER_REQUIRED;
            goto Cleanup;
        }

        TgtReply.version = KERBEROS_VERSION;
        TgtReply.message_type = KRB_TGT_REP;
        TgtReply.ticket = Tgt->Ticket;

    }

    Status = KerbGetServiceTicket(
                LogonSession,
                NULL,
                NULL,
                TargetName,
                &TargetRealm,
                NULL,
                0,
                0,
                0,
                NULL,
                NULL,
                (Upn ? &TgtReply : NULL),
                &ServiceTicket,
                NULL
                );

    if ( !NT_SUCCESS(Status) )
    {
        DebugLog((DEB_TRACE_S4U, "Couldn't get service ticket in S4UQueryWorker %x\n", Status));
        goto Cleanup;
    }


    //
    // U2U + S4UProxy won't work.  Target teh local machine.
    //
    if ( Upn )
    {                                   
        KerbFreeKdcName( &TargetName );
        KerbFreeString( &TargetRealm );
        
        KerbGlobalReadLock();

        Status = KerbDuplicateKdcName(
                        &TargetName,
                        KerbGlobalMitMachineServiceName
                        );
        if (NT_SUCCESS( Status ))
        {
            Status = KerbDuplicateString(
                        &TargetRealm,
                        &KerbGlobalDnsDomainName
                        );

        }

        KerbGlobalReleaseLock();
        if (!NT_SUCCESS( Status ))
        {
            goto Cleanup;
        }

        //
        // We can't use U2U + S4UProxy...  Decrypt the ticket, and re-encrypt w/ our password.
        //
        EncryptKey = KerbGetKeyFromList(
                        LogonSession->PrimaryCredentials.Passwords,
                        ServiceTicket->Ticket.encrypted_part.encryption_type
                        );    

        if ( EncryptKey == NULL)
        {
            goto Cleanup;
        }    

        Status = KerbPrepareEvidenceTicket(
                    &Tgt->SessionKey,
                    EncryptKey,
                    &ServiceTicket->Ticket
                    );        

        if (!NT_SUCCESS( Status ))
        {
            DebugLog((DEB_ERROR, "Couldn't encrypt evidence ticket %x\n", Status));
            goto Cleanup;
        }                

    }   


    Status = KerbGetServiceTicketByS4UProxy(
                LogonSession,
                LogonSession,
                NULL,
                ServiceTicket,
                TargetName,
                &TargetRealm,
                NULL,
                KERB_GET_TICKET_NO_CACHE,
                0,
                0,
                NULL,
                NULL,
                NULL,
                &S4UTicket,
                NULL
                );

    if (!NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }

Cleanup:

    //
    // Make sure to turn off one shot bit, so further requests can process
    //
    if ( !LogonSessionLocked )
    {
        KerbWriteLockLogonSessions( LogonSession );
    }

    LogonSession->LogonSessionFlags &= ~KERB_LOGON_ONE_SHOT;
    KerbUnlockLogonSessions( LogonSession );       

    KerbDereferenceLogonSession(LogonSession);

#if DBG
    D_DebugLog((DEB_TRACE_S4U, "Result %x :: ", Status));

    if (KerbAllowedForS4UProxy(&LogonSession->LogonId))
    {
        DebugLog((DEB_TRACE_S4U, "Allowed\n"));
    }
    else
    {
        DebugLog((DEB_TRACE_S4U, "NOT Allowed\n"));
    }

#endif

    KerbFreeKdcName( &TargetName );

    if ( ServiceTicket )
    {
        KerbDereferenceTicketCacheEntry( ServiceTicket );
    }

    if ( S4UTicket )
    {
        KerbDereferenceTicketCacheEntry( S4UTicket );
    }

    if ( Tgt )
    {
        KerbDereferenceTicketCacheEntry( Tgt );
    }

    return;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbS4UTaskCleanup
//
//  Synopsis:   Destroys a S4U query task
//
//  Effects:
//
//  Arguments:  TaskItem - cache entry to destroy
//
//  Requires:
//
//  Returns:    Nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------

void
KerbS4UTaskCleanup(
    void * TaskItem
    )
{
    PKERB_LOGON_SESSION LogonSession = (PKERB_LOGON_SESSION) TaskItem;

    if ( LogonSession )
    {                                       
        //
        // Release the refcount held by the task worker.
        //
        KerbDereferenceLogonSession(LogonSession);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbScheduleS4UQuery
//
//  Synopsis:   Sets up a task in the priority queue so that we can make
//              periodic attempts at S4UProxy, and determine if there are
//              any targets we're qualified (as indicated by the e_data).
//              See gettgs.cxx / KerbUnpackAdditionalTickets for more info
//              on this functionality.
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session of the service doing the
//                             S4U request
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbScheduleS4UQuery(
    IN PKERB_LOGON_SESSION LogonSession,
    IN LONG Interval,
    IN BOOLEAN Periodic
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG LogonSessionFlags;
    
    KerbReadLockLogonSessions( LogonSession );
    LogonSessionFlags = LogonSession->LogonSessionFlags;
    KerbUnlockLogonSessions( LogonSession );
    
    //
    // If we've already scheduled a query, bail now, as we
    // don't need to create a new task entry.
    //
    if ((LogonSessionFlags & KERB_LOGON_ONE_SHOT) != 0)
    {
        return Status;
    }
    
    D_DebugLog((DEB_TRACE_S4U, "Adding %s task to %p\n", (Periodic ? "periodic" : "oneshot"), LogonSession));
    
    Status = KerbAddScavengerTask(
                            Periodic,
                            Interval,
                            0, // no special processing flags
                            KerbS4UQueryWorker,
                            KerbS4UTaskCleanup,
                            LogonSession,
                            NULL
                            );

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR, "Failed to schedule scavenger task (%x) for LS %p\n", Status, LogonSession));
    }
    else
    {
        //
        // Add a reference for the task...
        //
        
        if ( !Periodic )
        {
	        KerbWriteLockLogonSessions( LogonSession );
            LogonSession->LogonSessionFlags |= KERB_LOGON_ONE_SHOT;
            KerbUnlockLogonSessions( LogonSession );
        }                                          

        KerbReferenceLogonSessionByPointer(LogonSession, FALSE);
    }                                   
    
    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbScheduleS4UCleanup
//
//  Synopsis:   Walks the list to cleanup any old, unreferenced entries.
//
//  Effects:
//
//  Arguments:  
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbScheduleS4UCleanup()

{
    NTSTATUS Status = STATUS_SUCCESS;
    LONG Interval = 60 * 1000 * 60; // once per hour  
    
    
    Status = KerbAddScavengerTask(
                            TRUE,
                            Interval,
                            0, // no special processing flags
                            KerbS4UCleanupWorker,
                            NULL,
                            NULL,
                            NULL
                            );

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR, "Failed to schedule scavenger task (%x) \n", Status));
    }
    
    return Status;
}
    


//+-------------------------------------------------------------------------
//
//  Function:   KerbAllowedForS4UProxy
//
//  Synopsis:  Check the S4UCACHE_DATA to see if we can do S4U for this target.  
//             This will only get called in the AcceptSecurityContext() code path
//             where we'll need to see if we need to cache tickets.  Cache them,
//             for now, but kick off a worker thread to see if there's any need
//             to cache tickets in the future.
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session of the service doing the
//                             S4U request
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//+-------------------------------------------------------------------------
BOOLEAN
KerbAllowedForS4UProxy(
    IN PLUID LogonId
    )
{
    ULONG                   CacheState = 0;
    PKERB_S4UCACHE_DATA     S4UCacheEntry = NULL;
    BOOLEAN                 fRet = TRUE, Update = FALSE;
    PKERB_LOGON_SESSION     LogonSession = NULL;
    LUID                    LocalService =  LOCALSERVICE_LUID;
    LUID                    Anonymous = ANONYMOUS_LOGON_LUID;
    KERBEROS_MACHINE_ROLE   Role;


    Role = KerbGetGlobalRole();
    
    //
    // S4UToProxy is not allowed for anything but
    // server products.
    //
    if (!KerbGlobalRunningServer ||
        RtlEqualLuid(LogonId, &LocalService) || 
        RtlEqualLuid(LogonId, &Anonymous) ||
        Role < KerbRoleWorkstation )
    {
        return FALSE;
    }

    S4UCacheEntry = KerbLocateS4UCacheEntry(
                           LogonId,
                           &CacheState
                           );

    if ( NULL != S4UCacheEntry )
    { 
        if (( CacheState & S4UCACHE_S4U_UNAVAILABLE ) != 0)
        {
            D_DebugLog((DEB_TRACE_S4U, "Luid %x:%x can't do S4u\n", LogonId->HighPart, LogonId->LowPart));
            fRet = FALSE;
        }
        
        if (( CacheState & S4UCACHE_TIMEOUT ) != 0)
        {
            Update = TRUE;
        }
    
        KerbDereferenceS4UCacheEntry(S4UCacheEntry);
    }
    else
    {
        Update = TRUE;
    }


    if ( Update )
    {
        LONG Period = 1;

        LogonSession = KerbReferenceLogonSession(LogonId, FALSE);
        if ( LogonSession )
        {   
            KerbReadLockLogonSessions( LogonSession );
            if (( LogonSession->LogonSessionFlags & KERB_LOGON_LOCAL_ONLY ) != 0)
            {
                KerbUnlockLogonSessions( LogonSession );
                DebugLog((DEB_TRACE_S4U, "Local account %p - s4u not allowed\n", LogonSession ));
                fRet = FALSE;
            }
            else
            {
                KerbUnlockLogonSessions( LogonSession );
                //
                // Do this async in 1sec to keep from blocking
                // ASC.
                //
                
                KerbScheduleS4UQuery(LogonSession, Period, FALSE);                                             
                KerbDereferenceLogonSession( LogonSession );
            }
        } 
        else
        {
            fRet = FALSE;
        }
    }  

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\kerbtick.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbtick.cxx
//
// Contents:    Routines for obtaining and manipulating tickets
//
//
// History:     23-April-1996   Created         MikeSw
//              26-Sep-1998   ChandanS
//                            Added more debugging support etc.
//              15-Oct-1999   ChandanS
//                            Send more choice of encryption types.
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>
#include <userapi.h>    // for GSS support routines
#include <kerbpass.h>
#include <krbaudit.h>

extern "C"
{
#include <stdlib.h>     // abs()
}

#include <utils.hxx>

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif
#define FILENO FILENO_KERBTICK


#ifndef WIN32_CHICAGO // We don't do server side stuff
#include <authen.hxx>

CAuthenticatorList * Authenticators;
#endif // WIN32_CHICAGO // We don't do server side stuff

#include <lsaitf.h>



//+-------------------------------------------------------------------------
//
//  Function:   KerbRenewTicket
//
//  Synopsis:   renews a ticket
//
//  Effects:    Tries to renew a ticket
//
//  Arguments:  LogonSession - LogonSession for user, contains ticket caches
//                      and locks
//              Credentials - Present if the ticket being renewed is hanging
//                      off a credential structure
//              CredManCredentials - Credman credential
//              Ticket - Ticket to renew
//              IsTgt - Whether the ticket is a TGT
//              NewTicket - Receives the renewed ticket
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbRenewTicket(
    IN PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_CREDENTIAL Credentials,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN PKERB_TICKET_CACHE_ENTRY Ticket,
    IN BOOLEAN IsTgt,
    OUT PKERB_TICKET_CACHE_ENTRY *NewTicket
    )
{
    NTSTATUS Status;
    PKERB_INTERNAL_NAME ServiceName = NULL;
    PKERB_KDC_REPLY KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY KdcReplyBody = NULL;
    UNICODE_STRING ServiceRealm = NULL_UNICODE_STRING;
    BOOLEAN TicketCacheLocked = FALSE;
    BOOLEAN LogonSessionsLocked = FALSE;
    PKERB_PRIMARY_CREDENTIAL PrimaryCred;
    ULONG CacheFlags = 0;
    ULONG RetryFlags = 0;

    *NewTicket = NULL;

    //
    // Copy the names out of the input structures so we can
    // unlock the structures while going over the network.
    //

    KerbReadLockTicketCache();
    TicketCacheLocked = TRUE;

    //
    // If the renew time is not much bigger than the end time, don't bother
    // renewing
    //

    if (KerbGetTime(Ticket->EndTime) + KerbGetTime(KerbGlobalSkewTime) >= KerbGetTime(Ticket->RenewUntil))
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }
    CacheFlags = Ticket->CacheFlags;

    Status = KerbDuplicateString(
                &ServiceRealm,
                &Ticket->DomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbDuplicateKdcName(
                &ServiceName,
                Ticket->ServiceName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if ((Ticket->TicketFlags & KERB_TICKET_FLAGS_renewable) == 0)
    {
        Status = STATUS_ILLEGAL_FUNCTION;
        DebugLog((DEB_ERROR, "KerbRenewTicket trying to renew a non renewable ticket to"));
        KerbPrintKdcName(DEB_ERROR, ServiceName);
        goto Cleanup;
    }

    KerbUnlockTicketCache();
    TicketCacheLocked = FALSE;

    Status = KerbGetTgsTicket(
                &ServiceRealm,
                Ticket,
                ServiceName,
                0, // no flags
                KERB_KDC_OPTIONS_renew,
                0,       // no encryption type
                NULL,    // no authorization data
                NULL,    // no PaDataList
                NULL,    // no tgt reply
                NULL,    // no evidence ticket
                NULL,    // no endtime
                &KdcReply,
                &KdcReplyBody,
                &RetryFlags  // no retry is necessary
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "KerbRenewTicket failed to get TGS ticket for service 0x%x ", Status));
        KerbPrintKdcName(DEB_ERROR, ServiceName);
        goto Cleanup;
    }

    KerbWriteLockLogonSessions(LogonSession);
    LogonSessionsLocked = TRUE;

    if ((Credentials != NULL) && (Credentials->SuppliedCredentials != NULL))
    {
        PrimaryCred = Credentials->SuppliedCredentials;
    }
    else if (CredManCredentials)
    {
        PrimaryCred = CredManCredentials->SuppliedCredentials;
    }
    else
    {
        PrimaryCred = &LogonSession->PrimaryCredentials;
    }

    Status = KerbCreateTicketCacheEntry(
                KdcReply,
                KdcReplyBody,
                ServiceName,
                &ServiceRealm,
                CacheFlags,
                (IsTgt ? &PrimaryCred->AuthenticationTicketCache : &PrimaryCred->ServerTicketCache),
                NULL,
                NewTicket
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN, "KerbRenewTicket failed to create a ticket cache entry for service %#x ", Status));
        KerbPrintKdcName(DEB_WARN, ServiceName);
        goto Cleanup;
    }

Cleanup:

    if (TicketCacheLocked)
    {
        KerbUnlockTicketCache();
    }
    
    if (LogonSessionsLocked)
    {
        KerbUnlockLogonSessions(LogonSession);
    }

    KerbFreeTgsReply(KdcReply);
    KerbFreeKdcReplyBody(KdcReplyBody);
    KerbFreeKdcName(&ServiceName);
    KerbFreeString(&ServiceRealm);
    
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbRefreshPrimaryTgt
//
//  Synopsis:   Obtains a new TGT for a logon session or credential
//
//
//  Effects:    does a new AS exchange with the KDC to get a TGT for the client
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbRefreshPrimaryTgt(
    IN PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_CREDENTIAL Credentials,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN OPTIONAL PUNICODE_STRING SuppRealm,
    IN OPTIONAL PKERB_TICKET_CACHE_ENTRY OldTgt,
    IN BOOLEAN GetInitialPrimaryTgt
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;

    if (ARGUMENT_PRESENT(OldTgt))
    {
        PKERB_TICKET_CACHE_ENTRY NewTgt = NULL;

        DebugLog((DEB_WARN, "KerbRefreshPrimaryTgt attempting to renew primary TGT\n"));

        Status = KerbRenewTicket(
                    LogonSession,
                    Credentials,
                    CredManCredentials,
                    OldTgt,
                    TRUE,   // it is a TGT
                    &NewTgt
                    );
        if (NewTgt) 
        {
            KerbDereferenceTicketCacheEntry(NewTgt);
        }
    }

    if (!NT_SUCCESS(Status) && GetInitialPrimaryTgt)
    {
        DebugLog((DEB_WARN, "KerbRefreshPrimaryTgt getting new TGT for account\n"));

        Status = KerbGetTicketForCredential(
                    LogonSession,
                    Credentials,
                    CredManCredentials,
                    SuppRealm
                    );                   
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetTgtForService
//
//  Synopsis:   Gets a TGT for the domain of the specified service. If a
//              cached one is available, it uses that one. Otherwise it
//              calls the KDC to acquire it.
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session for which to acquire a ticket
//              Credentials - If present & contains supp. creds, use them
//                      for the ticket cache
//              SuppRealm - This is a supplied realm for which to acquire
//                      a TGT, this may or may not be the same as the
//                      TargetDomain.
//              TargetDomain - Realm of service for which to acquire a TGT
//              NewCacheEntry - Receives a referenced ticket cache entry for
//                      TGT
//              CrossRealm - TRUE if target is known to be in a different realm
//
//  Requires:   The primary credentials be locked
//
//  Returns:    Kerberos errors, NT status codes.
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetTgtForService(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN OPTIONAL PUNICODE_STRING SuppRealm,
    IN PUNICODE_STRING TargetDomain,
    IN ULONG TargetFlags,
    OUT PKERB_TICKET_CACHE_ENTRY * NewCacheEntry,
    OUT PBOOLEAN CrossRealm
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_TICKET_CACHE_ENTRY CacheEntry;
    BOOLEAN DoRetry = TRUE;
    PKERB_PRIMARY_CREDENTIAL PrimaryCredentials;

    *CrossRealm = FALSE;
    *NewCacheEntry = NULL;

    D_DebugLog((DEB_TRACE, "KerbGetTgtForService TargetFlags %#x, SuppRealm %wZ, TargetFlags %wZ\n", TargetFlags, SuppRealm, TargetDomain));

    if (ARGUMENT_PRESENT(Credential) && (Credential->SuppliedCredentials != NULL))
    {
        PrimaryCredentials = Credential->SuppliedCredentials;
    }
    else if (ARGUMENT_PRESENT(CredManCredentials))
    {
        PrimaryCredentials = CredManCredentials->SuppliedCredentials;
    }
    else
    {
        PrimaryCredentials = &LogonSession->PrimaryCredentials;
    }

    if (TargetDomain->Length != 0)
    {
        CacheEntry = KerbLocateTicketCacheEntryByRealm(
                        &PrimaryCredentials->AuthenticationTicketCache,
                        TargetDomain,
                        0
                        );

        if (CacheEntry != NULL)
        {
            *NewCacheEntry = CacheEntry;
            goto Cleanup;
        }
    }

    //
    // Well, we didn't find one to the other domain. Return a TGT for our
    // domain.
    //

Retry:

    CacheEntry = KerbLocateTicketCacheEntryByRealm(
                    &PrimaryCredentials->AuthenticationTicketCache,
                    SuppRealm,
                    KERB_TICKET_CACHE_PRIMARY_TGT
                    );

    if (CacheEntry != NULL)
    {
        //
        // The first pass, make sure the ticket has a little bit of life.
        // The second pass, we don't ask for as much
        //

        if (!KerbTicketIsExpiring(CacheEntry, DoRetry))
        {
            Status = STATUS_SUCCESS;
            *NewCacheEntry = CacheEntry;

            //
            // If the TGT is not for the domain of the service,
            // this is cross realm.  If we used the SPN cache, we're
            // obviously missing a ticket, and we need to restart the
            // referral process.
            //
            //

            if ((TargetDomain->Length != 0) &&
                (TargetFlags & KERB_TARGET_USED_SPN_CACHE) == 0)
            {
                *CrossRealm = TRUE;
            }
            goto Cleanup;
        }
    }

    //
    // Try to obtain a new TGT
    //

    if (DoRetry)
    {
        PKERB_PRIMARY_CREDENTIAL PrimaryCred;

        if ((Credential != NULL) && (Credential->SuppliedCredentials != NULL))
        {
            PrimaryCred = Credential->SuppliedCredentials;
        }
        else if (CredManCredentials)
        {
            PrimaryCred = CredManCredentials->SuppliedCredentials;
        }
        else
        {
            PrimaryCred = &LogonSession->PrimaryCredentials;
        }

        //
        // Unlock the logon session so we can try to get a new TGT
        //

        KerbUnlockLogonSessions(LogonSession);

        DebugLog((DEB_WARN, "KerbGetTgtForService getting new TGT for account\n"));

        if (KerbHaveKeyMaterials(NULL, PrimaryCred)) 
        {
            Status = KerbGetTicketForCredential(
                        LogonSession,
                        Credential,
                        CredManCredentials,
                        SuppRealm
                        );

        }
        else  // no key materials? renew the existing TGT
        {
            Status = KerbRefreshPrimaryTgt(
                        LogonSession,
                        Credential,
                        CredManCredentials,
                        SuppRealm,
                        CacheEntry,
                        PrimaryCred->PublicKeyCreds != NULL // get initial primary TGT for smartcard credential
                        );
            if (!NT_SUCCESS(Status)) 
            {
                DebugLog((DEB_WARN, "KerbGetTgtForService falied to refresh TGT %#x for %wZ@%wZ\n", Status, &PrimaryCred->UserName, &PrimaryCred->DomainName));

                DoRetry = FALSE; // do not remove the existing cache entry and allow retry
            }
        }

        if (CacheEntry != NULL)
        {
             // pull the old TGT from the list, if its been replaced
            if (NT_SUCCESS(Status) && DoRetry)
            {
                KerbRemoveTicketCacheEntry(CacheEntry);
            }

            KerbDereferenceTicketCacheEntry(CacheEntry);
            CacheEntry = NULL;
        }

        KerbReadLockLogonSessions(LogonSession);
        if (!NT_SUCCESS(Status) && DoRetry)
        {
            DebugLog((DEB_ERROR, "KerbGetTgtForService failed to refresh primary TGT: 0x%x. %ws, line %d\n", Status, THIS_FILE, __LINE__ ));
            goto Cleanup;
        }
        DoRetry = FALSE;
        goto Retry;
    }

    if (NT_SUCCESS(Status)) 
    {
        Status = SEC_E_NO_CREDENTIALS; // can not get TGT, possibly TGT expired
    }

Cleanup:

    if (!NT_SUCCESS(Status) && (CacheEntry != NULL))
    {
        KerbDereferenceTicketCacheEntry(CacheEntry);
        *NewCacheEntry = NULL;
    }

    return (Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildKerbCred
//
//  Synopsis:   Builds a marshalled KERB_CRED structure
//
//  Effects:    allocates destination with MIDL_user_allocate
//
//  Arguments:  Ticket - The ticket of the session key to seal the
//                      encrypted portion (OPTIONAL)
//              DelegationTicket - The ticket to marshall into the cred message
//              MarshalledKerbCred - Receives a marshalled KERB_CRED structure
//              KerbCredSizes - Receives size, in bytes, of marshalled
//                      KERB_CRED.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildKerbCred(
    IN OPTIONAL PKERB_TICKET_CACHE_ENTRY Ticket,
    IN PKERB_TICKET_CACHE_ENTRY DelegationTicket,
    OUT PUCHAR * MarshalledKerbCred,
    OUT PULONG KerbCredSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    KERB_CRED KerbCred;
    KERB_CRED_INFO_LIST CredInfo;
    KERB_ENCRYPTED_CRED EncryptedCred;
    KERB_CRED_TICKET_LIST TicketList;
    PUCHAR MarshalledEncryptPart = NULL;
    ULONG MarshalledEncryptSize;
    ULONG ConvertedFlags;

    //
    // Initialize the structures so they can be freed later.
    //

    *MarshalledKerbCred = NULL;
    *KerbCredSize = 0;

    RtlZeroMemory(
        &KerbCred,
        sizeof(KERB_CRED)
        );

    RtlZeroMemory(
        &EncryptedCred,
        sizeof(KERB_ENCRYPTED_CRED)
        );
    RtlZeroMemory(
        &CredInfo,
        sizeof(KERB_CRED_INFO_LIST)
        );
    RtlZeroMemory(
        &TicketList,
        sizeof(KERB_CRED_TICKET_LIST)
        );

    KerbCred.version = KERBEROS_VERSION;
    KerbCred.message_type = KRB_CRED;

    //
    // First stick the ticket into the ticket list.
    //

    KerbReadLockTicketCache();

    TicketList.next= NULL;
    TicketList.value = DelegationTicket->Ticket;
    KerbCred.tickets = &TicketList;

    //
    // Now build the KERB_CRED_INFO for this ticket
    //

    CredInfo.value.key = DelegationTicket->SessionKey;
    KerbConvertLargeIntToGeneralizedTime(
        &CredInfo.value.endtime,
        NULL,
        &DelegationTicket->EndTime
        );
    CredInfo.value.bit_mask |= endtime_present;

    KerbConvertLargeIntToGeneralizedTime(
        &CredInfo.value.starttime,
        NULL,
        &DelegationTicket->StartTime
        );
    CredInfo.value.bit_mask |= KERB_CRED_INFO_starttime_present;

    KerbConvertLargeIntToGeneralizedTime(
        &CredInfo.value.KERB_CRED_INFO_renew_until,
        NULL,
        &DelegationTicket->RenewUntil
        );
    CredInfo.value.bit_mask |= KERB_CRED_INFO_renew_until_present;

    ConvertedFlags = KerbConvertUlongToFlagUlong(DelegationTicket->TicketFlags);
    CredInfo.value.flags.value = (PUCHAR) &ConvertedFlags;
    CredInfo.value.flags.length = 8 * sizeof(ULONG);
    CredInfo.value.bit_mask |= flags_present;

    //
    // The following fields are marked as optional but treated
    // as mandatory by the MIT implementation of Kerberos and
    // therefore we provide them.
    //

    KerbErr = KerbConvertKdcNameToPrincipalName(
                &CredInfo.value.principal_name,
                DelegationTicket->ClientName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }
    CredInfo.value.bit_mask |= principal_name_present;

    KerbErr = KerbConvertKdcNameToPrincipalName(
                &CredInfo.value.service_name,
                DelegationTicket->ServiceName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }
    CredInfo.value.bit_mask |= service_name_present;

    //
    // We are assuming that because we are sending a TGT the
    // client realm is the same as the server realm. If we ever
    // send non-tgt or cross-realm tgt, this needs to be fixed.
    //

    KerbErr = KerbConvertUnicodeStringToRealm(
                &CredInfo.value.principal_realm,
                &DelegationTicket->ClientDomainName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        goto Cleanup;
    }
    //
    // The realms are the same, so don't allocate both
    //

    CredInfo.value.service_realm = CredInfo.value.principal_realm;
    CredInfo.value.bit_mask |= principal_realm_present | service_realm_present;

    EncryptedCred.ticket_info = &CredInfo;


    //
    // Now encrypted the encrypted cred into the cred
    //

    if (!KERB_SUCCESS(KerbPackEncryptedCred(
                        &EncryptedCred,
                        &MarshalledEncryptSize,
                        &MarshalledEncryptPart
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // If we are doing DES encryption, then we are talking with an non-NT
    // server. Hence, don't encrypt the kerb-cred.
    //
    // Additionally, if service ticket == NULL, don't encrypt kerb cred
    //

    if (!ARGUMENT_PRESENT(Ticket))
    {
       KerbCred.encrypted_part.cipher_text.length = MarshalledEncryptSize;
       KerbCred.encrypted_part.cipher_text.value = MarshalledEncryptPart;
       KerbCred.encrypted_part.encryption_type = 0;
       MarshalledEncryptPart = NULL;
    }
    else if( KERB_IS_DES_ENCRYPTION(Ticket->SessionKey.keytype))
    {
       KerbCred.encrypted_part.cipher_text.length = MarshalledEncryptSize;
       KerbCred.encrypted_part.cipher_text.value = MarshalledEncryptPart;
       KerbCred.encrypted_part.encryption_type = 0;
       MarshalledEncryptPart = NULL;
    }
    else
    {
        //
        // Now get the encryption overhead
        //

        KerbErr = KerbAllocateEncryptionBufferWrapper(
                    Ticket->SessionKey.keytype,
                    MarshalledEncryptSize,
                    &KerbCred.encrypted_part.cipher_text.length,
                    &KerbCred.encrypted_part.cipher_text.value
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }



        //
        // Encrypt the data.
        //

        KerbErr = KerbEncryptDataEx(
                    &KerbCred.encrypted_part,
                    MarshalledEncryptSize,
                    MarshalledEncryptPart,
                    KERB_NO_KEY_VERSION,
                    KERB_CRED_SALT,
                    &Ticket->SessionKey
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }

    //
    // Now we have to marshall the whole KERB_CRED
    //

    if (!KERB_SUCCESS(KerbPackKerbCred(
                        &KerbCred,
                        KerbCredSize,
                        MarshalledKerbCred
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

Cleanup:
    KerbUnlockTicketCache();

    KerbFreePrincipalName(&CredInfo.value.service_name);

    KerbFreePrincipalName(&CredInfo.value.principal_name);

    KerbFreeRealm(&CredInfo.value.principal_realm);

    if (MarshalledEncryptPart != NULL)
    {
        MIDL_user_free(MarshalledEncryptPart);
    }
    if (KerbCred.encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(KerbCred.encrypted_part.cipher_text.value);
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetDelegationTgt
//
//  Synopsis:   Gets a TGT to delegate to another service. This TGT
//              is marked as forwarded and does not include any
//              client addresses
//
//  Effects:
//
//  Arguments:
//
//  Requires:   Logon sesion must be read-locked
//
//  Returns:
//
//  Notes:      This gets a delegation TGT & caches it under the realm name
//              "$$Delegation Ticket$$". When we look for it again later,
//              it should be discoverable under the same name.
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbGetDelegationTgt(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    IN PKERB_TICKET_CACHE_ENTRY ServicetTicket,
    OUT PKERB_TICKET_CACHE_ENTRY * DelegationTgt
    )
{
    PKERB_TICKET_CACHE_ENTRY TicketGrantingTicket = NULL;
    PKERB_INTERNAL_NAME TgsName = NULL;
    UNICODE_STRING TgsRealm = {0};
    PKERB_KDC_REPLY KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY KdcReplyBody = NULL;
    BOOLEAN LogonSessionLocked = TRUE;
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING CacheName;
    BOOLEAN CacheTicket = TRUE;
    ULONG RetryFlags = 0;

    RtlInitUnicodeString(
        &CacheName,
        L"$$Delegation Ticket$$"
        );

    *DelegationTgt = KerbLocateTicketCacheEntryByRealm(
                            &Credentials->AuthenticationTicketCache,
                            &CacheName,
                            KERB_TICKET_CACHE_DELEGATION_TGT
                            );
    if (*DelegationTgt != NULL )
    {
        KerbReadLockTicketCache();

        //
        // when use cached tgt, make sure the encryption_type matches and 
        // life time is no less than that of the service ticket
        //

        if ((ServicetTicket->Ticket.encrypted_part.encryption_type != (*DelegationTgt)->Ticket.encrypted_part.encryption_type)
            || (KerbGetTime((*DelegationTgt)->EndTime) < KerbGetTime(ServicetTicket->EndTime)))
        {
            KerbUnlockTicketCache();
            KerbDereferenceTicketCacheEntry(*DelegationTgt);
            *DelegationTgt = NULL;
            CacheTicket = FALSE;
        }
        else
        {
            KerbUnlockTicketCache();
            goto Cleanup;
        }
    }

    TicketGrantingTicket = KerbLocateTicketCacheEntryByRealm(
                                &Credentials->AuthenticationTicketCache,
                                &Credentials->DomainName,       // take the logon TGT
                                0
                                );


    if ((TicketGrantingTicket == NULL) ||
        ((TicketGrantingTicket->TicketFlags & KERB_TICKET_FLAGS_forwardable) == 0) )
    {
        DebugLog((DEB_WARN, "Trying to delegate but no forwardable TGT\n"));
        Status = SEC_E_NO_CREDENTIALS;
        goto Cleanup;
    }

    //
    // Get the TGT service name from the TGT
    //

    KerbReadLockTicketCache();

    Status = KerbDuplicateKdcName(
                &TgsName,
                TicketGrantingTicket->ServiceName
                );
    if (NT_SUCCESS(Status))
    {
        Status = KerbDuplicateString(
                    &TgsRealm,
                    &TicketGrantingTicket->DomainName
                    );
    }
    KerbUnlockTicketCache();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    DsysAssert( LogonSessionLocked );
    KerbUnlockLogonSessions(LogonSession);
    LogonSessionLocked = FALSE;

    //
    // Now try to get the ticket.
    //

    Status = KerbGetTgsTicket(
                &TgsRealm,
                TicketGrantingTicket,
                TgsName,
                TRUE, // no name canonicalization, no GC lookups.
                KERB_KDC_OPTIONS_forwarded | KERB_DEFAULT_TICKET_FLAGS,
                ServicetTicket->Ticket.encrypted_part.encryption_type,                 // no encryption type
                NULL,                           // no authorization data
                NULL,                           // no pa data
                NULL,                           // no tgt reply
                NULL,                           // no evidence ticket
                NULL,                           // let kdc determine end time
                &KdcReply,
                &KdcReplyBody,
                &RetryFlags
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    DsysAssert( !LogonSessionLocked );
    KerbReadLockLogonSessions(LogonSession);
    LogonSessionLocked = TRUE;

    Status = KerbCreateTicketCacheEntry(
                KdcReply,
                KdcReplyBody,
                NULL,           // no target name
                &CacheName,
                KERB_TICKET_CACHE_DELEGATION_TGT,
                CacheTicket ? &Credentials->AuthenticationTicketCache : NULL,
                NULL,                               // no credential key
                DelegationTgt
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

Cleanup:
    KerbFreeTgsReply (KdcReply);
    KerbFreeKdcReplyBody (KdcReplyBody);

    if (TicketGrantingTicket != NULL)
    {
        KerbDereferenceTicketCacheEntry(TicketGrantingTicket);
    }
    KerbFreeKdcName(&TgsName);
    KerbFreeString(&TgsRealm);

    if (!LogonSessionLocked)
    {
        KerbReadLockLogonSessions(LogonSession);
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildGssChecskum
//
//  Synopsis:   Builds the GSS checksum to go in an AP request
//
//  Effects:    Allocates a checksum with KerbAllocate
//
//  Arguments:  ContextFlags - Requested context flags
//              LogonSession - LogonSession to be used for delegation
//              GssChecksum - Receives the new checksum
//              ApOptions - Receives the requested AP options
//
//  Requires:
//
//  Returns:
//
//  Notes:      The logon session is locked when this is called.
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildGssChecksum(
    IN  PKERB_LOGON_SESSION      LogonSession,
    IN  PKERB_PRIMARY_CREDENTIAL PrimaryCredentials,
    IN  PKERB_TICKET_CACHE_ENTRY Ticket,
    IN  OUT PULONG               ContextFlags,
    OUT PKERB_CHECKSUM           GssChecksum,
    OUT PULONG                   ApOptions,
    IN  PSEC_CHANNEL_BINDINGS    pChannelBindings
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_GSS_CHECKSUM ChecksumBody = NULL;
    PKERB_TICKET_CACHE_ENTRY TicketGrantingTicket = NULL;
    ULONG ChecksumSize = GSS_CHECKSUM_SIZE;
    ULONG KerbCredSize = 0 ;
    PUCHAR KerbCred = NULL;
    BOOL OkAsDelegate = FALSE, OkToTrustMitKdc = FALSE;
    PKERB_MIT_REALM MitRealm = NULL;
    BOOLEAN UsedAlternateName;
    ULONG BindHash[4];

    *ApOptions = 0;

    //
    // If we are doing delegation, built a KERB_CRED message to return
    //

    if (*ContextFlags & (ISC_RET_DELEGATE | ISC_RET_DELEGATE_IF_SAFE))
    {
        KerbReadLockTicketCache();
        OkAsDelegate = ((Ticket->TicketFlags & KERB_TICKET_FLAGS_ok_as_delegate) != 0) ? TRUE : FALSE;
        if (KerbLookupMitRealm(
               &Ticket->DomainName,
               &MitRealm,
               &UsedAlternateName))
        {
            if ((MitRealm->Flags & KERB_MIT_REALM_TRUSTED_FOR_DELEGATION) != 0)
            {
                OkToTrustMitKdc = TRUE;
            }
        }
        KerbUnlockTicketCache();

        if (OkAsDelegate || OkToTrustMitKdc)
        {
            D_DebugLog((DEB_TRACE, "KerbBuildGssChecksum asked for delegate if safe, and getting delegation TGT\n"));

            //
            // Check to see if we have a TGT
            //

            Status = KerbGetDelegationTgt(
                        LogonSession,
                        PrimaryCredentials,
                        Ticket,
                        &TicketGrantingTicket
                        );
            if (!NT_SUCCESS(Status))
            {
                //
                // Turn off the delegate flag for building the token.
                //

                *ContextFlags &= ~ISC_RET_DELEGATE;
                *ContextFlags &= ~ISC_RET_DELEGATE_IF_SAFE;
                DebugLog((DEB_WARN, "KerbBuildGssChecksum failed to get delegation TGT: 0x%x\n", Status));
                Status = STATUS_SUCCESS;
            }
            else
            {
                //
                // Build the KERB_CRED message
                //

                Status = KerbBuildKerbCred(
                            Ticket,
                            TicketGrantingTicket,
                            &KerbCred,
                            &KerbCredSize
                            );
                if (!NT_SUCCESS(Status))
                {
                    D_DebugLog((DEB_ERROR, "Failed to build KERB_CRED: 0x%x. %ws, line %d\n", Status, THIS_FILE, __LINE__));
                    goto Cleanup;
                }
                //ChecksumSize= sizeof(KERB_GSS_CHECKSUM) - ANYSIZE_ARRAY * sizeof(UCHAR) + KerbCredSize;
                ChecksumSize = GSS_DELEGATE_CHECKSUM_SIZE + KerbCredSize;

                //
                // And if only the DELEGATE_IF_SAFE flag was on, turn on the
                // real delegate flag:
                //
                *ContextFlags |= ISC_RET_DELEGATE ;
            }
        }
        else
        {
            //
            // Turn off the delegate flag for building the token.
            //

            *ContextFlags &= ~ISC_RET_DELEGATE;
            *ContextFlags &= ~ISC_RET_DELEGATE_IF_SAFE;
        }
    }

    ChecksumBody = (PKERB_GSS_CHECKSUM) KerbAllocate(ChecksumSize);
    if (ChecksumBody == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Convert the requested flags to AP options.
    //

    if ((*ContextFlags & ISC_RET_MUTUAL_AUTH) != 0)
    {
        *ApOptions |= KERB_AP_OPTIONS_mutual_required;
        ChecksumBody->GssFlags |= GSS_C_MUTUAL_FLAG;
    }

    if ((*ContextFlags & ISC_RET_USE_SESSION_KEY) != 0)
    {
        *ApOptions |= KERB_AP_OPTIONS_use_session_key;
    }

    if ((*ContextFlags & ISC_RET_USED_DCE_STYLE) != 0)
    {
        ChecksumBody->GssFlags |= GSS_C_DCE_STYLE;
    }

    if ((*ContextFlags & ISC_RET_SEQUENCE_DETECT) != 0)
    {
        ChecksumBody->GssFlags |= GSS_C_SEQUENCE_FLAG;
    }

    if ((*ContextFlags & ISC_RET_REPLAY_DETECT) != 0)
    {
        ChecksumBody->GssFlags |= GSS_C_REPLAY_FLAG;
    }

    if ((*ContextFlags & ISC_RET_CONFIDENTIALITY) != 0)
    {
        ChecksumBody->GssFlags |= GSS_C_CONF_FLAG;
    }

    if ((*ContextFlags & ISC_RET_INTEGRITY) != 0)
    {
        ChecksumBody->GssFlags |= GSS_C_INTEG_FLAG;
    }

    if ((*ContextFlags & ISC_RET_IDENTIFY) != 0)
    {
        ChecksumBody->GssFlags |= GSS_C_IDENTIFY_FLAG;
    }

    if ((*ContextFlags & ISC_RET_EXTENDED_ERROR) != 0)
    {
        ChecksumBody->GssFlags |= GSS_C_EXTENDED_ERROR_FLAG;
    }

    if ((*ContextFlags & ISC_RET_DELEGATE) != 0)
    {
        ChecksumBody->GssFlags |= GSS_C_DELEG_FLAG;
        ChecksumBody->Delegation = 1;
        ChecksumBody->DelegationLength = (USHORT) KerbCredSize;
        RtlCopyMemory(
            ChecksumBody->DelegationInfo,
            KerbCred,
            KerbCredSize
            );
    }

    ChecksumBody->BindLength = 0x10;

    //
    // (viz. Windows Bugs 94818)
    // If channel bindings are absent, BindHash should be {0,0,0,0}
    //
    if( pChannelBindings == NULL )
    {
        RtlZeroMemory( ChecksumBody->BindHash, ChecksumBody->BindLength );
    }
    else
    {
        Status = KerbComputeGssBindHash( pChannelBindings, (PUCHAR)BindHash );

        if( !NT_SUCCESS(Status) )
        {
            goto Cleanup;
        }

        RtlCopyMemory( ChecksumBody->BindHash, BindHash, ChecksumBody->BindLength );
    }

    GssChecksum->checksum_type = GSS_CHECKSUM_TYPE;
    GssChecksum->checksum.length = ChecksumSize;
    GssChecksum->checksum.value = (PUCHAR) ChecksumBody;
    ChecksumBody = NULL;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (ChecksumBody != NULL)
        {
            KerbFree(ChecksumBody);
        }
    }
    if (TicketGrantingTicket != NULL)
    {
        KerbDereferenceTicketCacheEntry(TicketGrantingTicket);
    }

    if (KerbCred != NULL)
    {
        MIDL_user_free(KerbCred);
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildApRequest
//
//  Synopsis:   Builds an AP request message from a logon session and a
//              ticket cache entry.
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session used to build this AP request
//              Credential - Optional credential for use with supplemental credentials
//              TicketCacheEntry - Ticket with which to build the AP request
//              ErrorMessage - Optionally contains error message from last AP request
//              ContextFlags - Flags passed in by client indicating
//                      authentication requirements. If the flags can't
//                      be supported they will be turned off.
//              MarshalledApReqest - Receives a marshalled AP request allocated
//                      with KerbAllocate
//              ApRequestSize - Length of the AP reques structure in bytes
//              Nonce - Nonce used for this request. if non-zero, then the
//                      nonce supplied by the caller will be used.
//              SubSessionKey - if generated, returns a sub-session key in AP request
//              pAuthenticatorTime - timestamp placed on the AP request
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbBuildApRequest(
    IN PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry,
    IN OPTIONAL PKERB_ERROR ErrorMessage,
    IN ULONG ContextAttributes,
    IN OUT PULONG ContextFlags,
    OUT PUCHAR * MarshalledApRequest,
    OUT PULONG ApRequestSize,
    OUT PULONG Nonce,
    OUT OPTIONAL PTimeStamp pAuthenticatorTime,
    IN OUT PKERB_ENCRYPTION_KEY SubSessionKey,
    IN PSEC_CHANNEL_BINDINGS pChannelBindings
    )
{
    NTSTATUS Status;
    ULONG ApOptions = 0;
    KERBERR KerbErr;
    KERB_CHECKSUM GssChecksum = {0};
    PKERB_PRIMARY_CREDENTIAL PrimaryCredentials = NULL;
    TimeStamp ServerTime;
    ULONG RequestSize;
    PUCHAR RequestWithHeader = NULL;
    PUCHAR RequestStart;
    gss_OID MechId;
    BOOLEAN LogonSessionLocked = FALSE;

    *ApRequestSize = 0;
    *MarshalledApRequest = NULL;

    //
    // If we have an error message, use it to compute a skew time to adjust
    // local time by
    //

    if (ARGUMENT_PRESENT(ErrorMessage))
    {
        TimeStamp CurrentTime;
        GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);

        KerbWriteLockTicketCache();

        //
        // Update the skew cache the first time we fail to a server
        //

        if ((KERBERR) ErrorMessage->error_code == KRB_AP_ERR_SKEW)
        {
            if (KerbGetTime(TicketCacheEntry->TimeSkew) == 0)
            {
                KerbUpdateSkewTime(TRUE);
            }
        }
        KerbConvertGeneralizedTimeToLargeInt(
            &ServerTime,
            &ErrorMessage->server_time,
            ErrorMessage->server_usec
            );
        KerbSetTime(&TicketCacheEntry->TimeSkew, KerbGetTime(ServerTime) - KerbGetTime(CurrentTime));
        KerbUnlockTicketCache();
    }

    //
    // Allocate a nonce if we don't have one already.
    //

    if (*Nonce == 0)
    {
        *Nonce = KerbAllocateNonce();
    }

    D_DebugLog((DEB_TRACE,"BuildApRequest using nonce 0x%x\n",*Nonce));

    DsysAssert( !LogonSessionLocked );
    KerbReadLockLogonSessions(LogonSession);
    LogonSessionLocked = TRUE;

    if (ARGUMENT_PRESENT(Credential))
    {
        if (Credential->SuppliedCredentials != NULL)
        {
            PrimaryCredentials = Credential->SuppliedCredentials;
        }
    }

    // use cred manager creds if present
    if (ARGUMENT_PRESENT(CredManCredentials))
    {
        PrimaryCredentials = CredManCredentials->SuppliedCredentials;
    }

    if (PrimaryCredentials == NULL)
    {
        PrimaryCredentials = &LogonSession->PrimaryCredentials;
    }

    //
    // get the GSS checksum
    //

    Status = KerbBuildGssChecksum(
                LogonSession,
                PrimaryCredentials,
                TicketCacheEntry,
                ContextFlags,
                &GssChecksum,
                &ApOptions,
                pChannelBindings
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to build GSS checksum: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // If are an export client, create a subsession key. For datagram,
    // the caller passes in a pre-generated session key.
    //

    //
    // For datagram, they subsession key has already been set so we don't need
    // to create one here.
    //

    if ((((*ContextFlags & ISC_RET_DATAGRAM) == 0)) ||
        (((*ContextFlags & (ISC_RET_USED_DCE_STYLE | ISC_RET_MUTUAL_AUTH)) == 0) && !KerbGlobalUseStrongEncryptionForDatagram))
    {
        KERBERR KerbErr;

        //
        // First free the Subsession key, if there was one.
        //

        KerbFreeKey(SubSessionKey);

        KerbErr = KerbMakeKey(
                    TicketCacheEntry->SessionKey.keytype,
                    SubSessionKey
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }
    }

    //
    // Create the AP request
    //

    KerbReadLockTicketCache();

    //
    // Bug 464930: the KDC could generate a NULL client name,
    //             but doing so is clearly wrong
    //

    if ( TicketCacheEntry->ClientName == NULL ) {

        Status = STATUS_INVALID_PARAMETER;
        KerbUnlockTicketCache();
        goto Cleanup;
    }

    KerbErr = KerbCreateApRequest(
                TicketCacheEntry->ClientName,
                &TicketCacheEntry->ClientDomainName,
                &TicketCacheEntry->SessionKey,
                (SubSessionKey->keyvalue.value != NULL) ? SubSessionKey : NULL,
                *Nonce,
                pAuthenticatorTime,
                &TicketCacheEntry->Ticket,
                ApOptions,
                &GssChecksum,
                &TicketCacheEntry->TimeSkew,
                FALSE,                          // not a KDC request
                ApRequestSize,
                MarshalledApRequest
                );

    KerbUnlockTicketCache();

    DsysAssert( LogonSessionLocked );
    KerbUnlockLogonSessions(LogonSession);
    LogonSessionLocked = FALSE;

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to create AP request: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    //
    // If we aren't doing DCE style, add in the GSS token headers now
    //

    if ((*ContextFlags & ISC_RET_USED_DCE_STYLE) != 0)
    {
       goto Cleanup;
    }

    //
    // Pick the correct OID
    //

    if ((ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
    {
        MechId = gss_mech_krb5_u2u;
    }
    else
    {
        MechId = gss_mech_krb5_new;
    }

    RequestSize = g_token_size(MechId, *ApRequestSize);
    RequestWithHeader = (PUCHAR) KerbAllocate(RequestSize);
    if (RequestWithHeader == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // the g_make_token_header will reset this to point to the end of the
    // header
    //

    RequestStart = RequestWithHeader;

    g_make_token_header(
        MechId,
        *ApRequestSize,
        &RequestStart,
        KG_TOK_CTX_AP_REQ
        );

    DsysAssert(RequestStart - RequestWithHeader + *ApRequestSize == RequestSize);

    RtlCopyMemory(
        RequestStart,
        *MarshalledApRequest,
        *ApRequestSize
        );

    KerbFree(*MarshalledApRequest);
    *MarshalledApRequest = RequestWithHeader;
    *ApRequestSize = RequestSize;
    RequestWithHeader = NULL;

Cleanup:

    if (LogonSessionLocked)
    {
        KerbUnlockLogonSessions(LogonSession);
    }
    if (GssChecksum.checksum.value != NULL)
    {
        KerbFree(GssChecksum.checksum.value);
    }
    if (!NT_SUCCESS(Status) && (*MarshalledApRequest != NULL))
    {
        KerbFree(*MarshalledApRequest);
        *MarshalledApRequest = NULL;
    }
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildNullSessionApRequest
//
//  Synopsis:   builds an AP request for a null session
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbBuildNullSessionApRequest(
    OUT PUCHAR * MarshalledApRequest,
    OUT PULONG ApRequestSize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    KERB_AP_REQUEST ApRequest;
    UNICODE_STRING NullString = CONSTANT_UNICODE_STRING(L"");
    UCHAR TempBuffer[1];
    ULONG RequestSize;
    PUCHAR RequestWithHeader = NULL;
    PUCHAR RequestStart;

    RtlZeroMemory(
        &ApRequest,
        sizeof(KERB_AP_REQUEST)
        );


    TempBuffer[0] = '\0';

    //
    // Fill in the AP request structure.
    //

    ApRequest.version = KERBEROS_VERSION;
    ApRequest.message_type = KRB_AP_REQ;

    //
    // Fill in mandatory fields - ASN1/OSS requires this
    //

    if (!KERB_SUCCESS(KerbConvertStringToPrincipalName(
                        &ApRequest.ticket.server_name,
                        &NullString,
                        KRB_NT_UNKNOWN
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbConvertUnicodeStringToRealm(
                        &ApRequest.ticket.realm,
                        &NullString
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ApRequest.ticket.encrypted_part.cipher_text.length = 1;
    ApRequest.ticket.encrypted_part.cipher_text.value = TempBuffer;
    ApRequest.authenticator.cipher_text.length = 1;
    ApRequest.authenticator.cipher_text.value = TempBuffer;


    //
    // Now marshall the request
    //

    KerbErr = KerbPackApRequest(
                &ApRequest,
                ApRequestSize,
                MarshalledApRequest
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to pack AP request: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Since we never do null sessions with user-to-user, we don't have
    // to worry about which mech id to use
    //

    RequestSize = g_token_size((gss_OID) gss_mech_krb5_new, *ApRequestSize);

    RequestWithHeader = (PUCHAR) KerbAllocate(RequestSize);
    if (RequestWithHeader == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // the g_make_token_header will reset this to point to the end of the
    // header
    //

    RequestStart = RequestWithHeader;

    g_make_token_header(
        (gss_OID) gss_mech_krb5_new,
        *ApRequestSize,
        &RequestStart,
        KG_TOK_CTX_AP_REQ
        );

    DsysAssert(RequestStart - RequestWithHeader + *ApRequestSize == RequestSize);

    RtlCopyMemory(
        RequestStart,
        *MarshalledApRequest,
        *ApRequestSize
        );

    KerbFree(*MarshalledApRequest);
    *MarshalledApRequest = RequestWithHeader;
    *ApRequestSize = RequestSize;
    RequestWithHeader = NULL;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (*MarshalledApRequest != NULL)
        {
            MIDL_user_free(*MarshalledApRequest);
            *MarshalledApRequest = NULL;
        }
    }
    KerbFreeRealm(&ApRequest.ticket.realm);
    KerbFreePrincipalName(&ApRequest.ticket.server_name);
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbMakeSocketCall
//
//  Synopsis:   Contains logic for sending a message to a KDC in the
//              specified realm on a specified port
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMakeSocketCall(
    IN PUNICODE_STRING RealmName,
    IN OPTIONAL PUNICODE_STRING AccountName,
    IN BOOLEAN CallPDC,
    IN BOOLEAN UseTcp,
    IN BOOLEAN CallKpasswd,
    IN PKERB_MESSAGE_BUFFER RequestMessage,
    IN PKERB_MESSAGE_BUFFER ReplyMessage,
    IN OPTIONAL PKERB_BINDING_CACHE_ENTRY OptionalBindingHandle,
    IN ULONG AdditionalFlags,
    OUT PBOOLEAN CalledPDC
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    ULONG Retries;
    PKERB_BINDING_CACHE_ENTRY BindingHandle = NULL;
    ULONG DesiredFlags;
    ULONG Timeout = KerbGlobalKdcCallTimeout;


    //
    // If the caller wants a PDC, so be it
    //

    *CalledPDC = FALSE;

    if (CallPDC)
    {
        DesiredFlags = DS_PDC_REQUIRED;
    }
    else
    {
        DesiredFlags = 0;
    }

    //
    // Now actually get the ticket. We will retry twice.
    //
    if ((AdditionalFlags & DS_FORCE_REDISCOVERY) != 0)
    {
       DesiredFlags |= DS_FORCE_REDISCOVERY;
       D_DebugLog((DEB_TRACE,"KerbMakeSocketCall() caller wants rediscovery!\n"));
    }

    Retries = 0;
    do
    {
        //
        // don't force retry the first time
        //

        if (Retries > 0)
        {
            DesiredFlags |= DS_FORCE_REDISCOVERY;
            Timeout += KerbGlobalKdcCallBackoff;
        }

        // Use ADSI supplied info, then retry using cached version
        if (ARGUMENT_PRESENT(OptionalBindingHandle) && (Retries == 0))
        {
           BindingHandle = OptionalBindingHandle;
        }
        else
        {
           Status = KerbGetKdcBinding(
                        RealmName,
                        AccountName,
                        DesiredFlags,
                        CallKpasswd,
                        UseTcp,
                        &BindingHandle
                        );
        }

        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_WARN,"Failed to get KDC binding for %wZ: 0x%x\n",
                RealmName, Status));
            goto Cleanup;
        }

        //
        // If the KDC doesn't support TCP, don't use TCP. Otherwise
        // use it if the sending buffer is too big, or if it was already
        // set.
        //

        if ((BindingHandle->CacheFlags & KERB_BINDING_NO_TCP) != 0)
        {
            UseTcp = FALSE;
        }
        else
        {
            if  (RequestMessage->BufferSize > KerbGlobalMaxDatagramSize)
            {
                UseTcp = TRUE;
            }
        }

        //
        // Lock the binding while we make the call
        //

        if (!*CalledPDC)
        {
            *CalledPDC = (BindingHandle->Flags & DS_PDC_REQUIRED) ? (BOOLEAN) TRUE : (BOOLEAN) FALSE;
        }

#ifndef WIN32_CHICAGO
        if ((BindingHandle->CacheFlags & KERB_BINDING_LOCAL) != 0)
        {
            NTSTATUS TokenStatus;
            HANDLE ImpersonationToken = NULL;
            // Are we impersonating?
            TokenStatus = NtOpenThreadToken(
                                NtCurrentThread(),
                                TOKEN_QUERY | TOKEN_IMPERSONATE,
                                TRUE,
                                &ImpersonationToken
                                );

            if( NT_SUCCESS(TokenStatus) )
            {
                //
                // stop impersonating.
                //
                RevertToSelf();
            }

            KERB_MESSAGE_BUFFER KdcReplyMessage = {0};
            if (!CallKpasswd)
            {

                D_DebugLog((DEB_TRACE,"Calling kdc directly\n"));

                DsysAssert(KerbKdcGetTicket != NULL);
                KerbErr = (*KerbKdcGetTicket)(
                                NULL,           // no context,
                                NULL,           // no client address
                                NULL,           // no server address
                                RequestMessage,
                                &KdcReplyMessage
                                );
            }
            else
            {
                DsysAssert(KerbKdcChangePassword != NULL);
                KerbErr = (*KerbKdcChangePassword)(
                                NULL,           // no context,
                                NULL,           // no client address
                                NULL,           // no server address
                                RequestMessage,
                                &KdcReplyMessage
                                );
            }

            if( ImpersonationToken != NULL ) {

                //
                // put the thread token back if we were impersonating.
                //
                SetThreadToken( NULL, ImpersonationToken );
                NtClose( ImpersonationToken );
            }

            if (KerbErr != KDC_ERR_NOT_RUNNING)
            {
                //
                // Copy the data so it can be freed with MIDL_user_free.
                //

                if ((0 != KdcReplyMessage.BufferSize) && (NULL != KdcReplyMessage.Buffer))
                {
                    ReplyMessage->BufferSize = KdcReplyMessage.BufferSize;
                    ReplyMessage->Buffer = (PUCHAR) MIDL_user_allocate(
                            KdcReplyMessage.BufferSize);
                    if (ReplyMessage->Buffer != NULL)
                    {
                        RtlCopyMemory(
                            ReplyMessage->Buffer,
                            KdcReplyMessage.Buffer,
                            KdcReplyMessage.BufferSize
                            );
                    }
                    else
                    {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                    (*KerbKdcFreeMemory)(KdcReplyMessage.Buffer);
                }
                else
                {
                    DebugLog((DEB_ERROR, "KerbMakeSocketCall direct kdc call returned %#x and received no error message KdcReplyMessage.BufferSize %#x KdcReplyMessage.Buffer %p\n",
                        KerbErr, KdcReplyMessage.BufferSize, KdcReplyMessage.Buffer));
                    Status = STATUS_INSUFFICIENT_RESOURCES; // no message returned from KDC
                }
                goto Cleanup;
            }
            else
            {
                //
                // The KDC said it wasn't running.
                //

                KerbKdcStarted = FALSE;
                Status = STATUS_NETLOGON_NOT_STARTED;

                //
                // Get rid of the binding handle so we don't use it again.
                // Don't whack supplied optional binding handle though
                //
                if (BindingHandle != OptionalBindingHandle)
                {
                   KerbRemoveBindingCacheEntry( BindingHandle );
                }
            }
        }

        else
#endif // WIN32_CHICAGO
        {
            DebugLog((DEB_TRACE_BND_CACHE, "Calling kdc %wZ for realm %S\n", &BindingHandle->KdcAddress, RealmName->Buffer));
            Status =  KerbCallKdc(
                        &BindingHandle->KdcAddress,
                        BindingHandle->AddressType,
                        Timeout,
                        !UseTcp,
                        CallKpasswd ? (USHORT) KERB_KPASSWD_PORT : (USHORT) KERB_KDC_PORT,
                        RequestMessage,
                        ReplyMessage
                        );

            if (!NT_SUCCESS(Status) )
            {
                //
                // If the request used UDP and we got an invalid buffer size error,
                // try again with TCP.
                //

                if ((Status == STATUS_INVALID_BUFFER_SIZE) && (!UseTcp)) {

                    if ((BindingHandle->CacheFlags & KERB_BINDING_NO_TCP) == 0)
                    {

                        UseTcp = TRUE;
                        Status =  KerbCallKdc(
                                    &BindingHandle->KdcAddress,
                                    BindingHandle->AddressType,
                                    Timeout,
                                    !UseTcp,
                                    CallKpasswd ? (USHORT) KERB_KPASSWD_PORT : (USHORT) KERB_KDC_PORT,
                                    RequestMessage,
                                    ReplyMessage
                                    );
                    }
                }

                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "Failed to get make call to KDC %wZ: 0x%x. %ws, line %d\n",
                        &BindingHandle->KdcAddress, Status, THIS_FILE, __LINE__));
                    //
                    // The call itself failed, so the binding handle was bad.
                    // Free it now, unless supplied as optional binding handle.
                    //
                    if (BindingHandle != OptionalBindingHandle)
                    {
                       KerbRemoveBindingCacheEntry( BindingHandle );
                    }
                }
            }
        }

        if (BindingHandle != OptionalBindingHandle)
        {
           KerbDereferenceBindingCacheEntry( BindingHandle );
           Retries++;
        }

        BindingHandle = NULL;

    } while ( !NT_SUCCESS(Status) && (Retries < KerbGlobalKdcSendRetries) );

Cleanup:

    //
    // monitor UDP transmission quality.
    //
    if (!UseTcp)
    {
        if ( !NT_SUCCESS(Status)  &&
           ( Retries == KerbGlobalKdcSendRetries ))
        {
            DebugLog((DEB_ERROR, "We look to be timing out on UDP \n"));
            KerbReportTransportError(Status);
        }
        else if (NT_SUCCESS(Status) && ( Retries < KerbGlobalKdcSendRetries ))
        {
            KerbResetTransportCounter();
        }
    }

    if ((BindingHandle != NULL) && (BindingHandle != OptionalBindingHandle))
    {
        KerbDereferenceBindingCacheEntry(BindingHandle);
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbMakeKdcCall
//
//  Synopsis:   Contains logic for calling a KDC including binding and
//              retrying.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMakeKdcCall(
    IN PUNICODE_STRING RealmName,
    IN OPTIONAL PUNICODE_STRING AccountName,
    IN BOOLEAN CallPDC,
    IN BOOLEAN UseTcp,
    IN PKERB_MESSAGE_BUFFER RequestMessage,
    IN PKERB_MESSAGE_BUFFER ReplyMessage,
    IN ULONG AdditionalFlags,
    OUT PBOOLEAN CalledPDC
    )
{

   if (ARGUMENT_PRESENT(AccountName))
   {
      D_DebugLog((DEB_ERROR, "[trace info] Making DsGetDcName w/ account name\n"));
   }

   return(KerbMakeSocketCall(
            RealmName,
            AccountName,
            CallPDC,
            UseTcp,
            FALSE,                      // don't call Kpasswd
            RequestMessage,
            ReplyMessage,
            NULL, // optional binding cache handle, for kpasswd only
            AdditionalFlags,
            CalledPDC
            ));
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbComputeTgsChecksum
//
//  Synopsis:   computes the checksum of a TGS request body by marshalling
//              the request and the checksumming it.
//
//  Effects:    Allocates destination with KerbAllocate().
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbComputeTgsChecksum(
    IN PKERB_KDC_REQUEST_BODY RequestBody,
    IN PKERB_ENCRYPTION_KEY Key,
    IN ULONG ChecksumType,
    OUT PKERB_CHECKSUM Checksum
    )
{
    PCHECKSUM_FUNCTION ChecksumFunction;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    KERB_MESSAGE_BUFFER MarshalledRequestBody = {0, NULL};
    NTSTATUS Status;

    RtlZeroMemory(
        Checksum,
        sizeof(KERB_CHECKSUM)
        );

    Status = CDLocateCheckSum(
                ChecksumType,
                &ChecksumFunction
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Allocate enough space for the checksum
    //

    Checksum->checksum.value = (PUCHAR) KerbAllocate(ChecksumFunction->CheckSumSize);
    if (Checksum->checksum.value == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    Checksum->checksum.length = ChecksumFunction->CheckSumSize;
    Checksum->checksum_type = (int) ChecksumType;

    // don't av here.

    if ((ChecksumType == KERB_CHECKSUM_REAL_CRC32) ||
        (ChecksumType == KERB_CHECKSUM_CRC32))
    {
        if (ChecksumFunction->Initialize)
        {
            Status = ChecksumFunction->Initialize(
                        0,
                        &CheckBuffer
                        );
        }
        else
        {
            Status = STATUS_CRYPTO_SYSTEM_INVALID;
        }
    }
    else
    {
        if (ChecksumFunction->InitializeEx2)
        {
            Status = ChecksumFunction->InitializeEx2(
                        Key->keyvalue.value,
                        (ULONG) Key->keyvalue.length,
                        NULL,
                        KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT,
                        &CheckBuffer
                        );
        }
        else if (ChecksumFunction->InitializeEx)
        {
            Status = ChecksumFunction->InitializeEx(
                        Key->keyvalue.value,
                        (ULONG) Key->keyvalue.length,
                        KERB_TGS_REQ_AP_REQ_AUTH_CKSUM_SALT,
                        &CheckBuffer
                        );
        }
        else
        {
            Status = STATUS_CRYPTO_SYSTEM_INVALID;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbPackData(
                        RequestBody,
                        KERB_MARSHALLED_REQUEST_BODY_PDU,
                        &MarshalledRequestBody.BufferSize,
                        &MarshalledRequestBody.Buffer
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Now checksum the buffer
    //

    ChecksumFunction->Sum(
        CheckBuffer,
        MarshalledRequestBody.BufferSize,
        MarshalledRequestBody.Buffer
        );

    ChecksumFunction->Finalize(
        CheckBuffer,
        Checksum->checksum.value
        );

Cleanup:
    if (CheckBuffer != NULL)
    {
        ChecksumFunction->Finish(&CheckBuffer);
    }
    if (MarshalledRequestBody.Buffer != NULL)
    {
        MIDL_user_free(MarshalledRequestBody.Buffer);
    }
    if (!NT_SUCCESS(Status) && (Checksum->checksum.value != NULL))
    {
        MIDL_user_free(Checksum->checksum.value);
        Checksum->checksum.value = NULL;
    }
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbGetTgsTicket
//
//  Synopsis:   Gets a ticket to the specified target with the specified
//              options.
//
//  Effects:
//
//  Arguments:  ClientRealm
//              TicketGrantingTicket - TGT to use for the TGS request
//              TargetName - Name of the target for which to obtain a ticket.
//              TicketOptions - Optionally contains requested KDC options flags
//              Flags
//              TicketOptions
//              EncryptionType - Optionally contains requested encryption type
//              AuthorizationData - Optional authorization data to stick
//                      in the ticket.
//              KdcReply - the ticket to be used for getting a ticket with
//                      the enc_tkt_in_skey flag.
//              ReplyBody - Receives the kdc reply.
//              pRetryFlags
//
//  Requires:
//
//  Returns:    Kerberos errors and NT errors
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbGetTgsTicket(
    IN PUNICODE_STRING ClientRealm,
    IN PKERB_TICKET_CACHE_ENTRY TicketGrantingTicket,
    IN PKERB_INTERNAL_NAME TargetName,
    IN ULONG Flags,
    IN OPTIONAL ULONG TicketOptions,
    IN OPTIONAL ULONG EncryptionType,
    IN OPTIONAL PKERB_AUTHORIZATION_DATA AuthorizationData,
    IN OPTIONAL PKERB_PA_DATA_LIST PADataList,
    IN OPTIONAL PKERB_TGT_REPLY TgtReply,
    IN OPTIONAL PKERB_TICKET EvidenceTicket,
    IN OPTIONAL PTimeStamp OptionalEndTime,
    OUT PKERB_KDC_REPLY * KdcReply,
    OUT PKERB_ENCRYPTED_KDC_REPLY * ReplyBody,
    OUT PULONG pRetryFlags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    ULONG Index = 0;
    KERB_KDC_REQUEST TicketRequest;
    PKERB_KDC_REQUEST_BODY RequestBody = &TicketRequest.request_body;
    PULONG CryptVector = NULL;
    ULONG EncryptionTypeCount = 0;
    PKERB_EXT_ERROR pExtendedError = NULL;
    ULONG Nonce;
    TimeStamp AuthenticatorTime = {0};
    KERB_PA_DATA_LIST ApRequest = {0};
    KERBERR KerbErr;
    KERB_MESSAGE_BUFFER RequestMessage = {0, NULL};
    KERB_MESSAGE_BUFFER ReplyMessage = {0, NULL};
    BOOLEAN DoRetryGetTicket = FALSE;
    BOOLEAN RetriedOnce = FALSE;
    UNICODE_STRING TempDomainName = NULL_UNICODE_STRING;
    KERB_CHECKSUM RequestChecksum = {0};
    BOOLEAN CalledPdc;
    KERB_TICKET_LIST TicketList[2];
    ULONG KdcOptions = 0;
    ULONG KdcFlagOptions;
    PKERB_MIT_REALM MitRealm = NULL;
    BOOLEAN UsedAlternateName = FALSE;
    BOOLEAN UseTcp = FALSE;
    BOOLEAN fMitRealmPossibleRetry = FALSE;

    D_DebugLog((DEB_TRACE, "KerbGetTgsTicket Flags %#x, ClientRealm %wZ, Tgt DomainName %wZ, Tgt TargetDomainName %wZ, TgtReply %p, EvidenceTicket %p, TargetName ",
                Flags, ClientRealm, &TicketGrantingTicket->DomainName, &TicketGrantingTicket->TargetDomainName, TgtReply, EvidenceTicket));
    D_KerbPrintKdcName((DEB_TRACE, TargetName));

    BOOLEAN TicketCacheLocked = FALSE;
    KERB_ENCRYPTED_DATA EncAuthData = {0};

#ifdef RESTRICTED_TOKEN

     if (AuthorizationData != NULL)
     {
         Status = KerbBuildEncryptedAuthData(
                    &EncAuthData,
                    TicketGrantingTicket,
                    AuthorizationData
                    );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to encrypt auth data: 0x%x\n",Status));
            goto Cleanup;
        }
     }
#endif

    //
    // This is the retry point if we need to retry getting a TGS ticket
    //

RetryGetTicket:

    RtlZeroMemory(
        &ApRequest,
        sizeof(KERB_PA_DATA_LIST)
        );

    RtlZeroMemory(
        &RequestChecksum,
        sizeof(KERB_CHECKSUM)
        );

    RtlZeroMemory(
        &TicketRequest,
        sizeof(KERB_KDC_REQUEST)
        );

    *KdcReply = NULL;
    *ReplyBody = NULL;

    //
    // Fill in the ticket request with the defaults.
    //
    if (!ARGUMENT_PRESENT( OptionalEndTime ))
    {
        KerbConvertLargeIntToGeneralizedTime(
            &RequestBody->endtime,
            NULL,
            &KerbGlobalWillNeverTime // use HasNeverTime instead
            );
    }
    else
    {
        KerbConvertLargeIntToGeneralizedTime(
            &RequestBody->endtime,
            NULL,
            OptionalEndTime
            );
    }

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_renew_until,
        NULL,
        &KerbGlobalHasNeverTime // use HasNeverTime instead
        );

    //
    // If the caller supplied kdc options, use those
    //

    if (TicketOptions != 0)
    {
        KdcOptions = TicketOptions;
    }
    else
    {
        //
        // Some missing (TGT) ticket options will result in a ticket not being
        // granted.  Others (such as name_canon.) will be usable by W2k KDCs
        // Make sure we can modify these so we can turn "on" various options
        // later.
        //

        KdcOptions = (KERB_DEFAULT_TICKET_FLAGS &
                      TicketGrantingTicket->TicketFlags) |
                      KerbGlobalKdcOptions;
    }

    Nonce = KerbAllocateNonce();

    RequestBody->nonce = Nonce;
    if (AuthorizationData != NULL)
    {
        RequestBody->enc_authorization_data = EncAuthData;
        RequestBody->bit_mask |= enc_authorization_data_present;
    }

    //
    // Build crypt vector.
    //

    //
    // First get the count of encryption types
    //

    (VOID) CDBuildIntegrityVect( &EncryptionTypeCount, NULL );

    //
    // Now allocate the crypt vector
    //

    SafeAllocaAllocate(CryptVector, sizeof(ULONG) * EncryptionTypeCount);

    if (CryptVector == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Now get the list of encrypt types
    //

    (VOID) CDBuildIntegrityVect( &EncryptionTypeCount, CryptVector );

    if (EncryptionTypeCount == 0)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // If caller didn't specify a favorite etype, send all that we support
    //

    if (EncryptionType != 0)
    {
        //
        // Swap the first one with the encryption type requested.
        // do this only if the first isn't already what is requested.
        //

        UINT i = 0;
        ULONG FirstOne = CryptVector[0];
        if (CryptVector[i] != EncryptionType)
        {

            CryptVector[i] = EncryptionType;
            for ( i = 1; i < EncryptionTypeCount;i++)
            {
                if (CryptVector[i] == EncryptionType)
                {
                    CryptVector[i] = FirstOne;
                    break;
                }
            }
        }
    }

    //
    // convert the array to a crypt list in the request
    //

    if (!KERB_SUCCESS(KerbConvertArrayToCryptList(
                        &RequestBody->encryption_type,
                        CryptVector,
                        EncryptionTypeCount,
                        FALSE)))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // If a TGT reply is present, stick the TGT into the ticket in the
    // additional tickets field and include set the enc_tkt_in_skey option.
    // The ticket that comes back will be encrypted with the session key
    // from the supplied TGT.
    //
    // For S4U, we present the evidence ticket.
    //
    // See gettgs.cxx, UnpackAdditionalTickets() for details.
    //

    Index = 0;

    if (ARGUMENT_PRESENT( TgtReply ))
    {
        ASSERT(Index == 0);
        D_DebugLog((DEB_TRACE_U2U, "KerbGetTgsTicket setting KERB_KDC_OPTIONS_enc_tkt_in_skey (index %d)\n", Index));

        TicketList[Index].next = NULL;
        TicketList[Index].value = TgtReply->ticket;
        KdcOptions |= KERB_KDC_OPTIONS_enc_tkt_in_skey;

        //
        // increment Index
        //

        Index++;
    }

    if (ARGUMENT_PRESENT( EvidenceTicket))
    {
        ASSERT(Index < 2);

        D_DebugLog((DEB_TRACE, "KerbGetTgsTicket setting KERB_KDC_OPTIONS_cname_in_addl_tkt (index %d)\n", Index));

        if (Index > 0)
        {
            TicketList[Index - 1].next = &TicketList[Index];
        }

        TicketList[Index].next = NULL;
        TicketList[Index].value = (*EvidenceTicket);
        KdcOptions |= KERB_KDC_OPTIONS_cname_in_addl_tkt;
    }

    if ((KdcOptions & (KERB_KDC_OPTIONS_enc_tkt_in_skey | KERB_KDC_OPTIONS_cname_in_addl_tkt)) != 0)
    {
        RequestBody->additional_tickets = &TicketList[0];
        RequestBody->bit_mask |= additional_tickets_present;
    }

    //
    // Fill in the strings in the ticket request
    //

    if (!KERB_SUCCESS(KerbConvertKdcNameToPrincipalName(
                        &RequestBody->KERB_KDC_REQUEST_BODY_server_name,
                        TargetName
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_server_name_present;

    //
    // Copy the domain name so we don't need to hold the lock
    //

    Status = KerbDuplicateString(
                &TempDomainName,
                &TicketGrantingTicket->TargetDomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Check if this is an MIT kdc or if the spn had a realm in it (e.g,
    // a/b/c@realm - if so, turn off name canonicalization
    //

    if ((Flags & KERB_GET_TICKET_NO_CANONICALIZE) != 0)
    {
        KdcOptions &= ~KERB_KDC_OPTIONS_name_canonicalize;
    }

    else if (KerbLookupMitRealm(
                &TempDomainName,
                &MitRealm,
                &UsedAlternateName
                ))
    {
        //
        // So the user is getting a ticket from an MIT realm. This means
        // if the MIT realm flags don't indicate that name canonicalization
        // is supported then we don't ask for name canonicalization
        //

        if ((MitRealm->Flags & KERB_MIT_REALM_DOES_CANONICALIZE) == 0)
        {
            fMitRealmPossibleRetry = TRUE;
            KdcOptions &= ~KERB_KDC_OPTIONS_name_canonicalize;
        }
        else
        {
            KdcOptions |= KERB_KDC_OPTIONS_name_canonicalize;
        }
    }

    KdcFlagOptions = KerbConvertUlongToFlagUlong(KdcOptions);
    RequestBody->kdc_options.length = sizeof(ULONG) * 8;
    RequestBody->kdc_options.value = (PUCHAR) &KdcFlagOptions;

    //
    // Marshall the request and compute a checksum of it
    //
    if (!KERB_SUCCESS(KerbConvertUnicodeStringToRealm(
                        &RequestBody->realm,
                        &TempDomainName
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    DsysAssert( !TicketCacheLocked );
    KerbReadLockTicketCache();
    TicketCacheLocked = TRUE;

    //
    // Now compute a checksum of that data
    //

    Status = KerbComputeTgsChecksum(
                RequestBody,
                &TicketGrantingTicket->SessionKey,
                (MitRealm != NULL) ? MitRealm->ApReqChecksumType : KERB_DEFAULT_AP_REQ_CSUM,
                &RequestChecksum
                );
    if (!NT_SUCCESS(Status))
    {
        KerbUnlockTicketCache();
        TicketCacheLocked = FALSE;
        goto Cleanup;
    }

    //
    // Create the AP request to the KDC for the ticket to the service
    //

RetryWithTcp:

    //
    // Lock the ticket cache while we access the cached tickets
    //

    KerbErr = KerbCreateApRequest(
                TicketGrantingTicket->ClientName,
                ClientRealm,
                &TicketGrantingTicket->SessionKey,
                NULL,                           // no subsessionkey
                Nonce,
                &AuthenticatorTime,
                &TicketGrantingTicket->Ticket,
                0,                              // no AP options
                &RequestChecksum,
                &TicketGrantingTicket->TimeSkew, // server time
                TRUE,                           // kdc request
                (PULONG) &ApRequest.value.preauth_data.length,
                &ApRequest.value.preauth_data.value
                );

    DsysAssert( TicketCacheLocked );
    KerbUnlockTicketCache();
    TicketCacheLocked = FALSE;

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to create authenticator: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ApRequest.next = NULL;
    ApRequest.value.preauth_data_type = KRB5_PADATA_TGS_REQ;
    TicketRequest.KERB_KDC_REQUEST_preauth_data = &ApRequest;
    TicketRequest.bit_mask |= KERB_KDC_REQUEST_preauth_data_present;

    // Insert additonal preauth into list
    if (ARGUMENT_PRESENT(PADataList))
    {
        // better be NULL padatalist
        ApRequest.next = PADataList;
    }
    else
    {
        ApRequest.next = NULL;
    }

    //
    // Marshall the request
    //

    TicketRequest.version = KERBEROS_VERSION;
    TicketRequest.message_type = KRB_TGS_REQ;

    //
    // Pack the request
    //

    KerbErr = KerbPackTgsRequest(
                &TicketRequest,
                &RequestMessage.BufferSize,
                &RequestMessage.Buffer
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Now actually get the ticket. We will retry once.
    //

    Status = KerbMakeKdcCall(
                &TempDomainName,
                NULL,           // **NEVER* call w/ account
                FALSE,          // don't require PDC
                UseTcp,
                &RequestMessage,
                &ReplyMessage,
                0, // no additional flags (yet)
                &CalledPdc
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to call KDC for TGS request: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    KerbErr = KerbUnpackTgsReply(
                ReplyMessage.Buffer,
                ReplyMessage.BufferSize,
                KdcReply
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        PKERB_ERROR ErrorMessage = NULL;
        DebugLog((DEB_WARN, "KerbGetTgsTicket failed to unpack KDC reply: 0x%x\n", KerbErr));

        //
        // Try to unpack it as kerb_error
        //

        KerbErr = KerbUnpackKerbError(
                        ReplyMessage.Buffer,
                        ReplyMessage.BufferSize,
                        &ErrorMessage
                        );
        if (KERB_SUCCESS(KerbErr))
        {
            if (ErrorMessage->bit_mask & error_data_present)
            {
                KerbUnpackErrorData(
                    ErrorMessage,
                    &pExtendedError
                    );
            }

           KerbErr = (KERBERR) ErrorMessage->error_code;

           KerbReportKerbError(
                TargetName,
                &TempDomainName,
                NULL,
                NULL,
                KLIN(FILENO, __LINE__),
                ErrorMessage,
                KerbErr,
                pExtendedError,
                FALSE
                );

            //
            // Check for time skew. If we got a skew error, record the time
            // skew between here and the KDC in the ticket so we can retry
            // with the correct time.
            //

            if (KerbErr == KRB_AP_ERR_SKEW)
            {
                TimeStamp CurrentTime;
                TimeStamp KdcTime;

                //
                // Only update failures with the same ticket once
                //

                if (KerbGetTime(TicketGrantingTicket->TimeSkew) == 0)
                {
                    KerbUpdateSkewTime(TRUE);
                }

                GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);

                KerbConvertGeneralizedTimeToLargeInt(
                    &KdcTime,
                    &ErrorMessage->server_time,
                    ErrorMessage->server_usec
                    );

                KerbWriteLockTicketCache();
#if 0
                D_DebugLog(( DEB_WARN, "KDC time : \n" ));
                DebugDisplayTime( DEB_WARN, (PFILETIME)&KdcTime);
                D_DebugLog(( DEB_WARN, "Current time : \n" ));
                DebugDisplayTime( DEB_WARN, (PFILETIME)&CurrentTime);
#endif
                KerbSetTime(&TicketGrantingTicket->TimeSkew, KerbGetTime(KdcTime) - KerbGetTime(CurrentTime));

                KerbUnlockTicketCache();
                DoRetryGetTicket = TRUE;
            }
            else if ((KerbErr == KRB_ERR_RESPONSE_TOO_BIG) && (!UseTcp))
            {
                //
                // The KDC response was too big to fit in a datagram. If
                // we aren't already using TCP use it now. Clean up allocated memory from UDP try
                //
                UseTcp = TRUE;
                KerbFreeKerbError(ErrorMessage);
                ErrorMessage = NULL;
                MIDL_user_free(ReplyMessage.Buffer);
                ReplyMessage.Buffer = NULL;

                MIDL_user_free(RequestMessage.Buffer);
                RequestMessage.Buffer = NULL;
                
                MIDL_user_free(ApRequest.value.preauth_data.value);
                ApRequest.value.preauth_data.value = NULL;

                DsysAssert( !TicketCacheLocked );
                KerbReadLockTicketCache();
                TicketCacheLocked = TRUE;
                goto RetryWithTcp;
            }
            else if (KerbErr == KDC_ERR_S_PRINCIPAL_UNKNOWN)
            {
                if (EXT_CLIENT_INFO_PRESENT(pExtendedError) && (STATUS_USER2USER_REQUIRED == pExtendedError->status))
                {
                    DebugLog((DEB_WARN, "KerbGetTgsTicket received KDC_ERR_S_PRINCIPAL_UNKNOWN and STATUS_USER2USER_REQUIRED\n"));
                    Status = STATUS_USER2USER_REQUIRED;
                    KerbFreeKerbError(ErrorMessage);
                    goto Cleanup;
                }
                //
                // This looks to be the MIT Realm retry case, where name canonicalization
                // is not on and the PRINCIPAL_UNKNOWN was returned by the MIT KDC
                //
                else if (fMitRealmPossibleRetry)
                {
                    *pRetryFlags |= KERB_MIT_NO_CANONICALIZE_RETRY;
                    D_DebugLog((DEB_TRACE, "KerbGetTgsTicket KerbCallKdc this is the MIT retry case\n"));
                }
            }

            //
            // Semi-hack here.  Bad option rarely is returned, and usually
            // indicates your TGT is about to expire.  TKT_EXPIRED is also
            // potentially recoverable. Check the e_data to
            // see if we should blow away TGT to fix TGS problem.
            //

            else if ((KerbErr == KDC_ERR_BADOPTION) ||
                     (KerbErr == KRB_AP_ERR_TKT_EXPIRED))
            {
                if (NULL != pExtendedError)
                {
                    Status = pExtendedError->status;
                    if ( Status == STATUS_TIME_DIFFERENCE_AT_DC )
                    {
                        *pRetryFlags |= KERB_RETRY_WITH_NEW_TGT;
                        D_DebugLog((DEB_TRACE, "Hit bad option retry case - %x \n", KerbErr));
                    }
                    else if ( Status == STATUS_NO_MATCH )
                    {
                        DebugLog((DEB_TRACE_S4U, "No match on S4UTarget\n"));
                        *pRetryFlags |= KERB_RETRY_NO_S4UMATCH;
                        KerbFreeKerbError(ErrorMessage);
                        goto Cleanup;
                    }
                    else if ( Status == STATUS_NOT_SUPPORTED )
                    {
                        D_DebugLog((DEB_TRACE_S4U, "No S4U available\n"));
                        *pRetryFlags |= KERB_RETRY_DISABLE_S4U;
                        KerbFreeKerbError(ErrorMessage);
                        goto Cleanup;
                    }
                }
                else
                {
                    //
                    // If we get BADOPTION on an S4U request, we've got to
                    // assume that our server doesn't support it.  There are some
                    // fringe cases where this may not be a reliable mechanism,
                    // however. FESTER - investigate other BADOPTION cases
                    //
                    D_DebugLog((DEB_TRACE_S4U, "No S4U available\n"));
                    *pRetryFlags |= KERB_RETRY_DISABLE_S4U;
                }
            }
            //
            // Per bug 315833, we purge on these errors as well
            //
            else if ((KerbErr == KDC_ERR_C_OLD_MAST_KVNO) ||
                     (KerbErr == KDC_ERR_TGT_REVOKED) ||
                     (KerbErr == KDC_ERR_NEVER_VALID) ||
                     (KerbErr == KRB_AP_ERR_BAD_INTEGRITY))
            {
                *pRetryFlags |= KERB_RETRY_WITH_NEW_TGT; 
                D_DebugLog((DEB_TRACE, " KerbGetTgsTicket got error requiring new tgt\n"));
                if (EXT_CLIENT_INFO_PRESENT(pExtendedError))
                {
                    Status = pExtendedError->status;
                }
                else
                {
                    Status = KerbMapKerbError(KerbErr);
                }

                DebugLog((DEB_WARN, "KerbGetTgsTicket failed w/ error %x, status %x\n", KerbErr, Status));
                KerbFreeKerbError(ErrorMessage);
                goto Cleanup;

            }
            else if ( KerbErr == KDC_ERR_CLIENT_REVOKED )
            {
                if (EXT_CLIENT_INFO_PRESENT(pExtendedError))
                {
                    Status = pExtendedError->status;
                }
                else
                {
                    Status = KerbMapKerbError(KerbErr);
                }

                DebugLog((DEB_WARN, "KerbGetTgsTicket CLIENTREVOKED status %x\n",Status));
                KerbFreeKerbError(ErrorMessage);
                goto Cleanup;

            }   
            else if ( KerbErr == KDC_ERR_POLICY )
            {
                if (EXT_CLIENT_INFO_PRESENT(pExtendedError))
                {
                    Status = pExtendedError->status;
                }
                else
                {
                    Status = KerbMapKerbError(KerbErr);
                }

                DebugLog((DEB_WARN, "KerbGetTgsTicket failed w/ error %x, status %x\n", KerbErr, Status));
                KerbFreeKerbError(ErrorMessage);
                goto Cleanup;
            }  
            else if (KerbErr == KDC_ERR_NONE)
            {
                DebugLog((DEB_ERROR, "KerbGetTgsTicket KerbCallKdc: error KDC_ERR_NONE\n"));
                KerbErr = KRB_ERR_GENERIC;
            }

            KerbFreeKerbError(ErrorMessage);
            DebugLog((DEB_WARN, "KerbGetTgsTicket KerbCallKdc: error 0x%x\n", KerbErr));
            Status = KerbMapKerbError(KerbErr);
        }
        else
        {
            Status = STATUS_LOGON_FAILURE;
        }
        goto Cleanup;
    }

    //
    // Now unpack the reply body:
    //

    KerbReadLockTicketCache();

    KerbErr = KerbUnpackKdcReplyBody(
                &(*KdcReply)->encrypted_part,
                &TicketGrantingTicket->SessionKey,
                KERB_ENCRYPTED_TGS_REPLY_PDU,
                ReplyBody
                );

    KerbUnlockTicketCache();

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR, "KerbGetTgsTicket failed to decrypt KDC reply body: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Verify the nonce is correct:
    //

    if (RequestBody->nonce != (*ReplyBody)->nonce)
    {
        D_DebugLog((DEB_ERROR, "KerbGetTgsTicket AS Nonces don't match: 0x%x vs 0x%x. %ws, line %d\n",
            RequestBody->nonce,
            (*ReplyBody)->nonce, THIS_FILE, __LINE__));
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

Cleanup:

    if (EncAuthData.cipher_text.value != NULL)
    {
        MIDL_user_free(EncAuthData.cipher_text.value);
    }
    if (RequestChecksum.checksum.value != NULL)
    {
        KerbFree(RequestChecksum.checksum.value);
    }

    SafeAllocaFree(CryptVector);
    CryptVector = NULL;

    KerbFreeCryptList(
        RequestBody->encryption_type
        );


    if (ReplyMessage.Buffer != NULL)
    {
        MIDL_user_free(ReplyMessage.Buffer);
        ReplyMessage.Buffer = NULL;
    }

    if (RequestMessage.Buffer != NULL)
    {
        MIDL_user_free(RequestMessage.Buffer);
        RequestMessage.Buffer = NULL;
    }

    if (ApRequest.value.preauth_data.value != NULL)
    {
        MIDL_user_free(ApRequest.value.preauth_data.value);
        ApRequest.value.preauth_data.value = NULL;
    }

    KerbFreePrincipalName(
        &RequestBody->KERB_KDC_REQUEST_BODY_server_name
        );

    KerbFreeRealm(
        &RequestBody->realm
        );
    KerbFreeString(
        &TempDomainName
        );

    if (NULL != pExtendedError)
    {
       KerbFreeData(KERB_EXT_ERROR_PDU, pExtendedError);
       pExtendedError = NULL;
    }

    //
    // If we should retry getting the ticket and we haven't already retried
    // once, try again.
    //

    if (DoRetryGetTicket && !RetriedOnce)
    {   
        RetriedOnce = TRUE;
        goto RetryGetTicket;
    }   

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetReferralNames
//
//  Synopsis:   Gets the referral names from a KDC reply. If none are present,
//              returned strings are empty.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetReferralNames(
    IN PKERB_ENCRYPTED_KDC_REPLY KdcReply,
    IN PKERB_INTERNAL_NAME OriginalTargetName,
    OUT PUNICODE_STRING ReferralRealm
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST PaEntry;
    PKERB_PA_SERV_REFERRAL ReferralInfo = NULL;
    KERBERR KerbErr;
    PKERB_INTERNAL_NAME TargetName = NULL;
    PKERB_INTERNAL_NAME KpasswdName = NULL;

    RtlInitUnicodeString(
        ReferralRealm,
        NULL
        );


    PaEntry = (PKERB_PA_DATA_LIST) KdcReply->encrypted_pa_data;

    //
    // Search the list for the referral infromation
    //

    while (PaEntry != NULL)
    {
        if (PaEntry->value.preauth_data_type == KRB5_PADATA_REFERRAL_INFO)
        {
            break;
        }
        PaEntry = PaEntry->next;
    }
    if (PaEntry == NULL)
    {

        //
        // Check to see if the server name is krbtgt - if it is, then
        // this is a referral.
        //

        KerbErr = KerbConvertPrincipalNameToKdcName(
                    &TargetName,
                    &KdcReply->server_name
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }

        //
        // Build the service name for the ticket
        //

        Status = KerbBuildKpasswdName(
                    &KpasswdName
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if ((TargetName->NameCount == 2) &&
             RtlEqualUnicodeString(
                    &KerbGlobalKdcServiceName,
                    &TargetName->Names[0],
                    FALSE                               // not case sensitive
                    ) &&
            !(KerbEqualKdcNames(
                OriginalTargetName,
                TargetName) ||
             KerbEqualKdcNames(
                OriginalTargetName,
                KpasswdName) ))
        {
                //
                // This is a referral, so set the referral name to the
                // second portion of the name
                //

                Status = KerbDuplicateString(
                            ReferralRealm,
                            &TargetName->Names[1]
                            );
        }

        KerbFreeKdcName(&TargetName);
        KerbFreeKdcName(&KpasswdName);

        return(Status);
    }

    //
    // Now try to unpack the data
    //

    KerbErr = KerbUnpackData(
                PaEntry->value.preauth_data.value,
                PaEntry->value.preauth_data.length,
                KERB_PA_SERV_REFERRAL_PDU,
                (PVOID *) &ReferralInfo
                );
    if (!KERB_SUCCESS( KerbErr ))
    {
        D_DebugLog((DEB_ERROR,"Failed to decode referral info: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    if (!KERB_SUCCESS(KerbConvertRealmToUnicodeString(
            ReferralRealm,
            &ReferralInfo->referred_server_realm
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

Cleanup:

    KerbFreeKdcName(&TargetName);
    KerbFreeKdcName(&KpasswdName);

    if (ReferralInfo != NULL)
    {
        KerbFreeData(
            KERB_PA_SERV_REFERRAL_PDU,
            ReferralInfo
            );
    }
    if (!NT_SUCCESS(Status))
    {
        KerbFreeString(
            ReferralRealm
            );
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbMITGetMachineDomain
//
//  Synopsis:   Determines if the machine is in a Windows 2000 domain and
//              if it is then the function attempts to get a TGT for this
//              domain with the passed in credentials.
//
//  Effects:
//
//  Arguments:  LogonSession - the logon session to use for ticket caching
//                      and the identity of the caller.
//              Credential - the credential of the caller
//              TargetName - Name of the target for which to obtain a ticket.
//              TargetDomainName - Domain name of target
//              ClientRealm - the realm of the machine which the retry will use
//              TicketGrantingTicket - Will be freed if non-NULL
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMITGetMachineDomain(
    IN PKERB_INTERNAL_NAME TargetName,
    IN OUT PUNICODE_STRING TargetDomainName,
    IN OUT PKERB_TICKET_CACHE_ENTRY *TicketGrantingTicket
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAPR_POLICY_DNS_DOMAIN_INFO DnsDomainInfo = NULL;
    PLSAPR_POLICY_INFORMATION Policy = NULL;
    KERBEROS_MACHINE_ROLE Role;

    Role = KerbGetGlobalRole();


    //
    // We're not part of a domain, so bail out here.
    //
    if (Role == KerbRoleRealmlessWksta)
    {
        Status = STATUS_NO_TRUST_SAM_ACCOUNT;
        goto Cleanup;
    }

    Status = I_LsaIQueryInformationPolicyTrusted(
                PolicyDnsDomainInformation,
                &Policy
                );

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_TRACE,"Failed Query policy %x %ws, line %d\n", THIS_FILE, __LINE__));
        goto Cleanup;
    }

    DnsDomainInfo = &Policy->PolicyDnsDomainInfo;

    //
    // make sure the computer is a member of an NT domain
    //

    if ((DnsDomainInfo->DnsDomainName.Length != 0) && (DnsDomainInfo->Sid != NULL))
    {
        //
        // make the client realm the domain of the computer
        //

        KerbFreeString(TargetDomainName);
        RtlZeroMemory(TargetDomainName, sizeof(UNICODE_STRING));

        Status = KerbDuplicateString(
                    TargetDomainName,
                    (PUNICODE_STRING)&DnsDomainInfo->DnsDomainName
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        (VOID) RtlUpcaseUnicodeString( TargetDomainName,
                                       TargetDomainName,
                                       FALSE);

        if (*TicketGrantingTicket != NULL)
        {
            KerbDereferenceTicketCacheEntry(*TicketGrantingTicket);
            *TicketGrantingTicket = NULL;
        }
    }
    else
    {
        Status = STATUS_NO_TRUST_SAM_ACCOUNT;
    }

Cleanup:

    if (Policy != NULL)
    {
        I_LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyDnsDomainInformation,
            Policy
            );
    }

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbGetServiceTicket
//
//  Synopsis:   Gets a ticket to a service and handles cross-domain referrals
//
//  Effects:
//
//  Arguments:  LogonSession - the logon session to use for ticket caching
//                      and the identity of the caller.
//              TargetName - Name of the target for which to obtain a ticket.
//              TargetDomainName - Domain name of target
//              Flags - Flags about the request
//              TicketOptions - KDC options flags
//              EncryptionType - optional Requested encryption type
//              ErrorMessage - Error message from an AP request containing hints
//                      for next ticket.
//              AuthorizationData - Optional authorization data to stick
//                      in the ticket.
//              TgtReply - TGT to use for getting a ticket with enc_tkt_in_skey
//              TicketCacheEntry - Receives a referenced ticket cache entry.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetServiceTicket(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN PKERB_INTERNAL_NAME TargetName,
    IN PUNICODE_STRING TargetDomainName,
    IN OPTIONAL PKERB_SPN_CACHE_ENTRY SpnCacheEntry,
    IN ULONG Flags,
    IN OPTIONAL ULONG TicketOptions,
    IN OPTIONAL ULONG EncryptionType,
    IN OPTIONAL PKERB_ERROR ErrorMessage,
    IN OPTIONAL PKERB_AUTHORIZATION_DATA AuthorizationData,
    IN OPTIONAL PKERB_TGT_REPLY TgtReply,
    OUT PKERB_TICKET_CACHE_ENTRY * NewCacheEntry,
    OUT LPGUID pLogonGuid OPTIONAL
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS AuditStatus = STATUS_SUCCESS;
    PKERB_TICKET_CACHE_ENTRY TicketCacheEntry = NULL;
    PKERB_TICKET_CACHE_ENTRY TicketGrantingTicket = NULL;
    PKERB_TICKET_CACHE_ENTRY LastTgt = NULL;
    PKERB_KDC_REPLY KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY KdcReplyBody = NULL;
    BOOLEAN LogonSessionsLocked = FALSE;
    BOOLEAN TicketCacheLocked = FALSE;
    BOOLEAN CrossRealm = FALSE;
    PKERB_INTERNAL_NAME RealTargetName = NULL;
    UNICODE_STRING RealTargetRealm = NULL_UNICODE_STRING;
    PKERB_INTERNAL_NAME TargetTgtKdcName = NULL;
    PKERB_PRIMARY_CREDENTIAL PrimaryCredentials = NULL;
    BOOLEAN UsedCredentials = FALSE;
    UNICODE_STRING ClientRealm = NULL_UNICODE_STRING;
    UNICODE_STRING SpnTargetRealm = NULL_UNICODE_STRING;
    BOOLEAN CacheTicket = TRUE;
    ULONG ReferralCount = 0;
    ULONG RetryFlags = 0;
    BOOLEAN fMITRetryAlreadyMade = FALSE;
    BOOLEAN TgtRetryMade = FALSE;
    BOOLEAN CacheBasedFailure = FALSE;
    GUID LogonGuid = { 0 };


    //
    // Check to see if the credential has any primary credentials
    //

TGTRetry:

    KerbFreeTgsReply(KdcReply);
    KerbFreeKdcReplyBody(KdcReplyBody);
    KdcReply = NULL;
    KdcReplyBody = NULL;


    DsysAssert( !LogonSessionsLocked );
    KerbReadLockLogonSessions(LogonSession);
    LogonSessionsLocked = TRUE;

    if ((Credential != NULL) && (Credential->SuppliedCredentials != NULL))
    {
        PrimaryCredentials = Credential->SuppliedCredentials;
        UsedCredentials = TRUE;
    }
    else if (CredManCredentials != NULL)
    {
        PrimaryCredentials = CredManCredentials->SuppliedCredentials;
        UsedCredentials = TRUE;
    }
    else
    {
        PrimaryCredentials = &LogonSession->PrimaryCredentials;
        UsedCredentials = ((LogonSession->LogonSessionFlags & KERB_LOGON_NEW_CREDENTIALS) != 0);
    }

    //
    // Make sure the name is not zero length
    //

    if ((TargetName->NameCount == 0) ||
        (TargetName->Names[0].Length == 0))
    {
        D_DebugLog((DEB_ERROR, "KerbGetServiceTicket trying to crack zero length name.\n"));
        Status = SEC_E_TARGET_UNKNOWN;
        goto Cleanup;
    }

    //
    // First check the ticket cache for this logon session. We don't look
    // for the target principal name because we can't be assured that this
    // is a valid principal name for the target. If we are doing user-to-
    // user, don't use the cache because the tgt key may have changed
    //

    if ((TgtReply == NULL) && ((Flags & KERB_GET_TICKET_NO_CACHE) == 0))
    {
        TicketCacheEntry = KerbLocateTicketCacheEntry(
                                &PrimaryCredentials->ServerTicketCache,
                                TargetName,
                                TargetDomainName
                                );
    }
    else
    {
        //
        // We don't want to cache user-to-user tickets
        //

        CacheTicket = FALSE;
    }

    if (TicketCacheEntry != NULL)
    {
        //
        // If we were given an error message that indicated a bad password
        // through away the cached ticket
        //

        //
        // If we were given an error message that indicated a bad password
        // through away the cached ticket
        //

        if (ARGUMENT_PRESENT(ErrorMessage) && ((KERBERR) ErrorMessage->error_code == KRB_AP_ERR_MODIFIED))
        {
            KerbRemoveTicketCacheEntry(TicketCacheEntry);
            KerbDereferenceTicketCacheEntry(TicketCacheEntry);
            TicketCacheEntry = NULL;
        }
        else
        {
            ULONG TicketFlags;
            ULONG CacheTicketFlags;
            ULONG CacheEncryptionType;

            //
            // Check if the flags are present
            //

            KerbReadLockTicketCache();
            CacheTicketFlags = TicketCacheEntry->TicketFlags;
            CacheEncryptionType = TicketCacheEntry->Ticket.encrypted_part.encryption_type;
            KerbUnlockTicketCache();

            TicketFlags = KerbConvertKdcOptionsToTicketFlags(TicketOptions);

            if (((CacheTicketFlags & TicketFlags) != TicketFlags) ||
                ((EncryptionType != 0) && (CacheEncryptionType != EncryptionType)))

            {
                KerbDereferenceTicketCacheEntry(TicketCacheEntry);
                TicketCacheEntry = NULL;
            }
            else
            {
            //
            // Check the ticket time
            //

                if (KerbTicketIsExpiring(TicketCacheEntry, TRUE))
                {
                    KerbDereferenceTicketCacheEntry(TicketCacheEntry);
                    TicketCacheEntry = NULL;
                }
                else
                {
                    *NewCacheEntry = TicketCacheEntry;
                    D_DebugLog((DEB_TRACE_REFERRAL, "KerbGetServiceTicket found ticket cache entry %#x, TargetName: ", TicketCacheEntry));
                    D_KerbPrintKdcName((DEB_TRACE_REFERRAL, TicketCacheEntry->TargetName));
                    D_DebugLog((DEB_TRACE_REFERRAL, "KerbGetServiceTicket target Realm: %wZ\n", &TicketCacheEntry->DomainName));
                    TicketCacheEntry = NULL;
                    goto Cleanup;
                }
            }
        }
    }

    //
    // If the caller wanted any special options, don't cache this ticket.
    //

    if ((TicketOptions != 0) || (EncryptionType != 0) || ((Flags & KERB_GET_TICKET_NO_CACHE) != 0))
    {
        CacheTicket = FALSE;
    }

    //
    // No cached entry was found so go ahead and call the KDC to
    // get the ticket.
    //


    //
    // Determine the state of the SPNCache using information in the credential.
    // Only do this if we've not been handed 
    //
    if ( ARGUMENT_PRESENT(SpnCacheEntry) && TargetDomainName->Buffer == NULL )
    {      
        Status = KerbGetSpnCacheStatus(
                    SpnCacheEntry,
                    PrimaryCredentials,
                    &SpnTargetRealm
                    );       

        if (NT_SUCCESS( Status ))
        {
            KerbFreeString(&RealTargetRealm);                       
            RealTargetRealm = SpnTargetRealm;                      
            RtlZeroMemory(&SpnTargetRealm, sizeof(UNICODE_STRING));
    
            D_DebugLog((DEB_TRACE_SPN_CACHE, "Found SPN cache entry - %wZ\n", &RealTargetRealm));
            D_KerbPrintKdcName((DEB_TRACE_SPN_CACHE, TargetName));
        }
        else if ( Status != STATUS_NO_MATCH )
        {
            D_DebugLog((DEB_TRACE_SPN_CACHE, "KerbGetSpnCacheStatus failed %x\n", Status));
            D_DebugLog((DEB_TRACE_SPN_CACHE,  "TargetName: \n"));
            D_KerbPrintKdcName((DEB_TRACE_SPN_CACHE, TargetName));

            CacheBasedFailure = TRUE;
            goto Cleanup;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // First get a TGT to the correct KDC. If a principal name was provided,
    // use it instead of the target name.
    //
    // There could also be a host to realm mapping taking place here.  If so,
    // realtargetrealm != NULL.
    //

    Status = KerbGetTgtForService(
                LogonSession,
                Credential,
                CredManCredentials,
                NULL,
                (RealTargetRealm.Buffer == NULL ? TargetDomainName : &RealTargetRealm),
                Flags,
                &TicketGrantingTicket,
                &CrossRealm
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to get TGT for service: 0x%x :", Status ));
        KerbPrintKdcName(DEB_ERROR, TargetName);
        DebugLog((DEB_ERROR, "%ws, line %d\n", THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Copy out the client realm name which is used when obtaining the ticket
    //

    Status = KerbDuplicateString(
                &ClientRealm,
                &PrimaryCredentials->DomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    DsysAssert( LogonSessionsLocked );
    KerbUnlockLogonSessions(LogonSession);
    LogonSessionsLocked = FALSE;

ReferralRestart:

    D_DebugLog((DEB_TRACE_REFERRAL, "KerbGetServiceTicket ReferralRestart\n"));
    D_DebugLog((DEB_TRACE_REFERRAL, "ClientRealm %wZ\n, TargetName ", &ClientRealm));
    D_KerbPrintKdcName((DEB_TRACE_REFERRAL, TargetName));
    D_DebugLog((DEB_TRACE_REFERRAL, "\n ", &ClientRealm));


    //
    // If this is not cross realm (meaning we have a TGT to the corect domain),
    // try to get a ticket directly to the service
    //

    if (!CrossRealm)
    {
        Status = KerbGetTgsTicket(
                    &ClientRealm,
                    TicketGrantingTicket,
                    TargetName,
                    Flags,
                    TicketOptions,
                    EncryptionType,
                    AuthorizationData,
                    NULL,                           // no pa data
                    TgtReply,                       // This is for the service directly, so use TGT
                    NULL,                           // no evidence ticket
                    NULL,                           // let kdc determine end time
                    &KdcReply,
                    &KdcReplyBody,
                    &RetryFlags
                    );

        if (!NT_SUCCESS(Status))
        {
            //
            // Check for bad option TGT purging
            //
            if (((RetryFlags & KERB_RETRY_WITH_NEW_TGT) != 0) && !TgtRetryMade)
            {
                DebugLog((DEB_WARN, "Doing TGT retry - %p\n", TicketGrantingTicket));

                //
                // Unlink && purge bad tgt
                //
                KerbRemoveTicketCacheEntry(TicketGrantingTicket);
                KerbDereferenceTicketCacheEntry(TicketGrantingTicket);
                TicketGrantingTicket = NULL;
                TgtRetryMade = TRUE;
                goto TGTRetry;
            }
            //
            // Check for the MIT retry case
            //
            if (((RetryFlags & KERB_MIT_NO_CANONICALIZE_RETRY) != 0)
                && (!fMITRetryAlreadyMade))
            {

                Status = KerbMITGetMachineDomain(
                                TargetName,
                                TargetDomainName,
                                &TicketGrantingTicket
                                );

                if (!NT_SUCCESS(Status))
                {
                    D_DebugLog((DEB_TRACE,"Failed Query policy information %ws, line %d\n", THIS_FILE, __LINE__));
                    goto Cleanup;
                }

                fMITRetryAlreadyMade = TRUE;
                Flags &= ~KERB_TARGET_USED_SPN_CACHE;
                goto TGTRetry;
            }


            DebugLog((DEB_WARN,"Failed to get TGS ticket for service 0x%x : \n",
                Status ));
            KerbPrintKdcName(DEB_WARN, TargetName);
            DebugLog((DEB_WARN, "%ws, line %d\n", THIS_FILE, __LINE__));
            goto Cleanup;
        }

        //
        // Check for referral info in the name
        //

        KerbFreeString(&RealTargetRealm);
        Status = KerbGetReferralNames(
                    KdcReplyBody,
                    TargetName,
                    &RealTargetRealm
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // If this is not a referral ticket, just cache it and return
        // the cache entry.
        //

        if (RealTargetRealm.Length == 0)
        {
            //
            // Now we have a ticket - lets cache it
            //

            KerbReadLockLogonSessions(LogonSession);

            Status = KerbCreateTicketCacheEntry(
                        KdcReply,
                        KdcReplyBody,
                        TargetName,
                        TargetDomainName,
                        0,
                        CacheTicket ? &PrimaryCredentials->ServerTicketCache : NULL,
                        NULL,                               // no credential key
                        &TicketCacheEntry
                        );

            KerbUnlockLogonSessions(LogonSession);

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            *NewCacheEntry = TicketCacheEntry;
            TicketCacheEntry = NULL;

            //
            // We're done, so get out of here.
            //

            goto Cleanup;
        }


        //
        // The server referred us to another domain. Get the service's full
        // name from the ticket and try to find a TGT in that domain.
        //

        Status = KerbDuplicateKdcName(
                    &RealTargetName,
                    TargetName
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        D_DebugLog((DEB_TRACE_REFERRAL, "Got referral ticket for service \n"));
        D_KerbPrintKdcName((DEB_TRACE_REFERRAL, TargetName));
        D_DebugLog((DEB_TRACE_REFERRAL, "in realm %wZ\n", &RealTargetRealm ));
        D_KerbPrintKdcName((DEB_TRACE_REFERRAL, RealTargetName));

        //
        // Cache the interdomain TGT
        //

        DsysAssert( !LogonSessionsLocked );
        KerbReadLockLogonSessions(LogonSession);
        LogonSessionsLocked = TRUE;

        Status = KerbCreateTicketCacheEntry(
                    KdcReply,
                    KdcReplyBody,
                    NULL,                       // no target name
                    NULL,                       // no target realm
                    0,                          // no flags
                    CacheTicket ? &PrimaryCredentials->AuthenticationTicketCache : NULL,
                    NULL,                               // no credential key
                    &TicketCacheEntry
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }


        //
        // Dereference the old ticket-granting ticket, and use
        // the one from the referral.  This allows us to chase
        // the proper referral path.
        //

        KerbDereferenceTicketCacheEntry(TicketGrantingTicket);
        TicketGrantingTicket = TicketCacheEntry;
        TicketCacheEntry = NULL;

        DsysAssert( LogonSessionsLocked );
        KerbUnlockLogonSessions(LogonSession);
        LogonSessionsLocked = FALSE;
    }
    else
    {
        //
        // Set the real names to equal the supplied names
        //

        Status = KerbDuplicateKdcName(
                    &RealTargetName,
                    TargetName
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // Don't overwrite if we're doing a referral, or if we're missing
        // a TGT for the target domain name.
        //
        if (RealTargetRealm.Buffer == NULL)
        {
            Status = KerbDuplicateString(
                            &RealTargetRealm,
                            TargetDomainName
                            );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
    }

    //
    // Now we are in a case where we have a realm to aim for and a TGT. While
    // we don't have a TGT for the target realm, get one.
    //

    if (!KERB_SUCCESS(KerbBuildFullServiceKdcName(
                            &RealTargetRealm,
                            &KerbGlobalKdcServiceName,
                            KRB_NT_SRV_INST,
                            &TargetTgtKdcName
                            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    DsysAssert( !TicketCacheLocked );
    KerbReadLockTicketCache();
    TicketCacheLocked = TRUE;

    //
    // Referral chasing code block - very important to get right
    // If we know the "real" target realm, eg. from GC, then
    // we'll walk trusts until we hit "real" target realm.
    //

    while (!RtlEqualUnicodeString(
                &RealTargetRealm,
                &TicketGrantingTicket->TargetDomainName,
                TRUE ))
    {

        //
        // If we just got two TGTs for the same domain, then we must have
        // gotten as far as we can. Chances our our RealTargetRealm is a
        // variation of what the KDC hands out.
        //

        if ((LastTgt != NULL) &&
             RtlEqualUnicodeString(
                &LastTgt->TargetDomainName,
                &TicketGrantingTicket->TargetDomainName,
                TRUE ))
        {
            DsysAssert( TicketCacheLocked );
            KerbUnlockTicketCache();
            TicketCacheLocked = FALSE;

            KerbSetTicketCacheEntryTarget(
                &RealTargetRealm,
                LastTgt
                );

            DsysAssert( !TicketCacheLocked );
            KerbReadLockTicketCache();
            TicketCacheLocked = TRUE;
            D_DebugLog((DEB_TRACE_REFERRAL, "Got two TGTs for same realm (%wZ), bailing out of referral loop\n",
                &LastTgt->TargetDomainName));
            break;
        }

        D_DebugLog((DEB_TRACE_REFERRAL, "Getting referral TGT for \n"));
        D_KerbPrintKdcName((DEB_TRACE_REFERRAL, TargetTgtKdcName));
        D_KerbPrintKdcName((DEB_TRACE_REFERRAL, TicketGrantingTicket->ServiceName));

        DsysAssert( TicketCacheLocked );
        KerbUnlockTicketCache();
        TicketCacheLocked = FALSE;

        //
        // Cleanup old state
        //

        KerbFreeTgsReply(KdcReply);
        KerbFreeKdcReplyBody(KdcReplyBody);
        KdcReply = NULL;
        KdcReplyBody = NULL;


        D_DebugLog((DEB_TRACE_REFERRAL, "TGT TargetDomain %wZ\n", &TicketGrantingTicket->TargetDomainName));
        D_DebugLog((DEB_TRACE_REFERRAL, "TGT Domain %wZ\n", &TicketGrantingTicket->DomainName));


        Status = KerbGetTgsTicket(
                    &ClientRealm,
                    TicketGrantingTicket,
                    TargetTgtKdcName,
                    FALSE,
                    TicketOptions,
                    EncryptionType,
                    AuthorizationData,
                    NULL,                       // no pa data
                    NULL,                       // no tgt reply since target is krbtgt
                    NULL,                       // no evidence ticket
                    NULL,                       // let kdc determine end time
                    &KdcReply,
                    &KdcReplyBody,
                    &RetryFlags
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN,"Failed to get TGS ticket for service 0x%x :",
                Status ));
            KerbPrintKdcName(DEB_WARN, TargetTgtKdcName);
            DebugLog((DEB_WARN, "%ws, line %d\n", THIS_FILE, __LINE__));

            //
            // We want to map cross-domain failures to failures indicating
            // that a KDC could not be found. This means that for Kerberos
            // logons, the negotiate code will retry with a different package
            //

            // if (Status == STATUS_NO_TRUST_SAM_ACCOUNT)
            // {
            //     Status = STATUS_NO_LOGON_SERVERS;
            // }
            goto Cleanup;
        }

        //
        // Now we have a ticket - lets cache it
        //

        KerbReadLockLogonSessions(LogonSession);

        Status = KerbCreateTicketCacheEntry(
                    KdcReply,
                    KdcReplyBody,
                    NULL,                               // no target name
                    NULL,                               // no targe realm
                    0,                                  // no flags
                    CacheTicket ? &PrimaryCredentials->AuthenticationTicketCache : NULL,
                    NULL,                               // no credential key
                    &TicketCacheEntry
                    );

        KerbUnlockLogonSessions(LogonSession);

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }


        //
        // Make sure we're not in a referral chasing loop.
        //
        // Basically, this means that the DomainName of
        // the last TGT != the TargetDomain of the new 
        // tgt.
        //
        if (RtlEqualUnicodeString(&TicketGrantingTicket->DomainName, &TicketCacheEntry->TargetDomainName, TRUE) &&
            !RtlEqualUnicodeString(&TicketGrantingTicket->TargetDomainName, &TicketCacheEntry->TargetDomainName, TRUE))
        {
            DebugLog((DEB_ERROR, "Referral loop TO  : %wZ\n", &TicketCacheEntry->DomainName ));
            DebugLog((DEB_ERROR, "TO  : %wZ\n", &TicketCacheEntry->TargetDomainName));
            DebugLog((DEB_ERROR, "TKE %p TGT %p\n", TicketCacheEntry, TicketGrantingTicket));
            Status = STATUS_DOMAIN_TRUST_INCONSISTENT;
            goto Cleanup;
        }   
      
        if (LastTgt != NULL)
        {
            KerbDereferenceTicketCacheEntry(LastTgt);
            LastTgt = NULL;
        }

        LastTgt = TicketGrantingTicket;
        TicketGrantingTicket = TicketCacheEntry;   
        TicketCacheEntry = NULL;

        DsysAssert( !TicketCacheLocked );
        KerbReadLockTicketCache();
        TicketCacheLocked = TRUE;
    }     // ** WHILE **

    DsysAssert(TicketCacheLocked);
    KerbUnlockTicketCache();
    TicketCacheLocked = FALSE;

    //
    // Now we must have a TGT to the destination domain. Get a ticket
    // to the service.
    //

    //
    // Cleanup old state
    //

    KerbFreeTgsReply(KdcReply);
    KerbFreeKdcReplyBody(KdcReplyBody);
    KdcReply = NULL;
    KdcReplyBody = NULL;
    RetryFlags = 0;

    Status = KerbGetTgsTicket(
                &ClientRealm,
                TicketGrantingTicket,
                RealTargetName,
                FALSE,
                TicketOptions,
                EncryptionType,
                AuthorizationData,
                NULL,                           // no pa data
                TgtReply,
                NULL,                           // no evidence ticket
                NULL,                           // let kdc determine end time
                &KdcReply,
                &KdcReplyBody,
                &RetryFlags
                );

    if (!NT_SUCCESS(Status))
    { 

        //
        // Check for bad option TGT purging
        //
        if (((RetryFlags & KERB_RETRY_WITH_NEW_TGT) != 0) && !TgtRetryMade)
        {
            DebugLog((DEB_WARN, "Doing TGT retry - %p\n", TicketGrantingTicket));

            //
            // Unlink && purge bad tgt
            //
            KerbRemoveTicketCacheEntry(TicketGrantingTicket); // free from list
            KerbDereferenceTicketCacheEntry(TicketGrantingTicket);
            TicketGrantingTicket = NULL;
            TgtRetryMade = TRUE;
            goto TGTRetry;
        }


        DebugLog((DEB_WARN,"Failed to get TGS ticket for service 0x%x ",
            Status ));
        KerbPrintKdcName(DEB_WARN, RealTargetName);
        DebugLog((DEB_WARN, "%ws, line %d\n", THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Now that we are in the domain to which we were referred, check for referral
    // info in the name
    //

    KerbFreeString(&RealTargetRealm);
    Status = KerbGetReferralNames(
                KdcReplyBody,
                RealTargetName,
                &RealTargetRealm
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If this is not a referral ticket, just cache it and return
    // the cache entry.
    //

    if (RealTargetRealm.Length != 0)
    {
        //
        // To prevent loops, we limit the number of referral we'll take
        //

        if (ReferralCount > KerbGlobalMaxReferralCount)
        {
            D_DebugLog((DEB_ERROR, "Maximum referral count exceeded for name: "));
            D_KerbPrintKdcName((DEB_ERROR, RealTargetName));
            Status = STATUS_MAX_REFERRALS_EXCEEDED;
            goto Cleanup;
        }

        ReferralCount++;

        //
        // Cache the interdomain TGT
        //

        KerbReadLockLogonSessions(LogonSession);

        Status = KerbCreateTicketCacheEntry(
                    KdcReply,
                    KdcReplyBody,
                    NULL,                       // no target name
                    NULL,                       // no target realm
                    0,                          // no flags
                    CacheTicket ? &PrimaryCredentials->AuthenticationTicketCache : NULL,
                    NULL,                       // no credential key
                    &TicketCacheEntry
                    );

        KerbUnlockLogonSessions(LogonSession);

        if (RtlEqualUnicodeString(&TicketGrantingTicket->DomainName, &TicketCacheEntry->TargetDomainName, TRUE) &&
            !RtlEqualUnicodeString(&TicketGrantingTicket->TargetDomainName, &TicketCacheEntry->TargetDomainName, TRUE))
        {
            DebugLog((DEB_ERROR, "Referral loop (2) FROM  : %wZ\n", &TicketCacheEntry->DomainName ));
            DebugLog((DEB_ERROR, "TO  : %wZ\n", &TicketCacheEntry->TargetDomainName));
            DebugLog((DEB_ERROR, "TKE %p tgt %p\n", TicketCacheEntry, TicketGrantingTicket));
            Status = STATUS_DOMAIN_TRUST_INCONSISTENT;
            goto Cleanup;
        }  


        //
        // Cleanup old state
        //

        KerbFreeTgsReply(KdcReply);
        KerbFreeKdcReplyBody(KdcReplyBody);
        KdcReply = NULL;
        KdcReplyBody = NULL;

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if (LastTgt != NULL)
        {
            KerbDereferenceTicketCacheEntry(LastTgt);
            LastTgt = NULL;
        }

        LastTgt = TicketGrantingTicket;
        TicketGrantingTicket = TicketCacheEntry;
        TicketCacheEntry = NULL;

        D_DebugLog((DEB_TRACE_REFERRAL, "Restart referral:%wZ", &RealTargetRealm));

        goto ReferralRestart;
    }

    

    KerbReadLockLogonSessions(LogonSession);

    Status = KerbCreateTicketCacheEntry(
                KdcReply,
                KdcReplyBody,
                TargetName,
                TargetDomainName,
                TgtReply ? KERB_TICKET_CACHE_TKT_ENC_IN_SKEY : 0,                                      // no flags
                CacheTicket ? &PrimaryCredentials->ServerTicketCache : NULL,
                NULL,                               // no credential key
                &TicketCacheEntry
                );

    KerbUnlockLogonSessions(LogonSession);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *NewCacheEntry = TicketCacheEntry;
    TicketCacheEntry = NULL;

Cleanup:

    if ( NT_SUCCESS( Status ) )
    {
        //
        // Generate the logon GUID
        //
        AuditStatus = KerbGetLogonGuid(
                          PrimaryCredentials,
                          KdcReplyBody,
                          &LogonGuid
                          );

        //
        // return the logon GUID if requested
        //
        if ( NT_SUCCESS(AuditStatus) && pLogonGuid )
        {
            *pLogonGuid = LogonGuid;
        }

        //
        // generate SE_AUDITID_LOGON_USING_EXPLICIT_CREDENTIALS
        // if explicit credentials were used for this logon.
        //
        if ( UsedCredentials )
        {
            (void) KerbGenerateAuditForLogonUsingExplicitCreds(
                       LogonSession,
                       PrimaryCredentials,
                       &LogonGuid,
                       TargetName
                       );
        }
    }

    //
    // Bad or unlocatable SPN -- Don't update if we got the value from the cache, though.
    //
    if (( TargetName->NameType == KRB_NT_SRV_INST ) &&
        ( NT_SUCCESS(Status) || Status == STATUS_NO_TRUST_SAM_ACCOUNT ) &&
        ( !CacheBasedFailure ))
    {
        NTSTATUS Tmp;
        ULONG UpdateValue = KERB_SPN_UNKNOWN;
        PUNICODE_STRING Realm = NULL;

        if ( NT_SUCCESS( Status ))
        {
            Realm = &(*NewCacheEntry)->TargetDomainName;
            UpdateValue = KERB_SPN_KNOWN;
        } 
        
        Tmp = KerbUpdateSpnCacheEntry(
                    SpnCacheEntry,
                    TargetName,
                    PrimaryCredentials,
                    UpdateValue,
                    Realm
                    );
    }

    KerbFreeTgsReply( KdcReply );
    KerbFreeKdcReplyBody( KdcReplyBody );
    KerbFreeKdcName( &TargetTgtKdcName );
    KerbFreeString( &RealTargetRealm );
    KerbFreeString( &SpnTargetRealm );

    KerbFreeKdcName(&RealTargetName);

    if (TicketCacheLocked)
    {
        KerbUnlockTicketCache();
    }

    if (LogonSessionsLocked)
    {
        KerbUnlockLogonSessions(LogonSession);
    }

    KerbFreeString(&RealTargetRealm);


    if (TicketGrantingTicket != NULL)
    {
        if (Status == STATUS_WRONG_PASSWORD)
        {
            KerbRemoveTicketCacheEntry(
                TicketGrantingTicket
                );
        }
        KerbDereferenceTicketCacheEntry(TicketGrantingTicket);
    }
    if (LastTgt != NULL)
    {
        KerbDereferenceTicketCacheEntry(LastTgt);
        LastTgt = NULL;
    }


    KerbFreeString(&ClientRealm);

    //
    // If we still have a pointer to the ticket cache entry, free it now.
    //

    if (TicketCacheEntry != NULL)
    {   
        KerbRemoveTicketCacheEntry( TicketCacheEntry );
        KerbDereferenceTicketCacheEntry(TicketCacheEntry);

    }
    return(Status);
}

#ifndef WIN32_CHICAGO

//+-------------------------------------------------------------------------
//
//  Function:   KerbCountPasswords
//
//  Synopsis:   Determines how many passwords are in a extra cred list.
//
//  Effects:
//
//  Arguments:
//
//  Requires:   Readlock of cred list
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
ULONG
KerbCountPasswords(
    PEXTRA_CRED_LIST ExtraCredentials
    )
{
    ULONG               Count = 0;
    PKERB_EXTRA_CRED    ExtraCred = NULL;
    PLIST_ENTRY         ListEntry;

    for ( ListEntry = ExtraCredentials->CredList.List.Flink ;
             ( ListEntry !=  &ExtraCredentials->CredList.List );
             ListEntry = ListEntry->Flink )
    {
           ExtraCred = CONTAINING_RECORD(ListEntry, KERB_EXTRA_CRED, ListEntry.Next);

           if ( ExtraCred->Passwords )
           {
               Count++;
           }

           if ( ExtraCred->OldPasswords )
           {
               Count++;
           }
    }

    return Count;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildKeyList
//
//  Synopsis:   Used for conglomerating a list of keys for use in
//              decrypting AP_REQ.
//
//  Effects:
//
//  Arguments:
//
//  Requires:   Readlock logon session
//
//  Returns:
//
//  Notes:  In order to optimize perf, we order this 1. current password,
//  2. "extra" credentials, 3. old passwords
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbBuildKeyArray(
    IN OPTIONAL PKERB_LOGON_SESSION LogonSession,
    IN PKERB_PRIMARY_CREDENTIAL PrimaryCred,
    IN ULONG Etype,
    IN OUT PKERB_ENCRYPTION_KEY *KeyArray,
    IN OUT PULONG KeyCount
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    PLIST_ENTRY         ListEntry;
    PKERB_EXTRA_CRED    ExtraCred = NULL;

    ULONG LocalKeyCount = 0; 
    PKERB_ENCRYPTION_KEY Key = NULL;

    Key = KerbGetKeyFromList(
            PrimaryCred->Passwords,
            Etype
            );

    if ( Key == NULL )
    {
        Status = SEC_E_NO_CREDENTIALS;
        goto cleanup;
    }

    KeyArray[LocalKeyCount++] = Key;

    //
    // Scan the logon session for extra creds
    //
    if (ARGUMENT_PRESENT( LogonSession ))
    {
        for ( ListEntry = LogonSession->ExtraCredentials.CredList.List.Flink ;
              ( ListEntry !=  &LogonSession->ExtraCredentials.CredList.List );
              ListEntry = ListEntry->Flink )
        {
            ExtraCred = CONTAINING_RECORD(ListEntry, KERB_EXTRA_CRED, ListEntry.Next);

            Key = KerbGetKeyFromList(
                    ExtraCred->Passwords,
                    Etype
                    );

            if ( Key == NULL )
            {
                continue;
            }

            KeyArray[LocalKeyCount++] = Key;

            Key = KerbGetKeyFromList(
                    ExtraCred->OldPasswords,
                    Etype
                    );
    
            if (  Key == NULL )
            {
                continue;
            }

            KeyArray[LocalKeyCount++] = Key;
        }
    }

    //
    // Fill in old password.  If its NULL, we haven't allocated space
    //
    if ( PrimaryCred->OldPasswords != NULL )
    {
        Key = KerbGetKeyFromList(
                PrimaryCred->OldPasswords,
                Etype
                );

        if ( Key != NULL )
        {
            KeyArray[LocalKeyCount++] = Key;        
        }
    }

    DsysAssert(LocalKeyCount <= (*KeyCount));

    *KeyCount = LocalKeyCount;

cleanup:

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbHaveKeyMaterials
//
//  Synopsis:   Used to check for conglomerating a list of keys for use in
//              decrypting AP_REQ.
//
//  Effects:
//
//  Arguments:
//
//  Requires:   Readlock logon session
//
//  Returns:
//
//  Notes:  In order to optimize perf, we order this 1. current password,
//  2. "extra" credentials, 3. old passwords
//
//
//--------------------------------------------------------------------------

BOOL
KerbHaveKeyMaterials(
    IN OPTIONAL PKERB_LOGON_SESSION LogonSession,
    IN PKERB_PRIMARY_CREDENTIAL PrimaryCred
    )
{
     return (PrimaryCred->Passwords != NULL) ||
         (LogonSession && LogonSession->ExtraCredentials.Count) ||
         (PrimaryCred->OldPasswords != NULL);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateApRequest
//
//  Synopsis:   builds an AP request message
//
//  Effects:    allocates memory with MIDL_user_allocate
//
//  Arguments:  ClientName - Name of client
//              ClientRealm - Realm of client
//              SessionKey - Session key for the ticket
//              SubSessionKey - obtional sub Session key for the authenticator
//              Nonce - Nonce to use in authenticator
//              pAuthenticatorTime - time stamp used for AP request (generated in KerbCreateAuthenticator)
//              ServiceTicket - Ticket for service to put in request
//              ApOptions - Options to stick in AP request
//              GssChecksum - Checksum for GSS compatibility containing
//                      context options and delegation info.
//              KdcRequest - if TRUE, this is an AP request for a TGS req
//              ServerSkewTime - Optional skew of server's time
//              RequestSize - Receives size of the marshalled request
//              Request - Receives the marshalled request
//
//  Requires:
//
//  Returns:    KDC_ERR_NONE on success, KRB_ERR_GENERIC on memory or
//              marshalling failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------



KERBERR
KerbCreateApRequest(
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN OPTIONAL PKERB_ENCRYPTION_KEY SubSessionKey,
    IN ULONG Nonce,
    OUT OPTIONAL PTimeStamp pAuthenticatorTime,
    IN PKERB_TICKET ServiceTicket,
    IN ULONG ApOptions,
    IN OPTIONAL PKERB_CHECKSUM GssChecksum,
    IN OPTIONAL PTimeStamp ServerSkewTime,
    IN BOOLEAN KdcRequest,
    OUT PULONG RequestSize,
    OUT PUCHAR * Request
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_AP_REQUEST ApRequest;
    ULONG ApFlags;

    *Request = NULL;
    RtlZeroMemory(
        &ApRequest,
        sizeof(KERB_AP_REQUEST)
        );

    //
    // Fill in the AP request structure.
    //

    ApRequest.version = KERBEROS_VERSION;
    ApRequest.message_type = KRB_AP_REQ;
    ApFlags = KerbConvertUlongToFlagUlong(ApOptions);
    ApRequest.ap_options.value = (PUCHAR) &ApFlags;
    ApRequest.ap_options.length = sizeof(ULONG) * 8;
    ApRequest.ticket = *ServiceTicket;

    //
    // Create the authenticator for the request
    //

    KerbErr = KerbCreateAuthenticator(
                SessionKey,
                Nonce,
                pAuthenticatorTime,
                ClientName,
                ClientRealm,
                ServerSkewTime,
                SubSessionKey,
                GssChecksum,
                KdcRequest,
                &ApRequest.authenticator
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to build authenticator: 0x%x\n",
            KerbErr ));
        goto Cleanup;
    }

    //
    // Now marshall the request
    //

    KerbErr = KerbPackApRequest(
                &ApRequest,
                RequestSize,
                Request
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to pack AP request: 0x%x\n",KerbErr));
        goto Cleanup;
    }

Cleanup:
    if (ApRequest.authenticator.cipher_text.value != NULL)
    {
        MIDL_user_free(ApRequest.authenticator.cipher_text.value);
    }
    return(KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifyApRequest
//
//  Synopsis:   Verifies that an AP request message is valid
//
//  Effects:    decrypts ticket in AP request
//
//  Arguments:  RequestMessage - Marshalled AP request message
//              RequestSize - Size in bytes of request message
//              LogonSession - Logon session for server
//              Credential - Credential for server containing
//                      supplied credentials
//              UseSuppliedCreds - If TRUE, use creds from credential
//              ApRequest - Receives unmarshalled AP request
//              NewTicket - Receives ticket from AP request
//              NewAuthenticator - receives new authenticator from AP request
//              SessionKey -receives the session key from the ticket
//              ContextFlags - receives the requested flags for the
//                      context.
//              pChannelBindings - pChannelBindings supplied by app to check
//                      against hashed ones in AP_REQ
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbVerifyApRequest(
    IN OPTIONAL PKERB_CONTEXT Context,
    IN PUCHAR RequestMessage,
    IN ULONG RequestSize,
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN BOOLEAN UseSuppliedCreds,
    IN BOOLEAN CheckForReplay,
    OUT PKERB_AP_REQUEST  * ApRequest,
    OUT PKERB_ENCRYPTED_TICKET * NewTicket,
    OUT PKERB_AUTHENTICATOR * NewAuthenticator,
    OUT PKERB_ENCRYPTION_KEY SessionKey,
    OUT PKERB_ENCRYPTION_KEY TicketKey,
    OUT PKERB_ENCRYPTION_KEY ServerKey,
    OUT PULONG ContextFlags,
    OUT PULONG ContextAttributes,
    OUT PKERBERR ReturnKerbErr,
    IN PSEC_CHANNEL_BINDINGS pChannelBindings
    )
{
    KERBERR KerbErr = KDC_ERR_NONE, TmpErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_AP_REQUEST Request = NULL;
    UNICODE_STRING ServerName[3] = {0};
    ULONG NameCount = 0;
    BOOLEAN UseSubKey = FALSE;
    BOOLEAN LockAcquired = FALSE, UsedExtraCreds = FALSE;
    PKERB_GSS_CHECKSUM GssChecksum;
    BOOLEAN TicketCacheLocked = FALSE;
    PKERB_ENCRYPTION_KEY* KeyArray = NULL;
    ULONG KeyCount = 0;

    PKERB_PRIMARY_CREDENTIAL PrimaryCredentials;
    ULONG StrippedRequestSize = RequestSize;
    PUCHAR StrippedRequest = RequestMessage;
    PKERB_TICKET_CACHE_ENTRY CacheEntry = NULL;
    ULONG i, ApOptions = 0;
    ULONG BindHash[4];


    *ApRequest = NULL;
    *ContextFlags = 0;
    *NewTicket = NULL;
    *NewAuthenticator = NULL;
    *ReturnKerbErr = KDC_ERR_NONE;

    RtlZeroMemory(
        SessionKey,
        sizeof(KERB_ENCRYPTION_KEY)
        );
    *TicketKey = *SessionKey;
    *ServerKey = *SessionKey;

    //
    // First unpack the KDC request.
    //

    //
    // Verify the GSSAPI header
    //

    D_DebugLog((DEB_TRACE, "KerbVerifyApRequest UseSuppliedCreds %s, CheckForReplay %s\n",
                UseSuppliedCreds ? "true" : "false", CheckForReplay ? "true" : "false"));

    if (!g_verify_token_header(
            (gss_OID) gss_mech_krb5_new,
            (INT *) &StrippedRequestSize,
            &StrippedRequest,
            KG_TOK_CTX_AP_REQ,
            RequestSize
            ))
    {
        StrippedRequestSize = RequestSize;
        StrippedRequest = RequestMessage;

        //
        // Check if this is user-to-user kerberos
        //

        if (g_verify_token_header(
                gss_mech_krb5_u2u,
                (INT *) &StrippedRequestSize,
                &StrippedRequest,
                KG_TOK_CTX_TGT_REQ,
                RequestSize))
        {
            //
            // Return now because there is no AP request. Return a distinct
            // success code so the caller knows to reparse the request as
            // a TGT request.
            //

            D_DebugLog((DEB_TRACE_U2U, "KerbVerifyApRequest got TGT reqest\n"));

            return (STATUS_REPARSE_OBJECT);
        }
        else
        {
            StrippedRequestSize = RequestSize;
            StrippedRequest = RequestMessage;

            if (!g_verify_token_header(         // check for a user-to-user AP request
                    gss_mech_krb5_u2u,
                    (INT *) &StrippedRequestSize,
                    &StrippedRequest,
                    KG_TOK_CTX_AP_REQ,
                    RequestSize))
            {
                //
                // BUG 454895: remove when not needed for compatibility
                //
                
                //
                // if that didn't work, just use the token as it is.
                //
                StrippedRequest = RequestMessage;
                StrippedRequestSize = RequestSize;
                D_DebugLog((DEB_TRACE,"KerbVerifyApRequest didn't find GSS header on AP request\n"));
            }
        }
    }

    KerbErr = KerbUnpackApRequest(
                StrippedRequest,
                StrippedRequestSize,
                &Request
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to unpack AP request: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Check for a null session
    //

    if ((Request->version == KERBEROS_VERSION) &&
        (Request->message_type == KRB_AP_REQ) &&
        (Request->ticket.encrypted_part.cipher_text.length == 1) &&
        (*Request->ticket.encrypted_part.cipher_text.value == '\0') &&
        (Request->authenticator.cipher_text.length == 1) &&
        (*Request->authenticator.cipher_text.value == '\0'))
    {
        //
        // We have a null session. Not much to do here.
        //

        Status = STATUS_SUCCESS;

        RtlZeroMemory(
            SessionKey,
            sizeof(KERB_ENCRYPTION_KEY)
            );
        *ContextFlags |= ISC_RET_NULL_SESSION;
        goto Cleanup;
    }

    DsysAssert( !LockAcquired );
    KerbReadLockLogonSessions(LogonSession);
    LockAcquired = TRUE;

    if ( UseSuppliedCreds )
    {
        PrimaryCredentials = Credential->SuppliedCredentials;
    }
    else
    {
        PrimaryCredentials = &LogonSession->PrimaryCredentials;

        KerbLockList(&LogonSession->ExtraCredentials.CredList);
        if ( LogonSession->ExtraCredentials.Count )
        {
            KeyCount += KerbCountPasswords(&LogonSession->ExtraCredentials);
            UsedExtraCreds = TRUE;
        }
        else
        {
            KerbUnlockList(&LogonSession->ExtraCredentials.CredList);
        }
    }

    //
    // Check for existence of a password and use_session_key
    //

    ApOptions = KerbConvertFlagsToUlong( &Request->ap_options);

    D_DebugLog((DEB_TRACE, "KerbVerifyApRequest AP options = 0x%x\n", ApOptions));

    if ((ApOptions & KERB_AP_OPTIONS_use_session_key) == 0)
    {
        if (!KerbHaveKeyMaterials((UsedExtraCreds ? LogonSession : NULL), PrimaryCredentials))
        {
            Status = SEC_E_NO_CREDENTIALS;
            *ReturnKerbErr = KRB_AP_ERR_USER_TO_USER_REQUIRED;
            goto Cleanup;
        }
        else
        {
            //
            // If someone's added credentials to a non-joined machine,then
            // there's a possibility that we don't have a pwd w/ our primary
            // credentials structure.
            //
            if (PrimaryCredentials->Passwords != NULL)
            {
                KeyCount++;
            }
                           
            if (PrimaryCredentials->OldPasswords != NULL)
            {
                KeyCount++;
            }
        }
    }

    if (!KERB_SUCCESS(KerbBuildFullServiceName(
                        &PrimaryCredentials->DomainName,
                        &PrimaryCredentials->UserName,
                        &ServerName[NameCount++]
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ServerName[NameCount++] = PrimaryCredentials->UserName;

    if (Credential->CredentialName.Length != 0)
    {
        ServerName[NameCount++] = Credential->CredentialName;
    }

    //
    // Now Check the ticket
    //

    //
    // If this is use_session key, get the key from the tgt
    //

    if ((ApOptions & KERB_AP_OPTIONS_use_session_key) != 0)
    {
        D_DebugLog((DEB_TRACE_U2U, "KerbVerifyApRequest verifying ticket with TGT session key\n"));

        *ContextAttributes |= KERB_CONTEXT_USER_TO_USER;

        //
        // If we have a context, try to get the TGT from it.
        //

        if (ARGUMENT_PRESENT(Context))
        {
            KerbReadLockContexts();
            CacheEntry = Context->TicketCacheEntry;
            KerbUnlockContexts();
        }

        //
        // If there is no TGT in the context, try getting one from the
        // logon session.
        //

        if (CacheEntry == NULL)
        {
            //
            // Locate the TGT for the principal, this can never happen!
            //

            DebugLog((DEB_WARN, "KerbVerifyApRequest tried to request TGT on credential without a TGT\n"));

            CacheEntry = KerbLocateTicketCacheEntryByRealm(
                            &PrimaryCredentials->AuthenticationTicketCache,
                            &PrimaryCredentials->DomainName,                    // get initial ticket
                            0
                            );
        }
        else
        {
            KerbReferenceTicketCacheEntry(
                CacheEntry
                );
        }
        if (CacheEntry == NULL)
        {
            DebugLog((DEB_ERROR, "KerbVerifyApRequest tried to request TGT on credential without a TGT\n"));
            *ReturnKerbErr = KRB_AP_ERR_NO_TGT;
            Status = SEC_E_NO_CREDENTIALS;
            goto Cleanup;

        }

        DsysAssert( !TicketCacheLocked );
        KerbReadLockTicketCache();
        TicketCacheLocked = TRUE;

        KeyCount = 1;
        SafeAllocaAllocate(KeyArray, ( sizeof(PKERB_ENCRYPTION_KEY) * KeyCount ));
        if (KeyArray == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        KeyArray[0] = &CacheEntry->SessionKey;
    }
    else
    {
        SafeAllocaAllocate(KeyArray, ( sizeof(PKERB_ENCRYPTION_KEY) * KeyCount ));
        if (KeyArray == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;

        }

        RtlZeroMemory(KeyArray, ( sizeof(PKERB_ENCRYPTION_KEY) * KeyCount ));


        Status = KerbBuildKeyArray(
                    (UsedExtraCreds ? LogonSession : NULL),
                    PrimaryCredentials,
                    Request->ticket.encrypted_part.encryption_type,
                    KeyArray,
                    &KeyCount
                    );

        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR, "Couldn't find server key of type 0x%x. %ws, line %d\n",
                        Request->ticket.encrypted_part.encryption_type, THIS_FILE, __LINE__ ));
            goto Cleanup;
        }
    }

    for ( i = 0; i < KeyCount ; i++ )
    {
        TmpErr = KerbCheckTicket(
                    &Request->ticket,
                    &Request->authenticator,
                    KeyArray[i],
                    Authenticators,
                    &KerbGlobalSkewTime,
                    NameCount,
                    ServerName,
                    &PrimaryCredentials->DomainName,
                    CheckForReplay,
                    FALSE,                  // not a KDC request
                    NewTicket,
                    NewAuthenticator,
                    TicketKey,
                    SessionKey,
                    &UseSubKey
                    );

        if (KERB_SUCCESS( TmpErr ))
        {
            D_DebugLog((DEB_TRACE, "KerbVerifyApRequest ticket check succeeded using key %x\n", i));
            break;
        }
        else if ( TmpErr == KRB_AP_ERR_MODIFIED )
        {
            continue;
        }
        else
        {
            Status = KerbMapKerbError( TmpErr );
            *ReturnKerbErr = TmpErr;
            goto Cleanup;
        }
    }

    if (!KERB_SUCCESS( TmpErr ))
    {
        DebugLog((DEB_ERROR, "KerbVerifyApRequest failed to check ticket %x %p\n", TmpErr, Request));
        Status = KerbMapKerbError( TmpErr );
        *ReturnKerbErr = TmpErr;
        goto Cleanup;
    }

    *ReturnKerbErr = TmpErr;

    //
    // Copy the key that was used.
    //

    if (!KERB_SUCCESS(KerbDuplicateKey(
                        ServerKey,
                        KeyArray[i])))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if (UsedExtraCreds)
    {
        KerbUnlockList(&LogonSession->ExtraCredentials.CredList);
        UsedExtraCreds = FALSE;
    }

    //
    // Get the context flags out of the authenticator and the AP request
    //

    if ((((*NewAuthenticator)->bit_mask & checksum_present) != 0) &&
        ((*NewAuthenticator)->checksum.checksum_type == GSS_CHECKSUM_TYPE) &&
        ((*NewAuthenticator)->checksum.checksum.length >= GSS_CHECKSUM_SIZE))
    {
        GssChecksum = (PKERB_GSS_CHECKSUM) (*NewAuthenticator)->checksum.checksum.value;

        if (GssChecksum->GssFlags & GSS_C_MUTUAL_FLAG)
        {
            //
            // Make sure this is also present in the AP request
            //

            if ((ApOptions & KERB_AP_OPTIONS_mutual_required) == 0)
            {
                DebugLog((DEB_ERROR,"KerbVerifyApRequest sent AP_mutual_req but not GSS_C_MUTUAL_FLAG. %ws, line %d\n", THIS_FILE, __LINE__));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }
        }
        if (GssChecksum->GssFlags & GSS_C_DCE_STYLE)
        {
            *ContextFlags |= ISC_RET_USED_DCE_STYLE;
        }
        if (GssChecksum->GssFlags & GSS_C_REPLAY_FLAG)
        {
            *ContextFlags |= ISC_RET_REPLAY_DETECT;
        }
        if (GssChecksum->GssFlags & GSS_C_SEQUENCE_FLAG)
        {
            *ContextFlags |= ISC_RET_SEQUENCE_DETECT;
        }
        if (GssChecksum->GssFlags & GSS_C_CONF_FLAG)
        {
            *ContextFlags |= (ISC_RET_CONFIDENTIALITY |
                             ISC_RET_INTEGRITY |
                             ISC_RET_SEQUENCE_DETECT |
                             ISC_RET_REPLAY_DETECT );
        }
        if (GssChecksum->GssFlags & GSS_C_INTEG_FLAG)
        {
            *ContextFlags |= ISC_RET_INTEGRITY;
        }
        if (GssChecksum->GssFlags & GSS_C_IDENTIFY_FLAG)
        {
            *ContextFlags |= ISC_RET_IDENTIFY;
        }
        if (GssChecksum->GssFlags & GSS_C_DELEG_FLAG)
        {
            *ContextFlags |= ISC_RET_DELEGATE;
        }
        if (GssChecksum->GssFlags & GSS_C_EXTENDED_ERROR_FLAG)
        {
            *ContextFlags |= ISC_RET_EXTENDED_ERROR;
        }

        if( pChannelBindings != NULL )
        {
            Status = KerbComputeGssBindHash( pChannelBindings, (PUCHAR)BindHash );

            if( !NT_SUCCESS(Status) )
            {
                goto Cleanup;
            }

            if( RtlCompareMemory( BindHash,
                                  GssChecksum->BindHash,
                                  GssChecksum->BindLength )
                    != GssChecksum->BindLength )
            {
                Status = STATUS_BAD_BINDINGS;
                goto Cleanup;
            }
        }
    }

    if ((ApOptions & KERB_AP_OPTIONS_use_session_key) != 0)
    {
        *ContextFlags |= ISC_RET_USE_SESSION_KEY;
    }

    if ((ApOptions & KERB_AP_OPTIONS_mutual_required) != 0)
    {
        *ContextFlags |= ISC_RET_MUTUAL_AUTH;
    }

    *ApRequest = Request;
    Request = NULL;

Cleanup:

    if (TicketCacheLocked)
    {
        KerbUnlockTicketCache();
    }

    if (CacheEntry)
    {
        KerbDereferenceTicketCacheEntry(CacheEntry);
    }

    if (UsedExtraCreds)
    {
        KerbUnlockList(&LogonSession->ExtraCredentials.CredList);
    }

    if (LockAcquired)
    {
        KerbUnlockLogonSessions(LogonSession);
    }

    if (Request != NULL)
    {
        //
        // If the client didn't want mutual-auth, then it won't be expecting
        // a response message so don't bother with the kerb error. By setting
        // KerbErr to KDC_ERR_NONE we won't send a message back to the client.
        //

        if ( (ApOptions & KERB_AP_OPTIONS_mutual_required) == 0 )
        {
            *ReturnKerbErr = KDC_ERR_NONE;
        }
    }

    if ( KeyArray != NULL )
    {
        SafeAllocaFree( KeyArray );
    }

    KerbFreeApRequest(Request);
    KerbFreeString(&ServerName[0]);
    if (!NT_SUCCESS(Status))
    {
        KerbFreeKey(TicketKey);
    }

    return (Status);
}
#endif // WIN32_CHICAGO

//+-------------------------------------------------------------------------
//
//  Function:   KerbMarshallApReply
//
//  Synopsis:   Takes a reply and reply body and encrypts and marshalls them
//              into a return message
//
//  Effects:    Allocates output buffer
//
//  Arguments:  Reply - The outer reply to marshall
//              ReplyBody - The reply body to marshall
//              SessionKey - Session key to encrypt reply
//              ContextFlags - Flags for context
//              PackedReply - Recives marshalled reply buffer
//              PackedReplySize - Receives size in bytes of marshalled reply
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMarshallApReply(
    IN PKERB_AP_REPLY Reply,
    IN PKERB_ENCRYPTED_AP_REPLY ReplyBody,
    IN PKERB_ENCRYPTION_KEY SessionKey,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    OUT PUCHAR * PackedReply,
    OUT PULONG PackedReplySize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG PackedApReplySize;
    PUCHAR PackedApReply = NULL;
    ULONG ReplySize;
    PUCHAR ReplyWithHeader = NULL;
    PUCHAR ReplyStart;
    KERBERR KerbErr;
    gss_OID_desc * MechId;


    if (!KERB_SUCCESS(KerbPackApReplyBody(
                        ReplyBody,
                        &PackedApReplySize,
                        &PackedApReply
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Now encrypt the response
    //
    KerbErr = KerbAllocateEncryptionBufferWrapper(
                SessionKey->keytype,
                PackedApReplySize,
                &Reply->encrypted_part.cipher_text.length,
                &Reply->encrypted_part.cipher_text.value
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to get encryption overhead. 0x%x. %ws, line %d\n", KerbErr, THIS_FILE, __LINE__));
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }


    if (!KERB_SUCCESS(KerbEncryptDataEx(
                        &Reply->encrypted_part,
                        PackedApReplySize,
                        PackedApReply,
                        KERB_NO_KEY_VERSION,
                        KERB_AP_REP_SALT,
                        SessionKey
                        )))
    {
        D_DebugLog((DEB_ERROR,"Failed to encrypt AP Reply. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Now pack the reply into the output buffer
    //

    if (!KERB_SUCCESS(KerbPackApReply(
                        Reply,
                        PackedReplySize,
                        PackedReply
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // If we aren't doing DCE style, add in the GSS token headers now
    //

    if ((ContextFlags & ISC_RET_USED_DCE_STYLE) != 0)
    {
        goto Cleanup;
    }

    if ((ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
    {
        MechId = gss_mech_krb5_u2u;
    }
    else
    {
        MechId = gss_mech_krb5_new;
    }

    ReplySize = g_token_size(
                    MechId,
                    *PackedReplySize);

    ReplyWithHeader = (PUCHAR) KerbAllocate(ReplySize);
    if (ReplyWithHeader == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // the g_make_token_header will reset this to point to the end of the
    // header
    //

    ReplyStart = ReplyWithHeader;

    g_make_token_header(
        MechId,
        *PackedReplySize,
        &ReplyStart,
        KG_TOK_CTX_AP_REP
        );

    DsysAssert(ReplyStart - ReplyWithHeader + *PackedReplySize == ReplySize);

    RtlCopyMemory(
            ReplyStart,
            *PackedReply,
            *PackedReplySize
            );

    KerbFree(*PackedReply);
    *PackedReply = ReplyWithHeader;
    *PackedReplySize = ReplySize;
    ReplyWithHeader = NULL;

Cleanup:
    if (Reply->encrypted_part.cipher_text.value != NULL)
    {
        MIDL_user_free(Reply->encrypted_part.cipher_text.value);
        Reply->encrypted_part.cipher_text.value = NULL;
    }
    if (PackedApReply != NULL)
    {
        MIDL_user_free(PackedApReply);
    }
    if (!NT_SUCCESS(Status) && (*PackedReply != NULL))
    {
        KerbFree(*PackedReply);
        *PackedReply = NULL;
    }
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildApReply
//
//  Synopsis:   Builds an AP reply message if mutual authentication is
//              desired.
//
//  Effects:    InternalAuthenticator - Authenticator from the AP request
//                  this reply is for.
//              Request - The AP request to which to reply.
//              ContextFlags - Contains context flags from the AP request.
//              SessionKey - The session key to use to build the reply,.
//                      receives the new session key (if KERB_AP_USE_SKEY
//                      is negotiated).
//              NewReply - Receives the AP reply.
//              NewReplySize - Receives the size of the AP reply.
//
//  Arguments:
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS, STATUS_INSUFFICIENT_MEMORY, or errors from
//              KIEncryptData
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildApReply(
    IN PKERB_AUTHENTICATOR InternalAuthenticator,
    IN PKERB_AP_REQUEST Request,
    IN ULONG ContextFlags,
    IN ULONG ContextAttributes,
    IN PKERB_ENCRYPTION_KEY TicketKey,
    IN OUT PKERB_ENCRYPTION_KEY SessionKey,
    OUT PULONG Nonce,
    OUT PUCHAR * NewReply,
    OUT PULONG NewReplySize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_AP_REPLY Reply = {0};
    KERB_ENCRYPTED_AP_REPLY ReplyBody = {0};
    KERB_ENCRYPTION_KEY NewSessionKey = {0};

    *NewReply = NULL;
    *NewReplySize = 0;

    Reply.version = KERBEROS_VERSION;
    Reply.message_type = KRB_AP_REP;

    ReplyBody.client_time = InternalAuthenticator->client_time;
    ReplyBody.client_usec = InternalAuthenticator->client_usec;

    //
    // Generate a new nonce for the reply
    //

    *Nonce = KerbAllocateNonce();


    D_DebugLog((DEB_TRACE,"BuildApReply using nonce 0x%x\n",*Nonce));

    if (*Nonce != 0)
    {
        ReplyBody.KERB_ENCRYPTED_AP_REPLY_sequence_number = (int) *Nonce;
        ReplyBody.bit_mask |= KERB_ENCRYPTED_AP_REPLY_sequence_number_present;

    }

    //
    // If the client wants to use a session key, create one now
    //

    if ((InternalAuthenticator->bit_mask & KERB_AUTHENTICATOR_subkey_present) != 0 )
    {
        KERBERR KerbErr;
        //
        // If the client sent us an export-strength subkey, use it
        //

        if (KerbIsKeyExportable(
                &InternalAuthenticator->KERB_AUTHENTICATOR_subkey
                ))
        {
            D_DebugLog((DEB_TRACE_CTXT,"Client sent exportable key, using it on server on server\n"));
            if (!KERB_SUCCESS(KerbDuplicateKey(
                                &NewSessionKey,
                                &InternalAuthenticator->KERB_AUTHENTICATOR_subkey
                                )))
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
        }
        else
        {

            //
            // If we are export-strength, create our own key. Otherwise use
            // the client's key.
            //

            D_DebugLog((DEB_TRACE_CTXT,"Client sent strong key, using it on server on server\n"));
            KerbErr = KerbDuplicateKey(
                        &NewSessionKey,
                        &InternalAuthenticator->KERB_AUTHENTICATOR_subkey
                        );

            if (!KERB_SUCCESS(KerbErr))
            {
                Status = KerbMapKerbError(KerbErr);
                goto Cleanup;
            }

        }
        ReplyBody.KERB_ENCRYPTED_AP_REPLY_subkey = NewSessionKey;
        ReplyBody.bit_mask |= KERB_ENCRYPTED_AP_REPLY_subkey_present;
    }
    else
    {
        KERBERR KerbErr;

        //
        // Create a subkey ourselves if we are export strength
        //

        KerbErr = KerbMakeKey(
                    Request->authenticator.encryption_type,
                    &NewSessionKey
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }

        ReplyBody.KERB_ENCRYPTED_AP_REPLY_subkey = NewSessionKey;
        ReplyBody.bit_mask |= KERB_ENCRYPTED_AP_REPLY_subkey_present;
    }

    Status = KerbMarshallApReply(
                &Reply,
                &ReplyBody,
                TicketKey,
                ContextFlags,
                ContextAttributes,
                NewReply,
                NewReplySize
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If they asked for a session key, replace our current session key
    // with it.
    //

    if (NewSessionKey.keyvalue.value != NULL)
    {
        KerbFreeKey(SessionKey);
        *SessionKey = NewSessionKey;
        RtlZeroMemory(
            &NewSessionKey,
            sizeof(KERB_ENCRYPTION_KEY)
            );
    }

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        KerbFreeKey(&NewSessionKey);
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildThirdLegApReply
//
//  Synopsis:   Builds a third leg AP reply message if DCE-style
//               authentication is desired.
//
//  Effects:    Context - Context for which to build this message.
//              NewReply - Receives the AP reply.
//              NewReplySize - Receives the size of the AP reply.
//
//  Arguments:
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS, STATUS_INSUFFICIENT_MEMORY, or errors from
//              KIEncryptData
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildThirdLegApReply(
    IN PKERB_CONTEXT Context,
    IN ULONG ReceiveNonce,
    OUT PUCHAR * NewReply,
    OUT PULONG NewReplySize
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_AP_REPLY Reply;
    KERB_ENCRYPTED_AP_REPLY ReplyBody;
    TimeStamp CurrentTime;

    RtlZeroMemory(
        &Reply,
        sizeof(KERB_AP_REPLY)
        );
    RtlZeroMemory(
        &ReplyBody,
        sizeof(KERB_ENCRYPTED_AP_REPLY)
        );
    *NewReply = NULL;
    *NewReplySize = 0;

    Reply.version = KERBEROS_VERSION;
    Reply.message_type = KRB_AP_REP;

    GetSystemTimeAsFileTime((PFILETIME)
        &CurrentTime
        );

    KerbConvertLargeIntToGeneralizedTimeWrapper(
        &ReplyBody.client_time,
        &ReplyBody.client_usec,
        &CurrentTime
        );

    ReplyBody.KERB_ENCRYPTED_AP_REPLY_sequence_number = ReceiveNonce;
    ReplyBody.bit_mask |= KERB_ENCRYPTED_AP_REPLY_sequence_number_present;

    D_DebugLog((DEB_TRACE,"Building third leg AP reply with nonce 0x%x\n",ReceiveNonce));

    //
    // We already negotiated context flags so don't bother filling them in
    // now.
    //

    KerbReadLockContexts();

    DsysAssert((int) Context->EncryptionType == Context->TicketKey.keytype);

    Status = KerbMarshallApReply(
                &Reply,
                &ReplyBody,
                &Context->TicketKey,
                Context->ContextFlags,
                Context->ContextAttributes,
                NewReply,
                NewReplySize
                );
    KerbUnlockContexts();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

Cleanup:

    return (Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbKerbTimeEqual
//
//  Synopsis:   Compares two KERB_TIME values
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    TRUE - times are the same; otherwise FALSE
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOLEAN
KerbKerbTimeEqual(
    PKERB_TIME pt1,
    PKERB_TIME pt2
    )
{
    if (pt1->day != pt2->day)
        return (FALSE);
    if (pt1->diff != pt2->diff)
        return (FALSE);
    if (pt1->hour != pt2->hour)
        return (FALSE);
    if (pt1->millisecond != pt2->millisecond)
        return (FALSE);
    if (pt1->minute != pt2->minute)
        return (FALSE);
    if (pt1->month != pt2->month)
        return (FALSE);
    if (pt1->second != pt2->second)
        return (FALSE);
    if (pt1->universal != pt2->universal)
        return (FALSE);
    if (pt1->year != pt2->year)
        return (FALSE);

    return (TRUE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifyApReply
//
//  Synopsis:   Verifies an AP reply corresponds to an AP request
//
//  Effects:    Decrypts the AP reply
//
//  Arguments:
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_LOGON_FAILURE
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbVerifyApReply(
    IN PKERB_CONTEXT Context,
    IN PUCHAR PackedReply,
    IN ULONG PackedReplySize,
    OUT PULONG Nonce
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    PKERB_AP_REPLY Reply = NULL;
    PKERB_ENCRYPTED_AP_REPLY ReplyBody = NULL;
    BOOLEAN ContextsLocked = FALSE;
    ULONG StrippedReplySize = PackedReplySize;
    PUCHAR StrippedReply = PackedReply;
    gss_OID_desc * MechId;
    KERB_TIME AP_REQ_client_time;
    ASN1int32_t AP_REQ_client_usec;

    //
    // Verify the GSSAPI header
    //

    KerbReadLockContexts();
    if ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) == 0)
    {
        if ((Context->ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
        {
            MechId = gss_mech_krb5_u2u;
        }
        else
        {
            MechId = gss_mech_krb5_new;
        }
        if (!g_verify_token_header(
                (gss_OID) MechId,
                (INT *) &StrippedReplySize,
                &StrippedReply,
                KG_TOK_CTX_AP_REP,
                PackedReplySize
                ))
        {
            //
            // BUG 454895: remove when not needed for compatibility
            //

            //
            // if that didn't work, just use the token as it is.
            //

            StrippedReply = PackedReply;
            StrippedReplySize = PackedReplySize;
            D_DebugLog((DEB_WARN,"Didn't find GSS header on AP Reply\n"));

        }
    }
    KerbUnlockContexts();

    if (!KERB_SUCCESS(KerbUnpackApReply(
                        StrippedReply,
                        StrippedReplySize,
                        &Reply
                        )))
    {
        D_DebugLog((DEB_WARN, "Failed to unpack AP reply, %ws, %d\n", THIS_FILE, __LINE__));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if ((Reply->version != KERBEROS_VERSION) ||
        (Reply->message_type != KRB_AP_REP))
    {
        D_DebugLog((DEB_ERROR,"Illegal version or message as AP reply: 0x%x, 0x%x. %ws, line %d\n",
            Reply->version, Reply->message_type, THIS_FILE, __LINE__ ));
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Now decrypt the encrypted part.
    //

    KerbReadLockTicketCache();
    KerbWriteLockContexts();
    ContextsLocked = TRUE;

    KerbErr = KerbDecryptDataEx(
                &Reply->encrypted_part,
                &Context->TicketKey,
                KERB_AP_REP_SALT,
                (PULONG) &Reply->encrypted_part.cipher_text.length,
                Reply->encrypted_part.cipher_text.value
                );
    KerbUnlockTicketCache();

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "Failed to decrypt AP reply: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        if (KerbErr == KRB_ERR_GENERIC)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            Status = STATUS_LOGON_FAILURE;
        }
        goto Cleanup;
    }

    //
    // Decode the contents now
    //

    if (!KERB_SUCCESS(KerbUnpackApReplyBody(
                        Reply->encrypted_part.cipher_text.value,
                        Reply->encrypted_part.cipher_text.length,
                        &ReplyBody)))
    {
        DebugLog((DEB_ERROR, "Failed to unpack AP reply body. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Check the mutual auth with ctime/utime reply from remote
    // This will check only the ISC KERB AP_Requests & AP_Responses
    // We may want to add in more support into the DCE path in ASC() - TBD
    //

    if ((Context->ContextAttributes & KERB_CONTEXT_OUTBOUND) != 0)
    {
        KerbConvertLargeIntToGeneralizedTimeWrapper(
            &AP_REQ_client_time,
            &AP_REQ_client_usec,
            &Context->AuthenticatorTime
        );

        if ((AP_REQ_client_usec != ReplyBody->client_usec) ||
            (!KerbKerbTimeEqual(&AP_REQ_client_time, &(ReplyBody->client_time))))
        {
            DebugLog((DEB_ERROR,"AP Authenticator times match Failed!\n"));
            D_DebugLog((DEB_ERROR,"Context   %d/%d/%d %d:%d:%d.%d\n",
                        AP_REQ_client_time.month, AP_REQ_client_time.day, AP_REQ_client_time.year,
                        AP_REQ_client_time.hour, AP_REQ_client_time.minute, AP_REQ_client_time.second,
                        AP_REQ_client_usec));
            D_DebugLog((DEB_ERROR,"AP_Reply   %d/%d/%d %d:%d:%d.%d\n",
                        ReplyBody->client_time.month, ReplyBody->client_time.day, ReplyBody->client_time.year,
                        ReplyBody->client_time.hour, ReplyBody->client_time.minute, ReplyBody->client_time.second,
                        ReplyBody->client_usec));

            // ASSERT(0);

            //   Kerb error KRB_AP_ERR_MUT_FAIL
            Status = STATUS_MUTUAL_AUTHENTICATION_FAILED;
            goto Cleanup;
        }
    }

    if ((ReplyBody->bit_mask & KERB_ENCRYPTED_AP_REPLY_sequence_number_present) != 0)
    {
        *Nonce = ReplyBody->KERB_ENCRYPTED_AP_REPLY_sequence_number;

        D_DebugLog((DEB_TRACE,"Verifying AP reply: AP nonce = 0x%x, context nonce = 0x%x, receive nonce = 0x%x\n",
             *Nonce,
             Context->Nonce,
             Context->ReceiveNonce
             ));
        //
        // If this is a third-leg AP reply, verify the nonce.
        //

        if ((Context->ContextAttributes & KERB_CONTEXT_INBOUND) != 0)
        {
            if (*Nonce != Context->Nonce)
            {
                D_DebugLog((DEB_ERROR,"Nonce in third-leg AP rep didn't match context: 0x%x vs 0x%x\n",
                    *Nonce, Context->Nonce ));
                Status = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }
        }
    }
    else
    {
        *Nonce = 0;
    }

    //
    // Check to see if a new session key was sent back. If it was, stick it
    // in the context.
    //

    if ((ReplyBody->bit_mask & KERB_ENCRYPTED_AP_REPLY_subkey_present) != 0)
    {
        KerbFreeKey(&Context->SessionKey);
        if (!KERB_SUCCESS(KerbDuplicateKey(
            &Context->SessionKey,
            &ReplyBody->KERB_ENCRYPTED_AP_REPLY_subkey
            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }

    Status = STATUS_SUCCESS;

Cleanup:

    if (ContextsLocked)
    {
        KerbUnlockContexts();
    }
    if (Reply != NULL)
    {
        KerbFreeApReply(Reply);
    }
    if (ReplyBody != NULL)
    {
        KerbFreeApReplyBody(ReplyBody);
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitGlobalVariables
//
//  Synopsis:   Initializes global variables
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:   NTSTATUS code
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitGlobalVariables(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
#ifndef WIN32_CHICAGO
    LPNET_CONFIG_HANDLE ConfigHandle = NULL;
    BOOL TempBool;
#endif // WIN32_CHICAGO
    ULONG SkewTimeInMinutes = KERB_DEFAULT_SKEWTIME;
    NET_API_STATUS NetStatus = ERROR_SUCCESS;
    ULONG FarKdcTimeout = KERB_BINDING_FAR_DC_TIMEOUT;
    ULONG NearKdcTimeout = KERB_BINDING_NEAR_DC_TIMEOUT;
    ULONG SpnCacheTimeout = KERB_SPN_CACHE_TIMEOUT;
    ULONG S4UCacheTimeout = KERB_S4U_CACHE_TIMEOUT;
    ULONG S4UTicketLifetime = KERB_S4U_TICKET_LIFETIME;

    //
    // Initialize the kerberos token source
    //

    RtlCopyMemory(
        KerberosSource.SourceName,
        "Kerberos",
        sizeof( KerberosSource.SourceName )
        );

    NtAllocateLocallyUniqueId(&KerberosSource.SourceIdentifier);

    KerbGlobalKdcWaitTime = KERB_KDC_WAIT_TIME;
    KerbGlobalKdcCallTimeout = KERB_KDC_CALL_TIMEOUT;
    KerbGlobalKdcCallBackoff = KERB_KDC_CALL_TIMEOUT_BACKOFF;
    KerbGlobalMaxDatagramSize = KERB_MAX_DATAGRAM_SIZE;
    KerbGlobalKdcSendRetries = KERB_MAX_RETRIES;
    KerbGlobalMaxReferralCount = KERB_MAX_REFERRAL_COUNT;
    KerbGlobalUseStrongEncryptionForDatagram = KERB_DEFAULT_USE_STRONG_ENC_DG;
    KerbGlobalDefaultPreauthEtype = KERB_ETYPE_RC4_HMAC_NT;
    KerbGlobalMaxTokenSize = KERBEROS_MAX_TOKEN;

#ifndef WIN32_CHICAGO
    //
    // Set the max authenticator age to be less than the allowed skew time
    // on debug builds so we can have widely varying time on machines but
    // don't build up a huge list of authenticators.
    //


    NetStatus = NetpOpenConfigDataWithPath(
                    &ConfigHandle,
                    NULL,               // no server name
                    KERB_PATH,
                    TRUE                // read only
                    );
    if (NetStatus == ERROR_SUCCESS)
    {
        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_SKEWTIME,
                        KERB_DEFAULT_SKEWTIME,
                        &SkewTimeInMinutes
                        );

        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_MAX_TOKEN_SIZE,
                        KERBEROS_MAX_TOKEN,
                        &KerbGlobalMaxTokenSize
                        );

        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        //
        // Get the far timeout for the kdc
        //

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_FAR_KDC_TIMEOUT,
                        KERB_BINDING_FAR_DC_TIMEOUT,
                        &FarKdcTimeout
                        );

        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        //
        // Get the near timeout for the kdc
        //

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_NEAR_KDC_TIMEOUT,
                        KERB_BINDING_NEAR_DC_TIMEOUT,
                        &NearKdcTimeout
                        );

        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        //
        // Get the SPN cache lifetime
        //

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_SPN_CACHE_TIMEOUT,
                        KERB_SPN_CACHE_TIMEOUT,
                        &SpnCacheTimeout
                        );

        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        //
        // Get the S4U cache lifetime
        //

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_S4UCACHE_TIMEOUT,
                        KERB_S4U_CACHE_TIMEOUT,
                        &S4UCacheTimeout
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        //
        // Get the S4U ticket and ticket cache - must be at least 5 
        // minutes long, though, or you'll get all sorts of bogus errors.
        //

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_S4UTICKET_LIFETIME,
                        KERB_S4U_TICKET_LIFETIME,
                        &S4UTicketLifetime
                        );

        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        if ( S4UTicketLifetime < KERB_MIN_S4UTICKET_LIFETIME )
        {
           S4UTicketLifetime = KERB_MIN_S4UTICKET_LIFETIME;
        }

        NetStatus = NetpGetConfigBool(
                        ConfigHandle,
                        KERB_PARAMETER_CACHE_S4UTICKET,
                        KERB_DEFAULT_CACHE_S4UTICKET,
                        &TempBool
                        );

        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        KerbGlobalCacheS4UTicket = (BOOLEAN)(TempBool != 0 );
        
        //
        // Get the wait time for the service to start
        //

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_START_TIME,
                        KERB_KDC_WAIT_TIME,
                        &KerbGlobalKdcWaitTime
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_KDC_CALL_TIMEOUT,
                        KERB_KDC_CALL_TIMEOUT,
                        &KerbGlobalKdcCallTimeout
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_MAX_UDP_PACKET,
                        KERB_MAX_DATAGRAM_SIZE,
                        &KerbGlobalMaxDatagramSize
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }
        else
        {
            //
            // UDP packets have a 2-byte length field so under no
            // circumstances can they be bigger than 64K
            //

            KerbGlobalMaxDatagramSize = min( KerbGlobalMaxDatagramSize, 64*1024 );
        }

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_KDC_BACKOFF_TIME,
                        KERB_KDC_CALL_TIMEOUT_BACKOFF,
                        &KerbGlobalKdcCallBackoff
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_MAX_REFERRAL_COUNT,
                        KERB_MAX_REFERRAL_COUNT,
                        &KerbGlobalMaxReferralCount
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_KDC_SEND_RETRIES,
                        KERB_MAX_RETRIES,
                        &KerbGlobalKdcSendRetries
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_DEFAULT_ETYPE,
                        KerbGlobalDefaultPreauthEtype,
                        &KerbGlobalDefaultPreauthEtype
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        NetStatus = NetpGetConfigDword(
                        ConfigHandle,
                        KERB_PARAMETER_REQUEST_OPTIONS,
                        KERB_ADDITIONAL_KDC_OPTIONS,
                        &KerbGlobalKdcOptions
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }

        //
        // BUG 454981: get this from the same place as NTLM
        //

        NetStatus = NetpGetConfigBool(
                        ConfigHandle,
                        KERB_PARAMETER_STRONG_ENC_DG,
                        KERB_DEFAULT_USE_STRONG_ENC_DG,
                        &TempBool
                        );
        if (!NT_SUCCESS(NetStatus))
        {
            Status = NetpApiStatusToNtStatus(NetStatus);
            goto Cleanup;
        }
        KerbGlobalUseStrongEncryptionForDatagram = (BOOLEAN)(TempBool != 0 );
    }
#endif // WIN32_CHICAGO


    KerbSetTimeInMinutes(&KerbGlobalSkewTime, SkewTimeInMinutes);
    KerbSetTimeInMinutes(&KerbGlobalFarKdcTimeout,FarKdcTimeout);
    KerbSetTimeInMinutes(&KerbGlobalNearKdcTimeout, NearKdcTimeout);
    KerbSetTimeInMinutes(&KerbGlobalSpnCacheTimeout, SpnCacheTimeout);
    KerbSetTimeInMinutes(&KerbGlobalS4UCacheTimeout, S4UCacheTimeout);
    KerbSetTimeInMinutes(&KerbGlobalS4UTicketLifetime, S4UTicketLifetime);

    goto Cleanup; // needed for WIN32_CHICAGO builds to use Cleanup label

Cleanup:
#ifndef WIN32_CHICAGO
    if (ConfigHandle != NULL)
    {
        NetpCloseConfigData( ConfigHandle );
    }
#endif // WIN32_CHICAGO

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitTicketHandling
//
//  Synopsis:   Initializes ticket handling, such as authenticator list
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:   NTSTATUS code
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitTicketHandling(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    // Set global variables
    Status = KerbInitGlobalVariables();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

#ifndef WIN32_CHICAGO
    Authenticators = new CAuthenticatorList( KerbGlobalSkewTime );
    if (Authenticators == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = Authenticators->Init();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
#endif WIN32_CHICAGO


    //
    // Initialize the time skew code
    //

    Status = KerbInitializeSkewState();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
Cleanup:

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCleanupTicketHandling
//
//  Synopsis:   cleans up ticket handling state, such as the
//              list of authenticators.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbCleanupTicketHandling(
    VOID
    )
{
#ifndef WIN32_CHICAGO
    if (Authenticators != NULL)
    {
        delete Authenticators;
    }
#endif // WIN32_CHICAGO
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildTgtRequest
//
//  Synopsis:   Creates a tgt request for user-to-user authentication
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildTgtRequest(
    IN PKERB_INTERNAL_NAME TargetName,
    IN PUNICODE_STRING TargetRealm,
    OUT PULONG ContextAttributes,
    OUT PUCHAR * MarshalledTgtRequest,
    OUT PULONG TgtRequestSize
    )
{
    KERB_TGT_REQUEST Request = {0};
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PBYTE TempRequest = NULL;
    PBYTE RequestStart;
    ULONG TempRequestSize = 0;

    D_DebugLog((DEB_TRACE_U2U, "KerbBuildTgtRequest TargetRealm %wZ, TargetName ", TargetRealm));
    D_KerbPrintKdcName((DEB_TRACE_U2U, TargetName));

    //
    // First build the request
    //

    Request.version = KERBEROS_VERSION;
    Request.message_type = KRB_TGT_REQ;
    if (TargetName->NameCount > 0)
    {
        KerbErr = KerbConvertKdcNameToPrincipalName(
                    &Request.KERB_TGT_REQUEST_server_name,
                    TargetName
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }
        Request.bit_mask |= KERB_TGT_REQUEST_server_name_present;
    }
    else
    {
        *ContextAttributes |= KERB_CONTEXT_REQ_SERVER_NAME;
    }

    if (TargetRealm->Length > 0)
    {
        KerbErr = KerbConvertUnicodeStringToRealm(
                        &Request.server_realm,
                        TargetRealm
                        );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }
        Request.bit_mask |= server_realm_present;
    }
    else
    {
        *ContextAttributes |= KERB_CONTEXT_REQ_SERVER_REALM;
    }

    //
    // Encode the request
    //

    KerbErr = KerbPackData(
                &Request,
                KERB_TGT_REQUEST_PDU,
                &TempRequestSize,
                &TempRequest
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Now add on the space for the OID
    //

    *TgtRequestSize = g_token_size(
                        gss_mech_krb5_u2u,
                        TempRequestSize
                        );

    *MarshalledTgtRequest = (PBYTE) MIDL_user_allocate(
                                        *TgtRequestSize
                                        );

    if (*MarshalledTgtRequest == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Add the token ID & mechanism
    //

    RequestStart = *MarshalledTgtRequest;

    g_make_token_header(
        gss_mech_krb5_u2u,
        TempRequestSize,
        &RequestStart,
        KG_TOK_CTX_TGT_REQ
        );

    RtlCopyMemory(
        RequestStart,
        TempRequest,
        TempRequestSize
        );

    Status = STATUS_SUCCESS;

Cleanup:

    if (TempRequest != NULL )
    {
        MIDL_user_free(TempRequest);
    }

    KerbFreePrincipalName(
        &Request.KERB_TGT_REQUEST_server_name
        );

    if ((Request.bit_mask & server_realm_present) != 0)
    {
        KerbFreeRealm(
            &Request.server_realm
            );
    }

    return (Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildTgtReply
//
//  Synopsis:   Builds a TGT reply with the appropriate options set
//
//  Effects:
//
//  Arguments:
//
//  Requires:   The logonsession / credential must be LOCKD!
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildTgtReply(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credentials,
    IN PUNICODE_STRING pSuppRealm,
    OUT PKERBERR ReturnedError,
    OUT OPTIONAL PBYTE * MarshalledReply,
    OUT OPTIONAL PULONG ReplySize,
    OUT PKERB_TICKET_CACHE_ENTRY  * TgtUsed
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    KERBERR KerbErr = KDC_ERR_NONE;
    KERB_TICKET_CACHE_ENTRY* TicketGrantingTicket = NULL;
    KERB_TGT_REPLY Reply = {0};
    UNICODE_STRING TempName = {0};
    BOOLEAN CrossRealm = FALSE;

    *TgtUsed = NULL;                    ;

    D_DebugLog((DEB_TRACE_U2U, "KerbBuildTgtReply SuppRealm %wZ\n", pSuppRealm));

    Status = KerbGetTgtForService(
                LogonSession,
                Credentials,
                NULL, // no credman on the server side
                pSuppRealm, // SuppRealm is the server's realm
                &TempName,  // no target realm
                KERB_TICKET_CACHE_PRIMARY_TGT,
                &TicketGrantingTicket,
                &CrossRealm
                );

    if (!NT_SUCCESS(Status) || CrossRealm)
    {
        DebugLog((DEB_ERROR, "KerbBuildTgtReply failed to get TGT: %#x, CrossRealm ? %s, SuppRealm %wZ\n", Status, CrossRealm ? "true" : "false", pSuppRealm));
        *ReturnedError = KRB_AP_ERR_NO_TGT;
        Status = STATUS_USER2USER_REQUIRED;
        goto Cleanup;
    }

    Reply.version = KERBEROS_VERSION;
    Reply.message_type = KRB_TGT_REP;

    KerbReadLockTicketCache();
    Reply.ticket = TicketGrantingTicket->Ticket;

    //
    // Marshall the output
    //

    KerbErr = KerbPackData(
                &Reply,
                KERB_TGT_REPLY_PDU,
                ReplySize,
                MarshalledReply
                );

    KerbUnlockTicketCache();

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    *TgtUsed = TicketGrantingTicket;
    TicketGrantingTicket = NULL;

Cleanup:

    if (TicketGrantingTicket != NULL)
    {
        KerbDereferenceTicketCacheEntry(TicketGrantingTicket);
    }

    KerbFreeString(&TempName);

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildTgtErrorReply
//
//  Synopsis:   Builds a TgtReply message for use in a KERB_ERROR message
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbBuildTgtErrorReply(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN BOOLEAN UseSuppliedCreds,
    IN OUT PKERB_CONTEXT Context,
    OUT PULONG ReplySize,
    OUT PBYTE * Reply
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_PRIMARY_CREDENTIAL PrimaryCredentials;
    PKERB_TICKET_CACHE_ENTRY TgtUsed = NULL, OldTgt = NULL;

    KerbReadLockLogonSessions(LogonSession);

    if ( UseSuppliedCreds )
    {
        PrimaryCredentials = Credential->SuppliedCredentials;
    }
    else
    {
        PrimaryCredentials = &LogonSession->PrimaryCredentials;
    }

    Status = KerbBuildTgtReply(
                LogonSession,
                Credential,
                &PrimaryCredentials->DomainName,
                &KerbErr,
                Reply,
                ReplySize,
                &TgtUsed
                );
    KerbUnlockLogonSessions(LogonSession);

    //
    //Store the cache entry in the context
    //

    if (NT_SUCCESS(Status))
    {
        KerbWriteLockContexts();
        OldTgt = Context->TicketCacheEntry;
        Context->TicketCacheEntry = TgtUsed;

        //
        // On the error path, do not set KERB_CONTEXT_USER_TO_USER because the
        // client do not expect user2user at this moment
        //
        // Context->ContextAttributes |= KERB_CONTEXT_USER_TO_USER;
        //

        KerbUnlockContexts();

        DebugLog((DEB_TRACE_U2U, "KerbHandleTgtRequest (TGT in error reply) saving ASC context->TicketCacheEntry, TGT is %p, was %p\n", TgtUsed, OldTgt));

        TgtUsed = NULL;

        if (OldTgt != NULL)
        {
            KerbDereferenceTicketCacheEntry(OldTgt);
        }
    }
    return (Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbHandleTgtRequest
//
//  Synopsis:   Processes a request for a TGT. It will verify the supplied
//              principal names and marshall a TGT response structure
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbHandleTgtRequest(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential,
    IN BOOLEAN UseSuppliedCreds,
    IN PUCHAR RequestMessage,
    IN ULONG RequestSize,
    IN ULONG ContextRequirements,
    IN PSecBuffer OutputToken,
    IN PLUID LogonId,
    OUT PULONG ContextAttributes,
    OUT PKERB_CONTEXT * Context,
    OUT PTimeStamp ContextLifetime,
    OUT PKERBERR ReturnedError
    )
{
    ULONG StrippedRequestSize;
    PUCHAR StrippedRequest;
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_TGT_REQUEST Request = NULL;
    BOOLEAN LockAcquired = FALSE;
    PKERB_PRIMARY_CREDENTIAL PrimaryCredentials;
    PKERB_TICKET_CACHE_ENTRY pOldTgt = NULL;
    ULONG ReplySize = 0;
    PBYTE MarshalledReply = NULL;
    ULONG FinalSize;
    PBYTE ReplyStart;
    PKERB_TICKET_CACHE_ENTRY TgtUsed = NULL;

    D_DebugLog((DEB_TRACE_U2U, "KerbHandleTgtRequest UseSuppliedCreds %s, ContextRequirements %#x\n",
              UseSuppliedCreds ? "true" : "false", ContextRequirements));

    StrippedRequestSize = RequestSize;
    StrippedRequest = RequestMessage;

    *ReturnedError = KDC_ERR_NONE;

    //
    // We need an output  token
    //

    if (OutputToken == NULL)
    {
        return(SEC_E_INVALID_TOKEN);
    }

    //
    // Check if this is user-to-user kerberos
    //

    if (g_verify_token_header(
            gss_mech_krb5_u2u,
            (INT *) &StrippedRequestSize,
            &StrippedRequest,
            KG_TOK_CTX_TGT_REQ,
            RequestSize))
    {
        *ContextAttributes |= ASC_RET_USE_SESSION_KEY;
    }
    else
    {
        Status = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // Decode the tgt request message.
    //

    KerbErr = KerbUnpackData(
                StrippedRequest,
                StrippedRequestSize,
                KERB_TGT_REQUEST_PDU,
                (PVOID *) &Request
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to decode TGT request: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    DsysAssert( !LockAcquired );
    KerbReadLockLogonSessions(LogonSession);
    LockAcquired = TRUE;

    if ( UseSuppliedCreds )
    {
        PrimaryCredentials = Credential->SuppliedCredentials;
    }
    else
    {
        PrimaryCredentials = &LogonSession->PrimaryCredentials;
    }

    //
    // Check the supplied principal name and realm to see if it matches
    // out credentials
    //

    //
    // We don't need to verify the server name because the client can do
    // that.
    //

    //
    // Allocate a context
    //

    Status = KerbCreateEmptyContext(
                Credential,
                ASC_RET_USE_SESSION_KEY,        // indicating user-to-user
                KERB_CONTEXT_USER_TO_USER | KERB_CONTEXT_INBOUND,
                0,                              // no nego info here.
                LogonId,
                Context,
                ContextLifetime
                );
    DebugLog((DEB_TRACE_U2U, "KerbHandleTgtRequest (TGT in TGT reply) USER2USER-INBOUND set %#x\n", Status));

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbBuildTgtReply(
                LogonSession,
                Credential,
                &PrimaryCredentials->DomainName,
                ReturnedError,
                &MarshalledReply,
                &ReplySize,
                &TgtUsed
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Put it in the context for later use
    //

    KerbWriteLockContexts();
    pOldTgt = (*Context)->TicketCacheEntry;
    (*Context)->TicketCacheEntry = TgtUsed;
    KerbUnlockContexts();

    DebugLog((DEB_TRACE_U2U, "KerbHandleTgtRequest (TGT in TGT reply) saving ASC context->TicketCacheEntry, TGT is %p, was %p\n", TgtUsed, pOldTgt));
    TgtUsed = NULL;

    if (pOldTgt)
    {
        KerbDereferenceTicketCacheEntry(pOldTgt);
        pOldTgt = NULL;
    }

    //
    // Now build the output message
    //

    FinalSize = g_token_size(
                    gss_mech_krb5_u2u,
                    ReplySize
                    );

    if ((ContextRequirements & ASC_REQ_ALLOCATE_MEMORY) == 0)
    {
        if (OutputToken->cbBuffer < FinalSize)
        {
            D_DebugLog((DEB_ERROR,"Output token is too small - sent in %d, needed %d. %ws, line %d\n",
                OutputToken->cbBuffer,ReplySize, THIS_FILE, __LINE__ ));
            Status = STATUS_BUFFER_TOO_SMALL;
            goto Cleanup;
        }
    }
    else
    {
        OutputToken->pvBuffer = KerbAllocate(FinalSize);
        if (OutputToken->pvBuffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        *ContextAttributes |= ISC_RET_ALLOCATED_MEMORY;
    }

    ReplyStart = (PUCHAR) OutputToken->pvBuffer;
    g_make_token_header(
        gss_mech_krb5_u2u,
        ReplySize,
        &ReplyStart,
        KG_TOK_CTX_TGT_REP
        );

    RtlCopyMemory(
        ReplyStart,
        MarshalledReply,
        ReplySize
        );

    OutputToken->cbBuffer = FinalSize;
    KerbWriteLockContexts();
    (*Context)->ContextState = TgtReplySentState;
    KerbUnlockContexts();

Cleanup:

    if (LockAcquired)
    {
        KerbUnlockLogonSessions(LogonSession);
    }
    if (TgtUsed != NULL)
    {
        KerbDereferenceTicketCacheEntry(TgtUsed);
    }
    if (MarshalledReply != NULL)
    {
        MIDL_user_free(MarshalledReply);
    }
    if (Request != NULL)
    {
        KerbFreeData(KERB_TGT_REQUEST_PDU, Request);
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbUnpackTgtReply
//
//  Synopsis:   Unpacks a TGT reply and verifies contents, sticking
//              reply into context.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbUnpackTgtReply(
    IN PKERB_CONTEXT Context,
    IN PUCHAR ReplyMessage,
    IN ULONG ReplySize,
    OUT PKERB_INTERNAL_NAME * TargetName,
    OUT PUNICODE_STRING TargetRealm,
    OUT PKERB_TGT_REPLY * Reply
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    UNICODE_STRING LocalTargetRealm = {0};
    PUCHAR StrippedReply = ReplyMessage;
    ULONG StrippedReplySize = ReplySize;
    ULONG ContextAttributes;

    *Reply = NULL;
    KerbReadLockContexts();
    ContextAttributes = Context->ContextAttributes;
    KerbUnlockContexts();

    D_DebugLog((DEB_TRACE_U2U, "KerbUnpackTgtReply is User2User set in ContextAttributes? %s\n", ContextAttributes & KERB_CONTEXT_USER_TO_USER ? "yes" : "no"));

    //
    // Verify the OID header on the response. If this wasn't a user-to-user
    // context then the message came from a KERB_ERROR message and won't
    // have the OID header.
    //

    if ((ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
    {
        if (!g_verify_token_header(
                gss_mech_krb5_u2u,
                (INT *) &StrippedReplySize,
                &StrippedReply,
                KG_TOK_CTX_TGT_REP,
                ReplySize))
        {
            D_DebugLog((DEB_WARN, "KerbUnpackTgtReply failed to verify u2u token header\n"));
            Status = SEC_E_INVALID_TOKEN;
            goto Cleanup;
        }
    }
    else
    {
        StrippedReply = ReplyMessage;
        StrippedReplySize = ReplySize;

        //
        // this is an error tgt reply
        //

        KerbWriteLockContexts();
        Context->ContextFlags |= ISC_RET_USE_SESSION_KEY;

        //
        // KERB_CONTEXT_USER_TO_USER needs to be set
        //

        Context->ContextAttributes |= KERB_CONTEXT_USER_TO_USER;
        KerbUnlockContexts();

        DebugLog((DEB_TRACE_U2U, "KerbUnpackTgtReply (TGT in error reply) USER2USER-OUTBOUND set\n"));
    }

    //
    // Decode the response
    //

    KerbErr = KerbUnpackData(
                StrippedReply,
                StrippedReplySize,
                KERB_TGT_REPLY_PDU,
                (PVOID *) Reply
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Pull the target name & realm out of the TGT reply message
    //

    KerbErr = KerbConvertRealmToUnicodeString(
                    &LocalTargetRealm,
                    &(*Reply)->ticket.realm
                    );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // If we were asked to get the server & realm name, use them now
    //

    //
    // BUG 455793: we also use them if we weren't passed a target name on this
    // call. Since we don't require names to be passed, though, this is
    // a security problem, as mutual authentication is no longer guaranteed.
    //

    if (((ContextAttributes & KERB_CONTEXT_REQ_SERVER_REALM) != 0)  ||
        (TargetRealm->Length == 0))
    {
        KerbFreeString(
            TargetRealm
            );
        *TargetRealm = LocalTargetRealm;
        LocalTargetRealm.Buffer = NULL;
    }

    if (((ContextAttributes & KERB_CONTEXT_REQ_SERVER_NAME) != 0) ||
        (((*TargetName)->NameCount == 1) && ((*TargetName)->Names[0].Length == 0)))
    {
        ULONG ProcessFlags = 0;
        UNICODE_STRING TempRealm = {0};

        KerbFreeKdcName(
            TargetName
            );

        Status = KerbProcessTargetNames(
                    &Context->ServerPrincipalName,
                    NULL,                               // no local target name
                    0,                                  // no flags
                    &ProcessFlags,
                    TargetName,
                    &TempRealm,
                    NULL
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        KerbFreeString(&TempRealm);
    }

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (*Reply != NULL)
        {
            KerbFreeData(
                KERB_TGT_REPLY_PDU,
                *Reply
                );
            *Reply = NULL;
        }
    }

    if (LocalTargetRealm.Buffer != NULL)
    {
        KerbFreeString(
            &LocalTargetRealm
            );
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbComputeGssBindHash
//
//  Synopsis:   Computes the Channel Bindings Hash for GSSAPI
//
//  Effects:
//
//  Arguments:
//
//  Requires:   At least 16 bytes allocated to HashBuffer
//
//  Returns:
//
//  Notes:
// (viz. RFC1964)
// MD5 hash of channel bindings, taken over all non-null
// components of bindings, in order of declaration.
// Integer fields within channel bindings are represented
// in little-endian order for the purposes of the MD5
// calculation.
//
//--------------------------------------------------------------------------

NTSTATUS
KerbComputeGssBindHash(
    IN PSEC_CHANNEL_BINDINGS pChannelBindings,
    OUT PUCHAR HashBuffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCHECKSUM_FUNCTION MD5Check = NULL;
    PCHECKSUM_BUFFER MD5ScratchBuffer = NULL;

    //
    // Locate the MD5 Hash Function
    //
    Status = CDLocateCheckSum(KERB_CHECKSUM_MD5, &MD5Check);

    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog( (DEB_ERROR,
                   "Failure Locating MD5: 0x%x. %ws, line %d\n",
                   Status,
                   THIS_FILE,
                   __LINE__) );

        goto Cleanup;
    }

    //
    // Initialize the Buffer
    //
    Status = MD5Check->Initialize(0, &MD5ScratchBuffer);

    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog( (DEB_ERROR,
                   "Failure initializing MD5: 0x%x. %ws, line %d\n",
                   Status,
                   THIS_FILE,
                   __LINE__) );

        goto Cleanup;
    }

    //
    // Build the MD5 hash
    //
    Status = MD5Check->Sum(MD5ScratchBuffer,
                           sizeof(DWORD),
                           (PUCHAR) &pChannelBindings->dwInitiatorAddrType );

    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog( (DEB_ERROR,
                   "Failure building MD5: 0x%x. %ws, line %d\n",
                   Status,
                   THIS_FILE,
                   __LINE__) );
    }

    Status = MD5Check->Sum(MD5ScratchBuffer,
                           sizeof(DWORD),
                           (PUCHAR) &pChannelBindings->cbInitiatorLength );

    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog( (DEB_ERROR,
                   "Failure building MD5: 0x%x. %ws, line %d\n",
                    Status,
                    THIS_FILE,
                    __LINE__) );
    }

    if( pChannelBindings->cbInitiatorLength )
    {
        Status = MD5Check->Sum(MD5ScratchBuffer,
                               pChannelBindings->cbInitiatorLength,
                               (PUCHAR) pChannelBindings + pChannelBindings->dwInitiatorOffset);

        if( !NT_SUCCESS(Status) )
        {
            D_DebugLog( (DEB_ERROR,
                       "Failure building MD5: 0x%x. %ws, line %d\n",
                        Status,
                        THIS_FILE,
                        __LINE__) );
        }
    }

    Status = MD5Check->Sum(MD5ScratchBuffer,
                           sizeof(DWORD),
                           (PUCHAR) &pChannelBindings->dwAcceptorAddrType);

    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog( (DEB_ERROR,
                   "Failure building MD5: 0x%x. %ws, line %d\n",
                   Status,
                   THIS_FILE,
                   __LINE__) );
    }

    Status = MD5Check->Sum(MD5ScratchBuffer,
                           sizeof(DWORD),
                           (PUCHAR) &pChannelBindings->cbAcceptorLength);

    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog( (DEB_ERROR,
                   "Failure building MD5: 0x%x. %ws, line %d\n",
                   Status,
                   THIS_FILE,
                   __LINE__) );
    }

    if( pChannelBindings->cbAcceptorLength)
    {
        Status = MD5Check->Sum(MD5ScratchBuffer,
                               pChannelBindings->cbAcceptorLength,
                               (PUCHAR) pChannelBindings + pChannelBindings->dwAcceptorOffset);

        if( !NT_SUCCESS(Status) )
        {
            D_DebugLog( (DEB_ERROR,
                       "Failure building MD5: 0x%x. %ws, line %d\n",
                       Status,
                       THIS_FILE,
                       __LINE__) );
        }
    }

    Status = MD5Check->Sum(MD5ScratchBuffer,
                           sizeof(DWORD),
                           (PUCHAR) &pChannelBindings->cbApplicationDataLength);

    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog( (DEB_ERROR,
                   "Failure building MD5: 0x%x. %ws, line %d\n",
                   Status,
                   THIS_FILE,
                   __LINE__) );
    }

    if( pChannelBindings->cbApplicationDataLength)
    {
        Status = MD5Check->Sum(MD5ScratchBuffer,
                               pChannelBindings->cbApplicationDataLength,
                               (PUCHAR) pChannelBindings + pChannelBindings->dwApplicationDataOffset);

        if( !NT_SUCCESS(Status) )
        {
            D_DebugLog( (DEB_ERROR,
                       "Failure building MD5: 0x%x. %ws, line %d\n",
                       Status,
                       THIS_FILE,
                       __LINE__) );
        }
    }


    //
    // Copy the hash results into the checksum field
    //
    DsysAssert( MD5Check->CheckSumSize == 4*sizeof(ULONG) );

    Status = MD5Check->Finalize( MD5ScratchBuffer, HashBuffer );

    if( !NT_SUCCESS(Status) )
    {
        D_DebugLog( (DEB_ERROR,
                   "Failure Finalizing MD5: 0x%x. %ws, line %d\n",
                   Status,
                   THIS_FILE,
                   __LINE__) );

        goto Cleanup;
    }

Cleanup:

    if( MD5Check != NULL )
    {
        MD5Check->Finish( &MD5ScratchBuffer );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\kerbtrace.h ===
#ifndef _KERBTRACE_H
#define _KERBTRACE_H
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    kerbtrace.h

Abstract:

    Defines appropriate stuff for event tracing a/k/a wmi tracing a/k/a software tracing 

Author:

    15 June 2000   t-ryanj      (* largely stolen from kdctrace.h *)
    
Revision History:

--*/

//
//
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wtypes.h>

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

#include <wmistr.h>
#include <evntrace.h>

#ifdef __cplusplus
}
#endif // __cplusplus

EXTERN_C BOOLEAN          KerbEventTraceFlag;
EXTERN_C TRACEHANDLE      KerbTraceRegistrationHandle;
EXTERN_C TRACEHANDLE      KerbTraceLoggerHandle;

EXTERN_C
ULONG
KerbInitializeTrace();


// be careful with INSERT_ULONG_INTO_MOF; it evaluates its arguments more than once 
#define INSERT_ULONG_INTO_MOF( x, MOF, Start )       \
         (MOF)[(Start)].DataPtr   = (ULONGLONG)&(x); \
	 (MOF)[(Start)].Length    = sizeof(ULONG);
	 
// be careful with INSERT_UNICODE_STRING_INTO_MOF; it evaluates its arguments more than once
#define INSERT_UNICODE_STRING_INTO_MOF( USTRING, MOF, Start )       \
         (MOF)[(Start)].DataPtr   = (ULONGLONG)&((USTRING).Length); \
	 (MOF)[(Start)].Length    = sizeof      ((USTRING).Length); \
	 (MOF)[(Start)+1].DataPtr = (ULONGLONG)  (USTRING).Buffer;  \
	 (MOF)[(Start)+1].Length  =              (USTRING).Length;
	 
typedef struct _KERB_LOGON_INFO 
// Start {No Data}, End {Status, LogonType, (UserName), (LogonDomain)}
{
    EVENT_TRACE_HEADER EventTrace;       
    MOF_FIELD MofData[7];
} KERB_LOGON_INFO, *PKERB_LOGON_INFO;

typedef struct _KERB_INITSC_INFO
// Start {No Data}, End {Status, CredSource, DomainName, UserName, Target, (KerbExtError), (Klininfo)}
{
    EVENT_TRACE_HEADER EventTrace;
    MOF_FIELD MofData[11];
} KERB_INITSC_INFO, *PKERB_INITSC_INFO;

typedef struct _KERB_ACCEPTSC_INFO
// Start {No Data}, End {Status, CredSource, DomainName, UserName, Target}
{
    EVENT_TRACE_HEADER EventTrace;    
    MOF_FIELD MofData[9];
} KERB_ACCEPTSC_INFO, *PKERB_ACCEPTSC_INFO;

typedef struct _KERB_SETPASS_INFO
// Start {No Data}, End {Status, AccountName, AccountRealm, (ClientName), (ClientRealm), (KdcAddress)}
{
    EVENT_TRACE_HEADER EventTrace;
    MOF_FIELD MofData[11];
} KERB_SETPASS_INFO, *PKERB_SETPASS_INFO;

typedef struct _KERB_CHANGEPASS_INFO
// Start {No Data}, End {Status, AccountName, AccountRealm}
{
    EVENT_TRACE_HEADER EventTrace;
    MOF_FIELD MofData[5];
} KERB_CHANGEPASS_INFO, *PKERB_CHANGEPASS_INFO;

// Control Guid
DEFINE_GUID ( /* bba3add2-c229-4cdb-ae2b-57eb6966b0c4 */
    KerbControlGuid,
    0xbba3add2,
    0xc229,
    0x4cdb,
    0xae, 0x2b, 0x57, 0xeb, 0x69, 0x66, 0xb0, 0xc4
  );


// LogonUser Guid
DEFINE_GUID ( /* 8a3b8d86-db1e-47a9-9264-146e097b3c64 */
    KerbLogonGuid,
    0x8a3b8d86,
    0xdb1e,
    0x47a9,
    0x92, 0x64, 0x14, 0x6e, 0x09, 0x7b, 0x3c, 0x64
  );

// InitializeSecurityContext Guid
DEFINE_GUID ( /* 52e82f1a-7cd4-47ed-b5e5-fde7bf64cea6 */
    KerbInitSCGuid,
    0x52e82f1a,
    0x7cd4,
    0x47ed,
    0xb5, 0xe5, 0xfd, 0xe7, 0xbf, 0x64, 0xce, 0xa6
  );

// AcceptSecurityContext Guid
DEFINE_GUID ( /* 94acefe3-9e56-49e3-9895-7240a231c371 */
    KerbAcceptSCGuid,
    0x94acefe3,
    0x9e56,
    0x49e3,
    0x98, 0x95, 0x72, 0x40, 0xa2, 0x31, 0xc3, 0x71
  );

DEFINE_GUID ( /* 94c79108-b23b-4418-9b7f-e6d75a3a0ab2 */
    KerbSetPassGuid,
    0x94c79108,
    0xb23b,
    0x4418,
    0x9b, 0x7f, 0xe6, 0xd7, 0x5a, 0x3a, 0x0a, 0xb2
  );

DEFINE_GUID ( /* c55e606b-334a-488b-b907-384abaa97b04 */
    KerbChangePassGuid,
    0xc55e606b,
    0x334a,
    0x488b,
    0xb9, 0x07, 0x38, 0x4a, 0xba, 0xa9, 0x7b, 0x04
  );

#endif /* _KERBTRACE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\kerbutil.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbutil.cxx
//
// Contents:    Utility functions for Kerberos package
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>
#ifndef WIN32_CHICAGO
#include <nb30.h>
#else // WIN32_CHICAGO
#define NCBNAMSZ 16
#endif // WIN32_CHICAGO
#include <userapi.h>            // for gss support routines

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

GUID GUID_NULL = {0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};




//+-------------------------------------------------------------------------
//
//  Function:   KerbSplitFullServiceName
//
//  Synopsis:   Splits a full service name into a domain name and a
//              service name. The output strings point into the input
//              string's buffer and should not be freed
//
//  Effects:
//
//  Arguments:  FullServiceName - The full service name in a domain\service
//                      format
//              DomainName - Receives the domain portion of the full service
//                      name in a 'domain' format
//              ServiceName - Receives the service name in a 'service' format
//
//  Requires:
//
//  Returns:    STATUS_INVALID_PARAMETER if the service name does not
//                      match the correct format.
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbSplitFullServiceName(
    IN PUNICODE_STRING FullServiceName,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING ServiceName
    )
{
    UNICODE_STRING TempDomainName;
    UNICODE_STRING TempServiceName;

    TempDomainName = *FullServiceName;

    //
    // Find the split between domain and service name
    //

    TempDomainName.Length = 0;
    while ((TempDomainName.Length < FullServiceName->Length) &&
           (TempDomainName.Buffer[TempDomainName.Length/sizeof(WCHAR)] != L'\\') &&
           (TempDomainName.Buffer[TempDomainName.Length/sizeof(WCHAR)] != L'@') )
    {
        TempDomainName.Length += sizeof(WCHAR);
    }

    //
    // In this case, there is no separator
    //

    if (TempDomainName.Length == FullServiceName->Length)
    {
        *ServiceName = *FullServiceName;
        EMPTY_UNICODE_STRING( DomainName );
        return(STATUS_SUCCESS);
    }

    //
    // If the separator is an "@" switch the doman & service portion
    //

    if (TempDomainName.Buffer[TempDomainName.Length/sizeof(WCHAR)] == L'@')
    {
        TempServiceName = TempDomainName;

        TempDomainName.Buffer = TempServiceName.Buffer + TempServiceName.Length/sizeof(WCHAR) + 1;
        TempServiceName.MaximumLength = TempServiceName.Length;

        //
        // The Domain name is everything else
        //

        TempDomainName.Length = FullServiceName->Length - TempServiceName.Length - sizeof(WCHAR);
        TempDomainName.MaximumLength = TempDomainName.Length;
    }
    else
    {
        TempServiceName.Buffer = TempDomainName.Buffer + TempDomainName.Length/sizeof(WCHAR) + 1;
        TempDomainName.MaximumLength = TempDomainName.Length;

        //
        // The service name is everything else
        //

        TempServiceName.Length = FullServiceName->Length - TempDomainName.Length - sizeof(WCHAR);
        TempServiceName.MaximumLength = TempServiceName.Length;

    }

    //
    // We could be pointing at the end of the buffer.  Set this to NULL
    //
    if (TempServiceName.Length == 0)
    {
        TempServiceName.Buffer = NULL;
    }

    if (TempDomainName.Length == 0)
    {
        TempDomainName.Buffer = NULL;
    }

    *ServiceName = TempServiceName;
    *DomainName = TempDomainName;

    return(STATUS_SUCCESS);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAllocateNonce
//
//  Synopsis:   Allocates a locally unique number
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    the nonce
//
//  Notes:
//
//
//--------------------------------------------------------------------------

ULONG
KerbAllocateNonce(
    VOID
    )
{
    LUID TempLuid;
    TimeStamp CurrentTime;

    NtAllocateLocallyUniqueId(&TempLuid);
    GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);
#ifndef WIN32_CHICAGO
    return(0x7fffffff & (TempLuid.LowPart ^ TempLuid.HighPart ^ CurrentTime.LowPart ^ CurrentTime.HighPart));
#else // WIN32_CHICAGO
    return(0x7fffffff & ((ULONG)(TempLuid.LowPart ^ TempLuid.HighPart ^ CurrentTime)));
#endif // WIN32_CHICAGO
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAllocate
//
//  Synopsis:   Allocate memory in either lsa mode or user mode
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


PVOID
KerbAllocate(
    IN SIZE_T BufferSize
    )
{
    PVOID pBuffer = NULL;
    if (KerberosState == KerberosLsaMode)
    {
        pBuffer = LsaFunctions->AllocateLsaHeap((ULONG) BufferSize);
        // Lsa helper routine zeroes the memory.
    }
    else
    {
        DsysAssert(KerberosState == KerberosUserMode);
        pBuffer = LocalAlloc(0,BufferSize);
        if (pBuffer)
        {
            RtlZeroMemory (pBuffer, BufferSize);
        }
    }

    return pBuffer;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFree
//
//  Synopsis:   Free memory in either lsa mode or user mode
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbFree(
    IN PVOID Buffer
    )
{
    if (ARGUMENT_PRESENT(Buffer))
    {
        if (KerberosState == KerberosLsaMode)
        {
            LsaFunctions->FreeLsaHeap(Buffer);
        }
        else
        {
            DsysAssert(KerberosState == KerberosUserMode);
            LocalFree(Buffer);
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbStringToUnicodeString()
//
//  Synopsis:   Takes a ansi string and (1) unicodes it, (2) copies it
//
//  Effects:
//
//  Arguments: pDest must be initialized unicode string
//
//  Requires:
//
//  Returns:   Free .buffer using KerbFree()
//
//  Notes:
//
//--------------------------------------------------------------------------
BOOLEAN
KerbMbStringToUnicodeString(PUNICODE_STRING     pDest,
                            char *              pszString)
{
    int cbNewString = 0;
    USHORT cbOriginalString;
    BOOLEAN fRet = FALSE;

    cbOriginalString = (USHORT) strlen(pszString) + 1;



    cbNewString = MultiByteToWideChar(
                    CP_OEMCP, 
                    MB_PRECOMPOSED, 
                    pszString, 
                    cbOriginalString,
                    NULL, 
                    0
                    );   

    if ( cbNewString && ( cbNewString < KERB_MAX_UNICODE_STRING ))
    {
        pDest->Buffer = (PWSTR) KerbAllocate(cbNewString);
        if (NULL == pDest->Buffer)
        {
            return FALSE;
        }  

        if (MultiByteToWideChar(CP_OEMCP, MB_PRECOMPOSED,
                                pszString, cbOriginalString,
                                pDest->Buffer, cbNewString))
        {
            pDest->Length = (USHORT) cbNewString;
            pDest->MaximumLength = (USHORT) cbNewString;
            fRet = TRUE;
        }
    }
        
    return fRet;
}




#ifndef WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   KerbWaitForEvent
//
//  Synopsis:   Wait up to Timeout seconds for EventName to be triggered.
//
//  Effects:
//
//  Arguments:      EventName - Name of event to wait on
//                  Timeout - Timeout for event (in seconds).
//
//  Requires:
//
//  Returns:        STATUS_SUCCESS - Indicates Event was set.
//                  STATUS_NETLOGON_NOT_STARTED - Timeout occurred.
//
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbWaitForEvent(
    IN LPWSTR EventName,
    IN ULONG Timeout
    )
{
    NTSTATUS Status;

    HANDLE EventHandle;
    OBJECT_ATTRIBUTES EventAttributes;
    UNICODE_STRING EventNameString;
    LARGE_INTEGER LocalTimeout;


    //
    // Create an event for us to wait on.
    //

    RtlInitUnicodeString( &EventNameString, EventName);
    InitializeObjectAttributes( &EventAttributes, &EventNameString, 0, 0, NULL);

    Status = NtCreateEvent(
                   &EventHandle,
                   SYNCHRONIZE,
                   &EventAttributes,
                   NotificationEvent,
                   (BOOLEAN) FALSE      // The event is initially not signaled
                   );

    if ( !NT_SUCCESS(Status)) {

        //
        // If the event already exists, the server beat us to creating it.
        // Just open it.
        //

        if( Status == STATUS_OBJECT_NAME_EXISTS ||
            Status == STATUS_OBJECT_NAME_COLLISION ) {

            Status = NtOpenEvent( &EventHandle,
                                  SYNCHRONIZE,
                                  &EventAttributes );

        }
        if ( !NT_SUCCESS(Status)) {
            KdPrint(("[MSV1_0] OpenEvent failed %lx\n", Status ));
            return Status;
        }
    }


    //
    // Wait for NETLOGON to initialize.  Wait a maximum of Timeout seconds.
    //

    LocalTimeout.QuadPart = ((LONGLONG)(Timeout)) * (-10000000);
    Status = NtWaitForSingleObject( EventHandle, (BOOLEAN)FALSE, &LocalTimeout);
    (VOID) NtClose( EventHandle );

    if ( !NT_SUCCESS(Status) || Status == STATUS_TIMEOUT ) {
        if ( Status == STATUS_TIMEOUT ) {
            Status = STATUS_NETLOGON_NOT_STARTED;   // Map to an error condition
        }
        return Status;
    }

    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbWaitForKdc
//
//  Synopsis:   Wait up to Timeout seconds for the netlogon service to start.
//
//  Effects:
//
//  Arguments:  Timeout - Timeout for netlogon (in seconds).
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - Indicates NETLOGON successfully initialized.
//              STATUS_NETLOGON_NOT_STARTED - Timeout occurred.
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbWaitForKdc(
    IN ULONG Timeout
    )
{
    NTSTATUS Status;
    ULONG NetStatus;
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    SERVICE_STATUS ServiceStatus;
    LPQUERY_SERVICE_CONFIG ServiceConfig;
    LPQUERY_SERVICE_CONFIG AllocServiceConfig = NULL;
    QUERY_SERVICE_CONFIG DummyServiceConfig;
    DWORD ServiceConfigSize;
    BOOLEAN AutoStart = FALSE;


    //
    // If the KDC service is currently running,
    //  skip the rest of the tests.
    //

    Status = KerbWaitForEvent( KDC_START_EVENT, 0 );

    if ( NT_SUCCESS(Status) ) {
        KerbKdcStarted = TRUE;
        return Status;
    }


    //
    // Open a handle to the KDC Service.
    //

    ScManagerHandle = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_CONNECT );

    if (ScManagerHandle == NULL) {
        DebugLog((DEB_ERROR, " KerbWaitForKdc: OpenSCManager failed: "
                      "%lu. %ws, line %d\n", GetLastError(), THIS_FILE, __LINE__));
        Status = STATUS_NETLOGON_NOT_STARTED;
        goto Cleanup;
    }

    ServiceHandle = OpenService(
                        ScManagerHandle,
                        SERVICE_KDC,
                        SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG );

    if ( ServiceHandle == NULL ) {
        D_DebugLog((DEB_ERROR, "KerbWaitForKdc: OpenService failed: "
                      "%lu. %ws, line %d\n", GetLastError(), THIS_FILE, __LINE__));
        Status = STATUS_NETLOGON_NOT_STARTED;
        goto Cleanup;
    }


    //
    // If the KDC service isn't configured to be automatically started
    //  by the service controller, don't bother waiting for it to start -
    // just check to see if it is started.
    //
    // ?? Pass "DummyServiceConfig" and "sizeof(..)" since QueryService config
    //  won't allow a null pointer, yet.

    if ( QueryServiceConfig(
            ServiceHandle,
            &DummyServiceConfig,
            sizeof(DummyServiceConfig),
            &ServiceConfigSize )) {

        ServiceConfig = &DummyServiceConfig;

    } else {

        NetStatus = GetLastError();
        if ( NetStatus != ERROR_INSUFFICIENT_BUFFER ) {
            D_DebugLog((DEB_ERROR,"KerbWaitForKdc: QueryServiceConfig failed: "
                      "%lu. %ws, line %d\n", NetStatus, THIS_FILE, __LINE__));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }

        SafeAllocaAllocate(AllocServiceConfig, ServiceConfigSize);

        ServiceConfig = AllocServiceConfig;

        if ( AllocServiceConfig == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        if ( !QueryServiceConfig(
                ServiceHandle,
                ServiceConfig,
                ServiceConfigSize,
                &ServiceConfigSize )) {

            D_DebugLog((DEB_ERROR, "KerbWaitForKdc: QueryServiceConfig "
                      "failed again: %lu. %ws, line %d\n", GetLastError(), THIS_FILE, __LINE__));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }
    }

    if ( ServiceConfig->dwStartType == SERVICE_AUTO_START ) {

        AutoStart = TRUE;
    }



    //
    // Loop waiting for the KDC service to start.
    //

    for (;;) {


        //
        // Query the status of the KDC service.
        //

        if (! QueryServiceStatus( ServiceHandle, &ServiceStatus )) {

            D_DebugLog((DEB_ERROR, "KerbWaitForKdc: QueryServiceStatus failed: "
                          "%lu. %ws, line %d\n", GetLastError(), THIS_FILE, __LINE__ ));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }

        //
        // Return or continue waiting depending on the state of
        //  the KDC service.
        //

        switch( ServiceStatus.dwCurrentState) {
        case SERVICE_RUNNING:
            Status = STATUS_SUCCESS;
            goto Cleanup;

        case SERVICE_STOPPED:

            //
            // If KDC failed to start,
            //  error out now.  The caller has waited long enough to start.
            //
            if ( ServiceStatus.dwWin32ExitCode != ERROR_SERVICE_NEVER_STARTED ){
#if DBG
                D_DebugLog((DEB_ERROR, "KerbWaitForKdc: "
                          "KDC service couldn't start: %lu %lx. %ws, line %d\n",
                          ServiceStatus.dwWin32ExitCode,
                          ServiceStatus.dwWin32ExitCode, THIS_FILE, __LINE__ ));
                if ( ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR ) {
                    D_DebugLog((DEB_ERROR, "         Service specific error code: %lu %lx. %ws, line %d\n",
                              ServiceStatus.dwServiceSpecificExitCode,
                              ServiceStatus.dwServiceSpecificExitCode,
                              THIS_FILE, __LINE__ ));
                }
#endif // DBG
                Status = STATUS_NETLOGON_NOT_STARTED;
                goto Cleanup;
            }

            //
            // If KDC has never been started on this boot,
            //  continue waiting for it to start.
            //

            break;

        //
        // If KDC is trying to start up now,
        //  continue waiting for it to start.
        //
        case SERVICE_START_PENDING:
            break;

        //
        // Any other state is bogus.
        //
        default:
            D_DebugLog((DEB_ERROR, "KerbWaitForKdc: "
                      "Invalid service state: %lu. %ws, line %d\n",
                      ServiceStatus.dwCurrentState, THIS_FILE, __LINE__ ));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;

        }


        //
        // If the service wasn't auto start, don't bother waiting and
        // retrying
        //

        if ((ServiceStatus.dwCurrentState) != SERVICE_START_PENDING && !AutoStart) {
            break;
        }

        //
        // Wait a second for the KDC service to start.
        //  If it has successfully started, just return now.
        //

        Status = KerbWaitForEvent( KDC_START_EVENT, 1 );

        if ( Status != STATUS_NETLOGON_NOT_STARTED ) {
            goto Cleanup;
        }

        //
        // If we've waited long enough for KDC to start,
        //  time out now.
        //

        if ( (--Timeout) == 0 ) {
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }


    }

    /* NOT REACHED */

Cleanup:

    if ( ScManagerHandle != NULL ) {
        (VOID) CloseServiceHandle(ScManagerHandle);
    }

    if ( ServiceHandle != NULL ) {
        (VOID) CloseServiceHandle(ServiceHandle);
    }

    SafeAllocaFree( AllocServiceConfig );

    if (NT_SUCCESS(Status)) {
        KerbKdcStarted = TRUE;
    } else {
        KerbKdcStarted = FALSE;
    }
    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbWaitForService
//
//  Synopsis:   Wait up to Timeout seconds for the service to start.
//
//  Effects:
//
//  Arguments:  ServiceName - Name of service to wait for
//              ServiceEvent - Optionally has event name signalling that
//                      service is started
//              Timeout - Timeout for netlogon (in seconds).
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - Indicates NETLOGON successfully initialized.
//              STATUS_NETLOGON_NOT_STARTED - Timeout occurred.
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbWaitForService(
    IN LPWSTR ServiceName,
    IN OPTIONAL LPWSTR ServiceEvent,
    IN ULONG Timeout
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG NetStatus;
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;
    SERVICE_STATUS ServiceStatus;
    LPQUERY_SERVICE_CONFIG ServiceConfig;
    LPQUERY_SERVICE_CONFIG AllocServiceConfig = NULL;
    QUERY_SERVICE_CONFIG DummyServiceConfig;
    DWORD ServiceConfigSize;
    BOOLEAN AutoStart = FALSE;

    if (ARGUMENT_PRESENT(ServiceEvent))
    {
        //
        // If the KDC service is currently running,
        //  skip the rest of the tests.
        //

        Status = KerbWaitForEvent( ServiceEvent, 0 );

        if ( NT_SUCCESS(Status) ) {
            return Status;
        }


    }


    //
    // Open a handle to the Service.
    //

    ScManagerHandle = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_CONNECT );

    if (ScManagerHandle == NULL) {
        D_DebugLog((DEB_ERROR, " KerbWaitForService: OpenSCManager failed: "
                      "%lu. %ws, line %d\n", GetLastError(), THIS_FILE, __LINE__));
        Status = STATUS_NETLOGON_NOT_STARTED;
        goto Cleanup;
    }

    ServiceHandle = OpenService(
                        ScManagerHandle,
                        ServiceName,
                        SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG );

    if ( ServiceHandle == NULL ) {
        D_DebugLog((DEB_ERROR, "KerbWaitForService: OpenService failed: "
                      "%lu. %ws, line %d\n", GetLastError(), THIS_FILE, __LINE__));
        Status = STATUS_NETLOGON_NOT_STARTED;
        goto Cleanup;
    }


    //
    // If the KDC service isn't configured to be automatically started
    //  by the service controller, don't bother waiting for it to start -
    // just check to see if it is started.
    //
    // ?? Pass "DummyServiceConfig" and "sizeof(..)" since QueryService config
    //  won't allow a null pointer, yet.

    if ( QueryServiceConfig(
            ServiceHandle,
            &DummyServiceConfig,
            sizeof(DummyServiceConfig),
            &ServiceConfigSize )) {

        ServiceConfig = &DummyServiceConfig;

    } else {

        NetStatus = GetLastError();
        if ( NetStatus != ERROR_INSUFFICIENT_BUFFER ) {
            D_DebugLog((DEB_ERROR,"KerbWaitForService: QueryServiceConfig failed: "
                      "%lu. %ws, line %d\n", NetStatus, THIS_FILE, __LINE__));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }

        SafeAllocaAllocate(AllocServiceConfig, ServiceConfigSize);

        ServiceConfig = AllocServiceConfig;

        if ( AllocServiceConfig == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        if ( !QueryServiceConfig(
                ServiceHandle,
                ServiceConfig,
                ServiceConfigSize,
                &ServiceConfigSize )) {

            D_DebugLog((DEB_ERROR, "KerbWaitForService: QueryServiceConfig "
                      "failed again: %lu. %ws, line %d\n", GetLastError(), THIS_FILE, __LINE__));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }
    }

    if ( ServiceConfig->dwStartType == SERVICE_AUTO_START ) {

        AutoStart = TRUE;
    }



    //
    // Loop waiting for the KDC service to start.
    //

    for (;;) {


        //
        // Query the status of the KDC service.
        //

        if (! QueryServiceStatus( ServiceHandle, &ServiceStatus )) {

            D_DebugLog((DEB_ERROR, "KerbWaitForService: QueryServiceStatus failed: "
                          "%lu. %ws, line %d\n", GetLastError(), THIS_FILE, __LINE__ ));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }

        //
        // Return or continue waiting depending on the state of
        //  the KDC service.
        //

        switch( ServiceStatus.dwCurrentState) {
        case SERVICE_RUNNING:
            Status = STATUS_SUCCESS;
            goto Cleanup;

        case SERVICE_STOPPED:

            //
            // If KDC failed to start,
            //  error out now.  The caller has waited long enough to start.
            //
            if ( ServiceStatus.dwWin32ExitCode != ERROR_SERVICE_NEVER_STARTED ){
#if DBG
                D_DebugLog((DEB_ERROR, "KerbWaitForService: "
                          "%ws service couldn't start: %lu %lx. %ws, line %d\n",
                          ServiceName,
                          ServiceStatus.dwWin32ExitCode,
                          ServiceStatus.dwWin32ExitCode, THIS_FILE, __LINE__ ));
                if ( ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR ) {
                    D_DebugLog((DEB_ERROR, "         Service specific error code: %lu %lx. %ws, line %d\n",
                              ServiceStatus.dwServiceSpecificExitCode,
                              ServiceStatus.dwServiceSpecificExitCode,
                              THIS_FILE, __LINE__ ));
                }
#endif // DBG
                Status = STATUS_NETLOGON_NOT_STARTED;
                goto Cleanup;
            }

            //
            // If service has never been started on this boot,
            //  continue waiting for it to start.
            //

            break;

        //
        // If service is trying to start up now,
        //  continue waiting for it to start.
        //
        case SERVICE_START_PENDING:
            break;

        //
        // Any other state is bogus.
        //
        default:
            D_DebugLog((DEB_ERROR, "KerbWaitForService: "
                      "Invalid service state: %lu. %ws, line %d\n",
                      ServiceStatus.dwCurrentState, THIS_FILE, __LINE__ ));
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;

        }


        //
        // If the service wasn't auto start, don't bother waiting and
        // retrying
        //

        if (!AutoStart) {
            break;
        }

        //
        // Wait a second for the KDC service to start.
        //  If it has successfully started, just return now.
        //

        if (ARGUMENT_PRESENT(ServiceEvent))
        {
            Status = KerbWaitForEvent( ServiceEvent, 1 );

            if ( Status != STATUS_NETLOGON_NOT_STARTED ) {
                goto Cleanup;
            }

        }
        else
        {
            Sleep(1000);
        }

        //
        // If we've waited long enough for KDC to start,
        //  time out now.
        //

        if ( (--Timeout) == 0 ) {
            Status = STATUS_NETLOGON_NOT_STARTED;
            goto Cleanup;
        }
    }

    /* NOT REACHED */

Cleanup:

    if ( ScManagerHandle != NULL ) {
        (VOID) CloseServiceHandle(ScManagerHandle);
    }

    if ( ServiceHandle != NULL ) {
        (VOID) CloseServiceHandle(ServiceHandle);
    }

    SafeAllocaFree(AllocServiceConfig);

    return Status;
}
#endif // WIN32_CHICAGO




//+-------------------------------------------------------------------------
//
//  Function:   KerbMapContextFlags
//
//  Synopsis:   Maps the ISC_RET_xx flags to ASC_RET_xxx flags
//
//  Effects:
//
//  Arguments:  ContextFlags - Flags to map
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

struct _KERB_FLAG_MAPPING {
    ULONG InitFlag;
    ULONG AcceptFlag;
}  KerbContextFlagMappingTable[] = {
     {ISC_RET_EXTENDED_ERROR, ASC_RET_EXTENDED_ERROR},
     {ISC_RET_INTEGRITY , ASC_RET_INTEGRITY },
     {ISC_RET_IDENTIFY, ASC_RET_IDENTIFY },
     {ISC_RET_NULL_SESSION, ASC_RET_NULL_SESSION }
};

#define KERB_CONTEXT_FLAG_IDENTICAL 0xFFF & ~( ISC_RET_USED_COLLECTED_CREDS | ISC_RET_USED_SUPPLIED_CREDS)

ULONG
KerbMapContextFlags(
    IN ULONG ContextFlags
    )
{
    ULONG OutputFlags;
    ULONG Index;

    //
    // First copy the identical flags
    //

    OutputFlags = ContextFlags & KERB_CONTEXT_FLAG_IDENTICAL;
    for (Index = 0; Index < sizeof(KerbContextFlagMappingTable) / (2 * sizeof(ULONG)) ;Index++ )
    {
        if ((ContextFlags & KerbContextFlagMappingTable[Index].InitFlag) != 0)
        {
            OutputFlags |= KerbContextFlagMappingTable[Index].AcceptFlag;
        }
    }
    return(OutputFlags);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbIsIpAddress
//
//  Synopsis:   Checks to see if a target name is an IP address
//
//  Effects:    none
//
//  Arguments:  TargetName - Name to check
//
//  Requires:
//
//  Returns:    TRUE if the name is an ip address
//
//  Notes:      IP address consist of only digits and periods, possibly
//              with a terminating '$'.
//
//
//--------------------------------------------------------------------------
BOOLEAN
KerbIsIpAddress(
    IN PUNICODE_STRING TargetName
    )
{
    ULONG Index;
    ULONG  PeriodCount = 0;

    //
    // Null names are not IP addresses.
    //

    if (!ARGUMENT_PRESENT(TargetName) || (TargetName->Length == 0))
    {
        return(FALSE);
    }

    for (Index = 0; Index < TargetName->Length/sizeof(WCHAR) ; Index++ )
    {
        switch(TargetName->Buffer[Index])
        {
        case L'0':
        case L'1':
        case L'2':
        case L'3':
        case L'4':
        case L'5':
        case L'6':
        case L'7':
        case L'8':
        case L'9':
            continue;
        case L'$':
            //
            // Only allow this at the end.
            //

            if (Index != (TargetName->Length/sizeof(WCHAR) -1) )
            {
                return(FALSE);
            }
            continue;
        case L'.':
            PeriodCount++;
            break;
        default:
            return(FALSE);
        }
    }

    //
    // We require a period in the name, so return the FoundPeriod flag
    //

    if (PeriodCount == 3)
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbHidePassword
//
//  Synopsis:   obscures a password in memory
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbHidePassword(
    IN OUT PUNICODE_STRING Password
    )
{
    LsaFunctions->LsaProtectMemory(
                        Password->Buffer,
                        (ULONG)Password->MaximumLength
                        );
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbRevealPassword
//
//  Synopsis:   Reveals a password that has been hidden
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbRevealPassword(
    IN OUT PUNICODE_STRING HiddenPassword
    )
{
    LsaFunctions->LsaUnprotectMemory(
                        HiddenPassword->Buffer,
                        (ULONG)HiddenPassword->MaximumLength
                        );
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicatePassword
//
//  Synopsis:   Duplicates a UNICODE_STRING. If the source string buffer is
//              NULL the destionation will be too.  The MaximumLength contains
//              room for encryption padding data.
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  DestinationString - Receives a copy of the source string
//              SourceString - String to copy
//
//  Requires:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbDuplicatePassword(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    DestinationString->Buffer = NULL;
    DestinationString->Length =
                        DestinationString->MaximumLength =
                        0;

    if ((ARGUMENT_PRESENT(SourceString)) &&
        (SourceString->Buffer != NULL))
    {
        USHORT PaddingLength;

        PaddingLength = RTL_ENCRYPT_MEMORY_SIZE - (SourceString->Length % RTL_ENCRYPT_MEMORY_SIZE);

        if( PaddingLength == RTL_ENCRYPT_MEMORY_SIZE )
        {
            PaddingLength = 0;
        }

        //
        // Make sure we don't overflow maximum length w/ pwd + max padding
        // pwd won't be 65k long :)
        //
        if (SourceString->Length > (KERB_MAX_UNICODE_STRING - RTL_ENCRYPT_MEMORY_SIZE))
        {
            return STATUS_ILL_FORMED_PASSWORD;
        }

        DestinationString->Buffer = (LPWSTR) MIDL_user_allocate(
                                                    SourceString->Length +
                                                    PaddingLength
                                                    );

        if (DestinationString->Buffer != NULL)
        {
            DestinationString->Length = SourceString->Length;
            DestinationString->MaximumLength = SourceString->Length + PaddingLength;
            
            if( DestinationString->MaximumLength == SourceString->MaximumLength )
            {
                //
                // duplicating an already padded buffer -- pickup the original
                // pad.
                //

                RtlCopyMemory(
                    DestinationString->Buffer,
                    SourceString->Buffer,
                    SourceString->MaximumLength
                    );
            } else {

                //
                // duplicating an unpadded buffer -- pickup only the string
                // and fill the rest with pad.
                //

                RtlCopyMemory(
                    DestinationString->Buffer,
                    SourceString->Buffer,
                    SourceString->Length
                    );
            }
        }
        else
        {
            Status = STATUS_NO_MEMORY;
        }
    }

    return Status;
}



#ifdef notdef
// use this if we ever need to map errors in kerb to something else.

//+-------------------------------------------------------------------------
//
//  Function:   KerbMapKerbNtStatusToNtStatus
//
//  Synopsis:   Maps an NT status code to a security status
//              Here's the package's chance to send back generic NtStatus
//              errors
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMapKerbNtStatusToNtStatus(
    IN NTSTATUS Status
    )
{
    return(Status);
}
#endif


void * __cdecl
operator new(
    size_t nSize
    )
{
    return((LPVOID)LocalAlloc(LPTR, nSize));
}

void  __cdecl
operator delete(
    void *pv
    )
{
    LocalFree((HLOCAL)pv);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbExtractDomainName
//
//  Synopsis:   Extracts the domain name from a principal name
//
//  Effects:    Allocates the destination string
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbExtractDomainName(
    OUT PUNICODE_STRING DomainName,
    IN PKERB_INTERNAL_NAME PrincipalName,
    IN PUNICODE_STRING TicketSourceDomain
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING TempPrincipal;
    UNICODE_STRING TempDomain = NULL_UNICODE_STRING;

    EMPTY_UNICODE_STRING( DomainName );

    //
    // We do different things depending on the name type:
    // - for NT_MS_PRINCIPAL we call KerbSplitFullServiceName, then do the
    //      same as for other name types
    // - For all other names, if the first portion is "krbtgt" then
    //      we use the second portion of the name, otherwise the
    //      TicketSourceRealm
    //

    if (PrincipalName->NameType == KRB_NT_MS_PRINCIPAL)
    {
        if (PrincipalName->NameCount != 1)
        {
            D_DebugLog((DEB_ERROR,"Principal name has more than one name. %ws, line %d\n", THIS_FILE, __LINE__ ));
            Status = STATUS_TOO_MANY_PRINCIPALS;
            return(Status);
        }
        else
        {
            Status = KerbSplitFullServiceName(
                        &PrincipalName->Names[0],
                        &TempDomain,
                        &TempPrincipal
                        );
            if (!NT_SUCCESS(Status))
            {
                return(Status);
            }

        }
    }
    else
    {

        //
        // The principal name is the first portion. If there are exactly
        // two portions, the domain name is the second portion
        //

        TempPrincipal = PrincipalName->Names[0];
        if (PrincipalName->NameCount == 2)
        {
            TempDomain = PrincipalName->Names[1];
        }
        else
        {
            TempDomain = *TicketSourceDomain;
        }

    }

    //
    // Check to see if the principal is "krbtgt" - if it is, the domain
    // is TempDomain - otherwise it is TicketSourceDomain.
    //

    if (RtlEqualUnicodeString(
            &TempPrincipal,
            &KerbGlobalKdcServiceName,
            TRUE                      // case insensitive
            ))
    {
        Status = KerbDuplicateString(
                    DomainName,
                    &TempDomain
                    );
    }
    else
    {
        Status = KerbDuplicateString(
                    DomainName,
                    TicketSourceDomain
                    );
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbUtcTimeToLocalTime
//
//  Synopsis:   Converts system time (used internally) to local time, which
//              is returned to callers.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbUtcTimeToLocalTime(
    OUT PTimeStamp LocalTime,
    IN PTimeStamp SystemTime
    )
{
#ifndef WIN32_CHICAGO
    NTSTATUS Status;
    Status = RtlSystemTimeToLocalTime(
                    SystemTime,
                    LocalTime
                    );
    DsysAssert(NT_SUCCESS(Status));
#else
    BOOL Result;
    Result = FileTimeToLocalFileTime(
                (PFILETIME) SystemTime,
                (PFILETIME) LocalTime
                );
    DsysAssert(Result);
#endif

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertKdcOptionsToTicketFlags
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


ULONG
KerbConvertKdcOptionsToTicketFlags(
    IN ULONG KdcOptions
    )
{
    ULONG TicketFlags = 0;

    if ((KdcOptions & KERB_KDC_OPTIONS_forwardable) != 0)
    {
        TicketFlags |= KERB_TICKET_FLAGS_forwardable;
    }

    if ((KdcOptions & KERB_KDC_OPTIONS_forwarded) != 0)
    {
        TicketFlags |= KERB_TICKET_FLAGS_forwarded;
    }

    if ((KdcOptions & KERB_KDC_OPTIONS_proxiable) != 0)
    {
        TicketFlags |= KERB_TICKET_FLAGS_proxiable;
    }

    if ((KdcOptions & KERB_KDC_OPTIONS_proxy) != 0)
    {
        TicketFlags |= KERB_TICKET_FLAGS_proxy;
    }

    if ((KdcOptions & KERB_KDC_OPTIONS_postdated) != 0)
    {
        TicketFlags |= KERB_TICKET_FLAGS_postdated;
    }

    if ((KdcOptions & KERB_KDC_OPTIONS_allow_postdate) != 0)
    {
        TicketFlags |= KERB_TICKET_FLAGS_may_postdate;
    }

    if ((KdcOptions & KERB_KDC_OPTIONS_renewable) != 0)
    {
        TicketFlags |= KERB_TICKET_FLAGS_renewable;
    }

    return(TicketFlags);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetAddressListFromWinsock
//
//  Synopsis:   gets the list of addresses from a winsock ioctl
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbGetAddressListFromWinsock(
    OUT LPSOCKET_ADDRESS_LIST * SocketAddressList
    )
{
    ULONG BytesReturned = 150;
    LPSOCKET_ADDRESS_LIST AddressList = NULL;
    INT i,j;
    ULONG NetStatus;
    NTSTATUS Status = STATUS_SUCCESS;
    SOCKET AddressSocket = INVALID_SOCKET;

#ifdef WIN32_CHICAGO
    j = 0;
    AddressList = (LPSOCKET_ADDRESS_LIST) MIDL_user_allocate(sizeof(SOCKET_ADDRESS_LIST));
    if (AddressList == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
#else // WIN32_CHICAGO
    AddressSocket = WSASocket( AF_INET,
                           SOCK_DGRAM,
                           0, // PF_INET,
                           NULL,
                           0,
                           0 );

    if ( AddressSocket == INVALID_SOCKET ) {

        NetStatus = WSAGetLastError();
        D_DebugLog((DEB_ERROR,"WSASocket failed with %ld. %ws, line %d\n", NetStatus, THIS_FILE, __LINE__ ));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    for (;;) {

        //
        // Allocate a buffer that should be big enough.
        //

        if ( AddressList != NULL ) {
            MIDL_user_free( AddressList );
        }

        AddressList = (LPSOCKET_ADDRESS_LIST) MIDL_user_allocate( BytesReturned );

        if ( AddressList == NULL ) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Get the list of IP addresses
        //

        NetStatus = WSAIoctl( AddressSocket,
                              SIO_ADDRESS_LIST_QUERY,
                              NULL, // No input buffer
                              0,    // No input buffer
                              (PVOID) AddressList,
                              BytesReturned,
                              &BytesReturned,
                              NULL, // No overlapped,
                              NULL );   // Not async

        if ( NetStatus != 0 ) {
            NetStatus = WSAGetLastError();
            //
            // If the buffer isn't big enough, try again.
            //
            if ( NetStatus == WSAEFAULT ) {
                continue;
            }

            D_DebugLog((DEB_ERROR,"KerbGetAddressListFromWinsock: Cannot WSAIoctl SIO_ADDRESS_LIST_QUERY %ld %ld. %ws, line %d\n",
                      NetStatus, BytesReturned, THIS_FILE, __LINE__));
            Status = STATUS_UNSUCCESSFUL;
            goto Cleanup;
        }

        break;
    }

    //
    // Weed out any zero IP addresses and other invalid addresses
    //

    for ( i = 0, j = 0; i < AddressList->iAddressCount; i++ ) {
        PSOCKET_ADDRESS SocketAddress;

        //
        // Copy this address to the front of the list.
        //
        AddressList->Address[j] = AddressList->Address[i];

        //
        // If the address isn't valid,
        //  skip it.
        //
        SocketAddress = &AddressList->Address[j];

        if ( SocketAddress->iSockaddrLength == 0 ||
             SocketAddress->lpSockaddr == NULL ||
             SocketAddress->lpSockaddr->sa_family != AF_INET ||
             ((PSOCKADDR_IN)(SocketAddress->lpSockaddr))->sin_addr.s_addr == 0 ) {


        } else {

            //
            // Otherwise keep it.
            //

            j++;
        }
    }
#endif // WIN32_CHICAGO

    AddressList->iAddressCount = j;
    *SocketAddressList = AddressList;
    AddressList = NULL;

Cleanup:
    if (AddressList != NULL)
    {
        MIDL_user_free(AddressList);
    }

    if ( AddressSocket != INVALID_SOCKET ) {
        closesocket(AddressSocket);
    }

    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildHostAddresses
//
//  Synopsis:   Builds a list of host addresses to go in a KDC request
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbBuildHostAddresses(
    IN BOOLEAN IncludeIpAddresses,
    IN BOOLEAN IncludeNetbiosAddresses,
    OUT PKERB_HOST_ADDRESSES * HostAddresses
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_HOST_ADDRESSES Addresses = NULL;
    PKERB_HOST_ADDRESSES TempAddress = NULL;
    BOOLEAN LockHeld = FALSE;

#ifndef WIN32_CHICAGO

    KerbGlobalReadLock();
    LockHeld = TRUE;

    //
    // Check to see if we've gotten out addresses from Netlogon yet.
    //
    if ( IncludeIpAddresses &&
         KerbGlobalIpAddressCount == 0)
    {
        LPSOCKET_ADDRESS_LIST SocketAddressList = NULL;
        KerbGlobalReleaseLock();
        LockHeld = FALSE;

        //
        // We haven't get them now
        //

        Status = KerbGetAddressListFromWinsock(
                    &SocketAddressList
                    );

        if (NT_SUCCESS(Status))
        {
            Status = KerbUpdateGlobalAddresses(
                        SocketAddressList->Address,
                        SocketAddressList->iAddressCount
                        );
            MIDL_user_free(SocketAddressList);
        }
        else
        {
            KerbGlobalWriteLock();
            KerbGlobalIpAddressesInitialized = TRUE;
            KerbGlobalReleaseLock();
        }
        KerbGlobalReadLock();
        LockHeld = TRUE;
    }

    //
    // On failure don't bother inserting the IP addresses
    //

    if ( Status == STATUS_SUCCESS &&
         IncludeIpAddresses ) {

        ULONG Index;

        for (Index = 0; Index < KerbGlobalIpAddressCount ; Index++ )
        {
            TempAddress = (PKERB_HOST_ADDRESSES) KerbAllocate(sizeof(KERB_HOST_ADDRESSES));
            if (TempAddress == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            TempAddress->value.address_type = KERB_ADDRTYPE_INET;
            TempAddress->value.address.length = 4;
            TempAddress->value.address.value = (PUCHAR) KerbAllocate(4);
            if (TempAddress->value.address.value == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlCopyMemory
               (
                TempAddress->value.address.value,
                &KerbGlobalIpAddresses[Index].sin_addr.S_un.S_addr,
                4
                );
            TempAddress->next = Addresses;
            Addresses = TempAddress;
            TempAddress = NULL;
        }
    }
    else
    {
        Status = STATUS_SUCCESS;
    }

#endif // WIN32_CHICAGO

    //
    // Insert the netbios address (if it will fit)
    //

    if (IncludeNetbiosAddresses &&
        KerbGlobalKerbMachineName.Length < NCBNAMSZ)
    {
        TempAddress = (PKERB_HOST_ADDRESSES) KerbAllocate(sizeof(KERB_HOST_ADDRESSES));
        if (TempAddress == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        TempAddress->value.address_type = KERB_ADDRTYPE_NETBIOS;
        TempAddress->value.address.length = NCBNAMSZ;
        TempAddress->value.address.value = (PUCHAR) KerbAllocate(NCBNAMSZ);
        if (TempAddress->value.address.value == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            TempAddress->value.address.value,
            KerbGlobalKerbMachineName.Buffer,
            KerbGlobalKerbMachineName.Length
            );
        memset(
            TempAddress->value.address.value + KerbGlobalKerbMachineName.Length,
            ' ',        // space
            NCBNAMSZ - KerbGlobalKerbMachineName.Length
            );

        TempAddress->next = Addresses;
        Addresses = TempAddress;
        TempAddress = NULL;

    }

    *HostAddresses = Addresses;
    Addresses = NULL;

Cleanup:

    if (LockHeld)
    {
        KerbGlobalReleaseLock();
    }
    if (TempAddress != NULL)
    {
        if (TempAddress->value.address.value != NULL)
        {
            KerbFree(TempAddress->value.address.value);
        }
        KerbFree(TempAddress);
    }
    if (Addresses != NULL)
    {
        //KerbFreeHostAddresses(Addresses);
        while (Addresses != NULL)
        {
            TempAddress = Addresses;
            Addresses = Addresses->next;
            if (TempAddress->value.address.value != NULL)
            {
                KerbFree(TempAddress->value.address.value);
            }
            KerbFree(TempAddress);
        }
    }

    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildGssErrorMessage
//
//  Synopsis:   Builds an error message with GSS framing, if necessary
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildGssErrorMessage(
    IN KERBERR Error,
    IN PBYTE ErrorData,
    IN ULONG ErrorDataSize,
    IN PKERB_CONTEXT Context,
    OUT PULONG ErrorMessageSize,
    OUT PBYTE * ErrorMessage
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PUNICODE_STRING pDomain = NULL;
    PBYTE RawErrorMessage = NULL;
    ULONG RawErrorMessageSize = 0;
    PBYTE EncodedErrorData = NULL;
    ULONG EncodedErrorDataSize = 0;
    PBYTE MessageStart = NULL;
    KERB_ERROR_METHOD_DATA ApErrorData = {0};
    PKERB_INTERNAL_NAME Spn = NULL;
    gss_OID MechId;


    //
    // First, convert the error data to a specified type
    //

    if (Error == KRB_AP_ERR_SKEW)
    {
        ApErrorData.data_type = KERB_AP_ERR_TYPE_SKEW_RECOVERY;
        ApErrorData.data_value.value = NULL;
        ApErrorData.data_value.length = 0;

        KerbErr = KerbPackData(
                    &ApErrorData,
                    KERB_ERROR_METHOD_DATA_PDU,
                    &EncodedErrorDataSize,
                    &EncodedErrorData
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }
    }
    else if (ErrorDataSize != 0)
    {
        if (Error == KRB_AP_ERR_USER_TO_USER_REQUIRED)
        {
            EncodedErrorData = ErrorData;
            EncodedErrorDataSize = ErrorDataSize;
        }
        else
        {
            ApErrorData.data_type = KERB_AP_ERR_TYPE_NTSTATUS;
            ApErrorData.data_value.value = ErrorData;
            ApErrorData.data_value.length = ErrorDataSize;
            ApErrorData.bit_mask |= data_value_present;

            KerbErr = KerbPackData(
                        &ApErrorData,
                        KERB_ERROR_METHOD_DATA_PDU,
                        &EncodedErrorDataSize,
                        &EncodedErrorData
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                Status = KerbMapKerbError(KerbErr);
                goto Cleanup;
            }
        }
    }

    //
    // First build the error message
    //
    KerbGlobalReadLock();

    if (Context->ServerPrincipalName.Buffer != NULL)
    {
       KerbErr = KerbConvertStringToKdcName(
                     &Spn,
                     &Context->ServerPrincipalName
                     );

       if (!KERB_SUCCESS(KerbErr))
       {
          Status = KerbMapKerbError(KerbErr);
          goto Cleanup;
       }
    }
    else
    {
       Spn = KerbGlobalMitMachineServiceName;
    }


    if (KerbGlobalDnsDomainName.Buffer != NULL)
    {
        pDomain = &KerbGlobalDnsDomainName;
    }
    else if (KerbGlobalDomainName.Buffer != NULL)
    {
        pDomain = &KerbGlobalDomainName;
    }

    KerbErr = KerbBuildErrorMessageEx(
                Error,
                NULL, // no extended error
                pDomain,
                Spn,
                NULL,               // no client realm
                EncodedErrorData,
                EncodedErrorDataSize,
                &RawErrorMessageSize,
                &RawErrorMessage
                );

    KerbGlobalReleaseLock();
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Figure out what OID to use
    //

    KerbReadLockContexts();

    //
    // For DCE style we don't use an OID
    //

    if ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) != 0)
    {
        KerbUnlockContexts();
        *ErrorMessage = RawErrorMessage;
        *ErrorMessageSize = RawErrorMessageSize;
        RawErrorMessage = NULL;
        goto Cleanup;
    }

    if ((Context->ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
    {
        MechId = gss_mech_krb5_u2u;
    }
    else
    {
        MechId = gss_mech_krb5_new;
    }
    KerbUnlockContexts();

    *ErrorMessageSize = g_token_size(MechId, RawErrorMessageSize);

    *ErrorMessage = (PBYTE) KerbAllocate(*ErrorMessageSize);
    if (*ErrorMessage == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // the g_make_token_header will reset this to point to the end of the
    // header
    //


    MessageStart = *ErrorMessage;

    g_make_token_header(
        MechId,
        RawErrorMessageSize,
        &MessageStart,
        KG_TOK_CTX_ERROR
        );

    RtlCopyMemory(
        MessageStart,
        RawErrorMessage,
        RawErrorMessageSize
        );

Cleanup:
    if (RawErrorMessage != NULL)
    {
        MIDL_user_free(RawErrorMessage);
    }
    if (EncodedErrorData != ErrorData)
    {
        MIDL_user_free(EncodedErrorData);
    }

    if (Spn != NULL && Context->ServerPrincipalName.Buffer != NULL)
    {
       MIDL_user_free(Spn);
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbReceiveErrorMessage
//
//  Synopsis:   Unpacks an error message from a context request
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbReceiveErrorMessage(
    IN PBYTE ErrorMessage,
    IN ULONG ErrorMessageSize,
    IN PKERB_CONTEXT Context,
    OUT PKERB_ERROR * DecodedErrorMessage,
    OUT PKERB_ERROR_METHOD_DATA * ErrorData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    PBYTE MessageStart = NULL;
    ULONG MessageSize = 0;
    BOOLEAN VerifiedHeader = FALSE;
    gss_OID MechId = NULL;

    KerbReadLockContexts();

    //
    // For DCE style we don't use an OID
    //

    if ((Context->ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
    {
        MechId = gss_mech_krb5_u2u;
    }
    else
    {
        MechId = gss_mech_krb5_new;
    }
    KerbUnlockContexts();

    //
    // First try pull off the header
    //

    MessageSize = ErrorMessageSize;
    MessageStart = ErrorMessage;

    if (!g_verify_token_header(
            MechId,
            (INT *) &MessageSize,
            &MessageStart,
            KG_TOK_CTX_ERROR,
            ErrorMessageSize
            ))
    {
        //
        // If we couldn't find the header, try it without
        // a header
        //

        MessageSize = ErrorMessageSize;
        MessageStart = ErrorMessage;
    }
    else
    {
        VerifiedHeader = TRUE;
    }

    KerbErr = KerbUnpackKerbError(
        MessageStart,
        MessageSize,
        DecodedErrorMessage
        );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (((*DecodedErrorMessage)->bit_mask & error_data_present) != 0)
    {
        KerbUnpackErrorMethodData(
           *DecodedErrorMessage,
           ErrorData
           );
    }
    else
    {
        Status = KerbMapKerbError(KerbErr);
    }
Cleanup:
    return(Status);
}

#ifndef WIN32_CHICAGO

//+-------------------------------------------------------------------------
//
//  Function:   KerbUnpackErrorMethodData
//
//  Synopsis:   This routine unpacks extended error information from
//              a KERB_ERROR message
//
//  Effects:
//
//  Arguments:    Unpacked error message.  Returns extended error to
//                be freed using KerbFree
//
//  Requires:
//
//  Returns:   NTSTATUS
//
//  Notes:
//
//
//--------------------------------------------------------------------------
KERBERR
KerbUnpackErrorMethodData(
   IN PKERB_ERROR  ErrorMessage,
   IN OUT OPTIONAL PKERB_ERROR_METHOD_DATA * ppErrorData
   )
{

    PKERB_ERROR_METHOD_DATA pErrorData = NULL;
    KERBERR KerbErr = KDC_ERR_NONE;

    if (ARGUMENT_PRESENT(ppErrorData))
    {
       *ppErrorData = NULL;
    }

    if ((ErrorMessage->bit_mask & error_data_present) == 0)
    {
       return (KRB_ERR_GENERIC);
    }

    KerbErr = KerbUnpackData(
        ErrorMessage->error_data.value,
        ErrorMessage->error_data.length,
        KERB_ERROR_METHOD_DATA_PDU,
        (void**) &pErrorData
        );

    if (KERB_SUCCESS(KerbErr) && ARGUMENT_PRESENT(ppErrorData) && (NULL != pErrorData))
    {
        *ppErrorData = pErrorData;
        pErrorData = NULL;
    }

    if (pErrorData)
    {
        KerbFreeData(KERB_ERROR_METHOD_DATA_PDU, pErrorData);
    }

    return (KerbErr);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetDnsHostName
//
//  Synopsis:   This routine gets DnsHostName of this machine.
//
//  Effects:
//
//  Arguments:      DnsHostName - Returns the DNS Host Name of the machine.
//        Will return a NULL string if this machine has no DNS host name.
//        Free this buffer using KerbFreeString.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbGetDnsHostName(
    OUT PUNICODE_STRING DnsHostName
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    WCHAR LocalDnsUnicodeHostName[DNS_MAX_NAME_BUFFER_LENGTH+1];
    ULONG LocalDnsUnicodeHostNameLen = DNS_MAX_NAME_BUFFER_LENGTH+1;
    LPWSTR ConfiguredDnsName = LocalDnsUnicodeHostName;
    UNICODE_STRING HostName;


    RtlInitUnicodeString(
        DnsHostName,
        NULL
        );
    //
    // Get the DNS host name.
    //
    if (!GetComputerNameEx(
            ComputerNameDnsHostname,
            ConfiguredDnsName,
            &LocalDnsUnicodeHostNameLen))
    {
        goto Cleanup;
    }


    ConfiguredDnsName = &LocalDnsUnicodeHostName[LocalDnsUnicodeHostNameLen];
    *ConfiguredDnsName = L'.';
    ConfiguredDnsName++;

    //
    // Now get the DNS domain name
    //

    LocalDnsUnicodeHostNameLen = DNS_MAX_NAME_BUFFER_LENGTH - LocalDnsUnicodeHostNameLen;

    if (!GetComputerNameEx(
            ComputerNameDnsDomain,
            ConfiguredDnsName,
            &LocalDnsUnicodeHostNameLen
            ))
    {
        goto Cleanup;
    }


    RtlInitUnicodeString(
        &HostName,
        LocalDnsUnicodeHostName
        );

    Status = RtlDowncaseUnicodeString(
                &HostName,
                &HostName,
                FALSE           // don't allocate destination
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = KerbDuplicateString(
                DnsHostName,
                &HostName
                );


Cleanup:
    return Status;
}

#endif // WIN32_CHICAGO


//+-------------------------------------------------------------------------
//
//  Function:   KerbIsThisOurDomain
//
//  Synopsis:   Compares a domain name to the local domain anme
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbIsThisOurDomain(
    IN PUNICODE_STRING DomainName
    )
{
    BOOLEAN Result;
    KerbGlobalReadLock();

    Result = KerbCompareUnicodeRealmNames(
                    DomainName,
                    &KerbGlobalDnsDomainName
                    ) ||
             RtlEqualUnicodeString(
                    DomainName,
                    &KerbGlobalDomainName,
                    TRUE
                    );

    KerbGlobalReleaseLock();
    return(Result);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetOurDomainName
//
//  Synopsis:   Copies the machines dns domain name, if available,
//              netbios otherwise.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbGetOurDomainName(
    OUT PUNICODE_STRING DomainName
    )
{
    NTSTATUS Status;
    KerbGlobalReadLock();

    if (KerbGlobalDnsDomainName.Length != 0)
    {
        Status = KerbDuplicateString(
                    DomainName,
                    &KerbGlobalDnsDomainName
                    );
    }
    else
    {
        Status = KerbDuplicateString(
                    DomainName,
                    &KerbGlobalDomainName
                    );
    }

    KerbGlobalReleaseLock();
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetGlobalRole
//
//  Synopsis:   Returns the current role of the machine
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

KERBEROS_MACHINE_ROLE
KerbGetGlobalRole(
    VOID
    )
{
    KERBEROS_MACHINE_ROLE Role;
    KerbGlobalReadLock();
    Role = KerbGlobalRole;
    KerbGlobalReleaseLock();
    return(Role);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbSetComputerName
//
//  Synopsis:   Sets all computer-name related global variables
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbSetComputerName(
    VOID
    )
{
    UNICODE_STRING LocalMachineName;
    STRING LocalKerbMachineName;

    UNICODE_STRING OldMachineName;
    STRING OldKerbMachineName;

    ULONG ComputerNameLength;
    NTSTATUS Status;
    BOOLEAN LockHeld = FALSE;
#ifdef WIN32_CHICAGO
    CHAR TempAnsiBuffer[MAX_COMPUTERNAME_LENGTH + 1];
    ComputerNameLength = sizeof(TempAnsiBuffer);
#endif

    LocalMachineName.Buffer = NULL;
    LocalKerbMachineName.Buffer = NULL;

#ifndef WIN32_CHICAGO
    ComputerNameLength = 0;
    if (GetComputerNameW(
            NULL,
            &ComputerNameLength
            ))
    {
        D_DebugLog((DEB_ERROR,"Succeeded to get computer name when failure expected! %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    LocalMachineName.Buffer = (LPWSTR) KerbAllocate(
                                                ((ComputerNameLength + 1) * sizeof(WCHAR))
                                                );
    if (LocalMachineName.Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
#endif // WIN32_CHICAGO

#ifndef WIN32_CHICAGO
    if (!GetComputerNameW(
            LocalMachineName.Buffer,
            &ComputerNameLength
            ))
#else // WIN32_CHICAGO

    if (!GetComputerName(
            TempAnsiBuffer,
            &ComputerNameLength
            ))
#endif // WIN32_CHICAGO
    {
        D_DebugLog((DEB_ERROR,"Failed to get computer name: %d. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

#ifndef WIN32_CHICAGO
    LocalMachineName.Length = (USHORT)(ComputerNameLength * sizeof(WCHAR));
    LocalMachineName.MaximumLength = LocalMachineName.Length + sizeof(WCHAR);
#else
    RtlCreateUnicodeStringFromAsciiz (&LocalMachineName, TempAnsiBuffer);
//    KerbFree (TempAnsiBuffer);
#endif // WIN32_CHICAGO

    //
    // Build the ansi format
    //

    if (!KERB_SUCCESS(KerbUnicodeStringToKerbString(
            &LocalKerbMachineName,
            &LocalMachineName
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // free the current globals, and update to point at new values.
    //

    KerbGlobalWriteLock();
    LockHeld = TRUE;

    OldMachineName = KerbGlobalMachineName;
    OldKerbMachineName = KerbGlobalKerbMachineName;

    KerbGlobalMachineName = LocalMachineName;
    KerbGlobalKerbMachineName = LocalKerbMachineName;

    //
    // now, see if the netbios machine name changed versus the prior
    // value.
    //

    if( OldMachineName.Buffer != NULL )
    {
        if(!RtlEqualUnicodeString( &OldMachineName, &LocalMachineName, FALSE ))
        {
            D_DebugLog((DEB_WARN,"Netbios computer name change detected.\n"));
            KerbGlobalMachineNameChanged = TRUE;
        }
    }

    KerbGlobalReleaseLock();
    LockHeld = FALSE;

    LocalMachineName.Buffer = NULL;
    LocalKerbMachineName.Buffer = NULL;

    KerbFreeString( &OldMachineName );
    KerbFreeString( (PUNICODE_STRING)&OldKerbMachineName );

    Status = STATUS_SUCCESS;

Cleanup:

    if( LockHeld )
    {
        KerbGlobalReleaseLock();
    }

    KerbFreeString( &LocalMachineName );
    KerbFreeString( (PUNICODE_STRING)&LocalKerbMachineName );

    return Status;
}



//
//
// Routine Description:
//
//  This function checks the system to see if
//  we are running on the personal version of
//  the operating system.
//
//  The personal version is denoted by the product
//  id equal to WINNT, which is really workstation,
//  and the product suite containing the personal
//  suite string.
//

BOOLEAN
KerbRunningPersonal(
    VOID
    )
{
    OSVERSIONINFOEXW OsVer = {0};
    ULONGLONG ConditionMask = 0;

    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    OsVer.wSuiteMask = VER_SUITE_PERSONAL;
    OsVer.wProductType = VER_NT_WORKSTATION;

    VER_SET_CONDITION( ConditionMask, VER_PRODUCT_TYPE, VER_EQUAL );
    VER_SET_CONDITION( ConditionMask, VER_SUITENAME, VER_AND );

    return RtlVerifyVersionInfo( &OsVer,
                                 VER_PRODUCT_TYPE | VER_SUITENAME,
                                 ConditionMask) == STATUS_SUCCESS;
}

BOOLEAN
KerbRunningServer(
    VOID
    )
{
    OSVERSIONINFOEXW OsVer = {0};
    ULONGLONG ConditionMask = 0;

    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    OsVer.wProductType = VER_NT_DOMAIN_CONTROLLER;

    VER_SET_CONDITION( ConditionMask, VER_PRODUCT_TYPE, VER_GREATER_EQUAL );

    return RtlVerifyVersionInfo( &OsVer,
                                 VER_PRODUCT_TYPE ,
                                 ConditionMask) == STATUS_SUCCESS;
}









//+-------------------------------------------------------------------------
//
//  Function:   KerbSetDomainName
//
//  Synopsis:   Sets all domain-name related global variables
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbSetDomainName(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING DnsDomainName,
    IN PSID DomainSid,
    IN GUID DomainGuid
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN AcquiredLock = FALSE;
    UNICODE_STRING TempDomainName = {0};
    UNICODE_STRING TempDnsDomainName = {0};
    UNICODE_STRING TempMachineServiceName = {0};
    PKERB_INTERNAL_NAME TempMitMachineServiceName = NULL;
    PSID TempDomainSid = NULL;
    UNICODE_STRING TempString;
    WCHAR MachineAccountName[CNLEN + 2];  // for null and '$'
    UNICODE_STRING DnsString = {0};
#ifndef WIN32_CHICAGO
    LUID SystemLogonId = SYSTEM_LUID;
    LUID NetworkServiceLogonId = NETWORKSERVICE_LUID;
    PKERB_LOGON_SESSION SystemLogonSession = NULL;
    PKERB_LOGON_SESSION NetworkServiceLogonSession = NULL;
#endif

    static TimeStamp KerbSetDomainNameTime = {0};
    static ULONG NumOfUpdatedLuids = 0;

    NtQuerySystemTime(&KerbSetDomainNameTime);

    //
    // Copy the domain name / sid
    //

    Status = KerbDuplicateString(
                &TempDomainName,
                DomainName
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbDuplicateString(
                &TempDnsDomainName,
                DnsDomainName
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If we are in an NT domain, uppercase the dns domain name
    //
#ifndef WIN32_CHICAGO
    if (DomainSid != NULL)
#endif
    {
        Status = RtlUpcaseUnicodeString(
                    &TempDnsDomainName,
                    &TempDnsDomainName,
                    FALSE   // don't allocate
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

#ifndef WIN32_CHICAGO

    if (DomainSid != NULL)
    {
        Status = KerbDuplicateSid(
                    &TempDomainSid,
                    DomainSid
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }
#endif

    //
    // Create the new machine names
    //

    KerbGlobalReadLock();

    ASSERT( (KerbGlobalMachineName.Length <= (CNLEN * sizeof(WCHAR)) ) );

    RtlCopyMemory(
        MachineAccountName,
        KerbGlobalMachineName.Buffer,
        KerbGlobalMachineName.Length
        );

    MachineAccountName[KerbGlobalMachineName.Length/sizeof(WCHAR)] = SSI_ACCOUNT_NAME_POSTFIX_CHAR;
    MachineAccountName[1 + KerbGlobalMachineName.Length/sizeof(WCHAR)] = L'\0';

    KerbGlobalReleaseLock();

    RtlInitUnicodeString(
        &TempString,
        MachineAccountName
        );

    Status = KerbDuplicateString(
                &TempMachineServiceName,
                &TempString
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


#ifndef WIN32_CHICAGO

    //
    // Now build the MIT version of our machine service name
    //

    Status = KerbGetDnsHostName(
                &DnsString
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    RtlInitUnicodeString(
        &TempString,
        KERB_HOST_STRING
        );


    if (!KERB_SUCCESS(KerbBuildFullServiceKdcName(
                        &DnsString,
                        &TempString,
                        KRB_NT_SRV_HST,
                        &TempMitMachineServiceName
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Acquire the global lock so we can update the data
    //

    if (!KerbGlobalWriteLock())
    {
        D_DebugLog((DEB_ERROR, "Failed to acquire global resource. Not changing domain. %ws, line %d\n", THIS_FILE, __LINE__));
        goto Cleanup;
    }
    AcquiredLock = TRUE;
#endif // WIN32_CHICAGO

    //
    // Copy all the data to the global structures
    //

    // If we're NT4, we don't have a dns domain name
    // If we're joined to an MIT domain, we don't have a domain GUID and we
    // have a dns domain name

    if ((DomainGuid == GUID_NULL) && (TempDnsDomainName.Length == 0))
    {
        KerbGlobalDomainIsPreNT5 = TRUE;
    }
    else
    {
        KerbGlobalDomainIsPreNT5 = FALSE;
    }

    KerbFreeString(&KerbGlobalDomainName);
    KerbGlobalDomainName = TempDomainName;
    TempDomainName.Buffer = NULL;

    KerbFreeString(&KerbGlobalDnsDomainName);
    KerbGlobalDnsDomainName = TempDnsDomainName;
    TempDnsDomainName.Buffer = NULL;

    KerbFreeString(&KerbGlobalMachineServiceName);
    KerbGlobalMachineServiceName = TempMachineServiceName;
    TempMachineServiceName.Buffer = NULL;


#ifndef WIN32_CHICAGO

    KerbFreeKdcName(&KerbGlobalMitMachineServiceName);
    KerbGlobalMitMachineServiceName = TempMitMachineServiceName;
    TempMitMachineServiceName = NULL;



    if (KerbGlobalDomainSid != NULL)
    {
        KerbFree(KerbGlobalDomainSid);
    }
    KerbGlobalDomainSid = TempDomainSid;
    TempDomainSid = NULL;

    //
    // Update the role on non DCs. The role of a DC never changes.
    // Demotion requires a reboot so that the domain controller role
    // will not change.
    //

    if (KerbGlobalRole != KerbRoleDomainController)
    {

        if (KerbRunningPersonal())
        {
            KerbGlobalRole = KerbRoleRealmlessWksta;
        }
        else if (DomainSid == NULL )
        {
            // No machine account, nor associate w/ MIT realm
            if (DnsDomainName->Length == 0 )
            {
                KerbGlobalRole = KerbRoleRealmlessWksta;
            }
            // Member of MIT realm, but not a domain
            else
            {
                KerbGlobalRole = KerbRoleStandalone;
            }
        }
        else
        {
            KerbGlobalRole = KerbRoleWorkstation;
        }
    }

    KerbGlobalReleaseLock();
    AcquiredLock = FALSE;

    //
    // Update the system/networkservice logon session, if there is one
    //

    SystemLogonSession = KerbReferenceLogonSession(
                            &SystemLogonId,
                            FALSE  // don't unlink
                            );

    if (SystemLogonSession)
    {
        KerbWriteLockLogonSessions(SystemLogonSession);

        D_DebugLog((DEB_TRACE_CRED, 
            "KerbSetDomainName change localsystem domain name from %wZ to %wZ\n",
             &SystemLogonSession->PrimaryCredentials.DomainName,
             DnsDomainName));

        //
        // detect fake updates
        //

        if (!RtlEqualUnicodeString(
                &SystemLogonSession->PrimaryCredentials.DomainName,
                DnsDomainName,
                TRUE
                )) 
        {
            KerbFreeString(&SystemLogonSession->PrimaryCredentials.DomainName);
    
            Status = KerbDuplicateString(
                        &SystemLogonSession->PrimaryCredentials.DomainName ,
                        DnsDomainName
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
    
            KerbPurgeTicketCache(&SystemLogonSession->PrimaryCredentials.ServerTicketCache);
            KerbPurgeTicketCache(&SystemLogonSession->PrimaryCredentials.AuthenticationTicketCache);
            KerbPurgeTicketCache(&SystemLogonSession->PrimaryCredentials.S4UTicketCache);
            SystemLogonSession->LogonSessionFlags |= KERB_LOGON_DEFERRED;
            NumOfUpdatedLuids++;
        }

        KerbUnlockLogonSessions(SystemLogonSession);

    }   

    NetworkServiceLogonSession = KerbReferenceLogonSession(
                                    &NetworkServiceLogonId,
                                    FALSE  // don't unlink
                                    );

    if (NetworkServiceLogonSession != NULL)
    {
        KerbWriteLockLogonSessions(NetworkServiceLogonSession);

        D_DebugLog((DEB_TRACE_CRED, 
            "KerbSetDomainName change networkservice domain name from %wZ to %wZ\n",
             &NetworkServiceLogonSession->PrimaryCredentials.DomainName,
             DnsDomainName));

        //
        // detect fake updates
        //

        if (!RtlEqualUnicodeString(
                &NetworkServiceLogonSession->PrimaryCredentials.DomainName,
                DnsDomainName,
                TRUE
                )) 
        {
            KerbFreeString(&NetworkServiceLogonSession->PrimaryCredentials.DomainName);
            Status = KerbDuplicateString(
                        &NetworkServiceLogonSession->PrimaryCredentials.DomainName ,
                        DnsDomainName
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
    
            KerbPurgeTicketCache(&NetworkServiceLogonSession->PrimaryCredentials.ServerTicketCache);
            KerbPurgeTicketCache(&NetworkServiceLogonSession->PrimaryCredentials.AuthenticationTicketCache);
            KerbPurgeTicketCache(&NetworkServiceLogonSession->PrimaryCredentials.S4UTicketCache);
            NetworkServiceLogonSession->LogonSessionFlags |= KERB_LOGON_DEFERRED;
            NumOfUpdatedLuids++;
        }

        KerbUnlockLogonSessions(NetworkServiceLogonSession);
    }   
    
#endif

Cleanup:

#ifndef WIN32_CHICAGO
    if (AcquiredLock)
    {
        KerbGlobalReleaseLock();
    }
#endif // WIN32_CHICAGO

    KerbFreeString(
        &DnsString
        );
    KerbFreeString(
        &TempDomainName
        );
    KerbFreeString(
        &TempDnsDomainName
        );
    KerbFreeString(
        &TempMachineServiceName
        );

#ifndef WIN32_CHICAGO


    KerbFreeKdcName(
        &TempMitMachineServiceName
        );

    if (TempDomainSid != NULL)
    {
        KerbFree(TempDomainSid);
    }
    if (SystemLogonSession != NULL)
    {
        KerbDereferenceLogonSession(SystemLogonSession);
    }

    if (NetworkServiceLogonSession != NULL)
    {
        KerbDereferenceLogonSession(NetworkServiceLogonSession);
    }

#endif

    return(Status);

}

#ifndef WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   KerbLoadKdc
//
//  Synopsis:   Loads kdcsvc.dll and gets the address of important functions
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS if kdcsvc.dll could be loaded and the
//              necessary entrypoints found.
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbLoadKdc(
    VOID
    )
{
    NTSTATUS Status  = STATUS_SUCCESS;
    KerbKdcHandle = LoadLibraryA("kdcsvc.dll");
    if (KerbKdcHandle == NULL) {
        D_DebugLog((DEB_WARN,"Failed to load kdcsvc.dll: %d\n",GetLastError()));
        return(STATUS_DLL_NOT_FOUND);
    }

    KerbKdcVerifyPac = (PKDC_VERIFY_PAC_ROUTINE) GetProcAddress(
                                                    KerbKdcHandle,
                                                    KDC_VERIFY_PAC_NAME
                                                    );
    if (KerbKdcVerifyPac == NULL)
    {
        D_DebugLog((DEB_WARN, "Failed to get proc address for KdcVerifyPac: %d\n",
            GetLastError()));
        Status = STATUS_PROCEDURE_NOT_FOUND;
        goto Cleanup;
    }

    KerbKdcGetTicket = (PKDC_GET_TICKET_ROUTINE) GetProcAddress(
                                                    KerbKdcHandle,
                                                    KDC_GET_TICKET_NAME
                                                    );
    if (KerbKdcGetTicket == NULL)
    {
        D_DebugLog((DEB_WARN,"Failed to get proc address for KdcGetTicket: %d\n",
            GetLastError()));
        Status = STATUS_PROCEDURE_NOT_FOUND;
        goto Cleanup;
    }

    KerbKdcChangePassword = (PKDC_GET_TICKET_ROUTINE) GetProcAddress(
                                                    KerbKdcHandle,
                                                    KDC_CHANGE_PASSWORD_NAME
                                                    );
    if (KerbKdcChangePassword == NULL)
    {
        D_DebugLog((DEB_WARN,"Failed to get proc address for KdcChangePassword: %d\n",
            GetLastError()));
        Status = STATUS_PROCEDURE_NOT_FOUND;
        goto Cleanup;
    }

    KerbKdcFreeMemory = (PKDC_FREE_MEMORY_ROUTINE) GetProcAddress(
                                                    KerbKdcHandle,
                                                    KDC_FREE_MEMORY_NAME
                                                    );
    if (KerbKdcFreeMemory == NULL)
    {
        D_DebugLog((DEB_WARN,"Failed to get proc address for KdcFreeMemory: %d\n",
            GetLastError()));
        Status = STATUS_PROCEDURE_NOT_FOUND;
        goto Cleanup;
    }


Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (KerbKdcHandle != NULL)
        {
            FreeLibrary(KerbKdcHandle);
            KerbKdcHandle = NULL;
        }
    }
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbDomainChangeCallback
//
//  Synopsis:   Function to be called when domain changes
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID NTAPI
KerbDomainChangeCallback(
    IN POLICY_NOTIFICATION_INFORMATION_CLASS ChangedInfoClass
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAPR_POLICY_INFORMATION Policy = NULL;



    //
    // We only care about domain dns information
    //

    if (ChangedInfoClass != PolicyNotifyDnsDomainInformation)
    {
        return;
    }


    //
    // Get the new domain information
    //


    Status = I_LsaIQueryInformationPolicyTrusted(
                PolicyDnsDomainInformation,
                &Policy
                );

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to query domain dns information %x - not updating. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // update computer name info.
    //

    Status = KerbSetComputerName();

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to set computer name: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    Status = KerbSetDomainName(
                (PUNICODE_STRING) &Policy->PolicyDnsDomainInfo.Name,
                (PUNICODE_STRING) &Policy->PolicyDnsDomainInfo.DnsDomainName,
                (PSID) Policy->PolicyDnsDomainInfo.Sid,
                (GUID) Policy->PolicyDnsDomainInfo.DomainGuid
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to set domain name: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Domain Name has changed. So, the cache in the registry will
    // have changed too. And we haven't rebooted yet.
    //

    KerbSetKdcData(TRUE, FALSE);



Cleanup:

    if (Policy != NULL)
    {
        I_LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyDnsDomainInformation,
            Policy
            );
    }
    return;

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbRegisterForDomainChange
//
//  Synopsis:   Register with the LSA to be notified of domain changes
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbRegisterForDomainChange(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    Status = I_LsaIRegisterPolicyChangeNotificationCallback(
                KerbDomainChangeCallback,
                PolicyNotifyDnsDomainInformation
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to register for domain change notification: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
    }
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbUnregisterForDomainChange
//
//  Synopsis:   Unregister for domain change notification
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbUnregisterForDomainChange(
    VOID
    )
{
    (VOID) I_LsaIUnregisterPolicyChangeNotificationCallback(
                KerbDomainChangeCallback,
                PolicyNotifyDnsDomainInformation
                );

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbUpdateGlobalAddresses
//
//  Synopsis:   Updates the global array of addresses with information from
//              netlogon.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes: Ideally, we should also have called WSAProviderConfigChange to be
//         notified of when tcp is added/removed. But, we can take advantage
//         of the fact that netlogon is registered for changes in ipaddress
//         so, even though, change of ipaddress & xports notifications are
//         async, we will get to know of it, so, it suffices to rely on
//         netlogon rather than register for a notification change.
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbUpdateGlobalAddresses(
    IN PSOCKET_ADDRESS NewAddresses,
    IN ULONG NewAddressCount
    )
{
    PSOCKADDR_IN GlobalIpAddresses = NULL;
    ULONG Index;
    ULONG AddressCount = 0;
    WSAPROTOCOL_INFO *lpProtocolBuf = NULL;
    DWORD dwBufLen = 0;
    INT protocols[2];
    int nRet = 0;
    BOOLEAN NoTcpInstalled = FALSE;

    GlobalIpAddresses = (PSOCKADDR_IN) KerbAllocate(sizeof(SOCKADDR_IN) * NewAddressCount);
    if (GlobalIpAddresses == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    for (Index = 0; Index < NewAddressCount ; Index++ )
    {
        if ((NewAddresses[Index].iSockaddrLength == sizeof(SOCKADDR)) &&
            (NewAddresses[Index].lpSockaddr->sa_family == AF_INET))
        {
            RtlCopyMemory(
                &GlobalIpAddresses[AddressCount++],
                NewAddresses[Index].lpSockaddr,
                sizeof(SOCKADDR_IN)
                );
        }
        else
        {
            D_DebugLog((DEB_ERROR,"Netlogon handed us a address of length or type %d, %d. %ws, line %d\n",
                NewAddresses[Index].iSockaddrLength,
                NewAddresses[Index].lpSockaddr->sa_family,
                THIS_FILE, __LINE__ ));
        }
    }

    //
    // winsock is already initialized by now, or we would not have
    // gotten so far. Check if TCP s an available xport
    //

    protocols[0] = IPPROTO_TCP;
    protocols[1] = NULL;
    nRet = WSAEnumProtocols(protocols, lpProtocolBuf, &dwBufLen);
    if (nRet == 0)
    {
        //
        // Tcp is not installed as a xport.
        //

        D_DebugLog((DEB_TRACE_SOCK,"WSAEnumProtocols returned 0x%x. %ws, line %d\n", nRet, THIS_FILE, __LINE__ ));
        NoTcpInstalled = TRUE;
    }
    //
    // Copy them into the global for others to use
    //

    KerbGlobalWriteLock();
    if (KerbGlobalIpAddresses != NULL)
    {
        KerbFree(KerbGlobalIpAddresses);
    }
    KerbGlobalIpAddresses = GlobalIpAddresses;
    KerbGlobalIpAddressCount = AddressCount;
    KerbGlobalIpAddressesInitialized = TRUE;
    KerbGlobalNoTcpUdp = NoTcpInstalled;
    KerbGlobalReleaseLock();

    return(STATUS_SUCCESS);

}





#ifdef RESTRICTED_TOKEN

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetTokenInformation
//
//  Synopsis:   Allocates and returns token information
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetTokenInformation(
    IN HANDLE TokenHandle,
    IN TOKEN_INFORMATION_CLASS InformationClass,
    IN OUT PVOID * Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BufferSize = 0;

    //
    // First retrieve the restricted sids
    //


    Status = NtQueryInformationToken(
                TokenHandle,
                InformationClass,
                NULL,
                0,
                &BufferSize
                );
    if (Status != STATUS_BUFFER_TOO_SMALL)
    {
        goto Cleanup;
    }

    *Buffer = KerbAllocate(BufferSize);
    if (*Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = NtQueryInformationToken(
                TokenHandle,
                InformationClass,
                *Buffer,
                BufferSize,
                &BufferSize
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
Cleanup:

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCaptureTokenRestrictions
//
//  Synopsis:   Captures the restrictions of a restricted token
//
//  Effects:
//
//  Arguments:  TokenHandle - token handle open for TOKEN_QUERY access
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCaptureTokenRestrictions(
    IN HANDLE TokenHandle,
    OUT PKERB_AUTHORIZATION_DATA Restrictions
    )
{
    PTOKEN_GROUPS Groups = NULL;
    PTOKEN_GROUPS RestrictedSids = NULL;
    PTOKEN_PRIVILEGES Privileges = NULL;
    PTOKEN_PRIVILEGES DeletePrivileges = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG BufferSize = 0;
    ULONG Index,Index2,LastIndex;
    KERB_TOKEN_RESTRICTIONS TokenRestrictions = {0};

    Status = KerbGetTokenInformation(
                    TokenHandle,
                    TokenRestrictedSids,
                    (PVOID *) &RestrictedSids
                    );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = KerbGetTokenInformation(
                    TokenHandle,
                    TokenGroups,
                    (PVOID *) &Groups
                    );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = KerbGetTokenInformation(
                    TokenHandle,
                    TokenPrivileges,
                    (PVOID *) &Privileges
                    );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Now build the list of just the restricted privileges & groups
    //

    //
    // First, find what groups are restricted.
    //

    LastIndex = 0;
    for (Index = 0; Index < Groups->GroupCount ; Index++ )
    {
        if ((Groups->Groups[Index].Attributes & SE_GROUP_USE_FOR_DENY_ONLY) != 0)
        {
            if (LastIndex != Index)
            {
                Groups->Groups[LastIndex].Sid = Groups->Groups[Index].Sid;
                Groups->Groups[LastIndex].Attributes = 0;
            }
            LastIndex++;
        }
    }
    Groups->GroupCount = LastIndex;
    if (LastIndex != 0)
    {
        TokenRestrictions.GroupsToDisable = (PPAC_TOKEN_GROUPS) Groups;
        TokenRestrictions.Flags |= KERB_TOKEN_RESTRICTION_DISABLE_GROUPS;
    }

    //
    // Add the restricted sids
    //

    if (RestrictedSids->GroupCount != 0)
    {
        for (Index = 0; Index < RestrictedSids->GroupCount ; Index++ )
        {
            RestrictedSids->Groups[Index].Attributes = 0;
        }
        TokenRestrictions.RestrictedSids = (PPAC_TOKEN_GROUPS) RestrictedSids;
        TokenRestrictions.Flags |= KERB_TOKEN_RESTRICTION_RESTRICT_SIDS;
    }

    //
    // Now make a list of all the privileges that _aren't_ enabled
    //

    SafeAllocaAllocate(DeletePrivileges,
                       sizeof(TOKEN_PRIVILEGES) +
                           sizeof(LUID_AND_ATTRIBUTES) *
                               (1 + SE_MAX_WELL_KNOWN_PRIVILEGE - SE_MIN_WELL_KNOWN_PRIVILEGE));

    if (DeletePrivileges == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    DeletePrivileges->PrivilegeCount = 0;

    //
    // Find out what privileges haven't been enabled
    //

    LastIndex = 0;
    for (Index = SE_MIN_WELL_KNOWN_PRIVILEGE; Index <= SE_MAX_WELL_KNOWN_PRIVILEGE ; Index++ )
    {
        LUID TempLuid;
        BOOLEAN Found = FALSE;
        TempLuid = RtlConvertUlongToLuid(Index);
        for (Index2 = 0; Index2 < Privileges->PrivilegeCount ; Index2++ )
        {
            if (RtlEqualLuid(&Privileges->Privileges[Index2].Luid,&TempLuid) &&
                ((Privileges->Privileges[Index2].Attributes & SE_PRIVILEGE_ENABLED) != 0))
            {
                Found = TRUE;
                break;
            }
        }
        if (!Found)
        {
            DeletePrivileges->Privileges[LastIndex].Luid = TempLuid;
            DeletePrivileges->Privileges[LastIndex].Attributes = 0;
            LastIndex++;
        }
    }
    DeletePrivileges->PrivilegeCount = LastIndex;
    if (LastIndex != 0)
    {
        TokenRestrictions.PrivilegesToDelete = (PPAC_TOKEN_PRIVILEGES) DeletePrivileges;
        TokenRestrictions.Flags |= KERB_TOKEN_RESTRICTION_DELETE_PRIVS;
    }

    Restrictions->value.auth_data_type = KERB_AUTH_DATA_TOKEN_RESTRICTIONS;
    Status = PAC_EncodeTokenRestrictions(
                &TokenRestrictions,
                &Restrictions->value.auth_data.value,
                &Restrictions->value.auth_data.length
                );

Cleanup:

    if (Groups != NULL)
    {
        KerbFree(Groups);
    }

    if (RestrictedSids != NULL)
    {
        KerbFree(RestrictedSids);
    }

    if (Privileges != NULL)
    {
        KerbFree(Privileges);
    }

    SafeAllocaFree(DeletePrivileges);

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAddRestrictionsToCredential
//
//  Synopsis:   Captures client'st token restrictions and sticks them in
//              the credential
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbAddRestrictionsToCredential(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_AUTHORIZATION_DATA AuthData = NULL;
    BOOLEAN CrossRealm;
    PKERB_TICKET_CACHE_ENTRY ExistingTgt = NULL;
    HANDLE ClientToken = NULL;
    PKERB_INTERNAL_NAME ServiceName = NULL;
    UNICODE_STRING ServiceRealm = NULL_UNICODE_STRING;
    PKERB_KDC_REPLY KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY KdcReplyBody = NULL;
    BOOLEAN TicketCacheLocked = FALSE;
    PKERB_TICKET_CACHE_ENTRY NewTicket = NULL;
    ULONG CacheFlags = 0;
    BOOLEAN UseSuppliedCreds = FALSE;

    //
    // Capture the existing TGT
    //

    Status = LsaFunctions->ImpersonateClient();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = NtOpenThreadToken(
                NtCurrentThread(),
                TOKEN_QUERY,
                TRUE,                   // open as self
                &ClientToken
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    RevertToSelf();

    //
    // Capture the restrictions for this token
    //

    AuthData = (PKERB_AUTHORIZATION_DATA) MIDL_user_allocate(sizeof(KERB_AUTHORIZATION_DATA));
    if (AuthData == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    Status = KerbCaptureTokenRestrictions(
                ClientToken,
                AuthData
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to capture token restrictions: 0x%x\n",Status));
        goto Cleanup;
    }

    KerbWriteLockLogonSessions(LogonSession);
    Credential->AuthData = AuthData;

    //
    // Turn off tgt avail to force us to get a new tgt
    //

    Credential->CredentialFlags &= ~KERB_CRED_TGT_AVAIL;
    AuthData = NULL;
    KerbUnlockLogonSessions(LogonSession);

Cleanup:
    if (AuthData != NULL)
    {
        if (AuthData->value.auth_data.value != NULL)
        {
            MIDL_user_free(AuthData->value.auth_data.value);
        }
        MIDL_user_free(AuthData);
    }
    if (ClientToken != NULL)
    {
        NtClose(ClientToken);
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildTokenRestrictionAuthData
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:  Not called yet - used for restricted tickets
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildEncryptedAuthData(
    OUT PKERB_ENCRYPTED_DATA EncryptedAuthData,
    IN PKERB_TICKET_CACHE_ENTRY Ticket,
    IN PKERB_AUTHORIZATION_DATA PlainAuthData
    )
{
    KERBERR KerbErr;
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_MESSAGE_BUFFER PackedAuthData = {0};


    KerbErr = KerbPackData(
                &PlainAuthData,
                PKERB_AUTHORIZATION_DATA_LIST_PDU,
                &PackedAuthData.BufferSize,
                &PackedAuthData.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    KerbReadLockTicketCache();

    KerbErr = KerbAllocateEncryptionBufferWrapper(
                Ticket->SessionKey.keytype,
                PackedAuthData.BufferSize,
                &EncryptedAuthData->cipher_text.length,
                &EncryptedAuthData->cipher_text.value
                );
    if (KERB_SUCCESS(KerbErr))
    {
        KerbErr = KerbEncryptDataEx(
                    EncryptedAuthData,
                    PackedAuthData.BufferSize,
                    PackedAuthData.Buffer,
                    KERB_NO_KEY_VERSION,
                    KERB_TGS_REQ_SESSKEY_SALT,    // was KERB_NON_KERB_SALT need to check for KERB_TGS_REQ_SUBKEY_SALT also
                    &Ticket->SessionKey
                    );
    }
    KerbUnlockTicketCache();
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

Cleanup:
    if (PackedAuthData.Buffer != NULL)
    {
        MIDL_user_free(PackedAuthData.Buffer);
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetRestrictedTgtForCredential
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetRestrictedTgtForCredential(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_AUTHORIZATION_DATA AuthData = NULL;
    BOOLEAN CrossRealm;
    PKERB_TICKET_CACHE_ENTRY ExistingTgt = NULL;
    PKERB_INTERNAL_NAME ServiceName = NULL;
    UNICODE_STRING ServiceRealm = NULL_UNICODE_STRING;
    PKERB_KDC_REPLY KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY KdcReplyBody = NULL;
    BOOLEAN TicketCacheLocked = FALSE;
    PKERB_TICKET_CACHE_ENTRY NewTicket = NULL;
    ULONG CacheFlags = 0, RetryFlags = 0;
    BOOLEAN UseSuppliedCreds = FALSE;

    //
    // First get an old TGT
    //

    KerbReadLockLogonSessions(LogonSession);

    if (Credential->SuppliedCredentials == NULL)
    {
        ULONG Flags;

        //
        // We don't have supplied creds, but we need them, so copy
        // from the logon session.
        //

        Status = KerbCaptureSuppliedCreds(
                    LogonSession,
                    NULL,                       // no auth data
                    NULL,                       // no principal name
                    &Credential->SuppliedCredentials,
                    &Flags
                    );

        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to capture dummy supplied creds: 0x%x\n",Status));
            KerbUnlockLogonSessions(LogonSession);
            goto Cleanup;
        }
        AuthData = Credential->AuthData;
    }
    else
    {
        UseSuppliedCreds = FALSE;
    }

    DsysAssert(Credential->SuppliedCredentials != NULL);

    Status = KerbGetTgtForService(
                LogonSession,
                (UseSuppliedCreds) ? Credential : NULL,
                NULL,
                NULL, // no SuppRealm
                &Credential->SuppliedCredentials->DomainName,
                &ExistingTgt,
                &CrossRealm
                );
    KerbUnlockLogonSessions(LogonSession);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Now get a new TGT with this ticket
    //

    //
    // Copy the names out of the input structures so we can
    // unlock the structures while going over the network.
    //

    DsysAssert( !TicketCacheLocked );
    KerbReadLockTicketCache();
    TicketCacheLocked = TRUE;

    //
    // If the renew time is not much bigger than the end time, don't bother
    // renewing
    //


    Status = KerbDuplicateString(
                &ServiceRealm,
                &ExistingTgt->DomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Status = KerbDuplicateKdcName(
                &ServiceName,
                ExistingTgt->ServiceName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    CacheFlags = ExistingTgt->CacheFlags;

    DsysAssert( TicketCacheLocked );
    KerbUnlockTicketCache();
    TicketCacheLocked = FALSE;

    Status = KerbGetTgsTicket(
                &ServiceRealm,
                ExistingTgt,
                ServiceName,
                FALSE,
                0,                              // no ticket optiosn
                0,                              // no encryption type
                AuthData,                       // no authorization data
                NULL,                           // no tgt reply
                NULL,
                NULL,
                &KdcReply,
                &KdcReplyBody,
                &RetryFlags
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to get restricted tgs ticket: 0x%x\n",Status));
        goto Cleanup;
    }

    //
    // Now we want to purge the existing ticket cache and add this ticket
    //

    KerbPurgeTicketCache(
        &Credential->SuppliedCredentials->AuthenticationTicketCache
        );
    KerbPurgeTicketCache(
        &Credential->SuppliedCredentials->ServerTicketCache
        );

    KerbReadLockLogonSessions(LogonSession);

    Status = KerbCreateTicketCacheEntry(
                KdcReply,
                KdcReplyBody,
                ServiceName,
                &ServiceRealm,
                CacheFlags,
                &Credential->SuppliedCredentials->AuthenticationTicketCache,
                NULL,                               // no credential key
                &NewTicket
                );

    KerbUnlockLogonSessions(LogonSession);

Cleanup:
    if (TicketCacheLocked)
    {
        KerbUnlockTicketCache();
    }
    if (ExistingTgt != NULL)
    {
        KerbDereferenceTicketCacheEntry(ExistingTgt);
    }
    if (NewTicket != NULL)
    {
        KerbDereferenceTicketCacheEntry(NewTicket);
    }
    KerbFreeTgsReply(KdcReply);
    KerbFreeKdcReplyBody(KdcReplyBody);
    KerbFreeKdcName(&ServiceName);
    KerbFreeString(&ServiceRealm);
    return(Status);
}
#endif
#endif // WIN32_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\krbaudit.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2001
//
// File:        krbaudit.cxx
//
// Contents:    Auditing routines
//
//
// History:     27-April-2001   Created         kumarp
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>
#include <krbaudit.h>


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetLogonGuid
//
//  Synopsis:   Gets a unique ID based on certain fields in the ticket
//
//  Arguments:  pPrimaryCredentials -- primary credentials
//              pKdcReplyBody       -- kdc reply structure
//              pLogonGuid          -- returned GUID
//
//  Returns:    NTSTATUS code
//
//  Notes:      The generated GUID is MD5 hash of 3 fields:
//                -- client name
//                -- client realm
//                -- ticket start time
//                
//              All of these fields are available at client/kdc/server machine.
//              this allows us to generate the same unique ID on these machines
//              without having to introduce a new field in the ticket.
//              This GUID is used in audit events allowing us to correlate
//              events on three different machines.
//
//--------------------------------------------------------------------------
NTSTATUS
KerbGetLogonGuid(
    IN  PKERB_PRIMARY_CREDENTIAL  pPrimaryCredentials,
    IN  PKERB_ENCRYPTED_KDC_REPLY pKdcReplyBody,
    OUT LPGUID pLogonGuid
    )
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    // ISSUE-2001/04/28-kumarp : use KERB_ENCRYPTED_KDC_REPLY_starttime_present
    //if ( KdcReplyBody->flags & KERB_ENCRYPTED_KDC_REPLY_starttime_present )
    if ( pKdcReplyBody && pPrimaryCredentials )
    {

        Status = LsaIGetLogonGuid(
                     &pPrimaryCredentials->UserName,
                     &pPrimaryCredentials->DomainName,
                     (PBYTE) &pKdcReplyBody->starttime,
                     sizeof(KERB_TIME),
                     pLogonGuid
                     );

        if (!NT_SUCCESS(Status))
        {
            RtlZeroMemory( pLogonGuid, sizeof(GUID) );
        }
    }
    
    return Status;
}
    


//+-------------------------------------------------------------------------
//
//  Function:   KerbGenerateAuditForLogonUsingExplicitCreds
//
//  Synopsis:   Generate an audit event to indicate that somebody logged on
//              by supplying explicit credentials.
//
//  Arguments:  pCurrentUserLogonSession   -- logon session of the user
//                                            who supplied credentials of
//                                            another user
//              pNewUserPrimaryCredentials -- supplied primary credentials
//              pNewUserLogonGuid          -- logon GUID for the new logon
//              pTargetName                -- name of the target server
//
//  Returns:    NTSTATUS code
//
//  Notes:      This event covers credentials obtained from credman
//
//--------------------------------------------------------------------------
NTSTATUS
KerbGenerateAuditForLogonUsingExplicitCreds(
    IN PKERB_LOGON_SESSION pCurrentUserLogonSession,
    IN PKERB_PRIMARY_CREDENTIAL pNewUserPrimaryCredentials,
    IN LPGUID pNewUserLogonGuid,
    IN PKERB_INTERNAL_NAME pTargetName
      )
{
    NTSTATUS Status = STATUS_SUCCESS;
    GUID CurrentUserLogonGuid;
    LPGUID pCurrentUserLogonGuid = NULL;
    PKERB_TICKET_CACHE_ENTRY pTicketCacheEntry = NULL;
    UNICODE_STRING OurDomainName = { 0 };
    KERB_TIME CurrentUserStartTime = { 0 };
    KERBERR KerbErr = KDC_ERR_NONE;
    PUNICODE_STRING pTargetServerName = NULL;
    PUNICODE_STRING pTargetFullName = NULL;
    UNICODE_STRING  TargetFullName =  { 0 };
    
    //
    // calculate LogonGuid for current logged on user
    // we need the following 3 parameters for this:
    //   -- client name
    //   -- client realm
    //   -- ticket start time
    //
    if ( !(pCurrentUserLogonSession->LogonSessionFlags &
           (KERB_LOGON_LOCAL_ONLY | KERB_LOGON_DEFERRED)) )
    {
        Status = KerbGetOurDomainName( &OurDomainName );

        ASSERT( NT_SUCCESS(Status) && L"KerbGenerateAuditForLogonUsingExplicitCreds: KerbGetOurDomainName failed" );
        
        if (NT_SUCCESS(Status))
        {
            //
            // find the cached ticket for the local machine from
            // the ticket cache of the current logon session.
            //
            pTicketCacheEntry =
                KerbLocateTicketCacheEntry(
                    &pCurrentUserLogonSession->PrimaryCredentials.ServerTicketCache,
                    KerbGlobalMitMachineServiceName,
                    &OurDomainName
                    );

            if ( pTicketCacheEntry )
            {
                //
                // Convert start time to the format we want.
                //
                KerbConvertLargeIntToGeneralizedTime(
                    &CurrentUserStartTime,
                    NULL,
                    &pTicketCacheEntry->StartTime
                    );

                //
                // Generate the logon GUID
                //
                Status = LsaIGetLogonGuid(
                             &pCurrentUserLogonSession->PrimaryCredentials.UserName,
                             &pCurrentUserLogonSession->PrimaryCredentials.DomainName,
                             (PBYTE) &CurrentUserStartTime,
                             sizeof(KERB_TIME),
                             &CurrentUserLogonGuid
                             );
                if (NT_SUCCESS(Status))
                {
                    pCurrentUserLogonGuid = &CurrentUserLogonGuid;
                }
            }
            else
            {
                D_DebugLog((DEB_TRACE, "KerbGenerateAuditForLogonUsingExplicitCreds: could not locate ticket"));
            }                                                                                                   
        }

        //
        // ISSUE-2002/03/28-kumarp : this should be inside the if stmt
        //
        KerbFreeString(&OurDomainName);

    }
#if DBG
    else
    {
        //
        // KERB_LOGON_LOCAL_ONLY indicates a logon using non Kerberos package.
        // Logon GUID is supported only by Kerberos therefore its generation
        // is skipped.
        //
        if (pCurrentUserLogonSession->LogonSessionFlags & KERB_LOGON_LOCAL_ONLY)
        {
            D_DebugLog((DEB_TRACE,"KerbGenerateAuditForLogonUsingExplicitCreds: LogonSession %p has KERB_LOGON_LOCAL_ONLY\n", pCurrentUserLogonSession));
        }

        //
        // KERB_LOGON_DEFERRED indicates that a logon occurred using
        // cached credentials because kdc was not available.  In this case,
        // we will not have a ticket for local machine therefore generation of
        // the logon GUID is skipped.
        //
        if (pCurrentUserLogonSession->LogonSessionFlags & KERB_LOGON_DEFERRED)
        {
            D_DebugLog((DEB_TRACE,"KerbGenerateAuditForLogonUsingExplicitCreds: LogonSession %p has KERB_LOGON_DEFERRED\n", pCurrentUserLogonSession));
        }
    }
#endif

    //
    // convert pTargetName which is in kdc format to a UNICODE_STRING
    //

    KerbErr = KerbConvertKdcNameToString(
                  &TargetFullName,
                  pTargetName,
                  NULL
                  );

    if ( KerbErr == KDC_ERR_NONE )
    {
        pTargetFullName = &TargetFullName;
    }
    else
    {
        pTargetFullName = NULL;
    }

    //
    // extract the target computer name for known cases
    //

    if ( pTargetName->NameCount == 1 )
    {
        pTargetServerName = &pTargetName->Names[0];
    }
    else if ( pTargetName->NameCount >= 2 )
    {
        pTargetServerName = &pTargetName->Names[1];
    }
    else
    {
        pTargetServerName = NULL;
    }
    
    //
    // now generate the audit
    //
    Status = I_LsaIAuditLogonUsingExplicitCreds(
                 EVENTLOG_AUDIT_SUCCESS,
                 &pCurrentUserLogonSession->LogonId,
                 pCurrentUserLogonGuid,
                 (HANDLE) (ULONG_PTR) GetCurrentProcessId(),
                 &pNewUserPrimaryCredentials->UserName,
                 &pNewUserPrimaryCredentials->DomainName,
                 pNewUserLogonGuid,
                 pTargetServerName,
                 pTargetFullName
                 );

    
    if ( TargetFullName.Buffer != NULL )
    {
        MIDL_user_free( TargetFullName.Buffer );
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbAuditLogon
//
//  Synopsis:   Generate a successful logon audit event
//
//  Arguments:  LogonStatus         -- overall logon status
//              LogonSubStatus      -- sub-category within a failed logon status
//              pEncryptedTicket    -- ticket used
//              pUserSid            -- user's SID
//              pWorkstationName    -- logon workstation
//              pLogonId            -- logon LUID
//              pTransittedServices -- list of transitted services
//
//  Returns:    NTSTATUS code
//
//  Notes:      A new field (logon GUID) was added to this audit event.
//              In order to send this new field to LSA, we had two options:
//              1) add new function (AuditLogonEx) to LSA dispatch table
//              2) define a private (LsaI) function to do the job
//
//             option#2 was chosen because the logon GUID is a Kerberos only
//             feature.
//
//--------------------------------------------------------------------------
NTSTATUS
KerbAuditLogon(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PKERB_CONTEXT Context,
    IN PUNICODE_STRING pWorkstationName,
    IN PLUID pLogonId,
    IN PLSA_ADT_STRING_LIST pTransittedServices
    )
{
    GUID LogonGuid = { 0 };
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_TIME StartTime;

    //
    // Pull this eventually. I think we're OK, though.
    //
    if (Context == NULL)
    {
        DsysAssert(FALSE);
        goto Cleanup;
    }


    KerbConvertLargeIntToGeneralizedTime(
        &StartTime,
        NULL,
        &Context->StartTime
        );

    //
    // generate the logon GUID
    //
    Status = I_LsaIGetLogonGuid(
                 &Context->ClientName,
                 &Context->ClientRealm,
                 (PBYTE) &StartTime,
                 sizeof(KERB_TIME),
                 &LogonGuid
                 );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // generate successful logon audit. use the special 
    // LsaIAuditKerberosLogon function so that we can pass in
    // the generated unique logon guid
    //
    I_LsaIAuditKerberosLogon(
        LogonStatus,
        LogonSubStatus,
        &Context->ClientName,
        &Context->ClientRealm,
        pWorkstationName,
        Context->UserSid,
        Network,
        &KerberosSource,
        pLogonId,
        &LogonGuid,
        pTransittedServices
        );

Cleanup:
    if ( !NT_SUCCESS( Status ) )
    {
        D_DebugLog((DEB_ERROR,"KerbAuditLogon: failed: %x\n", Status ));
    }


    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\kerbwow.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 2000
//
// File:        kerbwow.h
//
// Contents:    prototypes for 32-64 bit interop for the Kerberos package
//
//
// History:     25-Oct-2000     JSchwart        Created
//
//------------------------------------------------------------------------

#ifndef __KERBWOW_H__
#define __KERBWOW_H__

#ifdef _WIN64

//
// WOW versions of native structures
//

typedef UNICODE_STRING32     UNICODE_STRING_WOW64;
typedef UNICODE_STRING_WOW64 *PUNICODE_STRING_WOW64;

typedef struct _SECHANDLE_WOW64
{
    ULONG dwLower;
    ULONG dwUpper;
}
SECHANDLE_WOW64, *PSECHANDLE_WOW64;


typedef struct _KERB_TICKET_CACHE_INFO_WOW64
{
    UNICODE_STRING_WOW64 ServerName;
    UNICODE_STRING_WOW64 RealmName;
    LARGE_INTEGER        StartTime;
    LARGE_INTEGER        EndTime;
    LARGE_INTEGER        RenewTime;
    LONG                 EncryptionType;
    ULONG                TicketFlags;
}
KERB_TICKET_CACHE_INFO_WOW64, *PKERB_TICKET_CACHE_INFO_WOW64;


typedef struct _KERB_TICKET_CACHE_INFO_EX_WOW64
{
    UNICODE_STRING_WOW64 ClientName;
    UNICODE_STRING_WOW64 ClientRealm;
    UNICODE_STRING_WOW64 ServerName;
    UNICODE_STRING_WOW64 ServerRealm;
    LARGE_INTEGER        StartTime;
    LARGE_INTEGER        EndTime;
    LARGE_INTEGER        RenewTime;
    LONG                 EncryptionType;
    ULONG                TicketFlags;
}
KERB_TICKET_CACHE_INFO_EX_WOW64, *PKERB_TICKET_CACHE_INFO_EX_WOW64;

typedef struct _KERB_CHANGE_MACH_PWD_REQUEST_WOW64
{
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    UNICODE_STRING_WOW64       NewPassword;
    UNICODE_STRING_WOW64       OldPassword;
}
KERB_CHANGE_MACH_PWD_REQUEST_WOW64, *PKERB_CHANGE_MACH_PWD_REQUEST_WOW64;


typedef struct _KERB_CHANGEPASSWORD_REQUEST_WOW64
{
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    UNICODE_STRING_WOW64       DomainName;
    UNICODE_STRING_WOW64       AccountName;
    UNICODE_STRING_WOW64       OldPassword;
    UNICODE_STRING_WOW64       NewPassword;
    BOOLEAN                    Impersonating;
}
KERB_CHANGEPASSWORD_REQUEST_WOW64, *PKERB_CHANGEPASSWORD_REQUEST_WOW64;


typedef struct _KERB_PURGE_TKT_CACHE_REQUEST_WOW64
{
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    LUID                       LogonId;
    UNICODE_STRING_WOW64       ServerName;
    UNICODE_STRING_WOW64       RealmName;
}
KERB_PURGE_TKT_CACHE_REQUEST_WOW64, *PKERB_PURGE_TKT_CACHE_REQUEST_WOW64;


typedef struct _KERB_PURGE_TKT_CACHE_EX_REQUEST_WOW64
{
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    LUID LogonId;
    ULONG Flags;
    KERB_TICKET_CACHE_INFO_EX_WOW64 TicketTemplate;
}
KERB_PURGE_TKT_CACHE_EX_REQUEST_WOW64, *PKERB_PURGE_TKT_CACHE_EX_REQUEST_WOW64;


typedef struct _KERB_QUERY_TKT_CACHE_RESPONSE_WOW64
{
    KERB_PROTOCOL_MESSAGE_TYPE   MessageType;
    ULONG                        CountOfTickets;
    KERB_TICKET_CACHE_INFO_WOW64 Tickets[ANYSIZE_ARRAY];
}
KERB_QUERY_TKT_CACHE_RESPONSE_WOW64, *PKERB_QUERY_TKT_CACHE_RESPONSE_WOW64;


typedef struct _KERB_QUERY_TKT_CACHE_EX_RESPONSE_WOW64
{
    KERB_PROTOCOL_MESSAGE_TYPE      MessageType;
    ULONG                           CountOfTickets;
    KERB_TICKET_CACHE_INFO_EX_WOW64 Tickets[ANYSIZE_ARRAY];
}
KERB_QUERY_TKT_CACHE_EX_RESPONSE_WOW64, *PKERB_QUERY_TKT_CACHE_EX_RESPONSE_WOW64;


typedef struct _KERB_SETPASSWORD_REQUEST_WOW64
{
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    LUID                       LogonId;
    SECHANDLE_WOW64            CredentialsHandle;
    ULONG                      Flags;
    UNICODE_STRING_WOW64       DomainName;
    UNICODE_STRING_WOW64       AccountName;
    UNICODE_STRING_WOW64       Password;
}
KERB_SETPASSWORD_REQUEST_WOW64, *PKERB_SETPASSWORD_REQUEST_WOW64;


typedef struct _KERB_SETPASSWORD_EX_REQUEST_WOW64
{
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    LUID                       LogonId;
    SECHANDLE_WOW64            Unused;
    ULONG                      Flags;
    UNICODE_STRING_WOW64       AccountRealm;
    UNICODE_STRING_WOW64       AccountName;
    UNICODE_STRING_WOW64       Password;
    UNICODE_STRING_WOW64       OldPassword;
    UNICODE_STRING_WOW64       ClientRealm;
    UNICODE_STRING_WOW64       ClientName;
    BOOLEAN                    Impersonating;
    UNICODE_STRING_WOW64       KdcAddress;
    ULONG                      KdcAddressType;
}
KERB_SETPASSWORD_EX_REQUEST_WOW64, *PKERB_SETPASSWORD_EX_REQUEST_WOW64;


typedef struct _KERB_ADD_BINDING_CACHE_ENTRY_REQUEST_WOW64
{
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;
    UNICODE_STRING_WOW64 RealmName;
    UNICODE_STRING_WOW64 KdcAddress;
    ULONG AddressType;                  //dsgetdc.h DS_NETBIOS_ADDRESS||DS_INET_ADDRESS
}
KERB_ADD_BINDING_CACHE_ENTRY_REQUEST_WOW64, *PKERB_ADD_BINDING_CACHE_ENTRY_REQUEST_WOW64;


typedef struct _SecPkgContext_NativeNamesW_WOW64
{
    ULONG sClientName;
    ULONG sServerName;
}
SecPkgContext_NativeNamesW_WOW64, *PSecPkgContext_NativeNamesW_WOW64;


//
// WOW helper macros
//

#define UNICODE_STRING_FROM_WOW_STRING(pUnicodeString, pWOWString)                       \
            (pUnicodeString)->Length        = (pWOWString)->Length;                      \
            (pUnicodeString)->MaximumLength = (pWOWString)->MaximumLength;               \
            (pUnicodeString)->Buffer        = (LPWSTR) UlongToPtr((pWOWString)->Buffer);


//
// WOW helper functions
//

NTSTATUS
KerbConvertWOWLogonBuffer(
    IN     PVOID                   ProtocolSubmitBuffer,
    IN     PVOID                   ClientBufferBase,
    IN OUT PULONG                  pSubmitBufferSize,
    IN     KERB_LOGON_SUBMIT_TYPE  MessageType,
    OUT    PVOID                   *ppTempSubmitBuffer
    );

NTSTATUS
KerbAllocateInteractiveWOWBuffer(
    OUT PKERB_INTERACTIVE_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO3 UserInfo,
    IN  PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_ENCRYPTED_TICKET LogonTicket,
    IN OPTIONAL PKERB_INTERACTIVE_LOGON KerbLogonInfo,
    IN  PUCHAR *PClientBufferBase,
    IN  BOOLEAN BuildSmartCardProfile,
    IN  BOOLEAN BuildTicketProfile
    );

NTSTATUS
KerbPackExternalWOWTicket(
    PKERB_TICKET_CACHE_ENTRY  pCacheEntry,
    PKERB_MESSAGE_BUFFER      pEncodedTicket,
    PKERB_EXTERNAL_TICKET     *pTicketResponse,
    PBYTE                     *pClientTicketResponse,
    PULONG                    pTicketSize
    );

VOID
KerbPutWOWString(
    IN PUNICODE_STRING        InputString,
    OUT PUNICODE_STRING_WOW64 OutputString,
    IN LONG_PTR               Offset,
    IN OUT PBYTE              * Where
    );

VOID
KerbPutKdcNameAsWOWString(
    IN PKERB_INTERNAL_NAME    InputName,
    OUT PUNICODE_STRING_WOW64 OutputName,
    IN LONG_PTR               Offset,
    IN OUT PBYTE              * Where
    );


#endif  // _WIN64
#endif  // __KERBWOW_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\kerbutil.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbutil.h
//
// Contents:    prototypes for Kerberos utility functions
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __KERBUTIL_H__
#define __KERBUTIL_H__


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Miscellaneous macros                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// RELOCATE_ONE - Relocate a single pointer in a client buffer.
//
// Note: this macro is dependent on parameter names as indicated in the
//       description below.  On error, this macro goes to 'Cleanup' with
//       'Status' set to the NT Status code.
//
// The MaximumLength is forced to be Length.
//
// Define a macro to relocate a pointer in the buffer the client passed in
// to be relative to 'ProtocolSubmitBuffer' rather than being relative to
// 'ClientBufferBase'.  The result is checked to ensure the pointer and
// the data pointed to is within the first 'SubmitBufferSize' of the
// 'ProtocolSubmitBuffer'.
//
// The relocated field must be aligned to a WCHAR boundary.
//
//  _q - Address of UNICODE_STRING structure which points to data to be
//       relocated
//

#define RELOCATE_ONE( _q ) \
    {                                                                       \
        ULONG_PTR Offset;                                                   \
                                                                            \
        Offset = (((PUCHAR)((_q)->Buffer)) - ((PUCHAR)ClientBufferBase));   \
        if ( Offset >= SubmitBufferSize ||                                  \
             Offset + (_q)->Length > SubmitBufferSize ||                    \
             !COUNT_IS_ALIGNED( Offset, ALIGN_WCHAR) ) {                    \
                                                                            \
            Status = STATUS_INVALID_PARAMETER;                              \
            goto Cleanup;                                                   \
        }                                                                   \
                                                                            \
        (_q)->Buffer = (PWSTR)(((PUCHAR)ProtocolSubmitBuffer) + Offset);    \
        (_q)->MaximumLength = (_q)->Length ;                                \
    }

//
// NULL_RELOCATE_ONE - Relocate a single (possibly NULL) pointer in a client
//  buffer.
//
// This macro special cases a NULL pointer then calls RELOCATE_ONE.  Hence
// it has all the restrictions of RELOCATE_ONE.
//
//
//  _q - Address of UNICODE_STRING structure which points to data to be
//       relocated
//

#define NULL_RELOCATE_ONE( _q ) \
    {                                                                       \
        if ( (_q)->Buffer == NULL ) {                                       \
            if ( (_q)->Length != 0 ) {                                      \
                Status = STATUS_INVALID_PARAMETER;                          \
                goto Cleanup;                                               \
            }                                                               \
        } else if ( (_q)->Length == 0 ) {                                   \
            (_q)->Buffer = NULL;                                            \
        } else {                                                            \
            RELOCATE_ONE( _q );                                             \
        }                                                                   \
    }


//
// RELOCATE_ONE_ENCODED - Relocate a unicode string pointer in a client
//   buffer.  The upper byte of the length field may be an encryption seed
//   and should not be used for error checking.
//
// Note: this macro is dependent on parameter names as indicated in the
//       description below.  On error, this macro goes to 'Cleanup' with
//       'Status' set to the NT Status code.
//
// The MaximumLength is forced to be Length & 0x00ff.
//
// Define a macro to relocate a pointer in the buffer the client passed in
// to be relative to 'ProtocolSubmitBuffer' rather than being relative to
// 'ClientBufferBase'.  The result is checked to ensure the pointer and
// the data pointed to is within the first 'SubmitBufferSize' of the
// 'ProtocolSubmitBuffer'.
//
// The relocated field must be aligned to a WCHAR boundary.
//
//  _q - Address of UNICODE_STRING structure which points to data to be
//       relocated
//

#define RELOCATE_ONE_ENCODED( _q ) \
    {                                                                       \
        ULONG_PTR Offset;                                                   \
                                                                            \
        Offset = ((PUCHAR)((_q)->Buffer)) - ((PUCHAR)ClientBufferBase);     \
        if ( Offset > SubmitBufferSize ||                                  \
             Offset + ((_q)->Length & 0x00ff) > SubmitBufferSize ||         \
             !COUNT_IS_ALIGNED( Offset, ALIGN_WCHAR) ) {                    \
                                                                            \
            Status = STATUS_INVALID_PARAMETER;                              \
            goto Cleanup;                                                   \
        }                                                                   \
                                                                            \
        (_q)->Buffer = (PWSTR)(((PUCHAR)ProtocolSubmitBuffer) + Offset);    \
        (_q)->MaximumLength = (_q)->Length & 0x00ff;                                \
    }


//
//  Following macro is used to initialize UNICODE strings
//

#define CONSTANT_UNICODE_STRING(s)   { sizeof( s ) - sizeof( WCHAR ), sizeof( s ), s }
#define NULL_UNICODE_STRING {0 , 0, NULL }
#define EMPTY_UNICODE_STRING(s) { (s)->Buffer = NULL; (s)->Length = 0; (s)->MaximumLength = 0; }



///VOID
// KerbSetTime(
//     IN OUT PTimeStamp TimeStamp,
//     IN LONGLONG Time
//     )


#ifndef WIN32_CHICAGO
#define KerbSetTime(_d_, _s_) (_d_)->QuadPart = (_s_)
#else  // WIN32_CHICAGO
#define KerbSetTime(_d_, _s_) *(_d_) = (_s_)
#endif // WIN32_CHICAGO



// TimeStamp
// KerbGetTime(
//     IN TimeStamp Time
//     )

#ifndef WIN32_CHICAGO
#define KerbGetTime(_x_) ((_x_).QuadPart)
#else  // WIN32_CHICAGO
#define KerbGetTime(_x_) (_x_)
#endif // WIN32_CHICAGO





// VOID
// KerbSetTimeInMinutes(
//    IN OUT PTimeStamp Time,
//    IN LONG TimeInMinutes
//    )

#ifndef WIN32_CHICAGO
#define KerbSetTimeInMinutes(_x_, _m_) (_x_)->QuadPart = (LONGLONG) 10000000 * 60 * (_m_)
#else  // WIN32_CHICAGO
#define KerbSetTimeInMinutes(_x_, _m_) *(_x_) = (LONGLONG) 10000000 * 60 * (_m_)
#endif // WIN32_CHICAGO





NTSTATUS
KerbSplitFullServiceName(
    IN PUNICODE_STRING FullServiceName,
    OUT PUNICODE_STRING DomainName,
    OUT PUNICODE_STRING ServiceName
    );

ULONG
KerbAllocateNonce(
    VOID
    );

#ifndef WIN32_CHICAGO
PSID
KerbMakeDomainRelativeSid(
    IN PSID DomainId,
    IN ULONG RelativeId
    );
#endif // WIN32_CHICAGO

#ifdef notdef
VOID
KerbFree(
    IN PVOID Buffer
    );
#endif

PVOID
KerbAllocate(
    IN SIZE_T BufferSize
    );

BOOLEAN
KerbRunningPersonal(
    VOID
    );

#ifndef WIN32_CHICAGO
NTSTATUS
KerbWaitForKdc(
    IN ULONG Timeout
    );

NTSTATUS
KerbWaitForService(
    IN LPWSTR ServiceName,
    IN OPTIONAL LPWSTR ServiceEvent,
    IN ULONG Timeout
    );
#endif // WIN32_CHICAGO

ULONG
KerbMapContextFlags(
    IN ULONG ContextFlags
    );

BOOLEAN
KerbIsIpAddress(
    IN PUNICODE_STRING TargetName
    );


VOID
KerbHidePassword(
    IN OUT PUNICODE_STRING Password
    );


VOID
KerbRevealPassword(
    IN OUT PUNICODE_STRING Password
    );

NTSTATUS
KerbDuplicatePassword(
    OUT PUNICODE_STRING DestinationString,
    IN OPTIONAL PUNICODE_STRING SourceString
    );


#ifdef notdef
// use this if we ever need to map errors in kerb to something else.
NTSTATUS
KerbMapKerbNtStatusToNtStatus(
    IN NTSTATUS Status
    );
#else
#ifndef WIN32_CHICAGO
//#if DBG
//#define KerbMapKerbNtStatusToNtStatus(x) (RtlCheckForOrphanedCriticalSections(NtCurrentThread()),x)
//#else
#define KerbMapKerbNtStatusToNtStatus(x) (x)
//#endif
#else // WIN32_CHICAGO
#define KerbMapKerbNtStatusToNtStatus(x) (x)
#endif
#endif

NTSTATUS
KerbExtractDomainName(
    OUT PUNICODE_STRING DomainName,
    IN PKERB_INTERNAL_NAME PrincipalName,
    IN PUNICODE_STRING TicketSourceDomain
    );

VOID
KerbUtcTimeToLocalTime(
    OUT PTimeStamp LocalTime,
    IN PTimeStamp SystemTime
    );

ULONG
KerbConvertKdcOptionsToTicketFlags(
    IN ULONG KdcOptions
    );

NTSTATUS
KerbUnpackErrorMethodData(
   IN PKERB_ERROR ErrorMessage,
   IN OUT OPTIONAL PKERB_ERROR_METHOD_DATA * ppErrorData
   );

NTSTATUS
KerbBuildHostAddresses(
    IN BOOLEAN IncludeIpAddresses,
    IN BOOLEAN IncludeNetbiosAddresses,
    OUT PKERB_HOST_ADDRESSES * HostAddresses
    );

NTSTATUS
KerbReceiveErrorMessage(
    IN PBYTE ErrorMessage,
    IN ULONG ErrorMessageSize,
    IN PKERB_CONTEXT Context,
    OUT PKERB_ERROR * DecodedErrorMessage,
    OUT PKERB_ERROR_METHOD_DATA * ErrorData
    );

NTSTATUS
KerbBuildGssErrorMessage(
    IN KERBERR Error,
    IN PBYTE ErrorData,
    IN ULONG ErrorDataSize,
    IN PKERB_CONTEXT Context,
    OUT PULONG ErrorMessageSize,
    OUT PBYTE * ErrorMessage
    );


NTSTATUS
KerbGetDnsHostName(
    OUT PUNICODE_STRING DnsHostName
    );

NTSTATUS
KerbSetComputerName(
    VOID
    );

NTSTATUS
KerbSetDomainName(
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING DnsDomainName,
    IN PSID DomainSid,
    IN GUID DomainGuid
    );


BOOLEAN
KerbIsThisOurDomain(
    IN PUNICODE_STRING DomainName
    );

NTSTATUS
KerbGetOurDomainName(
    OUT PUNICODE_STRING DomainName
    );

KERBEROS_MACHINE_ROLE
KerbGetGlobalRole(
    VOID
    );


#ifndef WIN32_CHICAGO
NTSTATUS
KerbLoadKdc(
    VOID
    );

NTSTATUS
KerbRegisterForDomainChange(
    VOID
    );

VOID
KerbUnregisterForDomainChange(
    VOID
    );

NTSTATUS
KerbUpdateGlobalAddresses(
    IN PSOCKET_ADDRESS NewAddresses,
    IN ULONG NewAddressCount
    );


NTSTATUS
KerbCaptureTokenRestrictions(
    IN HANDLE TokenHandle,
    OUT PKERB_AUTHORIZATION_DATA Restrictions
    );

NTSTATUS
KerbBuildEncryptedAuthData(
    OUT PKERB_ENCRYPTED_DATA EncryptedAuthData,
    IN PKERB_TICKET_CACHE_ENTRY Ticket,
    IN PKERB_AUTHORIZATION_DATA PlainAuthData
    );

NTSTATUS
KerbGetRestrictedTgtForCredential(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential
    );

NTSTATUS
KerbAddRestrictionsToCredential(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_CREDENTIAL Credential
    );

BOOLEAN
KerbRunningServer(
    VOID
    );


#endif // WIN32_CHICAGO

#endif // __KERBUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\kerbwow.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        kerbwow.cxx
//
// Contents:    Code for 32-64 bit interop for the Kerberos package
//
//
// History:     25-Oct-2000     JSchwart        Created
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>

#ifdef _WIN64

#ifdef DEBUG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

#define FILENO FILENO_KERBWOW



//
// WOW versions of public Kerberos logon buffer structures.  These MUST
// be kept in sync with their public counterparts!
//

typedef struct _KERB_INTERACTIVE_LOGON_WOW64
{
    KERB_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING_WOW64 LogonDomainName;
    UNICODE_STRING_WOW64 UserName;
    UNICODE_STRING_WOW64 Password;
}
KERB_INTERACTIVE_LOGON_WOW64, *PKERB_INTERACTIVE_LOGON_WOW64;


typedef struct _KERB_INTERACTIVE_UNLOCK_LOGON_WOW64
{
    KERB_INTERACTIVE_LOGON_WOW64 Logon;
    LUID LogonId;
}
KERB_INTERACTIVE_UNLOCK_LOGON_WOW64, *PKERB_INTERACTIVE_UNLOCK_LOGON_WOW64;


typedef struct _KERB_SMART_CARD_LOGON_WOW64
{
    KERB_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING_WOW64 Pin;
    ULONG CspDataLength;
    ULONG CspData;
}
KERB_SMART_CARD_LOGON_WOW64, *PKERB_SMART_CARD_LOGON_WOW64;


typedef struct _KERB_SMART_CARD_UNLOCK_LOGON_WOW64
{
    KERB_SMART_CARD_LOGON_WOW64 Logon;
    LUID LogonId;
}
KERB_SMART_CARD_UNLOCK_LOGON_WOW64, *PKERB_SMART_CARD_UNLOCK_LOGON_WOW64;


typedef struct _KERB_TICKET_LOGON_WOW64
{
    KERB_LOGON_SUBMIT_TYPE MessageType;
    ULONG Flags;
    ULONG ServiceTicketLength;
    ULONG TicketGrantingTicketLength;
    ULONG ServiceTicket;
    ULONG TicketGrantingTicket;
}
KERB_TICKET_LOGON_WOW64, *PKERB_TICKET_LOGON_WOW64;

typedef struct _KERB_TICKET_UNLOCK_LOGON_WOW64
{
    KERB_TICKET_LOGON_WOW64 Logon;
    LUID LogonId;
}
KERB_TICKET_UNLOCK_LOGON_WOW64, *PKERB_TICKET_UNLOCK_LOGON_WOW64;


//
// WOW versions of public Kerberos profile buffer structures.  These MUST
// be kept in sync with their public counterparts!
//

typedef struct _KERB_INTERACTIVE_PROFILE_WOW64
{
    KERB_PROFILE_BUFFER_TYPE MessageType;
    USHORT                   LogonCount;
    USHORT                   BadPasswordCount;
    LARGE_INTEGER            LogonTime;
    LARGE_INTEGER            LogoffTime;
    LARGE_INTEGER            KickOffTime;
    LARGE_INTEGER            PasswordLastSet;
    LARGE_INTEGER            PasswordCanChange;
    LARGE_INTEGER            PasswordMustChange;
    UNICODE_STRING_WOW64     LogonScript;
    UNICODE_STRING_WOW64     HomeDirectory;
    UNICODE_STRING_WOW64     FullName;
    UNICODE_STRING_WOW64     ProfilePath;
    UNICODE_STRING_WOW64     HomeDirectoryDrive;
    UNICODE_STRING_WOW64     LogonServer;
    ULONG                    UserFlags;
}
KERB_INTERACTIVE_PROFILE_WOW64, *PKERB_INTERACTIVE_PROFILE_WOW64;

typedef struct _KERB_SMART_CARD_PROFILE_WOW64
{
    KERB_INTERACTIVE_PROFILE_WOW64 Profile;
    ULONG CertificateSize;
    ULONG CertificateData;
}
KERB_SMART_CARD_PROFILE_WOW64, *PKERB_SMART_CARD_PROFILE_WOW64;

typedef struct KERB_CRYPTO_KEY_WOW64
{
    LONG KeyType;
    ULONG Length;
    ULONG Value;
}
KERB_CRYPTO_KEY_WOW64, *PKERB_CRYPTO_KEY_WOW64;

typedef struct _KERB_TICKET_PROFILE_WOW64
{
    KERB_INTERACTIVE_PROFILE_WOW64 Profile;
    KERB_CRYPTO_KEY_WOW64 SessionKey;
}
KERB_TICKET_PROFILE_WOW64, *PKERB_TICKET_PROFILE_WOW64;

typedef struct _KERB_INTERNAL_NAME_WOW64
{
    SHORT                NameType;
    USHORT               NameCount;
    UNICODE_STRING_WOW64 Names[ANYSIZE_ARRAY];
}
KERB_INTERNAL_NAME_WOW64, *PKERB_INTERNAL_NAME_WOW64;

typedef struct _KERB_EXTERNAL_NAME_WOW64
{
    SHORT                NameType;
    USHORT               NameCount;
    UNICODE_STRING_WOW64 Names[ANYSIZE_ARRAY];
}
KERB_EXTERNAL_NAME_WOW64, *PKERB_EXTERNAL_NAME_WOW64;

typedef struct _KERB_EXTERNAL_TICKET_WOW64
{
    ULONG                     ServiceName;
    ULONG                     TargetName;
    ULONG                     ClientName;
    UNICODE_STRING_WOW64      DomainName;
    UNICODE_STRING_WOW64      TargetDomainName;
    UNICODE_STRING_WOW64      AltTargetDomainName;
    KERB_CRYPTO_KEY_WOW64     SessionKey;
    ULONG                     TicketFlags;
    ULONG                     Flags;
    LARGE_INTEGER             StartTime;
    LARGE_INTEGER             EndTime;
    LARGE_INTEGER             RenewUntil;
    LARGE_INTEGER             TimeSkew;
    ULONG                     EncodedTicketSize;
    ULONG                     EncodedTicket;
}
KERB_EXTERNAL_TICKET_WOW64, *PKERB_EXTERNAL_TICKET_WOW64;

#if 0
typedef struct _KERB_EXTERNAL_TICKET_EX_WOW64
{
    PKERB_EXTERNAL_NAME_WOW64      ClientName;
    PKERB_EXTERNAL_NAME_WOW64      ServiceName;
    PKERB_EXTERNAL_NAME_WOW64      TargetName;
    UNICODE_STRING_WOW64           ClientRealm;
    UNICODE_STRING_WOW64           ServiceRealm;
    UNICODE_STRING_WOW64           TargetDomainName;
    UNICODE_STRING_WOW64           AltTargetDomainName;
    KERB_CRYPTO_KEY_WOW64          SessionKey;
    ULONG                          TicketFlags;
    ULONG                          Flags;
    LARGE_INTEGER                  StartTime;
    LARGE_INTEGER                  EndTime;
    LARGE_INTEGER                  RenewUntil;
    LARGE_INTEGER                  TimeSkew;
    PKERB_NET_ADDRESSES            TicketAddresses;
    PKERB_AUTH_DATA                AuthorizationData;
    _KERB_EXTERNAL_TICKET_EX_WOW64 * SecondTicket;
    ULONG                          EncodedTicketSize;
    PUCHAR                         EncodedTicket;
}
KERB_EXTERNAL_TICKET_EX_WOW64, *PKERB_EXTERNAL_TICKET_EX_WOW64;
#endif   // 0

#define RELOCATE_WOW_UNICODE_STRING(WOWString, NativeString, Offset)  \
            NativeString.Length        = WOWString.Length;                             \
            NativeString.MaximumLength = WOWString.MaximumLength;                      \
            NativeString.Buffer        = (LPWSTR) ((LPBYTE) UlongToPtr(WOWString.Buffer) + Offset);


//+-------------------------------------------------------------------------
//
//  Function:   KerbPutWOWString
//
//  Synopsis:   Copies a UNICODE_STRING into a buffer
//
//  Effects:
//
//  Arguments:  InputString - String to 'put'
//              OutputString - Receives 'put' string
//              Offset - Difference in addresses of local and client buffers.
//              Where - Location in local buffer to place string.
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutString.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
KerbPutWOWString(
    IN PUNICODE_STRING        InputString,
    OUT PUNICODE_STRING_WOW64 OutputString,
    IN LONG_PTR               Offset,
    IN OUT PBYTE              * Where
    )
{
    OutputString->Length = OutputString->MaximumLength = InputString->Length;
    OutputString->Buffer = PtrToUlong (*Where + Offset);
    RtlCopyMemory(
        *Where,
        InputString->Buffer,
        InputString->Length
        );
    *Where += InputString->Length;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPutWOWKdcName
//
//  Synopsis:   Copies a Kdc name to a buffer
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutKdcName.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
KerbPutWOWKdcName(
    IN  PKERB_INTERNAL_NAME         InputName,
    OUT PULONG                      OutputName,
    IN  LONG_PTR                    Offset,
    IN  OUT PBYTE                 * Where
    )
{
    ULONG Index;
    PKERB_INTERNAL_NAME_WOW64 LocalName = (PKERB_INTERNAL_NAME_WOW64) *Where;

    if (!ARGUMENT_PRESENT(InputName))
    {
        *OutputName = NULL;
        return;
    }

    *Where += sizeof(KERB_INTERNAL_NAME_WOW64) - sizeof(UNICODE_STRING_WOW64) +
                InputName->NameCount * sizeof(UNICODE_STRING_WOW64);

    LocalName->NameType  = InputName->NameType;
    LocalName->NameCount = InputName->NameCount;

    for (Index = 0; Index < InputName->NameCount ; Index++ )
    {
        LocalName->Names[Index].Length =
            LocalName->Names[Index].MaximumLength =
            InputName->Names[Index].Length;

        LocalName->Names[Index].Buffer = PtrToUlong(*Where + Offset);

        RtlCopyMemory(*Where,
                      InputName->Names[Index].Buffer,
                      InputName->Names[Index].Length);

        *Where += InputName->Names[Index].Length;
    }

    *Where = (PBYTE) ROUND_UP_POINTER(*Where, sizeof(ULONG));

    *OutputName = PtrToUlong((PBYTE) LocalName + Offset);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPutKdcNameAsWOWString
//
//  Synopsis:   Copies a KERB_INTERNAL_NAME into a buffer
//
//  Effects:
//
//  Arguments:  InputString - String to 'put'
//              OutputString - Receives 'put' string
//              Offset - Difference in addresses of local and client buffers.
//              Where - Location in local buffer to place string.
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutKdcNameAsString.  Make sure any
//              changes made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
KerbPutKdcNameAsWOWString(
    IN PKERB_INTERNAL_NAME    InputName,
    OUT PUNICODE_STRING_WOW64 OutputName,
    IN LONG_PTR               Offset,
    IN OUT PBYTE              * Where
    )
{
    USHORT Index;

    OutputName->Buffer = PtrToUlong (*Where + Offset);
    OutputName->Length = 0;
    OutputName->MaximumLength = 0;

    for (Index = 0; Index < InputName->NameCount ; Index++ )
    {
        RtlCopyMemory(
            *Where,
            InputName->Names[Index].Buffer,
            InputName->Names[Index].Length
            );
        *Where += InputName->Names[Index].Length;
        OutputName->Length = OutputName->Length + InputName->Names[Index].Length;
        if (Index == (InputName->NameCount - 1))
        {
            *((LPWSTR) *Where) = L'\0';
            OutputName->MaximumLength = OutputName->Length + sizeof(WCHAR);
        }
        else
        {
            *((LPWSTR) *Where) = L'/';
            OutputName->Length += sizeof(WCHAR);
        }
        *Where += sizeof(WCHAR);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPutWOWClientString
//
//  Synopsis:   Copies a string into a buffer that will be copied to the
//              32-bit client's address space
//
//  Effects:
//
//  Arguments:  Where - Location in local buffer to place string.
//              Delta - Difference in addresses of local and client buffers.
//              OutString - Receives 'put' string
//              InString - String to 'put'
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutClientString.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
KerbPutWOWClientString(
    IN OUT PUCHAR * Where,
    IN LONG_PTR Delta,
    IN PUNICODE_STRING_WOW64 OutString,
    IN PUNICODE_STRING InString
    )
{
    if (InString->Length == 0)
    {
        OutString->Buffer = 0;
        OutString->Length = OutString->MaximumLength = 0;
    }
    else
    {
        RtlCopyMemory(*Where,
                      InString->Buffer,
                      InString->Length);

        OutString->Buffer = PtrToUlong(*Where + Delta);
        OutString->Length = InString->Length;
        *Where += InString->Length;
        *(LPWSTR) (*Where) = L'\0';
        *Where += sizeof(WCHAR);
        OutString->MaximumLength = OutString->Length + sizeof(WCHAR);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbWOWNameLength
//
//  Synopsis:   returns length in bytes of variable portion
//              of KERB_INTERNAL_NAME
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbNameLength.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------

ULONG
KerbWOWNameLength(
    IN PKERB_INTERNAL_NAME Name
    )
{
    ULONG Length = 0;
    ULONG Index;

    if (!ARGUMENT_PRESENT(Name))
    {
        return 0;
    }

    Length = sizeof(KERB_INTERNAL_NAME_WOW64)
                - sizeof(UNICODE_STRING_WOW64)
                + Name->NameCount * sizeof(UNICODE_STRING_WOW64);

    for (Index = 0; Index < Name->NameCount ;Index++ )
    {
        Length += Name->Names[Index].Length;
    }

    Length = ROUND_UP_COUNT(Length, sizeof(ULONG));

    return Length;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbConvertWOWLogonBuffer
//
//  Synopsis:   Converts logon buffers passed in from WOW clients to 64-bit
//
//  Effects:
//
//  Arguments:  ProtocolSubmitBuffer -- original 32-bit logon buffer
//              pSubmitBufferSize    -- size of the 32-bit logon buffer
//              MessageType          -- format of the logon buffer
//              ppTempSubmitBuffer   -- filled in with the converted buffer
//
//  Requires:
//
//  Returns:
//
//  Notes:      This routine allocates the converted buffer and returns it
//              on success.  It is the caller's responsibility to free it.
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbConvertWOWLogonBuffer(
    IN     PVOID                   ProtocolSubmitBuffer,
    IN     PVOID                   ClientBufferBase,
    IN OUT PULONG                  pSubmitBufferSize,
    IN     KERB_LOGON_SUBMIT_TYPE  MessageType,
    OUT    PVOID                   *ppTempSubmitBuffer
    )
{
    NTSTATUS  Status       = STATUS_SUCCESS;
    PVOID     pTempBuffer  = NULL;
    ULONG     dwBufferSize = *pSubmitBufferSize;

    switch (MessageType)
    {
        case KerbInteractiveLogon:
        case KerbWorkstationUnlockLogon:
        {
            PKERB_INTERACTIVE_LOGON        Logon;
            PKERB_INTERACTIVE_LOGON_WOW64  LogonWOW;
            DWORD                          dwOffset;
            DWORD                          dwWOWOffset;

            //
            // Scale up the size and add on 3 PVOIDs for the worst-case
            // scenario to align the three embedded UNICODE_STRINGs
            //

            dwBufferSize += sizeof(KERB_INTERACTIVE_LOGON)
                                - sizeof(KERB_INTERACTIVE_LOGON_WOW64);

            if (dwBufferSize < sizeof(KERB_INTERACTIVE_LOGON))
            {
                DebugLog((DEB_ERROR,
                          "Submit buffer to logon too small: %d. %ws, line %d\n",
                          dwBufferSize,
                          THIS_FILE,
                          __LINE__));

                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            pTempBuffer = KerbAllocate(dwBufferSize);

            if (pTempBuffer == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            Logon    = (PKERB_INTERACTIVE_LOGON) pTempBuffer;
            LogonWOW = (PKERB_INTERACTIVE_LOGON_WOW64) ProtocolSubmitBuffer;

            Logon->MessageType = LogonWOW->MessageType;

            dwOffset    = sizeof(KERB_INTERACTIVE_LOGON);
            dwWOWOffset = sizeof(KERB_INTERACTIVE_LOGON_WOW64);

            if (MessageType == KerbWorkstationUnlockLogon)
            {
                if (dwBufferSize < sizeof(KERB_INTERACTIVE_UNLOCK_LOGON))
                {
                    DebugLog((DEB_ERROR,
                              "Submit buffer to logon too small: %d. %ws, line %d\n",
                              dwBufferSize,
                              THIS_FILE,
                              __LINE__));

                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

                //
                // One additional field for this type (a LUID)
                //

                PKERB_INTERACTIVE_UNLOCK_LOGON        Unlock;
                PKERB_INTERACTIVE_UNLOCK_LOGON_WOW64  UnlockWOW;

                Unlock = (PKERB_INTERACTIVE_UNLOCK_LOGON) pTempBuffer;
                UnlockWOW = (PKERB_INTERACTIVE_UNLOCK_LOGON_WOW64) ProtocolSubmitBuffer;

                Unlock->LogonId = UnlockWOW->LogonId;

                dwOffset    = sizeof(KERB_INTERACTIVE_UNLOCK_LOGON);
                dwWOWOffset = sizeof(KERB_INTERACTIVE_UNLOCK_LOGON_WOW64);
            }

            //
            // Copy the variable-length data
            //

            RtlCopyMemory((LPBYTE) Logon + dwOffset,
                          (LPBYTE) LogonWOW + dwWOWOffset,
                          *pSubmitBufferSize - dwWOWOffset);

            //
            // Set up the pointers in the native struct
            //

            RELOCATE_WOW_UNICODE_STRING(LogonWOW->LogonDomainName,
                                        Logon->LogonDomainName,
                                        dwOffset - dwWOWOffset);

            RELOCATE_WOW_UNICODE_STRING(LogonWOW->UserName,
                                        Logon->UserName,
                                        dwOffset - dwWOWOffset);

            RELOCATE_WOW_UNICODE_STRING(LogonWOW->Password,
                                        Logon->Password,
                                        dwOffset - dwWOWOffset);

            break;
        }

        case KerbSmartCardLogon:
        case KerbSmartCardUnlockLogon:
        {
            PKERB_SMART_CARD_LOGON        Logon;
            PKERB_SMART_CARD_LOGON_WOW64  LogonWOW;
            DWORD                         dwOffset;
            DWORD                         dwWOWOffset;

            //
            // Scale up the size and add on 2 PVOIDs for the worst-case
            // scenario to align the embedded UNICODE_STRING and CspData
            //

            dwBufferSize += sizeof(KERB_SMART_CARD_LOGON)
                                - sizeof(KERB_SMART_CARD_LOGON_WOW64);

            if (dwBufferSize < sizeof(KERB_SMART_CARD_LOGON))
            {
                DebugLog((DEB_ERROR,
                          "Submit buffer to logon too small: %d. %ws, line %d\n",
                          dwBufferSize,
                          THIS_FILE,
                          __LINE__));

                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            pTempBuffer = KerbAllocate(dwBufferSize);

            if (pTempBuffer == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            Logon    = (PKERB_SMART_CARD_LOGON) pTempBuffer;
            LogonWOW = (PKERB_SMART_CARD_LOGON_WOW64) ProtocolSubmitBuffer;

            Logon->MessageType   = LogonWOW->MessageType;
            Logon->CspDataLength = LogonWOW->CspDataLength;

            dwOffset    = sizeof(KERB_SMART_CARD_LOGON);
            dwWOWOffset = sizeof(KERB_SMART_CARD_LOGON_WOW64);

            if (MessageType == KerbSmartCardUnlockLogon)
            {
                if (dwBufferSize < sizeof(KERB_SMART_CARD_UNLOCK_LOGON))
                {
                    DebugLog((DEB_ERROR,
                              "Submit buffer to logon too small: %d. %ws, line %d\n",
                              dwBufferSize,
                              THIS_FILE,
                              __LINE__));

                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

                //
                // One additional field for this type (a LUID)
                //

                PKERB_SMART_CARD_UNLOCK_LOGON        Unlock;
                PKERB_SMART_CARD_UNLOCK_LOGON_WOW64  UnlockWOW;

                Unlock = (PKERB_SMART_CARD_UNLOCK_LOGON) pTempBuffer;
                UnlockWOW = (PKERB_SMART_CARD_UNLOCK_LOGON_WOW64) ProtocolSubmitBuffer;

                Unlock->LogonId = UnlockWOW->LogonId;

                dwOffset    = sizeof(KERB_SMART_CARD_UNLOCK_LOGON);
                dwWOWOffset = sizeof(KERB_SMART_CARD_UNLOCK_LOGON_WOW64);
            }

            //
            // Copy the variable-length data
            //

            RtlCopyMemory((LPBYTE) Logon + dwOffset,
                          (LPBYTE) LogonWOW + dwWOWOffset,
                          *pSubmitBufferSize - dwWOWOffset);

            //
            // Set up the pointers in the native struct
            //

            RELOCATE_WOW_UNICODE_STRING(LogonWOW->Pin,
                                        Logon->Pin,
                                        dwOffset - dwWOWOffset);

            Logon->CspData = (PUCHAR) ((LPBYTE) UlongToPtr(LogonWOW->CspData) + (dwOffset - dwWOWOffset));

            break;
        }

        case KerbTicketLogon:
        case KerbTicketUnlockLogon:
        {
            PKERB_TICKET_LOGON        Logon;
            PKERB_TICKET_LOGON_WOW64  LogonWOW;
            DWORD                     dwOffset;
            DWORD                     dwWOWOffset;

            //
            // Scale up the size and add on 2 PVOIDs for the worst-case
            // scenario to align the two embedded pointers
            //

            dwBufferSize += sizeof(KERB_TICKET_LOGON)
                                - sizeof(KERB_TICKET_LOGON_WOW64);

            if (dwBufferSize < sizeof(KERB_TICKET_LOGON))
            {
                DebugLog((DEB_ERROR,
                          "Submit buffer to logon too small: %d. %ws, line %d\n",
                          dwBufferSize,
                          THIS_FILE,
                          __LINE__));

                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            pTempBuffer = KerbAllocate(dwBufferSize);

            if (pTempBuffer == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            Logon    = (PKERB_TICKET_LOGON) pTempBuffer;
            LogonWOW = (PKERB_TICKET_LOGON_WOW64) ProtocolSubmitBuffer;

            Logon->MessageType                = LogonWOW->MessageType;
            Logon->Flags                      = LogonWOW->Flags;
            Logon->ServiceTicketLength        = LogonWOW->ServiceTicketLength;
            Logon->TicketGrantingTicketLength = LogonWOW->TicketGrantingTicketLength;

            dwOffset    = sizeof(KERB_TICKET_LOGON);
            dwWOWOffset = sizeof(KERB_TICKET_LOGON_WOW64);

            if (MessageType == KerbTicketUnlockLogon)
            {
                if (dwBufferSize < sizeof(KERB_TICKET_UNLOCK_LOGON))
                {
                    DebugLog((DEB_ERROR,
                              "Submit buffer to logon too small: %d. %ws, line %d\n",
                              dwBufferSize,
                              THIS_FILE,
                              __LINE__));

                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

                //
                // One additional field for this type (a LUID)
                //

                PKERB_TICKET_UNLOCK_LOGON        Unlock;
                PKERB_TICKET_UNLOCK_LOGON_WOW64  UnlockWOW;

                Unlock = (PKERB_TICKET_UNLOCK_LOGON) pTempBuffer;
                UnlockWOW = (PKERB_TICKET_UNLOCK_LOGON_WOW64) ProtocolSubmitBuffer;

                Unlock->LogonId = UnlockWOW->LogonId;

                dwOffset    = sizeof(KERB_TICKET_UNLOCK_LOGON);
                dwWOWOffset = sizeof(KERB_TICKET_UNLOCK_LOGON_WOW64);
            }

            //
            // Copy the variable-length data
            //

            RtlCopyMemory((LPBYTE) Logon + dwOffset,
                          (LPBYTE) LogonWOW + dwWOWOffset,
                          *pSubmitBufferSize - dwWOWOffset);

            //
            // Set up the pointers in the native struct
            //

            Logon->ServiceTicket = (PUCHAR) ((LPBYTE) UlongToPtr(LogonWOW->ServiceTicket)
                                                          + (dwOffset - dwWOWOffset));

            Logon->TicketGrantingTicket = (PUCHAR) ((LPBYTE) UlongToPtr(LogonWOW->TicketGrantingTicket)
                                                                 + (dwOffset - dwWOWOffset));

            break;
        }

        default:

            DebugLog((DEB_ERROR,
                      "Invalid info class to logon: %d. %ws, line %d\n",
                      MessageType,
                      THIS_FILE,
                      __LINE__));

            Status = STATUS_INVALID_INFO_CLASS;
            goto Cleanup;
    }

    *pSubmitBufferSize  = dwBufferSize;
    *ppTempSubmitBuffer = pTempBuffer;

    return STATUS_SUCCESS;


Cleanup:

    ASSERT(!NT_SUCCESS(Status));

    if (pTempBuffer)
    {
        KerbFree(pTempBuffer);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAllocateInteractiveWOWProfile
//
//  Synopsis:   This allocates and fills in the interactive profile for
//              a WOW64 client.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:      This code is (effectively) duplicated in
//              KerbAllocateInteractiveBuffer.  Make sure any
//              changes made here are applied there as well.
//
//--------------------------------------------------------------------------


NTSTATUS
KerbAllocateInteractiveWOWBuffer(
    OUT PKERB_INTERACTIVE_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO3 UserInfo,
    IN  PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_ENCRYPTED_TICKET LogonTicket,
    IN OPTIONAL PKERB_INTERACTIVE_LOGON KerbLogonInfo,
    IN  PUCHAR *pClientBufferBase,
    IN  BOOLEAN BuildSmartCardProfile,
    IN  BOOLEAN BuildTicketProfile
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_INTERACTIVE_PROFILE_WOW64 LocalProfileBuffer = NULL;
    PKERB_SMART_CARD_PROFILE_WOW64 SmartCardProfile = NULL;
    PKERB_TICKET_PROFILE_WOW64 TicketProfile = NULL;
    LONG_PTR Delta = 0;
    PUCHAR Where = NULL;

    if (BuildSmartCardProfile)
    {
        *ProfileBufferSize = sizeof(KERB_SMART_CARD_PROFILE_WOW64) +
                LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext->cbCertEncoded;
    }
    else if (BuildTicketProfile)
    {
        *ProfileBufferSize = sizeof(KERB_TICKET_PROFILE_WOW64) +
                LogonTicket->key.keyvalue.length;
    }
    else
    {
        *ProfileBufferSize = sizeof(KERB_INTERACTIVE_PROFILE_WOW64);
    }

    *ProfileBufferSize +=
        UserInfo->LogonScript.Length + sizeof(WCHAR) +
        UserInfo->HomeDirectory.Length + sizeof(WCHAR) +
        UserInfo->HomeDirectoryDrive.Length + sizeof(WCHAR) +
        UserInfo->FullName.Length + sizeof(WCHAR) +
        UserInfo->ProfilePath.Length + sizeof(WCHAR) +
        UserInfo->LogonServer.Length + sizeof(WCHAR);

    LocalProfileBuffer = (PKERB_INTERACTIVE_PROFILE_WOW64) KerbAllocate(*ProfileBufferSize);

    if (LocalProfileBuffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = LsaFunctions->AllocateClientBuffer(
                NULL,
                *ProfileBufferSize,
                (PVOID *) pClientBufferBase
                );

    if ( !NT_SUCCESS( Status ) )
    {
        goto Cleanup;
    }

    Delta = (LONG_PTR) (*pClientBufferBase - (PUCHAR) LocalProfileBuffer) ;

    //
    // Don't walk over smart card data
    //

    if (BuildSmartCardProfile)
    {
        Where = (PUCHAR) ((PKERB_SMART_CARD_PROFILE_WOW64) LocalProfileBuffer + 1);
    }
    else if (BuildTicketProfile)
    {
        Where = (PUCHAR) ((PKERB_TICKET_PROFILE_WOW64) LocalProfileBuffer + 1);
    }
    else
    {
        Where = (PUCHAR) (LocalProfileBuffer + 1);
    }

    //
    // Copy the scalar fields into the profile buffer.
    //

    LocalProfileBuffer->MessageType = KerbInteractiveProfile;
    LocalProfileBuffer->LogonCount = UserInfo->LogonCount;
    LocalProfileBuffer->BadPasswordCount= UserInfo->BadPasswordCount;
    OLD_TO_NEW_LARGE_INTEGER( UserInfo->LogonTime,
                              LocalProfileBuffer->LogonTime );
    OLD_TO_NEW_LARGE_INTEGER( UserInfo->LogoffTime,
                              LocalProfileBuffer->LogoffTime );
    OLD_TO_NEW_LARGE_INTEGER( UserInfo->KickOffTime,
                              LocalProfileBuffer->KickOffTime );
    OLD_TO_NEW_LARGE_INTEGER( UserInfo->PasswordLastSet,
                              LocalProfileBuffer->PasswordLastSet );
    OLD_TO_NEW_LARGE_INTEGER( UserInfo->PasswordCanChange,
                              LocalProfileBuffer->PasswordCanChange );
    OLD_TO_NEW_LARGE_INTEGER( UserInfo->PasswordMustChange,
                              LocalProfileBuffer->PasswordMustChange );
    LocalProfileBuffer->UserFlags = UserInfo->UserFlags;

    //
    // Copy the Unicode strings into the profile buffer.
    //

    KerbPutWOWClientString(&Where,
                           Delta,
                           &LocalProfileBuffer->LogonScript,
                           &UserInfo->LogonScript );

    KerbPutWOWClientString(&Where,
                           Delta,
                           &LocalProfileBuffer->HomeDirectory,
                           &UserInfo->HomeDirectory );

    KerbPutWOWClientString(&Where,
                           Delta,
                           &LocalProfileBuffer->HomeDirectoryDrive,
                           &UserInfo->HomeDirectoryDrive );

    KerbPutWOWClientString(&Where,
                           Delta,
                           &LocalProfileBuffer->FullName,
                           &UserInfo->FullName );

    KerbPutWOWClientString(&Where,
                           Delta,
                           &LocalProfileBuffer->ProfilePath,
                           &UserInfo->ProfilePath );

    KerbPutWOWClientString(&Where,
                           Delta,
                           &LocalProfileBuffer->LogonServer,
                           &UserInfo->LogonServer );

    if (BuildSmartCardProfile)
    {
        LocalProfileBuffer->MessageType = KerbSmartCardProfile;
        SmartCardProfile = (PKERB_SMART_CARD_PROFILE_WOW64) LocalProfileBuffer;
        SmartCardProfile->CertificateSize = LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext->cbCertEncoded;
        SmartCardProfile->CertificateData = PtrToUlong(Where + Delta);

        RtlCopyMemory(Where,
                      LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext->pbCertEncoded,
                      SmartCardProfile->CertificateSize);

        Where += SmartCardProfile->CertificateSize;
    }
    else if (BuildTicketProfile)
    {
        LocalProfileBuffer->MessageType = KerbTicketProfile;
        TicketProfile = (PKERB_TICKET_PROFILE_WOW64) LocalProfileBuffer;

        TicketProfile->SessionKey.KeyType = LogonTicket->key.keytype;
        TicketProfile->SessionKey.Length = LogonTicket->key.keyvalue.length;
        TicketProfile->SessionKey.Value = PtrToUlong(Where + Delta);

        RtlCopyMemory(Where,
                      LogonTicket->key.keyvalue.value,
                      LogonTicket->key.keyvalue.length);

        Where += TicketProfile->SessionKey.Length;
    }

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        LsaFunctions->FreeClientBuffer(NULL, *pClientBufferBase);

        if (LocalProfileBuffer != NULL)
        {
            KerbFree(LocalProfileBuffer);
        }
    }
    else
    {
        *ProfileBuffer = (PKERB_INTERACTIVE_PROFILE) LocalProfileBuffer;
    }

    return Status;

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPackExternalWOWTicket
//
//  Synopsis:   This allocates and fills in the external ticket for
//              a WOW64 client.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPackExternalTicket.  Make sure any
//              changes made here are applied there as well.
//
//--------------------------------------------------------------------------

NTSTATUS
KerbPackExternalWOWTicket(
    IN  PKERB_TICKET_CACHE_ENTRY  pCacheEntry,
    IN  PKERB_MESSAGE_BUFFER      pEncodedTicket,
    OUT PKERB_EXTERNAL_TICKET     *pTicketResponse,
    OUT PBYTE                     *pClientTicketResponse,
    OUT PULONG                    pTicketSize
    )
{
    PKERB_EXTERNAL_TICKET_WOW64 TicketResponseWOW       = NULL;
    PBYTE                       ClientTicketResponseWOW = NULL;
    ULONG                       ulTicketSize;
    ULONG                       Offset;
    PUCHAR                      Where;
    NTSTATUS                    Status;

    ulTicketSize = sizeof(KERB_EXTERNAL_TICKET_WOW64) +
                      pCacheEntry->DomainName.Length +
                      pCacheEntry->TargetDomainName.Length +
                      pCacheEntry->ClientDomainName.Length +
                      pCacheEntry->SessionKey.keyvalue.length +
                      KerbWOWNameLength(pCacheEntry->ServiceName) +
                      KerbWOWNameLength(pCacheEntry->TargetName) +
                      KerbWOWNameLength(pCacheEntry->ClientName) +
                      pEncodedTicket->BufferSize;

    //
    // Now allocate two copies of the structure - one in our process,
    // one in the client's process. We then build the structure in our
    // process but with pointer valid in the client's process
    //

    TicketResponseWOW = (PKERB_EXTERNAL_TICKET_WOW64) KerbAllocate(ulTicketSize);

    if (TicketResponseWOW == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = LsaFunctions->AllocateClientBuffer(NULL,
                                                ulTicketSize,
                                                (PVOID *) &ClientTicketResponseWOW);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Offset = (ULONG) (ClientTicketResponseWOW - (PBYTE) TicketResponseWOW);

    Where = ((PUCHAR) (TicketResponseWOW + 1));

    //
    // Copy the non-pointer fields
    //

    TicketResponseWOW->TicketFlags        = pCacheEntry->TicketFlags;
    TicketResponseWOW->Flags              = 0;
    TicketResponseWOW->StartTime          = pCacheEntry->StartTime;
    TicketResponseWOW->EndTime            = pCacheEntry->EndTime;
    TicketResponseWOW->RenewUntil         = pCacheEntry->RenewUntil;
    TicketResponseWOW->TimeSkew           = pCacheEntry->TimeSkew;
    TicketResponseWOW->SessionKey.KeyType = pCacheEntry->SessionKey.keytype;


    //
    // Copy the structure to the client's address space
    //

    //
    // These are 32-bit PVOID (i.e., ULONG) aligned
    //

    //
    // Make sure the two name types are the same
    //

    DsysAssert(sizeof(KERB_INTERNAL_NAME_WOW64) == sizeof(KERB_EXTERNAL_NAME_WOW64));
    DsysAssert(FIELD_OFFSET(KERB_INTERNAL_NAME_WOW64,NameType) == FIELD_OFFSET(KERB_EXTERNAL_NAME_WOW64,NameType));
    DsysAssert(FIELD_OFFSET(KERB_INTERNAL_NAME_WOW64,NameCount) == FIELD_OFFSET(KERB_EXTERNAL_NAME_WOW64,NameCount));
    DsysAssert(FIELD_OFFSET(KERB_INTERNAL_NAME_WOW64,Names) == FIELD_OFFSET(KERB_EXTERNAL_NAME_WOW64,Names));

    KerbPutWOWKdcName(pCacheEntry->ServiceName,
                      &TicketResponseWOW->ServiceName,
                      Offset,
                      &Where);

    KerbPutWOWKdcName(pCacheEntry->TargetName,
                      &TicketResponseWOW->TargetName,
                      Offset,
                      &Where);

    KerbPutWOWKdcName(pCacheEntry->ClientName,
                      &TicketResponseWOW->ClientName,
                      Offset,
                      &Where);

    //
    // From here on, they are WCHAR aligned
    //

    KerbPutWOWString(&pCacheEntry->DomainName,    
                     &TicketResponseWOW->DomainName,
                     Offset,
                     &Where);

    KerbPutWOWString(&pCacheEntry->TargetDomainName,
                     &TicketResponseWOW->TargetDomainName,
                     Offset,
                     &Where);

    KerbPutWOWString(&pCacheEntry->ClientDomainName,           // bug # 488056
                     &TicketResponseWOW->AltTargetDomainName,
                     Offset,
                     &Where);

    //
    // And from here they are BYTE aligned
    //

    TicketResponseWOW->SessionKey.Value = PtrToUlong(Where + Offset);

    RtlCopyMemory(Where,
                  pCacheEntry->SessionKey.keyvalue.value,
                  pCacheEntry->SessionKey.keyvalue.length);

    Where += pCacheEntry->SessionKey.keyvalue.length;

    TicketResponseWOW->SessionKey.Length = pCacheEntry->SessionKey.keyvalue.length;

    TicketResponseWOW->EncodedTicketSize = pEncodedTicket->BufferSize;
    TicketResponseWOW->EncodedTicket     = PtrToUlong(Where + Offset);

    RtlCopyMemory(Where,
                  pEncodedTicket->Buffer,
                  pEncodedTicket->BufferSize);

    Where += pEncodedTicket->BufferSize;

    DsysAssert(Where - ((PUCHAR) TicketResponseWOW) == (LONG_PTR) ulTicketSize);

    *pTicketResponse       = (PKERB_EXTERNAL_TICKET) TicketResponseWOW;
    *pClientTicketResponse = ClientTicketResponseWOW;
    *pTicketSize           = ulTicketSize;

    return STATUS_SUCCESS;

Cleanup:

    if (TicketResponseWOW != NULL)
    {
        KerbFree(TicketResponseWOW);
    }

    if (ClientTicketResponseWOW != NULL)
    {
        LsaFunctions->FreeClientBuffer(NULL, ClientTicketResponseWOW);
    }

    *pTicketResponse       = NULL;
    *pClientTicketResponse = NULL;
    *pTicketSize           = 0;

    return Status;
}

#endif  // _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\krbevent.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       krbevent.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    05-Oct-98       MikeSw          Created
//
//----------------------------------------------------------------------------

#ifndef __KRBEVENT_H__
#define __KRBEVENT_H__

#define KERB_FUNC_INIT_CONTEXT          L"InitializeSecurityContext"
#define KERB_FUNC_ACCEPT_CONTEXT        L"AcceptSecurityContext"
#define KERB_FUNC_LOGON_USER            L"LogonUser"
#define KERB_FUNC_ACQUIRE_CREDS         L"AcquireCredentialsHandle"
#define KERB_FUNC_CHANGE_PASSWORD       L"ChangePassword"
#define KERB_FUNC_BUILD_PREAUTH         L"BuildPreAuthDataForRealm"


#ifndef WIN32_CHICAGO
NTSTATUS
KerbInitializeEvents(void);


VOID
KerbReportPACError(
    PUNICODE_STRING ClientName,
    PUNICODE_STRING ClientDomain,
    NTSTATUS        FailureStatus
    );

VOID
KerbReportRasCardError(
    NTSTATUS CardStatus
    );

VOID
KerbReportCredmanError(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Domain,
    IN BOOLEAN Pkinit,
    IN NTSTATUS CardStatus
    );




VOID
KerbReportPkinitError(
    ULONG PolicyStatus,
    IN OPTIONAL PCCERT_CONTEXT KdcCert
    );


VOID
KerbReportTransportError(NTSTATUS Status);

VOID
KerbResetTransportCounter();

NTSTATUS
KerbInitUdpStatistics();

VOID
KerbReportMissingRDN();



VOID
KerbReportKerbError(
                   IN OPTIONAL PKERB_INTERNAL_NAME PrincipalName,
                   IN OPTIONAL PUNICODE_STRING PrincipalRealm,
                   IN OPTIONAL PKERB_LOGON_SESSION LogonSession,
                   IN OPTIONAL PKERB_CREDENTIAL Credential,
                   IN ULONG KlinInfo,
                   IN OPTIONAL PKERB_ERROR ErrorMsg,
                   IN ULONG KerbError,
                   IN OPTIONAL PKERB_EXT_ERROR pExtendedError,
                   IN BOOLEAN RequiredEvent
                   );


VOID
KerbReportApError(
   PKERB_ERROR ErrorMessage,
   IN OPTIONAL PUNICODE_STRING TargetServer
   );

VOID
KerbReportNtstatus(
    IN ULONG ErrorClass,
    IN NTSTATUS Status,
    IN LPWSTR* ErrorStrings,
    IN ULONG NumberOfStrings,
    IN PULONG Data,
    IN ULONG NumberOfUlong
    );








VOID
KerbShutdownEvents(void);

#else // WIN32_CHICAGO

#define KerbInitializeEvents() (STATUS_SUCCESS)
#define KerbShutdownEvents() (TRUE)
#define KerbReportKerbError(_a_,_b_,_u_,_v_,_w_,_x_,_y_,_z_)
#define KerbReportApError(_a_)
#endif

#endif //  __KRBEVENT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\krbaudit.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 2001
//
// File:        krbaudit.h
//
// Contents:    Auditing routines
//
//
// History:     27-April-2001   Created         kumarp
//
//------------------------------------------------------------------------

NTSTATUS
KerbGetLogonGuid(
    IN  PKERB_PRIMARY_CREDENTIAL  pPrimaryCredentials,
    IN  PKERB_ENCRYPTED_KDC_REPLY pKdcReplyBody,
    OUT LPGUID pLogonGuid
    );


NTSTATUS
KerbGenerateAuditForLogonUsingExplicitCreds(
    IN PKERB_LOGON_SESSION CurrentUserLogonSession,
    IN PKERB_PRIMARY_CREDENTIAL NewUserPrimaryCredentials,
    IN LPGUID pNewUserLogonGuid,
    IN PKERB_INTERNAL_NAME pTargetName
    );

NTSTATUS
KerbAuditLogon(
    IN NTSTATUS LogonStatus,
    IN NTSTATUS LogonSubStatus,
    IN PKERB_CONTEXT Context,
    IN PUNICODE_STRING pWorkstationName,
    IN PLUID pLogonId,
    IN PLSA_ADT_STRING_LIST pTransittedServices
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\krbevent.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       events.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    1-03-95   RichardW   Created
//
//----------------------------------------------------------------------------


#include <kerb.hxx>
#include <kerbp.h>
#include "krbevent.h"
#include "kerbevt.h"
#include <limits.h>

#ifdef DEBUG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif


HANDLE  KerbEventLogHandle = NULL;
WCHAR   KerbEventSourceName[] = L"Kerberos";

LONG           KerbUdpTimeoutEvents = 0;
TimeStamp       KerbUdpNextUpdate;
RTL_RESOURCE    KerbUdpLock;

#define         UDPTIMEOUT_LOGGING_THRESHHOLD   20
#define         UDPTIMEOUT_LOGGING_INTERVAL     30
#define         KerbWriteLockUdpStats()         RtlAcquireResourceExclusive(&KerbUdpLock, TRUE)
#define         KerbReadLockUdpStats()          RtlAcquireResourceShared(&KerbUdpLock, TRUE)
#define         KerbReadToWriteLockUdpStats()   RtlConvertSharedToExclusive(&KerbUdpLock);
#define         KerbUnlockUdpStats()            RtlReleaseResource(&KerbUdpLock)



//+-------------------------------------------------------------------------
//
//  Function:   KerbInitUdpStatistics
//
//  Synopsis:   returns a string from the data segment pointing to the name
//              of an error
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//-
NTSTATUS
KerbInitUdpStatistics()
{
    NTSTATUS Status = STATUS_SUCCESS;
    TimeStamp CurrentTime, Delta;

    GetSystemTimeAsFileTime((LPFILETIME) &CurrentTime );
    KerbSetTimeInMinutes(&Delta, UDPTIMEOUT_LOGGING_INTERVAL); 

    __try
    {
        RtlInitializeResource(&KerbUdpLock);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status =  STATUS_INSUFFICIENT_RESOURCES;
        return Status;
    }     

    KerbWriteLockUdpStats();                                                   
    KerbSetTime(&KerbUdpNextUpdate,(KerbGetTime(CurrentTime) + KerbGetTime(Delta)));
    KerbUdpTimeoutEvents = 0;
    KerbUnlockUdpStats();

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbErrorToString
//
//  Synopsis:   returns a string from the data segment pointing to the name
//              of an error
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


LPWSTR
KerbErrorToString(
                 IN KERBERR KerbErr
                 )
{
   LPWSTR String;
   switch (KerbErr)
   {
   case KDC_ERR_NONE                  : String = L"KDC_ERR_NONE"; break;
   case KDC_ERR_NAME_EXP              : String = L"KDC_ERR_NAME_EXP"; break;
   case KDC_ERR_SERVICE_EXP           : String = L"KDC_ERR_SERVICE_EXP"; break;
   case KDC_ERR_BAD_PVNO              : String = L"KDC_ERR_BAD_PVNO"; break;
   case KDC_ERR_C_OLD_MAST_KVNO       : String = L"KDC_ERR_C_OLD_MAST_KVNO"; break;
   case KDC_ERR_S_OLD_MAST_KVNO       : String = L"KDC_ERR_S_OLD_MAST_KVNO"; break;
   case KDC_ERR_C_PRINCIPAL_UNKNOWN   : String = L"KDC_ERR_C_PRINCIPAL_UNKNOWN"; break;
   case KDC_ERR_S_PRINCIPAL_UNKNOWN   : String = L" KDC_ERR_S_PRINCIPAL_UNKNOWN"; break;
   case KDC_ERR_PRINCIPAL_NOT_UNIQUE  : String = L"KDC_ERR_PRINCIPAL_NOT_UNIQUE"; break;
   case KDC_ERR_NULL_KEY              : String = L"KDC_ERR_NULL_KEY"; break;
   case KDC_ERR_CANNOT_POSTDATE       : String = L"KDC_ERR_CANNOT_POSTDATE"; break;
   case KDC_ERR_NEVER_VALID           : String = L"KDC_ERR_NEVER_VALID"; break;
   case KDC_ERR_POLICY                : String = L"KDC_ERR_POLICY"; break;
   case KDC_ERR_BADOPTION             : String = L"KDC_ERR_BADOPTION"; break;
   case KDC_ERR_ETYPE_NOTSUPP         : String = L"KDC_ERR_ETYPE_NOTSUPP"; break;
   case KDC_ERR_SUMTYPE_NOSUPP        : String = L"KDC_ERR_SUMTYPE_NOSUPP"; break;
   case KDC_ERR_PADATA_TYPE_NOSUPP    : String = L"KDC_ERR_PADATA_TYPE_NOSUPP"; break;
   case KDC_ERR_TRTYPE_NO_SUPP        : String = L"KDC_ERR_TRTYPE_NO_SUPP"; break;
   case KDC_ERR_CLIENT_REVOKED        : String = L"KDC_ERR_CLIENT_REVOKED"; break;
   case KDC_ERR_SERVICE_REVOKED       : String = L"KDC_ERR_SERVICE_REVOKED"; break;
   case KDC_ERR_TGT_REVOKED           : String = L"KDC_ERR_TGT_REVOKED"; break;
   case KDC_ERR_CLIENT_NOTYET         : String = L"KDC_ERR_CLIENT_NOTYET"; break;
   case KDC_ERR_SERVICE_NOTYET        : String = L"KDC_ERR_SERVICE_NOTYET"; break;
   case KDC_ERR_KEY_EXPIRED           : String = L"KDC_ERR_KEY_EXPIRED"; break;
   case KDC_ERR_PREAUTH_FAILED        : String = L"KDC_ERR_PREAUTH_FAILED"; break;
   case KDC_ERR_PREAUTH_REQUIRED      : String = L"KDC_ERR_PREAUTH_REQUIRED"; break;
   case KDC_ERR_SERVER_NOMATCH        : String = L"KDC_ERR_SERVER_NOMATCH"; break;
   case KDC_ERR_SVC_UNAVAILABLE       : String = L"KDC_ERR_SVC_UNAVAILABLE"; break;

   case KRB_AP_ERR_BAD_INTEGRITY      : String = L"KRB_AP_ERR_BAD_INTEGRITY"; break;
   case KRB_AP_ERR_TKT_EXPIRED        : String = L"KRB_AP_ERR_TKT_EXPIRED"; break;
   case KRB_AP_ERR_TKT_NYV            : String = L"KRB_AP_ERR_TKT_NYV"; break;
   case KRB_AP_ERR_REPEAT             : String = L"KRB_AP_ERR_REPEAT"; break;
   case KRB_AP_ERR_NOT_US             : String = L"KRB_AP_ERR_NOT_US"; break;
   case KRB_AP_ERR_BADMATCH           : String = L"KRB_AP_ERR_BADMATCH"; break;
   case KRB_AP_ERR_SKEW               : String = L"KRB_AP_ERR_SKEW"; break;
   case KRB_AP_ERR_BADADDR            : String = L"KRB_AP_ERR_BADADDR"; break;
   case KRB_AP_ERR_BADVERSION         : String = L"KRB_AP_ERR_BADVERSION"; break;
   case KRB_AP_ERR_MSG_TYPE           : String = L"KRB_AP_ERR_MSG_TYPE"; break;
   case KRB_AP_ERR_MODIFIED           : String = L"KRB_AP_ERR_MODIFIED"; break;
   case KRB_AP_ERR_BADORDER           : String = L"KRB_AP_ERR_BADORDER"; break;
   case KRB_AP_ERR_BADKEYVER          : String = L"KRB_AP_ERR_BADKEYVER"; break;
   case KRB_AP_ERR_NOKEY              : String = L"KRB_AP_ERR_NOKEY"; break;
   case KRB_AP_ERR_MUT_FAIL           : String = L"KRB_AP_ERR_MUT_FAIL"; break;
   case KRB_AP_ERR_BADDIRECTION       : String = L"KRB_AP_ERR_BADDIRECTION"; break;
   case KRB_AP_ERR_METHOD             : String = L"KRB_AP_ERR_METHOD"; break;
   case KRB_AP_ERR_BADSEQ             : String = L"KRB_AP_ERR_BADSEQ"; break;
   case KRB_AP_ERR_INAPP_CKSUM        : String = L"KRB_AP_ERR_INAPP_CKSUM"; break;
   case KRB_AP_PATH_NOT_ACCEPTED      : String = L"KRB_AP_PATH_NOT_ACCEPTED"; break;
   case KRB_ERR_RESPONSE_TOO_BIG      : String = L"KRB_ERR_RESPONSE_TOO_BIG"; break;

   case KRB_ERR_GENERIC               : String = L"KRB_ERR_GENERIC"; break;
   case KRB_ERR_FIELD_TOOLONG         : String = L"KRB_ERR_FIELD_TOOLONG"; break;


   case KDC_ERR_CLIENT_NOT_TRUSTED    : String = L"KDC_ERR_CLIENT_NOT_TRUSTED"; break;
   case KDC_ERR_KDC_NOT_TRUSTED       : String = L"KDC_ERR_KDC_NOT_TRUSTED"; break;
   case KDC_ERR_INVALID_SIG           : String = L"KDC_ERR_INVALID_SIG"; break;
   case KDC_ERR_KEY_TOO_WEAK          : String = L"KDC_ERR_KEY_TOO_WEAK"; break;
   case KRB_AP_ERR_USER_TO_USER_REQUIRED : String = L"KRB_AP_ERR_USER_TO_USER_REQUIRED"; break;
   case KRB_AP_ERR_NO_TGT             : String = L"KRB_AP_ERR_NO_TGT"; break;
   case KDC_ERR_WRONG_REALM           : String = L"KDC_ERR_WRONG_REALM"; break;
   default                            : String = L"Unknown Error"; break;

   }
   return(String);
}




//+---------------------------------------------------------------------------
//
//  Function:   InitializeEvents
//
//  Synopsis:   Connects to event log service
//
//  Arguments:  (none)
//
//  History:    1-03-95   RichardW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
NTSTATUS
KerbInitializeEvents(
    VOID
    )
{
    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitEventLogHandle
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbInitEventLogHandle()
{
    NTSTATUS Status = STATUS_SUCCESS;

    if (KerbEventLogHandle == NULL)
    {
        HANDLE EventLogHandle;

        //
        // open an instance of kerb event sources, that discards duplicate
        // events in a one hour window.
        //

        EventLogHandle = NetpEventlogOpen( KerbEventSourceName, 60000*60 );      
        if (EventLogHandle != NULL)
        {
            //
            // atomically store the new handle value.  If there was a race,
            // free the one we just created.
            //
            
            if(InterlockedCompareExchangePointer(
                        &KerbEventLogHandle,
                        EventLogHandle,
                        NULL
                        ) != NULL)
            {
                NetpEventlogClose( EventLogHandle );    
            }
        }

        if (KerbEventLogHandle == NULL)
        {
            D_DebugLog((DEB_ERROR, "Could not open event log, error %d. %ws, line %d - %x\n", GetLastError(), THIS_FILE, __LINE__, Status));
            return STATUS_EVENTLOG_CANT_START;
        }
    }
    
    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbReportNtstatus
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
#define MAX_NTSTATUS_STRINGS 10
#define MAX_ULONG_STRING 20
VOID
KerbReportNtstatus(
    IN ULONG ErrorClass,
    IN NTSTATUS Status,
    IN LPWSTR* ErrorStrings,
    IN ULONG NumberOfStrings,
    IN PULONG Data,
    IN ULONG NumberOfUlong
    )
{
    ULONG   StringCount, i, j, allocstart = 0;
    LPWSTR  Strings[MAX_NTSTATUS_STRINGS];
    

    StringCount = NumberOfUlong + NumberOfStrings;

    if (StringCount > MAX_NTSTATUS_STRINGS)
    {
        return;
    }

    //
    // Validate params
    //
    switch (ErrorClass)
    {
    case KERBEVT_INSUFFICIENT_TOKEN_SIZE:
        if ((NumberOfStrings != 0) || (NumberOfUlong > 3))
        {
            DsysAssert(FALSE);
            return;
        }
        break;

    default:
        return;
    }


    if (KerbEventLogHandle == NULL)
    {
        NTSTATUS TmpStatus;
        TmpStatus = KerbInitEventLogHandle();
        if (TmpStatus != STATUS_SUCCESS)
        {
            return;
        }
    }



    ZeroMemory( Strings, (StringCount * sizeof(Strings[0])) );

    for (i = 0; i < NumberOfStrings; i++)
    {
        Strings[i] = ErrorStrings[i];
    }

    allocstart = i; // save for cleanup

    for (j = 0; j < NumberOfUlong; j++)
    {
        UNICODE_STRING DummyString = { MAX_ULONG_STRING, MAX_ULONG_STRING, NULL};

        DummyString.Buffer = (LPWSTR) LsaFunctions->AllocatePrivateHeap(MAX_ULONG_STRING);
        if ( DummyString.Buffer == NULL )
        {
            goto Cleanup;
        }

        //
        // Use this since they don't export
        // RtlIntegerToUnicode(), and we don't want to
        // bring in _itow.
        //
        RtlIntegerToUnicodeString(
                Data[j],
                16,
                &DummyString
                );

        Strings[i] = DummyString.Buffer;

        i++;
    }

    if (ERROR_SUCCESS != NetpEventlogWriteEx(
                                KerbEventLogHandle,
                                EVENTLOG_WARNING_TYPE,
                                0,
                                ErrorClass,
                                (WORD) StringCount,
                                sizeof(NTSTATUS),
                                Strings,
                                &Status
                                ))
    {
        D_DebugLog((DEB_ERROR,"Failed to report event: %d. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
    }

Cleanup:

    for (i = allocstart ; i < (allocstart+NumberOfUlong) ; i++)
    {
        if (Strings[i] != NULL)
        {
            LsaFunctions->FreePrivateHeap(Strings[i]);
        }
    }

    return;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReportKerbError
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbReportKerbError(
                   IN OPTIONAL PKERB_INTERNAL_NAME PrincipalName,
                   IN OPTIONAL PUNICODE_STRING PrincipalRealm,
                   IN OPTIONAL PKERB_LOGON_SESSION LogonSession,
                   IN OPTIONAL PKERB_CREDENTIAL Credential,
                   IN ULONG KlinInfo,
                   IN OPTIONAL PKERB_ERROR ErrorMsg,
                   IN ULONG KerbError,
                   IN OPTIONAL PKERB_EXT_ERROR pExtendedError,
                   IN BOOLEAN RequiredEvent
                   )
{
#ifdef WIN32_CHICAGO
    return;
#else
    UNICODE_STRING ClientRealm = {0};
    UNICODE_STRING ClientName = {0};
    UNICODE_STRING ServerRealm = {0};
    UNICODE_STRING ServerName = {0};
    UNICODE_STRING ErrorText = {0};
    UNICODE_STRING LogonSessionName = {0};
    UNICODE_STRING TargetFullName = {0};
    WCHAR ClientTime[50] = {0};
    WCHAR ServerTime[50] = {0};
    WCHAR LineString[12] = {0};
    WCHAR FileString[12] = {0};
    WCHAR ErrorCode[12] = {0};
    WCHAR ExtendedError[128] = {0};
    KERBERR KerbErr;
    ULONG NameType;
    NTSTATUS Status = STATUS_SUCCESS;
    STRING KerbString = {0};
#define KERB_ERROR_STRING_COUNT 14
    LPWSTR Strings[KERB_ERROR_STRING_COUNT];
    ULONG RawDataSize = 0;
    PVOID RawData = NULL;
    ULONG Index;

    if ( !RequiredEvent && (KerbGlobalLoggingLevel == 0) )
    {
        return;
    }

    if (KerbEventLogHandle == NULL)
    {
        Status = KerbInitEventLogHandle();
        if (Status != STATUS_SUCCESS)
        {
            return;
        }
    }

    //
    // Get the user name from the logon session
    //

    if (ARGUMENT_PRESENT(LogonSession))
    {
        KerbReadLockLogonSessions( LogonSession );
        KerbErr = KerbBuildFullServiceName(
                      &LogonSession->PrimaryCredentials.DomainName,
                      &LogonSession->PrimaryCredentials.UserName,
                      &LogonSessionName
                      );
 
        KerbUnlockLogonSessions( LogonSession );
 
        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
    }

    if (ARGUMENT_PRESENT(pExtendedError))
    {
        swprintf(ExtendedError, L"0x%x KLIN(%x)", pExtendedError->status, pExtendedError->klininfo);
    }

    if (ARGUMENT_PRESENT(PrincipalName) && ARGUMENT_PRESENT(PrincipalRealm))
    {
        KerbConvertKdcNameToString(
            &TargetFullName,
            PrincipalName,
            PrincipalRealm
            );
    }

    swprintf(LineString, L"%x", (KlinInfo & 0xFFFF));
    swprintf(FileString, L"%x", (KlinInfo >> 16));

    if (ARGUMENT_PRESENT(ErrorMsg))
    {
        swprintf(ErrorCode, L"0x%x", ErrorMsg->error_code);

        //
        // Get the client and server realms
        //
     
        if ((ErrorMsg->bit_mask & client_realm_present) != 0)
        {
            KerbErr = KerbConvertRealmToUnicodeString(
                          &ClientRealm,
                          &ErrorMsg->client_realm
                          );

            if (!KERB_SUCCESS(KerbErr))
            {
                goto Cleanup;
            }
        }
   
        if (ErrorMsg->realm != NULL)
        {
            KerbErr = KerbConvertRealmToUnicodeString(
                          &ServerRealm,
                          &ErrorMsg->realm
                          );

            if (!KERB_SUCCESS(KerbErr))
            {
               goto Cleanup;
            }
        }
   
        if ((ErrorMsg->bit_mask & KERB_ERROR_client_name_present) != 0)
        {
            KerbErr = KerbConvertPrincipalNameToString(
                          &ClientName,
                          &NameType,
                          &ErrorMsg->KERB_ERROR_client_name
                          );

            if (!KERB_SUCCESS(KerbErr))
            {
               goto Cleanup;
            }
        }
   
        KerbErr = KerbConvertPrincipalNameToString(
                      &ServerName,
                      &NameType,
                      &ErrorMsg->server_name
                      );

        if (!KERB_SUCCESS(KerbErr))
        {
            goto Cleanup;
        }
   
        if ((ErrorMsg->bit_mask & client_time_present) != 0)
        {
            swprintf(ClientTime,L"%d:%d:%d.%04d %d/%d/%d %ws",
                     ErrorMsg->client_time.hour,
                     ErrorMsg->client_time.minute,
                     ErrorMsg->client_time.second,
                     ErrorMsg->client_time.millisecond,
                     ErrorMsg->client_time.month,
                     ErrorMsg->client_time.day,
                     ErrorMsg->client_time.year,
                     (ErrorMsg->client_time.universal) ? L"Z" : L""
                    );
        }
   
        swprintf(ServerTime,L"%d:%d:%d.%04d %d/%d/%d %ws",
                 ErrorMsg->server_time.hour,
                 ErrorMsg->server_time.minute,
                 ErrorMsg->server_time.second,
                 ErrorMsg->server_time.millisecond,
                 ErrorMsg->server_time.month,
                 ErrorMsg->server_time.day,
                 ErrorMsg->server_time.year,
                 (ErrorMsg->server_time.universal) ? L"Z" : L""
                );

        if (((ErrorMsg->bit_mask & error_text_present) != 0) &&
            (ErrorMsg->error_text.length < SHRT_MAX))
        {
            KerbString.Buffer = ErrorMsg->error_text.value;
            KerbString.Length = (USHORT) ErrorMsg->error_text.length;
   
            KerbErr = KerbStringToUnicodeString(
                          &ErrorText,
                          &KerbString
                          );

            if (!KERB_SUCCESS(KerbErr))
            {
               goto Cleanup;
            }
        }

        if ((ErrorMsg->bit_mask & error_data_present) != 0)
        {
            RawDataSize = ErrorMsg->error_data.length;
            RawData = ErrorMsg->error_data.value;
        }
    }
    else
    {
        swprintf(ErrorCode, L"0x%x", KerbError);
    }

    //
    // Build the array of strings
    //
 
    Strings[0] = LogonSessionName.Buffer;
    Strings[1] = ClientTime;
    Strings[2] = ServerTime;
    Strings[3] = ErrorCode;
    Strings[4] = (ARGUMENT_PRESENT(ErrorMsg)
                  ? KerbErrorToString(ErrorMsg->error_code) :
                    KerbErrorToString(KerbError));

    Strings[5] = ExtendedError;
    Strings[6] = ClientRealm.Buffer;
    Strings[7] = ClientName.Buffer;
    Strings[8] = ServerRealm.Buffer;
    Strings[9] = ServerName.Buffer;
    Strings[10] = TargetFullName.Buffer;
    Strings[11] = ErrorText.Buffer;
    Strings[12] = FileString;
    Strings[13] = LineString;

    //
    // Replace NULLs with an empty string.
    //

    for (Index = 0; Index < KERB_ERROR_STRING_COUNT ; Index++ )
    {
        if (Strings[Index] == NULL)
        {
            Strings[Index] = L"";
        }
    }

    if (ERROR_SUCCESS != NetpEventlogWriteEx(
                             KerbEventLogHandle,
                             EVENTLOG_ERROR_TYPE,
                             0,
                             KERBEVT_KERB_ERROR_MSG,
                             KERB_ERROR_STRING_COUNT,
                             RawDataSize,
                             Strings,
                             RawData
                             ))
    {
        D_DebugLog((DEB_ERROR,"Failed to report event: %d. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
    }

Cleanup:

    KerbFreeString( &LogonSessionName );
    KerbFreeString( &ClientRealm );
    KerbFreeString( &ClientName );
    KerbFreeString( &ServerRealm );
    KerbFreeString( &ServerName );
    KerbFreeString( &ErrorText );
    KerbFreeString( &TargetFullName );
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReportApModifiedError
//
//  Synopsis:   Reports error of type KRB_AP_ERR_MODIFIED
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

#define MAX_STRINGS 3
VOID
KerbReportApError(
   PKERB_ERROR ErrorMsg,
   IN OPTIONAL PUNICODE_STRING TargetName
   )
{


   KERBERR KerbErr;
   LPWSTR  Strings[MAX_STRINGS] = {NULL, NULL, NULL};
   DWORD   EventId = 0, dwDataSize = 0;
   WORD StringCount = 2;
   LPVOID  lpRawData = NULL;
   UNICODE_STRING ServerName = {0};
   UNICODE_STRING ServerRealm = {0};
   UNICODE_STRING NewTargetName = {0};
   ULONG NameType;
   NTSTATUS Status;

    if (KerbEventLogHandle == NULL)
    {
        Status = KerbInitEventLogHandle();
        if (Status != STATUS_SUCCESS)
        {
            return;
        }
    }

   KerbErr = KerbConvertPrincipalNameToString(
                                          &ServerName,
                                          &NameType,
                                          &ErrorMsg->server_name
                                          );
   if (!KERB_SUCCESS(KerbErr))
   {
      goto Cleanup;
   }

   if (ErrorMsg->realm != NULL)
   {
      KerbErr = KerbConvertRealmToUnicodeString(
                                               &ServerRealm,
                                               &ErrorMsg->realm
                                               );
      if (!KERB_SUCCESS(KerbErr))
      {
         goto Cleanup;
      }
   }

   Strings[0] = ServerName.Buffer;
   Strings[1] = ServerRealm.Buffer;

   switch (ErrorMsg->error_code)
   {
   case KRB_AP_ERR_MODIFIED:
      EventId = KERBEVT_KRB_AP_ERR_MODIFIED;

      // not sure if this is always null terminated, so do it.
      Status = KerbDuplicateString(
                &NewTargetName,
                TargetName
                );

      if (Status != STATUS_SUCCESS)
      {
          return;
      }
      Strings[2] = NewTargetName.Buffer;
      StringCount++;
      break;
   case KRB_AP_ERR_TKT_NYV:
      EventId = KERBEVT_KRB_AP_ERR_TKT_NYV;
      break;
   default:
      D_DebugLog((DEB_ERROR, "Unknown error to KerbReportApError  %x\n", ErrorMsg->error_code));
      goto Cleanup;
   }


   if (ERROR_SUCCESS != NetpEventlogWriteEx(
                                KerbEventLogHandle,
                                EVENTLOG_ERROR_TYPE,
                                0,
                                EventId,
                                StringCount,
                                dwDataSize,
                                Strings,
                                lpRawData
                                ))
   {
      D_DebugLog((DEB_ERROR,"Failed to report event: %d. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
   }

Cleanup:

   KerbFreeString( &ServerRealm );
   KerbFreeString( &ServerName );
   KerbFreeString( &NewTargetName );

}



#endif // WIN32_CHICAGO

//+-------------------------------------------------------------------------
//
//  Function:   KerbShutdownEvents
//
//  Synopsis:   Shutsdown event log reporting
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbShutdownEvents(
    VOID
    )
{
    HANDLE EventLogHandle;
    
    EventLogHandle = InterlockedExchangePointer( &KerbEventLogHandle, NULL );

    if( EventLogHandle )
    {
        NetpEventlogClose( EventLogHandle );
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbReportPACError
//
//  Synopsis:   Reports error of type KERBEVT_KRB_PAC_VERIFICATION_FAILURE
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbReportPACError(
    PUNICODE_STRING ClientName,
    PUNICODE_STRING ClientDomain,
    NTSTATUS        FailureStatus
    )
{
   LPWSTR  Strings[MAX_STRINGS] = {NULL, NULL};
   NTSTATUS Status;
   
   if (KerbEventLogHandle == NULL)
   {
       Status = KerbInitEventLogHandle();
       if (Status != STATUS_SUCCESS)
       {
           return;
       }
   }


   //
   // There's a small window of oppty when KDCs might try to validate
   // the PAC locally, even though the kdcsvc.dll hasn't been loaded into
   // lsass.exe yet.
   //
   if ( FailureStatus == STATUS_MUST_BE_KDC )
   {
       return;
   }

   Strings[0] = ClientName->Buffer;    // this is null terminated in this case
   Strings[1] = ClientDomain->Buffer;  // this is null terminated in this case

   if (ERROR_SUCCESS != NetpEventlogWriteEx(
                                KerbEventLogHandle,
                                EVENTLOG_ERROR_TYPE,
                                0,
                                KERBEVT_KRB_PAC_VERIFICATION_FAILURE,
                                2,
                                sizeof(NTSTATUS),
                                Strings,
                                &FailureStatus
                                ))
   {
      D_DebugLog((DEB_ERROR,"Failed to report event: %d. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
   }

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbReportUdpEvent
//
//  Synopsis:   See if its time to log an event.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOLEAN
KerbReportUdpEvent()
{ 
    
    TimeStamp CurrentTime;
    BOOLEAN   fRet = FALSE;
    
    GetSystemTimeAsFileTime((LPFILETIME) &CurrentTime);
    InterlockedIncrement(&KerbUdpTimeoutEvents);
    
    KerbReadLockUdpStats();

    if (( KerbUdpTimeoutEvents > UDPTIMEOUT_LOGGING_THRESHHOLD ) &&
        ( KerbGetTime(CurrentTime) < KerbGetTime( KerbUdpNextUpdate )))
    {
        fRet = TRUE;
        KerbReadToWriteLockUdpStats();
        KerbUdpTimeoutEvents = 0;
    }
    else if ( KerbGetTime( CurrentTime ) > KerbGetTime( KerbUdpNextUpdate ))
    {
        //
        // Time to reset our counter, and our time
        //
        KerbReadToWriteLockUdpStats();
        TimeStamp Delta;
        KerbSetTimeInMinutes(&Delta, UDPTIMEOUT_LOGGING_INTERVAL);
        KerbSetTime(&KerbUdpNextUpdate,(KerbGetTime(CurrentTime) + KerbGetTime(Delta)));
        KerbUdpTimeoutEvents = 0;
    }   
    
    KerbUnlockUdpStats();

    return fRet;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReportMissingRDN.
//
//  Synopsis:   Reports error when we don't have enough information in the 
//              subject RDN.
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbReportMissingRDN()
{  
   NTSTATUS Status;
   
   if (KerbEventLogHandle == NULL)
   {
       Status = KerbInitEventLogHandle();
       if (Status != STATUS_SUCCESS)
       {
           return;
       }
   }

   if (ERROR_SUCCESS != NetpEventlogWriteEx(
                                KerbEventLogHandle,
                                EVENTLOG_ERROR_TYPE,
                                0,
                                KERBEVT_NO_RDN,
                                0,
                                0,
                                NULL,
                                NULL
                                ))
   {
      D_DebugLog((DEB_TRACE,"Failed to report event: %d. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
   }

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbReportTransportError.
//
//  Synopsis:   Reports warning when we're hitting UDP timeouts.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbReportTransportError(
    NTSTATUS        FailureStatus
    )
{  
   NTSTATUS Status;
   
   if (KerbEventLogHandle == NULL)
   {
       Status = KerbInitEventLogHandle();
       if (Status != STATUS_SUCCESS)
       {
           return;
       }
   }

   //
   // Only log every 20th event.
   //
   if (!KerbReportUdpEvent())
   {
       return;
   }
     
   D_DebugLog((DEB_TRACE, "Logging UDP event\n"));

   if (ERROR_SUCCESS != NetpEventlogWriteEx(
                                KerbEventLogHandle,
                                EVENTLOG_WARNING_TYPE,
                                0,
                                KERBEVT_UDP_TIMEOUT,
                                0,
                                sizeof(NTSTATUS),
                                NULL,
                                &FailureStatus
                                ))
   {
      D_DebugLog((DEB_TRACE,"Failed to report event: %d. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
   }

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbResetTransmissionCounter
//
//  Synopsis:   Don't log UDP problems if we have no network, or can't 
//              reach a DC.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbResetTransportCounter()
{ 
    
    KerbReadLockUdpStats();
    if (KerbUdpTimeoutEvents != 0)
    {
        //
        // Avoid taking write lock unless needed.
        //
        D_DebugLog((DEB_ERROR, "Resetting transmission counter. Current (%x)\n", KerbUdpTimeoutEvents));
        KerbReadToWriteLockUdpStats();
        KerbUdpTimeoutEvents = 0;
    }                            
    KerbUnlockUdpStats();
}
//+-------------------------------------------------------------------------
//
//  Function:   KerbReportPkinit
//
//  Synopsis:   Reports errors generated by invalid client certificates
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbReportPkinitError(
    IN ULONG PolicyStatus,
    IN OPTIONAL PCCERT_CONTEXT KdcCert
    )
{
   LPWSTR  Strings[MAX_STRINGS] = {NULL, NULL, NULL};
   WCHAR SubjectName[DNS_MAX_NAME_LENGTH + 1];
   DWORD NameMaxLength = DNS_MAX_NAME_LENGTH + 1;
   DWORD SubjectLength;
   NTSTATUS Status;
   ULONG StringCount = 1;
   
   LPWSTR  MessageBuffer = NULL;
   DWORD   MessageSize = 0;



   if (KerbEventLogHandle == NULL)
   {
       Status = KerbInitEventLogHandle();
       if (Status != STATUS_SUCCESS)
       {
           return;
       }
   }

   MessageSize = FormatMessageW(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                    NULL,
                    PolicyStatus,
                    0,
                    (WCHAR*) &MessageBuffer,
                    MessageSize,
                    NULL
                    );


   if ( MessageSize != 0 )
   {   
       Strings[0] = MessageBuffer;

       if (ARGUMENT_PRESENT(KdcCert))
       {
           RtlZeroMemory(
               SubjectName,
               NameMaxLength
               );

           SubjectLength = CertGetNameString(
               KdcCert,
               CERT_NAME_DNS_TYPE,
               0,
               NULL,
               SubjectName,
               NameMaxLength
               );

           if (SubjectLength != 0)
           {
               Strings[1] = SubjectName;
               StringCount++;
           } 
           else
           {
               Strings[1] = L"<no dns name present>";
               StringCount++;
           }

       }  


       if (ERROR_SUCCESS != NetpEventlogWriteEx(
                                    KerbEventLogHandle,
                                    EVENTLOG_ERROR_TYPE,
                                    0,
                                    (ARGUMENT_PRESENT(KdcCert) ? 
                                     KERBEVT_BAD_KDC_CERTIFICATE : 
                                     KERBEVT_BAD_CLIENT_CERTIFICATE),
                                    StringCount,
                                    sizeof(ULONG),
                                    Strings,
                                    &PolicyStatus
                                    ))
       {
          D_DebugLog((DEB_ERROR,"Failed to report event: %d. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
       }

       LocalFree(MessageBuffer);

   }
   else
   {
       D_DebugLog((DEB_ERROR, "Formatmessage failed %x\n", GetLastError()));
       DsysAssert(FALSE);
   }

                            

}




//+-------------------------------------------------------------------------
//
//  Function:   KerbReportRasCardError
//
//  Synopsis:   Problem w/ *Session && Smartcard error.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//---------------------------------------------------------------------------

VOID
KerbReportRasCardError(
    NTSTATUS CardStatus
    )
{

    NTSTATUS Status;
    if (KerbEventLogHandle == NULL)
    {
        Status = KerbInitEventLogHandle();
        if (Status != STATUS_SUCCESS)
        {
            return;
        }
    } 

    NetpEventlogWriteEx(
        KerbEventLogHandle,
        EVENTLOG_WARNING_TYPE,
        0,
        KERBEVT_RAS_CARD_ERROR,
        0,
        sizeof(NTSTATUS),
        NULL,
        &CardStatus
        ); 
}




//+-------------------------------------------------------------------------
//
//  Function:   KerbReportCredmanError
//
//  Synopsis:   Problem w/ credman creds
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//---------------------------------------------------------------------------

VOID
KerbReportCredmanError(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING Domain,
    IN BOOLEAN Pkinit,
    IN NTSTATUS CardStatus
    )
{

    NTSTATUS Status;
    ULONG StringCount = 1;
    LPWSTR   Strings[3] ={0};
    
    if (KerbEventLogHandle == NULL)
    {
        Status = KerbInitEventLogHandle();
        if (Status != STATUS_SUCCESS)
        {
            return;
        }
    } 

    Strings[0] = UserName->Buffer;

    if (( Domain->Length > 0 ) &&
        ( Domain->Buffer ))
    {
        Strings[0] = Domain->Buffer;
        Strings[1] = L"\\";
        Strings[2] = UserName->Buffer;
        StringCount = 3;
    }                   


    NetpEventlogWriteEx(
        KerbEventLogHandle,
        EVENTLOG_WARNING_TYPE,
        0,
        (Pkinit ? KERBEVT_CREDMAN_CARD_ERROR : KERBEVT_CREDMAN_PWD_ERROR),
        StringCount,
        sizeof(NTSTATUS),
        Strings,
        &CardStatus
        ); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\logonses.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        logonses.cxx
//
// Contents:    Code for managing the global list of logon sessions
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#define LOGONSES_ALLOCATE
#include <kerbp.h>


#ifdef DEBUG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

LONG LogonSessionCount;

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitLogonSessionList
//
//  Synopsis:   Initializes logon session list
//
//  Effects:    allocates a resources
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, other error codes
//              on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbInitLogonSessionList(
    VOID
    )
{
    NTSTATUS Status;


    Status = KerbInitializeList( &KerbLogonSessionList, LS_LIST_LOCK_ENUM );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    KerberosLogonSessionsInitialized = TRUE;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KerbFreeList( &KerbLogonSessionList);

    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function: KerbInitLoopbackDetection
//
//  Synopsis: Initialize the network service session loopback detection
//
//  Effects: Allocates a resources
//
//  Arguments: none
//
//  Requires:
//
//  Returns: STATUS_SUCCESS on success, other error codes on failure
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitLoopbackDetection(
    VOID
    )
{
   NTSTATUS Status = STATUS_SUCCESS;

   InitializeListHead(&KerbSKeyList);

#if DBG

   KerbcSKeyEntries = 0;

#endif

   KerbhSKeyTimerQueue = NULL;

   __try
   {
       SafeInitializeResource(&KerbSKeyLock, LOCAL_LOOPBACK_SKEY_LOCK);
   }
   __except(EXCEPTION_EXECUTE_HANDLER)
   {
       Status = STATUS_INSUFFICIENT_RESOURCES;
   }

   return Status;
}

//+-------------------------------------------------------------------------
//
//  Function: KerbFreeSKeyListAndLock
//
//  Synopsis: Free the network service session key list and its lock
//
//  Effects: Frees a resources
//
//  Arguments: none
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID
KerbFreeSKeyListAndLock(
    VOID
    )
{
   if (SafeAcquireResourceExclusive(&KerbSKeyLock, TRUE))
   {
        for (LIST_ENTRY* pListEntry = KerbSKeyList.Flink;
             pListEntry != &KerbSKeyList;
             pListEntry = pListEntry->Flink)
        {
           KERB_SESSION_KEY_ENTRY* pSKeyEntry = CONTAINING_RECORD(pListEntry, KERB_SESSION_KEY_ENTRY, ListEntry);

           KerbFreeSKeyEntry(pSKeyEntry);
        }
        SafeReleaseResource(&KerbSKeyLock);
   }

   SafeDeleteResource(&KerbSKeyLock);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeLogonSessionList
//
//  Synopsis:   Frees the logon session list
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeLogonSessionList(
    VOID
    )
{
    PKERB_LOGON_SESSION LogonSession;


    if (KerberosLogonSessionsInitialized)
    {

        KerbLockList(&KerbLogonSessionList);

        //
        // Go through the list of logon sessions and dereferences them all
        //

        while (!IsListEmpty(&KerbLogonSessionList.List))
        {
            LogonSession = CONTAINING_RECORD(
                            KerbLogonSessionList.List.Flink,
                            KERB_LOGON_SESSION,
                            ListEntry.Next
                            );

            KerbReferenceListEntry(
                &KerbLogonSessionList,
                &LogonSession->ListEntry,
                TRUE
                );

            KerbDereferenceLogonSession(LogonSession);

        }

        KerbFreeList(&KerbLogonSessionList);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbAllocateLogonSession
//
//  Synopsis:   Allocates a logon session structure
//
//  Effects:    Allocates a logon session, but does not add it to the
//              list of logon sessions
//
//  Arguments:  NewLogonSession - receives a new logon session allocated
//                  with KerbAllocate
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//              STATUS_INSUFFICIENT_RESOURCES if the allocation fails
//
//  Notes:
//
//
//--------------------------------------------------------------------------

// Init flags
#define LSI_EXTRA_CREDS  0x1
#define LSI_SESSION_LOCK 0x2
#define LSI_CREDMAN      0x4

NTSTATUS
KerbAllocateLogonSession(
    PKERB_LOGON_SESSION * NewLogonSession
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_LOGON_SESSION LogonSession;
    ULONG InitStatus = 0;

    LogonSession = (PKERB_LOGON_SESSION) KerbAllocate(
                        sizeof(KERB_LOGON_SESSION)
                        );
    if (LogonSession == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // Set the references to 1 since we are returning a pointer to the
    // logon session
    //

    KerbInitializeListEntry(
        &LogonSession->ListEntry
        );

    //
    // Initialize the ticket caches
    //

    KerbInitTicketCache(&LogonSession->PrimaryCredentials.ServerTicketCache);
    KerbInitTicketCache(&LogonSession->PrimaryCredentials.AuthenticationTicketCache);
    KerbInitTicketCache(&LogonSession->PrimaryCredentials.S4UTicketCache);

    Status = KerbInitializeList(
                 &LogonSession->ExtraCredentials.CredList,
                 LS_EXTRACRED_LOCK_ENUM
                 );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    InitStatus |= LSI_EXTRA_CREDS;

    Status = SafeInitializeCriticalSection(
                 &LogonSession->Lock,
                 LOGON_SESSION_LOCK_ENUM
                 );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    InitStatus |= LSI_SESSION_LOCK;

    Status = KerbInitializeList(
                 &LogonSession->CredmanCredentials,
                 LS_CREDMAN_LOCK_ENUM
                 );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    InitStatus |= LSI_CREDMAN;

    *NewLogonSession = LogonSession;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (InitStatus & LSI_EXTRA_CREDS)
        {
            SafeDeleteCriticalSection(&LogonSession->ExtraCredentials.CredList.Lock);
        }

        if (InitStatus & LSI_SESSION_LOCK)
        {
            SafeDeleteCriticalSection(&LogonSession->Lock);
        }

        if (InitStatus & LSI_CREDMAN)
        {
            SafeDeleteCriticalSection(&LogonSession->CredmanCredentials.Lock);
        }

        KerbFree(LogonSession);
    }

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInsertLogonSession
//
//  Synopsis:   Inserts a logon session into the list of logon sessions
//
//  Effects:    bumps reference count on logon session
//
//  Arguments:  LogonSession - LogonSession to insert
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS always
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbInsertLogonSession(
    IN PKERB_LOGON_SESSION LogonSession
    )
{
    KerbInsertListEntry(
        &LogonSession->ListEntry,
        &KerbLogonSessionList
        );
#if DBG
    InterlockedIncrement(&LogonSessionCount);
#endif

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceLogonSession
//
//  Synopsis:   Locates a logon session from the logon ID and references it
//
//  Effects:    Increments reference count and possible unlinks it from list
//
//  Arguments:  LogonId - LogonId of logon session to locate
//              RemoveFromList - If TRUE, logon session will be delinked
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


PKERB_LOGON_SESSION
KerbReferenceLogonSession(
    IN PLUID LogonId,
    IN BOOLEAN RemoveFromList
    )
{
    PLIST_ENTRY ListEntry;
    PKERB_LOGON_SESSION LogonSession = NULL;
    BOOLEAN Found = FALSE;

    KerbLockList(&KerbLogonSessionList);

    //
    // Go through the list of logon sessions looking for the correct
    // LUID
    //

    for (ListEntry = KerbLogonSessionList.List.Flink ;
         ListEntry !=  &KerbLogonSessionList.List ;
         ListEntry = ListEntry->Flink )
    {
        LogonSession = CONTAINING_RECORD(ListEntry, KERB_LOGON_SESSION, ListEntry.Next);
        if (RtlEqualLuid(
                &LogonSession->LogonId,
                LogonId
                ) )
        {
            D_DebugLog((DEB_TRACE_LSESS, "Referencing session 0x%x:0x%x, Remove=%d\n",
                LogonSession->LogonId.HighPart,
                LogonSession->LogonId.LowPart,
                RemoveFromList
                ));

            KerbReferenceListEntry(
                &KerbLogonSessionList,
                &LogonSession->ListEntry,
                RemoveFromList
                );
            Found = TRUE;

            break;
        }

    }
    if (!Found)
    {
        LogonSession = NULL;
    }

    KerbUnlockList(&KerbLogonSessionList);


    return(LogonSession);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeLogonSession
//
//  Synopsis:   Frees a logon session and all associated data
//
//  Effects:
//
//  Arguments:  LogonSession
//
//  Requires:   the logon session must already be unlinked
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbFreeLogonSession(
    IN PKERB_LOGON_SESSION LogonSession
    )
{
    DsysAssert((LogonSession->ListEntry.Next.Flink == NULL) &&
           (LogonSession->ListEntry.Next.Blink == NULL));

    // Don't purge creds, as there isn't a ref-count for the credential in
    // the logon session list,and there might be outstanding handles to your
    // credentials in a local system process.
    //KerbPurgeCredentials(&LogonSession->SspCredentials);
    KerbPurgeTicketCache(&LogonSession->PrimaryCredentials.ServerTicketCache);
    KerbPurgeTicketCache(&LogonSession->PrimaryCredentials.AuthenticationTicketCache);
    KerbPurgeTicketCache(&LogonSession->PrimaryCredentials.S4UTicketCache);

    if (LogonSession->PrimaryCredentials.Passwords != NULL)
    {
        KerbFreeStoredCred(LogonSession->PrimaryCredentials.Passwords);
    }

    if (LogonSession->PrimaryCredentials.OldPasswords != NULL)
    {
        KerbFreeStoredCred(LogonSession->PrimaryCredentials.OldPasswords);
    }

    KerbFreeString(&LogonSession->PrimaryCredentials.UserName);
    KerbFreeString(&LogonSession->PrimaryCredentials.DomainName);

    if (LogonSession->PrimaryCredentials.ClearPassword.Buffer != NULL)
    {
        RtlZeroMemory(
            LogonSession->PrimaryCredentials.ClearPassword.Buffer,
            LogonSession->PrimaryCredentials.ClearPassword.Length
            );
        KerbFreeString(&LogonSession->PrimaryCredentials.ClearPassword);

    }

    KerbFreeExtraCredList(&LogonSession->ExtraCredentials);

    if (LogonSession->PrimaryCredentials.PublicKeyCreds != NULL)
    {

#ifndef WIN32_CHICAGO
        KerbReleasePkCreds(
            LogonSession,
            NULL,
            FALSE
            );
#endif // WIN32_CHICAGO
    }

    SafeDeleteCriticalSection(&LogonSession->CredmanCredentials.Lock);
    SafeDeleteCriticalSection(&LogonSession->ExtraCredentials.CredList.Lock);
    SafeDeleteCriticalSection(&LogonSession->Lock);

    KerbFree(LogonSession);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceLogonSession
//
//  Synopsis:   Dereferences a logon session - if reference count goes
//              to zero it frees the logon session
//
//  Effects:    decrements reference count
//
//  Arguments:  LogonSession - Logon session to dereference
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbDereferenceLogonSession(
    IN PKERB_LOGON_SESSION LogonSession
    )
{
    if (KerbDereferenceListEntry(
            &LogonSession->ListEntry,
            &KerbLogonSessionList
            ) )
    {
        D_DebugLog((DEB_TRACE_LSESS, "Dereferencing and freeing logon session 0x%x:0x%x\n",
            LogonSession->LogonId.HighPart,
            LogonSession->LogonId.HighPart
            ));
        KerbFreeLogonSession( LogonSession );

#if DBG
        InterlockedDecrement(&LogonSessionCount);
#endif

    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceLogonSessionByPointer
//
//  Synopsis:   References a LogonSession by the LogonSession pointer itself.
//
//  Effects:    Increments reference count and possible unlinks it from list
//
//  Arguments:  LogonSession - The LogonSession to reference.
//              RemoveFromList - If TRUE, LogonSession will be delinked
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbReferenceLogonSessionByPointer(
    IN PKERB_LOGON_SESSION LogonSession,
    IN BOOLEAN RemoveFromList
    )
{

    KerbLockList(&KerbLogonSessionList);

    KerbReferenceListEntry(
        &KerbLogonSessionList,
        &LogonSession->ListEntry,
        RemoveFromList
        );

    KerbUnlockList(&KerbLogonSessionList);
 
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetSaltForEtype
//
//  Synopsis:   Looks in the list of salt for an etype & returns it if found
//
//  Effects:    Allocate the output string
//
//  Arguments:  EncryptionType - etype searched for
//              EtypeInfo - List of etypes
//              DefaultSalt - salt to use if none provided
//              Salt - receives the salt to use. On error, no key should be
//                      generated.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetSaltForEtype(
    IN ULONG EncryptionType,
    IN OPTIONAL PKERB_ETYPE_INFO EtypeInfo,
    IN OPTIONAL PKERB_STORED_CREDENTIAL PasswordList,
    IN PUNICODE_STRING DefaultSalt,
    OUT PUNICODE_STRING SaltToUse
    )
{
    PKERB_ETYPE_INFO ListEntry;
    STRING TempString;

    //
    // If there is no etype, just use the default
    //

    if (EtypeInfo == NULL)
    {
        //
        // If we have a password list, get the salt from that.
        //

        if (ARGUMENT_PRESENT(PasswordList))
        {
            ULONG Index;
            for (Index = 0; Index < PasswordList->CredentialCount ; Index++ )
            {
                if (PasswordList->Credentials[Index].Key.keytype == (int) EncryptionType)
                {
                    if (PasswordList->Credentials[Index].Salt.Buffer != NULL)
                    {
                        return(KerbDuplicateString(
                                SaltToUse,
                                &PasswordList->Credentials[Index].Salt
                                ));
                    }
                    else if (PasswordList->DefaultSalt.Buffer != NULL)
                    {
                        return(KerbDuplicateString(
                                SaltToUse,
                                &PasswordList->DefaultSalt
                                ));
                    }
                    break;
                }
            }
        }

        //
        // otherise return the default
        //

        return(KerbDuplicateString(
                    SaltToUse,
                    DefaultSalt
                    ));
    }

    //
    // Otherwise, only return salt if the etype is in the list.
    //

    for (ListEntry = EtypeInfo; ListEntry != NULL ; ListEntry = ListEntry->next )
    {
        //
        // First check for the encryption type we want.
        //

        if (ListEntry->value.encryption_type == (int) EncryptionType)
        {

            //
            // if it has salt, return that.
            //

            if ((ListEntry->value.bit_mask & salt_present) != 0)
            {
                KERBERR KerbErr;
                TempString.Buffer = (PCHAR) ListEntry->value.salt.value;
                TempString.Length = (USHORT) ListEntry->value.salt.length;
                TempString.MaximumLength = (USHORT) ListEntry->value.salt.length;

                //
                // validate inputs don't overflow USHORT for MaximumLength.
                //
                if ( TempString.Length > KERB_MAX_STRING )
                {
                    return STATUS_NAME_TOO_LONG;
                }

                KerbErr = KerbStringToUnicodeString(
                            SaltToUse,
                            &TempString
                            );
                return(KerbMapKerbError(KerbErr));
            }
            else
            {
                //
                // Otherwise return the default
                //

                return(KerbDuplicateString(
                        SaltToUse,
                        DefaultSalt
                        ));
            }
        }
    }
    return(STATUS_OBJECT_NAME_NOT_FOUND);
}





//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeStoredCred
//
//  Synopsis:   Frees a KERB_STORED_CREDENTIAL
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeStoredCred(
    IN PKERB_STORED_CREDENTIAL StoredCred
    )
{
    USHORT Index;
    for (Index = 0; Index < StoredCred->CredentialCount + StoredCred->OldCredentialCount ; Index++ )
    {
        if (StoredCred->Credentials[Index].Salt.Buffer != NULL)
        {
            KerbFreeString(&StoredCred->Credentials[Index].Salt);
        }
    }
    KerbFree(StoredCred);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildPasswordList
//
//  Synopsis:   Builds a list of passwords for a logged on user
//
//  Effects:    allocates memory
//
//  Arguments:  Password - clear or OWF password
//              PasswordFlags - Indicates whether the password is clear or OWF
//              PasswordList - Receives new password list
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildPasswordList(
    IN PUNICODE_STRING Password,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DomainName,
    IN PKERB_ETYPE_INFO SuppliedSalt,
    IN PKERB_STORED_CREDENTIAL OldPasswords,
    IN OPTIONAL PUNICODE_STRING PrincipalName,
    IN KERB_ACCOUNT_TYPE AccountType,
    IN ULONG PasswordFlags,
    OUT PKERB_STORED_CREDENTIAL * PasswordList
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG CryptTypes[KERB_MAX_CRYPTO_SYSTEMS];
    ULONG CryptCount = 0 ;
    PKERB_STORED_CREDENTIAL Credentials = NULL;
    UNICODE_STRING KeySalt = {0};
    UNICODE_STRING DefaultSalt = {0};
    ULONG CredentialSize = 0;
    ULONG CredentialCount = 0;
    PCRYPTO_SYSTEM CryptoSystem;
    ULONG Index, CredentialIndex = 0;
    PUCHAR Base;
    ULONG Offset;
    KERBERR KerbErr;

    *PasswordList = NULL;

    //
    // If we were passed an OWF, then there is just one password
    //

    if ((PasswordFlags & PRIMARY_CRED_OWF_PASSWORD) != 0)
    {
        CredentialSize += Password->Length + sizeof(KERB_KEY_DATA);
        CredentialCount++;
#ifndef DONT_SUPPORT_OLD_TYPES
        CredentialSize += Password->Length + sizeof(KERB_KEY_DATA);
        CredentialCount++;
#endif
    }
    else if ((PasswordFlags & PRIMARY_CRED_CLEAR_PASSWORD) != 0)
    {

        //
        // Build the key salt.
        //

        KerbErr = KerbBuildKeySalt(
                    DomainName,
                    (ARGUMENT_PRESENT(PrincipalName) && PrincipalName->Length != 0) ? PrincipalName : UserName,
                    (ARGUMENT_PRESENT(PrincipalName) && PrincipalName->Length != 0) ? UnknownAccount : AccountType,
                    &DefaultSalt
                    );
        if (!KERB_SUCCESS(KerbErr))
        {
            D_DebugLog((DEB_ERROR, "Can't build salt. Might as well fail here\n"));
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }

        //
        // For a cleartext password, build a list of encryption types and
        // create a key for each one
        //

        Status = CDBuildIntegrityVect(
                    &CryptCount,
                    CryptTypes
                    );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Can't build a list of encryption types: 0x%x.\n",Status));
            goto Cleanup;
        }
        DsysAssert(CryptCount <= KERB_MAX_CRYPTO_SYSTEMS);

        //
        // Now find the size of the key for each crypto system
        //

        for (Index = 0; Index < CryptCount; Index++ )
        {
            Status = CDLocateCSystem(
                        CryptTypes[Index],
                        &CryptoSystem
                        );
            if (!NT_SUCCESS(Status))
            {
                D_DebugLog((DEB_ERROR,"Failed to load %d crypt system: 0x%x.\n",CryptTypes[Index],Status));
                goto Cleanup;
            }

            if (((CryptoSystem->Attributes & CSYSTEM_USE_PRINCIPAL_NAME) == 0) ||
                (DefaultSalt.Buffer != NULL ))
            {
                CredentialSize += sizeof(KERB_KEY_DATA) + CryptoSystem->KeySize;
                CredentialCount++;
            }
        }
    }
    else
    {
        //
        // No flags set, so nothing we can do.
        //

        D_DebugLog((DEB_TRACE, "KerbBuildPasswordList assword passed but no flags set, do nothing\n"));
        return(STATUS_SUCCESS);
    }

#ifdef notdef
    //
    // Add the space for the salt
    //

    CredentialSize += DefaultSalt.Length;

#endif

    //
    // Add in the size of the base structure
    //

    CredentialSize += FIELD_OFFSET(KERB_STORED_CREDENTIAL,Credentials);
    Credentials = (PKERB_STORED_CREDENTIAL) KerbAllocate(CredentialSize);
    if (Credentials == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Fill in the base structure
    //

    Credentials->Revision = KERB_PRIMARY_CRED_REVISION;
    Credentials->Flags = 0;
    Credentials->OldCredentialCount = 0;


    //
    // Now fill in the individual keys
    //

    Base = (PUCHAR) Credentials;
    Offset = FIELD_OFFSET(KERB_STORED_CREDENTIAL,Credentials) +
                CredentialCount * sizeof(KERB_KEY_DATA);

#ifdef notdef
    //
    // Add the default salt
    //

    Credentials->DefaultSalt = DefaultSalt;
    Credentials->DefaultSalt.Buffer = (LPWSTR) Base+Offset;

    RtlCopyMemory(
        Base + Offset,
        DefaultSalt.Buffer,
        DefaultSalt.Length
        );
    Offset += Credentials->DefaultSalt.Length;

#endif

    if ((PasswordFlags & PRIMARY_CRED_OWF_PASSWORD) != 0)
    {
        RtlCopyMemory(
            Base + Offset,
            Password->Buffer,
            Password->Length
            );

        if (!KERB_SUCCESS(KerbCreateKeyFromBuffer(
                            &Credentials->Credentials[CredentialIndex].Key,
                            Base + Offset,
                            Password->Length,
                            KERB_ETYPE_RC4_HMAC_NT
                            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        Base += Password->Length;
        CredentialIndex++;
#ifndef DONT_SUPPORT_OLD_TYPES

        RtlCopyMemory(
            Base + Offset,
            Password->Buffer,
            Password->Length
            );

        if (!KERB_SUCCESS(KerbCreateKeyFromBuffer(
                            &Credentials->Credentials[CredentialIndex].Key,
                            Base + Offset,
                            Password->Length,
                            (ULONG) KERB_ETYPE_RC4_HMAC_OLD
                            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        Base += Password->Length;
        CredentialIndex++;
#endif
    }
    else if ((PasswordFlags & PRIMARY_CRED_CLEAR_PASSWORD) != 0)
    {
        KERB_ENCRYPTION_KEY TempKey = {0};

        //
        // Now find the size of the key for each crypto system
        //

        for (Index = 0; Index < CryptCount; Index++ )
        {
            CryptoSystem = NULL;
            Status = CDLocateCSystem(
                         CryptTypes[Index],
                         &CryptoSystem
                         );

            if (!NT_SUCCESS(Status))
            {
                Status = STATUS_SUCCESS;
                continue;
            }

            KerbFreeString(&KeySalt);

            Status = KerbGetSaltForEtype(
                        CryptTypes[Index],
                        SuppliedSalt,
                        OldPasswords,
                        &DefaultSalt,
                        &KeySalt
                        );

            if (!NT_SUCCESS(Status))
            {
                if ( Status == STATUS_OBJECT_NAME_NOT_FOUND)
                {
                    Status = STATUS_SUCCESS;
                    continue;
                }  

                goto Cleanup;
            }

            //
            // If we don't have salt, skip this crypt system
            //

            if (((CryptoSystem->Attributes & CSYSTEM_USE_PRINCIPAL_NAME) != 0) &&
                (KeySalt.Buffer == NULL ))
            {
                continue;
            }

            KerbErr = KerbHashPasswordEx(
                        Password,
                        &KeySalt,
                        CryptTypes[Index],
                        &TempKey
                        );


            if (!KERB_SUCCESS(KerbErr))
            {
                //
                // It is possible that the password can't be used for every
                // encryption scheme, so skip failures
                //
                D_DebugLog((DEB_WARN, "Failed to hash pasword %wZ with type 0x%x\n",
                    Password,CryptTypes[Index] ));

                if ( CryptTypes[Index] != KERB_ETYPE_RC4_HMAC_NT ) // RC4_HMAC_NT should not fail
                {
                    Status = STATUS_SUCCESS;
                    continue;
                }
                
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            DsysAssert(CryptoSystem->KeySize >= TempKey.keyvalue.length);

            //
            // Copy the salt and key data into the credentials
            //

            Credentials->Credentials[CredentialIndex].Salt = KeySalt;

            RtlInitUnicodeString(
                &KeySalt,
                0
                );
            Credentials->Credentials[CredentialIndex].Key = TempKey;
            Credentials->Credentials[CredentialIndex].Key.keyvalue.value = Base + Offset;

            RtlCopyMemory(
                Base + Offset,
                TempKey.keyvalue.value,
                TempKey.keyvalue.length
                );

            Offset += TempKey.keyvalue.length;

            KerbFreeKey(
                &TempKey
                );

            CredentialIndex++;
        }

    }
    Credentials->CredentialCount = (USHORT) CredentialIndex;
    *PasswordList = Credentials;
    Credentials = NULL;

Cleanup:
    if (Credentials != NULL)
    {
         KerbFreeStoredCred(Credentials);
    }
    KerbFreeString(&KeySalt);
    KerbFreeString(&DefaultSalt);

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbReplacePasswords
//
//  Synopsis:   Validate supplied credentials == default credentials in special 
//              case.
//
//  Effects:    Replaces passwords if they're different than defaulted ones.
//
//  Arguments:  Current - KERB_CREDENTIAL passwords
//              New     - Default logon session passwords
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbReplacePasswords(
    IN PKERB_PRIMARY_CREDENTIAL Current,
    IN PKERB_PRIMARY_CREDENTIAL New
    )
{
    PKERB_ENCRYPTION_KEY CurrentKey = NULL;
    PKERB_ENCRYPTION_KEY NewKey = NULL;
    PKERB_STORED_CREDENTIAL NewPasswords = NULL;
    ULONG PasswordSize = 0;
    ULONG Index;
    PBYTE Where;
    

    DsysAssert(Current->Passwords);
    DsysAssert(New->Passwords);

    if ( Current->Passwords != NULL )
    {
        //
        // First off, compare the RC4 HMAC OWF - if its equal, then the other keys are equal.
        // Note - for DES / AES, this might not be the case, but assume that will be fixed up 
        // when we re-derive the pwd based on etype info.
        //
        CurrentKey = KerbGetKeyFromList( Current->Passwords, KERB_ETYPE_RC4_HMAC_NT );
        
        if (CurrentKey == NULL )
        {
            return STATUS_SUCCESS;
        }
    
        NewKey = KerbGetKeyFromList( New->Passwords, KERB_ETYPE_RC4_HMAC_NT );
        if ( NewKey == NULL )
        {
            return STATUS_SUCCESS;
        }                         
    
        DsysAssert( CurrentKey->keyvalue.length == NewKey->keyvalue.length );
        
        if (RtlEqualMemory( CurrentKey->keyvalue.value, NewKey->keyvalue.value, NewKey->keyvalue.length ))
        {
            return STATUS_SUCCESS;
        } 
    }

    DebugLog((DEB_ERROR, "Replacing keys\n"));

    //
    // Walk the credentials, and whackem.
    //

    PasswordSize = sizeof(KERB_STORED_CREDENTIAL) - (sizeof(KERB_KEY_DATA) * ANYSIZE_ARRAY) + (New->Passwords->CredentialCount * sizeof(KERB_KEY_DATA));

    for (Index = 0; Index < New->Passwords->CredentialCount ; Index++ )
    {
        PasswordSize += New->Passwords->Credentials[Index].Key.keyvalue.length;
    }

    NewPasswords = (PKERB_STORED_CREDENTIAL) KerbAllocate(PasswordSize);

    if (NewPasswords == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    NewPasswords->Revision = KERB_PRIMARY_CRED_REVISION;
    NewPasswords->Flags = 0;
    NewPasswords->OldCredentialCount = 0;

    //
    // Zero the salt so we don't accidentally re-use it.
    //

    RtlInitUnicodeString(
        &NewPasswords->DefaultSalt,
        NULL
        );


    NewPasswords->CredentialCount = New->Passwords->CredentialCount;

    Where = (PUCHAR) &NewPasswords->Credentials[NewPasswords->CredentialCount];

    //
    // Copy all the old passwords.
    //
    for (Index = 0;
         Index < (USHORT) (NewPasswords->CredentialCount) ;
         Index++ )
    {
        RtlInitUnicodeString(
            &NewPasswords->Credentials[Index].Salt,
            NULL
            );

        NewPasswords->Credentials[Index].Key = New->Passwords->Credentials[Index].Key;
        NewPasswords->Credentials[Index].Key.keyvalue.value = Where;

        RtlCopyMemory(
            Where,
            New->Passwords->Credentials[Index].Key.keyvalue.value,
            New->Passwords->Credentials[Index].Key.keyvalue.length
            );

        Where += NewPasswords->Credentials[Index].Key.keyvalue.length;

    }

    if ( Current->Passwords != NULL )
    {
        KerbFreeStoredCred( Current->Passwords );
    }

    Current->Passwords = NewPasswords;

    return STATUS_SUCCESS;

}   




//+-------------------------------------------------------------------------
//
//  Function:   KerbCreatePrimaryCredentials
//
//  Synopsis:   Fills in a new primary credentials structure
//
//  Effects:    allocates space for the user name and domain name
//
//  Arguments:  AccountName - Account name of this user
//              DomainName - domain name of this user
//              Password - Optionally contains a kereros hash of the password
//                      Note: if present, it is used and zeroed out.
//              PrimaryCredentials - contains structure to fill in.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreatePrimaryCredentials(
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING DomainName,
    IN OPTIONAL PUNICODE_STRING Password,
    IN OPTIONAL PUNICODE_STRING OldPassword,
    IN ULONG PasswordFlags,
    IN PLUID LogonId,
    OUT PKERB_PRIMARY_CREDENTIAL PrimaryCredentials
    )
{
    NTSTATUS Status;
    LUID SystemLogonId = SYSTEM_LUID;
    LUID NetworkServiceLogonId = NETWORKSERVICE_LUID;
    BOOLEAN IsMachineAccountLogon = FALSE;
    BOOLEAN IsPersonal = KerbRunningPersonal();


    //
    // We can only accept account name / service name / pwds of max_unicode_length
    // -1, because we NULL terminate these for later DES derivation, and the
    // input buffers from LogonUser may not be NULL terminated.
    //
    if ((AccountName->Length > KERB_MAX_UNICODE_STRING) ||
        (DomainName->Length > KERB_MAX_UNICODE_STRING))

    {
        return (STATUS_NAME_TOO_LONG);
    }

    if ((ARGUMENT_PRESENT(Password) && (Password->Length > KERB_MAX_UNICODE_STRING)) ||
        (ARGUMENT_PRESENT(OldPassword) && (OldPassword->Length > KERB_MAX_UNICODE_STRING)))
    {
        return (STATUS_NAME_TOO_LONG);
    }

    if (RtlEqualLuid(
            &SystemLogonId,
            LogonId)
        || RtlEqualLuid(
                &NetworkServiceLogonId, 
                LogonId))
    {
        IsMachineAccountLogon = TRUE;
    }

    Status = KerbDuplicateString(
                &PrimaryCredentials->UserName,
                AccountName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // The system logon always comes in uppercase, so lowercase it.
    //

    if (IsMachineAccountLogon)
    {
        RtlDowncaseUnicodeString(
            &PrimaryCredentials->UserName,
            &PrimaryCredentials->UserName,
            FALSE
            );
    }

    Status = KerbDuplicateString(
                &PrimaryCredentials->DomainName,
                DomainName
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    //  Neuter personal so it can't act as a server,
    //  even if someone has hacked in a machine pwd.
    //
    if (IsMachineAccountLogon && IsPersonal)
    {
        PrimaryCredentials->Passwords = NULL;
        PrimaryCredentials->OldPasswords = NULL;
        D_DebugLog((DEB_WARN, "Running personal - No kerberos for SYSTEM LUID\n"));
    }
    else
    {

        Status = KerbBuildPasswordList(
                        Password,
                        &PrimaryCredentials->UserName,
                        &PrimaryCredentials->DomainName,
                        NULL,                                   // no supplied salt
                        NULL,                                   // no old paswords
                        NULL,                                   // no principal name
                        IsMachineAccountLogon ? MachineAccount : UserAccount,
                        PasswordFlags,
                        &PrimaryCredentials->Passwords
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if (ARGUMENT_PRESENT(OldPassword) && (OldPassword->Buffer != NULL))
        {
            Status = KerbBuildPasswordList(
                        OldPassword,
                        &PrimaryCredentials->UserName,
                        &PrimaryCredentials->DomainName,
                        NULL,                           // no supplied salt
                        PrimaryCredentials->Passwords,
                        NULL,                           // no principal name
                        IsMachineAccountLogon ? MachineAccount : UserAccount,
                        PasswordFlags,
                        &PrimaryCredentials->OldPasswords
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }

        //
        // Store the clear password if necessary
        //

        if ((PasswordFlags & PRIMARY_CRED_CLEAR_PASSWORD) != 0)
        {
            Status = KerbDuplicatePassword(
                        &PrimaryCredentials->ClearPassword,
                        Password
                        );
            if (NT_SUCCESS(Status))
            {
                KerbHidePassword(
                    &PrimaryCredentials->ClearPassword
                    );
            }
        }
    }

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KerbFreeString(&PrimaryCredentials->UserName);
        KerbFreeString(&PrimaryCredentials->DomainName);
        if (PrimaryCredentials->ClearPassword.Buffer != NULL)
        {
            RtlZeroMemory(
                PrimaryCredentials->ClearPassword.Buffer,
                PrimaryCredentials->ClearPassword.Length
                );
            KerbFreeString(&PrimaryCredentials->ClearPassword);
        }

    }
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbChangeCredentialsPassword
//
//  Synopsis:   Changes the password for a KERB_PRIMARY_CREDENTIALS -
//              copies the current password into the old password field
//              and then sets the new pasword as the primary password.
//              If no new password is provided, it just fixes up the salt.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbChangeCredentialsPassword(
    IN PKERB_PRIMARY_CREDENTIAL PrimaryCredentials,
    IN OPTIONAL PUNICODE_STRING NewPassword,
    IN OPTIONAL PKERB_ETYPE_INFO EtypeInfo,
    IN KERB_ACCOUNT_TYPE AccountType,
    IN ULONG PasswordFlags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_STORED_CREDENTIAL Passwords = NULL;


    //
    // LogonSession no password was supplied, use the cleartext password
    //

    if (!ARGUMENT_PRESENT(NewPassword) && (PrimaryCredentials->ClearPassword.Buffer == NULL))
    {
        D_DebugLog((DEB_ERROR,"Can't change password without new password\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    if (PrimaryCredentials->ClearPassword.Buffer != NULL)
    {
        KerbRevealPassword(&PrimaryCredentials->ClearPassword);
    }

    Status = KerbBuildPasswordList(
                (ARGUMENT_PRESENT(NewPassword) ? NewPassword : &PrimaryCredentials->ClearPassword),
                &PrimaryCredentials->UserName,
                &PrimaryCredentials->DomainName,
                EtypeInfo,
                PrimaryCredentials->Passwords,
                NULL,                   // no principal name
                AccountType,
                PasswordFlags,
                &Passwords
                );
    if (!NT_SUCCESS(Status))
    {
        if (PrimaryCredentials->ClearPassword.Buffer != NULL)
        {
            KerbHidePassword(&PrimaryCredentials->ClearPassword);
        }
    }
    else if ((PasswordFlags & PRIMARY_CRED_CLEAR_PASSWORD) != 0)
    {
        KerbFreeString(&PrimaryCredentials->ClearPassword);

        Status = KerbDuplicatePassword(
                    &PrimaryCredentials->ClearPassword,
                    NewPassword
                    );
        if (NT_SUCCESS(Status))
        {
            KerbHidePassword(
                &PrimaryCredentials->ClearPassword
                );
        }
    }
    else
    {
        KerbHidePassword(
            &PrimaryCredentials->ClearPassword
            );
    }


    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Move the current password to the old password
    //

    if (ARGUMENT_PRESENT(NewPassword))
    {
        if (PrimaryCredentials->OldPasswords != NULL)
        {
            KerbFreeStoredCred(PrimaryCredentials->OldPasswords);
        }
        PrimaryCredentials->OldPasswords = PrimaryCredentials->Passwords;
    }
    else
    {
        KerbFreeStoredCred(PrimaryCredentials->Passwords);
    }

    PrimaryCredentials->Passwords = Passwords;
    Passwords = NULL;

Cleanup:
    if (Passwords != NULL)
    {
        MIDL_user_free(Passwords);
    }
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateLogonSession
//
//  Synopsis:   Allocates a logon session, fills in the various fields,
//              and inserts it on the logon session list
//
//  Effects:
//
//  Arguments:  LogonId - LogonId for new logon session
//              AccountName - Account name of user
//              Domain Name - Domain name of user
//              Password - password for user
//              OldPassword - Old password for user, if present
//              LogonType - Type of logon
//              NewLogonSession - Receives new logon session (referenced)
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateLogonSession(
    IN PLUID LogonId,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING DomainName,
    IN OPTIONAL PUNICODE_STRING Password,
    IN OPTIONAL PUNICODE_STRING OldPassword,
    IN ULONG PasswordFlags,
    IN ULONG LogonSessionFlags,
    IN BOOLEAN AllowDuplicate,
    OUT PKERB_LOGON_SESSION * NewLogonSession
    )
{
    PKERB_LOGON_SESSION LogonSession = NULL;
    NTSTATUS Status;

    D_DebugLog((DEB_TRACE_LSESS, "Creating logon session for 0x%x:0x%x\n",
        LogonId->HighPart, LogonId->LowPart));

    *NewLogonSession = NULL;

    //
    // Check for a logon session with the same id
    //

    LogonSession = KerbReferenceLogonSession(
                        LogonId,
                        FALSE           // don't unlink
                        );
    if (LogonSession != NULL)
    {
        //
        // We already have this logon session, so don't create another one.
        // Up the refcount on the logon session, or simply fail if duplicates
        // aren't allowed...
        //
        if ( AllowDuplicate )
        {
            *NewLogonSession = LogonSession;
            return (STATUS_OBJECT_NAME_EXISTS);
        }
        else
        {
            KerbDereferenceLogonSession(LogonSession);
            return(STATUS_OBJECT_NAME_EXISTS);
        }
    }



    //
    // Allocate the new logon session
    //

    Status = KerbAllocateLogonSession( &LogonSession );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Fill in the logon session components
    //

    LogonSession->LogonId = *LogonId;
    LogonSession->Lifetime = KerbGlobalWillNeverTime;


    //
    // If the domain name is equal to the computer name then the logon was
    //  local.
    //

#ifndef WIN32_CHICAGO
    KerbGlobalReadLock();

    if (RtlEqualDomainName(
            DomainName,
            &KerbGlobalMachineName
            ))
    {
        LogonSession->LogonSessionFlags |= KERB_LOGON_LOCAL_ONLY;
    }

    KerbGlobalReleaseLock();
#endif // WIN32_CHICAGO

    Status = KerbCreatePrimaryCredentials(
                AccountName,
                DomainName,
                Password,
                OldPassword,
                PasswordFlags,
                LogonId,
                &LogonSession->PrimaryCredentials
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    LogonSession->LogonSessionFlags |= ( KERB_LOGON_DEFERRED | LogonSessionFlags);

    if ((( LogonSessionFlags & KERB_LOGON_SMARTCARD) == 0) &&
        (( LogonSession->PrimaryCredentials.Passwords == NULL) ||
         ( LogonSession->PrimaryCredentials.Passwords->CredentialCount == 0)))
    {
        LogonSession->LogonSessionFlags |= KERB_LOGON_NO_PASSWORD;
    }


    //
    // Now that the logon session structure is filled out insert it
    // into the list. After this you need to hold the logon session lock
    // to read or write this logon session.
    //

    Status = KerbInsertLogonSession(LogonSession);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *NewLogonSession = LogonSession;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (NULL != LogonSession)
        {
            KerbFreeLogonSession(LogonSession); // not yet linked...
        }
    }
    return(Status);

}


#ifndef WIN32_CHICAGO




//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateDummyLogonSession
//
//  Synopsis:   Creates a logon session from scratch - likely created
//              from another package so call the lsa.
//
//  Effects:
//
//  Arguments:  LogonId - Logon id for the logon session
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCreateDummyLogonSession(
    IN PLUID LogonId,
    IN OUT PKERB_LOGON_SESSION * NewLogonSession,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN BOOLEAN Impersonating,
    IN OPTIONAL HANDLE hProcess
    )
{
    NTSTATUS            Status;
    PKERB_LOGON_SESSION LogonSession = NULL;
    UNICODE_STRING      TmpRealmName = {0};
    UNICODE_STRING      RealmName = {0};
    UNICODE_STRING      TmpUserName  = {0};
    UNICODE_STRING      UserName  = {0};
    BOOLEAN             OkForProxy, UseSamName = FALSE;
    LUID                BaseLogonId;
    LUID                AnonymousLogonId = ANONYMOUS_LOGON_LUID;
    ULONG               LogonSessionFlags = KERB_LOGON_DUMMY_SESSION;

    *NewLogonSession = NULL;


    if (!RtlEqualLuid(LogonId, &AnonymousLogonId))
    {
        //
        // Get the user name / dns domain name from the lsa.  If
        // we fail this call, the logon session is of unknown origin,
        // and we'll need to assert (where did it come from?)
        //

        Status = I_LsaIGetNameFromLuid(
            LogonId,
            NameSamCompatible,
            TRUE, // local only
            &TmpUserName
            );

        if (!NT_SUCCESS(Status))
        {
            goto cleanup;
        }

        Status = I_LsaIGetNameFromLuid(
            LogonId,
            NameDnsDomain,
            TRUE, // local only
            &TmpRealmName
            );

        if (!NT_SUCCESS(Status))
        {
            //
            // We may not have a dns domain.  In that case,
            // use the first part of the sam name.
            //
            UseSamName = TRUE;
        }
        else
        {
            RealmName = TmpRealmName;
        }

        //
        // No method for "sam" name, so lets split it up.
        //
        for (USHORT i = 0; i <= TmpUserName.Length; i++)
        {
            if (TmpUserName.Buffer[i] == L'\\')
            {
                if ( UseSamName )
                {
                    TmpUserName.Buffer[i] = L'\0';
                    RtlInitUnicodeString(
                        &RealmName,
                        TmpUserName.Buffer
                        );
                }

                RtlInitUnicodeString(
                    &UserName,
                    (PWSTR) &TmpUserName.Buffer[++i]
                    );
                break;
            }
        }

        //
        // If we haven't gotten a realm yet, we're hosed.  This should *never* happen.
        //
        if (RealmName.Length == 0)
        {
            Status = STATUS_NO_SUCH_USER;
            DsysAssert(FALSE);
            goto cleanup;
        }
    }
    else // anonymous does not have a lsap logon session
    {
        //
        // no need to look up anonymous logon, since anonymous logon with
        // no explicit cred supplied will fail with SEC_E_UNKNOWN_CREDENTIALS
        //

        RtlInitUnicodeString(&UserName, L"ANONYMOUS LOGON");
        RtlInitUnicodeString(&RealmName, L"NT AUTHORITY");
        LogonSessionFlags |= KERB_LOGON_LOCAL_ONLY; // anonymous is local well-known principal
    }

    //
    // Create a logon session.
    // If it was created on us during above processing, use that one.
    //
    Status = KerbCreateLogonSession(
                LogonId,
                &UserName,
                &RealmName,
                NULL,
                NULL,
                0,
                LogonSessionFlags,
                TRUE,                       // Allow duplicate.
                &LogonSession
                );

    if (!NT_SUCCESS(Status))
    {
        //
        // Already created - we're ok.  Move on..
        //
        if ( Status == STATUS_OBJECT_NAME_EXISTS )
        {
            *NewLogonSession = LogonSession;
            LogonSession = NULL;
            Status = STATUS_SUCCESS;
        }

        goto cleanup;
    }

    if ( Impersonating )
    {
        Status = KerbGetCallingLuid(
                    &BaseLogonId,
                    hProcess
                    );
        
        if (!NT_SUCCESS( Status ))
        {
            goto cleanup;
        }

        OkForProxy = KerbAllowedForS4UProxy(&BaseLogonId);

        DsysAssert(ImpersonationLevel != SecurityAnonymous);

        KerbWriteLockLogonSessions( LogonSession );

        //
        // If we're being called from an impersonation level context &&
        // the process is marked as OK for proxy, allow this to be used
        // for S4u
        //
        // Local accounts *can't* do S4U either...
        //
        if (( ImpersonationLevel >= SecurityImpersonation ) &&
            ( OkForProxy ) &&
            (( LogonSession->LogonSessionFlags & KERB_LOGON_LOCAL_ONLY ) == 0 ))
        {
            LogonSession->LogonSessionFlags |= KERB_LOGON_DELEGATE_OK;
        }
  
        KerbUnlockLogonSessions( LogonSession );
    }


    DebugLog((DEB_TRACE_S4U, "KerbCreateDummyLogonSession created logon session for 0x%x:0x%x - %p\n",
        LogonId->HighPart, LogonId->LowPart, LogonSession));


    *NewLogonSession = LogonSession;
    LogonSession = NULL;

cleanup:

    if ( LogonSession != NULL )
    {
        KerbFreeLogonSession( LogonSession );
    }

    if (TmpUserName.Buffer)
    {
        LsaFunctions->FreePrivateHeap(TmpUserName.Buffer);
    }

    if (TmpRealmName.Buffer)
    {
        LsaFunctions->FreePrivateHeap(TmpRealmName.Buffer);
    }

    return Status;

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateLogonSessionFromKerbCred
//
//  Synopsis:   Creates a logon session from the delegation information
//              in a KERB_CRED structure. If a logon session is supplied,
//              it is updated with the supplied information.
//
//  Effects:
//
//  Arguments:  LogonId - Logon id for the logon session
//              Ticket - Ticket from the AP request containing the client's
//                      name and realm.
//              KerbCred - KERB_CRED containing the delegation tickets
//              EncryptedCred - Structure containing information about the
//                      tickets, such as session keys, flags, etc.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateLogonSessionFromKerbCred(
    IN OPTIONAL PLUID LogonId,
    IN PKERB_ENCRYPTED_TICKET Ticket,
    IN PKERB_CRED KerbCred,
    IN PKERB_ENCRYPTED_CRED EncryptedCred,
    IN OUT PKERB_LOGON_SESSION *OldLogonSession
    )
{
    PKERB_LOGON_SESSION LogonSession = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING AccountName;
    UNICODE_STRING ShortAccountName;
    UNICODE_STRING DomainName;
    KERB_ENCRYPTED_KDC_REPLY FakeReplyBody;
    KERB_KDC_REPLY FakeReply;
    PKERB_CRED_INFO CredInfo;
    PKERB_CRED_TICKET_LIST TicketList;
    PKERB_CRED_INFO_LIST CredInfoList;
    PKERB_TICKET_CACHE_ENTRY TicketCacheEntry;
    ULONG NameType;
    LPWSTR LastSlash;
    BOOLEAN LogonSessionLocked = FALSE;
    BOOLEAN CreatedLogonSession = TRUE;
    PKERB_TICKET_CACHE TicketCache = NULL;
    ULONG TgtFlags = KERB_TICKET_CACHE_PRIMARY_TGT;
    ULONG CacheFlags = 0;

    AccountName.Buffer = NULL;
    DomainName.Buffer = NULL;
    if (ARGUMENT_PRESENT(LogonId))
    {
        D_DebugLog((DEB_TRACE_LSESS, "Creating logon session for 0x%x:0x%x\n",
            LogonId->HighPart,LogonId->LowPart));
    }


    if (!KERB_SUCCESS(KerbConvertPrincipalNameToString(
            &AccountName,
            &NameType,
            &Ticket->client_name
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // We need to strip off everything before the last '\' in case there
    // was a domain name.
    //

    LastSlash = wcsrchr(AccountName.Buffer, L'\\');
    if (LastSlash != NULL)
    {
        ShortAccountName.Buffer = LastSlash+1;
        RtlInitUnicodeString(
            &ShortAccountName,
            ShortAccountName.Buffer
            );
    }
    else
    {
        ShortAccountName = AccountName;
    }
    if (!KERB_SUCCESS(KerbConvertRealmToUnicodeString(
            &DomainName,
            &Ticket->client_realm
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE, "Creating delegation logon session for %wZ \\ %wZ\n",
        &DomainName, &ShortAccountName ));

    if ((*OldLogonSession) == NULL)
    {
        //
        // Allocate the new logon session
        //

        Status = KerbAllocateLogonSession( &LogonSession );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // Fill in the logon session components
        //

        LogonSession->LogonId = *LogonId;
        LogonSession->Lifetime = KerbGlobalWillNeverTime;


        Status = KerbCreatePrimaryCredentials(
                    &ShortAccountName,
                    &DomainName,
                    NULL,   // no password
                    NULL,   // no old password
                    0,      // no flags
                    LogonId,
                    &LogonSession->PrimaryCredentials
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }


        LogonSession->LogonSessionFlags |= KERB_LOGON_NO_PASSWORD;
    }
    else
    {
        CreatedLogonSession = FALSE;
        DsysAssert( !LogonSessionLocked );
        KerbWriteLockLogonSessions(*OldLogonSession);
        LogonSessionLocked = TRUE;
        LogonSession = *OldLogonSession;

        //
        // If the user name & domain name are blank, update them from the
        // ticket.
        //

        if (LogonSession->PrimaryCredentials.UserName.Length == 0)
        {
            KerbFreeString(&LogonSession->PrimaryCredentials.UserName);
            LogonSession->PrimaryCredentials.UserName = AccountName;
            AccountName.Buffer = NULL;
        }
        if (LogonSession->PrimaryCredentials.DomainName.Length == 0)
        {
            KerbFreeString(&LogonSession->PrimaryCredentials.DomainName);
            LogonSession->PrimaryCredentials.DomainName = DomainName;
            DomainName.Buffer = NULL;
        }
    }

    //
    // Now stick the ticket into the ticket cache. First build up a fake
    // KDC reply message from the encryped cred info.
    //

    TicketList = KerbCred->tickets;
    CredInfoList = EncryptedCred->ticket_info;

    while (TicketList != NULL)
    {
        TimeStamp Endtime = {0};

        if (CredInfoList == NULL)
        {

            D_DebugLog((DEB_ERROR, "No ticket info in encrypted cred. %ws, line %d\n", THIS_FILE, __LINE__));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        CredInfo = &CredInfoList->value;

        //
        // Set the lifetime to the end or renew_until of the longest lived ticket
        //

        if ((CredInfo->bit_mask & KERB_CRED_INFO_renew_until_present) != 0)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &Endtime,
                &CredInfo->KERB_CRED_INFO_renew_until,
                0                                   // no usec
                );
        }
        else if ((CredInfo->bit_mask & endtime_present) != 0)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &Endtime,
                &CredInfo->endtime,
                0                                   // no usec
                );
        }

        if (Endtime.QuadPart != 0)
        {
            if (LogonSession->Lifetime.QuadPart == KerbGlobalWillNeverTime.QuadPart)
            {
                LogonSession->Lifetime.QuadPart = Endtime.QuadPart;
            }
            else
            {
                LogonSession->Lifetime.QuadPart = max(LogonSession->Lifetime.QuadPart,Endtime.QuadPart);
            }
        }

        RtlZeroMemory(
            &FakeReplyBody,
            sizeof(KERB_ENCRYPTED_KDC_REPLY)
            );

        FakeReplyBody.session_key = CredInfo->key;
        FakeReplyBody.nonce = 0;

        //
        // Set the ticket flags
        //

        if (CredInfo->bit_mask & flags_present)
        {
            FakeReplyBody.flags = CredInfo->flags;
        }
        else
        {
            FakeReplyBody.flags.length = 0;
            FakeReplyBody.flags.value = NULL;
        }

        FakeReplyBody.authtime = Ticket->authtime;

        if (CredInfo->bit_mask & KERB_CRED_INFO_starttime_present)
        {
            FakeReplyBody.KERB_ENCRYPTED_KDC_REPLY_starttime =
                CredInfo->KERB_CRED_INFO_starttime;
            FakeReplyBody.bit_mask |= KERB_ENCRYPTED_KDC_REPLY_starttime_present;
        }

        //
        // If an end time was sent, use it, otherwise assume the ticket
        // lasts forever
        //

        if (CredInfo->bit_mask & endtime_present)
        {
            FakeReplyBody.endtime =
                CredInfo->endtime;
        }
        else
        {
            KerbConvertLargeIntToGeneralizedTime(
                &FakeReplyBody.endtime,
                NULL,
                &KerbGlobalWillNeverTime
                );
        }

        if (CredInfo->bit_mask & KERB_CRED_INFO_renew_until_present)
        {
            FakeReplyBody.KERB_ENCRYPTED_KDC_REPLY_renew_until =
                CredInfo->KERB_CRED_INFO_renew_until;
            FakeReplyBody.bit_mask |= KERB_ENCRYPTED_KDC_REPLY_renew_until_present;
        }

        FakeReplyBody.server_name = TicketList->value.server_name;
        FakeReplyBody.server_realm = TicketList->value.realm;

        //
        // Determine which ticket cache to use
        //

        if ((FakeReplyBody.server_name.name_string != NULL) &&
            _stricmp(
                FakeReplyBody.server_name.name_string->value,
                KDC_PRINCIPAL_NAME_A) == 0)
        {
            TicketCache = &LogonSession->PrimaryCredentials.AuthenticationTicketCache;
            //
            // We only want to use the primary_tgt flag the first time through
            //

            CacheFlags = TgtFlags;
            TgtFlags = 0;
            D_DebugLog((DEB_TRACE,"Adding ticket from kerb_cred to authentication ticket cache\n"));
        }
        else
        {
            TicketCache = &LogonSession->PrimaryCredentials.ServerTicketCache;
            CacheFlags = 0;
            D_DebugLog((DEB_TRACE,"Adding ticket from kerb_cred to server ticket cache\n"));
        }

        FakeReply.client_name = Ticket->client_name;
        FakeReply.ticket = TicketList->value;
        FakeReply.client_realm = Ticket->client_realm;

        Status = KerbCreateTicketCacheEntry(
                    &FakeReply,
                    &FakeReplyBody,
                    NULL,               // no target name
                    NULL,
                    CacheFlags,
                    TicketCache,
                    NULL,                               // no credential key
                    &TicketCacheEntry
                    );

        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR, "Failed to cache ticket: 0x%x. %ws, line %d\n",
                Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        LogonSession->LogonSessionFlags &= ~KERB_LOGON_DEFERRED;

        KerbDereferenceTicketCacheEntry(TicketCacheEntry);

        CredInfoList = CredInfoList->next;
        TicketList = TicketList->next;
    }

    //
    // Now that the logon session structure is filled out insert it
    // into the list. After this you need to hold the logon session lock
    // to read or write this logon session.
    //

    if (*OldLogonSession == NULL)
    {
        Status = KerbInsertLogonSession(LogonSession);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        *OldLogonSession = LogonSession;
    }

Cleanup:

    if (LogonSessionLocked)
    {
        KerbUnlockLogonSessions(LogonSession);
    }

    if (CreatedLogonSession)
    {
        if (!NT_SUCCESS(Status))
        {
            if (LogonSession != NULL)
            {
                KerbFreeLogonSession(LogonSession);
            }
        }
    }

    KerbFreeString(&AccountName);
    KerbFreeString(&DomainName);

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateLogonSessionFromTicket
//
//  Synopsis:   Creates a logon session from a service ticket.  Later
//              can be used for S4U proxy delegation.
//
//  Effects:
//
//  Arguments:  LogonId - Logon id for the logon session
//              Ticket - Ticket from the AP request containing the client's
//                      name and realm.
//              KerbCred - KERB_CRED containing the delegation tickets
//              EncryptedCred - Structure containing information about the
//                      tickets, such as session keys, flags, etc.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCreateLogonSessionFromTicket(
    IN PLUID NewLuid,
    IN OPTIONAL PLUID AcceptingLuid,
    IN PUNICODE_STRING ClientName,
    IN PUNICODE_STRING ClientRealm,
    IN PKERB_AP_REQUEST ApRequest,
    IN PKERB_ENCRYPTED_TICKET Ticket,
    IN OUT PKERB_LOGON_SESSION *NewLogonSession  // needed?
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_LOGON_SESSION LogonSession = NULL;

    KERB_ENCRYPTED_KDC_REPLY FakeReplyBody;
    KERB_KDC_REPLY FakeReply;
    PKERB_TICKET_CACHE_ENTRY TicketCacheEntry = NULL;
    LUID SystemLogonId = SYSTEM_LUID;
    BOOLEAN IsSystemLogon = FALSE;
    ULONG TicketFlags = 0;
    LUID  BaseLogonId;

    //
    // Only create these if we're allowed to do S4UToProxy.  Otherwise,
    // there's no reason to keep this ticket around.  If it starts becoming
    // available, we can always fall back to S4UToSelf to get a new service
    // ticket.
    //
    if (ARGUMENT_PRESENT(NewLogonSession))
    {
        *NewLogonSession = NULL;
    }

    if (!ARGUMENT_PRESENT( AcceptingLuid ))
    {
        Status = KerbGetCallingLuid(
                    &BaseLogonId,
                    NULL // no process handle
                    );
        
        if (!NT_SUCCESS( Status ))
        {
            goto Cleanup;
        }
    }
    else
    {
        BaseLogonId = (*AcceptingLuid);
    }

    if (!KerbAllowedForS4UProxy( &BaseLogonId ))
    {
        DebugLog((DEB_TRACE_LSESS, "KerbCreateLogonSessionFromTicket NOT creating ASC logon session for %#x:%#x, accepting %#x:%#x\n", 
            NewLuid->HighPart, NewLuid->LowPart, BaseLogonId.HighPart, BaseLogonId.LowPart));
        goto Cleanup;
    }

    DebugLog((DEB_TRACE_LSESS, "KerbCreateLogonSessionFromTicket creating logon session for %#x:%#x, accepting %#x:%#x, client %wZ@%wZ\n",
        NewLuid->HighPart, NewLuid->LowPart, BaseLogonId.HighPart, BaseLogonId.LowPart, ClientName, ClientRealm));

    //
    // Allocate the new logon session
    //

    Status = KerbAllocateLogonSession( &LogonSession );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Fill in the logon session components
    //

    LogonSession->LogonId = (*NewLuid);
    LogonSession->LogonSessionFlags = KERB_LOGON_ASC_SESSION | KERB_LOGON_NO_PASSWORD | KERB_LOGON_DEFERRED;

    KerbConvertGeneralizedTimeToLargeInt(
                &LogonSession->Lifetime,
                &Ticket->endtime,
                NULL
                );

    if (RtlEqualLuid(
            NewLuid,
            &SystemLogonId
            ))
    {
        IsSystemLogon = TRUE;
    }

    Status = KerbDuplicateString(
                &LogonSession->PrimaryCredentials.UserName,
                ClientName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // The system logon always comes in uppercase, so lowercase it.
    //

    if (IsSystemLogon)
    {
        RtlDowncaseUnicodeString(
            &LogonSession->PrimaryCredentials.UserName,
            &LogonSession->PrimaryCredentials.UserName,
            FALSE
            );
    }

    Status = KerbDuplicateString(
                &LogonSession->PrimaryCredentials.DomainName,
                ClientRealm
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // We now have to make a decision about whether to store
    // the ticket, and how to mark the logon session.  If
    // the ticket is non-fwdable, we can't do S4U using it, so we
    // might as well not cache it, but we should still create
    // the logon session...
    //
    // This allows for a bit of an optimization, as if the user's ticket
    // wasn't fwdable, we shouldn't do S4U2Self for that user, as
    // their account must be marked "sensitive and unable to be
    // delegated", and we'd be wasting an S4UToSelf tgs_req.
    //

    TicketFlags = KerbConvertFlagsToUlong(&Ticket->flags);

    if (( TicketFlags & KERB_TICKET_FLAGS_forwardable ) != 0)
    {
        ULONG ApOptions = KerbConvertFlagsToUlong(&ApRequest->ap_options);
        ULONG CacheFlags = KERB_TICKET_CACHE_ASC_TICKET;

        if (ApOptions & KERB_AP_OPTIONS_use_session_key)
        {
            D_DebugLog((DEB_TRACE_U2U, "KerbCreateLogonSessionFromTicket set TKT_ENC_IN_SKEY\n"));
            CacheFlags |= KERB_TICKET_CACHE_TKT_ENC_IN_SKEY;
        }

        LogonSession->LogonSessionFlags |= KERB_LOGON_DELEGATE_OK;

        //
        // Now stick the ticket into the ticket cache. First build up a fake
        // KDC reply message from the encryped cred info.
        //

        FakeReplyBody.authtime = Ticket->authtime;
        FakeReplyBody.starttime = Ticket->starttime;
        FakeReplyBody.endtime = Ticket->endtime;
        FakeReplyBody.server_name = ApRequest->ticket.server_name;
        FakeReplyBody.server_realm = ApRequest->ticket.realm;
        FakeReplyBody.session_key = Ticket->key;
        FakeReplyBody.flags = Ticket->flags;
        FakeReply.client_name = Ticket->client_name;
        FakeReply.ticket = ApRequest->ticket;
        FakeReply.client_realm = Ticket->client_realm;

        Status = KerbCreateTicketCacheEntry(
                    &FakeReply,
                    &FakeReplyBody,
                    NULL,               // no target name
                    NULL,
                    CacheFlags,
                    NULL,
                    NULL,                               // no credential key
                    &TicketCacheEntry
                    );

        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR, "Failed to cache ticket: 0x%x. %ws, line %d\n",
                        Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        TicketCacheEntry->EvidenceLogonId = BaseLogonId;

        KerbInsertTicketCacheEntry(
                &LogonSession->PrimaryCredentials.S4UTicketCache,
                TicketCacheEntry
                );

    }

#if DBG
    else
    {
        DebugLog((DEB_TRACE_LSESS, "Creating non-delegatable ASC logon session\n"));
    }
#endif

    //
    // Now that the logon session structure is filled out insert it
    // into the list. After this you need to hold the logon session lock
    // to read or write this logon session.
    //

    Status = KerbInsertLogonSession(LogonSession);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (ARGUMENT_PRESENT( NewLogonSession ))
    {
        *NewLogonSession = LogonSession;
    }
    else
    {
        // We aren't returning it, so...
        KerbDereferenceLogonSession( LogonSession );
    }

Cleanup:


    if (!NT_SUCCESS(Status) && (LogonSession != NULL))
    {
        KerbFreeLogonSession(LogonSession);
    }

    if (TicketCacheEntry != NULL)
    {
        KerbDereferenceTicketCacheEntry(TicketCacheEntry);
    }

    return(Status);

}

VOID
KerbFreeExtraCred(
    PKERB_EXTRA_CRED Cred
    )
{
    if (Cred != NULL)
    {
        if (Cred->Passwords != NULL)
        {
            KerbFreeStoredCred(Cred->Passwords);
        }

        if (Cred->OldPasswords != NULL)
        {
            KerbFreeStoredCred(Cred->OldPasswords);
        }

        KerbFreeString(&Cred->cName);
        KerbFreeString(&Cred->cRealm);
        KerbFree(Cred);
    }
}


VOID
KerbDereferenceExtraCred(
    PKERB_EXTRA_CRED Cred
    )
{
    DsysAssert(Cred->ListEntry.ReferenceCount != 0);

    if ( 0 == InterlockedDecrement((LONG *)&Cred->ListEntry.ReferenceCount ))
    {
        KerbFreeExtraCred(Cred);
    }
}

VOID
KerbReferenceExtraCred(
    PKERB_EXTRA_CRED Cred
    )
{
    InterlockedIncrement((LONG *)&Cred->ListEntry.ReferenceCount);
}

VOID
KerbRemoveExtraCredFromList(
    PKERB_EXTRA_CRED Cred,
    PEXTRA_CRED_LIST CredList
    )
{
    if ( InterlockedCompareExchange(
             &Cred->Linked,
             (LONG)FALSE,
             (LONG)TRUE ))
    {
        DsysAssert(Cred->ListEntry.ReferenceCount != 0);
        RemoveEntryList(&Cred->ListEntry.Next);
        KerbDereferenceExtraCred(Cred);
        InterlockedDecrement((LONG*) &CredList->Count );
    }
}


VOID
KerbInsertExtraCred(
    IN PKERB_EXTRA_CRED Cred,
    IN PEXTRA_CRED_LIST Credlist
    )
{
    if ( !InterlockedCompareExchange(
              &Cred->Linked,
              (LONG)TRUE,
              (LONG)FALSE ))
    {
        InterlockedIncrement( (LONG *)&Cred->ListEntry.ReferenceCount );
        InsertHeadList(
            &Credlist->CredList.List,
            &Cred->ListEntry.Next
            );

        InterlockedIncrement((LONG*) &Credlist->Count);
    }
}

VOID
KerbFreeExtraCredList(
    IN PEXTRA_CRED_LIST Credlist
    )
{
    PKERB_EXTRA_CRED Cred;

    KerbLockList(&Credlist->CredList);
    while (!IsListEmpty(&Credlist->CredList.List))
    {
        Cred = CONTAINING_RECORD(
                        Credlist->CredList.List.Flink,
                        KERB_EXTRA_CRED,
                        ListEntry.Next
                        );

        KerbRemoveExtraCredFromList(
            Cred,
            Credlist
            );
    }

    DsysAssert(Credlist->Count == 0);
    KerbUnlockList(&Credlist->CredList);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbAddExtraCredentialsToLogonSession
//
//  Synopsis:   Initializes logon session list
//
//  Effects:    allocates a resources
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, other error codes
//              on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbAddExtraCredentialsToLogonSession(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_ADD_CREDENTIALS_REQUEST AddCredRequest
    )
{



    NTSTATUS Status = STATUS_SUCCESS;

    PKERB_STORED_CREDENTIAL DerivedPasswords = NULL;
    PKERB_EXTRA_CRED        Cred = NULL;
    PLIST_ENTRY             ListEntry;
    BOOLEAN                 Matched = FALSE, ListLocked = FALSE;


    //
    // YuChen repellant
    //
    if ((AddCredRequest->UserName.Length > KERB_MAX_UNICODE_STRING) ||
    (AddCredRequest->DomainName.Length > KERB_MAX_UNICODE_STRING))
    {
        return (STATUS_NAME_TOO_LONG);
    }
    if ((AddCredRequest->Password.Length != 0) && (AddCredRequest->Password.Length > KERB_MAX_UNICODE_STRING))
    {
        return (STATUS_NAME_TOO_LONG);
    }


    //
    // See if we match an old "extra cred"
    //
    KerbLockList( &LogonSession->ExtraCredentials.CredList );
    ListLocked = TRUE;

    for (ListEntry = LogonSession->ExtraCredentials.CredList.List.Flink ;
         ListEntry != &LogonSession->ExtraCredentials.CredList.List ;
         ListEntry = ListEntry->Flink )
    {
        Cred = CONTAINING_RECORD(ListEntry, KERB_EXTRA_CRED, ListEntry.Next);


        if (RtlEqualUnicodeString(
                    &Cred->cName,
                    &AddCredRequest->UserName,
                    TRUE) &&
             RtlEqualUnicodeString(
                    &Cred->cRealm,
                    &AddCredRequest->DomainName,
                    TRUE))
        {
            D_DebugLog((DEB_TRACE, "Matched extra cred %p\n", Cred));
            Matched = TRUE;
            break;
        }

    }


    if ( Matched )
    {

        if (( AddCredRequest->Flags & ( KERB_REQUEST_ADD_CREDENTIAL | KERB_REQUEST_REPLACE_CREDENTIAL)) != 0)
        {

            Status = KerbBuildPasswordList(
                           &AddCredRequest->Password,
                           &AddCredRequest->UserName,
                           &AddCredRequest->DomainName,
                           NULL,
                           NULL,
                           NULL,
                           UnknownAccount,
                           PRIMARY_CRED_CLEAR_PASSWORD,
                           &DerivedPasswords
                           );

            if (!NT_SUCCESS( Status ))
            {
                DebugLog((DEB_ERROR, "Failed to build password list (%x) \n", Status));
                goto Cleanup;
            }


            if (Cred->OldPasswords != NULL)
            {
                KerbFreeStoredCred(Cred->OldPasswords);
            }

            if ((AddCredRequest->Flags & KERB_REQUEST_REPLACE_CREDENTIAL) == 0)
            {
                Cred->OldPasswords = Cred->Passwords;
            }
            else if (Cred->Passwords != NULL)
            {
                //
                // Doing a "replace" operation.
                //
                KerbFreeStoredCred(Cred->Passwords);
            }

            Cred->Passwords = DerivedPasswords;
            DerivedPasswords = NULL;

        }
        else
        {
            //
            // Remove the cred from the list, and deref it.
            //

            D_DebugLog((DEB_TRACE, "Removing extra cred %p\n", Cred));
            KerbRemoveExtraCredFromList(
                    Cred,
                    &LogonSession->ExtraCredentials
                    );
        }

    }
    else if (( AddCredRequest->Flags & KERB_REQUEST_REMOVE_CREDENTIAL) == 0)
    {
        D_DebugLog((DEB_TRACE, "Creating cred %p\n", Cred));

        Cred = (PKERB_EXTRA_CRED) KerbAllocate(sizeof(KERB_EXTRA_CRED));
        if (NULL == Cred)
        {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        Status = KerbDuplicateString(
                    &Cred->cName,
                    &AddCredRequest->UserName
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        Status = KerbDuplicateString(
                    &Cred->cRealm,
                    &AddCredRequest->DomainName
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        Status = KerbBuildPasswordList(
                    &AddCredRequest->Password,
                    &AddCredRequest->UserName,
                    &AddCredRequest->DomainName,
                    NULL,
                    NULL,
                    NULL,
                    UnknownAccount,
                    PRIMARY_CRED_CLEAR_PASSWORD,
                    &DerivedPasswords
                    );

        if (!NT_SUCCESS( Status ))
        {
            DebugLog((DEB_ERROR, "Failed to build password list (%x) \n", Status));
            goto Cleanup;
        }

        Cred->Passwords = DerivedPasswords;
        DerivedPasswords = NULL;

        KerbInsertExtraCred(
                Cred,
                &LogonSession->ExtraCredentials
                );

    }

    KerbUnlockList( &LogonSession->ExtraCredentials.CredList);
    ListLocked = FALSE;

Cleanup:

    if ( DerivedPasswords != NULL )
    {
        KerbFreeStoredCred( DerivedPasswords );
    }

    if (!NT_SUCCESS( Status ))
    {
        // only free it on error if we haven't
        // matched the credential...
        if ( Cred != NULL && !Matched)
        {
            KerbFreeExtraCred(Cred);
        }
    }

    if ( ListLocked )
    {
        KerbUnlockList( &LogonSession->ExtraCredentials.CredList );
    }

    return Status;
}

#endif // WIN32_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\logonapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        logonapi.cxx
//
// Contents:    Code for logon and logoff for the Kerberos package
//
//
// History:     16-April-1996   MikeSw          Created
//              15-June-2000    t-ryanj         Added event tracing support
//
//------------------------------------------------------------------------
#include <kerb.hxx>
#include <kerbp.h>

#include <utils.hxx>

#ifdef DEBUG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

#define FILENO FILENO_LOGONAPI

EXTERN BOOLEAN fNewDataAboutDomain;
EXTERN BOOLEAN fRebootedSinceJoin;

//+-------------------------------------------------------------------------
//
//  Function:   KerbFindCommonPaEtype
//
//  Synopsis:   Finds an encryption type in common between KDC and client.
//
//  Effects:
//
//  Arguments:  Credentials - Client's credentials, must be locked
//              InputPaData - PA data from an error return from the KDC
//              UseOldPassword - if TRUE, use the old password instead of current password
//              UserKey - receives key for common encryption type
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



NTSTATUS
KerbFindCommonPaEtype(
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    IN OPTIONAL PKERB_PA_DATA_LIST InputPaData,
    IN BOOLEAN UseOldPassword,
    IN BOOLEAN IgnoreSaltFailures,
    OUT PKERB_ENCRYPTION_KEY * UserKey
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    PKERB_PA_DATA InputData = NULL;
    ULONG PasswordTypes[KERB_MAX_CRYPTO_SYSTEMS];
    ULONG PasswordCount;
    ULONG KdcEtypes[KERB_MAX_CRYPTO_SYSTEMS];
    ULONG KdcEtypeCount = 0;
    PKERB_ETYPE_INFO * EtypeInfo = NULL;
    PKERB_ETYPE_INFO EtypeEntry;
    ULONG CommonCryptSystem;
    ULONG Index;
    PKERB_STORED_CREDENTIAL Passwords;
    BOOLEAN UseDES = FALSE;

    *UserKey = NULL;

    //
    // Check to see if the input had any interesting PA data
    //

    if ((InputPaData != NULL) && (!UseOldPassword))
    {
        InputData = KerbFindPreAuthDataEntry(
                        KRB5_PADATA_ETYPE_INFO,
                        InputPaData
                        );
        if (InputData == NULL)
        {
            //
            // If no etype-info was provided, then we are out of luck.
            // Change this to allow for utilizing default DES etype if no
            // etypeinfo specified for Heimdel KDC interop. Bug#87960
            //


            //Status = STATUS_NO_PA_DATA;
            //goto Cleanup;
            UseDES = TRUE;
        }
        else
        {
            //
            // Unpack the etype info
            //

            KerbErr = KerbUnpackData(
                        InputData->preauth_data.value,
                        InputData->preauth_data.length,
                        PKERB_ETYPE_INFO_PDU,
                        (PVOID *) &EtypeInfo
                        );
            if (!KERB_SUCCESS(KerbErr))
            {
                D_DebugLog((DEB_ERROR,"Failed to unpack ETYPE INFO: 0x%x. %ws, line%d\n",KerbErr, THIS_FILE, __LINE__));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            //
            // Build a new set of passwords
            //

            Status = KerbChangeCredentialsPassword(
                        Credentials,
                        NULL,                   // no password
                        *EtypeInfo,
                        UnknownAccount,
                        PRIMARY_CRED_CLEAR_PASSWORD
                        );
            if (!NT_SUCCESS(Status))
            {
                D_DebugLog((DEB_ERROR,"Failed to update primary creds with new salt: 0x%x, file %ws %d\n",
                        Status, THIS_FILE, __LINE__ ));

                if (!IgnoreSaltFailures)
                {
                    //
                    // Remap the error, as we want to return a more useful error
                    //

                    if (Status == STATUS_INVALID_PARAMETER)
                    {
                        Status = STATUS_WRONG_PASSWORD;
                    }
                    goto Cleanup;
                }
                else
                {
                    Status = STATUS_SUCCESS;
                }

            }

            //
            // Build a list of crypt types from the etype info
            //

            KdcEtypeCount = 0;
            EtypeEntry = *EtypeInfo;
            while (EtypeEntry != NULL)
            {
                KdcEtypes[KdcEtypeCount++] = EtypeEntry->value.encryption_type;
                EtypeEntry = EtypeEntry->next;
                if (KdcEtypeCount == KERB_MAX_CRYPTO_SYSTEMS)
                {
                    break;
                }
            }
        }

    } else {
        ULONG OldFirstEtype;

        //
        // Include all our crypt types as supported
        //

        Status = CDBuildIntegrityVect(
                    &KdcEtypeCount,
                    KdcEtypes
                    );
        DsysAssert(NT_SUCCESS(Status));
        DsysAssert(KdcEtypeCount >= 1);

        //
        // replace the first etype with the default
        //

        if (KdcEtypes[0] != KerbGlobalDefaultPreauthEtype)
        {
            OldFirstEtype = KdcEtypes[0];
            KdcEtypes[0] = KerbGlobalDefaultPreauthEtype;

            for (Index = 1; Index < KdcEtypeCount ; Index++ )
            {
                if ( KdcEtypes[Index] == KerbGlobalDefaultPreauthEtype)
                {
                    KdcEtypes[Index] = OldFirstEtype;
                    break;
                }
            }
        }

    }

    //  Heimdal KDC compat gives us no supported EType info, so
    //  we've got to rely upon SPEC'd default, DES encryption.
    //  See bug 87960 for more info.  NOTE:  We'll try this
    //  2 times...  Should work to avoid this..
    if (UseDES) {

        ULONG OldFirstEtype;

        //
        // Include all our crypt types as supported
        //

        Status = CDBuildIntegrityVect(
                    &KdcEtypeCount,
                    KdcEtypes
                    );
        DsysAssert(NT_SUCCESS(Status));
        DsysAssert(KdcEtypeCount >= 1);

        //
        // Use **only** DES, as it should be supported by all
        // KDCs, and w/o preauth ETYPEINFO data, we would have
        // to hit every ETYPE.
        // TBD:  When Heimdal supports RC4, or if they fix their
        // padata, then pull this code.
        if (KdcEtypes[0] != KERB_ETYPE_DES_CBC_MD5)
        {
            OldFirstEtype = KdcEtypes[0];
            KdcEtypes[0] = KERB_ETYPE_DES_CBC_MD5;

            for (Index = 1; Index < KdcEtypeCount ; Index++ )
            {
                if ( KdcEtypes[Index] == KERB_ETYPE_DES_CBC_MD5)
                {
                    KdcEtypes[Index] = OldFirstEtype;
                    break;
                }
            }
        }

    }

    //
    // Build the list of passwords
    //

    if (UseOldPassword)
    {
        Passwords = Credentials->OldPasswords;
    }
    else
    {
        Passwords = Credentials->Passwords;
    }

    if (Passwords == NULL)
    {
        Status = STATUS_WRONG_PASSWORD;
        goto Cleanup;
    }

    PasswordCount = Passwords->CredentialCount;
    if (PasswordCount > KERB_MAX_CRYPTO_SYSTEMS)
    {
        DsysAssert(PasswordCount < KERB_MAX_CRYPTO_SYSTEMS);
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    for (Index = 0; Index < PasswordCount ; Index++ )
    {
        PasswordTypes[Index] = (ULONG) Passwords->Credentials[Index].Key.keytype;
    }

    //
    // Now find the common crypt system
    //


    Status = CDFindCommonCSystemWithKey(
                KdcEtypeCount,
                KdcEtypes,
                PasswordCount,
                PasswordTypes,
                &CommonCryptSystem
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Get the key for the common crypt type
    //

    *UserKey = KerbGetKeyFromList(
                Passwords,
                CommonCryptSystem
                );
    DsysAssert(*UserKey != NULL);


    //
    // If we were using etype info, and not an old password, and the
    // etype doesn't use salt, then fail the operation, as we aren't
    // really generating a new key.
    //

    if (!UseOldPassword &&
        (CommonCryptSystem == KerbGlobalDefaultPreauthEtype) &&
        ARGUMENT_PRESENT(InputPaData))
    {
        PCRYPTO_SYSTEM CryptoSystem = NULL;
        Status = CDLocateCSystem(CommonCryptSystem, &CryptoSystem);
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to load %d crypt system: 0x%x.\n",CommonCryptSystem,Status ));
            goto Cleanup;
        }

        DsysAssert(CryptoSystem != NULL);
        if ((CryptoSystem->Attributes & CSYSTEM_USE_PRINCIPAL_NAME) == 0)
        {
            if (!IgnoreSaltFailures)
            {
                D_DebugLog((DEB_WARN,"Tried to update password with new salt, but keytype 0x%x doesn't use salt.\n",
                          CommonCryptSystem));

                *UserKey = NULL;
                Status = STATUS_WRONG_PASSWORD;
                goto Cleanup;
            }
        }
    }

Cleanup:

    if (EtypeInfo != NULL)
    {
        KerbFreeData(PKERB_ETYPE_INFO_PDU, EtypeInfo);
    }
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildPreAuthData
//
//  Synopsis:   Builds pre-auth data for type the specified pre-auth types
//
//  Effects:
//
//  Arguments:  Credentials - Client's credentials, must be locked
//              RealmName - Name of target realm
//              ServiceName - Name of target server
//              PaTypeCount - count of pre-auth types to build
//              PaTypes - list of pre-auth types to build
//              InputPaData - any PA data returned by a previous (failed)
//                  AS request
//              TimeSkew - Time Skew with KDC
//              UseOldPassword - Use the old password instead of current one
//              PreAuthData - receives list of pre-auth data
//              Done - don't call again on pre-auth failure
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbBuildPreAuthData(
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    IN PUNICODE_STRING RealmName,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN ULONG PaTypeCount,
    IN PULONG PaTypes,
    IN OPTIONAL PKERB_PA_DATA_LIST InputPaData,
    IN PTimeStamp TimeSkew,
    IN BOOLEAN UseOldPassword,
    IN ULONG Nonce,
    IN KERBERR ErrorCode,
    OUT PKERB_PA_DATA_LIST * PreAuthData,
    OUT PKERB_ENCRYPTION_KEY EncryptionKey,
    OUT PKERB_CRYPT_LIST * CryptList,
    OUT PBOOLEAN Done
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement = NULL;
    PKERB_PA_DATA_LIST OutputList = NULL;
    ULONG Index;
    BOOLEAN FoundPreauth = FALSE;


    //
    // Initialize outputs
    //

    *PreAuthData = NULL;
    *Done = FALSE;

    for (Index = 0 ; Index < PaTypeCount ; Index++ )
    {
        switch(PaTypes[Index]) {
        case KRB5_PADATA_ENC_TIMESTAMP:
            {
                KERB_ENCRYPTED_TIMESTAMP Timestamp = {0};
                TimeStamp CurrentTime;
                PBYTE EncryptedTime = NULL;
                ULONG EncryptedTimeSize = 0;
                KERB_ENCRYPTED_DATA EncryptedData = {0};
                PKERB_ENCRYPTION_KEY UserKey = NULL;

                FoundPreauth = TRUE;
                //
                // Check for encryption hints in the incoming pa-data
                //

                Status = KerbFindCommonPaEtype(
                            Credentials,
                            InputPaData,
                            UseOldPassword,
                            ErrorCode == KDC_ERR_PREAUTH_REQUIRED,      // ignore salt problems on preauth-req errors
                            &UserKey
                            );
                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                //
                // If there was any input PA data, we don't want to try again.
                //

                if (InputPaData != NULL)
                {
                    *Done = TRUE;
                }
                //
                // Build the output element
                //

                ListElement = (PKERB_PA_DATA_LIST) KerbAllocate(sizeof(KERB_PA_DATA_LIST));
                if (ListElement == NULL)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                //
                // Now build the encrypted timestamp
                //

                GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);

                //
                // Adjust for time skew with KDC
                //

                KerbSetTime(&CurrentTime, KerbGetTime(CurrentTime) + KerbGetTime(*TimeSkew));

                KerbConvertLargeIntToGeneralizedTimeWrapper(
                    &Timestamp.timestamp,
                    &Timestamp.KERB_ENCRYPTED_TIMESTAMP_usec,
                    &CurrentTime
                    );

                Timestamp.bit_mask = KERB_ENCRYPTED_TIMESTAMP_usec_present;

                KerbErr = KerbPackEncryptedTime(
                            &Timestamp,
                            &EncryptedTimeSize,
                            &EncryptedTime
                            );
                if (!KERB_SUCCESS(KerbErr))
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                //
                // Now encrypt the time
                //

                KerbErr = KerbAllocateEncryptionBufferWrapper(
                            UserKey->keytype,
                            EncryptedTimeSize,
                            &EncryptedData.cipher_text.length,
                            &EncryptedData.cipher_text.value
                            );

                if (!KERB_SUCCESS(KerbErr))
                {
                    D_DebugLog((DEB_ERROR,"\n\nFailed to get encryption overhead. %ws, line %d\n\n", THIS_FILE, __LINE__));
                    KerbFree(EncryptedTime);
                    Status = KerbMapKerbError(KerbErr);
                    goto Cleanup;
                }


                KerbErr = KerbEncryptDataEx(
                            &EncryptedData,
                            EncryptedTimeSize,
                            EncryptedTime,
                            KERB_NO_KEY_VERSION,
                            KERB_ENC_TIMESTAMP_SALT,
                            UserKey
                            );
                KerbFree(EncryptedTime);

                if (!KERB_SUCCESS(KerbErr))
                {
                    MIDL_user_free(EncryptedData.cipher_text.value);
                    D_DebugLog((DEB_ERROR,"Failed to encrypt PA data. %ws, line %d\n", THIS_FILE, __LINE__));
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                //
                // Now pack the encrypted data
                //

                KerbErr = KerbPackEncryptedData(
                            &EncryptedData,
                            (PULONG) &ListElement->value.preauth_data.length,
                            (PUCHAR *) &ListElement->value.preauth_data.value
                            );

                MIDL_user_free(EncryptedData.cipher_text.value);

                if (!KERB_SUCCESS(KerbErr))
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                ListElement->value.preauth_data_type = KRB5_PADATA_ENC_TIMESTAMP;
                ListElement->next = OutputList;
                OutputList = ListElement;
                ListElement = NULL;
                break;
            }
#ifndef WIN32_CHICAGO
        case KRB5_PADATA_PK_AS_REQ:
            FoundPreauth = TRUE;
            Status = KerbBuildPkinitPreauthData(
                        Credentials,
                        InputPaData,
                        TimeSkew,
                        ServiceName,
                        RealmName,
                        Nonce,
                        &OutputList,
                        EncryptionKey,
                        CryptList,
                        Done
                        );

            break;
#endif // WIN32_CHICAGO
        default:
            continue;
        }
    }
    if (!FoundPreauth)
    {
        DebugLog((DEB_ERROR,"NO known pa data type passed to KerbBuildPreAuthData. %ws, line %d\n",
            THIS_FILE, __LINE__ ));
        Status = STATUS_UNSUPPORTED_PREAUTH;
        goto Cleanup;

    }
    *PreAuthData = OutputList;
    OutputList = NULL;

Cleanup:

    if (OutputList != NULL)
    {
        KerbFreePreAuthData(
            OutputList
            );
    }
    if (ListElement != NULL)
    {
        KerbFreePreAuthData(
            ListElement
            );
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetPreAuthDataForRealm
//
//  Synopsis:   Gets the appropriate pre-auth data for the specified realm.
//              Right now it always returns KRB_ENC_TIMESTAMP pre-auth data
//              but at some point it might do different things based on
//              the realm.
//
//  Effects:
//
//  Arguments:  Credentials - Client's credentials
//              TargetRealm - realm from which the client is requesting a ticket
//              OldPreAuthData - any pre-auth data returned from the KDC on
//                      the last AS request.
//              TimeSkew - Time skew with KDC
//              UseOldPassword - if TRUE, use the old password instead of current
//              PreAuthData - Receives the new pre-auth data
//              Done - if TRUE, don't bother trying again on a pre-auth required
//                      failure
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetPreAuthDataForRealm(
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    IN PUNICODE_STRING TargetRealm,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN PKERB_PA_DATA_LIST OldPreAuthData,
    IN PTimeStamp TimeSkew,
    IN BOOLEAN UseOldPassword,
    IN ULONG Nonce,
    IN KERBERR ErrorCode,
    OUT PKERB_PA_DATA_LIST * PreAuthData,
    OUT PKERB_ENCRYPTION_KEY EncryptionKey,
    OUT PKERB_CRYPT_LIST * CryptList,
    OUT PBOOLEAN Done
    )
{
#define KERB_MAX_PA_DATA_TYPES 10
    NTSTATUS Status;
    ULONG PaTypeCount = 0;
    ULONG PaDataTypes[KERB_MAX_PA_DATA_TYPES];
    PKERB_MIT_REALM MitRealm;
    BOOLEAN UsedAlternateName;
    PKERB_PA_DATA_LIST PreAuthElement = NULL;


    //
    // If an error message was supplied, see if we can pull out the
    // list of supported pre-auth types from it.
    //

    if (ARGUMENT_PRESENT(OldPreAuthData) && (ErrorCode == KDC_ERR_PREAUTH_REQUIRED))
    {

        //
        // Pick the first type from the list as the type
        //

        PreAuthElement = OldPreAuthData;
        while ((PaTypeCount < KERB_MAX_PA_DATA_TYPES) && (PreAuthElement != NULL))
        {
            PaDataTypes[PaTypeCount++] = (ULONG) PreAuthElement->value.preauth_data_type;
            PreAuthElement = PreAuthElement->next;
        }

    }
    else
    {
        //
        // For MIT realms, check the list to see what kind of preauth to do.
        //

        if (KerbLookupMitRealm(
                TargetRealm,
                &MitRealm,
                &UsedAlternateName
                ))
        {
           //
           //  There are some types of preauth returned from the KDC that we
           //  need to log an event for.   PA-PW-SALT (3) and PA-AFS3-SALT (10)
           //  are not implemented in our client, so log an error to help admins,
           //  and retry w/ default for realm.
           //
           while ((PaTypeCount < KERB_MAX_PA_DATA_TYPES) && (PreAuthElement != NULL))
           {
              if (PreAuthElement->value.preauth_data_type == KRB5_PADATA_PW_SALT ||
                  PreAuthElement->value.preauth_data_type == KRB5_PADATA_AFS3_SALT)
              {

                 Status = STATUS_UNSUPPORTED_PREAUTH;
                 DebugLog((
                           DEB_ERROR,
                           "Unsupported Preauth type : %x\n",
                           PreAuthElement->value.preauth_data_type
                           ));

                 goto Cleanup;
              }

              PaTypeCount++;
              PreAuthElement = PreAuthElement->next;
           }

           if (MitRealm->PreAuthType != 0)
           {
              PaDataTypes[0] = MitRealm->PreAuthType;
              PaTypeCount = 1;
           }
           else
           {
              return(STATUS_SUCCESS);
           }
        }

        //
        // Plug in fancier capabilities here.
        //

        //
        // If the caller has public key credentials, use pkinit rather than
        // encrypted timestamp
        //


        else if (Credentials->PublicKeyCreds != NULL)
        {
            PaDataTypes[0] = KRB5_PADATA_PK_AS_REQ;
            PaTypeCount = 1;
        }
        else
        {
            //
            // If we were succeful, ignore this preauth data
            //

            if ((ErrorCode == KDC_ERR_NONE) && (OldPreAuthData != NULL))
            {
                return(STATUS_SUCCESS);
            }
            PaDataTypes[0] = KRB5_PADATA_ENC_TIMESTAMP;
            PaTypeCount = 1;
        }


    }

    Status = KerbBuildPreAuthData(
                Credentials,
                TargetRealm,
                ServiceName,
                PaTypeCount,
                PaDataTypes,
                OldPreAuthData,
                TimeSkew,
                UseOldPassword,
                Nonce,
                ErrorCode,
                PreAuthData,
                EncryptionKey,
                CryptList,
                Done
                );

Cleanup:

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbUnpackErrorPreauth
//
//  Synopsis:   Unpacks preauth data from a kerb_error message
//
//  Effects:
//
//  Arguments:  ErrorMessage - ErrorMessage from an AS request that failed
//                      with KDC_ERR_PREAUTH_REQUIRED
//              PreAuthData - returns any preauth data from the error message
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbUnpackErrorPreauth(
    IN PKERB_ERROR ErrorMessage,
    OUT PKERB_PA_DATA_LIST ** PreAuthData
    )
{
    KERBERR KerbErr = KDC_ERR_NONE;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PREAUTH_DATA_LIST * ErrorPreAuth = NULL;

    *PreAuthData = NULL;

    //
    // If there was no data, return now
    //

    if ((ErrorMessage->bit_mask & error_data_present) == 0)
    {
        //
        // If we weren't given any hints, we can't do any better so return
        // an error.
        //

        KerbErr = KDC_ERR_PREAUTH_REQUIRED;
        goto Cleanup;
    }

    KerbErr = KerbUnpackData(
                ErrorMessage->error_data.value,
                ErrorMessage->error_data.length,
                PKERB_PREAUTH_DATA_LIST_PDU,
                (PVOID *) &ErrorPreAuth
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to unpack pre-auth data from error message. %ws, line %d\n", THIS_FILE, __LINE__));

        //
        // This error code isn't particularly informative but we were unable to get the
        // error information so this is the best we can do.
        //

        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Make sure the two structures are similar
    //

    DsysAssert(FIELD_OFFSET(KERB_PREAUTH_DATA_LIST,next) == FIELD_OFFSET(KERB_PA_DATA_LIST,next));
    DsysAssert(FIELD_OFFSET(KERB_PREAUTH_DATA_LIST,value) == FIELD_OFFSET(KERB_PA_DATA_LIST,value));
    DsysAssert(sizeof(KERB_PREAUTH_DATA_LIST) == sizeof(KERB_PA_DATA_LIST));

    *PreAuthData = (PKERB_PA_DATA_LIST *) ErrorPreAuth;
    ErrorPreAuth = NULL;

Cleanup:

    if (ErrorPreAuth != NULL)
    {
        KerbFreeData(PKERB_PREAUTH_DATA_LIST_PDU,ErrorPreAuth);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAddPacRequestPreAuth
//
//  Synopsis:   Add the pac-request preauth data to either requst a pac
//              or request that no pac be included
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbAddPacRequestPreAuth(
    OUT PKERB_PA_DATA_LIST * PreAuthData,
    IN ULONG TicketFlags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_PA_DATA_LIST ListElement = NULL;
    PKERB_PA_DATA_LIST LastElement = NULL;
    KERB_PA_PAC_REQUEST PacRequest = {0};

    ListElement = (PKERB_PA_DATA_LIST) KerbAllocate(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if ((TicketFlags & KERB_GET_TICKET_NO_PAC) != 0 )
    {
        PacRequest.include_pac = FALSE;
    }
    else
    {
        PacRequest.include_pac = TRUE;
    }

    //
    // Marshall the type into the list element.
    //

    if (!KERB_SUCCESS(KerbPackData(
                        &PacRequest,
                        KERB_PA_PAC_REQUEST_PDU,
                        (PULONG) &ListElement->value.preauth_data.length,
                        (PUCHAR *) &ListElement->value.preauth_data.value
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    ListElement->value.preauth_data_type = KRB5_PADATA_PAC_REQUEST;

    //
    // We want this to go at the end, so that it will override any other
    // pa-data that may enable a PAC.
    //

    LastElement = *PreAuthData;
    if (LastElement != NULL)
    {
        while (LastElement->next != NULL)
        {
            LastElement = LastElement->next;
        }
        LastElement->next = ListElement;
    }
    else
    {
        *PreAuthData = ListElement;
    }

    ListElement->next = NULL;
    ListElement = NULL;

Cleanup:
    if (ListElement != NULL)
    {
        KerbFreePreAuthData(
            ListElement
            );
    }

    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbPingWlBalloon
//
//  Synopsis:   Opens and pulses winlogon event, so they can pop up the balloon,
//              informing user of bad pwd, or expired pwd
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session for which to acquire a ticket
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//
//
//
//

#define KERBEROS_NOTIFICATION_EVENT_NAME             L"WlballoonKerberosNotificationEventName"

BOOLEAN
KerbPingWlBalloon(
    PLUID Luid
    )
{
    HANDLE              EventHandle;
    WCHAR               Event[512];

    wsprintfW(
        Event,
        L"Global\\%08x%08x_%s",
        Luid->HighPart,
        Luid->LowPart,
        KERBEROS_NOTIFICATION_EVENT_NAME
        );

    EventHandle = OpenEventW(EVENT_MODIFY_STATE, FALSE, Event);

    if (EventHandle == NULL)
    {
        D_DebugLog((DEB_TRACE, "Opening winlogon event %S failed %x\n", Event, GetLastError()));
        return FALSE;
    }

    if (!SetEvent(EventHandle))
    {
        D_DebugLog((DEB_ERROR, "SETTING winlogon event %S failed %x\n", Event, GetLastError()));
    }


    if (EventHandle != NULL)
    {
        CloseHandle(EventHandle);
    }

    return TRUE;

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbGetAuthenticationTicket
//
//  Synopsis:   Gets an AS ticket for the specified logon session
//
//  Effects:
//
//  Arguments:  LogonSession - Logon session for which to acquire a ticket
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success
//
//
//  Notes:      The retry logic here is complex. The idea is that we
//              shouldn't retry more than once for any particular failure.
//
//
//--------------------------------------------------------------------------

#define KERB_RETRY_ETYPE_FAILURE        0x0001
#define KERB_RETRY_TIME_FAILURE         0x0002
#define KERB_RETRY_PASSWORD_FAILURE     0x0004
#define KERB_RETRY_WRONG_PREAUTH        0x0008
#define KERB_RETRY_USE_TCP              0x0010
#define KERB_RETRY_CALL_PDC             0x0020
#define KERB_RETRY_SALT_FAILURE         0x0040
#define KERB_RETRY_WITH_ACCOUNT         0x0080
#define KERB_RETRY_BAD_REALM            0x0100
#define KERB_RETRY_PKINIT               0x0200
#define KERB_RETRY_BAD_KDC              0x0400

NTSTATUS
KerbGetAuthenticationTicket(
    IN OUT PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN BOOLEAN SupplyPreauth,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN PUNICODE_STRING ServerRealm,
    IN PKERB_INTERNAL_NAME ClientFullName,
    IN ULONG TicketFlags,
    IN ULONG CacheFlags,
    OUT OPTIONAL PKERB_TICKET_CACHE_ENTRY * TicketCacheEntry,
    OUT OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey,
    OUT PUNICODE_STRING CorrectRealm
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS OldStatus = STATUS_SUCCESS;
    NTSTATUS ExtendedStatus = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    KERBERR LastKerbErr = KDC_ERR_NONE;
    KERB_KDC_REQUEST TicketRequest = {0};
    PKERB_KDC_REQUEST_BODY RequestBody;
    PULONG CryptVector = NULL;
    BOOLEAN LogonSessionsLocked = FALSE;
    PKERB_KDC_REPLY KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY ReplyBody = NULL;
    PKERB_TICKET_CACHE_ENTRY CacheEntry = NULL;
    TimeStamp TempTime;
    KERB_MESSAGE_BUFFER RequestMessage = {0, NULL};
    KERB_MESSAGE_BUFFER ReplyMessage = {0, NULL};
    UNICODE_STRING ClientName = NULL_UNICODE_STRING;
    PKERB_ENCRYPTION_KEY ClientKey;
    ULONG RetryFlags = 0;
    BOOLEAN CalledPDC = FALSE;
    PKERB_PRIMARY_CREDENTIAL PrimaryCredentials = NULL;
    BOOLEAN PreAuthDone = FALSE;
    PKERB_ERROR ErrorMessage = NULL;
    PKERB_PA_DATA_LIST * OldPreAuthData = NULL;
#ifndef WIN32_CHICAGO
    LARGE_INTEGER TimeSkew = {0,0};
#else // WIN32_CHICAGO
    TimeStamp TimeSkew = 0;
#endif // WIN32_CHICAGO
    LONG NameType = KRB_NT_MS_PRINCIPAL;
    BOOLEAN UsedAlternateName = FALSE;
    PKERB_MIT_REALM MitRealm = NULL;
    PKERB_INTERNAL_NAME LocalServiceName = NULL;
    PKERB_EXT_ERROR pExtendedError = NULL;
    BOOLEAN UsedCredentials = FALSE;
    KERB_ENCRYPTION_KEY EncryptionKey = {0};
    PKERB_HOST_ADDRESSES HostAddresses = NULL;
    PKERB_CRYPT_LIST CryptList = NULL;
    UNICODE_STRING ClientRealm = {0};
    ULONG KdcOptions;
    ULONG KdcFlagOptions, AdditionalFlags = 0;
    BOOLEAN DoLogonRetry = FALSE;
    BOOLEAN DoTcpRetry = FALSE;
    BOOLEAN DoPreauthRetry = FALSE;
    BOOLEAN DoAccountLookup = FALSE;
    BOOLEAN IncludeIpAddresses = FALSE;
    BOOLEAN IncludeNetbiosAddresses = TRUE;
    LUID SystemLuid = SYSTEM_LUID;
    

    D_DebugLog((DEB_TRACE, "KerbGetAuthenticationTicket getting authentication ticket for client "));
    D_KerbPrintKdcName((DEB_TRACE, ClientFullName));
    D_DebugLog((DEB_TRACE, "KerbGetAuthenticationTicket for service in realm %wZ, ", ServerRealm));
    D_KerbPrintKdcName((DEB_TRACE, ServiceName));

    //
    // Initialize variables to NULL
    //

    RequestBody = &TicketRequest.request_body;
    RtlInitUnicodeString(
        CorrectRealm,
        NULL
        );

    if ((ClientFullName->NameCount == 0) || (ClientFullName->Names[0].Length == 0))
    {
        D_DebugLog((DEB_WARN, "KerbGetServiceTicket not requesting ticket for blank server name\n"));
        Status = STATUS_NO_SUCH_USER;
        goto Cleanup;
    }

    //
    // Build the request
    //

    KdcOptions = KERB_DEFAULT_TICKET_FLAGS;

    //
    // The domain name may be null - if so, use our domain for now.
    //

    //
    // Check to see if the domain is an MIT realm
    //

    if (KerbLookupMitRealm(
            ServerRealm,
            &MitRealm,
            &UsedAlternateName
            ) ||
        ((TicketFlags & KERB_GET_AUTH_TICKET_NO_CANONICALIZE) != 0))
    {
        DsysAssert(((TicketFlags & KERB_GET_AUTH_TICKET_NO_CANONICALIZE) != 0) ||
                   (MitRealm != NULL));

        //
        // So the user is getting a ticket from an MIT realm. This means
        // we don't ask for name canonicalization.
        //

        KdcOptions &= ~KERB_KDC_OPTIONS_name_canonicalize;                                      
    }

    KdcFlagOptions = KerbConvertUlongToFlagUlong(KdcOptions);
    RequestBody->kdc_options.value = (PUCHAR) &KdcFlagOptions ;
    RequestBody->kdc_options.length = sizeof(ULONG) * 8;

    RequestBody->nonce = KerbAllocateNonce();

    TempTime = KerbGlobalWillNeverTime;

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->endtime,
        NULL,
        &TempTime
        );

    KerbConvertLargeIntToGeneralizedTime(
        &RequestBody->KERB_KDC_REQUEST_BODY_renew_until,
        NULL,
        &TempTime
        );

    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_renew_until_present;

    //
    // Lock down the logon session while we build the request.
    //

    DsysAssert( !LogonSessionsLocked );
    KerbReadLockLogonSessions(LogonSession);
    LogonSessionsLocked = TRUE;

    //
    // If credentials were supplied, use the primary creds from there
    //

    if (ARGUMENT_PRESENT(Credential) && (Credential->SuppliedCredentials != NULL))
    {
        UsedCredentials = TRUE;

        //
        // Special case hack for callers using machinename$ / domain, w/ no password.
        // always use the current password of the local system luid.
        //
        if (( Credential->CredentialFlags & KERB_CRED_LS_DEFAULT ) &&
            ( RtlEqualLuid(&LogonSession->LogonId, &SystemLuid) ))
        {   
            Status = KerbReplacePasswords(Credential->SuppliedCredentials, &LogonSession->PrimaryCredentials);
            if (!NT_SUCCESS( Status ))
            {
                goto Cleanup;
            }
        } 
        
        PrimaryCredentials = Credential->SuppliedCredentials;
        
        D_DebugLog((DEB_TRACE_CRED, "KerbGetAuthenticationTicket using supplied credentials %wZ\\%wZ to ",
            &PrimaryCredentials->DomainName,
            &PrimaryCredentials->UserName
            ));
        D_KerbPrintKdcName((DEB_TRACE_CRED, ServiceName));

    }
    else if (ARGUMENT_PRESENT(CredManCredentials))
    {
        UsedCredentials = TRUE;

        PrimaryCredentials = CredManCredentials->SuppliedCredentials;
        D_DebugLog((DEB_TRACE_CRED, "KerbGetAuthenticationTicket using cred manager credentials %wZ\\%wZ to \n",
            &PrimaryCredentials->DomainName,
            &PrimaryCredentials->UserName
            ));
        D_KerbPrintKdcName((DEB_TRACE_CRED, ServiceName));
    }
    else
    {
        PrimaryCredentials = &LogonSession->PrimaryCredentials;
        D_DebugLog((DEB_TRACE_CRED, "KerbGetAuthenticationTicket using default credentials %wZ\\%wZ to ",
            &PrimaryCredentials->DomainName,
            &PrimaryCredentials->UserName
            ));

        D_KerbPrintKdcName((DEB_TRACE_CRED, ServiceName));
    }

    if ((PrimaryCredentials->Passwords == NULL) &&
        (PrimaryCredentials->PublicKeyCreds == NULL))
    {
        D_DebugLog((DEB_ERROR,"Can't get AS ticket with no password. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = SEC_E_NO_CREDENTIALS;
        goto Cleanup;
    }

    //
    // Copy all the names into the request message
    //

    //
    // Build the client name from the client domain & user name.
    //

    KerbErr = KerbConvertKdcNameToPrincipalName(
                &RequestBody->KERB_KDC_REQUEST_BODY_client_name,
                ClientFullName
                );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_client_name_present;

    //
    // If we are talking to an NT Domain, or are using an MIT compatible
    // name type, convert the service name as is is
    //

    KerbErr = KerbConvertKdcNameToPrincipalName(
                    &RequestBody->KERB_KDC_REQUEST_BODY_server_name,
                    ServiceName
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RequestBody->bit_mask |= KERB_KDC_REQUEST_BODY_server_name_present;

    //
    // Build the list of host addresses. We don't do this for all
    // MIT realms
    //

    if ( KerbGlobalUseClientIpAddresses ) {

        IncludeIpAddresses = TRUE;
    }

    //
    // MIT realms never care to see the NetBIOS addresses
    //

    if ( MitRealm != NULL ) {

        IncludeNetbiosAddresses = FALSE;

        if (( MitRealm->Flags & KERB_MIT_REALM_SEND_ADDRESS ) != 0 ) {

            IncludeIpAddresses = TRUE;
        }
    }

    //
    // We always put the NetBIOS name of the client into the request,
    // as this is how the workstations restriction is enforced.
    // It is understood that the mechanism is bogus, as the client can spoof
    // the netbios address, but that's okay -- we're only doing this for
    // feature preservation, this is no worse than W2K.
    //
    // The IP address is only put in based on a registry setting or for MIT
    // realms that explicity request it, as having them in the request would
    // break us when going through NATs.
    //

    Status = KerbBuildHostAddresses(
                 IncludeIpAddresses,
                 IncludeNetbiosAddresses,
                 &HostAddresses
                 );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if ( HostAddresses )
    {
        RequestBody->addresses = HostAddresses;
        RequestBody->bit_mask |= addresses_present;
    }

    TicketRequest.version = KERBEROS_VERSION;
    TicketRequest.message_type = KRB_AS_REQ;

PreauthRestart:
    //
    // Lock down the logon session while we build the request.
    // This is done so that when we try the second time around, the logon
    // session list is locked
    //

    if (!LogonSessionsLocked)
    {
        KerbReadLockLogonSessions(LogonSession);
        LogonSessionsLocked = TRUE;
    }

    DoPreauthRetry = FALSE;
    if (RequestMessage.Buffer != NULL)
    {
        MIDL_user_free(RequestMessage.Buffer);
        RequestMessage.Buffer = NULL;
    }

    // Free this in case we are doing a retry

    KerbFreeRealm(
        &RequestBody->realm
        );

    KerbErr = KerbConvertUnicodeStringToRealm(
                &RequestBody->realm,
                ServerRealm
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Stick the PA data in the request, if requested.  This is the norm,
    // unless we're doing S4U location.
    //
    if ( SupplyPreauth )
    {
    
        DsysAssert(TicketRequest.KERB_KDC_REQUEST_preauth_data == NULL);
    
        Status = KerbGetPreAuthDataForRealm(
                    PrimaryCredentials,
                    ServerRealm,
                    ServiceName,
                    (OldPreAuthData != NULL) ? *OldPreAuthData : NULL,
                    &TimeSkew,
                    (RetryFlags & KERB_RETRY_PASSWORD_FAILURE) != 0,
                    RequestBody->nonce,
                    LastKerbErr,
                    &TicketRequest.KERB_KDC_REQUEST_preauth_data,
                    &EncryptionKey,
                    &CryptList,
                    &PreAuthDone
                    );
    
        if (!NT_SUCCESS(Status))
        {
            //
            // If we couldn't build the preauth, try again
            //
    
            if (Status == STATUS_WRONG_PASSWORD)
            {
                if ((RetryFlags & KERB_RETRY_PASSWORD_FAILURE) == 0)
                {
                    RetryFlags |= KERB_RETRY_PASSWORD_FAILURE;
                    goto PreauthRestart;
                }
                else if ((RetryFlags & KERB_RETRY_SALT_FAILURE) == 0)
                {
                    RetryFlags |= KERB_RETRY_SALT_FAILURE;
                    RetryFlags &= ~KERB_RETRY_PASSWORD_FAILURE;
                    goto PreauthRestart;
                }
            } 
            else if (Status == STATUS_UNSUPPORTED_PREAUTH)
            {
    
                  // Log this, every time, as this is impossible to triage otherwise
    
                 KerbReportKerbError(
                    ServiceName,
                    ServerRealm,
                    NULL,
                    Credential,
                    KLIN(FILENO,__LINE__),
                    NULL,
                    KDC_ERR_PADATA_TYPE_NOSUPP,
                    NULL,
                    TRUE
                    );
            }
    
            DebugLog((DEB_ERROR,"GetAuthenticationTicket: Failed to build pre-auth data: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }
    }

    //
    // Build crypt list
    //

    KerbFreeCryptList(
        RequestBody->encryption_type
        );

    RequestBody->encryption_type = NULL;

    if (PrimaryCredentials->Passwords != NULL) {

        if (!KERB_SUCCESS(KerbConvertKeysToCryptList(
                            &RequestBody->encryption_type,
                            PrimaryCredentials->Passwords
                            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

    } else {

        ULONG CryptTypes[KERB_MAX_CRYPTO_SYSTEMS];
        ULONG CryptTypeCount = KERB_MAX_CRYPTO_SYSTEMS;

        //
        // Include all our crypt types as supported
        //

        Status = CDBuildIntegrityVect(
                    &CryptTypeCount,
                    CryptTypes
                    );

        DsysAssert(NT_SUCCESS(Status));

        if (!KERB_SUCCESS(KerbConvertArrayToCryptList(
                            &RequestBody->encryption_type,
                            CryptTypes,
                            CryptTypeCount,
                            FALSE)))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }

    //
    // Add in preauth generated encryption types
    //

    if (CryptList != NULL)
    {
        PKERB_CRYPT_LIST Next;
        Next = CryptList;
        while (Next != NULL)
        {
            if (Next->next == NULL)
            {
                Next->next = RequestBody->encryption_type;
                RequestBody->encryption_type = CryptList;
                CryptList = NULL;
                break;
            }
            Next = Next->next;

        }
    }

    //
    // If the we need to either request the presence or absence of a PAC, do
    // it here
    //

    if (MitRealm == NULL)
    {
        Status = KerbAddPacRequestPreAuth(
                    &TicketRequest.KERB_KDC_REQUEST_preauth_data,
                    TicketFlags
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    if (TicketRequest.KERB_KDC_REQUEST_preauth_data != NULL)
    {
        TicketRequest.bit_mask |= KERB_KDC_REQUEST_preauth_data_present;
    }

    //
    // Pack the request
    //

    KerbErr = KerbPackAsRequest(
                &TicketRequest,
                &RequestMessage.BufferSize,
                &RequestMessage.Buffer
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

RetryLogon:

    DoLogonRetry = FALSE;

    //
    // Unlock the logon sessions and credential so we don't cause problems
    // waiting for a network request to complete.
    //


    if (LogonSessionsLocked)
    {
        KerbUnlockLogonSessions(LogonSession);
        LogonSessionsLocked = FALSE;
    }

    D_DebugLog((DEB_TRACE_KDC,"KerbGetAuthenticationTicket: Calling KDC\n"));

RetryWithTcp:

    if (ReplyMessage.Buffer != NULL)
    {
        MIDL_user_free(ReplyMessage.Buffer);
        ReplyMessage.Buffer = NULL;
    }

    DoTcpRetry = FALSE;

    Status = KerbMakeKdcCall(
                ServerRealm,
                (DoAccountLookup && ClientFullName->NameType == KRB_NT_PRINCIPAL) ? &ClientFullName->Names[0] : NULL,        // send the client name, if available
                (RetryFlags & KERB_RETRY_CALL_PDC) != 0,
                (RetryFlags & KERB_RETRY_USE_TCP) != 0,
                &RequestMessage,
                &ReplyMessage,
                AdditionalFlags,
                &CalledPDC
                );

    D_DebugLog((DEB_TRACE_KDC,"KerbGetAuthenticationTicket: Returned from KDC status 0x%x\n",
        Status ));

    if (!NT_SUCCESS(Status))
    {
#if DBG
        if (Status != STATUS_NO_LOGON_SERVERS)
        {
            DebugLog((DEB_ERROR,"Failed KerbMakeKdcCall for AS request: 0x%x. %ws, line %d\n", Status, THIS_FILE, __LINE__));
        }
#endif

        //
        // If this is the second time around (on the PDC) and this fails,
        // use the original error
        //

        if (OldStatus != STATUS_SUCCESS)
        {
            Status = OldStatus;
        }
        goto Cleanup;
    }

    //
    // Free the preauth data now, as it is not necessary any more
    //

    KerbFreePreAuthData( TicketRequest.KERB_KDC_REQUEST_preauth_data );
    TicketRequest.KERB_KDC_REQUEST_preauth_data = NULL;

    KerbErr = KerbUnpackAsReply(
                ReplyMessage.Buffer,
                ReplyMessage.BufferSize,
                &KdcReply
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_WARN,"Failed to unpack KDC reply as AS: 0x%x\n", KerbErr ));

        //
        // Try to unpack it as  kerb_error
        //

        if (ErrorMessage != NULL)
        {
            KerbFreeKerbError(ErrorMessage);
            ErrorMessage = NULL;
        }

        KerbErr =  KerbUnpackKerbError(
                        ReplyMessage.Buffer,
                        ReplyMessage.BufferSize,
                        &ErrorMessage
                        );
        if (KERB_SUCCESS(KerbErr))
        {
           //
           // Let's see if there's any extended error here
           //
           if (ErrorMessage->bit_mask & error_data_present)
           {
              if (NULL != pExtendedError) // might be a re-auth failure. Don't leak!
              {
                 KerbFree(pExtendedError);
                 pExtendedError = NULL;
              }

              KerbErr = KerbUnpackErrorData(
                  ErrorMessage,
                  &pExtendedError
                  );

              if (KERB_SUCCESS(KerbErr) && (EXT_CLIENT_INFO_PRESENT(pExtendedError)))
              {
                 ExtendedStatus = pExtendedError->status;
              }
           }

           KerbErr = (KERBERR) ErrorMessage->error_code;
           LastKerbErr = KerbErr;
           DebugLog((DEB_ERROR,"KerbCallKdc failed: error 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));

           Status = KerbMapKerbError(KerbErr);

           KerbReportKerbError(
                ServiceName,
                ServerRealm,
                LogonSession,
                Credential,
                KLIN(FILENO,__LINE__),
                ErrorMessage,
                KerbErr,
                pExtendedError,
                FALSE
                );

            if (KerbErr == KRB_ERR_RESPONSE_TOO_BIG)
            {
                if ((RetryFlags & KERB_RETRY_USE_TCP) != 0)
                {
                    D_DebugLog((DEB_ERROR,"Got response too big twice. %ws, %d\n",
                            THIS_FILE, __LINE__ ));
                    Status = STATUS_LOGON_FAILURE;
                    goto Cleanup;
                }
                RetryFlags |= KERB_RETRY_USE_TCP;
                DoTcpRetry = TRUE;
            }

            //
            // If we didn't try the PDC, try it now.
            //

            else if (KerbErr == KDC_ERR_KEY_EXPIRED)
            {
                if (CalledPDC ||
                    ((RetryFlags & KERB_RETRY_CALL_PDC) != 0) ||
                    (!KerbGlobalRetryPdc))
                {
                   // If we've already tried the PDC, then we should
                   // have some extended info w.r.t. what's up w/
                   // this password.
                   if (EXT_CLIENT_INFO_PRESENT(pExtendedError))
                   {
                      Status = ExtendedStatus;
                   }
                   else
                   {
                      Status = KerbMapKerbError(KerbErr);
                   }
                   goto Cleanup;
                }
                RetryFlags |= KERB_RETRY_CALL_PDC;
                DoLogonRetry = TRUE;
            }

            //
            // Check for time skew. If so, calculate the skew and retry
            //

            else if (KerbErr == KRB_AP_ERR_SKEW)
            {
                TimeStamp CurrentTime;
                TimeStamp KdcTime;

                if ((RetryFlags & KERB_RETRY_TIME_FAILURE) != 0)
                {
                    Status = KerbMapKerbError(KerbErr);
                    goto Cleanup;
                }

                RetryFlags |= KERB_RETRY_TIME_FAILURE;
                DoPreauthRetry = TRUE;

                GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);


                KerbConvertGeneralizedTimeToLargeInt(
                    &KdcTime,
                    &ErrorMessage->server_time,
                    ErrorMessage->server_usec
                    );

                KerbSetTime(&TimeSkew, KerbGetTime(KdcTime) - KerbGetTime(CurrentTime));
                KerbUpdateSkewTime(TRUE);
            }

            //
            // Check for pre-authenication required
            //

            else if ((KerbErr == KDC_ERR_PREAUTH_FAILED) ||
                     (KerbErr == KRB_AP_ERR_BAD_INTEGRITY))
            {
                //
                // This is a bad password failure.
                //

                if ((RetryFlags & KERB_RETRY_PASSWORD_FAILURE) == 0)
                {
                    RetryFlags |= KERB_RETRY_PASSWORD_FAILURE;
                }
                else if ((RetryFlags & KERB_RETRY_SALT_FAILURE) != 0)
                {
                    Status = KerbMapKerbError(KerbErr);
                    goto Cleanup;
                }
                else
                {
                    RetryFlags |= KERB_RETRY_SALT_FAILURE;
                    RetryFlags &= ~KERB_RETRY_PASSWORD_FAILURE;
                }

                //
                // In this case, there may be data in the error data
                //

                KerbFreeData(
                    PKERB_PREAUTH_DATA_LIST_PDU,
                    OldPreAuthData
                    );

                OldPreAuthData = NULL;

                (VOID) KerbUnpackErrorPreauth(
                                ErrorMessage,
                                &OldPreAuthData
                                );

                DoPreauthRetry = TRUE;



            }
            else if ((KerbErr == KDC_ERR_ETYPE_NOTSUPP) ||
                     (KerbErr == KDC_ERR_PREAUTH_REQUIRED))
            {
                NTSTATUS TempStatus;

                if (KerbErr == KDC_ERR_ETYPE_NOTSUPP)
                {
                    if ((RetryFlags & KERB_RETRY_ETYPE_FAILURE) != 0)
                    {
                        Status = KerbMapKerbError(KerbErr);
                        goto Cleanup;
                    }
                    RetryFlags |= KERB_RETRY_ETYPE_FAILURE;
                }
                else
                {
                    if ((RetryFlags & KERB_RETRY_WRONG_PREAUTH) != 0)
                    {
                        Status = KerbMapKerbError(KerbErr);
                        goto Cleanup;
                    }
                    RetryFlags |= KERB_RETRY_WRONG_PREAUTH;

                }

                //
                // In this case, there should be etype info in the error data
                //

                KerbFreeData(
                    PKERB_PREAUTH_DATA_LIST_PDU,
                    OldPreAuthData
                    );

                OldPreAuthData = NULL;

                TempStatus = KerbUnpackErrorPreauth(
                                ErrorMessage,
                                &OldPreAuthData
                                );
                if (!NT_SUCCESS(TempStatus))
                {
                    D_DebugLog((DEB_ERROR, "KerbGetAuthenticationTicket failed to unpack error for preauth : 0x%x. %ws, line %d\n", TempStatus, THIS_FILE, __LINE__));
                    D_DebugLog((DEB_ERROR, "KerbGetAuthenticationTicket client was "));
                    D_KerbPrintKdcName((DEB_ERROR, ClientFullName));
                    D_DebugLog((DEB_ERROR, "KerbGetAuthenticationTicket for service in realm %wZ : ", ServerRealm));
                    D_KerbPrintKdcName((DEB_ERROR, ServiceName));
                    DsysAssert(!NT_SUCCESS(Status));
                    goto Cleanup;
                }

                if ( SupplyPreauth )
                {
                    DoPreauthRetry = TRUE;
                }
                
            }
            //
            // There's something wrong w/ the client's account.  In all cases
            // this error should be accompanied by an extended error packet.
            // and no retry should be attempted (see restrict.cxx)
            //
            else if ((KerbErr == KDC_ERR_CLIENT_REVOKED ||
                      KerbErr == KDC_ERR_POLICY ) &&
                     EXT_CLIENT_INFO_PRESENT(pExtendedError))
            {
               Status = pExtendedError->status;
               goto Cleanup;
            }
            //
            // For PKINIT, the client not trusted error indicates that SCLogon failed
            // as the client certificate was bogus.  Log an error here.
            // NOTE:  The extended status is a wincrypt error, so just return the
            // normal status (
            //
            else if (KerbErr == KDC_ERR_CLIENT_NOT_TRUSTED)
            {

                ULONG PolicyStatus = ERROR_NOT_SUPPORTED; // w2k DCs won't likely have this data.

                //
                // WE may have trust status on the client certificate
                // use this to create an event log.  NOte:  this is only
                // going to happen if logon was against Whistler DC
                //
                // W2K Dcs returning errors will get mapped to generic
                // error.
                //
                if (EXT_CLIENT_INFO_PRESENT(pExtendedError))
                {
                    PolicyStatus = pExtendedError->status;
                }

                KerbReportPkinitError(PolicyStatus, NULL);
                Status = KerbMapCertChainError(PolicyStatus, TRUE);
                DebugLog((DEB_ERROR, "Client certificate didn't validate on KDC - %x\n", PolicyStatus));

            }
            else if ((KerbErr == KDC_ERR_PADATA_TYPE_NOSUPP) &&
                     (EXT_CLIENT_INFO_PRESENT(pExtendedError)))
            {
                if ((RetryFlags & KERB_RETRY_PKINIT) != 0)
                {
                    Status = KerbMapKerbError(KerbErr);
                    goto Cleanup;
                }

                //
                // no KDC certificate error in edata, do a retry against
                // another DC
                //
                if (pExtendedError->status == STATUS_PKINIT_FAILURE)
                {
                    RetryFlags |= KERB_RETRY_PKINIT;
                    AdditionalFlags = DS_FORCE_REDISCOVERY;
                    DoLogonRetry = TRUE;
                }
            }
            //
            // Check if the server didn't know the client principal
            //

            else if (KerbErr == KDC_ERR_C_PRINCIPAL_UNKNOWN )
            {

               if ((RetryFlags & KERB_RETRY_WITH_ACCOUNT) != 0)
               {
                  Status = KerbMapKerbError(KerbErr);
                  goto Cleanup;
               }

               RetryFlags |= KERB_RETRY_WITH_ACCOUNT;

               DoAccountLookup = TRUE;

               if ((ErrorMessage->bit_mask & client_realm_present) != 0)
               {
                  UNICODE_STRING TempRealm;

                  if (!KERB_SUCCESS(KerbConvertRealmToUnicodeString(
                     &TempRealm,
                     &ErrorMessage->client_realm
                     )))
                  {
                     Status = STATUS_INSUFFICIENT_RESOURCES;
                     goto Cleanup;
                  }

                  if (!RtlEqualUnicodeString(
                     ServerRealm,
                     &TempRealm,
                     TRUE            // case insensitive
                     ))
                  {
                     D_DebugLog((DEB_TRACE,"Received UPN referral to another domain: %wZ\n",
                                 &TempRealm ));
                     //
                     // Return the correct realm so the caller will retry
                     //

                     *CorrectRealm = TempRealm;
                     TempRealm.Buffer = NULL;
                     DoAccountLookup = FALSE;
                  }

                   KerbFreeString( &TempRealm );
               }


               if (DoAccountLookup)
               {
                  DoLogonRetry = TRUE;
               }
            }
            //
            // Something's wrong w/ the KDC...  Try another one, but 1 time only
            //
            else if (KerbErr == KDC_ERR_SVC_UNAVAILABLE)
            {

                if ((RetryFlags & KERB_RETRY_BAD_KDC) != 0)
                {
                    Status = KerbMapKerbError(KerbErr);
                    goto Cleanup;
                }

                D_DebugLog((DEB_ERROR, "Retrying new KDC\n"));

                AdditionalFlags = DS_FORCE_REDISCOVERY;
                DoLogonRetry = TRUE;
                RetryFlags |= KERB_RETRY_BAD_KDC;
            }
            else if (KerbErr == KDC_ERR_WRONG_REALM)
            {
               if ((RetryFlags & KERB_RETRY_BAD_REALM) != 0)
               {
                  Status = KerbMapKerbError(KerbErr);
                  goto Cleanup;
               }

               RetryFlags |= KERB_RETRY_BAD_REALM;

               AdditionalFlags = DS_FORCE_REDISCOVERY; // possibly bad cached DC
               DoLogonRetry = TRUE;

               if ((ErrorMessage->bit_mask & client_realm_present) != 0)
               {
                  UNICODE_STRING TempRealm;
                  if (!KERB_SUCCESS(KerbConvertRealmToUnicodeString(
                     &TempRealm,
                     &ErrorMessage->client_realm
                     )))
                  {
                     Status = STATUS_INSUFFICIENT_RESOURCES;
                     goto Cleanup;
                  }

                  if (!RtlEqualUnicodeString(
                     ServerRealm,
                     &TempRealm,
                     TRUE            // case insensitive
                     ))
                  {
                     D_DebugLog((DEB_TRACE,"Received UPN referral to another domain: %wZ\n",
                                 &TempRealm ));
                    //
                    // Return the correct realm so the caller will retry
                    //

                     *CorrectRealm = TempRealm;
                     TempRealm.Buffer = NULL;
                     DoLogonRetry = FALSE;  // this is a referral, not a bad cache entry
                  }

                  KerbFreeString( &TempRealm );

               }
            }

            //
            // Retry if need be
            //

            if (DoPreauthRetry)
            {
                goto PreauthRestart;
            }
            else if (DoLogonRetry)
            {
                goto RetryLogon;
            }
            else if (DoTcpRetry)
            {
                goto RetryWithTcp;
            }
        }
        else
        {
           DebugLog((DEB_ERROR, "Failed to unpack KDC reply as AS or Error: 0x%x\n", KerbErr));
           Status = STATUS_INTERNAL_ERROR;
        }

        goto Cleanup;
    }

    //
    // Update the skew counter if necessary
    //

    if ((RetryFlags & KERB_RETRY_TIME_FAILURE) == 0)
    {
        KerbUpdateSkewTime(FALSE);

    }

    //
    // Now unpack the reply body:
    //

    DsysAssert( !LogonSessionsLocked );
    KerbWriteLockLogonSessions(LogonSession);
    LogonSessionsLocked = TRUE;

    //
    // if there was any pre auth data, process it now
    //

    if ((KdcReply->bit_mask & KERB_KDC_REPLY_preauth_data_present) != 0)
    {
        Status = KerbGetPreAuthDataForRealm(
                    PrimaryCredentials,
                    ServerRealm,
                    ServiceName,
                    (PKERB_PA_DATA_LIST) KdcReply->KERB_KDC_REPLY_preauth_data,
                    &TimeSkew,
                    (RetryFlags & KERB_RETRY_PASSWORD_FAILURE) != 0,
                    RequestBody->nonce,
                    KDC_ERR_NONE,
                    &TicketRequest.KERB_KDC_REQUEST_preauth_data,
                    &EncryptionKey,
                    &CryptList,
                    &PreAuthDone
                    );
        if (!NT_SUCCESS(Status))
        {
           if (Status == STATUS_UNSUPPORTED_PREAUTH )
           {
               // Log this, every time, as this is impossible to triage otherwise
               KerbReportKerbError(
                   ServiceName,
                   ServerRealm,
                   NULL,
                   Credential,
                   KLIN(FILENO,__LINE__),
                   NULL,
                   KDC_ERR_PADATA_TYPE_NOSUPP,
                   NULL,
                   TRUE
                   );
           }

           D_DebugLog((DEB_ERROR,"Failed to post process pre-auth data: 0x%x. %ws, %d\n",Status, THIS_FILE, __LINE__));
           goto Cleanup;
        }

        KerbFreeCryptList(CryptList);
        CryptList = NULL;
    }

    //
    // If there is any preauth in the response, handle it
    //

    if (EncryptionKey.keyvalue.value == NULL)
    {
        ClientKey = KerbGetKeyFromList(
                        PrimaryCredentials->Passwords,
                        KdcReply->encrypted_part.encryption_type
                        );

        DsysAssert(ClientKey != NULL);

        if (ClientKey == NULL)
        {
            D_DebugLog((DEB_ERROR,"Kdc returned reply with encryption type we don't support: %d. %ws, line %d\n",
                KdcReply->encrypted_part.encryption_type, THIS_FILE, __LINE__));
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }
    }
    else
    {
        //
        // Use the encryption key we have from the pre-auth data
        //

        ClientKey = &EncryptionKey;
    }

    KerbErr = KerbUnpackKdcReplyBody(
                &KdcReply->encrypted_part,
                ClientKey,
                KERB_ENCRYPTED_AS_REPLY_PDU,
                &ReplyBody
                );

    //
    // if we couldn't decrypt it and we have an old password around,
    // give it a try too before heading to the PDC.
    //

    if ((KerbErr == KRB_AP_ERR_MODIFIED) &&
        (PrimaryCredentials->OldPasswords != NULL) &&
        (EncryptionKey.keyvalue.value == NULL))
    {
        ClientKey = KerbGetKeyFromList(
                        PrimaryCredentials->OldPasswords,
                        KdcReply->encrypted_part.encryption_type
                        );
        if (ClientKey != NULL)
        {
            KerbErr = KerbUnpackKdcReplyBody(
                        &KdcReply->encrypted_part,
                        ClientKey,
                        KERB_ENCRYPTED_AS_REPLY_PDU,
                        &ReplyBody
                        );
        }
    }

    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to decrypt KDC reply body: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));

        //
        // If we didn't try the PDC, try it now.
        //

        if (((RetryFlags & KERB_RETRY_CALL_PDC) == 0) &&
             (KerbErr == KRB_AP_ERR_MODIFIED) &&
             (KerbGlobalRetryPdc))
        {
            RetryFlags |= KERB_RETRY_CALL_PDC;


            KerbFreeAsReply(KdcReply);
            KdcReply = NULL;

            ReplyMessage.Buffer = NULL;

            D_DebugLog((DEB_TRACE_CRED,"KerbGetAuthenticationTicket: Password wrong, trying PDC\n"));
            goto RetryLogon;
        }

        //
        // <HACK> - If we're doing a S4U location (e.g. SupplyPreauth == FALSE ) 
        // for an account that doesn't require preauth, and we've gotten back 
        // a response from the KDC that's *not* an error, return a wrong
        // password error to KerbGetS4UClientRealm. </HACK>
        //
        Status = (SupplyPreauth ?  STATUS_LOGON_FAILURE : STATUS_WRONG_PASSWORD );
        goto Cleanup;
    }

    //
    // Verify the nonce is correct:
    //

    if (RequestBody->nonce != ReplyBody->nonce)
    {
        D_DebugLog((DEB_ERROR,"AS Nonces don't match: 0x%x vs 0x%x. %ws, line %d\n",RequestBody->nonce, ReplyBody->nonce, THIS_FILE, __LINE__));
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Update the logon session with the information if we didn't use
    // supplied credentials.
    //

    {
        UNICODE_STRING TempName;
        UNICODE_STRING TempRealm;

        //
        // Get the new client realm & user name - if they are different
        // we will update the logon session. This is in case the user
        // logged on with a nickname (e.g. email name)
        //

        if (!KERB_SUCCESS(KerbConvertPrincipalNameToString(
                &ClientName,
                (PULONG) &NameType,
                &KdcReply->client_name
                )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // The KDC may hand back names with domains, so split the name
        // now.
        //

        Status = KerbSplitFullServiceName(
                    &ClientName,
                    &TempRealm,
                    &TempName
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if (!KERB_SUCCESS(KerbConvertRealmToUnicodeString(
                &ClientRealm,
                &KdcReply->client_realm
                )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        if (!RtlEqualUnicodeString(
                &PrimaryCredentials->UserName,
                &TempName,
                TRUE                // case insensitive
                )) {

            D_DebugLog((DEB_TRACE_LSESS,"UserName different in logon session & AS ticket: %wZ vs %wZ\n",
                &PrimaryCredentials->UserName,
                &TempName
                ));

            KerbFreeString(
                &PrimaryCredentials->UserName
                );

            Status = KerbDuplicateString(
                        &PrimaryCredentials->UserName,
                        &TempName
                        );

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }

        if (!RtlEqualUnicodeString(
                &PrimaryCredentials->DomainName,
                &ClientRealm,
                FALSE // case sensitive, specially for ext chars.
                )) {

            D_DebugLog((DEB_TRACE_LSESS, "Domain name is different in logon session & as ticket: %wZ vs %wZ\n",
                &PrimaryCredentials->DomainName,
                &ClientRealm
                ));

            KerbFreeString(
                &PrimaryCredentials->DomainName
                );
            PrimaryCredentials->DomainName = ClientRealm;
            ClientRealm.Buffer = NULL;
        }
    }

    //
    // Cache the ticket
    //

    DsysAssert(LogonSessionsLocked);

    //
    // Free the cleartext password as we now have a ticket acquired with them.
    //

    if (PrimaryCredentials->ClearPassword.Buffer != NULL)
    {
        RtlZeroMemory(
            PrimaryCredentials->ClearPassword.Buffer,
            PrimaryCredentials->ClearPassword.Length
            );
        KerbFreeString(&PrimaryCredentials->ClearPassword);
    }

    Status = KerbCreateTicketCacheEntry(
                KdcReply,
                ReplyBody,
                ServiceName,
                ServerRealm,
                CacheFlags,
                &PrimaryCredentials->AuthenticationTicketCache,
                &EncryptionKey,
                &CacheEntry
                );

    if (!NT_SUCCESS(Status))
    {
       if (Status == STATUS_TIME_DIFFERENCE_AT_DC &&
           ((RetryFlags & KERB_RETRY_TIME_FAILURE) == 0))
       {
          RetryFlags |= KERB_RETRY_TIME_FAILURE;
          KerbUpdateSkewTime(TRUE);
          D_DebugLog((DEB_WARN, "Retrying AS after trying to cache time invalid ticket\n"));
          goto PreauthRestart;
       }

       goto Cleanup;
    }

    if (ARGUMENT_PRESENT(TicketCacheEntry))
    {
        *TicketCacheEntry = CacheEntry;
        CacheEntry = NULL;
    }

    if (ARGUMENT_PRESENT(CredentialKey))
    {
        *CredentialKey = EncryptionKey;
        EncryptionKey.keyvalue.value = NULL;
    }

Cleanup:

    if (HostAddresses != NULL)
    {
        KerbFreeHostAddresses(HostAddresses);
    }

    if (ErrorMessage != NULL)
    {
        KerbFreeKerbError(ErrorMessage);
    }

    if (pExtendedError)
    {
        KerbFreeData(KERB_EXT_ERROR_PDU, pExtendedError);
    }

    if (LogonSessionsLocked)
    {
        KerbUnlockLogonSessions(LogonSession);
    }

    if (CryptVector != NULL)
    {
        KerbFree(CryptVector);
    }

    if (OldPreAuthData != NULL)
    {
        KerbFreeData(
            PKERB_PREAUTH_DATA_LIST_PDU,
            OldPreAuthData
            );
    }

    KerbFreePreAuthData( TicketRequest.KERB_KDC_REQUEST_preauth_data );

    KerbFreeCryptList(
        RequestBody->encryption_type
        );

    KerbFreeCryptList(
        CryptList
        );

    KerbFreeString(
        &ClientName
        );

    KerbFreeKdcName(
        &LocalServiceName
        );

    KerbFreeString(
        &ClientRealm
        );

    KerbFreePrincipalName(
        &RequestBody->KERB_KDC_REQUEST_BODY_client_name
        );

    KerbFreePrincipalName(
        &RequestBody->KERB_KDC_REQUEST_BODY_server_name
        );

    KerbFreeRealm(
        &RequestBody->realm
        );

    KerbFreeKdcReplyBody( ReplyBody );

    KerbFreeAsReply( KdcReply );

    if (CacheEntry != NULL)
    {
        KerbDereferenceTicketCacheEntry(CacheEntry);
    }

    if (ReplyMessage.Buffer != NULL)
    {
        MIDL_user_free(ReplyMessage.Buffer);
    }

    if (RequestMessage.Buffer != NULL)
    {
        MIDL_user_free(RequestMessage.Buffer);
    }

    KerbFreeKey(&EncryptionKey);
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetClientNameAndRealm
//
//  Synopsis:   Proceses the name & realm supplied by a client to determine
//              a name & realm to be sent to the KDC
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



NTSTATUS
KerbGetClientNameAndRealm(
    IN OPTIONAL LUID *pLogonId,
    IN PKERB_PRIMARY_CREDENTIAL PrimaryCreds,
    IN BOOLEAN SuppliedCreds,
    IN OPTIONAL PUNICODE_STRING SuppRealm,
    IN OUT OPTIONAL BOOLEAN * MitRealmUsed,
    IN BOOLEAN UseWkstaRealm,
    OUT PKERB_INTERNAL_NAME * ClientName,
    OUT PUNICODE_STRING ClientRealm
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG ParseFlags = 0;
    ULONG ProcessFlags = 0;
    BOOLEAN UseCertificateDomain = FALSE;
    PUNICODE_STRING UserName = NULL;

    UNICODE_STRING LocalMachineServiceName;
    LUID SystemLogonId = SYSTEM_LUID;

    KERBEROS_MACHINE_ROLE   Role = KerbGetGlobalRole();

    LocalMachineServiceName.Buffer = NULL;

    //
    // if the computer name has changed, we lie about the machineservicename,
    // since existing creds contain the wrong username
    //

    if (( KerbGlobalMachineNameChanged ) &&
        ( !SuppliedCreds ) &&
        ( pLogonId != NULL ) &&
        ( RtlEqualLuid(pLogonId, &SystemLogonId)))
    {
        D_DebugLog((DEB_WARN,"Netbios machine name change caused credential over-ride.\n"));

        KerbGlobalReadLock();
        Status = KerbDuplicateString( &LocalMachineServiceName, &KerbGlobalMachineServiceName );
        KerbGlobalReleaseLock();

        if(!NT_SUCCESS( Status ))
        {
            goto Cleanup;
        }

        UserName = &LocalMachineServiceName;
    } else {
        UserName = &PrimaryCreds->UserName;
    }


    //
    // Compute the parse flags
    //

    if (PrimaryCreds->DomainName.Length != 0)
    {
        ParseFlags |= KERB_CRACK_NAME_REALM_SUPPLIED;
    }
    else if (UseWkstaRealm)
    {
        //
        // Two choices here - Realmless workstation's don't have a
        // "realm" to use.  If we've got public key credentials, then try
        // using the name from the certifcate's subject.
        //
        if (( Role == KerbRoleRealmlessWksta ) &&
            ( PrimaryCreds->PublicKeyCreds != NULL ) &&
            ( PrimaryCreds->PublicKeyCreds->AlternateDomainName.Buffer != NULL ))
        {
            UseCertificateDomain = TRUE;
        }
        else
        {
            ParseFlags |= KERB_CRACK_NAME_USE_WKSTA_REALM;
        }
    }

    Status = KerbProcessTargetNames(
                UserName,
                NULL,
                ParseFlags,
                &ProcessFlags,
                ClientName,
                ClientRealm,
                NULL
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If we were not supplied a realm, use the one from the name
    //
    if (SuppRealm && (SuppRealm->Length != 0))
    {
        KerbFreeString(ClientRealm);
        Status = KerbDuplicateString(
                    ClientRealm,
                    SuppRealm
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
    else if (PrimaryCreds->DomainName.Length != 0)
    {
        KerbFreeString(ClientRealm);
        Status = KerbDuplicateString(
                    ClientRealm,
                    &PrimaryCreds->DomainName
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
    else if ( UseCertificateDomain )
    {
        KerbFreeString( ClientRealm );
        Status = KerbDuplicateString(
                        ClientRealm,
                        &PrimaryCreds->PublicKeyCreds->AlternateDomainName
                        );

        if (!NT_SUCCESS(Status))
        {
           goto Cleanup;
        }
    }

Cleanup:


    if (ARGUMENT_PRESENT(MitRealmUsed))
    {
        *MitRealmUsed = ((ProcessFlags & KERB_MIT_REALM_USED) != 0);

        //
        // check for MIT realms
        //

        if (!*MitRealmUsed && (ParseFlags & KERB_CRACK_NAME_REALM_SUPPLIED))
        {
            *MitRealmUsed = KerbLookupMitRealm(ClientRealm, NULL, NULL);    
        }
    }

    KerbFreeString( &LocalMachineServiceName );

    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetTicketGrantingTicket
//
//  Synopsis:   Gets a TGT for a set of credentials
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetTicketGrantingTicket(
    IN OUT PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN OPTIONAL PUNICODE_STRING SuppRealm,
    OUT OPTIONAL PKERB_TICKET_CACHE_ENTRY * TicketCacheEntry,
    OUT OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    PKERB_INTERNAL_NAME KdcServiceKdcName = NULL;
    PKERB_INTERNAL_NAME ClientName = NULL;
    UNICODE_STRING UClientName = {0};
    UNICODE_STRING ClientRealm = {0};
    UNICODE_STRING CorrectRealm = {0};
    ULONG RetryCount = KERB_CLIENT_REFERRAL_MAX;
    PKERB_PRIMARY_CREDENTIAL PrimaryCreds;
    PKERB_MIT_REALM MitRealm = NULL;
    ULONG RequestFlags = 0;
    BOOLEAN UsingSuppliedCreds = FALSE;
    BOOLEAN UseWkstaRealm = TRUE;
    BOOLEAN MitRealmLogon = FALSE;
    BOOLEAN UsedPrimaryLogonCreds = FALSE;
    BOOLEAN LogonSessionLocked = FALSE;

    LUID LogonId;

    //
    // Get the proper realm name
    //

    if (ARGUMENT_PRESENT(Credential) && (Credential->SuppliedCredentials != NULL))
    {
        PrimaryCreds = Credential->SuppliedCredentials;
        if ((Credential->CredentialFlags & KERB_CRED_NO_PAC) != 0)
        {
            RequestFlags |= KERB_GET_TICKET_NO_PAC;
        }
        LogonId = Credential->LogonId;
        UsingSuppliedCreds = TRUE;
    }
    else if (ARGUMENT_PRESENT(CredManCredentials))
    {
        PrimaryCreds = CredManCredentials->SuppliedCredentials;
        LogonId = LogonSession->LogonId;
    }
    else
    {
        DsysAssert( !LogonSessionLocked );
        KerbWriteLockLogonSessions(LogonSession);
        LogonSessionLocked = TRUE;
        PrimaryCreds = &LogonSession->PrimaryCredentials;
        LogonId = LogonSession->LogonId;

        Status = KerbDuplicateString(
                    &UClientName,
                    &LogonSession->PrimaryCredentials.UserName
                    );

        if (!NT_SUCCESS(Status))
        {
            DsysAssert( LogonSessionLocked );
            KerbUnlockLogonSessions(LogonSession);
            LogonSessionLocked = FALSE;
            goto Cleanup;
        }

        UsedPrimaryLogonCreds = TRUE;
    }

    //
    // Parse the name
    //

    Status = KerbGetClientNameAndRealm(
                &LogonId,
                PrimaryCreds,
                UsingSuppliedCreds,
                SuppRealm,
                &MitRealmLogon,
                UseWkstaRealm,
                &ClientName,
                &ClientRealm
                );
    //
    //   If we're doing a MIT logon, add the MIT logon flag
    //
    if (MitRealmLogon && UsedPrimaryLogonCreds)
    {
       LogonSession->LogonSessionFlags |= KERB_LOGON_MIT_REALM;
    }

    // only needed lock if we're tinkering w/ primary creds
    // in case updates the credentials for that logon id.
    if (LogonSessionLocked)
    {
        KerbUnlockLogonSessions(LogonSession);
        LogonSessionLocked = FALSE;
    }

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to get client name & realm: 0x%x, %ws line %d\n",
            Status, THIS_FILE, __LINE__ ));
        goto Cleanup;
    }

GetTicketRestart:

    D_DebugLog((DEB_TRACE, "KerbGetTicketGrantingTicket GetTicketRestart ClientRealm %wZ\n", &ClientRealm));

    KerbErr = KerbBuildFullServiceKdcName(
                &ClientRealm,
                &KerbGlobalKdcServiceName,
                KRB_NT_SRV_INST,
                &KdcServiceKdcName
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = KerbGetAuthenticationTicket(
                LogonSession,
                Credential,
                CredManCredentials,
                TRUE,
                KdcServiceKdcName,
                &ClientRealm,
                ClientName,
                RequestFlags,
                KERB_TICKET_CACHE_PRIMARY_TGT,
                TicketCacheEntry,
                CredentialKey,
                &CorrectRealm
                );

    //
    // If it failed but gave us another realm to try, go there
    //

    if (!NT_SUCCESS(Status) && (CorrectRealm.Length != 0))
    {
       if (--RetryCount != 0)
       {
          KerbFreeKdcName(&KdcServiceKdcName);
          KerbFreeString(&ClientRealm);
          ClientRealm = CorrectRealm;
          CorrectRealm.Buffer = NULL;

          //
          // Might be an MIT realm, in which case we'll need to adjust
          // the client name.  This will also populate the realm list
          // with appropriate entries, so the KerbGetKdcBinding will not
          // hit DNS again.
          //
          if (KerbLookupMitRealmWithSrvLookup(
                           &ClientRealm,
                           &MitRealm,
                           FALSE,
                           FALSE
                           ))
          {
             D_DebugLog((DEB_TRACE,"Reacquiring client name & realm after referral\n"));
             UseWkstaRealm = FALSE;
             KerbFreeKdcName(&ClientName);

             Status = KerbGetClientNameAndRealm(
                        &LogonId,
                        PrimaryCreds,
                        UsingSuppliedCreds,
                        NULL,
                        NULL,
                        UseWkstaRealm,
                        &ClientName,
                        &ClientRealm
                        );

             if (!NT_SUCCESS(Status))
             {
                 goto Cleanup;
             }
          }

          goto GetTicketRestart;
       }
       else
       {
          // Tbd:  Log error here?  Max referrals reached..
          goto Cleanup;
       }
    }
    else if (((Status == STATUS_NO_SUCH_USER ) && UsingSuppliedCreds && UseWkstaRealm) ||
             ((Status == STATUS_NO_LOGON_SERVERS ) && UsingSuppliedCreds && !fRebootedSinceJoin))
    {
        //
        // We tried using the realm of the workstation and the account couldn't
        // be found - try the realm from the UPN now.
        //

        if (KerbIsThisOurDomain(&ClientRealm))
        {
            DebugLog((DEB_ERROR, "Doing freboot retry\n"));

            UseWkstaRealm = FALSE;

            KerbFreeKdcName(&ClientName);
            KerbFreeString(&ClientRealm);

            //
            // Only do this if the caller did not supply a
            // domain name
            //

            KerbReadLockLogonSessions(LogonSession);

            if (PrimaryCreds->DomainName.Length == 0)
            {
                Status = KerbGetClientNameAndRealm(
                            &LogonId,
                            PrimaryCreds,
                            UsingSuppliedCreds,
                            NULL,
                            NULL,
                            UseWkstaRealm,
                            &ClientName,
                            &ClientRealm
                            );
            }

            KerbUnlockLogonSessions(LogonSession);

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            goto GetTicketRestart;
        }
    }

Cleanup:

    if (Status == STATUS_ACCOUNT_DISABLED && UsedPrimaryLogonCreds)
    {
        D_DebugLog((DEB_ERROR, "Purging NLP Cache entry due to disabled acct.\n"));

        KerbCacheLogonInformation(
            &UClientName,
            &ClientRealm,
            NULL,
            NULL,
            NULL,
            LogonSession,
            MSV1_0_CACHE_LOGON_DELETE_ENTRY,
            NULL,
            NULL,                          // no supplemental creds
            0
            );
    }

    if (UsedPrimaryLogonCreds &&
        ((Status == STATUS_WRONG_PASSWORD) ||
         (Status == STATUS_SMARTCARD_NO_CARD) ||
         (Status == STATUS_SMARTCARD_CARD_NOT_AUTHENTICATED) ))
    {
        KerbPingWlBalloon(&LogonSession->LogonId);
    }

    //
    // Credman creds need some enhanced logging on failure
    //
    if (!NT_SUCCESS( Status ) && ARGUMENT_PRESENT( CredManCredentials ))
    {         
        KerbLogCredmanError(
            CredManCredentials,
            Status
            );

    }





    KerbFreeString(&ClientRealm);
    KerbFreeString(&CorrectRealm);
    KerbFreeString(&UClientName);

    KerbFreeKdcName(&KdcServiceKdcName);
    KerbFreeKdcName(&ClientName);

    DsysAssert( !LogonSessionLocked );

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPurgeServiceTicketAndTgt
//
//  Synopsis:   Whacks the service ticket, and its associated TGT, usually as a
//              result of some sort of error condition.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOLEAN
KerbPurgeServiceTicketAndTgt(
     IN PKERB_CONTEXT Context,
     IN LSA_SEC_HANDLE CredentialHandle,
     IN OPTIONAL PKERB_CREDMAN_CRED CredManHandle
     )
{
    PKERB_PRIMARY_CREDENTIAL   PrimaryCredentials = NULL;
    PKERB_LOGON_SESSION        LogonSession = NULL;
    UNICODE_STRING             RealmName[3];
    PUNICODE_STRING            pTmp = RealmName;
    PKERB_TICKET_CACHE_ENTRY   TicketCacheEntry = NULL;
    PKERB_CREDENTIAL           Credential = NULL;
    BOOLEAN                    LogonSessionsLocked = FALSE, CacheLocked = FALSE, fRet = FALSE;
    NTSTATUS                   Status;

    // Validate in params
    // If any of these fires, contact Todds
    DsysAssert(NULL != CredentialHandle);
    DsysAssert(NULL != Context->TicketCacheEntry );
    DsysAssert(NULL != Context->TicketCacheEntry->TargetDomainName.Buffer);

    Status = KerbReferenceCredential(
                   CredentialHandle,
                   0,
                   FALSE,
                   &Credential
                   );

    if (!NT_SUCCESS(Status) || Credential == NULL)
    {
        D_DebugLog((DEB_ERROR,"KerbPurgeServiceTicket supplied w/ bogus cred handle\n"));
        goto Cleanup;
    }

    LogonSession = KerbReferenceLogonSession(&Credential->LogonId, FALSE);
    if (NULL == LogonSession)
    {
        D_DebugLog((DEB_ERROR, "Couldn't find LUID %x\n", Credential->LogonId));
        goto Cleanup;
    }

    DsysAssert( !LogonSessionsLocked );
    KerbReadLockLogonSessions(&KerbLogonSessionList);
    LogonSessionsLocked = TRUE;

    if (NULL != Credential && Credential->SuppliedCredentials != NULL)
    {
        PrimaryCredentials = Credential->SuppliedCredentials;
        D_DebugLog((DEB_TRACE, "Purging tgt associated with SUPPLIED creds (%S\\%S)\n",
                 PrimaryCredentials->DomainName.Buffer,PrimaryCredentials->UserName.Buffer));
    }
    else if ARGUMENT_PRESENT(CredManHandle)
    {
        PrimaryCredentials = CredManHandle->SuppliedCredentials;
        D_DebugLog((DEB_TRACE, "Purging tgt associated with CREDMAN creds (%S\\%S)\n",
                 PrimaryCredentials->DomainName.Buffer,PrimaryCredentials->UserName.Buffer));

    }
    else
    {
        PrimaryCredentials = &LogonSession->PrimaryCredentials;
        D_DebugLog((DEB_TRACE, "Purging tgt associated with PRIMARY creds (%S\\%S)\n",
                 PrimaryCredentials->DomainName.Buffer,PrimaryCredentials->UserName.Buffer));
    }

    KerbWriteLockContexts();
    TicketCacheEntry = Context->TicketCacheEntry;
    Context->TicketCacheEntry = NULL;
    KerbUnlockContexts();

    DsysAssert( !CacheLocked );
    KerbReadLockTicketCache();
    CacheLocked = TRUE;

    // Do some mem copy rather than block over ticket cache searches
    RtlCopyMemory(RealmName, &TicketCacheEntry->TargetDomainName, sizeof(UNICODE_STRING));

    SafeAllocaAllocate(RealmName[0].Buffer, RealmName[0].MaximumLength);
    if (NULL == RealmName[0].Buffer)
    {
        goto Cleanup;
    }

    RtlCopyUnicodeString(
       &RealmName[0],
       &TicketCacheEntry->TargetDomainName
       );

    RtlCopyMemory(&RealmName[1],&TicketCacheEntry->AltTargetDomainName, sizeof(UNICODE_STRING));
    if (RealmName[1].Buffer != NULL && RealmName[1].MaximumLength != 0)
    {
        SafeAllocaAllocate(RealmName[1].Buffer, RealmName[1].MaximumLength);
        if (NULL == RealmName[1].Buffer)
        {
            goto Cleanup;
        }

        RtlCopyUnicodeString(
           &RealmName[1],
           &TicketCacheEntry->TargetDomainName
           );
    }

    DsysAssert( CacheLocked );
    KerbUnlockTicketCache();
    CacheLocked = FALSE;

    RtlInitUnicodeString(
       &RealmName[2],
       NULL
       );

    // Kill the service ticket
    KerbRemoveTicketCacheEntry(TicketCacheEntry);

    do
    {
        PKERB_TICKET_CACHE_ENTRY   DummyEntry = NULL;

        DummyEntry = KerbLocateTicketCacheEntryByRealm(
                          &PrimaryCredentials->AuthenticationTicketCache,
                          pTmp,
                          KERB_TICKET_CACHE_PRIMARY_TGT
                          );

        if (NULL == DummyEntry)
        {
            D_DebugLog((DEB_TRACE, "Didn't find primary TGT for %S \n", pTmp->Buffer));
        }
        else
        {
            KerbRemoveTicketCacheEntry(DummyEntry);
            KerbDereferenceTicketCacheEntry(DummyEntry);
        }

        DummyEntry = KerbLocateTicketCacheEntryByRealm(
                          &PrimaryCredentials->AuthenticationTicketCache,
                          pTmp,
                          KERB_TICKET_CACHE_DELEGATION_TGT
                          );

        if (NULL == DummyEntry)
        {
            D_DebugLog((DEB_TRACE, "Didn't find delegation TGT for %S\n", pTmp->Buffer));
        }
        else
        {
            KerbRemoveTicketCacheEntry(DummyEntry);
            KerbDereferenceTicketCacheEntry(DummyEntry);
        }

        pTmp++;
    } while (pTmp->Buffer != NULL);

    fRet = TRUE;

Cleanup:

    if (CacheLocked)
    {
        KerbUnlockTicketCache();
    }

    if (NULL != Credential)
    {
        KerbDereferenceCredential(Credential);
    }

    if ( LogonSessionsLocked )
    {
        KerbUnlockLogonSessions(&KerbLogonSessionList);
    }

    if (NULL != LogonSession)
    {
        KerbDereferenceLogonSession(LogonSession);
    }

    SafeAllocaFree(RealmName[0].Buffer);
    SafeAllocaFree(RealmName[1].Buffer);

    return fRet;
}


//+-------------------------------------------------------------------------
//
//  Function:  KerbEqualAccount
//
//  Synopsis:  Compare two SAM style account names to see if they are the
//             the same
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
KerbEqualAccount(
    IN UNICODE_STRING* pUserNameFoo,
    IN UNICODE_STRING* pDomainNameFoo,
    IN UNICODE_STRING* pUserNameBar,
    IN UNICODE_STRING* pDomainNameBar,
    OUT BOOLEAN* pbIsEqual
    )
{
   if (!pbIsEqual)
   {
       return STATUS_INVALID_PARAMETER;
   }

   *pbIsEqual = FALSE;

   if ((RtlEqualUnicodeString(
            pUserNameFoo,
            pUserNameBar,
            TRUE                                        // case insensitive
            )) &&
       (RtlEqualUnicodeString(
           pDomainNameFoo,
           pDomainNameBar,
           TRUE                                        // case insensitive
           ))
      )
   {
       *pbIsEqual = TRUE;
       return STATUS_SUCCESS;
   }

   return STATUS_SUCCESS;
}

//+-------------------------------------------------------------------------
//
//  Function:  GetPrimaryPrincipalSid
//
//  Synopsis:  Get SID for an LSAP_LOGON_SESSION by Logon ID
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//--------------------------------------------------------------------------

NTSTATUS
GetPrimaryPrincipalSid(
    IN LUID* pLogonId,
    OUT PSID* ppsid
    )
{
    SECURITY_LOGON_SESSION_DATA* pLogonSessionData = NULL;
    ULONG cbSid = 0;
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;
    PSID pSid = NULL;

    if (!ppsid || !pLogonId)
    {
        return STATUS_INVALID_PARAMETER;
    }

    *ppsid = NULL;

    NtStatus = LsaGetLogonSessionData(pLogonId, &pLogonSessionData);

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = pLogonSessionData->Sid ? STATUS_SUCCESS : STATUS_UNSUCCESSFUL;
    }

    if (NT_SUCCESS(NtStatus))
    {
        cbSid = RtlLengthSid(pLogonSessionData->Sid);

        pSid = KerbAllocate(cbSid);

        NtStatus = pSid ? STATUS_SUCCESS : STATUS_NO_MEMORY;
    }

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = RtlCopySid(cbSid, pSid, pLogonSessionData->Sid);
    }

    if (NT_SUCCESS(NtStatus))
    {
        *ppsid = pSid;
    }
    else
    {
        KerbFree(pSid);
    }

    if (pLogonSessionData)
    {
        LsaFreeReturnBuffer(pLogonSessionData);
    }

    return NtStatus;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbUpdateOldLogonSession
//
//  Synopsis:   Update old logon session during unlock logon
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbUpdateOldLogonSession(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PSECPKG_PRIMARY_CRED PrimaryCredentials,
    IN PSECPKG_SUPPLEMENTAL_CRED_ARRAY SupplementalCredentials,
    IN PLUID OldLogonId,
    IN PKERB_TICKET_CACHE_ENTRY NewWorkstationTicket
    )
{
    NTSTATUS NtStatus = STATUS_UNSUCCESSFUL;

    BOOLEAN bMatch = FALSE;
    PKERB_LOGON_SESSION OldLogonSession;

    OldLogonSession = KerbReferenceLogonSession(
                        OldLogonId,
                        FALSE  // don't unlink
                        );
    if (OldLogonSession == NULL)
    {
        return;
    }

    KerbWriteLockLogonSessions(OldLogonSession);
    KerbWriteLockLogonSessions(LogonSession);
    KerbWriteLockTicketCache();

    //
    // Make sure the two accounts are the same before copying tickets
    // around.
    //

    NtStatus = KerbEqualAccount(
                   &LogonSession->PrimaryCredentials.UserName,
                   &LogonSession->PrimaryCredentials.DomainName,
                   &OldLogonSession->PrimaryCredentials.UserName,
                   &OldLogonSession->PrimaryCredentials.DomainName,
                   &bMatch
                   );

    //
    // if names do not match, compare the sids
    //

    if (NT_SUCCESS(NtStatus) && !bMatch)
    {
        PSID UserSidOldLogonSession = NULL;

        NtStatus = GetPrimaryPrincipalSid(&OldLogonSession->LogonId, &UserSidOldLogonSession);

        if (NT_SUCCESS(NtStatus))
        {
            bMatch = RtlEqualSid(PrimaryCredentials->UserSid, UserSidOldLogonSession);
        }

        if (UserSidOldLogonSession)
        {
            KerbFree(UserSidOldLogonSession);
        }
    }

    if (NT_SUCCESS(NtStatus) && bMatch)
    {
        PKERB_TICKET_CACHE_ENTRY ASTicket = NULL;

        DebugLog((DEB_TRACE_CRED, 
            "KerbUpdateOldLogonSession refreshing old logon session %#x:%#x, Flags %#x, SupplementalCredentials %p\n", 
            OldLogonSession->LogonId.HighPart, OldLogonSession->LogonId.LowPart,
            PrimaryCredentials->Flags, SupplementalCredentials));

        //
        // Search for the new TGT so we can put it in the old
        // cache.
        //

        ASTicket = KerbLocateTicketCacheEntryByRealm(
                        &LogonSession->PrimaryCredentials.AuthenticationTicketCache,
                        NULL,               // get initial ticket
                        KERB_TICKET_CACHE_PRIMARY_TGT
                        );

        if (ASTicket != NULL)
        {
            OldLogonSession->LogonSessionFlags &= ~KERB_LOGON_DEFERRED;
            KerbRemoveTicketCacheEntry(ASTicket);
        }
        else
        {
            //
            // Hold on to our old TGT if we didn't get one this time around..
            //

            D_DebugLog((DEB_ERROR, "Failed to find primary TGT on unlock logon session\n"));

            ASTicket = KerbLocateTicketCacheEntryByRealm(
                            &OldLogonSession->PrimaryCredentials.AuthenticationTicketCache,
                            NULL,
                            KERB_TICKET_CACHE_PRIMARY_TGT
                            );

            if (ASTicket != NULL)
            {
                //
                // Copy into new logon session cache for later reuse.
                //
                KerbRemoveTicketCacheEntry(ASTicket);
                OldLogonSession->LogonSessionFlags &= ~KERB_LOGON_DEFERRED;
            }
            else
            {
                //
                // No TGT in either new or old logonsession -- we're deferred...
                //
                D_DebugLog((DEB_ERROR, "Failed to find primary TGT on *OLD* logon session\n"));
                OldLogonSession->LogonSessionFlags |= KERB_LOGON_DEFERRED;
            }
        }

        if ((LogonSession->LogonSessionFlags & KERB_LOGON_SMARTCARD) != 0)
        {
            OldLogonSession->LogonSessionFlags |= KERB_LOGON_SMARTCARD;
        }
        else
        {
            OldLogonSession->LogonSessionFlags &= ~KERB_LOGON_SMARTCARD;
        }

        if ((LogonSession->LogonSessionFlags & KERB_LOGON_MIT_REALM) != 0) 
        {
            OldLogonSession->LogonSessionFlags |= KERB_LOGON_MIT_REALM; 
        }

        //
        // swap the primary creds
        //
        KerbFreePrimaryCredentials(&OldLogonSession->PrimaryCredentials, FALSE);

        if ( NewWorkstationTicket != NULL )
        {
            KerbRemoveTicketCacheEntry(NewWorkstationTicket);
        }

        KerbPurgeTicketCache(&LogonSession->PrimaryCredentials.AuthenticationTicketCache);
        KerbPurgeTicketCache(&LogonSession->PrimaryCredentials.S4UTicketCache);
        KerbPurgeTicketCache(&LogonSession->PrimaryCredentials.ServerTicketCache);

        RtlCopyMemory(
            &OldLogonSession->PrimaryCredentials,
            &LogonSession->PrimaryCredentials,
            sizeof(KERB_PRIMARY_CREDENTIAL)
            );

        RtlZeroMemory(
            &LogonSession->PrimaryCredentials,
            sizeof(KERB_PRIMARY_CREDENTIAL)
            );

        // Fix up list entry pointers.
        KerbInitTicketCache(&OldLogonSession->PrimaryCredentials.AuthenticationTicketCache);
        KerbInitTicketCache(&OldLogonSession->PrimaryCredentials.S4UTicketCache);
        KerbInitTicketCache(&OldLogonSession->PrimaryCredentials.ServerTicketCache);

        KerbInitTicketCache(&LogonSession->PrimaryCredentials.AuthenticationTicketCache);
        KerbInitTicketCache(&LogonSession->PrimaryCredentials.S4UTicketCache);
        KerbInitTicketCache(&LogonSession->PrimaryCredentials.ServerTicketCache);

        // insert new tickets into old logon session
        if (ASTicket != NULL)
        {
            KerbInsertTicketCacheEntry(&OldLogonSession->PrimaryCredentials.AuthenticationTicketCache, ASTicket);

            if (( ASTicket->CacheFlags & KERB_TICKET_CACHE_PRIMARY_TGT ) &&
                ( ASTicket->TicketFlags & KERB_TICKET_FLAGS_renewable )) {

                KerbScheduleTgtRenewal( ASTicket );
            }

            KerbDereferenceTicketCacheEntry(ASTicket); // for locate call above
        }

        if (NewWorkstationTicket != NULL)
        {
            //
            // On the offchance that the ticket is still linked, unlink it prior to inserting
            //

            KerbRemoveTicketCacheEntry( NewWorkstationTicket );
            DsysAssert( NewWorkstationTicket->ListEntry.ReferenceCount > 0 );

            KerbInsertTicketCacheEntry(&OldLogonSession->PrimaryCredentials.ServerTicketCache, NewWorkstationTicket);
        }
    }

    KerbUnlockTicketCache();
    KerbUnlockLogonSessions(LogonSession);
    KerbUnlockLogonSessions(OldLogonSession);
    KerbDereferenceLogonSession(OldLogonSession);

    //
    // changes in clear text passwords are handled by LsaLogonUser followed by 
    // a change-cached-password request from winlogon. However, supplemental 
    // credential changes are updated here: we do not know whether there is a 
    // real password change, but we issue a credential update anyway.
    //
    // ISSUE: Due to lack of cleartext passwords, we can not trigger a password 
    // change notification here
    //

    if (NT_SUCCESS(NtStatus) && bMatch 
        && (0 == (PrimaryCredentials->Flags & PRIMARY_CRED_CLEAR_PASSWORD))
        && SupplementalCredentials) 
    {    
        D_DebugLog((DEB_TRACE_CRED, 
            "KerbUpdateOldLogonSession updating credentials for %#x:%#x by %#x:%#x, "
            "Flag %#x, User %wZ\\%wZ, Upn %wZ, DnsLogonDomain %wZ, LogonServer %wZ\n",
            OldLogonId->HighPart, OldLogonId->LowPart, 
            LogonSession->LogonId.HighPart, LogonSession->LogonId.LowPart,
            PrimaryCredentials->Flags, 
            &PrimaryCredentials->DomainName, &PrimaryCredentials->DownlevelName, 
            &PrimaryCredentials->Upn, 
            &PrimaryCredentials->DnsDomainName,
            &PrimaryCredentials->LogonServer)); 

        DsysAssert(RtlEqualLuid(&PrimaryCredentials->LogonId, &LogonSession->LogonId) && L"KerbUpdateOldLogonSession PrimaryCredentials and logon session must have the same Luid\n");

        PrimaryCredentials->Flags |= PRIMARY_CRED_UPDATE;
        PrimaryCredentials->LogonId = *OldLogonId;
    
        LsaFunctions->UpdateCredentials(
                          PrimaryCredentials, 
                          SupplementalCredentials
                          );
    
        //
        // restore PrimaryCredentials
        //

        PrimaryCredentials->Flags &= ~PRIMARY_CRED_UPDATE;
        PrimaryCredentials->LogonId = LogonSession->LogonId;
    }
}

#ifndef WIN32_CHICAGO // later

//+-------------------------------------------------------------------------
//
//  Function:   KerbCheckDomainlessLogonPolicy
//
//  Synopsis:   If a machine is not a member of a domain or MIT realm,
//              we've got to verify that the kerberos principal is mapped
//              to a local account.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS NTAPI
KerbCheckRealmlessLogonPolicy(
    IN PKERB_TICKET_CACHE_ENTRY AsTicket,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;


    //
    //  Sanity check to prevent identity spoofing for
    //  gaining access to a machine
    //
    //  tbd:  Credman support?  Seems like we should be using credman
    //  credentials, if present, but for logon???
    //
    if (!KerbEqualKdcNames(
                    ClientName,
                    AsTicket->ClientName) ||
        !RtlEqualUnicodeString(
                    &AsTicket->ClientDomainName,
                    ClientRealm,
                    TRUE
                    ))
    {
        D_DebugLog((DEB_ERROR, "Logon session and AS ticket identities don't match\n"));
        // tbd:  Log names?
        Status = STATUS_NO_SUCH_USER;
    }

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   LsaApLogonUserEx2
//
//  Synopsis:   Handles service, batch, and interactive logons
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
LsaApLogonUserEx2(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PLUID NewLogonId,
    OUT PNTSTATUS ApiSubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCredentials
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_INTERACTIVE_LOGON LogonInfo = NULL;
    UCHAR Seed;
    UNICODE_STRING TempName = NULL_UNICODE_STRING;
    UNICODE_STRING TempAuthority = NULL_UNICODE_STRING;
    UNICODE_STRING NullAuthority = NULL_UNICODE_STRING;
    UNICODE_STRING MappedClientName = NULL_UNICODE_STRING;
    LUID LogonId;
    LUID OldLogonId;
    LUID AlternateLuid;
    BOOLEAN DoingUnlock = FALSE, WkstaAccount = FALSE;
    PKERB_TICKET_CACHE_ENTRY WorkstationTicket = NULL;
    PKERB_TICKET_CACHE_ENTRY AsTicket = NULL;
    KERB_MESSAGE_BUFFER ForwardedTgt = {0};
    KERBEROS_MACHINE_ROLE Role;
    PKERB_MIT_REALM MitRealm = NULL;
    BOOLEAN LocalLogon = FALSE, RealmlessWkstaLogon = FALSE;
    BOOLEAN UsedAlternateName = FALSE;
    KERB_ENCRYPTION_KEY CredentialKey = {0};
    UNICODE_STRING DomainName = {0};
    PKERB_INTERNAL_NAME ClientName = NULL;
    UNICODE_STRING ClientRealm = {0};
    UNICODE_STRING Upn = {0};
    PKERB_INTERNAL_NAME MachineServiceName = {0};
    PKERB_INTERNAL_NAME S4UClientName = {0};
    UNICODE_STRING S4UClientRealm = {0};
    UNICODE_STRING CorrectRealm = {0};
    PLSAPR_CR_CIPHER_VALUE SecretCurrent = NULL;
    UNICODE_STRING Prefix, SavedPassword = {0};
    BOOLEAN ServiceSecretLogon = FALSE;
    ULONG ProcessFlags = 0;
    PCERT_CONTEXT CertContext = NULL;
    BOOLEAN fSuppliedCertCred = FALSE;
    PVOID pTempSubmitBuffer = ProtocolSubmitBuffer;
    PNETLOGON_VALIDATION_SAM_INFO4 ValidationInfo = NULL;
    PNETLOGON_VALIDATION_SAM_INFO4 SCValidationInfo = NULL;
    GUID LogonGuid = { 0 };

    //
    // Credential manager stored credentials.
    //

    UNICODE_STRING CredmanUserName;
    UNICODE_STRING CredmanDomainName;
    UNICODE_STRING CredmanPassword;

#if _WIN64

    BOOL  fAllocatedSubmitBuffer = FALSE;

#endif  // _WIN64

    KERB_LOGON_INFO LogonTraceInfo;

    if (LogonType == CachedInteractive) {

        //
        // We don't support cached logons.
        //

        return STATUS_INVALID_LOGON_TYPE;
    }

    if( KerbEventTraceFlag ) // Event Trace:  KerbLogonUserStart {No Data}
    {
        // Set trace parameters
        LogonTraceInfo.EventTrace.Guid       = KerbLogonGuid;
        LogonTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_START;
        LogonTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID;
        LogonTraceInfo.EventTrace.Size       = sizeof(EVENT_TRACE_HEADER);

        TraceEvent(
            KerbTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&LogonTraceInfo);
    }

    //
    // First initialize all the output parameters to NULL.
    //

    *ProfileBuffer = NULL;
    *ApiSubStatus = STATUS_SUCCESS;
    *TokenInformation = NULL;
    *AccountName = NULL;
    *AuthenticatingAuthority = NULL;
    *MachineName = NULL;
    *CachedCredentials = NULL;

    CredmanUserName.Buffer      = NULL;
    CredmanDomainName.Buffer    = NULL;
    CredmanPassword.Buffer      = NULL;

    RtlZeroMemory(
        PrimaryCredentials,
        sizeof(SECPKG_PRIMARY_CRED)
        );

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_INVALID_SERVER_STATE;
        goto Cleanup;
    }

    //
    // Make sure we have at least tcp as a xport, unless we are doing
    // cached sc logon, in which case we'll let them get through.
    //

    KerbGlobalReadLock();
    if (KerbGlobalNoTcpUdp)
    {
        Status = STATUS_NETWORK_UNREACHABLE;
    }
    KerbGlobalReleaseLock();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    Role = KerbGetGlobalRole();

    *AccountName = (PUNICODE_STRING) KerbAllocate(sizeof(UNICODE_STRING));
    if (*AccountName == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    (*AccountName)->Buffer = NULL;

    *AuthenticatingAuthority = (PUNICODE_STRING) KerbAllocate(sizeof(UNICODE_STRING));
    if (*AuthenticatingAuthority == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    (*AuthenticatingAuthority)->Buffer = NULL;


    //
    // Initialize local pointers to NULL
    //

    LogonId.LowPart = 0;
    LogonId.HighPart = 0;
    *NewLogonId = LogonId;


    //
    // Check the logon type
    //

    switch (LogonType) {

    case Service:
    case Interactive:
    case Batch:
    case Network:
    case NetworkCleartext:
    case RemoteInteractive:


        PSECURITY_SEED_AND_LENGTH SeedAndLength;

        LogonInfo = (PKERB_INTERACTIVE_LOGON) pTempSubmitBuffer;

        if (SubmitBufferSize < sizeof(KERB_LOGON_SUBMIT_TYPE))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

#if _WIN64

        SECPKG_CALL_INFO  CallInfo;

        //
        // Expand the ProtocolSubmitBuffer to 64-bit pointers if this
        // call came from a WOW client.
        //

        if(!LsaFunctions->GetCallInfo(&CallInfo))
        {
            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }

        if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
        {
            Status = KerbConvertWOWLogonBuffer(ProtocolSubmitBuffer,
                                               ClientBufferBase,
                                               &SubmitBufferSize,
                                               LogonInfo->MessageType,
                                               &pTempSubmitBuffer);

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            fAllocatedSubmitBuffer = TRUE;

            //
            // Some macros below expand out to use ProtocolSubmitBuffer directly.
            // We've secretly replaced their usual ProtocolSubmitBuffer with
            // pTempSubmitBuffer -- let's see if they can tell the difference.
            //

            ProtocolSubmitBuffer = pTempSubmitBuffer;
            LogonInfo = (PKERB_INTERACTIVE_LOGON) pTempSubmitBuffer;
        }


#endif  // _WIN64


        if ((LogonInfo->MessageType == KerbInteractiveLogon) ||
            (LogonInfo->MessageType == KerbWorkstationUnlockLogon))
        {
            //
            // Pull the interesting information out of the submit buffer
            //

            if (LogonInfo->MessageType == KerbInteractiveLogon)
            {
                if (SubmitBufferSize < sizeof(KERB_INTERACTIVE_LOGON))
                {
                    D_DebugLog((DEB_ERROR,"Submit buffer to logon too small: %d. %ws, line %d\n",SubmitBufferSize, THIS_FILE, __LINE__));
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }
            }
            else
            {
                if (SubmitBufferSize < sizeof(KERB_INTERACTIVE_UNLOCK_LOGON))
                {
                    D_DebugLog((DEB_ERROR,"Submit buffer to logon too small: %d. %ws, line %d\n",SubmitBufferSize, THIS_FILE, __LINE__));
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }
                PKERB_INTERACTIVE_UNLOCK_LOGON UnlockInfo = (PKERB_INTERACTIVE_UNLOCK_LOGON) LogonInfo;

                OldLogonId = UnlockInfo->LogonId;
                DoingUnlock = TRUE;
            }

            //
            // If the password length is greater than 255 (i.e., the
            // upper byte of the length is non-zero) then the password
            // has been run-encoded for privacy reasons.  Get the
            // run-encode seed out of the upper-byte of the length
            // for later use.
            //

            SeedAndLength = (PSECURITY_SEED_AND_LENGTH)
                            &LogonInfo->Password.Length;
            Seed = SeedAndLength->Seed;
            SeedAndLength->Seed = 0;

            //
            // Enforce length restrictions on username and password.
            //

            if ( LogonInfo->UserName.Length > (UNLEN * sizeof(WCHAR)) ||
                LogonInfo->Password.Length > (PWLEN * sizeof(WCHAR)) ) {
                D_DebugLog((DEB_ERROR,"LsaApLogonUserEx2: Name or password too long. %ws, line%d\n", THIS_FILE, __LINE__));
                Status = STATUS_NAME_TOO_LONG;
                goto Cleanup;
            }


            //
            // Relocate any pointers to be relative to 'LogonInfo'
            //


            RELOCATE_ONE(&LogonInfo->UserName);
            NULL_RELOCATE_ONE(&LogonInfo->LogonDomainName);
            NULL_RELOCATE_ONE(&LogonInfo->Password);

            //
            // preserve the non-null pointer of password buffer if length is 0
            //

            if (!LogonInfo->Password.Length)
            {
                LogonInfo->Password.Buffer = L"";
            }

            if( (LogonInfo->LogonDomainName.Length <= sizeof(WCHAR)) &&
                (LogonInfo->Password.Length <= sizeof(WCHAR))
                )
            {
                if(KerbProcessUserNameCredential(
                                &LogonInfo->UserName,
                                &CredmanUserName,
                                &CredmanDomainName,
                                &CredmanPassword
                                ) == STATUS_SUCCESS)
                {
                    LogonInfo->UserName = CredmanUserName;
                    LogonInfo->LogonDomainName = CredmanDomainName;
                    LogonInfo->Password = CredmanPassword;
                    Seed = 0;
                }
            }


            if ( LogonType == Service )
            {
                SECPKG_CALL_INFO CallInfo;

                //
                // If we have a service logon, the password we got is likely the name of the
                // secret that is holding the account password.  Make sure to read that secret
                // here
                //

                RtlInitUnicodeString( &Prefix, L"_SC_" );
                if ( (RtlPrefixUnicodeString( &Prefix, &LogonInfo->Password, TRUE )) &&
                     (LsaFunctions->GetCallInfo(&CallInfo)) &&
                     (CallInfo.Attributes & SECPKG_CALL_IS_TCB)
                    )
                {
                    LSAPR_HANDLE SecretHandle = NULL;

                    Status = LsarOpenSecret( KerbGlobalPolicyHandle,
                                             ( PLSAPR_UNICODE_STRING )&LogonInfo->Password,
                                             SECRET_QUERY_VALUE,
                                             &SecretHandle );

                    if ( NT_SUCCESS( Status ) ) {

                        Status = LsarQuerySecret( SecretHandle,
                                                  &SecretCurrent,
                                                  NULL,
                                                  NULL,
                                                  NULL );

                        if ( NT_SUCCESS( Status ) && (SecretCurrent != NULL) ) {

                            RtlCopyMemory( &SavedPassword,
                                           &LogonInfo->Password,
                                           sizeof( UNICODE_STRING ) );
                            LogonInfo->Password.Length = ( USHORT )SecretCurrent->Length;
                            LogonInfo->Password.MaximumLength =
                                                       ( USHORT )SecretCurrent->MaximumLength;
                            LogonInfo->Password.Buffer = ( USHORT * )SecretCurrent->Buffer;
                            ServiceSecretLogon = TRUE;
                            Seed = 0; // do not run RtlRunDecodeUnicodeString for this password
                        }

                        LsarClose( &SecretHandle );
                    }
                }


                if ( !NT_SUCCESS( Status ) ) {

                    goto Cleanup;
                }

            }

            D_DebugLog((DEB_TRACE,"Logging on user %wZ, domain %wZ\n",
                &LogonInfo->UserName,
                &LogonInfo->LogonDomainName
                ));

            KerbGlobalReadLock();

            WkstaAccount = RtlEqualUnicodeString(
                                &KerbGlobalMachineName,
                                &LogonInfo->LogonDomainName,
                                TRUE
                                );

            KerbGlobalReleaseLock();


            // In the case where we're doing a realmless wksta
            // logon, then run see if there's a client mapping,
            // but only for interactive logons
            if ((!WkstaAccount) &&
                (Role == KerbRoleRealmlessWksta) &&
                (LogonType == Interactive ))
            {
                Status = KerbProcessTargetNames(
                                &LogonInfo->UserName,
                                NULL,
                                0,
                                &ProcessFlags,
                                &ClientName,
                                &ClientRealm,
                                NULL
                                );

                if (NT_SUCCESS(Status))
                {
                    Status = KerbMapClientName(
                                &MappedClientName,
                                ClientName,
                                &ClientRealm
                                );
                }

                if (NT_SUCCESS(Status))
                {
                    D_DebugLog((DEB_WARN, "Mapping user to MIT principal\n"));
                    RealmlessWkstaLogon = TRUE;
                }
            }

            if (WkstaAccount  ||
                 (KerbGlobalDomainIsPreNT5 && !RealmlessWkstaLogon) ||
                 (KerbGlobalSafeModeBootOptionPresent))
            {

                D_DebugLog(( DEB_TRACE, "Local Logon, bailing out now\n" ));
                Status = STATUS_NO_LOGON_SERVERS;
                goto Cleanup ;
            }


            //
            // Now decode the password, if necessary
            //

            if (Seed != 0) {
                __try {
                    RtlRunDecodeUnicodeString( Seed, &LogonInfo->Password);
                } __except(EXCEPTION_EXECUTE_HANDLER) {
                    Status = STATUS_ILL_FORMED_PASSWORD;
                    goto Cleanup;
                }
            }

            //
            // Check if the user name holds a cert context thumbprint
            //

            Status = KerbCheckUserNameForCert(
                            NULL,
                            TRUE,
                            &LogonInfo->UserName,
                            &CertContext
                            );
            if (NT_SUCCESS(Status))
            {
                if (NULL != CertContext)
                {
                    fSuppliedCertCred = TRUE;
                }
                else
                {
                    //
                    // Copy out the user name and Authenticating Authority so we can audit them.
                    //

                    Status = KerbDuplicateString(
                                &TempName,
                                &LogonInfo->UserName
                                );
                    if (!NT_SUCCESS(Status))
                    {
                        goto Cleanup;
                    }
                }
            }
            else
            {
                goto Cleanup;
            }

            if ( LogonInfo->LogonDomainName.Buffer != NULL ) {

                Status = KerbDuplicateString(
                            &TempAuthority,
                            &LogonInfo->LogonDomainName
                            );
                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }
            }


            //
            // Allocate a locally unique ID for this logon session. We will
            // create it in the LSA just before returning.
            //

            Status = NtAllocateLocallyUniqueId( &LogonId );
            if (!NT_SUCCESS(Status))
            {
                D_DebugLog((DEB_ERROR,"Failed to allocate locally unique ID: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
                goto Cleanup;
            }


            if (fSuppliedCertCred)
            {
                //
                // Build a logon session to hold all this information
                // for a smart card logon
                //

                Status = KerbCreateSmartCardLogonSessionFromCertContext(
                            &CertContext,
                            &LogonId,
                            &NullAuthority,
                            &LogonInfo->Password,
                            NULL,        // no CSP data
                            0,           // no CSP data
                            &LogonSession,
                            &TempName
                            );
                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                //
                // UPN logon...
                //
                Status = KerbDuplicateString(
                                &Upn,
                                &TempName
                                );

                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                D_DebugLog((DEB_TRACE, "UPN logon %wZ\n", &Upn));

            }
            else
            {
                //
                // Build a logon session to hold all this information
                //

                Status = KerbCreateLogonSession(
                            &LogonId,
                            &TempName,
                            &TempAuthority,
                            &LogonInfo->Password,
                            NULL,                       // no old password
                            PRIMARY_CRED_CLEAR_PASSWORD,
                            0,
                            FALSE,              // don't allow a duplicate.
                            &LogonSession
                            );
                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }


                //
                //   UPN logon...
                //
                if (TempAuthority.Length == 0)
                {
                    Status = KerbDuplicateString(
                                    &Upn,
                                    &TempName
                                    );

                    if (!NT_SUCCESS(Status))
                    {
                        goto Cleanup;
                    }

                    D_DebugLog((DEB_TRACE, "UPN logon %wZ\n", &Upn));
                }

            }
        }
        else if ((LogonInfo->MessageType == KerbSmartCardLogon) ||
                 (LogonInfo->MessageType == KerbSmartCardUnlockLogon))
        {

            if (LogonInfo->MessageType == KerbSmartCardUnlockLogon)
            {
                if (SubmitBufferSize < sizeof(KERB_SMART_CARD_UNLOCK_LOGON))
                {
                    D_DebugLog((DEB_ERROR,"Submit buffer to logon too small: %d. %ws, line %d\n",SubmitBufferSize, THIS_FILE, __LINE__));
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }
                PKERB_SMART_CARD_UNLOCK_LOGON UnlockInfo = (PKERB_SMART_CARD_UNLOCK_LOGON) LogonInfo;

                OldLogonId = UnlockInfo->LogonId;
                DoingUnlock = TRUE;
            }

            Status = KerbCreateSmartCardLogonSession(
                        pTempSubmitBuffer,
                        ClientBufferBase,
                        SubmitBufferSize,
                        LogonType,
                        &LogonSession,
                        &LogonId,
                        &TempName,
                        &TempAuthority
                        );
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "KerbCreateSCloongsession failed %x\n", Status));
                goto Cleanup;
            }

            //
            // UPN logon...
            //
            if (TempAuthority.Length == 0)
            {
               Status = KerbDuplicateString(
                           &Upn,
                           &TempName
                           );

               if (!NT_SUCCESS(Status))
               {
                   goto Cleanup;
               }

               D_DebugLog((DEB_TRACE, "UPN logon %wZ\n", &Upn));
            }



        }
        else if ((LogonInfo->MessageType == KerbTicketLogon) ||
                 (LogonInfo->MessageType == KerbTicketUnlockLogon))
        {
            if (LogonInfo->MessageType == KerbTicketUnlockLogon)
            {
                if (SubmitBufferSize < sizeof(KERB_TICKET_UNLOCK_LOGON))
                {
                    D_DebugLog((DEB_ERROR,"Submit buffer to logon too small: %d. %ws, line %d\n",SubmitBufferSize, THIS_FILE, __LINE__));
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }
                PKERB_TICKET_UNLOCK_LOGON UnlockInfo = (PKERB_TICKET_UNLOCK_LOGON) LogonInfo;

                OldLogonId = UnlockInfo->LogonId;
                DoingUnlock = TRUE;
            }

            Status = KerbCreateTicketLogonSession(
                        pTempSubmitBuffer,
                        ClientBufferBase,
                        SubmitBufferSize,
                        LogonType,
                        &LogonSession,
                        &LogonId,
                        &WorkstationTicket,
                        &ForwardedTgt
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        //
        // The S4UToSelf Logon really is quite different
        // than any other form of logon.  As such, we're
        // going to branch out into the S4UToSelf protocol
        // code.
        //
        else if (LogonInfo->MessageType == KerbS4ULogon)
        {
            if (SubmitBufferSize < sizeof(KERB_S4U_LOGON))
            {
                D_DebugLog((DEB_ERROR,"Submit buffer to logon too small: %d. %ws, line %d\n",SubmitBufferSize, THIS_FILE, __LINE__));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            if ( LogonType != Network )
            {
                D_DebugLog((DEB_ERROR, "LogonType must be network for S4ULogon\n"));
                Status = STATUS_INVALID_LOGON_TYPE;
                goto Cleanup;
            }

            Status = KerbS4UToSelfLogon(
                        pTempSubmitBuffer,
                        ClientBufferBase,
                        SubmitBufferSize,
                        &LogonSession,
                        &LogonId,
                        &WorkstationTicket,
                        &S4UClientName,
                        &S4UClientRealm,
                        &AlternateLuid
                        );

            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR, "KerbS4UToSelfLogon failed - %x\n", Status));
                goto Cleanup;
            }
        }

        else
        {
            D_DebugLog((DEB_TRACE,"Invalid info class to logon: %d. %ws, line %d\n",
                LogonInfo->MessageType, THIS_FILE, __LINE__));
            Status = STATUS_INVALID_INFO_CLASS;
            goto Cleanup;
        }

        break;

    default:
        //
        // No other logon types are supported.
        //

        Status = STATUS_INVALID_LOGON_TYPE;
        D_DebugLog((DEB_ERROR, "Invalid logon type passed to LsaApLogonUserEx2: %d. %ws, line %d\n",LogonType, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE, "LsaApLogonUserEx2: attempting to logon user %wZ\\%wZ\n",
        &TempAuthority,
        &TempName
        ));

    //
    // If the KDC is not yet started, start it now.
    //

#ifndef WIN32_CHICAGO
    if ((KerbGlobalRole == KerbRoleDomainController) && !KerbKdcStarted)
    {
        D_DebugLog((DEB_TRACE_LOGON,"Waiting for KDC to start\n"));
        Status = KerbWaitForKdc( KerbGlobalKdcWaitTime );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_TRACE_LOGON,"Failed to wait for KDC to start\n"));
            goto Cleanup;
        }

    }
#endif // WIN32_CHICAGO

    //
    // If we don't have a workstation ticket already, attempt to get one now.
    //

    // Per bug 94726, if we're not part of an NT domain, then we should not require
    // the workstation ticket to perform the logon successfully.

    if (WorkstationTicket == NULL)
    {
        //
        // Get the initial TGT for the user. This routine figures out the real
        // principal names & realm names
        //

        Status = KerbGetTicketGrantingTicket(
                    LogonSession,
                    NULL,
                    NULL,
                    NULL,           // no credential
                    (Role == KerbRoleRealmlessWksta ? &AsTicket : NULL),
                    &CredentialKey
                    );

        if ( Status == STATUS_NO_TRUST_SAM_ACCOUNT )
        {
            Status = STATUS_NO_LOGON_SERVERS ;
        }


        if (NT_SUCCESS(Status))
        {
            if (Role != KerbRoleRealmlessWksta) // joined machine
            {
                KerbWriteLockLogonSessions(LogonSession);
                LogonSession->LogonSessionFlags &= ~KERB_LOGON_DEFERRED;
                KerbUnlockLogonSessions(LogonSession);

                //
                // Check to see if the client is from an MIT realm
                //

                KerbGlobalReadLock();

                (VOID) KerbLookupMitRealm(
                            &KerbGlobalDnsDomainName,
                            &MitRealm,
                            &UsedAlternateName
                            );

                Status = KerbDuplicateKdcName(
                            &MachineServiceName,
                            KerbGlobalMitMachineServiceName
                            );

                KerbGlobalReleaseLock();
                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                Status = KerbGetOurDomainName(
                            &DomainName
                            );

                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                //
                // Now that we have a TGT, we need to build a token.  The PAC is currently
                // hidden inside the TGT, so we need to get a ticket to this workstation
                //

                D_DebugLog((DEB_TRACE_LOGON,"Getting outbound ticket to "));
                D_KerbPrintKdcName((DEB_TRACE_LOGON, MachineServiceName));

                Status = KerbGetServiceTicket(
                            LogonSession,
                            NULL,               // no credential
                            NULL,
                            MachineServiceName,
                            &DomainName,
                            NULL,
                            ProcessFlags,
                            0,                  // no options
                            0,                  // no enc type
                            NULL,               // no error message
                            NULL,               // no authorization data
                            NULL,               // no TGT reply
                            &WorkstationTicket,
                            &LogonGuid
                            );

                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR,"LogonUser: Failed to get workstation ticket for %wZ\\%wZ: 0x%x. %ws, line %d\n",
                              &TempAuthority, &TempName, Status, THIS_FILE, __LINE__ ));
                    goto Cleanup;
                }
            }
            else
            {
                D_DebugLog((DEB_ERROR, "Nonjoined workstation\n"));
                DsysAssert(AsTicket != NULL);
                DsysAssert(MappedClientName.Buffer != NULL);

                Status = KerbCheckRealmlessLogonPolicy(
                                    AsTicket,
                                    ClientName,
                                    &ClientRealm
                                    );

                if (!NT_SUCCESS(Status))
                {
                    D_DebugLog((DEB_ERROR, "LogonUser:  Failed check for domainless logon\n"));
                    goto Cleanup;
                }
            }
        }
        else
        {
            DebugLog((DEB_WARN, "LogonUser: Failed to get TGT for %wZ\\%wZ : 0x%x\n",
                      &TempAuthority,
                      &TempName,
                      Status ));

            //
            // If this was a smart card logon, try logging on locally for
            // non-definitive errors:
            //

            if ( ( (LogonInfo->MessageType == KerbSmartCardLogon ) ||
                   (LogonInfo->MessageType == KerbSmartCardUnlockLogon ) ) &&
                 ( ( Status == STATUS_NO_LOGON_SERVERS ) ||
                   ( Status == STATUS_NETWORK_UNREACHABLE ) ||// From DsGetdcName
                   ( Status == STATUS_NETLOGON_NOT_STARTED ) ) )
                {

                Status = KerbDoLocalSmartCardLogon(
                                LogonSession,
                                TokenInformationType,
                                TokenInformation,
                                ProfileBufferLength,
                                ProfileBuffer,
                                PrimaryCredentials,
                                CachedCredentials,
                                &SCValidationInfo
                                );

                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR,"Failed smart card local logon: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
                    goto Cleanup;
                }

                LocalLogon = TRUE;

            }
            else
            {
                //
                // Not smart card
                //

                goto Cleanup;
            }
        }
    }

    //
    // If we didn't already build a ticket, do so now
    //

    if (!LocalLogon)
    {
        Status = KerbCreateTokenFromLogonTicket(
                    WorkstationTicket,
                    &LogonId,
                    LogonInfo,
                    RealmlessWkstaLogon,
                    LogonType,
                    &CredentialKey,
                    &ForwardedTgt,
                    &MappedClientName,
                    S4UClientName,
                    &S4UClientRealm,
                    &AlternateLuid,
                    LogonSession,
                    TokenInformationType,
                    TokenInformation,
                    ProfileBufferLength,
                    ProfileBuffer,
                    PrimaryCredentials,
                    CachedCredentials,
                    &ValidationInfo
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN,"LogonUser: Failed to create token from ticket: 0x%x\n",Status));
            goto Cleanup;
        }

        //
        // Add the password to the primary credentials.
        //

        if (LogonInfo->MessageType == KerbInteractiveLogon && !fSuppliedCertCred)
        {
            Status = KerbDuplicateString(
                        &PrimaryCredentials->Password,
                        &LogonInfo->Password
                        );

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            PrimaryCredentials->Flags |= PRIMARY_CRED_CLEAR_PASSWORD;
        }
    }

    //
    // Get the final doamin name and user name out of the logon session,
    // if it is different than the one used for logon.
    //

    KerbReadLockLogonSessions(LogonSession);
    if (!RtlEqualUnicodeString(
            &TempName,
            &PrimaryCredentials->DownlevelName,
            TRUE))
    {
        KerbFreeString(&TempName);
        Status = KerbDuplicateString(
                    &TempName,
                    &PrimaryCredentials->DownlevelName
                    );
        if (!NT_SUCCESS(Status))
        {
            KerbUnlockLogonSessions(LogonSession);
            goto Cleanup;
        }
    }

    if (!RtlEqualDomainName(
            &TempAuthority,
            &PrimaryCredentials->DomainName
            ))
    {
        KerbFreeString(&TempAuthority);
        Status = KerbDuplicateString(
                    &TempAuthority,
                    &PrimaryCredentials->DomainName
                    );
        if (!NT_SUCCESS(Status))
        {
            KerbUnlockLogonSessions(LogonSession);
            goto Cleanup;
        }
    }

    KerbUnlockLogonSessions(LogonSession);

    //
    // Finally create the logon session in the LSA
    //

    Status = LsaFunctions->CreateLogonSession( &LogonId );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to create logon session: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Add additional names to the logon session name map.  Ignore failure
    // as that just means GetUserNameEx calls for these name formats later
    // on will be satisfied by hitting the wire.
    //

    if (ValidationInfo || SCValidationInfo)
    {
        PNETLOGON_VALIDATION_SAM_INFO4 Tmp = (ValidationInfo ? ValidationInfo : SCValidationInfo);

        if (Tmp->FullName.Length)
        {
            D_DebugLog((DEB_TRACE_LOGON, "NameDisplay %wZ\n", &Tmp->FullName));
            I_LsaIAddNameToLogonSession(&LogonId, NameDisplay, &Tmp->FullName);
        }

        //
        // Smart cards use a "special" UPN for the logon cache, so don't
        // use it here, as the cached logon will provide us w/ bogus data...
        //
        if (Upn.Buffer != NULL)
        {
            D_DebugLog((DEB_TRACE_LOGON, "NameUserPrincipal %wZ\n", &Upn));
            I_LsaIAddNameToLogonSession(&LogonId, NameUserPrincipal, &Upn);
        }

        if (Tmp->DnsLogonDomainName.Length)
        {
            D_DebugLog((DEB_TRACE_LOGON, "NameDnsDomain %wZ\n", &Tmp->DnsLogonDomainName));
            I_LsaIAddNameToLogonSession(&LogonId, NameDnsDomain, &Tmp->DnsLogonDomainName);
        }
    }

    I_LsaISetLogonGuidInLogonSession(&LogonId, &LogonGuid);


    //
    // If this was an unlock operation, copy the authentication ticket
    // cache into the original logon session.
    //

    if (DoingUnlock)
    {
        KerbUpdateOldLogonSession(
            LogonSession,
            PrimaryCredentials,
            *CachedCredentials,
            &OldLogonId,
            WorkstationTicket
            );
    }
    *NewLogonId = LogonId;

Cleanup:

    //
    // This is a "fake" Info4 struct... Free UPN and dnsdomain
    // name manually -- normally a giant struct alloc'd by RPC
    //
    if (ValidationInfo)
    {
        KerbFreeString(&ValidationInfo->DnsLogonDomainName);
        KerbFreeString(&ValidationInfo->Upn);
        KerbFreeString(&ValidationInfo->FullName);
        KerbFree(ValidationInfo);
    }

    if (SCValidationInfo)
    {
        LocalFree(SCValidationInfo); // this was alloc'd by cache lookup.
    }


    KerbFreeString( &CredmanUserName );
    KerbFreeString( &CredmanDomainName );
    KerbFreeString( &CredmanPassword );
    KerbFreeString( &Upn );

    if (CertContext != NULL)
    {
        CertFreeCertificateContext(CertContext);
    }

    //
    // Restore the saved password
    //
    if ( ServiceSecretLogon ) {

        RtlCopyMemory( &LogonInfo->Password,
                       &SavedPassword,
                       sizeof( UNICODE_STRING ) );

        //
        // Free the secret value we read...
        //
        LsaIFree_LSAPR_CR_CIPHER_VALUE( SecretCurrent );
    }


    KerbFreeString( &CorrectRealm );
    KerbFreeKey(&CredentialKey);
    if (*AccountName != NULL)
    {
        **AccountName = TempName;
        TempName.Buffer = NULL;
    }

    if (*AuthenticatingAuthority != NULL)
    {
        **AuthenticatingAuthority = TempAuthority;
        TempAuthority.Buffer = NULL;
    }

    if (!NT_SUCCESS(Status))
    {
        //
        // Unlink the new logon session
        //

        if (LogonSession != NULL)
        {
            KerbReferenceLogonSessionByPointer(LogonSession, TRUE);
            KerbDereferenceLogonSession(LogonSession);
        }
        if (*ProfileBuffer != NULL)
        {
            LsaFunctions->FreeClientBuffer(NULL, *ProfileBuffer);
            *ProfileBuffer = NULL;
        }
        if (*CachedCredentials != NULL)
        {
            KerbFree(*CachedCredentials);
            *CachedCredentials = NULL;
        }

        //
        // Map status codes to prevent specific information from being
        // released about this user.
        //
        switch (Status) {
        case STATUS_WRONG_PASSWORD:
        case STATUS_NO_SUCH_USER:
        case STATUS_PKINIT_FAILURE:
        case STATUS_SMARTCARD_SUBSYSTEM_FAILURE:
        case STATUS_SMARTCARD_WRONG_PIN:
        case STATUS_SMARTCARD_CARD_BLOCKED:
        case STATUS_SMARTCARD_NO_CARD:
        case STATUS_SMARTCARD_NO_KEY_CONTAINER:
        case STATUS_SMARTCARD_NO_CERTIFICATE:
        case STATUS_SMARTCARD_NO_KEYSET:
        case STATUS_SMARTCARD_IO_ERROR:
        case STATUS_SMARTCARD_CERT_REVOKED:
        case STATUS_SMARTCARD_CERT_EXPIRED:
        case STATUS_REVOCATION_OFFLINE_C:
        case STATUS_REVOCATION_OFFLINE_KDC:
        case STATUS_ISSUING_CA_UNTRUSTED_KDC:
        case STATUS_ISSUING_CA_UNTRUSTED:
        case STATUS_PKINIT_NAME_MISMATCH:
        case STATUS_KDC_CERT_EXPIRED:
        case STATUS_KDC_CERT_REVOKED:
        //case STATUS_REVOCATION_OFFLINE_S: Wait for ntstatus.h to propagate
        //case STATUS_DC_CERT_REVOKED:
        case STATUS_PKINIT_CLIENT_FAILURE:


            //
            // sleep 3 seconds to "discourage" dictionary attacks.
            // Don't worry about interactive logon dictionary attacks.
            // They will be slow anyway.
            //
            // per bug 171041, SField, RichardW, CliffV all decided this
            // delay has almost zero value for Win2000.  Offline attacks at
            // sniffed wire traffic are more efficient and viable.  Further,
            // opimizations in logon code path make failed interactive logons.
            // very fast.
            //
            //
//            if (LogonType != Interactive) {
//                Sleep( 3000 );
//            }

            //
            // This is for auditing.  Make sure to clear it out before
            // passing it out of LSA to the caller.
            //

            *ApiSubStatus = Status;
            Status = STATUS_LOGON_FAILURE;
            break;

        case STATUS_INVALID_LOGON_HOURS:
        case STATUS_INVALID_WORKSTATION:
        case STATUS_PASSWORD_EXPIRED:
        case STATUS_ACCOUNT_DISABLED:
        case STATUS_SMARTCARD_LOGON_REQUIRED:
            *ApiSubStatus = Status;
            Status = STATUS_ACCOUNT_RESTRICTION;
            break;

        //
        // This shouldn't happen, but guard against it anyway.
        //
        case STATUS_ACCOUNT_RESTRICTION:
            *ApiSubStatus = STATUS_ACCOUNT_RESTRICTION;
            break;

        case STATUS_ACCOUNT_EXPIRED: // fix 122291
            *ApiSubStatus = STATUS_ACCOUNT_EXPIRED;
            break;

        default:
            break;

        }


        if (*TokenInformation != NULL)
        {
            KerbFree( *TokenInformation );
            *TokenInformation = NULL;
        }
        KerbFreeString(
            &PrimaryCredentials->DownlevelName
            );
        KerbFreeString(
            &PrimaryCredentials->DomainName
            );
        KerbFreeString(
            &PrimaryCredentials->LogonServer
            );
        KerbFreeString(
            &PrimaryCredentials->Password
            );
        if (PrimaryCredentials->UserSid != NULL)
        {
            KerbFree(PrimaryCredentials->UserSid);
            PrimaryCredentials->UserSid = NULL;
        }
        RtlZeroMemory(
            PrimaryCredentials,
            sizeof(SECPKG_PRIMARY_CRED)
            );

        D_DebugLog((DEB_ERROR, "LogonUser returned %x, %x\n", Status, *ApiSubStatus));
    }


    if (WorkstationTicket != NULL)
    {
        KerbDereferenceTicketCacheEntry( WorkstationTicket );
    }

    if (AsTicket != NULL)
    {
        KerbDereferenceTicketCacheEntry( AsTicket );
    }

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }

    KerbFreeKdcName(&ClientName);
    KerbFreeKdcName(&S4UClientName);

    KerbFreeString(&ClientRealm);

    KerbFreeString(
        &DomainName
        );

    KerbFreeString(
        &MappedClientName
        );

    KerbFreeString(
        &TempName
        );
    KerbFreeString(
        &TempAuthority
        );

    KerbFreeKdcName(
        &MachineServiceName
        );

    KerbFreeString(
        &S4UClientRealm
        );


    // Allocate the machine name here. Lsa will free it after auditing is
    // done

    *MachineName = (PUNICODE_STRING) KerbAllocate( sizeof( UNICODE_STRING ) );

    if ( *MachineName != NULL )
    {
        NTSTATUS TempStatus;

        KerbGlobalReadLock();
        TempStatus = KerbDuplicateString (*MachineName, &KerbGlobalMachineName);
        KerbGlobalReleaseLock();

        if(!NT_SUCCESS(TempStatus))
        {
            D_DebugLog((DEB_ERROR, "Failed to duplicate KerbGlobalMachineName\n"));
            ZeroMemory( *MachineName, sizeof(UNICODE_STRING) );
        }
    }

    if( KerbEventTraceFlag ) // Event Trace: KerbLogonUserEnd {Status, (LogonType), (Username), (Domain)}
    {
        INSERT_ULONG_INTO_MOF( *ApiSubStatus, LogonTraceInfo.MofData, 0 );
        LogonTraceInfo.EventTrace.Size = sizeof(EVENT_TRACE_HEADER) + sizeof(MOF_FIELD);

        if( LogonInfo != NULL )
        {
            UNICODE_STRING KerbLogonTypeString;

            PCWSTR KerbLogonTypeTable[] = // see enum _KERB_LOGON_SUBMIT_TYPE
            {   L"",L"",
                L"KerbInteractiveLogon",  // = 2
                L"",L"",L"",
                L"KerbSmartCardLogon",    // = 6
                L"KerbWorkstationUnlockLogon",
                L"KerbSmartCardUnlockLogon",
                L"KerbProxyLogon",
                L"KerbTicketLogon",
                L"KerbTicketUnlockLogon"
            };

            RtlInitUnicodeString( &KerbLogonTypeString, KerbLogonTypeTable[LogonInfo->MessageType] );

            INSERT_UNICODE_STRING_INTO_MOF( KerbLogonTypeString,        LogonTraceInfo.MofData, 1 );
            INSERT_UNICODE_STRING_INTO_MOF( LogonInfo->UserName,        LogonTraceInfo.MofData, 3 );
            INSERT_UNICODE_STRING_INTO_MOF( LogonInfo->LogonDomainName, LogonTraceInfo.MofData, 5 );
            LogonTraceInfo.EventTrace.Size += 6*sizeof(MOF_FIELD);
        }

        // Set trace parameters
        LogonTraceInfo.EventTrace.Guid       = KerbLogonGuid;
        LogonTraceInfo.EventTrace.Class.Type = EVENT_TRACE_TYPE_END;
        LogonTraceInfo.EventTrace.Flags      = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;

        TraceEvent(
            KerbTraceLoggerHandle,
            (PEVENT_TRACE_HEADER)&LogonTraceInfo
            );
    }

#if _WIN64

    if (fAllocatedSubmitBuffer)
    {
        KerbFree(pTempSubmitBuffer);
    }

#endif  // _WIN64

    return(Status);
}

#endif // WIN32_CHICAGO // later


//+-------------------------------------------------------------------------
//
//  Function:   LsaApLogonTerminated
//
//  Synopsis:   This routine is called whenever a logon session terminates
//              (the last token for it is closed). It dereferences the
//              logon session (if it exists), which may cause any
//              associated credentials or contexts to be run down.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
LsaApLogonTerminated(
    IN PLUID LogonId
    )
{
    PKERB_LOGON_SESSION LogonSession;

    D_DebugLog((DEB_TRACE_LSESS, "LsaApLogonTerminated called: 0x%x:0x%x\n",
        LogonId->HighPart, LogonId->LowPart ));



    LogonSession = KerbReferenceLogonSession(
                        LogonId,
                        TRUE            // unlink logon session
                        );
    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }
    return;
}

#ifdef WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   KerbSspiLogonUser
//
//  Synopsis:   Handles service, batch, and interactive logons
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


SECURITY_STATUS
KerbSspiLogonUser(
    IN LPTSTR PackageName,
    IN LPTSTR UserName,
    IN LPTSTR DomainName,
    IN LPTSTR Password
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_LOGON_SESSION LogonSession = NULL;
    UNICODE_STRING TempName = NULL_UNICODE_STRING;
    UNICODE_STRING TempAuthority = NULL_UNICODE_STRING;
    UNICODE_STRING TempPassword = NULL_UNICODE_STRING;
    UNICODE_STRING KdcServiceName = NULL_UNICODE_STRING;
    PKERB_INTERNAL_NAME KdcServiceKdcName = NULL;
    LUID LogonId;
    PKERB_MIT_REALM MitRealm = NULL;
    BOOLEAN UsedAlternateName = NULL;

    //
    // First initialize all the output parameters to NULL.
    //

    Status = STATUS_SUCCESS;
    KdcServiceName.Buffer = NULL;

    //
    // Initialize local pointers to NULL
    //

    LogonId.LowPart = 0;
    LogonId.HighPart = 0;

    //
    // Copy out the user name and Authenticating Authority so we can audit them.
    //

    // NOTE - Do we need to enforce username & password restrictions here
    // or will the redir do the job when we setuid to it?

    if ( UserName != NULL ) {

        Status = RtlCreateUnicodeStringFromAsciiz(
                        &TempName,
                        UserName);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if ( DomainName != NULL ) {

        Status = RtlCreateUnicodeStringFromAsciiz(
                        &TempAuthority,
                        DomainName);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    if ( Password != NULL ) {

        Status = RtlCreateUnicodeStringFromAsciiz(
                        &TempPassword,
                        Password);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Allocate a locally unique ID for this logon session. We will
    // create it in the LSA just before returning.
    //

    Status = NtAllocateLocallyUniqueId( &LogonId );

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to allocate locally unique ID: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Check to see if the client is from an MIT realm
    //

    (VOID) KerbLookupMitRealm(
                    &TempAuthority,
                    &MitRealm,
                    &UsedAlternateName
                    );

    if ((MitRealm != NULL) && UsedAlternateName)
    {
        KerbFreeString(&TempAuthority);
        Status = KerbDuplicateString(
                        &TempAuthority,
                        &MitRealm->RealmName
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    // For win95, if there is a logon session in our list, remove it.
    // This is generated from the logon session dumped in the registry.
    // But, we are about to do a new logon. Get rid of the old logon.
    // If the new one does not succeed, too bad. But, that's by design.

    LsaApLogonTerminated(&LogonId);

    //
    // Build a logon session to hold all this information
    //

    Status = KerbCreateLogonSession(
                    &LogonId,
                    &TempName,
                    &TempAuthority,
                    &TempPassword,
                    NULL,                       // no old password
                    PRIMARY_CRED_CLEAR_PASSWORD,
                    0,
                    Network,
                    FALSE,
                    &LogonSession
                    );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE, "KerbSspiLogonUser attempting to logon user %wZ\\%wZ\n",
        &TempAuthority,
        &TempName
        ));

    //
    // Now the real work of logon begins - getting a TGT and then a ticket
    // to this machine.
    //

    if (!KERB_SUCCESS(KerbBuildFullServiceKdcName(
                    &TempAuthority,
                    &KerbGlobalKdcServiceName,
                    KRB_NT_MS_PRINCIPAL,
                    &KdcServiceKdcName
                    )))

    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = KerbGetTicketGrantingTicket(
                LogonSession,
                NULL,
                NULL,
                NULL,           // no credential
                NULL,           // don't return ticket cache entry
                NULL            // don't return credential key
                );



    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN, "LogonUser: Failed to get authentication ticket for %wZ\\%wZ to %wZ: 0x%x\n",
            &TempAuthority,
            &TempName,
            &KdcServiceName,
            Status ));
        goto Cleanup;

    }

    KerbWriteLockLogonSessions(LogonSession);
    LogonSession->LogonSessionFlags &= ~KERB_LOGON_DEFERRED;
    KerbUnlockLogonSessions(LogonSession);

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        //
        // Unlink the new logon session
        //

        if (LogonSession != NULL)
        {
            KerbReferenceLogonSessionByPointer(LogonSession, TRUE);
            KerbDereferenceLogonSession(LogonSession);
        }

        //
        // Map status codes to prevent specific information from being
        // released about this user.
        //
        switch (Status) {
        case STATUS_WRONG_PASSWORD:
        case STATUS_NO_SUCH_USER:

            //
            // This is for auditing.  Make sure to clear it out before
            // passing it out of LSA to the caller.
            //

            Status = STATUS_LOGON_FAILURE;
            break;

        case STATUS_INVALID_LOGON_HOURS:
        case STATUS_INVALID_WORKSTATION:
        case STATUS_PASSWORD_EXPIRED:
        case STATUS_ACCOUNT_DISABLED:
        case STATUS_ACCOUNT_EXPIRED:
            Status = STATUS_ACCOUNT_RESTRICTION;
            break;

        //
        // This shouldn't happen, but guard against it anyway.
        //
        case STATUS_ACCOUNT_RESTRICTION:
            Status = STATUS_ACCOUNT_RESTRICTION;
            break;

        default:
            break;

        }

    }


    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }

    KerbFreeString(
        &TempName
        );
    KerbFreeString(
        &TempAuthority
        );
    KerbFreeString(
        &KdcServiceName
        );

    KerbFreeKdcName( &KdcServiceKdcName );
    D_DebugLog((DEB_TRACE, "SspiLogonUser: returns 0x%x\n", Status));
    return(Status);
}


#endif // WIN32_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\logonapi.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        logonapi.h
//
// Contents:    Prototypes and structures for Logon support in Kerberos
//
//
// History:     19-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------


#ifndef __LOGONAPI_H__
#define __LOGONAPI_H__


NTSTATUS
KerbGetAuthenticationTicket(
    IN OUT PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN BOOLEAN SUpplyPreauth,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN PUNICODE_STRING ServerRealm,
    IN PKERB_INTERNAL_NAME ClientFullName,
    IN ULONG TicketFlags,
    IN ULONG CacheFlags,
    OUT OPTIONAL PKERB_TICKET_CACHE_ENTRY * TicketCacheEntry,
    OUT OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey,
    OUT PUNICODE_STRING CorrectRealm
    );

#define KERB_GET_TICKET_NO_PAC                  0x00000001
#define KERB_GET_AUTH_TICKET_NO_CANONICALIZE    0x00000002

#define KERB_CLIENT_REFERRAL_MAX 3

NTSTATUS
KerbGetTicketGrantingTicket(
    IN OUT PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_CREDENTIAL Credential,
    IN OPTIONAL PKERB_CREDMAN_CRED CredManCredentials,
    IN OPTIONAL PUNICODE_STRING SuppRealm,
    OUT OPTIONAL PKERB_TICKET_CACHE_ENTRY * TicketCacheEntry,
    OUT OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey
    );

BOOLEAN
KerbPurgeServiceTicketAndTgt(
     IN PKERB_CONTEXT Context,
     IN OPTIONAL LSA_SEC_HANDLE CredentialHandle,
     IN OPTIONAL PKERB_CREDMAN_CRED CredManHandle
     );

NTSTATUS
KerbGetClientNameAndRealm(
    IN OPTIONAL LUID *pLogonId,
    IN PKERB_PRIMARY_CREDENTIAL PrimaryCreds,
    IN BOOLEAN SuppliedCreds,
    IN OPTIONAL PUNICODE_STRING SuppRealm,
    IN OUT OPTIONAL BOOLEAN * MitRealmUsed,
    IN BOOLEAN UseWkstaRealm,
    OUT PKERB_INTERNAL_NAME * ClientName,
    OUT PUNICODE_STRING ClientRealm
    );


#endif __LOGONAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\krbtoken.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        token.h
//
// Contents:    Prototypes and structures for token creation
//
//
// History:     1-May-1996      Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __TOKEN_H__
#define __TOKEN_H__

//
// All global variables declared as EXTERN will be allocated in the file
// that defines CREDMGR_ALLOCATE
//
#ifdef EXTERN
#undef EXTERN
#endif

#ifdef CREDMGR_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

EXTERN TOKEN_SOURCE KerberosSource;


#ifndef WIN32_CHICAGO
#ifndef notdef
NTSTATUS
KerbCreateTokenFromTicket(
    IN OPTIONAL PLUID AcceptingLogonId,
    IN OPTIONAL PKERB_AP_REQUEST Request,
    IN PKERB_ENCRYPTED_TICKET InternalTicket,
    IN PKERB_AUTHENTICATOR InternalAuthenticator,
    IN ULONG ContextFlags,
    IN PKERB_ENCRYPTION_KEY TicketKey,
    IN PUNICODE_STRING ServiceDomain,
    IN KERB_ENCRYPTION_KEY* pSessionKey,
    OUT PLUID NewLogonId,
    OUT PSID * UserSid,
    OUT PHANDLE NewTokenHandle,
    OUT PUNICODE_STRING ClientName,
    OUT PUNICODE_STRING ClientDomain,
    OUT PUNICODE_STRING ClientNetbiosDomain,
    OUT OPTIONAL PS4U_DELEGATION_INFO* S4uDelegationInfo
    );
#endif

NTSTATUS
KerbCreateTokenFromLogonTicket(
    IN PKERB_TICKET_CACHE_ENTRY LogonTicket,
    IN PLUID LogonId,
    IN PKERB_INTERACTIVE_LOGON LogonInfo,
    IN BOOLEAN RealmlessWksta,
    IN SECURITY_LOGON_TYPE LogonType,
    IN OPTIONAL PKERB_ENCRYPTION_KEY TicketKey,
    IN OPTIONAL PKERB_MESSAGE_BUFFER ForwardedTgt,
    IN OPTIONAL PUNICODE_STRING MappedClientName,
    IN OPTIONAL PKERB_INTERNAL_NAME S4UClient,
    IN OPTIONAL PUNICODE_STRING S4URealm,
    IN OPTIONAL PLUID AlternateLuid,
    IN PKERB_LOGON_SESSION LogonSession,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *NewTokenInformation,
    OUT PULONG ProfileBufferLength,
    OUT PVOID * ProfileBuffer,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCredentials,
    OUT PNETLOGON_VALIDATION_SAM_INFO4 * ppValidationInfo
    );

NTSTATUS
KerbMakeTokenInformationV2(
    IN  PNETLOGON_VALIDATION_SAM_INFO3 UserInfo,
    IN  BOOLEAN IsLocalSystem,
    OUT PLSA_TOKEN_INFORMATION_V2 *TokenInformation
    );

NTSTATUS
KerbAllocateInteractiveProfile (
    OUT PKERB_INTERACTIVE_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO3 UserInfo,
    IN  PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_ENCRYPTED_TICKET LogonTicket,
    IN OPTIONAL PKERB_INTERACTIVE_LOGON KerbLogonInfo
    );

NTSTATUS
KerbGetCredsFromU2UTicket(
    IN PKERB_TICKET_CACHE_ENTRY U2UTicket,
    IN PKERB_TICKET_CACHE_ENTRY Tgt,
    IN OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * OutputCreds,
    OUT PNETLOGON_VALIDATION_SAM_INFO3*  ValidationInfo
    );

VOID
KerbCacheLogonInformation(
    IN PUNICODE_STRING LogonUserName,
    IN PUNICODE_STRING LogonDomainName,
    IN OPTIONAL PUNICODE_STRING Password,
    IN OPTIONAL PUNICODE_STRING DnsDomainName,
    IN OPTIONAL PUNICODE_STRING Upn,
    IN OPTIONAL KERB_LOGON_SESSION* LogonSession,
    IN ULONG Flags,
    IN OPTIONAL PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo,
    IN OPTIONAL PVOID SupplementalCreds,
    IN OPTIONAL ULONG SupplementalCredSize
    );

#endif // WIN32_CHICAGO

#endif // __TOKEN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\krbtoken.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        token.cxx
//
// Contents:    Routines building access tokens
//
//
// History:     1-May-1996      Created         MikeSw
//              26-Sep-1998   ChandanS
//                            Added more debugging support etc.
//
//------------------------------------------------------------------------
#include <kerb.hxx>
#include <kerbp.h>
#include <pac.hxx>
#include <utils.hxx>

#ifdef DEBUG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif


//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifyAuthData
//
//  Synopsis:   Verifies that we should not be rejecting the auth data
//              Accepted auth data is anything we know about and even values
//              Odd values and unknown auth data is rejected
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbVerifyAuthData(
    IN PKERB_AUTHORIZATION_DATA AuthData
    )
{
    PKERB_AUTHORIZATION_DATA TempData = AuthData;

    while (TempData != NULL)
    {
        if ((TempData->value.auth_data_type & 1) != 0)
        {

            switch(TempData->value.auth_data_type)
            {
            case KERB_AUTH_OSF_DCE:
            case KERB_AUTH_SESAME:
            case KERB_AUTH_DATA_PAC:
            case -KERB_AUTH_DATA_PAC:           // obsolete pac id
            case KERB_AUTH_PROXY_ANNOTATION:
            case KERB_AUTH_DATA_IF_RELEVANT:
            case KERB_AUTH_DATA_KDC_ISSUED:
#ifdef RESTRICTED_TOKEN
            case KERB_AUTH_DATA_TOKEN_RESTRICTIONS:
#endif
                break;
            default:
                D_DebugLog((DEB_ERROR,"Unknown auth type: %d\n",TempData->value.auth_data_type));
                return(FALSE);

            }
        }
        TempData = TempData->next;
    }
    return(TRUE);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbApplyTokenRestrictions
//
//  Synopsis:   Applies restrictions to a fresh token
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbApplyTokenRestrictions(
    IN PKERB_AUTHORIZATION_DATA AuthData,
    IN OUT PHANDLE TokenHandle
    )
{

    PKERB_TOKEN_RESTRICTIONS Restrictions = NULL;
    HANDLE RestrictedToken = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    Status = PAC_DecodeTokenRestrictions(
                AuthData->value.auth_data.value,
                AuthData->value.auth_data.length,
                &Restrictions
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Failed to decode token restrictions: 0x%x\n",Status));
        goto Cleanup;
    }

    //
    // If there are any restrictions, apply them here.
    //

    if (Restrictions->Flags != 0)
    {
        Status = NtFilterToken(
                    *TokenHandle,
                    0,                  // no flags,
                    (Restrictions->Flags & KERB_TOKEN_RESTRICTION_DISABLE_GROUPS) != 0 ? (PTOKEN_GROUPS) Restrictions->GroupsToDisable : NULL,
                    (Restrictions->Flags & KERB_TOKEN_RESTRICTION_DELETE_PRIVS) != 0 ? (PTOKEN_PRIVILEGES) Restrictions->PrivilegesToDelete : NULL,
                    (Restrictions->Flags & KERB_TOKEN_RESTRICTION_RESTRICT_SIDS) != 0 ? (PTOKEN_GROUPS) Restrictions->RestrictedSids : NULL,
                    &RestrictedToken
                    );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to filter token: 0x%x\n",Status));
            goto Cleanup;
        }
        NtClose(*TokenHandle);
        *TokenHandle = RestrictedToken;
        RestrictedToken = NULL;

    }

Cleanup:
    if (Restrictions != NULL)
    {
        MIDL_user_free(Restrictions);
    }
    if (RestrictedToken != NULL)
    {
        NtClose(RestrictedToken);
    }
    return(Status);
}
#ifdef RESTRICTED_TOKEN
//+-------------------------------------------------------------------------
//
//  Function:   KerbApplyAuthDataRestrictions
//
//  Synopsis:   Applies any restrictions from the auth data to the to token
//              and logon session.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbApplyAuthDataRestrictions(
    IN OUT PHANDLE TokenHandle,
    IN PKERB_AUTHORIZATION_DATA AuthData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_AUTHORIZATION_DATA TempData = AuthData;

    while (TempData != NULL)
    {
        if ((TempData->value.auth_data_type & 1) != 0)
        {

            switch(TempData->value.auth_data_type)
            {
            case KERB_AUTH_DATA_TOKEN_RESTRICTIONS:
                Status = KerbApplyTokenRestrictions(
                            TempData,
                            TokenHandle
                            );
                if (!NT_SUCCESS(Status))
                {
                    D_DebugLog((DEB_ERROR,"Failed to apply token restrictions: 0x%x\n",Status));
                    goto Cleanup;
                    break;
                }
            default:
                break;
            }
        }
        TempData = TempData->next;
    }
Cleanup:
    return(Status);
}
#endif

//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifyPacSignature
//
//  Synopsis:   Verifies the server signature on a PAC and if necessary
//              calls the KDC to verify the KDC signature.
//
//  Effects:
//
//  Arguments:  Pac - an unmarshalled pac
//              EncryptionKey - Key used to decrypt the ticket & verify the pac
//
//
//  Requires:
//
//  Returns:
//
//  Notes:      No locks should be held while calling this function
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbVerifyPacSignature(
    IN PUNICODE_STRING ServiceDomain,
    IN PPACTYPE Pac,
    IN ULONG PacSize,
    IN PKERB_ENCRYPTION_KEY EncryptionKey,
    IN PKERB_ENCRYPTED_TICKET Ticket,
    IN BOOLEAN CheckKdcSignature,
    OUT PNETLOGON_VALIDATION_SAM_INFO3 * ValidationInfo,
    OUT OPTIONAL PS4U_DELEGATION_INFO* S4uDelegationInfo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    NTSTATUS SubStatus;
    PKERB_VERIFY_PAC_REQUEST VerifyRequest = NULL;
    PMSV1_0_PASSTHROUGH_REQUEST PassthroughRequest = NULL;
    PMSV1_0_PASSTHROUGH_RESPONSE PassthroughResponse = NULL;
    ULONG RequestSize;
    ULONG ResponseSize;
    PCHECKSUM_FUNCTION Check = NULL ;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PPAC_SIGNATURE_DATA ServerSignature = NULL;
    PPAC_SIGNATURE_DATA PrivSvrSignature = NULL;
    PPAC_INFO_BUFFER ServerBuffer = NULL;
    PPAC_INFO_BUFFER PrivSvrBuffer = NULL;
    PPAC_INFO_BUFFER LogonInfo = NULL;
    PPAC_INFO_BUFFER ExtraLogonInfo = NULL;

    PPAC_INFO_BUFFER ClientBuffer = NULL;
    PPAC_INFO_BUFFER DelegationInfoBuffer = NULL;
    PPAC_CLIENT_INFO ClientInfo = NULL;
    UCHAR LocalChecksum[20];
    UCHAR LocalServerChecksum[20];
    UCHAR LocalPrivSvrChecksum[20];
    SECPKG_CLIENT_INFO LsaClientInfo;
    ULONG SignatureSize;
    PUCHAR Where;
    UNICODE_STRING MsvPackageName = CONSTANT_UNICODE_STRING(TEXT(MSV1_0_PACKAGE_NAME));
    ULONG NameType;
    UNICODE_STRING ClientName = {0};

    *ValidationInfo = NULL;

    //
    // Get the various pieces we need out of the PAC - the logon information
    // and the two signatures.
    //

    LogonInfo = PAC_Find(
                    Pac,
                    PAC_LOGON_INFO,
                    NULL
                    );
    if (LogonInfo == NULL)
    {
        D_DebugLog((DEB_ERROR,"Failed to find logon info! %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Verify that we don't have multiple pacs.
    //
    ExtraLogonInfo = PAC_Find(
                        Pac,
                        PAC_LOGON_INFO,
                        LogonInfo
                        );

    if ( ExtraLogonInfo )
    {
        DsysAssert(FALSE);
        DebugLog((DEB_ERROR, "We have multiple PAC entries \n"));
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // See if the delegation info is in the PAC
    //
    DelegationInfoBuffer = PAC_Find(
                               Pac,
                               PAC_DELEGATION_INFO,
                               NULL
                               );

    //
    // Get the PAC signature(s)
    //
    ServerBuffer = PAC_Find(
                        Pac,
                        PAC_SERVER_CHECKSUM,
                        NULL
                        );

    PrivSvrBuffer = PAC_Find(
                        Pac,
                        PAC_PRIVSVR_CHECKSUM,
                        NULL
                        );

    if ((ServerBuffer == NULL) || (PrivSvrBuffer == NULL))
    {

        D_DebugLog((DEB_ERROR, "Pac found with no signature!\n"));
        return(STATUS_LOGON_FAILURE);
    }

    //
    // Now verify the server checksum. First compute the checksum
    // over the logon info.
    //

    ServerSignature = (PPAC_SIGNATURE_DATA) ServerBuffer->Data;
    if ((sizeof(*ServerSignature) > ServerBuffer->cbBufferSize) ||
        (PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize) > sizeof(LocalServerChecksum)))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    PrivSvrSignature = (PPAC_SIGNATURE_DATA) PrivSvrBuffer->Data;
    if ((sizeof(*PrivSvrSignature) > PrivSvrBuffer->cbBufferSize) ||
        (PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize) > sizeof(LocalPrivSvrChecksum)))

    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Copy out the signature so we can zero the signature fields before
    // checksumming
    //

    RtlCopyMemory(
        LocalServerChecksum,
        ServerSignature->Signature,
        PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize)
        );

    RtlZeroMemory(
        ServerSignature->Signature,
        PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize)
        );

    RtlCopyMemory(
        LocalPrivSvrChecksum,
        PrivSvrSignature->Signature,
        PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)
        );
    RtlZeroMemory(
        PrivSvrSignature->Signature,
        PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize)
        );

    //
    // Now remarshal the PAC before checksumming.
    //

    if (!PAC_ReMarshal(Pac,PacSize))
    {
        DsysAssert(!"PAC_Remarhsal failed");
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    //
    // Locate the checksum of the logon info & compute it.
    //

    Status = CDLocateCheckSum(
                ServerSignature->SignatureType,
                &Check
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (Check->CheckSumSize > sizeof(LocalChecksum)) {
        DsysAssert(Check->CheckSumSize > sizeof(LocalChecksum));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // if available use the Ex2 version for keyed checksums where checksum
    // must be passed in on verification
    //
    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    EncryptionKey->keyvalue.value,
                    EncryptionKey->keyvalue.length,
                    LocalServerChecksum,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    EncryptionKey->keyvalue.value,
                    EncryptionKey->keyvalue.length,
                    KERB_NON_KERB_CKSUM_SALT,
                    &CheckBuffer
                    );
    }
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;

    }
    Check->Sum(
        CheckBuffer,
        PacSize,
        (PUCHAR) Pac
        );

    Check->Finalize(
        CheckBuffer,
        LocalChecksum
        );

    Check->Finish(&CheckBuffer);

    //
    // Now compare the local checksum to the supplied checksum.
    //

    if (Check->CheckSumSize != PAC_CHECKSUM_SIZE(ServerBuffer->cbBufferSize))
    {
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    if (!RtlEqualMemory(
            LocalChecksum,
            LocalServerChecksum,
            Check->CheckSumSize
            ))
    {
        DebugLog((DEB_ERROR, "Checksum on the PAC does not match! %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Now unmarshal the PAC so that the caller will have it back the
    // way they started.
    //

    if (!PAC_UnMarshal(Pac,PacSize))
    {
        DsysAssert(!"PAC_UnMarshal failed");
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    //
    // Check the client info, if present,
    //

    ClientBuffer = PAC_Find(
                    Pac,
                    PAC_CLIENT_INFO_TYPE,
                    NULL
                    );
    if (ClientBuffer != NULL)
    {
        TimeStamp ClientId;
        UNICODE_STRING PacClientName = {0};

        if (ClientBuffer->cbBufferSize < sizeof(PAC_CLIENT_INFO))
        {
            D_DebugLog((DEB_ERROR, "Clientinfo is too small: %d instead of %d. %ws, line %d\n",
                ClientBuffer->cbBufferSize, sizeof(PAC_CLIENT_INFO), THIS_FILE, __LINE__));
            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }
        ClientInfo = (PPAC_CLIENT_INFO) ClientBuffer->Data;
        if ((ClientInfo->NameLength - ANYSIZE_ARRAY * sizeof(WCHAR) + sizeof(PPAC_CLIENT_INFO))  > ClientBuffer->cbBufferSize)
        {
            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }
        KerbConvertGeneralizedTimeToLargeInt(
            &ClientId,
            &Ticket->authtime,
            0                           // no usec
            );
        if (!RtlEqualMemory(
                &ClientId,
                &ClientInfo->ClientId,
                sizeof(TimeStamp)
                ))
        {
            D_DebugLog((DEB_ERROR, "Client IDs don't match. %ws, line %d\n", THIS_FILE, __LINE__));
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }
        //
        // Check the name now
        //

        PacClientName.Buffer = ClientInfo->Name;
        PacClientName.Length = PacClientName.MaximumLength = ClientInfo->NameLength;

        if (KERB_SUCCESS(KerbConvertPrincipalNameToString(
                            &ClientName,
                            &NameType,
                            &Ticket->client_name
                            )))
        {
            if (!RtlEqualUnicodeString(
                    &ClientName,
                    &PacClientName,
                    TRUE))
            {
                D_DebugLog((DEB_ERROR,"Client names don't match: %wZ vs %wZ. %ws, line %d\n",
                    &PacClientName, &ClientName, THIS_FILE, __LINE__ ));
                Status = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }
    else
    {
        //
        // We *MUST* have a client info segment.  This keeps people from mis-using the pac
        //
        DebugLog((DEB_ERROR, "Missing client info!\n"));
        DsysAssert(FALSE);
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Unmarshall the logon info. We need to do this to get the logon domain
    // out to use for the pass-through.
    //


    Status = PAC_UnmarshallValidationInfo(
                ValidationInfo,
                LogonInfo->Data,
                LogonInfo->cbBufferSize
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (S4uDelegationInfo && DelegationInfoBuffer)
    {
        Status = UnmarshalS4UDelegationInformation(
                    DelegationInfoBuffer->cbBufferSize,
                    DelegationInfoBuffer->Data,
                    S4uDelegationInfo
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "KerbVerifyPacSignature failed to unmarshall S4U delgation info %#x\n", Status));
            goto Cleanup;
        }
    }

    //
    // If we don't need to check the KDC signature, bail now. This is for
    // tokens that can't be used for impersonation
    //

    if (!CheckKdcSignature)
    {
        goto Cleanup;

    }
    //
    // Now check to see if the client has TCB privilege. It it does, we
    // are done. Otherwise we need to call the KDC to verify the PAC.
    //

    Status = LsaFunctions->GetClientInfo(&LsaClientInfo);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (LsaClientInfo.HasTcbPrivilege)
    {

        goto Cleanup;
    }

    //
    // also let networkservice through.
    //

    {
        LUID NetworkServiceLuid = NETWORKSERVICE_LUID;

        if( RtlEqualLuid( &NetworkServiceLuid, &LsaClientInfo.LogonId ) )
        {
            goto Cleanup;
        }
    }

    //
    // We have to pass off to the DC so build the request.
    //


    SignatureSize = PAC_CHECKSUM_SIZE(PrivSvrBuffer->cbBufferSize);
    RequestSize = sizeof(MSV1_0_PASSTHROUGH_REQUEST) +
                    ROUND_UP_COUNT(ServiceDomain->Length, ALIGN_LPTSTR) +
                    ROUND_UP_COUNT(KerbPackageName.Length, ALIGN_LPTSTR) +
                    sizeof(KERB_VERIFY_PAC_REQUEST) - sizeof(UCHAR) * ANYSIZE_ARRAY +
                    Check->CheckSumSize +
                    SignatureSize;

    SafeAllocaAllocate(PassthroughRequest, RequestSize);

    if (PassthroughRequest == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }
    Where = (PUCHAR) (PassthroughRequest + 1);

    PassthroughRequest->MessageType = MsV1_0GenericPassthrough;

    PassthroughRequest->DomainName = *ServiceDomain;
    PassthroughRequest->DomainName.Buffer = (LPWSTR) Where;
    RtlCopyMemory(
        Where,
        ServiceDomain->Buffer,
        ServiceDomain->Length
        );
    Where += ROUND_UP_COUNT(ServiceDomain->Length, ALIGN_LPTSTR);

    PassthroughRequest->PackageName = KerbPackageName;

    PassthroughRequest->PackageName.Buffer = (LPWSTR) Where;
    RtlCopyMemory(
        Where,
        KerbPackageName.Buffer,
        KerbPackageName.Length
        );
    Where += ROUND_UP_COUNT(KerbPackageName.Length, ALIGN_LPTSTR);
    PassthroughRequest->LogonData = Where;
    PassthroughRequest->DataLength = sizeof(KERB_VERIFY_PAC_REQUEST) - sizeof(UCHAR) * ANYSIZE_ARRAY +
                                        Check->CheckSumSize +
                                        SignatureSize;
    VerifyRequest = (PKERB_VERIFY_PAC_REQUEST) PassthroughRequest->LogonData;
    VerifyRequest->MessageType = KerbVerifyPacMessage;

    VerifyRequest->ChecksumLength = Check->CheckSumSize;
    VerifyRequest->SignatureType = PrivSvrSignature->SignatureType;
    VerifyRequest->SignatureLength = SignatureSize;

    RtlCopyMemory(
        VerifyRequest->ChecksumAndSignature,
        LocalChecksum,
        Check->CheckSumSize
        );
    RtlCopyMemory(
        VerifyRequest->ChecksumAndSignature + Check->CheckSumSize,
        LocalPrivSvrChecksum,
        SignatureSize
        );

    //
    // We've build the buffer, now call NTLM to pass it through.
    //

    Status = LsaFunctions->CallPackage(
                &MsvPackageName,
                PassthroughRequest,
                RequestSize,
                (PVOID *) &PassthroughResponse,
                &ResponseSize,
                &SubStatus
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to call MSV package to verify PAC: 0x%x. %ws, line %d\n", Status, THIS_FILE, __LINE__));
        if (Status == STATUS_INVALID_INFO_CLASS)
        {
            Status = STATUS_LOGON_FAILURE;
        }
        goto Cleanup;
    }

    if (!NT_SUCCESS(SubStatus))
    {
        Status = SubStatus;
        DebugLog((DEB_ERROR, "KDC failed to verify PAC signature: 0x%x. %ws, line %d\n", Status, THIS_FILE, __LINE__));
        if ((Status == STATUS_INVALID_INFO_CLASS) ||
            (Status == STATUS_INVALID_SERVER_STATE) ||
            (Status == STATUS_NO_SUCH_USER))
        {
            Status = STATUS_PRIVILEGE_NOT_HELD;
        }
        goto Cleanup;
    }

Cleanup:

    KerbFreeString(&ClientName);
    if ( ( CheckBuffer != NULL ) &&
         ( Check != NULL ) )
    {
        Check->Finish(&CheckBuffer);
    }

    SafeAllocaFree(PassthroughRequest);

    if (PassthroughResponse != NULL)
    {
        LsaFunctions->FreeReturnBuffer(PassthroughResponse);
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbPutClientString
//
//  Synopsis:   Copies a string into a buffer that will be copied to the
//              client's address space
//
//  Effects:
//
//  Arguments:  Where - Location in local buffer to place string.
//              Delta - Difference in addresses of local and client buffers.
//              OutString - Receives 'put' string
//              InString - String to 'put'
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutWOWClientString.  Make sure any
//              changes made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
KerbPutClientString(
    IN OUT PUCHAR * Where,
    IN LONG_PTR Delta,
    IN PUNICODE_STRING OutString,
    IN PUNICODE_STRING InString
    )
{

    if (InString->Length == 0)
    {
        OutString->Buffer = NULL;
        OutString->Length = OutString->MaximumLength = 0;
    }
    else
    {
        RtlCopyMemory(
            *Where,
            InString->Buffer,
            InString->Length
            );

        OutString->Buffer = (LPWSTR) (*Where + Delta);
        OutString->Length = InString->Length;
        *Where += InString->Length;
        *(LPWSTR) (*Where) = L'\0';
        *Where += sizeof(WCHAR);
        OutString->MaximumLength = OutString->Length + sizeof(WCHAR);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAllocateInteractiveProfile
//
//  Synopsis:   This allocates and fills in the clients interactive profile.
//
//  Effects:
//
//  Arguments:
//
//    ProfileBuffer - Is used to return the address of the profile
//        buffer in the client process.  This routine is
//        responsible for allocating and returning the profile buffer
//        within the client process.  However, if the caller subsequently
//        encounters an error which prevents a successful logon, then
//        then it will take care of deallocating the buffer.  This
//        buffer is allocated with the AllocateClientBuffer() service.
//
//     ProfileBufferSize - Receives the Size (in bytes) of the
//        returned profile buffer.
//
//     NlpUser - Contains the validation information which is
//        to be copied in the ProfileBuffer.
//
//     LogonSession - Logon session structure containing certificate
//        context for smart card logons.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:      stolen from private\lsa\msv1_0\nlp.c
//
//              Some of this code is (effectively) duplicated in
//              KerbAllocateInteractiveWOWBuffer.  Make sure any
//              changes made here are applied there as well.
//
//--------------------------------------------------------------------------


NTSTATUS
KerbAllocateInteractiveProfile (
    OUT PKERB_INTERACTIVE_PROFILE *ProfileBuffer,
    OUT PULONG ProfileBufferSize,
    IN  PNETLOGON_VALIDATION_SAM_INFO3 UserInfo,
    IN  PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_ENCRYPTED_TICKET LogonTicket,
    IN OPTIONAL PKERB_INTERACTIVE_LOGON KerbLogonInfo
    )
{
    NTSTATUS Status;
    PKERB_INTERACTIVE_PROFILE LocalProfileBuffer = NULL;
    PKERB_SMART_CARD_PROFILE SmartCardProfile = NULL;
    PKERB_TICKET_PROFILE TicketProfile = NULL;
    PUCHAR ClientBufferBase = NULL;
    PUCHAR Where = NULL;
    LONG_PTR Delta = 0;
    BOOLEAN BuildSmartCardProfile = FALSE;
    BOOLEAN BuildTicketProfile = FALSE;

    //
    // Alocate the profile buffer to return to the client
    //

    KerbReadLockLogonSessions( LogonSession );

#if _WIN64

    SECPKG_CALL_INFO  CallInfo;

    if(!LsaFunctions->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

#endif  // _WIN64

    *ProfileBuffer = NULL;

    if ((LogonSession->PrimaryCredentials.PublicKeyCreds != NULL) &&
        (LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext  != NULL))
    {
        BuildSmartCardProfile = TRUE;
    }
    else if (ARGUMENT_PRESENT(KerbLogonInfo) &&
             (KerbLogonInfo->MessageType == KerbTicketLogon) ||
             (KerbLogonInfo->MessageType == KerbTicketUnlockLogon))
    {
        DsysAssert(ARGUMENT_PRESENT(LogonTicket));
        BuildTicketProfile = TRUE;
        KerbReadLockTicketCache();
    }

    //
    // NOTE:  The 64-bit code below is (effectively) duplicated in
    //        the WOW helper routine.  If modifying one, make sure
    //        to apply the change(s) to the other as well.
    //

#if _WIN64

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        Status = KerbAllocateInteractiveWOWBuffer(&LocalProfileBuffer,
                                                  ProfileBufferSize,
                                                  UserInfo,
                                                  LogonSession,
                                                  LogonTicket,
                                                  KerbLogonInfo,
                                                  &ClientBufferBase,
                                                  BuildSmartCardProfile,
                                                  BuildTicketProfile);

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
    else
    {

#endif  // _WIN64

        if (BuildSmartCardProfile)
        {
            *ProfileBufferSize = sizeof(KERB_SMART_CARD_PROFILE) +
                    LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext->cbCertEncoded;
        }
        else if (BuildTicketProfile)
        {
            *ProfileBufferSize = sizeof(KERB_TICKET_PROFILE) +
                    LogonTicket->key.keyvalue.length;
        }
        else
        {
            *ProfileBufferSize = sizeof(KERB_INTERACTIVE_PROFILE);
        }

        *ProfileBufferSize +=
            UserInfo->LogonScript.Length + sizeof(WCHAR) +
            UserInfo->HomeDirectory.Length + sizeof(WCHAR) +
            UserInfo->HomeDirectoryDrive.Length + sizeof(WCHAR) +
            UserInfo->FullName.Length + sizeof(WCHAR) +
            UserInfo->ProfilePath.Length + sizeof(WCHAR) +
            UserInfo->LogonServer.Length + sizeof(WCHAR);

        SafeAllocaAllocate(LocalProfileBuffer, *ProfileBufferSize);

        if (LocalProfileBuffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Status = LsaFunctions->AllocateClientBuffer(
                    NULL,
                    *ProfileBufferSize,
                    (PVOID *) &ClientBufferBase
                    );

        if ( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }

        Delta = (LONG_PTR) (ClientBufferBase - (PUCHAR) LocalProfileBuffer) ;

        //
        // Don't walk over smart card data
        //

        if (BuildSmartCardProfile)
        {
            Where = (PUCHAR) ((PKERB_SMART_CARD_PROFILE) LocalProfileBuffer + 1);
        }
        else if (BuildTicketProfile)
        {
            Where = (PUCHAR) ((PKERB_TICKET_PROFILE) LocalProfileBuffer + 1);
        }
        else
        {
            Where = (PUCHAR) (LocalProfileBuffer + 1);
        }

        //
        // Copy the scalar fields into the profile buffer.
        //

        LocalProfileBuffer->MessageType = KerbInteractiveProfile;
        LocalProfileBuffer->LogonCount = UserInfo->LogonCount;
        LocalProfileBuffer->BadPasswordCount= UserInfo->BadPasswordCount;
        OLD_TO_NEW_LARGE_INTEGER( UserInfo->LogonTime,
                                  LocalProfileBuffer->LogonTime );
        OLD_TO_NEW_LARGE_INTEGER( UserInfo->LogoffTime,
                                  LocalProfileBuffer->LogoffTime );
        OLD_TO_NEW_LARGE_INTEGER( UserInfo->KickOffTime,
                                  LocalProfileBuffer->KickOffTime );
        OLD_TO_NEW_LARGE_INTEGER( UserInfo->PasswordLastSet,
                                  LocalProfileBuffer->PasswordLastSet );
        OLD_TO_NEW_LARGE_INTEGER( UserInfo->PasswordCanChange,
                                  LocalProfileBuffer->PasswordCanChange );
        OLD_TO_NEW_LARGE_INTEGER( UserInfo->PasswordMustChange,
                                  LocalProfileBuffer->PasswordMustChange );
        LocalProfileBuffer->UserFlags = UserInfo->UserFlags;

        //
        // Copy the Unicode strings into the profile buffer.
        //

        KerbPutClientString(&Where,
                            Delta,
                            &LocalProfileBuffer->LogonScript,
                            &UserInfo->LogonScript );

        KerbPutClientString(&Where,
                            Delta,
                            &LocalProfileBuffer->HomeDirectory,
                            &UserInfo->HomeDirectory );

        KerbPutClientString(&Where,
                            Delta,
                            &LocalProfileBuffer->HomeDirectoryDrive,
                            &UserInfo->HomeDirectoryDrive );

        KerbPutClientString(&Where,
                            Delta,
                            &LocalProfileBuffer->FullName,
                            &UserInfo->FullName );

        KerbPutClientString(&Where,
                            Delta,
                            &LocalProfileBuffer->ProfilePath,
                            &UserInfo->ProfilePath );

        KerbPutClientString(&Where,
                            Delta,
                            &LocalProfileBuffer->LogonServer,
                            &UserInfo->LogonServer );

        if (BuildSmartCardProfile)
        {
            LocalProfileBuffer->MessageType = KerbSmartCardProfile;
            SmartCardProfile = (PKERB_SMART_CARD_PROFILE) LocalProfileBuffer;
            SmartCardProfile->CertificateSize = LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext->cbCertEncoded;
            SmartCardProfile->CertificateData = (PUCHAR) Where + Delta;
            RtlCopyMemory(
                Where,
                LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext->pbCertEncoded,
                SmartCardProfile->CertificateSize
                );
            Where += SmartCardProfile->CertificateSize;
        }
        else if (BuildTicketProfile)
        {
            LocalProfileBuffer->MessageType = KerbTicketProfile;
            TicketProfile = (PKERB_TICKET_PROFILE) LocalProfileBuffer;

            //
            // If the key is exportable or we are domestic, return the key
            //

            TicketProfile->SessionKey.KeyType = LogonTicket->key.keytype;
            TicketProfile->SessionKey.Length = LogonTicket->key.keyvalue.length;
            TicketProfile->SessionKey.Value = (PUCHAR) Where + Delta;
            RtlCopyMemory(
                Where,
                LogonTicket->key.keyvalue.value,
                LogonTicket->key.keyvalue.length
                );
            Where += TicketProfile->SessionKey.Length;
        }

#if _WIN64

    }

#endif  // _WIN64


    //
    // Flush the buffer to the client's address space.
    //

    Status = LsaFunctions->CopyToClientBuffer(
                NULL,
                *ProfileBufferSize,
                ClientBufferBase,
                LocalProfileBuffer
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *ProfileBuffer = (PKERB_INTERACTIVE_PROFILE) ClientBufferBase;

Cleanup:

    if (BuildTicketProfile)
    {
        KerbUnlockTicketCache();
    }

    KerbUnlockLogonSessions( LogonSession );

    //
    // If the copy wasn't successful,
    //  cleanup resources we would have returned to the caller.
    //

    if ( !NT_SUCCESS(Status) )
    {
        LsaFunctions->FreeClientBuffer( NULL, ClientBufferBase );
    }

#if _WIN64

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        KerbFree(LocalProfileBuffer);
    }
    else
    {

#endif  // _WIN64

        SafeAllocaFree(LocalProfileBuffer);

#if _WIN64

    }

#endif  // _WIN64

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbMakeTokenInformationV2
//
//  Synopsis:   This routine makes copies of all the pertinent
//              information from the UserInfo and generates a
//              LSA_TOKEN_INFORMATION_V2 data structure.
//
//  Effects:
//
//  Arguments:
//
//    UserInfo - Contains the validation information which is
//        to be copied into the TokenInformation.
//
//    TokenInformation - Returns a pointer to a properly Version 1 token
//        information structures.  The structure and individual fields are
//        allocated properly as described in ntlsa.h.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - Indicates the service completed successfully.
//
//              STATUS_INSUFFICIENT_RESOURCES -  This error indicates that
//                      the logon could not be completed because the client
//                      does not have sufficient quota to allocate the return
//                      buffer.
//
//  Notes:      stolen from msv1_0\nlp.c:NlpMakeTokenInformationV1
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbMakeTokenInformationV2(
    IN  PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo,
    IN BOOLEAN LocalSystem,
    OUT PLSA_TOKEN_INFORMATION_V2 *TokenInformation
    )
{
    PNETLOGON_VALIDATION_SAM_INFO3 UserInfo = ValidationInfo;
    NTSTATUS Status;
    PLSA_TOKEN_INFORMATION_V2 V2 = NULL;
    ULONG Size, i;
    BYTE SidBuffer[sizeof(SID) + sizeof(ULONG)];
    SID LocalSystemSid = {SID_REVISION,1,SECURITY_NT_AUTHORITY,SECURITY_LOCAL_SYSTEM_RID};
    PSID AdminsSid = SidBuffer;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    DWORD NumGroups = 0;
    PBYTE CurrentSid = NULL;
    ULONG SidLength = 0;
    KERBEROS_MACHINE_ROLE MachineRole;

    //
    // Filter the SIDs in the "member-to-DC" trust mode
    //

    KerbGlobalReadLock();
    MachineRole = KerbGlobalRole;
    KerbGlobalReleaseLock();

    //
    // If we are on a workstation, filter the SIDs that came from the DC
    // on a member-to-DC boundary policy (passing NULL SID to LsaIFilterSids)
    //

    if ( MachineRole == KerbRoleWorkstation ||
         MachineRole == KerbRoleDomainController )
    {
        //
        // Servers in KerbRoleStandalone and KerbRoleRealmlessWksta states
        // never receive Kerberos requests (as there are no local system keys
        // to decrypt service tickets, due to the fact that the machine aren't
        // joined to any domains).
        //

        Status = LsaIFilterSids(
                     NULL,
                     0,
                     0,
                     0,
                     NULL,
                     NetlogonValidationSamInfo2,
                     UserInfo,
                     UserInfo->ResourceGroupDomainSid,
                     &UserInfo->ResourceGroupCount,
                     UserInfo->ResourceGroupIds
                     );

        if ( !NT_SUCCESS( Status )) {

            return Status;
        }
    }

    //
    // For local system, add in administrators & set user id to local system
    //

    if (LocalSystem)
    {
        RtlInitializeSid(
            AdminsSid,
            &NtAuthority,
            2
            );
        *RtlSubAuthoritySid(AdminsSid,0) = SECURITY_BUILTIN_DOMAIN_RID;
        *RtlSubAuthoritySid(AdminsSid,1) = DOMAIN_ALIAS_RID_ADMINS;
    }

    //
    // Allocate the structure itself
    //

    Size = (ULONG)sizeof(LSA_TOKEN_INFORMATION_V2);

    //
    // Allocate an array to hold the groups
    //

    Size += sizeof(TOKEN_GROUPS);


    // Add room for groups passed as RIDS
    NumGroups = UserInfo->GroupCount;
    if(UserInfo->GroupCount)
    {
        Size += UserInfo->GroupCount * (RtlLengthSid(UserInfo->LogonDomainId) + sizeof(ULONG));
    }

    //
    // If there are extra SIDs, add space for them
    //

    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS) {
        ULONG i = 0;
        NumGroups += UserInfo->SidCount;

        // Add room for the sid's themselves
        for(i=0; i < UserInfo->SidCount; i++)
        {
            Size += RtlLengthSid(UserInfo->ExtraSids[i].Sid);
        }
    }

    //
    // If there are resource groups, add space for them
    //
    if (UserInfo->UserFlags & LOGON_RESOURCE_GROUPS) {

        NumGroups += UserInfo->ResourceGroupCount;

        if ((UserInfo->ResourceGroupCount != 0) &&
            ((UserInfo->ResourceGroupIds == NULL) ||
             (UserInfo->ResourceGroupDomainSid == NULL)))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        // Allocate space for the sids
        if(UserInfo->ResourceGroupCount)
        {
            Size += UserInfo->ResourceGroupCount * (RtlLengthSid(UserInfo->ResourceGroupDomainSid) + sizeof(ULONG));
        }

    }

    //
    // If this is local system, add space for User & Administrators
    //

    if (!LocalSystem)
    {

        if( UserInfo->UserId )
        {
            Size += 2*(RtlLengthSid(UserInfo->LogonDomainId) + sizeof(ULONG));
        }
        else
        {
            if ( UserInfo->SidCount <= 0 ) {

                Status = STATUS_INSUFFICIENT_LOGON_INFO;
                goto Cleanup;
            }

            Size += (RtlLengthSid(UserInfo->LogonDomainId) + sizeof(ULONG)) + RtlLengthSid(UserInfo->ExtraSids[0].Sid);

        }
    }
    else
    {
        NumGroups += 2;

        // Allocate sid space for LocalSystem, Administrators
        Size += sizeof(LocalSystemSid) + RtlLengthSid(AdminsSid);

        // Add space for the user sid
        if( UserInfo->UserId )
        {
            Size += (RtlLengthSid(UserInfo->LogonDomainId) + sizeof(ULONG));
        }
    }

    Size += (NumGroups - ANYSIZE_ARRAY)*sizeof(SID_AND_ATTRIBUTES);



    V2 = (PLSA_TOKEN_INFORMATION_V2) KerbAllocate( Size );
    if ( V2 == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory((PVOID)V2, Size);

    V2->Groups = (PTOKEN_GROUPS)(V2+1);

    V2->Groups->GroupCount = 0;
    CurrentSid = (PBYTE)&V2->Groups->Groups[NumGroups];

    OLD_TO_NEW_LARGE_INTEGER( UserInfo->KickOffTime, V2->ExpirationTime );


    if (!LocalSystem)
    {
        //
        // If the UserId is non-zero, then it contians the users RID.
        //

        if ( UserInfo->UserId ) {
            V2->User.User.Sid = (PSID)CurrentSid;
            CurrentSid += KerbCopyDomainRelativeSid((PSID)CurrentSid, UserInfo->LogonDomainId, UserInfo->UserId);
        }

        //
        // Make a copy of the primary group (a required field).
        //
        V2->PrimaryGroup.PrimaryGroup = (PSID)CurrentSid;
        CurrentSid += KerbCopyDomainRelativeSid((PSID)CurrentSid, UserInfo->LogonDomainId, UserInfo->PrimaryGroupId );

    }
    else
    {
        //
        // For local system, the user sid is LocalSystem and the primary
        // group is LocalSystem
        //
        V2->User.User.Sid = (PSID)CurrentSid;
        RtlCopySid(sizeof(LocalSystemSid),  (PSID)CurrentSid, &LocalSystemSid);

        CurrentSid += sizeof(LocalSystemSid);

        //
        // The real system token has LocalSystem for the primary
        // group. However, the LSA will add the primary group to the
        // list of groups if it isn't listed as a group, and since
        // LocalSystem is the user sid, we don't want that.
        //
        V2->PrimaryGroup.PrimaryGroup = (PSID)CurrentSid;
        SidLength = RtlLengthSid(AdminsSid);
        RtlCopySid(SidLength,  (PSID)CurrentSid, AdminsSid);
        CurrentSid += SidLength;


        //
        // If there is a user sid, add it as a group id.
        //

        if ( UserInfo->UserId ) {
            V2->Groups->Groups[V2->Groups->GroupCount].Attributes =
                    SE_GROUP_MANDATORY |
                    SE_GROUP_ENABLED|
                    SE_GROUP_ENABLED_BY_DEFAULT;

            V2->Groups->Groups[V2->Groups->GroupCount].Sid = (PSID)CurrentSid;
            CurrentSid += KerbCopyDomainRelativeSid((PSID)CurrentSid, UserInfo->LogonDomainId, UserInfo->UserId);

            V2->Groups->GroupCount++;
        }

        //
        // Add builtin administrators. This is not mandatory
        //

        V2->Groups->Groups[V2->Groups->GroupCount].Attributes =
                SE_GROUP_ENABLED|
                SE_GROUP_OWNER|
                SE_GROUP_ENABLED_BY_DEFAULT;

        V2->Groups->Groups[V2->Groups->GroupCount].Sid = V2->PrimaryGroup.PrimaryGroup;
        V2->Groups->GroupCount++;

    }



    //
    // Copy over all the groups passed as RIDs
    //

    for ( i=0; i < UserInfo->GroupCount; i++ ) {

        V2->Groups->Groups[V2->Groups->GroupCount].Attributes = UserInfo->GroupIds[i].Attributes;

        V2->Groups->Groups[V2->Groups->GroupCount].Sid = (PSID)CurrentSid;
        CurrentSid += KerbCopyDomainRelativeSid((PSID)CurrentSid, UserInfo->LogonDomainId, UserInfo->GroupIds[i].RelativeId);

        V2->Groups->GroupCount++;
    }


    //
    // Add in the extra SIDs
    //

    if (UserInfo->UserFlags & LOGON_EXTRA_SIDS) {

        ULONG index = 0;
        //
        // If the user SID wasn't passed as a RID, it is the first
        // SID.
        //

        if ( !V2->User.User.Sid ) {
            V2->User.User.Sid = (PSID)CurrentSid;
            SidLength = RtlLengthSid(UserInfo->ExtraSids[index].Sid);
            RtlCopySid(SidLength, (PSID)CurrentSid, UserInfo->ExtraSids[index].Sid);

            CurrentSid += SidLength;
            index++;
        }

        //
        // Copy over all additional SIDs as groups.
        //

        for ( ; index < UserInfo->SidCount; index++ ) {

            V2->Groups->Groups[V2->Groups->GroupCount].Attributes =
                UserInfo->ExtraSids[index].Attributes;

            V2->Groups->Groups[V2->Groups->GroupCount].Sid= (PSID)CurrentSid;
            SidLength = RtlLengthSid(UserInfo->ExtraSids[index].Sid);
            RtlCopySid(SidLength, (PSID)CurrentSid, UserInfo->ExtraSids[index].Sid);

            CurrentSid += SidLength;

            V2->Groups->GroupCount++;
        }
    }

    //
    // Check to see if any resouce groups exist
    //

    if (UserInfo->UserFlags & LOGON_RESOURCE_GROUPS) {


        for ( i=0; i < UserInfo->ResourceGroupCount; i++ ) {

            V2->Groups->Groups[V2->Groups->GroupCount].Attributes = UserInfo->ResourceGroupIds[i].Attributes;

            V2->Groups->Groups[V2->Groups->GroupCount].Sid= (PSID)CurrentSid;
            CurrentSid += KerbCopyDomainRelativeSid((PSID)CurrentSid, UserInfo->ResourceGroupDomainSid, UserInfo->ResourceGroupIds[i].RelativeId);

            V2->Groups->GroupCount++;
        }
    }

    ASSERT( ((PBYTE)V2 + Size) == CurrentSid );

    if (!V2->User.User.Sid) {

        Status = STATUS_INSUFFICIENT_LOGON_INFO;
        goto Cleanup;
    }

    //
    // There are no default privileges supplied.
    // We don't have an explicit owner SID.
    // There is no default DACL.
    //

    V2->Privileges = NULL;
    V2->Owner.Owner = NULL;
    V2->DefaultDacl.DefaultDacl = NULL;

    //
    // Return the Validation Information to the caller.
    //

    *TokenInformation = V2;
    return STATUS_SUCCESS;

    //
    // Deallocate any memory we've allocated
    //

Cleanup:

    KerbFree( V2 );

    return Status;

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateDelegationLogonSession
//
//  Synopsis:   Creates a logon session from the delegation information
//              in the GSS checksum
//
//  Effects:
//
//  Arguments:  LogonId - The logon id for the AP request, which will be used
//                      for the new logon session.
//              Ticket - The ticket used for the AP request, containing the
//                      session key to decrypt the KERB_CRED
//              GssChecksum - Checksum containing the delegation information
//
//  Requires:
//
//  Returns:    NTSTATUS codes
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateDelegationLogonSession(
    IN PLUID LogonId,
    IN PKERB_ENCRYPTED_TICKET Ticket,
    IN PKERB_GSS_CHECKSUM GssChecksum
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CRED KerbCred = NULL;
    PKERB_ENCRYPTED_CRED EncryptedCred = NULL;
    PKERB_LOGON_SESSION LogonSession = NULL;
    KERBERR KerbErr;

    D_DebugLog((DEB_TRACE, "Building delegation logon session\n"));

    if (GssChecksum->Delegation != 1)
    {
        D_DebugLog((DEB_ERROR, "Asked for GSS_C_DELEG_FLAG but Delegation != 1 = 0x%x. %ws, line %d\n",
                    GssChecksum->Delegation, THIS_FILE, __LINE__ ));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbUnpackKerbCred(
            GssChecksum->DelegationInfo,
            GssChecksum->DelegationLength,
            &KerbCred
            )))
    {
        D_DebugLog((DEB_WARN, "Failed to unpack kerb cred\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;

    }

    //
    // Now decrypt the encrypted part of the KerbCred.
    //
    KerbErr = KerbDecryptDataEx(
                &KerbCred->encrypted_part,
                &Ticket->key,
                KERB_CRED_SALT,
                (PULONG) &KerbCred->encrypted_part.cipher_text.length,
                KerbCred->encrypted_part.cipher_text.value
                );


    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to decrypt KERB_CRED: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        if (KerbErr == KRB_ERR_GENERIC)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        else
        {
            Status = STATUS_LOGON_FAILURE;

            //
            // MIT clients don't encrypt the encrypted part, so drop through
            //
        }
    }

    //
    // Now unpack the encrypted part.
    //

    if (!KERB_SUCCESS(KerbUnpackEncryptedCred(
            KerbCred->encrypted_part.cipher_text.value,
            KerbCred->encrypted_part.cipher_text.length,
            &EncryptedCred
            )))
    {
        //
        // Use the old status if it is available.
        //

        if (NT_SUCCESS(Status))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        D_DebugLog((DEB_WARN, "Failed to unpack encrypted cred\n"));
        goto Cleanup;
    }

    //
    // Now build a logon session.
    //

    Status = KerbCreateLogonSessionFromKerbCred(
                LogonId,
                Ticket,
                KerbCred,
                EncryptedCred,
                &LogonSession
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to create logon session from kerb cred: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    KerbWriteLockLogonSessions(LogonSession);
    LogonSession->LogonSessionFlags |= KERB_LOGON_DELEGATED ;
    KerbUnlockLogonSessions(LogonSession);

    KerbDereferenceLogonSession( LogonSession );

Cleanup:
    if (EncryptedCred != NULL)
    {
        KerbFreeEncryptedCred(EncryptedCred);
    }
    if (KerbCred != NULL)
    {
        KerbFreeKerbCred(KerbCred);
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateTokenFromTicket
//
//  Synopsis:   Pulls the PAC out of a ticket and
//
//  Effects:    Creates a logon session and a token
//
//  Arguments:  InternalTicket - The ticket off of which to base the
//                      token.
//              Authenticator - Authenticator from the AP request,
//                      which may contain delegation information.
//              NewLogonId - Receives the logon ID of the new logon session
//              UserSid - Receives user's sid.
//              NewTokenHandle - Receives the newly created token handle.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateTokenFromTicket(
    IN OPTIONAL PLUID AcceptingLogonId,
    IN OPTIONAL PKERB_AP_REQUEST Request,
    IN PKERB_ENCRYPTED_TICKET InternalTicket,
    IN OPTIONAL PKERB_AUTHENTICATOR Authenticator,
    IN ULONG ContextFlags,
    IN PKERB_ENCRYPTION_KEY TicketKey,
    IN PUNICODE_STRING ServiceDomain,
    IN KERB_ENCRYPTION_KEY* pSessionKey,
    OUT PLUID NewLogonId,
    OUT PSID * UserSid,
    OUT PHANDLE NewTokenHandle,
    OUT PUNICODE_STRING ClientName,
    OUT PUNICODE_STRING ClientDomain,
    OUT PUNICODE_STRING ClientNetbiosDomain,
    OUT OPTIONAL PS4U_DELEGATION_INFO* S4uDelegationInfo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    PPACTYPE Pac = NULL;
    PKERB_AUTHORIZATION_DATA PacAuthData = NULL;
    PKERB_AUTHORIZATION_DATA AuthData = NULL;
    PKERB_IF_RELEVANT_AUTH_DATA * IfRelevantData = NULL;
    PPAC_INFO_BUFFER LogonInfo = NULL;
    PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo = NULL;
    PLSA_TOKEN_INFORMATION_V2 TokenInformation = NULL;
    PLSA_TOKEN_INFORMATION_NULL TokenNull = NULL;
    LSA_TOKEN_INFORMATION_TYPE TokenType = LsaTokenInformationNull;
    PVOID LsaTokenInformation = NULL;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel = SecurityImpersonation;
    ULONG NameType;
    BOOLEAN BuildNullToken = FALSE;

    LUID LogonId;
    LUID BaseLuid = (*AcceptingLogonId);
    LUID SystemLogonId = SYSTEM_LUID;
    UNICODE_STRING Workstation = NULL_UNICODE_STRING;
    UNICODE_STRING TempUserName;
    UNICODE_STRING TempDomainName;
    PKERB_GSS_CHECKSUM GssChecksum;
    BOOLEAN IsLocalSystem = FALSE;

    NTSTATUS SubStatus;
    HANDLE TokenHandle = NULL;
    BOOLEAN FreePac = FALSE;
    ULONG TicketOptions = 0;

    SECPKG_PRIMARY_CRED PrimaryCredentials;

    DsysAssert(AcceptingLogonId->LowPart != 0);

    RtlZeroMemory(
        &PrimaryCredentials,
        sizeof(SECPKG_PRIMARY_CRED)
        );

    LogonId.HighPart = 0;
    LogonId.LowPart = 0;
    *UserSid = NULL;
    *NewLogonId = LogonId;

    //
    // Check to see if this was NULL session
    //

    if (ARGUMENT_PRESENT(InternalTicket))
    {

        TicketOptions = KerbConvertFlagsToUlong(&InternalTicket->flags);

        if (!KERB_SUCCESS(KerbConvertPrincipalNameToString(
                            ClientName,
                            &NameType,
                            &InternalTicket->client_name
                            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        if (!KERB_SUCCESS(KerbConvertRealmToUnicodeString(
                            ClientDomain,
                            &InternalTicket->client_realm
                            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }


        //
        // Convert the principal name into just a user name
        //

        (VOID) KerbSplitFullServiceName(
                ClientName,
                &TempDomainName,
                &TempUserName
                );

        TokenType = LsaTokenInformationV2;

        //
        // Make sure there is some authorization data
        //

        if (((InternalTicket->bit_mask & KERB_ENCRYPTED_TICKET_authorization_data_present) != 0) &&
             (InternalTicket->KERB_ENCRYPTED_TICKET_authorization_data != NULL))

        {

            AuthData = InternalTicket->KERB_ENCRYPTED_TICKET_authorization_data;

            //
            // Verify the auth data is valid
            //

            if (!KerbVerifyAuthData(
                InternalTicket->KERB_ENCRYPTED_TICKET_authorization_data
                ))
            {
                Status = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }

            //
            // Get the PAC out of the authorization data
            //

            KerbErr = KerbGetPacFromAuthData(
                            InternalTicket->KERB_ENCRYPTED_TICKET_authorization_data,
                            &IfRelevantData,
                            &PacAuthData
                            );

            if (!KERB_SUCCESS(KerbErr))
            {
                Status = KerbMapKerbError(KerbErr);
                goto Cleanup;
            }


            if (PacAuthData != NULL)
            {

                //
                // Unmarshall the PAC
                //

                Pac = (PPACTYPE) PacAuthData->value.auth_data.value;
                if (PAC_UnMarshal(Pac, PacAuthData->value.auth_data.length) == 0)
                {
                    D_DebugLog((DEB_ERROR,"Failed to unmarshal pac. %ws, line %d\n", THIS_FILE, __LINE__));
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

                //
                // Verify the signature on the pac
                //

                Status = KerbVerifyPacSignature(
                            ServiceDomain,
                            Pac,
                            PacAuthData->value.auth_data.length,
                            TicketKey,
                            InternalTicket,
                            TRUE,
                            &ValidationInfo,
                            S4uDelegationInfo
                            );
                if (!NT_SUCCESS(Status)) 
                {
                    KerbReportPACError(
                        ClientName,
                        ClientDomain,
                        Status
                        );

                    DebugLog((DEB_ERROR, "Pac signature did not verify: domain %wZ, status %x\n", ServiceDomain, Status));
                    goto Cleanup;
                }
            }
        }

        //
        // If we didn't find a PAC, try to build one locally
        //

        if (Pac == NULL)
        {
            PKERB_INTERNAL_NAME ClientKdcName = NULL;
            NTSTATUS TempStatus;


            //
            // Convert the client's name into a usable format
            //

            if (!KERB_SUCCESS(KerbConvertPrincipalNameToKdcName(
                                &ClientKdcName,
                                &InternalTicket->client_name
                                )))
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }


            TempStatus = KerbCreatePacForKerbClient(
                            &Pac,
                            ClientKdcName,
                            ClientDomain,
                            NULL
                            );

            KerbFreeKdcName(&ClientKdcName);

            if (!NT_SUCCESS(TempStatus))
            {

                //
                // Reuse the error from above, it is is available.
                //

                if ((TempStatus == STATUS_NO_SUCH_USER) ||
                    (TempStatus == STATUS_PRIVILEGE_NOT_HELD))
                {
                    D_DebugLog((DEB_TRACE,"Failed to create local pac for client : 0x%x\n",TempStatus));
                    BuildNullToken = TRUE;
                    Status = STATUS_SUCCESS;
                }
                else
                {
                    if (NT_SUCCESS(Status))
                    {
                        Status = TempStatus;
                    }
                    DebugLog((DEB_ERROR,"Failed to create local pac for client : 0x%x\n",Status));
                    goto Cleanup;
                }
            }

            //
            // If we have a PAC, build everything else we need now
            //

            if (!BuildNullToken)
            {
                FreePac = TRUE;

                KerbFreeString( ClientDomain );

                KerbGlobalReadLock();

                Status = KerbDuplicateString(
                            ClientDomain,
                            &KerbGlobalMachineName
                            );

                KerbGlobalReleaseLock();

                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                //
                // Find the SAM validation info
                //

                LogonInfo = PAC_Find(
                                Pac,
                                PAC_LOGON_INFO,
                                NULL
                                );
                if (LogonInfo == NULL)
                {
                    DebugLog((DEB_ERROR,"Failed to find logon info! %ws, line %d\n", THIS_FILE, __LINE__));
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

                //
                // Now unmarshall the validation info
                //


                Status = PAC_UnmarshallValidationInfo(
                            &ValidationInfo,
                            LogonInfo->Data,
                            LogonInfo->cbBufferSize
                            );
                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR,"Failed to unmarshall validation info: 0x%x. %ws, line %d\n",
                        Status, THIS_FILE, __LINE__));
                    goto Cleanup;
                }
            }
        }

        if (!BuildNullToken)
        {
            //
            // Check to see if the caller is local system on this
            // machine
            //

            if (RtlEqualUnicodeString(
                    ClientName,
                    &KerbGlobalMachineServiceName,
                    TRUE) &&
                KerbIsThisOurDomain(
                    ClientDomain
                    ))
            {
                //
                // check for local loopback case: if the session key entry
                // exists, it is localsystem loopback
                //

                Status = KerbDoesSKeyExist(pSessionKey, &IsLocalSystem);

                D_DebugLog((DEB_TRACE_LOOPBACK, "KerbCreateTokenFromTicket, KerbDoesSKeyExist Status %#x, IsLocalSystem? %s\n",
                    Status, (IsLocalSystem ? "true" : "false")));

                KerbDeleteSKeyEntry(pSessionKey);

                if (!NT_SUCCESS(Status))
                {
                    DebugLog((DEB_ERROR, "Failed to detect local loopback: 0x%x. %ws, line %d\n",
                        Status, THIS_FILE, __LINE__));
                    goto Cleanup;
                }
            }

            //
            // Now we need to build a LSA_TOKEN_INFORMATION_V2 from the validation
            // information
            //

            Status = KerbMakeTokenInformationV2(
                        ValidationInfo,
                        IsLocalSystem,
                        &TokenInformation
                        );
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"Failed to make token information v2: 0x%x. %ws, line %d\n",
                    Status, THIS_FILE, __LINE__));
                goto Cleanup;
            }

            //
            // Copy out the NT4 user name & domain name to give to the LSA. It
            // requres the names from SAM because it generates the output of
            // GetUserName.
            //
            // However, we only need to do this for MIT logons, otherwise, we
            // should use the name in the ticket...
            //
            if (RtlEqualUnicodeString(ClientName, &ValidationInfo->EffectiveName, TRUE))
            {
                KerbFreeString( ClientName );
                Status = KerbDuplicateString(
                            ClientName,
                            &ValidationInfo->EffectiveName
                            );
                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                D_DebugLog((DEB_TRACE_LOGON, "CreateToken : ClientName - %wZ\n", ClientName));


                Status = KerbDuplicateString(
                                ClientNetbiosDomain,
                                &ValidationInfo->LogonDomainName
                                );

                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                D_DebugLog((DEB_TRACE_LOGON, "CreateToken : ClientSamDomain - %wZ\n", ClientNetbiosDomain));

            }

            //
            // Now create the token.
            //

            LsaTokenInformation = TokenInformation;

            Status = KerbDuplicateSid(
                        UserSid,
                        TokenInformation->User.User.Sid
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
    }
    else
    {
        BuildNullToken = TRUE;
    }

    if (BuildNullToken)
    {
        SID AnonymousSid = {SID_REVISION, 1, SECURITY_NT_AUTHORITY, SECURITY_ANONYMOUS_LOGON_RID };

        TokenNull = (PLSA_TOKEN_INFORMATION_NULL) KerbAllocate(sizeof(LSA_TOKEN_INFORMATION_NULL));
        if (TokenNull == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        LsaTokenInformation = TokenNull;
        TokenNull->Groups = NULL;
        TokenNull->ExpirationTime = KerbGlobalWillNeverTime;
        TokenType = LsaTokenInformationNull;

        Status = KerbDuplicateSid(
                    UserSid,
                    &AnonymousSid
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Create a logon session.
    //

    NtAllocateLocallyUniqueId(&LogonId);

    Status = LsaFunctions->CreateLogonSession(&LogonId);
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR, "Failed to create logon session: 0x%x. %ws, line %d\n", Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Add additional names to the logon session name map.  Ignore failure
    // as that just means GetUserNameEx calls for these name formats later
    // on will be satisfied by hitting the wire.
    //

    if (ValidationInfo && ValidationInfo->FullName.Length)
    {
        I_LsaIAddNameToLogonSession(&LogonId, NameDisplay, &ValidationInfo->FullName);
    }

    if (ClientDomain->Length && ClientDomain->Buffer)
    {
        I_LsaIAddNameToLogonSession(&LogonId, NameDnsDomain, ClientDomain);
    }

    //
    // If the caller wanted an identify or delegate level token, duplicate the token
    // now.
    //

    if ((ContextFlags & ISC_RET_IDENTIFY) != 0)
    {
        ImpersonationLevel = SecurityIdentification;
    }
    else if ((ContextFlags & ISC_RET_DELEGATE) != 0)
    {
        ImpersonationLevel = SecurityDelegation;
    }

    if(ClientName->Length && ClientName->Buffer)
    {
        PrimaryCredentials.DownlevelName.Buffer = (PWSTR)LsaFunctions->AllocateLsaHeap(ClientName->Length);
        if (PrimaryCredentials.DownlevelName.Buffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        PrimaryCredentials.DownlevelName.Length =
        PrimaryCredentials.DownlevelName.MaximumLength = ClientName->Length;

        RtlCopyMemory(
                PrimaryCredentials.DownlevelName.Buffer,
                ClientName->Buffer,
                ClientName->Length
                );
    }

    if ( ClientNetbiosDomain->Length && ClientNetbiosDomain->Buffer )
    {
        PrimaryCredentials.DomainName.Buffer = (PWSTR)LsaFunctions->AllocateLsaHeap( ClientNetbiosDomain->Length );
        if (PrimaryCredentials.DomainName.Buffer == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        PrimaryCredentials.DomainName.Length =
        PrimaryCredentials.DomainName.MaximumLength = ClientNetbiosDomain->Length;

        RtlCopyMemory(
                PrimaryCredentials.DomainName.Buffer,
                ClientNetbiosDomain->Buffer,
                ClientNetbiosDomain->Length
                );

    }
    else
    {
        //
        // Huh?  No pac validation info - use the DNS name ...
        //
        Status = KerbDuplicateString(
                    ClientNetbiosDomain,
                    ClientDomain
                    );

        if (!NT_SUCCESS( Status ))
        {
            goto Cleanup;
        }                
    }

    DebugLog((DEB_TRACE, "KerbCreateTokenFromTicket for %wZ\\%wZ, %wZ\n", &PrimaryCredentials.DomainName, &PrimaryCredentials.DownlevelName, &PrimaryCredentials.Upn));

    Status = LsaFunctions->CreateTokenEx(
                &LogonId,
                &KerberosSource,
                Network,
                ImpersonationLevel,
                TokenType,
                LsaTokenInformation,
                NULL,                   // no token groups
                &Workstation,
                (ValidationInfo == NULL ? NULL : &ValidationInfo->ProfilePath),
                &PrimaryCredentials,
                SecSessionPrimaryCred,
                &TokenHandle,
                &SubStatus
                );


    // LsapCreateToken frees the TokenInformation structure for us, so
    // we don't need these pointers anymore.
    TokenInformation = NULL;
    TokenNull = NULL;

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to create token: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    if (!NT_SUCCESS(SubStatus))
    {
        DebugLog((DEB_ERROR,"Failed to create token, substatus = 0x%x. %ws, line %d\n",SubStatus, THIS_FILE, __LINE__));
        Status = SubStatus;
        goto Cleanup;
    }

    //
    // Check the delegation information to see if we need to create
    // a logon session for this.
    //
    // For impersonated contexts, we'll also create a logon session, but
    // there won't be much extra information in it.
    //

    if ((ContextFlags & ISC_RET_DELEGATE) != 0)
    {
        DsysAssert(ARGUMENT_PRESENT(Authenticator));
        GssChecksum = (PKERB_GSS_CHECKSUM) Authenticator->checksum.checksum.value;
        DsysAssert(GssChecksum != 0);
        Status = KerbCreateDelegationLogonSession(
                    &LogonId,
                    InternalTicket,
                    GssChecksum
                    );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to create delgation logon session: 0x%x. %ws, line %d\n",
                Status, THIS_FILE, __LINE__ ));
            goto Cleanup;
        }
    }
    else if (ARGUMENT_PRESENT(Request))
    {
        Status = KerbCreateLogonSessionFromTicket(
                    &LogonId,
                    &BaseLuid,
                    ClientName,
                    ClientDomain,
                    Request,
                    InternalTicket,
                    NULL
                    );

        if (!NT_SUCCESS( Status ))
        {
            DebugLog((DEB_ERROR, "Failed to create ASC logon session %x\n", Status));
            goto Cleanup;
        }
    }

    //
    //

    //
    // Apply any restrictions from the auth data
    // Note: Punted until Blackcomb
    //

#ifdef RESTRICTED_TOKEN
    if (AuthData != NULL)
    {
        Status = KerbApplyAuthDataRestrictions(
                    &TokenHandle,
                    AuthData
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
#endif

    *NewLogonId = LogonId;
    *NewTokenHandle = TokenHandle;

Cleanup:

    if(PrimaryCredentials.DownlevelName.Buffer)
    {
        LsaFunctions->FreeLsaHeap(PrimaryCredentials.DownlevelName.Buffer);
    }

    if(PrimaryCredentials.DomainName.Buffer)
    {
        LsaFunctions->FreeLsaHeap(PrimaryCredentials.DomainName.Buffer);
    }

    if(PrimaryCredentials.LogonServer.Buffer)
    {
        LsaFunctions->FreeLsaHeap(PrimaryCredentials.LogonServer.Buffer);
    }

    if(PrimaryCredentials.UserSid)
    {
        LsaFunctions->FreeLsaHeap(PrimaryCredentials.UserSid);
    }

    if(PrimaryCredentials.LogonServer.Buffer)
    {
        LsaFunctions->FreeLsaHeap(PrimaryCredentials.LogonServer.Buffer);
    }

    if(PrimaryCredentials.UserSid)
    {
        LsaFunctions->FreeLsaHeap(PrimaryCredentials.UserSid);
    } 

    if (TokenInformation != NULL)
    {
        KerbFree( TokenInformation );    
    }

    if (TokenNull != NULL)
    {
        KerbFree(TokenNull);
    }

    if (!NT_SUCCESS(Status))
    {
        //
        // Note: if we have created a token, we don't want to delete
        // the logon session here because we will end up dereferencing
        // the logon session twice.
        //

        if (TokenHandle != NULL)
        {
            NtClose(TokenHandle);
        }
        else if ((LogonId.LowPart != 0) || (LogonId.HighPart != 0))
        {
            if (!RtlEqualLuid(
                    &LogonId,
                    &SystemLogonId
                    ))
            {
                LsaFunctions->DeleteLogonSession(&LogonId);
            }
        }
        if (*UserSid != NULL)
        {
            KerbFree(*UserSid);
            *UserSid = NULL;
        }
    }
    if (FreePac && (Pac != NULL))
    {
        MIDL_user_free(Pac);
    }

    if (ValidationInfo != NULL)
    {
        MIDL_user_free(ValidationInfo);
    }

    if (IfRelevantData != NULL)
    {
        KerbFreeData(
            PKERB_IF_RELEVANT_AUTH_DATA_PDU,
            IfRelevantData
            );
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbExtractCachedCreds
//
//  Synopsis:   Extracts the cached credentials from a logon ticket
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbExtractCachedCreds(
    IN PPACTYPE Pac,
    IN PKERB_ENCRYPTION_KEY CredentialKey,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCredentials
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr;
    PPAC_INFO_BUFFER CredBuffer = NULL;
    PPAC_CREDENTIAL_INFO CredInfo = NULL;
    PBYTE CredData = NULL;
    ULONG CredDataSize = 0;
    PSECPKG_SUPPLEMENTAL_CRED_ARRAY DecodedCreds = NULL;
    KERB_ENCRYPTED_DATA EncryptedData = {0};

    *CachedCredentials = NULL;

    //
    // If we don't have a key to obtain credentials, o.k.
    //

    if (!ARGUMENT_PRESENT(CredentialKey) ||
        (CredentialKey->keyvalue.value == NULL))
    {
        goto Cleanup;
    }

    CredBuffer = PAC_Find(
                    Pac,
                    PAC_CREDENTIAL_TYPE,
                    NULL                        // no previous instance
                    );
    if (CredBuffer == NULL)
    {
        //
        // We have no credentials. O.k.
        //
        goto Cleanup;
    }

    //
    // Build an encrypted data structure so we can decrypt the response
    //

    CredInfo = (PPAC_CREDENTIAL_INFO) CredBuffer->Data;
    if (CredBuffer->cbBufferSize < sizeof(PAC_CREDENTIAL_INFO))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    EncryptedData.version = CredInfo->Version;
    EncryptedData.encryption_type = CredInfo->EncryptionType;
    EncryptedData.cipher_text.value = CredInfo->Data;
    CredDataSize = CredBuffer->cbBufferSize -
                        FIELD_OFFSET(PAC_CREDENTIAL_INFO, Data);
    EncryptedData.cipher_text.length = CredDataSize;

    //
    // Decrypt in place
    //

    CredData =  CredInfo->Data;

    KerbErr = KerbDecryptDataEx(
                &EncryptedData,
                CredentialKey,
                KERB_NON_KERB_SALT,
                &CredDataSize,
                (PBYTE) CredData
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        D_DebugLog((DEB_ERROR,"Failed to decrypt credentials: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Now build the return credentials
    //

    //
    // Now unmarshall the credential data
    //

    Status = PAC_UnmarshallCredentials(
                &DecodedCreds,
                CredData,
                CredDataSize
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *CachedCredentials = DecodedCreds;

    DecodedCreds = NULL;
Cleanup:
    if (DecodedCreds != NULL)
    {
        MIDL_user_free(DecodedCreds);
    }
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCacheLogonInformation
//
//  Synopsis:   Calls MSV1_0 to cache logon information. This routine
//              converts the pac into MSV1_0 compatible data and
//              makes a call to MSV1_0 to store it.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbCacheLogonInformation(
    IN PUNICODE_STRING LogonUserName,
    IN PUNICODE_STRING LogonDomainName,
    IN OPTIONAL PUNICODE_STRING Password,
    IN OPTIONAL PUNICODE_STRING DnsDomainName,
    IN OPTIONAL PUNICODE_STRING Upn,
    IN OPTIONAL KERB_LOGON_SESSION* LogonSession,
    IN ULONG Flags,
    IN OPTIONAL PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo,
    IN OPTIONAL PVOID SupplementalCreds,
    IN OPTIONAL ULONG SupplementalCredSize
    )
{
    NETLOGON_VALIDATION_SAM_INFO4 ValidationInfoToUse = {0};
    NETLOGON_INTERACTIVE_INFO MsvLogonInfo = {0};
    MSV1_0_CACHE_LOGON_REQUEST CacheRequest;
    UNICODE_STRING MsvPackageName = CONSTANT_UNICODE_STRING(TEXT(MSV1_0_PACKAGE_NAME));
    PVOID OutputBuffer = NULL;
    ULONG OutputBufferSize;
    NTSTATUS Status,TempStatus, SubStatus;
    UNICODE_STRING LocalMachineName;
    UNICODE_STRING DummyString;
    PBYTE Tmp, Tmp2;
    ULONG NewGroupCount = 0, Index = 0, Index2 = 0;
    PVOID SupplementalMitCreds = NULL;
    ULONG SupplementalMitCredSize = 0;
    BOOL MitLogon = LogonSession ? ((LogonSession->LogonSessionFlags & KERB_LOGON_MIT_REALM) != 0) : FALSE;

    NETLOGON_VALIDATION_SAM_INFO3 TempValidation = {0};
    PNETLOGON_SID_AND_ATTRIBUTES NewGroups = NULL;
    BOOL fUseTemp = FALSE;


    LocalMachineName.Buffer = NULL;

    if (KerbGetGlobalRole() == KerbRoleRealmlessWksta)
    {
        D_DebugLog((DEB_WARN, "KerbCacheLogonInformation does not support cached logon for reamless workstation\n"));
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // Cram resource groups into extra sids, as INFO4 doesn't support
    // them.
    //
    if ( ARGUMENT_PRESENT(ValidationInfo) && 
       ((ValidationInfo->UserFlags & LOGON_RESOURCE_GROUPS) != 0))
    {
        D_DebugLog((DEB_TRACE, "Found resource groups in PAC\n"));

        if (ValidationInfo->ResourceGroupCount != 0)
        {
            DebugLog((DEB_ERROR, " Expanding resource groups\n"));
            
	    //              
            // Build a new structure that contains the resource groups
            //                      
            RtlCopyMemory(
                &TempValidation,
                ValidationInfo,
                sizeof(NETLOGON_VALIDATION_SAM_INFO3)
                );

            NewGroupCount = ValidationInfo->SidCount + ValidationInfo->ResourceGroupCount;

            NewGroups = (PNETLOGON_SID_AND_ATTRIBUTES) KerbAllocate(sizeof(NETLOGON_SID_AND_ATTRIBUTES) * NewGroupCount);
            if (NewGroups == NULL)
            {
                Status=  STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            //      
            // Add in all the extra sids
            //              
            RtlCopyMemory(
                NewGroups,
                ValidationInfo->ExtraSids,
                ValidationInfo->SidCount * sizeof(NETLOGON_SID_AND_ATTRIBUTES)
                );

            Index2 = ValidationInfo->SidCount;
            for (Index = 0; Index < ValidationInfo->ResourceGroupCount ; Index++)
            {
                NewGroups[Index2].Attributes = ValidationInfo->ResourceGroupIds[Index].Attributes;

                NewGroups[Index2].Sid = KerbMakeDomainRelativeSid(
                    ValidationInfo->ResourceGroupDomainSid,
                    ValidationInfo->ResourceGroupIds[Index].RelativeId );

                if ( NewGroups[Index2].Sid == NULL ) 
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }
                Index2++;
            }

            DsysAssert(NewGroupCount == Index2);
            TempValidation.UserFlags |= LOGON_EXTRA_SIDS;
            TempValidation.SidCount = NewGroupCount;
            TempValidation.ExtraSids = NewGroups;
            fUseTemp = TRUE;
        }
    }


    //
    // Build up the NETLOGON_VALIDATION_SAM_INFO4 structure to pass to NTLM
    //
    
    if (ARGUMENT_PRESENT(ValidationInfo))
    {
        RtlCopyMemory(&ValidationInfoToUse,                                               
                     (fUseTemp ? &TempValidation : ValidationInfo),
                      sizeof(NETLOGON_VALIDATION_SAM_INFO2));

        if (ARGUMENT_PRESENT(DnsDomainName))
        {
            ValidationInfoToUse.DnsLogonDomainName = *DnsDomainName;
        }
    }

    MsvLogonInfo.Identity.LogonDomainName = *LogonDomainName;
    MsvLogonInfo.Identity.UserName = *LogonUserName;

    CacheRequest.RequestFlags = Flags;

    //
    // If this was a logon to an MIT realm that we know about,
    // then add the MIT username (upn?) & realm to the supplemental data
    //

    if (MitLogon)
    {
       D_DebugLog((DEB_TRACE, "KerbCacheLogonInformation caching MIT princ: logon %wZ\\%wZ, account %wZ\\%wZ, cred %wZ\\%wZ\n", 
           LogonDomainName, LogonUserName,
           &ValidationInfoToUse.LogonDomainName, &ValidationInfoToUse.EffectiveName,
           &LogonSession->PrimaryCredentials.DomainName, &LogonSession->PrimaryCredentials.UserName));

       CacheRequest.RequestFlags |= MSV1_0_CACHE_LOGON_REQUEST_MIT_LOGON;

       //
       // Marshall the MIT info into the supplemental creds.
       //

       SupplementalMitCredSize =
           (2* sizeof(UNICODE_STRING)) +
           ROUND_UP_COUNT(LogonSession->PrimaryCredentials.UserName.Length, ALIGN_LONG) +
           ROUND_UP_COUNT(LogonSession->PrimaryCredentials.DomainName.Length, ALIGN_LONG);

       SafeAllocaAllocate(SupplementalMitCreds, SupplementalMitCredSize);

       if (NULL == SupplementalMitCreds)
       {
           Status = STATUS_INSUFFICIENT_RESOURCES;
           goto Cleanup;
       }

       DummyString.Length = DummyString.MaximumLength = LogonSession->PrimaryCredentials.UserName.Length;
       Tmp = (PBYTE) (SupplementalMitCreds) + sizeof(UNICODE_STRING);

       if (DummyString.Length > 0)
       {

           RtlCopyMemory(
               Tmp,
               LogonSession->PrimaryCredentials.UserName.Buffer,
               LogonSession->PrimaryCredentials.UserName.Length
               );

           DummyString.Buffer = (PWSTR) UlongToPtr(RtlPointerToOffset(SupplementalMitCreds, Tmp));
       }
       else
       {
           DummyString.Buffer = NULL;
       }


       RtlCopyMemory(
           SupplementalMitCreds,
           &DummyString,
           sizeof(UNICODE_STRING)
           );

       Tmp2 = Tmp + ROUND_UP_COUNT(DummyString.Length, ALIGN_LONG);

       Tmp += ROUND_UP_COUNT(DummyString.Length, ALIGN_LONG) + sizeof(UNICODE_STRING);

       DummyString.Length = DummyString.MaximumLength = LogonSession->PrimaryCredentials.DomainName.Length;

       if (DummyString.Length > 0)
       {
             RtlCopyMemory(
                 Tmp,
                 LogonSession->PrimaryCredentials.DomainName.Buffer,
                 LogonSession->PrimaryCredentials.DomainName.Length
                 );

           DummyString.Buffer = (PWSTR) UlongToPtr(RtlPointerToOffset(SupplementalMitCreds, Tmp));
       }
       else
       {
           DummyString.Buffer = NULL;
       }

       RtlCopyMemory(
           Tmp2,
           &DummyString,
           sizeof(UNICODE_STRING)
           );


       CacheRequest.SupplementalCacheData = SupplementalMitCreds;
       CacheRequest.SupplementalCacheDataLength = SupplementalMitCredSize;
    }
    else
    {
       CacheRequest.RequestFlags = Flags;
       CacheRequest.SupplementalCacheData = SupplementalCreds;
       CacheRequest.SupplementalCacheDataLength = SupplementalCredSize;
    }

    //
    // Store the originating package of the logon
    //

    MsvLogonInfo.Identity.ParameterControl = RPC_C_AUTHN_GSS_KERBEROS;

    KerbGlobalReadLock();
    Status = KerbDuplicateString( &LocalMachineName, &KerbGlobalMachineName );
    KerbGlobalReleaseLock();

    if(!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR, "Failed to duplicate KerbGlobalMachineName\n"));
        goto Cleanup;
    }

    MsvLogonInfo.Identity.Workstation = LocalMachineName;

    if (ARGUMENT_PRESENT(Password))
    {
        Status = RtlCalculateNtOwfPassword(
                    Password,
                    &MsvLogonInfo.NtOwfPassword
                    );
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to calculate NT OWF for %wZ. %ws, line %d\n",Password, THIS_FILE, __LINE__));
            goto Cleanup;
        }
    }

    CacheRequest.MessageType = MsV1_0CacheLogon;
    CacheRequest.LogonInformation = &MsvLogonInfo;
    CacheRequest.ValidationInformation = &ValidationInfoToUse;

    //
    // tell NTLM it's a INFO4 structure.
    //

    CacheRequest.RequestFlags |= MSV1_0_CACHE_LOGON_REQUEST_INFO4;

    TempStatus = LsaFunctions->CallPackage(
                    &MsvPackageName,
                    &CacheRequest,
                    sizeof(CacheRequest),
                    &OutputBuffer,
                    &OutputBufferSize,
                    &SubStatus
                    );
    if (!NT_SUCCESS(TempStatus) || !NT_SUCCESS(SubStatus))
    {
        DebugLog((DEB_ERROR, "KerbCacheLogonInformation failed to cache credentials: 0x%x, 0x%x. %ws, line %d\n", TempStatus, SubStatus, THIS_FILE, __LINE__));
    }

Cleanup:

    KerbFreeString( &LocalMachineName );

    if (NewGroups != NULL)
    {
        for (Index = ValidationInfo->SidCount; Index < NewGroupCount ; Index++ )
        {
            if (NewGroups[Index].Sid != 0)
            {
                KerbFree(NewGroups[Index].Sid);
            }
        }
        KerbFree(NewGroups);
    }


    SafeAllocaFree(SupplementalMitCreds);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetCredsFromU2UTicket
//
//  Synopsis:   Verifies the ticket, and gets the credentials from the PAC
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//-----
NTSTATUS
KerbGetCredsFromU2UTicket(
    IN PKERB_TICKET_CACHE_ENTRY U2UTicket,
    IN PKERB_TICKET_CACHE_ENTRY Tgt,
    IN OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * OutputCreds,
    OUT PNETLOGON_VALIDATION_SAM_INFO3*  ValidationInfo
    )
{

    KERBERR                         KerbErr = KDC_ERR_NONE;
    NTSTATUS                        Status = STATUS_SUCCESS;
    PPACTYPE                        Pac = NULL;
    PKERB_AUTHORIZATION_DATA        PacAuthData = NULL;
    PKERB_AUTHORIZATION_DATA        AuthData = NULL;
    PKERB_IF_RELEVANT_AUTH_DATA     * IfRelevantData = NULL;
    PKERB_ENCRYPTED_TICKET          EncryptedTicket = NULL;
    PSECPKG_SUPPLEMENTAL_CRED_ARRAY LocalCreds = NULL;

    *OutputCreds = NULL;

    //
    // Validate the ticket
    //
    KerbErr = KerbVerifyTicket(
                    &U2UTicket->Ticket,
                    0,
                    NULL,
                    NULL,
                    &Tgt->SessionKey,
                    NULL,
                    &EncryptedTicket
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR, "KerbVerifyTicket failed - %x\n", KerbErr));
        goto Cleanup;
    }

    //
    // Extract the PAC
    //
    if (((EncryptedTicket->bit_mask & KERB_ENCRYPTED_TICKET_authorization_data_present) == 0) ||
         (EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data == NULL))

    {
        D_DebugLog((DEB_ERROR, "No authdata!\n"));
        DsysAssert(FALSE);
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    AuthData = EncryptedTicket->KERB_ENCRYPTED_TICKET_authorization_data;

    //
    // Verify the auth data is valid
    //
    if (!KerbVerifyAuthData( AuthData ))
    {
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Get the PAC out of the authorization data
    //

    KerbErr = KerbGetPacFromAuthData(
                    AuthData,
                    &IfRelevantData,
                    &PacAuthData
                    );

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    if ( PacAuthData == NULL )
    {
        D_DebugLog((DEB_ERROR, "No PAC!\n"));
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Unmarshall the PAC
    //
    Pac = (PPACTYPE) PacAuthData->value.auth_data.value;
    if (PAC_UnMarshal(Pac, PacAuthData->value.auth_data.length) == 0)
    {
        D_DebugLog((DEB_ERROR, "Failed to unmarshal pac. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Verify the signature on the pac
    //
    Status = KerbVerifyPacSignature(
                    &Tgt->ClientDomainName,
                    Pac,
                    PacAuthData->value.auth_data.length,
                    &Tgt->SessionKey,
                    EncryptedTicket,
                    FALSE,
                    ValidationInfo,
                    NULL
                    );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_WARN,"Pac signature did not verify %x\n", Status));
        DsysAssert(FALSE);
        goto Cleanup;
    }


    Status = KerbExtractCachedCreds(
                Pac,
                &Tgt->CredentialKey,
                &LocalCreds
                );

    if (!NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR, "KerbExtractCachedCreds failed %x\n", Status));
        goto Cleanup;
    }

    *OutputCreds = LocalCreds;
    LocalCreds = NULL;

Cleanup:

    if (!KERB_SUCCESS(KerbErr))
    {
        Status = KerbMapKerbError( KerbErr );
    }

    if ( LocalCreds )
    {
        MIDL_user_free( LocalCreds );
    }

    if (IfRelevantData != NULL)
    {
        KerbFreeData(
            PKERB_IF_RELEVANT_AUTH_DATA_PDU,
            IfRelevantData
            );
    }

    if ( EncryptedTicket )
    {
        KerbFreeTicket( EncryptedTicket );
    }

    return (Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateTokenFromLogonTicket
//
//  Synopsis:   Creates a token from a ticket to the workstation
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateTokenFromLogonTicket(
    IN OPTIONAL PKERB_TICKET_CACHE_ENTRY LogonTicket,
    IN PLUID LogonId,
    IN PKERB_INTERACTIVE_LOGON KerbLogonInfo,
    IN BOOLEAN RealmlessWkstaLogon,
    IN SECURITY_LOGON_TYPE LogonType,
    IN OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey,
    IN OPTIONAL PKERB_MESSAGE_BUFFER ForwardedTgt,
    IN OPTIONAL PUNICODE_STRING MappedName,
    IN OPTIONAL PKERB_INTERNAL_NAME S4UClient,
    IN OPTIONAL PUNICODE_STRING S4URealm,
    IN OPTIONAL PLUID AlternateLuid,
    IN PKERB_LOGON_SESSION LogonSession,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *NewTokenInformation,
    OUT PULONG ProfileBufferLength,
    OUT PVOID * ProfileBuffer,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCredentials,
    OUT PNETLOGON_VALIDATION_SAM_INFO4 * ppValidationInfo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_LOGON_SESSION SystemLogonSession = NULL;
    LUID SystemLogonId = SYSTEM_LUID;
    BOOLEAN TicketCacheLocked = FALSE;
    BOOLEAN LogonSessionsLocked = FALSE;
    PKERB_ENCRYPTED_TICKET Ticket = NULL;
    PPACTYPE Pac = NULL;
    PKERB_AUTHORIZATION_DATA PacAuthData = NULL;
    PKERB_IF_RELEVANT_AUTH_DATA * IfRelevantData = NULL;
    PPAC_INFO_BUFFER LogonInfo = NULL;
    PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo = NULL;
    PNETLOGON_VALIDATION_SAM_INFO4 ValidationInfo4 = NULL;
    PLSA_TOKEN_INFORMATION_V2 TokenInformation = NULL;
    PKERB_ENCRYPTION_KEY WkstaKey = NULL;
    BOOLEAN FreePac = FALSE;
    KERBERR KerbErr;
    UNICODE_STRING LocalDnsDomain = {0};
    LPWSTR lpDnsDomainName;
    UNICODE_STRING CRealm = {0};
    UNICODE_STRING CName = {0};
    UNICODE_STRING WkstaDomain = {0};
    ULONG NameType;
    

    // cache interactive logons only
    BOOLEAN CacheLogon = (LogonType == Interactive || LogonType == Service ||
                          LogonType == Batch || LogonType == RemoteInteractive );

    BOOLEAN AllowWorkstationLogon = (LogonType == Network || LogonType == NetworkCleartext);

    BOOLEAN CheckIdentify = ((KerbLogonInfo->MessageType == KerbTicketLogon) || 
                             (KerbLogonInfo->MessageType == KerbTicketUnlockLogon) ||
                             (KerbLogonInfo->MessageType == KerbS4ULogon));


    
    *ProfileBuffer = NULL;
    *NewTokenInformation = NULL;
    *ppValidationInfo = NULL;

    //
    // If you're not on a "joined" wksta, you don't need to use the
    // system key.  Otherwise, locate the sytem logon session, which contains the key
    // to decrypt the ticket
    //

    if (!RealmlessWkstaLogon)
    {
        //
        // S4U Logons will take place in the caller's context, and tickets
        // will be given directly to caller.
        //

        if (KerbLogonInfo->MessageType == KerbS4ULogon)
        {
            SystemLogonSession = KerbReferenceLogonSession(
                                        AlternateLuid,
                                        FALSE
                                        );

            DsysAssert(SystemLogonSession != NULL);
            if (SystemLogonSession == NULL)
            {
                Status = STATUS_NO_SUCH_LOGON_SESSION;
                goto Cleanup;
            }

            DsysAssert( !LogonSessionsLocked );
            KerbReadLockLogonSessions(SystemLogonSession);
            LogonSessionsLocked = TRUE;

            DsysAssert( !TicketCacheLocked );
            KerbReadLockTicketCache();
            TicketCacheLocked = TRUE;

            Status = KerbDuplicateString(
                        &LocalDnsDomain,
                        &SystemLogonSession->PrimaryCredentials.DomainName
                        );

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            if (LogonTicket && (LogonTicket->CacheFlags & KERB_TICKET_CACHE_TKT_ENC_IN_SKEY))
            {
                D_DebugLog((DEB_TRACE, "KerbCreateTokenFromLogonTicket using LogonTicketKey supplied\n"));

                WkstaKey = &LogonTicket->SessionKey; // use supplied logon ticket key
            }
        }
        else
        {
            SystemLogonSession = KerbReferenceLogonSession(
                                        &SystemLogonId,
                                        FALSE
                                        );
            DsysAssert(SystemLogonSession != NULL);
            if (SystemLogonSession == NULL)
            {
                Status = STATUS_NO_SUCH_LOGON_SESSION;
                goto Cleanup;
            }

            DsysAssert((SystemLogonSession->LogonSessionFlags & KERB_LOGON_NO_PASSWORD) == 0);

            Status = KerbGetOurDomainName(
                        &LocalDnsDomain
                        );

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            DsysAssert( !LogonSessionsLocked );
            KerbReadLockLogonSessions(SystemLogonSession);
            LogonSessionsLocked = TRUE;

            DsysAssert( !TicketCacheLocked );
            KerbReadLockTicketCache();
            TicketCacheLocked = TRUE;
        }

        //
        // Decrypt the ticket
        //

        //
        // Get the appropriate key
        //

        if (!WkstaKey)
        {
            D_DebugLog((DEB_TRACE, "KerbCreateTokenFromLogonTicket getting WkstaKey from SystemLogonSession\n"));

            WkstaKey = KerbGetKeyFromList(
                        SystemLogonSession->PrimaryCredentials.Passwords,
                        LogonTicket->Ticket.encrypted_part.encryption_type
                        );

            if (WkstaKey == NULL)
            {
                D_DebugLog((DEB_ERROR, "Couldn't find correct key type: 0x%x. %ws, line %d\n",
                          LogonTicket->Ticket.encrypted_part.encryption_type, THIS_FILE, __LINE__ ));
                Status = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }
        }

        KerbErr = KerbVerifyTicket(
                        &LogonTicket->Ticket,
                        1,
                        &KerbGlobalMachineServiceName,
                        &LocalDnsDomain,
                        WkstaKey,
                        NULL,           // don't check time
                        &Ticket
                        );

        //
        // Check that expired ticket for ticket logon are handled properly.
        // The client may pass a flag to explicitly allow an expired ticket.
        // This ticket makes the logon fail if the ticket is not expired.
        //

        if ((KerbLogonInfo->MessageType == KerbTicketLogon) ||
            (KerbLogonInfo->MessageType == KerbTicketUnlockLogon))
        {
            BOOLEAN AllowExpired = FALSE;
            PKERB_TICKET_LOGON TicketLogon = (PKERB_TICKET_LOGON) KerbLogonInfo;
            if ((TicketLogon->Flags & KERB_LOGON_FLAG_ALLOW_EXPIRED_TICKET) != 0)
            {
                AllowExpired = TRUE;
            }

            if (AllowExpired)
            {
                if (KerbErr == KDC_ERR_NONE)
                {
                    Status = STATUS_INVALID_PARAMETER;
                    D_DebugLog((DEB_ERROR,"Can't allow expired ticket on a non-expired ticket\n"));
                    goto Cleanup;
                }
                else if (KerbErr == KRB_AP_ERR_TKT_EXPIRED)
                {
                    KerbErr = KDC_ERR_NONE;
                }
            }
        }

        if (!KERB_SUCCESS(KerbErr))
        {
            DebugLog((DEB_ERROR,"Failed to decrypt workstation ticket: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
            if (KerbErr == KRB_AP_ERR_MODIFIED)
            {
                Status = STATUS_TRUSTED_RELATIONSHIP_FAILURE;
            }
            else
            {
                Status = KerbMapKerbError(KerbErr);
            }
        }

        //
        // If that failed, try again using the old password of the server
        //

        if ((Status == STATUS_TRUSTED_RELATIONSHIP_FAILURE) &&
            (SystemLogonSession->PrimaryCredentials.OldPasswords != NULL))
        {
            DebugLog((DEB_TRACE,"Current system password failed, trying old password\n"));

            //
            // Get the appropriate key
            //

            WkstaKey = KerbGetKeyFromList(
                            SystemLogonSession->PrimaryCredentials.OldPasswords,
                            LogonTicket->Ticket.encrypted_part.encryption_type
                            );
            if (WkstaKey == NULL)
            {
                DebugLog((DEB_ERROR,"Couldn't find correct key type: 0x%x. %ws, line %d\n",
                          LogonTicket->Ticket.encrypted_part.encryption_type, THIS_FILE, __LINE__ ));
                Status = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }

            KerbErr = KerbVerifyTicket(
                            &LogonTicket->Ticket,
                            1,
                            &KerbGlobalMachineServiceName,
                            &LocalDnsDomain,
                            WkstaKey,
                            NULL,               // don't check time
                            &Ticket
                            );
            if (!KERB_SUCCESS(KerbErr))
            {
                DebugLog((DEB_ERROR,"Failed to decrypt workstation ticket. %ws, line %d\n", THIS_FILE, __LINE__));
                if (KerbErr == KRB_AP_ERR_MODIFIED)
                {
                    Status = STATUS_TRUSTED_RELATIONSHIP_FAILURE;
                }
                else
                {
                    Status = KerbMapKerbError(KerbErr);
                }
            }
            else
            {
                Status = STATUS_SUCCESS;
            }
        }

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // Check out the client name in the ticket.  It must match, exactly,
        // what was requested.
        //

        if (KerbLogonInfo->MessageType == KerbS4ULogon)
        {
            BOOLEAN Result = FALSE;

            DsysAssert(ARGUMENT_PRESENT(S4UClient));
            DsysAssert(ARGUMENT_PRESENT(S4URealm));

            KerbErr = KerbCompareKdcNameToPrincipalName(
                            &Ticket->client_name,
                            S4UClient,
                            &Result
                            );

            if (!KERB_SUCCESS(KerbErr))
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            else if (!Result)
            {
                //
                // TBD: Audit?
                //

                DebugLog((DEB_ERROR, "S4UClient name != ticket CLIENTNAME\n"));
                Status = STATUS_LOGON_FAILURE;
                DsysAssert(FALSE);
                goto Cleanup;
            }

            KerbErr = KerbCompareUnicodeRealmToKerbRealm(
                            &Ticket->client_realm,
                            S4URealm,
                            &Result
                            );

            if (!KERB_SUCCESS(KerbErr))
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            else if (!Result)
            {
                //
                // TBD: Audit?
                //

                DebugLog((DEB_ERROR, "S4UClient REALM != ticket REALM\n"));
                Status = STATUS_LOGON_FAILURE;
                DsysAssert(FALSE);
                goto Cleanup;
            }
        }

        //
        // Make sure there is some authorization data
        //

        if (((Ticket->bit_mask & KERB_ENCRYPTED_TICKET_authorization_data_present) != 0) &&
             (Ticket->KERB_ENCRYPTED_TICKET_authorization_data != NULL))
        {
            KERB_ENCRYPTION_KEY LocalKey = {0};
            
            //
            // Verify the auth data is valid
            //

            if (!KerbVerifyAuthData(
                    Ticket->KERB_ENCRYPTED_TICKET_authorization_data
                ))
            {
                D_DebugLog((DEB_ERROR,"Failed to verify auth data\n"));
                Status = STATUS_LOGON_FAILURE;
                goto Cleanup;
            }

            //
            // Get the PAC out of the authorization data
            //

            KerbErr = KerbGetPacFromAuthData(
                          Ticket->KERB_ENCRYPTED_TICKET_authorization_data,
                          &IfRelevantData,
                          &PacAuthData
                          );

            if (!KERB_SUCCESS(KerbErr))
            {
                Status = KerbMapKerbError(KerbErr);
                goto Cleanup;
            }

            if (PacAuthData != NULL)
            {
                //
                // Unmarshall the PAC
                //

                Pac = (PPACTYPE) PacAuthData->value.auth_data.value;
                if (PAC_UnMarshal(Pac, PacAuthData->value.auth_data.length) == 0)
                {
                    D_DebugLog((DEB_ERROR,"Failed to unmarshal pac. %ws, line %d\n", THIS_FILE, __LINE__));
                    Status = STATUS_INVALID_PARAMETER;
                    goto Cleanup;
                }

                //
                // Copy state from the system logon session so we don't
                // leave it locked while verifying the PAC.
                //

                Status = KerbDuplicateString(
                            &WkstaDomain,
                            &SystemLogonSession->PrimaryCredentials.DomainName
                            );

                if (!NT_SUCCESS(Status))
                {
                    goto Cleanup;
                }

                if (!KERB_SUCCESS(KerbDuplicateKey(
                                    &LocalKey,
                                    WkstaKey)))
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                if (TicketCacheLocked)
                {
                    KerbUnlockTicketCache();
                    TicketCacheLocked = FALSE;
                }

                if (LogonSessionsLocked)
                {
                    KerbUnlockLogonSessions(SystemLogonSession);
                    LogonSessionsLocked = FALSE;
                }

                Status = KerbVerifyPacSignature(
                            &WkstaDomain,
                            Pac,
                            PacAuthData->value.auth_data.length,
                            &LocalKey,
                            Ticket,
                            FALSE,      // don't bother verifying at KDC, because we obtained the ticket
                            &ValidationInfo,
                            NULL // not interested in S4U delegation info
                            );
                
                KerbFreeKey( &LocalKey );

                if (!NT_SUCCESS(Status))
                {   
                    DebugLog((DEB_WARN,"Pac signature did not verify %x.\n", Status));

                    if (ARGUMENT_PRESENT(LogonTicket))
                    {
                        if (!KERB_SUCCESS(KerbConvertPrincipalNameToString( &CName, &NameType, &Ticket->client_name )))
                        {
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                            goto Cleanup;
                        }

                        if (!KERB_SUCCESS(KerbConvertRealmToUnicodeString( &CRealm, &Ticket->client_realm )))
                        {
                            Status = STATUS_INSUFFICIENT_RESOURCES;
                            goto Cleanup;
                        }
                          
                        KerbReportPACError(
                            &CName,
                            &CRealm,
                            Status
                            );
                    }

                    //
                    // DOA Leave now...
                    //

                    goto Cleanup;
                }

                DsysAssert( !LogonSessionsLocked );
                KerbReadLockLogonSessions(SystemLogonSession);  // nothing can change
                LogonSessionsLocked = TRUE;
            }
        }
    }

    //
    // If we didn't find a PAC, try to build one locally
    //

    if (RealmlessWkstaLogon || Pac == NULL)
    {   
        PKERB_INTERNAL_NAME ClientName = NULL;
        NTSTATUS TempStatus;

        DebugLog((DEB_WARN,"No authorization data in ticket - trying local\n"));

        // if we don't have a name, make one, but only if we have a service ticket
        if (ARGUMENT_PRESENT(LogonTicket))
        {

            if (!KERB_SUCCESS(KerbConvertRealmToUnicodeString(
                                    &CRealm,
                                    &Ticket->client_realm
                                    )))
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            //
            // Convert the client's name into a usable format
            //

            if (!KERB_SUCCESS(KerbConvertPrincipalNameToKdcName(
                                    &ClientName,
                                    &Ticket->client_name
                                    )))
            {   
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
        }
        //
        //  We don't have any information to do the mapping.  Return
        else if (MappedName->Buffer == NULL)
        {
            D_DebugLog((DEB_ERROR, "We don't have any information for creating a token!\n"));
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;

        }

        TempStatus = KerbCreatePacForKerbClient(
                        &Pac,
                        ClientName,
                        &CRealm,
                        MappedName
                        );

        KerbFreeKdcName(&ClientName);
        

        if (!NT_SUCCESS(TempStatus))
        {
            DebugLog((DEB_ERROR,"Failed to create local pac for client: 0x%x\n",TempStatus));

            //
            // Return the original error if we failed to build a pac
            //

            if (NT_SUCCESS(Status))
            {
                Status = TempStatus;
            }
            goto Cleanup;
        }

        FreePac = TRUE;

        //
        // Find the SAM validation info
        //

        LogonInfo = PAC_Find(
                        Pac,
                        PAC_LOGON_INFO,
                        NULL
                        );

        if (LogonInfo == NULL)
        {
            D_DebugLog((DEB_ERROR,"Failed to find logon info! %ws, line %d\n", THIS_FILE, __LINE__));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Now unmarshall the validation info
        //

        Status = PAC_UnmarshallValidationInfo(
                    &ValidationInfo,
                    LogonInfo->Data,
                    LogonInfo->cbBufferSize
                    );

        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to unmarshall validation info: 0x%x. %ws, line %d\n",
                Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }
    }

    //
    // Check to see if this is a non-user account. If so, don't allow the logon
    // unless its network, or network-cleartext.
    //

    if (((ValidationInfo->ExpansionRoom[SAMINFO_USER_ACCOUNT_CONTROL] & USER_MACHINE_ACCOUNT_MASK) != 0) &&
        ( !AllowWorkstationLogon ))
    {
        DebugLog((DEB_ERROR,"Logons to non-user accounts not allowed. UserAccountControl = 0x%x. %ws, line %d\n",
            ValidationInfo->ExpansionRoom[SAMINFO_USER_ACCOUNT_CONTROL], THIS_FILE, __LINE__ ));
        Status = STATUS_LOGON_TYPE_NOT_GRANTED;
        goto Cleanup;
    }

    //
    // Now we need to build a LSA_TOKEN_INFORMATION_V2 from the validation
    // information
    //

    Status = KerbMakeTokenInformationV2(
                ValidationInfo,
                FALSE,                  // not local system
                &TokenInformation
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to make token informatin v1: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // unlock ticket cache
    //
    // KerbAllocateInteractiveProfile will lock logon session and ticket cache
    //

    if (TicketCacheLocked)
    {
        KerbUnlockTicketCache();
        TicketCacheLocked = FALSE;
    }

    //
    // Allocate the client profile
    //

    Status = KerbAllocateInteractiveProfile(
                (PKERB_INTERACTIVE_PROFILE *) ProfileBuffer,
                ProfileBufferLength,
                ValidationInfo,
                LogonSession,
                Ticket,
                KerbLogonInfo
                );

    if (!KERB_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Build the primary credential. We let someone else fill in the
    // password.
    //

    PrimaryCredentials->LogonId = *LogonId;
    Status = KerbDuplicateString(
                &PrimaryCredentials->DownlevelName,
                &ValidationInfo->EffectiveName
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbDuplicateString(
                &PrimaryCredentials->DomainName,
                &ValidationInfo->LogonDomainName
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbDuplicateString(
                &PrimaryCredentials->LogonServer,
                &ValidationInfo->LogonServer
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbDuplicateSid(
                &PrimaryCredentials->UserSid,
                TokenInformation->User.User.Sid
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    PrimaryCredentials->Flags = 0;

    if ( CheckIdentify )
    {
        //
        // Do TCB check to see if we need an identify or impersonation
        // level token.
        //
        SECPKG_CLIENT_INFO ClientInfo;
        Status = LsaFunctions->GetClientInfo(&ClientInfo);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if (!ClientInfo.HasTcbPrivilege)
        {
            D_DebugLog((DEB_TRACE, "Building identify token\n"));
            PrimaryCredentials->Flags |= PRIMARY_CRED_LOGON_NO_TCB;
        }
    }    

    //
    // Get supplemental credentials out of the pac
    //

    Status = KerbExtractCachedCreds(
                Pac,
                CredentialKey,
                CachedCredentials
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // We're using the validation_info4 struct to pass appropriate information
    // back to caller for use in Lsa GetUserName().  We don't really use all
    // of this information, however, so only copy over interesting fields
    //

    ValidationInfo4 = (PNETLOGON_VALIDATION_SAM_INFO4) KerbAllocate(sizeof(NETLOGON_VALIDATION_SAM_INFO4));
    if (NULL == ValidationInfo4)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if (ValidationInfo->FullName.Length)
    {
        Status = KerbDuplicateString(
                    &ValidationInfo4->FullName,
                    &ValidationInfo->FullName
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    KerbReadLockLogonSessions(LogonSession);

    if (LogonSession->PrimaryCredentials.DomainName.Length)
    {

        D_DebugLog((DEB_TRACE_LOGON, "DomainName %wZ\n", &LogonSession->PrimaryCredentials.DomainName));

        Status = KerbDuplicateString(
                    &ValidationInfo4->DnsLogonDomainName,
                    &LogonSession->PrimaryCredentials.DomainName
                    );

        if (!NT_SUCCESS(Status))
        {
            KerbUnlockLogonSessions(LogonSession);
            goto Cleanup;
        }

        ValidationInfo4->Upn.Length = LogonSession->PrimaryCredentials.UserName.Length
                    + LogonSession->PrimaryCredentials.DomainName.Length
                    +sizeof(WCHAR);

        ValidationInfo4->Upn.MaximumLength = ValidationInfo4->Upn.Length + sizeof(WCHAR);

        ValidationInfo4->Upn.Buffer = (LPWSTR) KerbAllocate(ValidationInfo4->Upn.MaximumLength);

        if ( ValidationInfo4->Upn.Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            KerbUnlockLogonSessions(LogonSession);
            goto Cleanup;
        }

        RtlCopyMemory(
            ValidationInfo4->Upn.Buffer,
            LogonSession->PrimaryCredentials.UserName.Buffer,
            LogonSession->PrimaryCredentials.UserName.Length
            );

        ValidationInfo4->Upn.Buffer[LogonSession->PrimaryCredentials.UserName.Length/ sizeof(WCHAR)] = L'@';

        lpDnsDomainName =  ValidationInfo4->Upn.Buffer +
            LogonSession->PrimaryCredentials.UserName.Length / sizeof(WCHAR) + 1;

        RtlCopyMemory(
            lpDnsDomainName,
            LogonSession->PrimaryCredentials.DomainName.Buffer,
            LogonSession->PrimaryCredentials.DomainName.Length
            );

        D_DebugLog((DEB_TRACE_LOGON, "KerbCreateTokenFromLogonTicket built UPN %wZ\n", &ValidationInfo4->Upn));
    }

    KerbUnlockLogonSessions(LogonSession);

    //
    // Cache the logon info in MSV
    //

    if (CacheLogon)
    {
        if ( (KerbLogonInfo->MessageType == KerbInteractiveLogon)
              || (KerbLogonInfo->MessageType == KerbWorkstationUnlockLogon) )
        {
            //
            // Hold no locks when leaving this dll
            //

            if (TicketCacheLocked)
            {
                KerbUnlockTicketCache();
                TicketCacheLocked = FALSE;
            }

            if (LogonSessionsLocked)
            {
                KerbUnlockLogonSessions(SystemLogonSession);
                LogonSessionsLocked = FALSE;
            }

            KerbCacheLogonInformation(
                &KerbLogonInfo->UserName,
                &KerbLogonInfo->LogonDomainName,
                &KerbLogonInfo->Password,
                ((ValidationInfo4->DnsLogonDomainName.Length) ? &ValidationInfo4->DnsLogonDomainName : NULL),
                NULL, //((ValidationInfo4->Upn.Length) ? &ValidationInfo4->Upn : NULL),
                LogonSession,
                0, // no special flags                            
                ValidationInfo,
                NULL,                           // no supplemental creds
                0
                );

        }
        else if ((KerbLogonInfo->MessageType == KerbSmartCardLogon)
                  || (KerbLogonInfo->MessageType == KerbSmartCardUnlockLogon)) 
        {
            KerbCacheSmartCardLogon(
                ValidationInfo,
                ((ValidationInfo4->DnsLogonDomainName.Length) ? &ValidationInfo4->DnsLogonDomainName : NULL),
                NULL, //((ValidationInfo4->Upn.Length) ? &ValidationInfo4->Upn : NULL),
                LogonSession,
                *CachedCredentials
                );
        }
        else
        {
            D_DebugLog((DEB_WARN,"CacheLogon requested but logon type not cacheable\n"));
        }

    }

    //
    // If we were supplied a TGT for this logon, stick it in the logon session
    //

    if (ARGUMENT_PRESENT(ForwardedTgt) && (ForwardedTgt->BufferSize != 0))
    {
        Status = KerbExtractForwardedTgt(
                    LogonSession,
                    ForwardedTgt,
                    Ticket
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    *NewTokenInformation = TokenInformation;
    *TokenInformationType = LsaTokenInformationV2;
    *ppValidationInfo = ValidationInfo4;
    ValidationInfo4 = NULL;

Cleanup:

    KerbFreeString(&LocalDnsDomain);
    KerbFreeString( &CName );
    KerbFreeString( &CRealm );
    KerbFreeString( &WkstaDomain );

    if (TicketCacheLocked)
    {
        KerbUnlockTicketCache();
    }

    if (LogonSessionsLocked)
    {
        KerbUnlockLogonSessions(SystemLogonSession);
    }

    if (!NT_SUCCESS(Status))
    {
        if (TokenInformation != NULL)
        {
            KerbFree( TokenInformation );
        }
        if (*ProfileBuffer != NULL)
        {
            LsaFunctions->FreeClientBuffer(NULL, *ProfileBuffer);
            *ProfileBuffer = NULL;
        }
        KerbFreeString(
            &PrimaryCredentials->DownlevelName
            );
        KerbFreeString(
            &PrimaryCredentials->DomainName
            );
        KerbFreeString(
            &PrimaryCredentials->LogonServer
            );
        if (PrimaryCredentials->UserSid != NULL)
        {
            KerbFree(PrimaryCredentials->UserSid);
            PrimaryCredentials->UserSid = NULL;
        }
    }
    if (Ticket != NULL)
    {
        KerbFreeTicket(Ticket);
    }
    if (FreePac && (Pac != NULL))
    {
        MIDL_user_free(Pac);
    }

    if (IfRelevantData != NULL)
    {
        KerbFreeData(
            PKERB_IF_RELEVANT_AUTH_DATA_PDU,
            IfRelevantData
            );
    }

    if (ValidationInfo != NULL)
    {
        MIDL_user_free(ValidationInfo);
    }

    if (ValidationInfo4)
    {
        KerbFreeString(&ValidationInfo4->DnsLogonDomainName);
        KerbFreeString(&ValidationInfo4->Upn);
        KerbFreeString(&ValidationInfo4->FullName);
        KerbFree(ValidationInfo4);
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildLocalAccountToken
//
//  Synopsis:   Creates a token from a mapped kerberos principal
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
/*
NTSTATUS
KerbBuildLocalAccountToken(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PLUID LogonId,
    IN PUNICODE_STRING MappedClientName,
    IN PKERB_INTERACTIVE_LOGON KerbLogonInfo,
    OUT PLSA_TOKEN_INFORMATION_TYPE LogonSession,
    OUT PVOID * NewTokenInformation,
    OUT PULONG ProfileBufferLength,
    OUT PVOID * ProfileBuffer,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCreds
    )
{

    NTSTATUS Status = STATUS_SUCCESS;
    SECPKG_CLIENT_INFO ClientInfo;
    PLSAPR_POLICY_INFORMATION PolicyInfo = NULL;
    SAMPR_HANDLE SamHandle = NULL;
    SAMPR_HANDLE DomainHandle = NULL;
    SAMPR_HANDLE UserHandle = NULL;
    PSAMPR_GET_GROUPS_BUFFER Groups = NULL;
    SID_AND_ATTRIBUTES_LIST TransitiveGroups = {0};
    PSAMPR_USER_INFO_BUFFER UserInfo = NULL;
    PPACTYPE LocalPac = NULL;
    SAMPR_ULONG_ARRAY RidArray;
    SAMPR_ULONG_ARRAY UseArray;


    *ProfileBuffer = NULL;
    *NewTokenInformation = NULL;

    //
    // Verify that the caller has TCB privilege. Otherwise anyone can forge
    // a ticket to themselves to logon with any name in the list.
    //

    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    if (!ClientInfo.HasTcbPrivilege)
    {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    //
    // Call the LSA to get our domain sid
    //
    Status = LsaIQueryInformationPolicyTrusted(
                PolicyAccountDomainInformation,
                &PolicyInfo
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "LsaIQueryInformationPolicyTrusted failed - %x\n", Status));
        goto Cleanup;
    }

    //
    // Open SAM to get the account information
    //
    Status = SamIConnect(
                NULL,                   // no server name
                &SamHandle,
                0,                      // no desired access
                TRUE                    // trusted caller
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SamIConnectFailed - %x\n", Status));
        goto Cleanup;
    }

    Status = SamrOpenDomain(
                SamHandle,
                0,                      // no desired access
                (PRPC_SID) PolicyInfo->PolicyAccountDomainInfo.DomainSid,
                &DomainHandle
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SamrOpenDomain failed - %x\n", Status));
        goto Cleanup;
    }

    Status = SamrLookupNamesInDomain(
                    DomainHandle,
                    1,
                    (PRPC_UNICODE_STRING) MappedClientName,
                    &RidArray,
                    &UseArray
                    );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "SamrOpenDomain failed - %x\n", Status));
        goto Cleanup;
    }

    if ((UseArray.Element[0] != SidTypeUser) &&
        (UseArray.Element[0] != SidTypeComputer))
    {
        Status = STATUS_NONE_MAPPED;
        goto Cleanup;
    }

    Status = SamrOpenUser(
                DomainHandle,
                0,                      // no desired access,
                RidArray.Element[0],
                &UserHandle
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = SamrQueryInformationUser(
        UserHandle,
        UserAllInformation,
        &UserInfo
        );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = SamrGetGroupsForUser(
                UserHandle,
                &Groups
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerbGlobalReadLock();
    Status = KerbDuplicateString(
                    &LocalMachineName,
                    &KerbGlobalMachineName
                    );

    KerbGlobalReleaseLock();

    if(!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to duplicate KerbGlobalMachineName\n"));
        goto Cleanup;
    }


    //
    // Set the password must changes time to inifinite because we don't
    // want spurious password must change popups
    //

    UserInfo->All.PasswordMustChange = *(POLD_LARGE_INTEGER) &KerbGlobalWillNeverTime;

    //
    // *Don't build a PAC, that's extra effort in marshalling unmarshalling
    // data we can just convert over from Samuserall to Netlogon_Validation_Info
    //













}   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\logonses.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        logonses.h
//
// Contents:    prototypes and structures for the logon session list
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __LOGONSES_H__
#define __LOGONSES_H__

#include <safelock.h>

//
// All global variables declared as EXTERN will be allocated in the file
// that defines LOGONSES_ALLOCATE
//
#ifdef EXTERN
#undef EXTERN
#endif

#ifdef LOGONSES_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

EXTERN KERBEROS_LIST KerbLogonSessionList;
EXTERN BOOLEAN KerberosLogonSessionsInitialized;

//
// Keep track a list of session keys for network service in ISC. These keys are
// used in ASC to detect whether a kerb logon session is from ISC called by the
// local network serivce (the client)
//

EXTERN LIST_ENTRY KerbSKeyList;
EXTERN SAFE_RESOURCE KerbSKeyLock;

//
// the number of entries is only used in debugger spew of checked builds
//

#if DBG

EXTERN volatile LONG KerbcSKeyEntries;

#endif

//
// timer used to clean up the session key list above
//

EXTERN HANDLE KerbhSKeyTimerQueue;

//
// NOTICE: The logon session resource, credential resource, and context
// resource must all be acquired carefully to prevent deadlock. They
// can only be acquired in this order:
//
// 1. Logon Sessions
// 2. Credentials
// 3. Contexts
//

#if DBG
#ifdef WIN32_CHICAGO
#define KerbWriteLockLogonSessions(_X_) \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Write locking LogonSessions\n")); \
    DsysAssert(KerbGlobalContextsLocked != GetCurrentThreadId()); \
    EnterCriticalSection(&(_X_)->Lock); \
}
#define KerbReadLockLogonSessions(_X_) \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Read locking LogonSessions\n")); \
    DsysAssert(KerbGlobalContextsLocked != GetCurrentThreadId()); \
    EnterCriticalSection(&(_X_)->Lock); \
}
#define KerbUnlockLogonSessions(_X_) \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Unlocking LogonSessions\n")); \
    LeaveCriticalSection(&(_X_)->Lock); \
}
#else  // WIN32_CHICAGO
#define KerbWriteLockLogonSessions(_X_) \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Write locking LogonSession %p\n",(_X_))); \
    DsysAssert(KerbGlobalContextsLocked != GetCurrentThreadId()); \
    SafeEnterCriticalSection(&(_X_)->Lock); \
}
#define KerbReadLockLogonSessions(_X_) \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Read locking LogonSession %p\n",(_X_))); \
    DsysAssert(KerbGlobalContextsLocked != GetCurrentThreadId()); \
    SafeEnterCriticalSection(&(_X_)->Lock); \
}
#define KerbUnlockLogonSessions(_X_) \
{ \
    DebugLog((DEB_TRACE_LOCKS,"Unlocking LogonSessions\n")); \
    SafeLeaveCriticalSection(&(_X_)->Lock); \
}
#endif // WIN32_CHICAGO
#else
#ifdef WIN32_CHICAGO
#define KerbWriteLockLogonSessions(_X_) \
    EnterCriticalSection(&(_X_)->Lock)
#define KerbReadLockLogonSessions(_X_) \
    EnterCriticalSection(&(_X_)->Lock)
#define KerbUnlockLogonSessions(_X_) \
    LeaveCriticalSection(&(_X_)->Lock)
#else  // WIN32_CHICAGO
#define KerbWriteLockLogonSessions(_X_) \
    SafeEnterCriticalSection(&(_X_)->Lock);
#define KerbReadLockLogonSessions(_X_) \
    SafeEnterCriticalSection(&(_X_)->Lock);
#define KerbUnlockLogonSessions(_X_) \
    SafeLeaveCriticalSection(&(_X_)->Lock);
#endif // WIN32_CHICAGO
#endif

//
// Helper routines for Logon Sessions
//

NTSTATUS
KerbInitLogonSessionList(
    VOID
    );

NTSTATUS
KerbInitLoopbackDetection(
    VOID
    );

VOID
KerbFreeSKeyListAndLock(
    VOID
    );

VOID
KerbFreeLogonSessionList(
    VOID
    );

VOID
KerbFreeExtraCredList(
    IN PEXTRA_CRED_LIST Credlist
    );


NTSTATUS
KerbAllocateLogonSession(
    PKERB_LOGON_SESSION * NewLogonSession
    );

NTSTATUS
KerbInsertLogonSession(
    IN PKERB_LOGON_SESSION LogonSession
    );

PKERB_LOGON_SESSION
KerbReferenceLogonSession(
    IN PLUID LogonId,
    IN BOOLEAN RemoveFromList
    );

VOID
KerbReferenceLogonSessionByPointer(
    IN PKERB_LOGON_SESSION LogonSession,
    IN BOOLEAN RemoveFromList
    );


VOID
KerbDereferenceLogonSession(
    IN PKERB_LOGON_SESSION LogonSession
    );

NTSTATUS
KerbCreateLogonSession(
    IN PLUID LogonId,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING DomainName,
    IN OPTIONAL PUNICODE_STRING Password,
    IN OPTIONAL PUNICODE_STRING OldPassword,
    IN ULONG PasswordFlags,
    IN ULONG LogonSessionFlags,
    IN BOOLEAN AllowDuplicate,
    OUT PKERB_LOGON_SESSION * NewLogonSession
    );

NTSTATUS
KerbCreateDummyLogonSession(
    IN PLUID LogonId,
    IN OUT PKERB_LOGON_SESSION * NewLogonSession,
    IN SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
    IN BOOLEAN Impersonating,
    IN HANDLE hProcess
    );

VOID
KerbFreeLogonSession(
    IN PKERB_LOGON_SESSION LogonSession
    );

NTSTATUS
KerbCreateLogonSessionFromKerbCred(
    IN OPTIONAL PLUID LogonId,
    IN PKERB_ENCRYPTED_TICKET Ticket,
    IN PKERB_CRED KerbCred,
    IN PKERB_ENCRYPTED_CRED EncryptedCred,
    IN OUT PKERB_LOGON_SESSION *OldLogonSession
    );


NTSTATUS
KerbCreateLogonSessionFromTicket(
    IN PLUID NewLuid,
    IN OPTIONAL PLUID AcceptingLuid,
    IN PUNICODE_STRING ClientName,
    IN PUNICODE_STRING ClientRealm,
    IN PKERB_AP_REQUEST ApRequest,
    IN PKERB_ENCRYPTED_TICKET Ticket,
    IN OUT OPTIONAL PKERB_LOGON_SESSION *NewLogonSession
    );


NTSTATUS
KerbBuildPasswordList(
    IN PUNICODE_STRING Password,
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DomainName,
    IN PKERB_ETYPE_INFO SuppliedSalt,
    IN PKERB_STORED_CREDENTIAL OldPasswords,
    IN OPTIONAL PUNICODE_STRING PrincipalName,
    IN KERB_ACCOUNT_TYPE AccountType,
    IN ULONG PasswordFlags,
    OUT PKERB_STORED_CREDENTIAL * PasswordList
    );

VOID
KerbFreeStoredCred(
    IN PKERB_STORED_CREDENTIAL StoredCred
    );

NTSTATUS
KerbReplacePasswords(
    IN PKERB_PRIMARY_CREDENTIAL Current,
    IN PKERB_PRIMARY_CREDENTIAL New
    );

NTSTATUS
KerbChangeCredentialsPassword(
    IN PKERB_PRIMARY_CREDENTIAL PrimaryCredentials,
    IN OPTIONAL PUNICODE_STRING NewPassword,
    IN OPTIONAL PKERB_ETYPE_INFO EtypeInfo,
    IN KERB_ACCOUNT_TYPE AccountType,
    IN ULONG PasswordFlags
    );

NTSTATUS
KerbAddExtraCredentialsToLogonSession(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_ADD_CREDENTIALS_REQUEST AddCredRequest
    );



//
// Flags for logon sessions
//

#define KERB_LOGON_DEFERRED             0x1
#define KERB_LOGON_NO_PASSWORD          0x2
#define KERB_LOGON_LOCAL_ONLY           0x4
#define KERB_LOGON_ONE_SHOT             0x8

#define KERB_LOGON_SMARTCARD            0x10
#define KERB_LOGON_MIT_REALM            0x20
#define KERB_LOGON_HAS_TCB              0x40



//
// None of the below have credentials (TGT / pwd), so we need
// to do S4U to go off box, or we'll use a NULL connection..
//

#define KERB_LOGON_S4U_SESSION          0x1000
#define KERB_LOGON_DUMMY_SESSION        0x2000 // "other" package satisfied logon
#define KERB_LOGON_ASC_SESSION          0x4000 // formed from AcceptSecurityCtxt.
#define KERB_LOGON_TICKET_SESSION       0x0200
#define KERB_LOGON_DELEGATE_OK          0x0100 // Means we can delegate this - ok for proxy



#define KERB_LOGON_S4U_REQUIRED         0xF000

//
// Delegation with unconstrained delegation.
//

#define KERB_LOGON_DELEGATED            0x10000

//
// NewCredentials logon
//

#define KERB_LOGON_NEW_CREDENTIALS      0x20000



#endif // __LOGONSES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\miscapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        miscapi.cxx
//
// Contents:    Code for miscellaneous lsa mode Kerberos entrypoints
//
//
// History:     16-April-1996   MikeSw  Created
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>
#include <crypt.h>      // NT_OWF_PASSWORD_LENGTH
#include <kerbpass.h>

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

//
// LsaApCallPackage() function dispatch table
//

NTSTATUS NTAPI
KerbDebugRequest(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbQueryTicketCache(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbQueryTicketCacheEx(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbChangeMachinePassword(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbVerifyPac(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbRetrieveTicket(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbSetIpAddresses(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbPurgeTicket(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbPurgeTicketEx(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbRetrieveEncodedTicket(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbRetrieveEncodedTicketEx(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbAddBindingCacheEntry(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );


NTSTATUS NTAPI
KerbDecryptMessage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbVerifyCredentials(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbRefreshSmartcardCredentials(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

NTSTATUS NTAPI
KerbAddExtraCredential(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );


NTSTATUS NTAPI
KerbQuerySupplementalCredentials(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );


PLSA_AP_CALL_PACKAGE
KerbCallPackageDispatch[] = {
#if DBG
    KerbDebugRequest,
#else
    NULL,
#endif
    KerbQueryTicketCache,
    KerbChangeMachinePassword,
    KerbVerifyPac,
    KerbRetrieveTicket,
    KerbSetIpAddresses,
    KerbPurgeTicket,
    KerbChangePassword,
    KerbRetrieveEncodedTicket,
#if DBG
    KerbDecryptMessage,
#else
    NULL,
#endif
    KerbAddBindingCacheEntry,
    KerbSetPassword,
    KerbSetPassword,
    KerbVerifyCredentials,
    KerbQueryTicketCacheEx,
    KerbPurgeTicketEx,
    KerbRefreshSmartcardCredentials,
    KerbAddExtraCredential,
    KerbQuerySupplementalCredentials
    };



//+-------------------------------------------------------------------------
//
//  Function:   SpGetUserInfo
//
//  Synopsis:   Gets information about a user
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpGetUserInfo(
    IN PLUID LogonId,
    IN ULONG Flags,
    OUT PSecurityUserData * UserData
    )
{
    return(STATUS_NOT_SUPPORTED);
}



//+-------------------------------------------------------------------------
//
//  Function:   LsaApCallPackage
//
//  Synopsis:   Kerberos entrypoint for LsaCallAuthenticationPackage
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
LsaApCallPackage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    ULONG MessageType;
    PLSA_AP_CALL_PACKAGE TempFn = NULL;

    //
    // Get the messsage type from the protocol submit buffer.
    //

    if ( SubmitBufferLength < sizeof(KERB_PROTOCOL_MESSAGE_TYPE) )
    {
        return STATUS_INVALID_PARAMETER;
    }

    MessageType =
        (ULONG) *((PKERB_PROTOCOL_MESSAGE_TYPE)(ProtocolSubmitBuffer));

    if ((MessageType >=
         (sizeof(KerbCallPackageDispatch)/sizeof(KerbCallPackageDispatch[0]))) ||
         (KerbCallPackageDispatch[MessageType] == NULL))
    {

        return STATUS_INVALID_PARAMETER;
    }

    //
    // Allow the dispatch routines to only set the return buffer information
    // on success conditions.
    //

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    //
    // Call the appropriate routine for this message.
    //

    TempFn = KerbCallPackageDispatch[MessageType];
    if (!TempFn)
    {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    Status = (*TempFn)(
        ClientRequest,
        ProtocolSubmitBuffer,
        ClientBufferBase,
        SubmitBufferLength,
        ProtocolReturnBuffer,
        ReturnBufferLength,
        ProtocolStatus );

//    RtlCheckForOrphanedCriticalSections(NtCurrentThread());

Cleanup:
    return(Status);

}


NTSTATUS NTAPI
LsaApCallPackageUntrusted(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;

    //
    // Get the messsage type from the protocol submit buffer.
    //

    if ( SubmitBufferLength < sizeof(KERB_PROTOCOL_MESSAGE_TYPE) ) {
        return STATUS_INVALID_PARAMETER;
    }

    MessageType = *((PKERB_PROTOCOL_MESSAGE_TYPE)(ProtocolSubmitBuffer));

    if ( MessageType >=
        (sizeof(KerbCallPackageDispatch)/sizeof(KerbCallPackageDispatch[0])))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Untrusted clients are not allowed to call the ChangeMachinePassword function
    //

    if (MessageType == KerbChangeMachinePasswordMessage)
    {
        return STATUS_ACCESS_DENIED;
    }


    //
    // Allow the dispatch routines to only set the return buffer information
    // on success conditions.
    //

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    //
    // Call the appropriate routine for this message.
    //

    return(LsaApCallPackage(
                ClientRequest,
                ProtocolSubmitBuffer,
                ClientBufferBase,
                SubmitBufferLength,
                ProtocolReturnBuffer,
                ReturnBufferLength,
                ProtocolStatus) );
}


NTSTATUS NTAPI
LsaApCallPackagePassthrough(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    KERB_PROTOCOL_MESSAGE_TYPE MessageType;

    //
    // Get the messsage type from the protocol submit buffer.
    //

    if ( SubmitBufferLength < sizeof(KERB_PROTOCOL_MESSAGE_TYPE) ) {
        return STATUS_INVALID_PARAMETER;
    }

    MessageType = *((PKERB_PROTOCOL_MESSAGE_TYPE)(ProtocolSubmitBuffer));

    if ( MessageType >=
        (sizeof(KerbCallPackageDispatch)/sizeof(KerbCallPackageDispatch[0])))
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // only allow passthrough related requests.
    //

    if (MessageType != KerbVerifyPacMessage)
    {
        return STATUS_ACCESS_DENIED;
    }


    //
    // Allow the dispatch routines to only set the return buffer information
    // on success conditions.
    //

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    //
    // Call the appropriate routine for this message.
    //

    return(LsaApCallPackage(
                ClientRequest,
                ProtocolSubmitBuffer,
                ClientBufferBase,
                SubmitBufferLength,
                ProtocolReturnBuffer,
                ReturnBufferLength,
                ProtocolStatus) );
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbDebugRequest
//
//  Synopsis:   CallPackage entrypoint for debugging
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbDebugRequest(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

#if DBG
    PVOID Handle = NULL;
    PBYTE AuthData = NULL;
    UNICODE_STRING AccountName = {0};

    BYTE Buffer[sizeof(KERB_DEBUG_REPLY) + sizeof(KERB_DEBUG_STATS) - sizeof(UCHAR) * ANYSIZE_ARRAY];
    PKERB_DEBUG_REQUEST DebugRequest;
    PKERB_DEBUG_REPLY   DebugReply = (PKERB_DEBUG_REPLY) Buffer;
    PKERB_DEBUG_STATS   DebugStats = (PKERB_DEBUG_STATS) DebugReply->Data;

    if (SubmitBufferLength < sizeof(*DebugRequest)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    DebugRequest = (PKERB_DEBUG_REQUEST) ProtocolSubmitBuffer;
    switch(DebugRequest->DebugRequest) {
    case KERB_DEBUG_REQ_BREAKPOINT:
        DbgBreakPoint();
        break;

    case KERB_DEBUG_REQ_STATISTICS:
        DebugReply->MessageType = KerbDebugRequestMessage;
        DebugStats->CacheHits = KerbTicketCacheHits;
        DebugStats->CacheMisses = KerbTicketCacheMisses;
        DebugStats->SkewedRequests = KerbSkewState.SkewedRequests;
        DebugStats->SuccessRequests = KerbSkewState.SuccessRequests;
        DebugStats->LastSync = KerbSkewState.LastSync;
        Status = LsaFunctions->AllocateClientBuffer(
                    NULL,
                    sizeof(Buffer),
                    ProtocolReturnBuffer
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        Status = LsaFunctions->CopyToClientBuffer(
                    NULL,
                    sizeof(Buffer),
                    *ProtocolReturnBuffer,
                    DebugReply
                    );
        if (!NT_SUCCESS(Status))
        {
            LsaFunctions->FreeClientBuffer(
                NULL,
                *ProtocolReturnBuffer
                );
            *ProtocolReturnBuffer = NULL;
        }
        else
        {
            *ReturnBufferLength = sizeof(Buffer);
        }

        break;
#ifdef ALLOW_TOKEN_CREATION
    case KERB_DEBUG_CREATE_TOKEN:
    {
        UNICODE_STRING String, String2;
        ULONG AuthDataSize = 0;
        HANDLE TokenHandle = NULL;
        LUID LogonId;
        NTSTATUS SubStatus;

        RtlInitUnicodeString(
            &String,
            L"Administrator"
            );
        RtlInitUnicodeString(
            &String2,
            NULL
            );

        Status = LsaFunctions->OpenSamUser(
                    &String,
                    SecNameSamCompatible,
                    &String2,
                    TRUE,               // allow guest
                    0,                  // reserved
                    &Handle
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to open sam user: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        Status = LsaFunctions->GetUserAuthData(
                    Handle,
                    &AuthData,
                    &AuthDataSize
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to get auth data: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        //
        // Now create that token
        //

        Status = LsaFunctions->ConvertAuthDataToToken(
                    AuthData,
                    AuthDataSize,
                    SecurityImpersonation,
                    &KerberosSource,
                    Network,
                    &String,
                    &TokenHandle,
                    &LogonId,
                    &AccountName,
                    &SubStatus
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to create token: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }
        NtClose(TokenHandle);
        DebugLog((DEB_ERROR,"Logged on account is %wZ. %ws, line %d\n",&AccountName, THIS_FILE, __LINE__));
        break;

    }

#endif // ALLOW_TOKEN_CREATION
    default:
        Status = STATUS_INVALID_PARAMETER;
    }

Cleanup:

    if( Handle != NULL )
    {
        LsaFunctions->CloseSamUser( Handle );
    }

    if( AuthData != NULL )
    {
        LsaFunctions->FreeLsaHeap( AuthData );
    }

    if( AccountName.Buffer != NULL )
    {
        LsaFunctions->FreeLsaHeap( AccountName.Buffer );
    }

#else
    Status = STATUS_INVALID_PARAMETER;
#endif
    return(Status);

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbRefreshSmartcardCredentials
//
//  Synopsis:   Notifies Kerberos when the smart card credentials need to
//              be updated.  Basically a workaround for winlogon session
//              switching behavior during TS connects / re-connects.
//              When this happens, your HPROV goes bad...
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbRefreshSmartcardCredentials(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS                      Status = STATUS_SUCCESS;
    PKERB_LOGON_SESSION           LogonSession = NULL;
    PKERB_REFRESH_SCCRED_REQUEST  RefreshRequest;
    SECPKG_CLIENT_INFO            ClientInfo;
    PLUID                         LogonId;

    if (SubmitBufferSize < sizeof(KERB_REFRESH_SCCRED_REQUEST))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    RefreshRequest = (PKERB_REFRESH_SCCRED_REQUEST) ProtocolSubmitBuffer;

    if (ARGUMENT_PRESENT(ProtocolReturnBuffer))
    {
        *ProtocolReturnBuffer = NULL;
    }

    if (ARGUMENT_PRESENT(ReturnBufferLength))
    {
        *ReturnBufferLength = 0;
    }

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    if( !LsaFunctions->GetCallInfo( &CallInfo ))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0)
    {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

#endif // _WIN64
    
    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //
    Status = LsaFunctions->GetClientInfo( &ClientInfo );
    if ( !NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }

    if ( RtlIsZeroLuid( &RefreshRequest->LogonId ))
    {
        LogonId = &ClientInfo.LogonId;
    }
    else if ( (!ClientInfo.HasTcbPrivilege) || 
              ( RefreshRequest->Flags == KERB_REFRESH_SCCRED_GETTGT )) 
    {
        //
        // We can't do this w/o TCB.  && we can only get TGTs for ourselves
        // due to pin caching / impersonation issues.
        //
        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;
    }
    else
    {
        LogonId = &RefreshRequest->LogonId;
    }


    NULL_RELOCATE_ONE( &RefreshRequest->CredentialBlob );

    LogonSession = KerbReferenceLogonSession(
                            LogonId,
                            FALSE
                            );

    DsysAssert(LogonSession != NULL);
    if (LogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    if ( RefreshRequest->Flags == KERB_REFRESH_SCCRED_RELEASE )
    {  
        KerbReleasePkCreds(
            LogonSession,
            NULL,
            TRUE  // ok for reuse - save PIN and SChelper data
            );
    }
    else if ( RefreshRequest->Flags == KERB_REFRESH_SCCRED_GETTGT )
    {
        Status = KerbTicklePackage(
                    LogonSession,
                    &RefreshRequest->CredentialBlob
                    );

        if (!NT_SUCCESS( Status ))
        {
            goto Cleanup;
        }

    }
    else
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    Status = STATUS_SUCCESS;

Cleanup:
    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }

    *ProtocolStatus = Status;

    return(STATUS_SUCCESS);
}





//+-------------------------------------------------------------------------
//
//  Function:   KerbChangeMachinePassword
//
//  Synopsis:   Notifies Kerberos when the machine password has changed
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbChangeMachinePassword(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS                      Status = STATUS_SUCCESS;
    LUID                          SystemLogonId = SYSTEM_LUID;
    PKERB_LOGON_SESSION           SystemLogonSession = NULL;
    PKERB_CHANGE_MACH_PWD_REQUEST ChangeRequest;
    ULONG                         StructureSize = sizeof(KERB_CHANGE_MACH_PWD_REQUEST);

    if (ARGUMENT_PRESENT(ProtocolReturnBuffer))
    {
        *ProtocolReturnBuffer = NULL;
    }

    if (ARGUMENT_PRESENT(ReturnBufferLength))
    {
        *ReturnBufferLength = 0;
    }

#if _WIN64

    SECPKG_CALL_INFO              CallInfo;

    if(!LsaFunctions->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        StructureSize = sizeof(KERB_CHANGE_MACH_PWD_REQUEST_WOW64);
    }

#endif  // _WIN64

    if (SubmitBufferLength < StructureSize)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_SUCCESS;
        DsysAssert(FALSE);
        goto Cleanup;
    }

    ChangeRequest = (PKERB_CHANGE_MACH_PWD_REQUEST) ProtocolSubmitBuffer;

#if _WIN64

    KERB_CHANGE_MACH_PWD_REQUEST LocalChangeRequest;

    //
    // Thunk 32-bit pointers if this is a WOW caller
    //

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        PKERB_CHANGE_MACH_PWD_REQUEST_WOW64 ChangeRequestWOW =
            (PKERB_CHANGE_MACH_PWD_REQUEST_WOW64) ChangeRequest;

        LocalChangeRequest.MessageType = ChangeRequest->MessageType;

        UNICODE_STRING_FROM_WOW_STRING(&LocalChangeRequest.NewPassword,
                                       &ChangeRequestWOW->NewPassword);

        UNICODE_STRING_FROM_WOW_STRING(&LocalChangeRequest.OldPassword,
                                       &ChangeRequestWOW->OldPassword);

        ChangeRequest = &LocalChangeRequest;
    }

#endif  // _WIN64


    //
    // Find the system logon session.
    //

    SystemLogonSession = KerbReferenceLogonSession(
                            &SystemLogonId,
                            FALSE               // don't unlink
                            );

    DsysAssert(SystemLogonSession != NULL);
    if (SystemLogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }



    //
    // Calculate the new password list
    //

    if (ChangeRequest->NewPassword.Buffer != NULL)
    {
        //
        // If there is an old password, update with that one first so it
        // will later get moved to the old password field.
        //

        KerbWriteLockLogonSessions(SystemLogonSession);
        if (ChangeRequest->OldPassword.Buffer != NULL)
        {
            Status = KerbChangeCredentialsPassword(
                        &SystemLogonSession->PrimaryCredentials,
                        &ChangeRequest->OldPassword,
                        NULL,                           // no etype info
                        MachineAccount,
                        PRIMARY_CRED_CLEAR_PASSWORD
                        );
        }
        if (NT_SUCCESS(Status))
        {
            Status = KerbChangeCredentialsPassword(
                        &SystemLogonSession->PrimaryCredentials,
                        &ChangeRequest->NewPassword,
                        NULL,                           // no etype info
                        MachineAccount,
                        PRIMARY_CRED_CLEAR_PASSWORD
                        );
        }

        KerbUnlockLogonSessions(SystemLogonSession);

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // Update the flags to indicate that we have a password
        //

        KerbWriteLockLogonSessions(SystemLogonSession);
        SystemLogonSession->LogonSessionFlags &= ~(KERB_LOGON_LOCAL_ONLY | KERB_LOGON_NO_PASSWORD);
        KerbUnlockLogonSessions(SystemLogonSession);
    }
    else
    {
        //
        // Update the flags to indicate that we do not have a password
        //

        KerbWriteLockLogonSessions(SystemLogonSession);
        SystemLogonSession->LogonSessionFlags |= (KERB_LOGON_LOCAL_ONLY | KERB_LOGON_NO_PASSWORD);
        KerbUnlockLogonSessions(SystemLogonSession);
    }


    Status = STATUS_SUCCESS;
Cleanup:
    if (SystemLogonSession != NULL)
    {
        KerbDereferenceLogonSession(SystemLogonSession);
    }

    *ProtocolStatus = Status;

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbNameLength
//
//  Synopsis:   returns length in bytes of variable portion of KERB_INTERNAL_NAME
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbWOWNameLength.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------


ULONG
KerbNameLength(
    IN PKERB_INTERNAL_NAME Name
    )
{
    ULONG Length = 0;
    ULONG Index;

    if (!ARGUMENT_PRESENT(Name))
    {
        return(0);
    }
    Length = sizeof(KERB_INTERNAL_NAME)
                - sizeof(UNICODE_STRING)
                + Name->NameCount * sizeof(UNICODE_STRING) ;
    for (Index = 0; Index < Name->NameCount ;Index++ )
    {
        Length += Name->Names[Index].Length;
    }
    Length = ROUND_UP_COUNT(Length, sizeof(LPWSTR));
    return(Length);
}

ULONG
KerbStringNameLength(
    IN PKERB_INTERNAL_NAME Name
    )
{
    ULONG Length = 0;
    ULONG Index;

    Length = Name->NameCount * sizeof(WCHAR);   // for separators & null terminator
    for (Index = 0; Index < Name->NameCount ;Index++ )
    {
        Length += Name->Names[Index].Length;
    }
    return(Length);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPutKdcName
//
//  Synopsis:   Copies a Kdc name to a buffer
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutWOWKdcName.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
KerbPutKdcName(
    IN PKERB_INTERNAL_NAME InputName,
    OUT PKERB_EXTERNAL_NAME * OutputName,
    IN LONG_PTR Offset,
    IN OUT PBYTE * Where
    )
{
    ULONG Index;
    PKERB_INTERNAL_NAME LocalName = (PKERB_INTERNAL_NAME) *Where;

    if (!ARGUMENT_PRESENT(InputName))
    {
        *OutputName = NULL;
        return;
    }
    *Where += sizeof(KERB_INTERNAL_NAME) - sizeof(UNICODE_STRING) +
                InputName->NameCount * sizeof(UNICODE_STRING);
    LocalName->NameType = InputName->NameType;
    LocalName->NameCount = InputName->NameCount;

    for (Index = 0; Index < InputName->NameCount ; Index++ )
    {
        LocalName->Names[Index].Length =
            LocalName->Names[Index].MaximumLength =
            InputName->Names[Index].Length;
        LocalName->Names[Index].Buffer = (LPWSTR) (*Where + Offset);
        RtlCopyMemory(
            *Where,
            InputName->Names[Index].Buffer,
            InputName->Names[Index].Length
            );
        *Where += InputName->Names[Index].Length;
    }
    *Where = (PBYTE) ROUND_UP_POINTER(*Where,sizeof(LPWSTR));
    *OutputName = (PKERB_EXTERNAL_NAME) ((PBYTE) LocalName + Offset);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPutKdcNameAsString
//
//  Synopsis:   Copies a KERB_INTERNAL_NAME into a buffer
//
//  Effects:
//
//  Arguments:  InputString - String to 'put'
//              OutputString - Receives 'put' string
//              Offset - Difference in addresses of local and client buffers.
//              Where - Location in local buffer to place string.
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutKdcNameAsWOWString.  Make sure any
//              changes made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
KerbPutKdcNameAsString(
    IN PKERB_INTERNAL_NAME InputName,
    OUT PUNICODE_STRING OutputName,
    IN LONG_PTR Offset,
    IN OUT PBYTE * Where
    )
{
    USHORT Index;

    OutputName->Buffer = (LPWSTR) (*Where + Offset);
    OutputName->Length = 0;
    OutputName->MaximumLength = 0;

    for (Index = 0; Index < InputName->NameCount ; Index++ )
    {
        RtlCopyMemory(
            *Where,
            InputName->Names[Index].Buffer,
            InputName->Names[Index].Length
            );
        *Where += InputName->Names[Index].Length;
        OutputName->Length = OutputName->Length + InputName->Names[Index].Length;
        if (Index == (InputName->NameCount - 1))
        {
            *((LPWSTR) *Where) = L'\0';
            OutputName->MaximumLength = OutputName->Length + sizeof(WCHAR);
        }
        else
        {
            *((LPWSTR) *Where) = L'/';
            OutputName->Length += sizeof(WCHAR);
        }
        *Where += sizeof(WCHAR);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPutString
//
//  Synopsis:   Copies a UNICODE_STRING into a buffer
//
//  Effects:
//
//  Arguments:  InputString - String to 'put'
//              OutputString - Receives 'put' string
//              Offset - Difference in addresses of local and client buffers.
//              Where - Location in local buffer to place string.
//
//  Requires:
//
//  Returns:
//
//  Notes:      This code is (effectively) duplicated in
//              KerbPutWOWString.  Make sure any changes
//              made here are applied there as well.
//
//--------------------------------------------------------------------------

VOID
KerbPutString(
    IN PUNICODE_STRING InputString,
    OUT PUNICODE_STRING OutputString,
    IN LONG_PTR Offset,
    IN OUT PBYTE * Where
    )
{
    OutputString->Length = OutputString->MaximumLength = InputString->Length;
    OutputString->Buffer = (LPWSTR) (*Where + Offset);
    RtlCopyMemory(
        *Where,
        InputString->Buffer,
        InputString->Length
        );
    *Where += InputString->Length;
}


//+-------------------------------------------------------------------------
//
//  Function:   ComputeTicketCacheSize
//
//  Synopsis:   Computes the size necessary to store contents of a ticket cache
//
//  Effects:
//
//  Arguments:  TicketCache       cache to compute the size of
//              WowClient         is this a WOW client? (64-bit only)
//              CacheSize         used to append the size of cache
//              CacheEntries      used to append the number of entries
//
//  Requires:
//
//  Returns:    Nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------

void
KerbComputeTicketCacheSize(
    IN KERB_PRIMARY_CREDENTIAL * PrimaryCredentials,
    IN BOOLEAN WowClient,
    IN OUT ULONG * CacheSize,
    IN OUT ULONG * CacheEntries
    )
{
    DsysAssert( CacheSize );
    DsysAssert( CacheEntries );

#if _WIN64
    ULONG CacheEntrySize = WowClient ?
                               (ULONG) sizeof( KERB_TICKET_CACHE_INFO_WOW64 ) :
                               (ULONG) sizeof( KERB_TICKET_CACHE_INFO );
#else
    ULONG CacheEntrySize = sizeof( KERB_TICKET_CACHE_INFO );
    DsysAssert( WowClient == FALSE );
#endif  // _WIN64

    KERB_TICKET_CACHE * TicketCaches[3] = {
        &PrimaryCredentials->AuthenticationTicketCache,
        &PrimaryCredentials->ServerTicketCache,
        &PrimaryCredentials->S4UTicketCache
    };

    if ( *CacheSize == 0 ) {

        *CacheSize = FIELD_OFFSET( KERB_QUERY_TKT_CACHE_RESPONSE, Tickets );
    }

    for ( ULONG i = 0 ; i < 3 ; i++ ) {

        KERB_TICKET_CACHE * TicketCache = TicketCaches[i];

        for ( PLIST_ENTRY ListEntry = TicketCache->CacheEntries.Flink ;
              ListEntry !=  &TicketCache->CacheEntries ;
              ListEntry = ListEntry->Flink ) {

            KERB_TICKET_CACHE_ENTRY * CacheEntry;

            CacheEntry= CONTAINING_RECORD(
                            ListEntry,
                            KERB_TICKET_CACHE_ENTRY,
                            ListEntry.Next
                            );

            DsysAssert( CacheEntry->ServiceName != NULL );

            *CacheEntries += 1;

            *CacheSize += CacheEntrySize +
                         KerbStringNameLength( CacheEntry->ServiceName ) +
                         CacheEntry->DomainName.Length;
        }
    }
}


void
KerbBuildQueryTicketCacheResponse(
    IN KERB_PRIMARY_CREDENTIAL * PrimaryCredentials,
    IN PKERB_QUERY_TKT_CACHE_RESPONSE CacheResponse,
    IN BOOLEAN WowClient,
    IN OUT LONG_PTR * Offset,
    IN OUT PBYTE * Where,
    IN OUT ULONG * Index
    )
{
    DsysAssert( Offset );
    DsysAssert( Where );
    DsysAssert( Index );

#if _WIN64
    PKERB_QUERY_TKT_CACHE_RESPONSE_WOW64 CacheResponseWOW64 = (PKERB_QUERY_TKT_CACHE_RESPONSE_WOW64) CacheResponse;
    ULONG CacheEntrySize = WowClient ?
                               (ULONG) sizeof( KERB_TICKET_CACHE_INFO_WOW64 ) :
                               (ULONG) sizeof( KERB_TICKET_CACHE_INFO );
#else
    ULONG CacheEntrySize = sizeof( KERB_TICKET_CACHE_INFO );
    DsysAssert( WowClient == FALSE );
#endif  // _WIN64

    KERB_TICKET_CACHE * TicketCaches[3] = {
        &PrimaryCredentials->AuthenticationTicketCache,
        &PrimaryCredentials->ServerTicketCache,
        &PrimaryCredentials->S4UTicketCache
    };

    if ( *Where == NULL ) {

        *Where = ( PBYTE )( CacheResponse->Tickets ) + CacheResponse->CountOfTickets * CacheEntrySize;
    }

    for ( ULONG i = 0 ; i < 3 ; i++ ) {

        KERB_TICKET_CACHE * TicketCache = TicketCaches[i];

        for ( PLIST_ENTRY ListEntry = TicketCache->CacheEntries.Flink ;
              ListEntry !=  &TicketCache->CacheEntries ;
              ListEntry = ListEntry->Flink ) {

            KERB_TICKET_CACHE_ENTRY * CacheEntry;

            CacheEntry= CONTAINING_RECORD(
                            ListEntry,
                            KERB_TICKET_CACHE_ENTRY,
                            ListEntry.Next
                            );

#if _WIN64
            if ( !WowClient ) {
#endif  // _WIN64

                CacheResponse->Tickets[*Index].StartTime = CacheEntry->StartTime;
                CacheResponse->Tickets[*Index].EndTime = CacheEntry->EndTime;
                CacheResponse->Tickets[*Index].RenewTime = CacheEntry->RenewUntil;
                CacheResponse->Tickets[*Index].EncryptionType = (LONG) CacheEntry->Ticket.encrypted_part.encryption_type;
                CacheResponse->Tickets[*Index].TicketFlags = CacheEntry->TicketFlags;
                CacheResponse->Tickets[*Index].ServerName.Buffer = (LPWSTR) (*Where + *Offset);
                CacheResponse->Tickets[*Index].ServerName.Length = CacheEntry->ServiceName->Names[0].Length;
                CacheResponse->Tickets[*Index].ServerName.MaximumLength = CacheEntry->ServiceName->Names[0].Length;

                KerbPutString(
                    &CacheEntry->DomainName,
                    &CacheResponse->Tickets[*Index].RealmName,
                    *Offset,
                    Where
                    );

                KerbPutKdcNameAsString(
                    CacheEntry->ServiceName,
                    &CacheResponse->Tickets[*Index].ServerName,
                    *Offset,
                    Where
                    );

#if _WIN64

            }
            else
            {

                CacheResponseWOW64->Tickets[*Index].StartTime = CacheEntry->StartTime;
                CacheResponseWOW64->Tickets[*Index].EndTime = CacheEntry->EndTime;
                CacheResponseWOW64->Tickets[*Index].RenewTime = CacheEntry->RenewUntil;
                CacheResponseWOW64->Tickets[*Index].EncryptionType = ( LONG )CacheEntry->Ticket.encrypted_part.encryption_type;
                CacheResponseWOW64->Tickets[*Index].TicketFlags = CacheEntry->TicketFlags;
                CacheResponseWOW64->Tickets[*Index].ServerName.Buffer = PtrToUlong (*Where + *Offset);
                CacheResponseWOW64->Tickets[*Index].ServerName.Length = CacheEntry->ServiceName->Names[0].Length;
                CacheResponseWOW64->Tickets[*Index].ServerName.MaximumLength = CacheEntry->ServiceName->Names[0].Length;

                KerbPutWOWString(
                    &CacheEntry->DomainName,
                    &CacheResponseWOW64->Tickets[*Index].RealmName,
                    *Offset,
                    Where
                    );

                KerbPutKdcNameAsWOWString(
                    CacheEntry->ServiceName,
                    &CacheResponseWOW64->Tickets[*Index].ServerName,
                    *Offset,
                    Where
                    );
            }

#endif  // _WIN64

            (*Index)++;
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbQueryTicketCache
//
//  Synopsis:   Retrieves the list of tickets for the specified logon session
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbQueryTicketCache(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    PKERB_QUERY_TKT_CACHE_REQUEST CacheRequest = ( PKERB_QUERY_TKT_CACHE_REQUEST )ProtocolSubmitBuffer;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_QUERY_TKT_CACHE_RESPONSE CacheResponse = NULL;
    PKERB_QUERY_TKT_CACHE_RESPONSE ClientCacheResponse = NULL;
    ULONG CacheSize = 0;
    ULONG CacheEntries = 0;
    BOOLEAN LockHeld = FALSE;
    LONG_PTR Offset;
    PBYTE Where = NULL;
    ULONG Index = 0;

    //
    // Verify the request.
    //

    if ( SubmitBufferLength < sizeof( KERB_QUERY_TKT_CACHE_REQUEST )) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Find the caller's logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( RtlIsZeroLuid( &CacheRequest->LogonId )) {

        LogonId = &ClientInfo.LogonId;

    } else if ( !ClientInfo.HasTcbPrivilege ) {

        //
        // Caller must have TCB privilege in order to access to someone
        // else's ticket cache.
        //

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;

    } else {

        LogonId = &CacheRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                       LogonId,
                       FALSE               // don't unlink
                       );

    if ( LogonSession == NULL ) {

        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    if( !LsaFunctions->GetCallInfo( &CallInfo )) {

        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

#endif  // _WIN64

    //
    // Prowl through the caches and find all the tickets
    //

    DsysAssert( !LockHeld );
    KerbReadLockLogonSessions(LogonSession);
    KerbReadLockTicketCache();
    LockHeld = TRUE;

    //
    // Calculate the size needed for all the ticket information
    //

    KerbComputeTicketCacheSize(
        &LogonSession->PrimaryCredentials,
#if _WIN64
        (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0 ),
#else
        FALSE,
#endif
        &CacheSize,
        &CacheEntries
        );

    //
    // Now allocate two copies of the structure - one in our process, one in
    // the client's process.  We then build the structure in our process but
    // with pointer valid in the client's process.
    //

    SafeAllocaAllocate(CacheResponse, CacheSize);

    if ( CacheResponse == NULL )
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = LsaFunctions->AllocateClientBuffer(
                 NULL,
                 CacheSize,
                 ( PVOID * )&ClientCacheResponse
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    Offset = ( LONG_PTR )(( PBYTE )ClientCacheResponse - ( PBYTE )CacheResponse );

    //
    // Build up the return structure
    //

    CacheResponse->MessageType = KerbQueryTicketCacheMessage;
    CacheResponse->CountOfTickets = CacheEntries;

    KerbBuildQueryTicketCacheResponse(
        &LogonSession->PrimaryCredentials,
        CacheResponse,
#if _WIN64
        (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0 ),
#else
        FALSE,
#endif
        &Offset,
        &Where,
        &Index
        );

    //
    // Copy the structure to the client's address space
    //

    Status = LsaFunctions->CopyToClientBuffer(
                 NULL,
                 CacheSize,
                 ClientCacheResponse,
                 CacheResponse
                 );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *ProtocolReturnBuffer = ClientCacheResponse;
    ClientCacheResponse = NULL;
    *ReturnBufferLength = CacheSize;

Cleanup:

    if (LockHeld)
    {
        KerbUnlockTicketCache();
        KerbUnlockLogonSessions( LogonSession );
    }

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession( LogonSession );
    }

    SafeAllocaFree(CacheResponse);

    if (ClientCacheResponse != NULL)
    {
        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientCacheResponse
            );
    }

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   ComputeTicketCacheSizeEx
//
//  Synopsis:   Computes the size necessary to store contents of a ticket cache
//
//  Effects:
//
//  Arguments:  TicketCache       cache to compute the size of
//              WowClient         is this a WOW client (64-bit only)
//              CacheSize         used to append the size of cache
//              CacheEntries      used to append the number of entries
//
//  Requires:
//
//  Returns:    Nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------

void
KerbComputeTicketCacheSizeEx(
    IN KERB_PRIMARY_CREDENTIAL * PrimaryCredentials,
    IN BOOLEAN WowClient,
    IN OUT ULONG * CacheSize,
    IN OUT ULONG * CacheEntries
    )
{
    DsysAssert( CacheSize );
    DsysAssert( CacheEntries );

#if _WIN64
    ULONG CacheEntrySize = WowClient ?
                               (ULONG) sizeof( KERB_TICKET_CACHE_INFO_EX_WOW64 ) :
                               (ULONG) sizeof( KERB_TICKET_CACHE_INFO_EX );
#else
    ULONG CacheEntrySize = sizeof( KERB_TICKET_CACHE_INFO_EX );
    DsysAssert( WowClient == FALSE );
#endif  // _WIN64

    KERB_TICKET_CACHE * TicketCaches[3] = {
        &PrimaryCredentials->AuthenticationTicketCache,
        &PrimaryCredentials->ServerTicketCache,
        &PrimaryCredentials->S4UTicketCache
    };

    if ( *CacheSize == 0 ) {

        *CacheSize = FIELD_OFFSET( KERB_QUERY_TKT_CACHE_EX_RESPONSE, Tickets );
    }

    for ( ULONG i = 0 ; i < 3 ; i++ ) {

        KERB_TICKET_CACHE * TicketCache = TicketCaches[i];

        for ( PLIST_ENTRY ListEntry = TicketCache->CacheEntries.Flink ;
              ListEntry !=  &TicketCache->CacheEntries ;
              ListEntry = ListEntry->Flink ) {

            KERB_TICKET_CACHE_ENTRY * CacheEntry;

            CacheEntry= CONTAINING_RECORD(
                            ListEntry,
                            KERB_TICKET_CACHE_ENTRY,
                            ListEntry.Next
                            );

            DsysAssert( CacheEntry->ServiceName != NULL );

            *CacheEntries += 1;

            *CacheSize += CacheEntrySize +
                         // client name
                         PrimaryCredentials->UserName.Length +
                         // client realm
                         PrimaryCredentials->DomainName.Length +
                         // server name
                         KerbStringNameLength( CacheEntry->ServiceName ) +
                         // server realm
                         CacheEntry->DomainName.Length;
        }
    }
}


void
KerbBuildQueryTicketCacheResponseEx(
    IN KERB_PRIMARY_CREDENTIAL * PrimaryCredentials,
    IN PKERB_QUERY_TKT_CACHE_EX_RESPONSE CacheResponse,
    IN BOOLEAN WowClient,
    IN OUT LONG_PTR * Offset,
    IN OUT PBYTE * Where,
    IN OUT ULONG * Index
    )
{
    DsysAssert( Offset );
    DsysAssert( Where );
    DsysAssert( Index );

#if _WIN64
    PKERB_QUERY_TKT_CACHE_EX_RESPONSE_WOW64 CacheResponseWOW64 = (PKERB_QUERY_TKT_CACHE_EX_RESPONSE_WOW64) CacheResponse;
    ULONG CacheEntrySize = WowClient ?
                               (ULONG) sizeof( KERB_TICKET_CACHE_INFO_EX_WOW64 ) :
                               (ULONG) sizeof( KERB_TICKET_CACHE_INFO_EX );
#else
    ULONG CacheEntrySize = sizeof( KERB_TICKET_CACHE_INFO_EX );
    DsysAssert( WowClient == FALSE );
#endif  // _WIN64

    KERB_TICKET_CACHE * TicketCaches[3] = {
        &PrimaryCredentials->AuthenticationTicketCache,
        &PrimaryCredentials->ServerTicketCache,
        &PrimaryCredentials->S4UTicketCache
    };

    if ( *Where == NULL ) {

        *Where = ( PBYTE )( CacheResponse->Tickets ) + CacheResponse->CountOfTickets * CacheEntrySize;
    }

    for ( ULONG i = 0 ; i < 3 ; i++ ) {

        KERB_TICKET_CACHE * TicketCache = TicketCaches[i];

        for ( PLIST_ENTRY ListEntry = TicketCache->CacheEntries.Flink ;
              ListEntry !=  &TicketCache->CacheEntries ;
              ListEntry = ListEntry->Flink ) {

            KERB_TICKET_CACHE_ENTRY * CacheEntry;

            CacheEntry= CONTAINING_RECORD(
                            ListEntry,
                            KERB_TICKET_CACHE_ENTRY,
                            ListEntry.Next
                            );

#if _WIN64
            if ( !WowClient ) {
#endif  // _WIN64

                CacheResponse->Tickets[*Index].StartTime = CacheEntry->StartTime;
                CacheResponse->Tickets[*Index].EndTime = CacheEntry->EndTime;
                CacheResponse->Tickets[*Index].RenewTime = CacheEntry->RenewUntil;
                CacheResponse->Tickets[*Index].EncryptionType = ( LONG )CacheEntry->Ticket.encrypted_part.encryption_type;
                CacheResponse->Tickets[*Index].TicketFlags = CacheEntry->TicketFlags;

                KerbPutString(
                    &PrimaryCredentials->UserName,
                    &CacheResponse->Tickets[*Index].ClientName,
                    *Offset,
                    Where
                    );

                KerbPutString(
                    &PrimaryCredentials->DomainName,
                    &CacheResponse->Tickets[*Index].ClientRealm,
                    *Offset,
                    Where
                    );

                KerbPutKdcNameAsString(
                    CacheEntry->ServiceName,
                    &CacheResponse->Tickets[*Index].ServerName,
                    *Offset,
                    Where
                    );

                KerbPutString(
                    &CacheEntry->DomainName,
                    &CacheResponse->Tickets[*Index].ServerRealm,
                    *Offset,
                    Where
                    );

#if _WIN64

            } else {

                CacheResponseWOW64->Tickets[*Index].StartTime = CacheEntry->StartTime;
                CacheResponseWOW64->Tickets[*Index].EndTime = CacheEntry->EndTime;
                CacheResponseWOW64->Tickets[*Index].RenewTime = CacheEntry->RenewUntil;
                CacheResponseWOW64->Tickets[*Index].EncryptionType = ( LONG )CacheEntry->Ticket.encrypted_part.encryption_type;
                CacheResponseWOW64->Tickets[*Index].TicketFlags = CacheEntry->TicketFlags;

                KerbPutWOWString(
                    &PrimaryCredentials->UserName,
                    &CacheResponseWOW64->Tickets[*Index].ClientName,
                    *Offset,
                    Where
                    );

                KerbPutWOWString(
                    &PrimaryCredentials->DomainName,
                    &CacheResponseWOW64->Tickets[*Index].ClientRealm,
                    *Offset,
                    Where
                    );

                KerbPutKdcNameAsWOWString(
                    CacheEntry->ServiceName,
                    &CacheResponseWOW64->Tickets[*Index].ServerName,
                    *Offset,
                    Where
                    );

                KerbPutWOWString(
                    &CacheEntry->DomainName,
                    &CacheResponseWOW64->Tickets[*Index].ServerRealm,
                    *Offset,
                    Where
                    );
            }

#endif  // _WIN64

            (*Index)++;
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAddExtraCredential
//
//  Synopsis:   Retrieves the list of tickets for the specified logon session
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbAddExtraCredential(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{

    NTSTATUS Status;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    PKERB_ADD_CREDENTIALS_REQUEST AddCredRequest = (PKERB_ADD_CREDENTIALS_REQUEST) ProtocolSubmitBuffer;
    PKERB_LOGON_SESSION LogonSession = NULL;

    if (ARGUMENT_PRESENT( ReturnBufferLength ))
    {
        *ReturnBufferLength = 0;
    }

    if (ARGUMENT_PRESENT( ProtocolReturnBuffer ))
    {
        *ProtocolReturnBuffer = NULL;
    }

    if ( SubmitBufferSize < sizeof( KERB_ADD_CREDENTIALS_REQUEST ))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    if( !LsaFunctions->GetCallInfo( &CallInfo ))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0)
    {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

#endif // _WIN64

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if ( !NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( RtlIsZeroLuid( &AddCredRequest->LogonId ))
    {
        LogonId = &ClientInfo.LogonId;
    }
    else if ( !ClientInfo.HasTcbPrivilege )
    {
        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;
    }
    else
    {
        LogonId = &AddCredRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                       LogonId,
                       FALSE
                       );

    if ( LogonSession == NULL )
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    NULL_RELOCATE_ONE( &AddCredRequest->DomainName );
    NULL_RELOCATE_ONE( &AddCredRequest->Password );
    NULL_RELOCATE_ONE( &AddCredRequest->UserName );

    //
    // We will default nothing for this request.
    //
    if (( AddCredRequest->DomainName.Length == 0 ) ||
        ( AddCredRequest->UserName.Length == 0 ))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (((AddCredRequest->Flags & (KERB_REQUEST_ADD_CREDENTIAL | KERB_REQUEST_REPLACE_CREDENTIAL )) != 0) &&
         ( AddCredRequest->Password.Length == 0 ))

    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    Status = KerbAddExtraCredentialsToLogonSession(
                    LogonSession,
                    AddCredRequest
                    );

    if (!NT_SUCCESS( Status ))
    {
        D_DebugLog((DEB_ERROR, "KerbAddExtraCredentialToLogonSession failed %x\n", Status));
        goto Cleanup;
    }


Cleanup:

    if ( LogonSession != NULL )
    {
        KerbDereferenceLogonSession( LogonSession );
    }
    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}      




//+-------------------------------------------------------------------------
//
//  Function:   KerbQueryTicketCacheEx
//
//  Synopsis:   Retrieves the list of tickets for the specified logon session
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbQueryTicketCacheEx(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    PKERB_QUERY_TKT_CACHE_REQUEST CacheRequest = ( PKERB_QUERY_TKT_CACHE_REQUEST )ProtocolSubmitBuffer;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_QUERY_TKT_CACHE_EX_RESPONSE CacheResponse = NULL;
    PKERB_QUERY_TKT_CACHE_EX_RESPONSE ClientCacheResponse = NULL;
    ULONG CacheSize = 0;
    ULONG CacheEntries = 0;
    BOOLEAN TicketCacheLocked = FALSE;
    BOOLEAN CredmanLocked = FALSE;
    PLIST_ENTRY ListEntry;
    LONG_PTR Offset;
    PBYTE Where = NULL;
    ULONG Index = 0;

    //
    // Verify the request.
    //

    if ( SubmitBufferLength < sizeof( KERB_QUERY_TKT_CACHE_REQUEST )) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Find the caller's logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( RtlIsZeroLuid( &CacheRequest->LogonId )) {

        LogonId = &ClientInfo.LogonId;

    } else if ( !ClientInfo.HasTcbPrivilege ) {

        //
        // Caller must have TCB privilege in order to access to someone
        // else's ticket cache.
        //

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;

    } else {

        LogonId = &CacheRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                       LogonId,
                       FALSE
                       );

    if ( LogonSession == NULL ) {

        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    if( !LsaFunctions->GetCallInfo( &CallInfo )) {

        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

#endif // _WIN64

    //
    // Prowl through the caches and find all the tickets
    //

    DsysAssert( !TicketCacheLocked );
    KerbReadLockLogonSessions( LogonSession );

    KerbLockList( &LogonSession->CredmanCredentials );
    CredmanLocked = TRUE;

    KerbReadLockTicketCache();
    TicketCacheLocked = TRUE;

    //
    // Calculate the size needed for all the ticket information
    //

    KerbComputeTicketCacheSizeEx(
        &LogonSession->PrimaryCredentials,
#if _WIN64
        (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0 ),
#else
        FALSE,
#endif
        &CacheSize,
        &CacheEntries
        );

    for ( ListEntry = LogonSession->CredmanCredentials.List.Flink;
          ListEntry != &LogonSession->CredmanCredentials.List;
          ListEntry = ListEntry->Flink ) {

        PKERB_CREDMAN_CRED CredmanCred = CONTAINING_RECORD(
                                            ListEntry,
                                            KERB_CREDMAN_CRED,
                                            ListEntry.Next
                                            );

        if ( CredmanCred->SuppliedCredentials == NULL ) {

            continue;
        }

        KerbComputeTicketCacheSizeEx(
            CredmanCred->SuppliedCredentials,
#if _WIN64
            (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0 ),
#else
            FALSE,
#endif
            &CacheSize,
            &CacheEntries
            );
    }

    //
    // Now allocate two copies of the structure - one in our process, one in
    // the client's process.  We then build the structure in our process but
    // with pointer valid in the client's process.
    //

    SafeAllocaAllocate(CacheResponse, CacheSize);

    if ( CacheResponse == NULL )
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = LsaFunctions->AllocateClientBuffer(
                 NULL,
                 CacheSize,
                 ( PVOID * )&ClientCacheResponse
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    Offset = ( LONG_PTR )(( PBYTE )ClientCacheResponse - ( PBYTE )CacheResponse );

    //
    // Build up the return structure
    //

    CacheResponse->MessageType = KerbQueryTicketCacheExMessage;
    CacheResponse->CountOfTickets = CacheEntries;

    KerbBuildQueryTicketCacheResponseEx(
        &LogonSession->PrimaryCredentials,
        CacheResponse,
#if _WIN64
        (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0 ),
#else
        FALSE,
#endif
        &Offset,
        &Where,
        &Index
        );

    for ( ListEntry = LogonSession->CredmanCredentials.List.Flink;
          ListEntry != &LogonSession->CredmanCredentials.List;
          ListEntry = ListEntry->Flink ) {

        PKERB_CREDMAN_CRED CredmanCred = CONTAINING_RECORD(
                                            ListEntry,
                                            KERB_CREDMAN_CRED,
                                            ListEntry.Next
                                            );

        if ( CredmanCred->SuppliedCredentials == NULL ) {

            continue;
        }

        KerbBuildQueryTicketCacheResponseEx(
            CredmanCred->SuppliedCredentials,
            CacheResponse,
#if _WIN64
            (( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) != 0 ),
#else
            FALSE,
#endif
            &Offset,
            &Where,
            &Index
            );
    }

    //
    // Copy the structure to the client's address space
    //

    Status = LsaFunctions->CopyToClientBuffer(
                 NULL,
                 CacheSize,
                 ClientCacheResponse,
                 CacheResponse
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    *ProtocolReturnBuffer = ClientCacheResponse;
    ClientCacheResponse = NULL;
    *ReturnBufferLength = CacheSize;

Cleanup:

    if ( CredmanLocked ) {

        KerbUnlockList( &LogonSession->CredmanCredentials );
    }

    if ( TicketCacheLocked ) {

        KerbUnlockTicketCache();
        KerbUnlockLogonSessions( LogonSession );
    }

    if ( LogonSession != NULL ) {

        KerbDereferenceLogonSession( LogonSession );
    }

    SafeAllocaFree( CacheResponse );

    if ( ClientCacheResponse != NULL ) {

        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientCacheResponse
            );
    }

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPackExternalTicket
//
//  Synopsis:   Marshalls a ticket cache entry for return to the caller
//
//  Effects:    Allocates memory in client's address space
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbPackExternalTicket(
    IN PKERB_TICKET_CACHE_ENTRY CacheEntry,
    IN BOOL RetrieveTicketAsKerbCred,
    IN BOOL AllowTgtSessionKey,
    OUT PULONG ClientTicketSize,
    OUT PUCHAR * ClientTicket
    )
{
    ULONG TicketSize = 0;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_EXTERNAL_TICKET TicketResponse = NULL;
    PBYTE ClientTicketResponse = NULL;
    KERB_MESSAGE_BUFFER EncodedTicket = {0};
    LONG_PTR Offset;
    PBYTE Where;
    BOOL fTicketOnStack = FALSE;
    KERB_TICKET_CACHE_ENTRY CacheEntryT;

    *ClientTicket = NULL;
    *ClientTicketSize = 0;

#if _WIN64

    SECPKG_CALL_INFO  CallInfo;

    //
    // Return a 32-bit external ticket if this is a WOW caller
    //

    if(!LsaFunctions->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

#endif  // _WIN64

    //
    // 448010: do not fess up the session key for primary TGTs unless
    //         the caller is trusted or policy is set appropriately
    //
    if (( CacheEntry->ServiceName->NameCount == 2 ) &&
        ( !AllowTgtSessionKey ) && 
        ( RtlEqualUnicodeString( 
              &CacheEntry->ServiceName->Names[0], 
              &KerbGlobalKdcServiceName, 
              TRUE
              )))
    {
        D_DebugLog((DEB_ERROR, "Zeroing out session key\n"));
        CacheEntryT = *CacheEntry;
        RtlZeroMemory( &CacheEntryT.SessionKey, sizeof( KERB_ENCRYPTION_KEY ));
        CacheEntry = &CacheEntryT;
    }

    //
    // Encode the ticket
    //

    if ( RetrieveTicketAsKerbCred )
    {
        Status = KerbBuildKerbCred(
                     NULL,         // service ticket
                     CacheEntry,
                     &EncodedTicket.Buffer,
                     &EncodedTicket.BufferSize
                     );

        if ( !NT_SUCCESS( Status ))
        {
            goto Cleanup;
        }
    }
    else
    {
        KERBERR KerbErr;

        KerbErr = KerbPackData(
                    &CacheEntry->Ticket,
                    KERB_TICKET_PDU,
                    &EncodedTicket.BufferSize,
                    &EncodedTicket.Buffer
                    );

        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }
    }

    //
    // NOTE:  The 64-bit code below is (effectively) duplicated in
    //        the WOW helper routine.  If modifying one, make sure
    //        to apply the change(s) to the other as well.
    //

#if _WIN64

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        Status = KerbPackExternalWOWTicket(CacheEntry,
                                           &EncodedTicket,
                                           &TicketResponse,
                                           &ClientTicketResponse,
                                           &TicketSize);

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
    else
    {

#endif  // _WIN64

        TicketSize = sizeof(KERB_EXTERNAL_TICKET) +
                        CacheEntry->DomainName.Length +
                        CacheEntry->TargetDomainName.Length +
                        CacheEntry->ClientDomainName.Length +
                        CacheEntry->SessionKey.keyvalue.length +
                        KerbNameLength(CacheEntry->ServiceName) +
                        KerbNameLength(CacheEntry->TargetName) +
                        KerbNameLength(CacheEntry->ClientName) +
                        EncodedTicket.BufferSize
                        ;

        //
        // Now allocate two copies of the structure - one in our process,
        // one in the client's process. We then build the structure in our
        // process but with pointer valid in the client's process
        //

        SafeAllocaAllocate(TicketResponse, TicketSize);
        fTicketOnStack = TRUE;

        if (TicketResponse == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        Status = LsaFunctions->AllocateClientBuffer(
                    NULL,
                    TicketSize,
                    (PVOID *) &ClientTicketResponse
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        Offset = (LONG_PTR) (ClientTicketResponse - (PBYTE) TicketResponse);

        Where = ((PUCHAR) (TicketResponse + 1));

        //
        // Copy the non-pointer fields
        //

        TicketResponse->TicketFlags = CacheEntry->TicketFlags;
        TicketResponse->Flags = 0;
        TicketResponse->KeyExpirationTime.QuadPart = 0;
        TicketResponse->StartTime = CacheEntry->StartTime;
        TicketResponse->EndTime = CacheEntry->EndTime;
        TicketResponse->RenewUntil = CacheEntry->RenewUntil;
        TicketResponse->TimeSkew = CacheEntry->TimeSkew;
        TicketResponse->SessionKey.KeyType = CacheEntry->SessionKey.keytype;


        //
        // Copy the structure to the client's address space
        //

        //
        // These are PVOID aligned
        //

        //
        // Make sure the two name types are the same
        //

        DsysAssert(sizeof(KERB_INTERNAL_NAME) == sizeof(KERB_EXTERNAL_NAME));
        DsysAssert(FIELD_OFFSET(KERB_INTERNAL_NAME,NameType) == FIELD_OFFSET(KERB_EXTERNAL_NAME,NameType));
        DsysAssert(FIELD_OFFSET(KERB_INTERNAL_NAME,NameCount) == FIELD_OFFSET(KERB_EXTERNAL_NAME,NameCount));
        DsysAssert(FIELD_OFFSET(KERB_INTERNAL_NAME,Names) == FIELD_OFFSET(KERB_EXTERNAL_NAME,Names));

        KerbPutKdcName(
            CacheEntry->ServiceName,
            &TicketResponse->ServiceName,
            Offset,
            &Where
            );

        KerbPutKdcName(
            CacheEntry->TargetName,
            &TicketResponse->TargetName,
            Offset,
            &Where
            );

        KerbPutKdcName(
            CacheEntry->ClientName,
            &TicketResponse->ClientName,
            Offset,
            &Where
            );


        //
        // From here on, they are WCHAR aligned
        //

        KerbPutString(
            &CacheEntry->DomainName,
            &TicketResponse->DomainName,
            Offset,
            &Where
            );

        KerbPutString(
            &CacheEntry->TargetDomainName,
            &TicketResponse->TargetDomainName,
            Offset,
            &Where
            );

        KerbPutString(
            &CacheEntry->ClientDomainName,
            &TicketResponse->AltTargetDomainName,       // ClientDomainName
            Offset,
            &Where
            );


        //
        // And from here they are BYTE aligned
        //

        TicketResponse->SessionKey.Value = (PBYTE) (Where + Offset);
        RtlCopyMemory(
            Where,
            CacheEntry->SessionKey.keyvalue.value,
            CacheEntry->SessionKey.keyvalue.length
            );
        Where += CacheEntry->SessionKey.keyvalue.length;

        TicketResponse->SessionKey.Length = CacheEntry->SessionKey.keyvalue.length;

        TicketResponse->EncodedTicketSize = EncodedTicket.BufferSize;
        TicketResponse->EncodedTicket = Where + Offset;

        RtlCopyMemory(
            Where,
            EncodedTicket.Buffer,
            EncodedTicket.BufferSize
            );

        Where += EncodedTicket.BufferSize;

        DsysAssert(Where - ((PUCHAR) TicketResponse) == (LONG_PTR) TicketSize);

#if _WIN64

    }

#endif  // _WIN64

    //
    // Copy the mess to the client
    //


    Status = LsaFunctions->CopyToClientBuffer(
                NULL,
                TicketSize,
                ClientTicketResponse,
                TicketResponse
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *ClientTicket = ClientTicketResponse;
    *ClientTicketSize = TicketSize;

    ClientTicketResponse = NULL;

Cleanup:

    if (EncodedTicket.Buffer != NULL)
    {
        MIDL_user_free(EncodedTicket.Buffer);
    }

    if (ClientTicketResponse != NULL)
    {
        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientTicketResponse
            );
    }

    if (fTicketOnStack)
    {
        SafeAllocaFree(TicketResponse);
    }
    else
    {
        KerbFree(TicketResponse);
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbRetrieveTicket
//
//  Synopsis:   Retrieves the initial ticket cache entry.
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbRetrieveTicket(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_QUERY_TKT_CACHE_REQUEST CacheRequest;
    PBYTE ClientTicketResponse = NULL;
    PKERB_TICKET_CACHE_ENTRY CacheEntry = NULL;
    ULONG TicketSize = 0;

    //
    // Verify the request.
    //
    if (SubmitBufferLength < sizeof(KERB_QUERY_TKT_CACHE_REQUEST))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    CacheRequest = (PKERB_QUERY_TKT_CACHE_REQUEST) ProtocolSubmitBuffer;


    //
    // Find the callers logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( RtlIsZeroLuid( &CacheRequest->LogonId ) )
    {
        LogonId = &ClientInfo.LogonId;
    }
    else
    {
        //
        // Verify the caller has TCB privilege if they want access to someone
        // elses ticket cache.
        //

        if (!ClientInfo.HasTcbPrivilege)
        {
            Status = STATUS_PRIVILEGE_NOT_HELD;
            goto Cleanup;
        }

        LogonId = &CacheRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                    LogonId,
                    FALSE               // don't unlink
                    );

    if (LogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Now find the TGT from the authentication ticket cache.
    //

    KerbReadLockLogonSessions(LogonSession);

    CacheEntry = KerbLocateTicketCacheEntryByRealm(
                    &LogonSession->PrimaryCredentials.AuthenticationTicketCache,
                    NULL,               // get initial ticket
                    KERB_TICKET_CACHE_PRIMARY_TGT
                    );

    KerbUnlockLogonSessions(LogonSession);

    if (CacheEntry == NULL)
    {
        Status = SEC_E_NO_CREDENTIALS;
        goto Cleanup;
    }

    KerbReadLockTicketCache();

    Status = KerbPackExternalTicket(
                CacheEntry,
                FALSE,
                ( ClientInfo.HasTcbPrivilege || KerbGlobalAllowTgtSessionKey ),
                &TicketSize,
                &ClientTicketResponse
                );

    KerbUnlockTicketCache();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    *ProtocolReturnBuffer = ClientTicketResponse;
    ClientTicketResponse = NULL;
    *ReturnBufferLength = TicketSize;

Cleanup:
    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }
    if (CacheEntry != NULL)
    {
        KerbDereferenceTicketCacheEntry(CacheEntry);
    }
    if (ClientTicketResponse != NULL)
    {
        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientTicketResponse
            );
    }

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbSetIpAddresses
//
//  Synopsis:   Saves the IP addresses passed in by netlogon
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbSetIpAddresses(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    PKERB_UPDATE_ADDRESSES_REQUEST UpdateRequest;

    //
    // This can only be called internally.
    //

    if (ClientRequest != NULL)
    {
        DebugLog((DEB_ERROR,"Can't update addresses from outside process. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_ACCESS_DENIED;
        goto Cleanup;
    }

    //
    // Verify the request.
    //

    if (SubmitBufferLength < FIELD_OFFSET(KERB_UPDATE_ADDRESSES_REQUEST, Addresses))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    UpdateRequest = (PKERB_UPDATE_ADDRESSES_REQUEST) ProtocolSubmitBuffer;

    //
    // Validate the input
    //


    if (SubmitBufferLength < (sizeof(KERB_UPDATE_ADDRESSES_REQUEST)
                                + UpdateRequest->AddressCount * (sizeof(SOCKET_ADDRESS) + sizeof(struct sockaddr_in))
                                - ANYSIZE_ARRAY * sizeof(ULONG)))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    Status= KerbUpdateGlobalAddresses(
                (PSOCKET_ADDRESS) UpdateRequest->Addresses,
                UpdateRequest->AddressCount
                );


    //
    // Copy them into the global for others to use
    //


Cleanup:

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifyPac
//
//  Synopsis:   Verifies that a PAC was signed by a valid KDC
//
//  Effects:
//
//  Arguments:  Same as for LsaApCallAuthenticationPackage. The submit
//              buffer must contain a KERB_VERIFY_PAC_REQUEST message.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS. The real error is in the protocol status.
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbVerifyPac(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    PKERB_VERIFY_PAC_REQUEST VerifyRequest;
    DWORD MaxBufferSize, TotalBufferSize;

    if (ARGUMENT_PRESENT(ProtocolReturnBuffer))
    {
        *ProtocolReturnBuffer = NULL;
    }
    if (ARGUMENT_PRESENT(ReturnBufferLength))
    {
        *ReturnBufferLength = 0;
    }
    if (SubmitBufferLength < sizeof(KERB_VERIFY_PAC_REQUEST)) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (!KerbGlobalInitialized)
    {
        Status = STATUS_SUCCESS;
        DsysAssert(FALSE);
        goto Cleanup;
    }

    VerifyRequest = (PKERB_VERIFY_PAC_REQUEST) ProtocolSubmitBuffer;

    MaxBufferSize = SubmitBufferLength -
                    FIELD_OFFSET(KERB_VERIFY_PAC_REQUEST, ChecksumAndSignature);     

    TotalBufferSize = VerifyRequest->ChecksumLength + VerifyRequest->SignatureLength;


    if (( VerifyRequest->ChecksumLength > MaxBufferSize ) ||
        ( VerifyRequest->SignatureLength > MaxBufferSize ) ||
        ( TotalBufferSize > MaxBufferSize ))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Make sure we actually have valid data in the rest of the submit buffer.
    //
    if (SubmitBufferLength < TotalBufferSize + FIELD_OFFSET(KERB_VERIFY_PAC_REQUEST, ChecksumAndSignature))
    {
        DsysAssert(FALSE);
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    if (KerbKdcHandle == NULL)
    {
        Status = STATUS_MUST_BE_KDC;
        goto Cleanup;
    }

    DsysAssert(KerbKdcVerifyPac != NULL);

    Status = (*KerbKdcVerifyPac)(
                    VerifyRequest->ChecksumLength,
                    VerifyRequest->ChecksumAndSignature,
                    VerifyRequest->SignatureType,
                    VerifyRequest->SignatureLength,
                    VerifyRequest->ChecksumAndSignature + VerifyRequest->ChecksumLength
                    );
Cleanup:
    *ProtocolStatus = Status;

    return(STATUS_SUCCESS);
}


NTSTATUS
KerbPurgePrimaryCredentialsTickets(
    IN KERB_PRIMARY_CREDENTIAL * PrimaryCredentials,
    IN OPTIONAL PUNICODE_STRING ServerName,
    IN OPTIONAL PUNICODE_STRING ServerRealm
    )
{
    NTSTATUS Status;

    DsysAssert( PrimaryCredentials );

    if ( ServerName == NULL && ServerRealm == NULL ) {

        Status = STATUS_SUCCESS;

        KerbPurgeTicketCache( &PrimaryCredentials->AuthenticationTicketCache );
        KerbPurgeTicketCache( &PrimaryCredentials->ServerTicketCache );
        KerbPurgeTicketCache( &PrimaryCredentials->S4UTicketCache );


    } else if ( ServerName != NULL && ServerRealm != NULL ) {

        KERB_TICKET_CACHE * TicketCaches[3] = {
            &PrimaryCredentials->AuthenticationTicketCache,
            &PrimaryCredentials->ServerTicketCache,
            &PrimaryCredentials->S4UTicketCache
        };

        //
        // Prowl through the caches and remove all the matching tickets
        //

        Status = STATUS_OBJECT_NAME_NOT_FOUND;

        KerbWriteLockTicketCache();

        for ( ULONG i = 0 ; i < 3 ; i++ ) {

            KERB_TICKET_CACHE * TicketCache = TicketCaches[i];

            for ( PLIST_ENTRY ListEntry = TicketCache->CacheEntries.Flink ;
                  ListEntry !=  &TicketCache->CacheEntries ;
                  ListEntry = ListEntry->Flink ) {

                KERB_TICKET_CACHE_ENTRY * CacheEntry;
                UNICODE_STRING SearchName = {0};

                CacheEntry= CONTAINING_RECORD(
                                ListEntry,
                                KERB_TICKET_CACHE_ENTRY,
                                ListEntry.Next
                                );

                if ( !KERB_SUCCESS( KerbConvertKdcNameToString(
                                        &SearchName,
                                        CacheEntry->ServiceName,
                                        NULL ))) { // no realm

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    KerbUnlockTicketCache();
                    goto Cleanup;
                }

                //
                // Check to see if the server & realm name matches
                //

                if ( RtlEqualUnicodeString(
                         &SearchName,
                         ServerName,
                         TRUE ) &&
                     RtlEqualUnicodeString(
                         &CacheEntry->DomainName,
                         ServerRealm,
                         TRUE )) {

                    D_DebugLog((DEB_TRACE,"Purging a ticket!\n"));

                    Status = STATUS_SUCCESS;

                    //
                    // Move back one entry so that Remove() does not
                    // trash the iteration
                    //

                    ListEntry = ListEntry->Blink;

                    KerbRemoveTicketCacheEntry( CacheEntry );
                }

                KerbFreeString(&SearchName);
            }
        }

        KerbUnlockTicketCache();

    } else {

        //
        // ServerName and ServerRealm need to be either both specified or
        // both NULL.  Getting here means that only one of them is NULL,
        // and the assert below will specify which one it is.
        //

        DsysAssert( ServerName != NULL );
        DsysAssert( ServerRealm != NULL );

        Status = STATUS_SUCCESS;
    }

Cleanup:

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPurgeTicket
//
//  Synopsis:   Removes ticket from the ticket cache
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbPurgeTicket(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    ULONG StructureSize = sizeof( KERB_PURGE_TKT_CACHE_REQUEST );
    PKERB_PURGE_TKT_CACHE_REQUEST PurgeRequest  = ( PKERB_PURGE_TKT_CACHE_REQUEST )ProtocolSubmitBuffer;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;

    //
    // Verify the request.
    //

    D_DebugLog((DEB_TRACE, "Purging ticket cache\n"));


    //
    // Any purging will also tag SPN cache for purge
    //
    


#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    if(!LsaFunctions->GetCallInfo(&CallInfo))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        StructureSize = sizeof( KERB_PURGE_TKT_CACHE_REQUEST_WOW64 );
    }

#endif  // _WIN64

    if (SubmitBufferSize < StructureSize)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

#if _WIN64

    KERB_PURGE_TKT_CACHE_REQUEST LocalPurgeRequest;

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        //
        // Thunk 32-bit pointers if this is a WOW caller
        //

        PKERB_PURGE_TKT_CACHE_REQUEST_WOW64 PurgeRequestWOW =
            ( PKERB_PURGE_TKT_CACHE_REQUEST_WOW64 )PurgeRequest;

        LocalPurgeRequest.MessageType = PurgeRequestWOW->MessageType;
        LocalPurgeRequest.LogonId     = PurgeRequestWOW->LogonId;

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalPurgeRequest.ServerName,
            &PurgeRequestWOW->ServerName );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalPurgeRequest.RealmName,
            &PurgeRequestWOW->RealmName );

        PurgeRequest = &LocalPurgeRequest;
    }

#endif  // _WIN64

    //
    // Normalize the strings
    //

    NULL_RELOCATE_ONE( &PurgeRequest->ServerName );
    NULL_RELOCATE_ONE( &PurgeRequest->RealmName );

    //
    // Find the callers logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( RtlIsZeroLuid( &PurgeRequest->LogonId )) {

        LogonId = &ClientInfo.LogonId;

    } else if ( !ClientInfo.HasTcbPrivilege ) {

        //
        // The caller must have TCB privilege in order to access someone
        // else's ticket cache.
        //

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;

    } else {

        LogonId = &PurgeRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                       LogonId,
                       FALSE               // don't unlink
                       );

    if (LogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // If no servername / realm name were supplied, purge all tickets
    //

    if ((PurgeRequest->ServerName.Length) == 0 && (PurgeRequest->RealmName.Length == 0))
    {
        D_DebugLog((DEB_TRACE, "Purging all tickets\n"));

        KerbCleanupSpnCache();
        Status = KerbPurgePrimaryCredentialsTickets(
                     &LogonSession->PrimaryCredentials,
                     NULL,
                     NULL
                     );

    } else {

        D_DebugLog(( DEB_TRACE, "Purging tickets %wZ\\%wZ\n",
            &PurgeRequest->RealmName,
            &PurgeRequest->ServerName ));

        Status = KerbPurgePrimaryCredentialsTickets(
                     &LogonSession->PrimaryCredentials,
                     &PurgeRequest->ServerName,
                     &PurgeRequest->RealmName
                     );
    }

Cleanup:

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPurgeTicketEx
//
//  Synopsis:   Removes ticket from the ticket cache
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbPurgeTicketEx(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    ULONG StructureSize = sizeof( KERB_PURGE_TKT_CACHE_EX_REQUEST );
    PKERB_PURGE_TKT_CACHE_EX_REQUEST PurgeRequest = ( PKERB_PURGE_TKT_CACHE_EX_REQUEST )ProtocolSubmitBuffer;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;

    //
    // Verify the request.
    //

    D_DebugLog((DEB_TRACE, "Purging ticket cache Ex\n"));    

    //
    // Any purging will also tag SPN cache for purge
    //


#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    if( !LsaFunctions->GetCallInfo( &CallInfo )) {

        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) {

        StructureSize = sizeof( KERB_PURGE_TKT_CACHE_EX_REQUEST_WOW64 );
    }

#endif

    if ( SubmitBufferSize < StructureSize ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

#if _WIN64

    KERB_PURGE_TKT_CACHE_EX_REQUEST LocalPurgeRequest;

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) {

        //
        // Thunk 32-bit pointers if this is a WOW caller
        //

        PKERB_PURGE_TKT_CACHE_EX_REQUEST_WOW64 PurgeRequestWOW =
            ( PKERB_PURGE_TKT_CACHE_EX_REQUEST_WOW64 )PurgeRequest;

        LocalPurgeRequest.MessageType = PurgeRequestWOW->MessageType;
        LocalPurgeRequest.LogonId = PurgeRequestWOW->LogonId;

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalPurgeRequest.TicketTemplate.ClientName,
            &PurgeRequestWOW->TicketTemplate.ClientName );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalPurgeRequest.TicketTemplate.ClientRealm,
            &PurgeRequestWOW->TicketTemplate.ClientRealm );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalPurgeRequest.TicketTemplate.ServerName,
            &PurgeRequestWOW->TicketTemplate.ServerName );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalPurgeRequest.TicketTemplate.ServerRealm,
            &PurgeRequestWOW->TicketTemplate.ServerRealm );

        LocalPurgeRequest.TicketTemplate.StartTime = PurgeRequestWOW->TicketTemplate.StartTime;
        LocalPurgeRequest.TicketTemplate.EndTime = PurgeRequestWOW->TicketTemplate.EndTime;
        LocalPurgeRequest.TicketTemplate.RenewTime = PurgeRequestWOW->TicketTemplate.RenewTime;
        LocalPurgeRequest.TicketTemplate.EncryptionType = PurgeRequestWOW->TicketTemplate.EncryptionType;
        LocalPurgeRequest.TicketTemplate.TicketFlags = PurgeRequestWOW->TicketTemplate.TicketFlags;

        PurgeRequest = &LocalPurgeRequest;
    }

#endif

    //
    // Normalize the strings
    //

    NULL_RELOCATE_ONE( &PurgeRequest->TicketTemplate.ClientName );
    NULL_RELOCATE_ONE( &PurgeRequest->TicketTemplate.ClientRealm );
    NULL_RELOCATE_ONE( &PurgeRequest->TicketTemplate.ServerName );
    NULL_RELOCATE_ONE( &PurgeRequest->TicketTemplate.ServerRealm );

    //
    // Find the callers logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id
    //

    if ( RtlIsZeroLuid( &PurgeRequest->LogonId )) {

        LogonId = &ClientInfo.LogonId;

    } else if ( !ClientInfo.HasTcbPrivilege ) {

        //
        // The caller is required to have the TCB privilege
        // in order to access someone else's ticket cache
        //

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;

    } else {

        LogonId = &PurgeRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                       LogonId,
                       FALSE
                       );

    if ( LogonSession == NULL ) {

        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Purge the entire ticket cache?
    //

    if ( PurgeRequest->Flags & KERB_PURGE_ALL_TICKETS ) {

        D_DebugLog(( DEB_TRACE, "Purging all tickets\n" ));

        KerbCleanupSpnCache();

        Status = KerbPurgePrimaryCredentialsTickets(
                     &LogonSession->PrimaryCredentials,
                     NULL,
                     NULL
                     );

        DsysAssert( NT_SUCCESS( Status ));

        KerbLockList( &LogonSession->CredmanCredentials );

        for ( PLIST_ENTRY ListEntry = LogonSession->CredmanCredentials.List.Flink;
              ListEntry != &LogonSession->CredmanCredentials.List;
              ListEntry = ListEntry->Flink ) {

            PKERB_CREDMAN_CRED CredmanCred = CONTAINING_RECORD(
                                                 ListEntry,
                                                 KERB_CREDMAN_CRED,
                                                 ListEntry.Next
                                                 );

            if ( CredmanCred->SuppliedCredentials == NULL) {

                continue;
            }

            Status = KerbPurgePrimaryCredentialsTickets(
                         CredmanCred->SuppliedCredentials,
                         NULL,
                         NULL
                         );

            DsysAssert( NT_SUCCESS( Status ));
        }

        KerbUnlockList( &LogonSession->CredmanCredentials );

    } else {

        BOOLEAN MatchClient = (
                    PurgeRequest->TicketTemplate.ClientName.Length > 0 ||
                    PurgeRequest->TicketTemplate.ClientRealm.Length > 0 );

        BOOLEAN MatchServer = (
                    PurgeRequest->TicketTemplate.ServerName.Length > 0 ||
                    PurgeRequest->TicketTemplate.ServerRealm.Length > 0 );

        BOOLEAN Found = FALSE;

        //
        // Take a look at the primary credentials and see if they need cleaning
        //

        if ( !MatchClient ||
             ( RtlEqualUnicodeString(
                   &LogonSession->PrimaryCredentials.UserName,
                   &PurgeRequest->TicketTemplate.ClientName,
                   TRUE ) &&
               RtlEqualUnicodeString(
                   &LogonSession->PrimaryCredentials.DomainName,
                   &PurgeRequest->TicketTemplate.ClientRealm,
                   TRUE ))) {

            UNICODE_STRING * MatchServerName;
            UNICODE_STRING * MatchServerRealm;

            if ( MatchServer ) {

                MatchServerName = &PurgeRequest->TicketTemplate.ServerName;
                MatchServerRealm = &PurgeRequest->TicketTemplate.ServerRealm;

            } else {

                MatchServerName = NULL;
                MatchServerRealm = NULL;
            }

            Status = KerbPurgePrimaryCredentialsTickets(
                         &LogonSession->PrimaryCredentials,
                         MatchServerName,
                         MatchServerRealm
                         );

            if ( NT_SUCCESS( Status )) {

                Found = TRUE;

            } else if ( Status != STATUS_OBJECT_NAME_NOT_FOUND ) {

                goto Cleanup;
            }
        }

        //
        // Now look at the credman credentials and purge those
        //

        KerbLockList( &LogonSession->CredmanCredentials );

        for ( PLIST_ENTRY ListEntry = LogonSession->CredmanCredentials.List.Flink;
              ListEntry != &LogonSession->CredmanCredentials.List;
              ListEntry = ListEntry->Flink ) {

            PKERB_CREDMAN_CRED CredmanCred = CONTAINING_RECORD(
                                                 ListEntry,
                                                 KERB_CREDMAN_CRED,
                                                 ListEntry.Next
                                                 );

            if ( CredmanCred->SuppliedCredentials == NULL ) {

                continue;
            }

            if ( !MatchClient ||
                 ( RtlEqualUnicodeString(
                       &CredmanCred->SuppliedCredentials->UserName,
                       &PurgeRequest->TicketTemplate.ClientName,
                       TRUE ) &&
                   RtlEqualUnicodeString(
                       &CredmanCred->SuppliedCredentials->DomainName,
                       &PurgeRequest->TicketTemplate.ClientRealm,
                       TRUE ))) {

                UNICODE_STRING * MatchServerName;
                UNICODE_STRING * MatchServerRealm;

                if ( MatchServer ) {

                    MatchServerName = &PurgeRequest->TicketTemplate.ServerName;
                    MatchServerRealm = &PurgeRequest->TicketTemplate.ServerRealm;

                } else {

                    MatchServerName = NULL;
                    MatchServerRealm = NULL;
                }

                Status = KerbPurgePrimaryCredentialsTickets(
                             CredmanCred->SuppliedCredentials,
                             MatchServerName,
                             MatchServerRealm
                             );

                if ( NT_SUCCESS( Status )) {

                    Found = TRUE;

                } else if ( Status != STATUS_OBJECT_NAME_NOT_FOUND ) {

                    KerbUnlockList( &LogonSession->CredmanCredentials );
                    goto Cleanup;
                }
            }
        }

        KerbUnlockList( &LogonSession->CredmanCredentials );

        if ( Found ) {

            Status = STATUS_SUCCESS;

        } else {

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
    }

Cleanup:

    if ( LogonSession ) {

        KerbDereferenceLogonSession( LogonSession );
    }

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = NULL;

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbRetrieveEncodedTicket
//
//  Synopsis:   Retrieves an asn.1 encoded ticket from the ticket cache
//              specified.
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbRetrieveEncodedTicket(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    SECPKG_CLIENT_INFO ClientInfo;
    LUID DummyLogonId, *LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_CREDENTIAL Credential = NULL;
    KERB_PRIMARY_CREDENTIAL * PrimaryCreds = NULL;
    PKERB_RETRIEVE_TKT_REQUEST RetrieveRequest = ( PKERB_RETRIEVE_TKT_REQUEST )ProtocolSubmitBuffer;
    PKERB_RETRIEVE_TKT_RESPONSE RetrieveResponse = NULL;
    KERB_TICKET_CACHE_ENTRY * CacheEntry = NULL;
    PKERB_SPN_CACHE_ENTRY SpnCacheEntry = NULL;
    PBYTE ClientResponse = NULL;
    ULONG ResponseSize;
    PKERB_INTERNAL_NAME TargetName = NULL;
    UNICODE_STRING TargetRealm = {0};
    ULONG Flags = 0;
    ULONG StructureSize = sizeof( KERB_RETRIEVE_TKT_REQUEST );

    //
    // Verify the request.
    //

    D_DebugLog(( DEB_TRACE, "Retrieving encoded ticket\n" ));

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    //
    // Return 32-bit cache entries if this is a WOW caller
    //

    if (!LsaFunctions->GetCallInfo(&CallInfo))
    {

        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
    {
        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

#endif  // _WIN64

    if (SubmitBufferSize < StructureSize)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Normalize the strings
    //

    NULL_RELOCATE_ONE( &RetrieveRequest->TargetName );

    //
    // Find the callers logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, use the caller's logon id.
    //

    if ( (RetrieveRequest->CacheOptions & KERB_RETRIEVE_TICKET_USE_CREDHANDLE) != 0)
    {
        //
        // Get the associated credential
        //

        Status = KerbReferenceCredential(
                     RetrieveRequest->CredentialsHandle.dwUpper,
                     KERB_CRED_OUTBOUND | KERB_CRED_TGT_AVAIL,
                     FALSE,
                     &Credential);

        if (!NT_SUCCESS(Status))
        {
            DebugLog(( DEB_WARN, "Failed to locate credential: 0x%x\n", Status ));
            goto Cleanup;
        }

        //
        // Get the logon id from the credentials so we can locate the
        // logon session.
        //

        DummyLogonId = Credential->LogonId;
        LogonId = &DummyLogonId;

    }
    else if ( RtlIsZeroLuid( &RetrieveRequest->LogonId ) )
    {

        LogonId = &ClientInfo.LogonId;

    }
    else if ( !ClientInfo.HasTcbPrivilege )
    {
        //
        // The caller must have TCB privilege in order to access someone
        // elses ticket cache.
        //

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;

    } else {

        LogonId = &RetrieveRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                       LogonId,
                       FALSE               // don't unlink
                       );

    if (LogonSession == NULL)
    {
        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    //
    // Process the target names
    //

    Status = KerbProcessTargetNames(
                 &RetrieveRequest->TargetName,
                 NULL,                           // no supp target name
                 0,                              // no flags
                 &Flags,
                 &TargetName,
                 &TargetRealm,
                 &SpnCacheEntry
                 );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Check the TGT cache, as KerbGetServiceTicket doesn't look there
    //

    if ((RetrieveRequest->CacheOptions & KERB_RETRIEVE_TICKET_DONT_USE_CACHE) == 0)
    {
        KerbReadLockLogonSessions(LogonSession);

        //
        // Pick which ticket cache to use
        //

        if ((Credential != NULL) && (Credential->SuppliedCredentials != NULL))
        {
            PrimaryCreds = Credential->SuppliedCredentials;
        }
        else
        {
            PrimaryCreds = &LogonSession->PrimaryCredentials;
        }

        CacheEntry = KerbLocateTicketCacheEntry(
                         &PrimaryCreds->AuthenticationTicketCache,
                         TargetName,
                         &TargetRealm
                         );

        if (CacheEntry == NULL)
        {
            //
            // If the tgt cache failed, check the normal cache
            //

            CacheEntry = KerbLocateTicketCacheEntry(
                             &PrimaryCreds->ServerTicketCache,
                             TargetName,
                             &TargetRealm
                             );
        }

        //
        // Check if this is a TGT
        //

        if (CacheEntry == NULL)
        {
            if ((TargetName->NameCount == 2) &&
                 RtlEqualUnicodeString(
                     &TargetName->Names[0],
                     &KerbGlobalKdcServiceName,
                     TRUE                        // case insensitive
                     ))
            {

                //
                // If the tgt cache failed, check the normal cache
                //

                CacheEntry = KerbLocateTicketCacheEntryByRealm(
                                 &PrimaryCreds->AuthenticationTicketCache,
                                 &TargetRealm,
                                 KERB_TICKET_CACHE_PRIMARY_TGT
                                 );

                if (CacheEntry != NULL)
                {
                    //
                    // Make sure the name matches
                    //

                    KerbReadLockTicketCache();

                    if ( !KerbEqualKdcNames(
                              TargetName,
                              CacheEntry->ServiceName
                              ))
                    {
                        //
                        // We must unlock the ticket cache before dereferencing
                        //

                        KerbUnlockTicketCache();
                        KerbDereferenceTicketCacheEntry( CacheEntry );
                        CacheEntry = NULL;

                    }
                    else
                    {
                        KerbUnlockTicketCache();
                    }
                }
            }
        }

        //
        // If we found a ticket, make sure it has the right flags &
        // encryption type
        //

        if (CacheEntry != NULL)
        {
            ULONG TicketFlags;
            ULONG CacheTicketFlags;
            LONG CacheEncryptionType;

            //
            // Check if the flags are present
            //

            KerbReadLockTicketCache();
            CacheTicketFlags = CacheEntry->TicketFlags;
            CacheEncryptionType = CacheEntry->Ticket.encrypted_part.encryption_type;
            KerbUnlockTicketCache();

            TicketFlags = KerbConvertKdcOptionsToTicketFlags( RetrieveRequest->TicketFlags );

            //
            // Verify the flags
            //

            if ((( CacheTicketFlags & TicketFlags ) != TicketFlags) ||
                ((RetrieveRequest->EncryptionType != KERB_ETYPE_DEFAULT) && (CacheEncryptionType != RetrieveRequest->EncryptionType)))
            {
                //
                // Something doesn't match, so throw away the entry
                //

                KerbDereferenceTicketCacheEntry( CacheEntry );
                CacheEntry = NULL;
            }
        }

        KerbUnlockLogonSessions(LogonSession);
    }
    else
    {
        Flags |= KERB_GET_TICKET_NO_CACHE;
    }

    if (CacheEntry == NULL)
    {
        //
        // If we aren't supposed to get a new ticket, return a failure now.
        //

        if ((RetrieveRequest->CacheOptions & KERB_RETRIEVE_TICKET_USE_CACHE_ONLY) != 0)
        {
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
            goto Cleanup;
        }

        //
        // Now get a ticket
        //

        Status = KerbGetServiceTicket(
                    LogonSession,
                    Credential,
                    NULL,
                    TargetName,
                    &TargetRealm,
                    SpnCacheEntry,
                    Flags,
                    RetrieveRequest->TicketFlags,
                    RetrieveRequest->EncryptionType,
                    NULL,                       // no error message
                    NULL,                       // no authorization data
                    NULL,                       // no tgt reply
                    &CacheEntry,
                    NULL                        // don't return logon guid
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_WARN, "KerbRetrieveEncodedTicket failed to get outbound ticket: KerbGetServiceTicket failed with 0x%x\n",Status));
            goto Cleanup;
        }
    }

    //
    // Encode the ticket or kerb_cred
    //

    KerbReadLockTicketCache();

    Status = KerbPackExternalTicket(
                 CacheEntry,
                 RetrieveRequest->CacheOptions & KERB_RETRIEVE_TICKET_AS_KERB_CRED,
                 ( ClientInfo.HasTcbPrivilege || KerbGlobalAllowTgtSessionKey ),
                 &ResponseSize,
                 &ClientResponse
                 );

    KerbUnlockTicketCache();

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *ProtocolReturnBuffer = ClientResponse;
    ClientResponse = NULL;
    *ReturnBufferLength = ResponseSize;

Cleanup:

    if (CacheEntry != NULL)
    {
        KerbDereferenceTicketCacheEntry( CacheEntry );
    }

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession( LogonSession );
    }

    if (Credential != NULL)
    {
        KerbDereferenceCredential( Credential );
    }

    KerbFree( RetrieveResponse );

    if (ClientResponse != NULL)
    {
        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientResponse
            );
    }

    if ( SpnCacheEntry )
    {
        KerbDereferenceSpnCacheEntry( SpnCacheEntry );
    }

    KerbFreeString( &TargetRealm );
    KerbFreeKdcName( &TargetName );

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}


#if 0

//+-------------------------------------------------------------------------
//
//  Function:   KerbRetrieveEncodedTicketEx
//
//  Synopsis:   Retrieves an asn.1 encoded ticket from the ticket cache
//              specified.
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbRetrieveEncodedTicketEx(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    SECPKG_CLIENT_INFO ClientInfo;
    ULONG StructureSize = sizeof( KERB_RETRIEVE_TKT_EX_REQUEST );
    PKERB_RETRIEVE_TKT_EX_REQUEST RetrieveRequest = ( PKERB_RETRIEVE_TKT_EX_REQUEST )ProtocolSubmitBuffer;
    PKERB_RETRIEVE_TKT_EX_RESPONSE RetrieveResponse = NULL;
    PKERB_CREDENTIAL Credential = NULL;
    LUID DummyLogonId, *LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;
    ULONG Flags = 0;
    PKERB_INTERNAL_NAME TargetName = NULL;
    UNICODE_STRING TargetRealm = {0};
    PBYTE ClientResponse = NULL;
    ULONG ResponseSize;

    //
    // Verify the request
    //

    D_DebugLog(( DEB_TRACE, "Retrieving encoded ticket ex\n" ));

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    //
    // Return 32-bit cache entries if this is a WOW caller
    //

    if( !LsaFunctions->GetCallInfo( &CallInfo )) {

        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) {

        StructureSize = sizeof( KERB_RETRIEVE_TKT_EX_REQUEST_WOW64 );
    }

#endif  // _WIN64

    if ( SubmitBufferSize < StructureSize ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

#if _WIN64

    KERB_RETRIEVE_TKT_EX_REQUEST LocalRetrieveRequest;

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) {

        //
        // Thunk 32-bit pointers if this is a WOW caller
        //

        PKERB_RETRIEVE_TKT_EX_REQUEST_WOW64 RetrieveRequestWOW =
            ( PKERB_RETRIEVE_TKT_EX_REQUEST_WOW64 )RetrieveRequest;

        LocalRetrieveRequest.MessageType = RetrieveRequestWOW->MessageType;
        LocalRetrieveRequest.LogonId = RetrieveRequestWOW->LogonId;

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalRetrieveRequest.TicketTemplate.ClientName,
            &RetrieveRequestWOW->TicketTemplate.ClientName );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalRetrieveRequest.TicketTemplate.ClientRealm,
            &RetrieveRequestWOW->TicketTemplate.ClientRealm );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalRetrieveRequest.TicketTemplate.ServerName,
            &RetrieveRequestWOW->TicketTemplate.ServerName );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalRetrieveRequest.TicketTemplate.ServerRealm,
            &RetrieveRequestWOW->TicketTemplate.ServerRealm );

        LocalRetrieveRequest.TicketTemplate.StartTime = RetrieveRequestWOW->TicketTemplate.StartTime;
        LocalRetrieveRequest.TicketTemplate.EndTime = RetrieveRequestWOW->TicketTemplate.EndTime;
        LocalRetrieveRequest.TicketTemplate.RenewTime = RetrieveRequestWOW->TicketTemplate.RenewTime;
        LocalRetrieveRequest.TicketTemplate.EncryptionType = RetrieveRequestWOW->TicketTemplate.EncryptionType;
        LocalRetrieveRequest.TicketTemplate.TicketFlags = RetrieveRequestWOW->TicketTemplate.TicketFlags;

        LocalRetrieveRequest.CacheOptions = RetrieveRequestWOW->CacheOptions;
        LocalRetrieveRequest.CredentialsHandle = RetrieveRequestWOW->CredentialsHandle;

        //
        // TODO: take care of SecondTicket, UserAuthData and Addresses
        //

        LocalRetrieveRequest.SecondTicket = NULL;
        LocalRetrieveRequest.UserAuthData = NULL;
        LocalRetrieveRequest.Addresses = NULL;

        RetrieveRequest = &LocalRetrieveRequest;
    }

#endif

    //
    // Normalize the strings
    //

    NULL_RELOCATE_ONE( &RetrieveRequest->TicketTemplate.ClientName );
    NULL_RELOCATE_ONE( &RetrieveRequest->TicketTemplate.ClientRealm );
    NULL_RELOCATE_ONE( &RetrieveRequest->TicketTemplate.ServerName );
    NULL_RELOCATE_ONE( &RetrieveRequest->TicketTemplate.ServerRealm );

    //
    // TODO: take care of SecondTicket, UserAuthData and Addresses
    //

    if ( RetrieveRequest->SecondTicket != NULL ||
         RetrieveRequest->UserAuthData != NULL ||
         RetrieveRequest->Addresses != NULL ) {

        Status = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // Find the callers logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    //
    // If the caller did not provide a logon id, user the caller's logon id
    //

    if ( RetrieveRequest->CacheOptions & KERB_RETRIEVE_TICKET_USE_CREDHANDLE ) {

        //
        // Get the associated credential
        //

        Status = KerbReferenceCredential(
                     RetrieveRequest->CredentialsHandle.dwUpper,
                     KERB_CRED_OUTBOUND | KERB_CRED_TGT_AVAIL,
                     FALSE,
                     &Credential
                     );

        if ( !NT_SUCCESS( Status )) {

            DebugLog(( DEB_WARN, "Failed to locate credential: 0x%x\n", Status ));
            goto Cleanup;
        }

        //
        // Get the logon id from the credentials so we can locate the logon session
        //

        DummyLogonId = Credential->LogonId;
        LogonId = &DummyLogonId;

    } else if ( RtlIsZeroLuid( &RetrieveRequest->LogonId )) {

        LogonId = &ClientInfo.LogonId;

    } else if ( !ClientInfo.HasTcbPrivilege ) {

        //
        // The caller must have TCB privilege in order to access someone else's
        // ticket cache
        //

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;

    } else {

        LogonId = &RetrieveRequest->LogonId;
    }

    LogonSession = KerbReferenceLogonSession(
                       LogonId,
                       FALSE
                       );

    if ( LogonSession == NULL ) {

        Status = STATUS_NO_SUCH_LOGON_SESSION;
        goto Cleanup;
    }

    *ProtocolReturnBuffer = ClientResponse;
    ClientResponse = NULL;
    *ReturnBufferLength = ResponseSize;

Cleanup:

    if ( LogonSession != NULL ) {

        KerbDereferenceLogonSession( LogonSession );
    }

    if ( Credential != NULL ) {

        KerbDereferenceCredential( Credential );
    }

    KerbFree( RetrieveResponse );

    if ( ClientResponse != NULL ) {

        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientResponse
            );
    }

    *ProtocolStatus = Status;
    return STATUS_SUCCESS;
}

#endif // 0

//+-------------------------------------------------------------------------
//
//  Function:   KerbDecryptMessage
//
//  Synopsis:   Decrypts a buffer with either the specified key or the d
//              primary key from the specified logon session.
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
KerbDecryptMessage(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    SECPKG_CLIENT_INFO ClientInfo;
    PLUID LogonId;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_DECRYPT_REQUEST DecryptRequest;
    PBYTE DecryptResponse = NULL;
    ULONG ResponseLength = 0;

    PBYTE ClientResponse = NULL;
    PKERB_ENCRYPTION_KEY KeyToUse = NULL;
    KERB_ENCRYPTION_KEY SuppliedKey = {0};
    BOOLEAN FreeKey = FALSE;
    PCRYPTO_SYSTEM CryptoSystem = NULL;
    PCRYPT_STATE_BUFFER CryptBuffer = NULL;

    //
    // Verify the request.
    //

    D_DebugLog((DEB_TRACE, "Decrypting Message\n"));

    if (SubmitBufferSize < sizeof(KERB_DECRYPT_REQUEST))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    DecryptRequest = (PKERB_DECRYPT_REQUEST) ProtocolSubmitBuffer;

    //
    // Validate the pointers
    //

    if (DecryptRequest->InitialVector != NULL)
    {
        if (DecryptRequest->InitialVector - (PUCHAR) ClientBufferBase + DecryptRequest->InitialVectorSize > SubmitBufferSize)
        {
            DebugLog((DEB_ERROR,"InitialVector end pass end of buffer\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        if (DecryptRequest->InitialVector < (PUCHAR) ClientBufferBase + sizeof(KERB_DECRYPT_REQUEST))
        {
            DebugLog((DEB_ERROR,"InitialVector begin before end of DECRYPT_REQUEST\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        DecryptRequest->InitialVector = DecryptRequest->InitialVector - (PUCHAR) ClientBufferBase + (PUCHAR) ProtocolSubmitBuffer;
    }
    else
    {
        if (DecryptRequest->InitialVectorSize != 0)
        {
            DebugLog((DEB_ERROR,"Non-zero vector size with null vector\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    if (DecryptRequest->EncryptedData - (PUCHAR) ClientBufferBase + DecryptRequest->EncryptedDataSize > SubmitBufferSize)
    {
        DebugLog((DEB_ERROR,"EncryptedData end past end of request buffer\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (DecryptRequest->EncryptedData < (PUCHAR) ClientBufferBase + sizeof(KERB_DECRYPT_REQUEST))
    {
        DebugLog((DEB_ERROR,"EncryptedData begin before end of DECRYPT_REQUEST\n"));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    DecryptRequest->EncryptedData = DecryptRequest->EncryptedData - (PUCHAR) ClientBufferBase + (PUCHAR) ProtocolSubmitBuffer;

    //
    // If the caller wants the default key, then open the specified logon
    // session and get out the key.
    //

    if (DecryptRequest->Flags & KERB_DECRYPT_FLAG_DEFAULT_KEY)
    {
        //
        // Find the callers logon id & TCB status
        //

        Status = LsaFunctions->GetClientInfo(&ClientInfo);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // If the caller did not provide a logon id, use the caller's logon id.
        //

        if ( RtlIsZeroLuid( &DecryptRequest->LogonId ) )
        {
            LogonId = &ClientInfo.LogonId;
        }
        else
        {
            //
            // Verify the caller has TCB privilege if they want access to someone
            // elses ticket cache.
            //

            if (!ClientInfo.HasTcbPrivilege)
            {
                Status = STATUS_PRIVILEGE_NOT_HELD;
                goto Cleanup;
            }

            LogonId = &DecryptRequest->LogonId;
        }

        LogonSession = KerbReferenceLogonSession(
                        LogonId,
                        FALSE               // don't unlink
                        );

        if (LogonSession == NULL)
        {
            Status = STATUS_NO_SUCH_LOGON_SESSION;
            goto Cleanup;
        }

        //
        // Get the key from the logon session
        //

        KerbReadLockLogonSessions(LogonSession);
        if (LogonSession->PrimaryCredentials.Passwords != NULL)
        {
            KeyToUse = KerbGetKeyFromList(
                        LogonSession->PrimaryCredentials.Passwords,
                        DecryptRequest->CryptoType
                        );
            if (KeyToUse != NULL)
            {
                KERBERR KerbErr;

                KerbErr = KerbDuplicateKey(
                            &SuppliedKey,
                            KeyToUse
                            );
                KeyToUse = NULL;
                Status = KerbMapKerbError(KerbErr);
            }
            else
            {
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
            }

        }
        else
        {
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }
        KerbUnlockLogonSessions(LogonSession);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        KeyToUse = &SuppliedKey;
        FreeKey = TRUE;
    }
    else
    {
        if (DecryptRequest->Key.Value - (PUCHAR) ClientBufferBase + DecryptRequest->Key.Length > SubmitBufferSize)
        {
            DebugLog((DEB_ERROR,"End of supplied key past end of request buffer\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        if (DecryptRequest->Key.Value < (PUCHAR) ClientBufferBase + sizeof(KERB_DECRYPT_REQUEST))
        {
            DebugLog((DEB_ERROR,"Begin of supplied key before end of DECRYPT_REQUEST\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        DecryptRequest->Key.Value = DecryptRequest->Key.Value - (PUCHAR) ClientBufferBase + (PUCHAR) ProtocolSubmitBuffer;
        SuppliedKey.keytype = DecryptRequest->Key.KeyType;
        SuppliedKey.keyvalue.value = DecryptRequest->Key.Value;
        SuppliedKey.keyvalue.length = DecryptRequest->Key.Length;
        KeyToUse = &SuppliedKey;
    }



    //
    // Now do the decryption
    //

    SafeAllocaAllocate(DecryptResponse, DecryptRequest->EncryptedDataSize);

    if (DecryptResponse == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ResponseLength = DecryptRequest->EncryptedDataSize;

    Status = CDLocateCSystem(
                DecryptRequest->CryptoType,
                &CryptoSystem
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // The crypt system must be integrity protected - otherwise it may be
    // used as a general purpose encryption/decryption technique.
    //

    if ((CryptoSystem->Attributes & CSYSTEM_INTEGRITY_PROTECTED) == 0)
    {
        DebugLog((DEB_ERROR,"Trying to decrypt with non-integrity protected crypt system (%d)\n",
            CryptoSystem->EncryptionType));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    Status = CryptoSystem->Initialize(
                KeyToUse->keyvalue.value,
                KeyToUse->keyvalue.length,
                DecryptRequest->KeyUsage,
                &CryptBuffer
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If there was an initial vector, use it now
    //

    if (DecryptRequest->InitialVectorSize != 0)
    {
        Status = CryptoSystem->Control(
                    CRYPT_CONTROL_SET_INIT_VECT,
                    CryptBuffer,
                    DecryptRequest->InitialVector,
                    DecryptRequest->InitialVectorSize
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Decrypt
    //

    Status = CryptoSystem->Decrypt(
                CryptBuffer,
                DecryptRequest->EncryptedData,
                DecryptRequest->EncryptedDataSize,
                DecryptResponse,
                &ResponseLength
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Return the decrypted data to the client
    //

    Status = LsaFunctions->AllocateClientBuffer(
                NULL,
                ResponseLength,
                (PVOID *) &ClientResponse
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = LsaFunctions->CopyToClientBuffer(
                NULL,
                ResponseLength,
                ClientResponse,
                DecryptResponse
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    *ProtocolReturnBuffer = ClientResponse;
    ClientResponse = NULL;
    *ReturnBufferLength = ResponseLength;

Cleanup:

    if ((CryptoSystem != NULL) && (CryptBuffer != NULL))
    {
        CryptoSystem->Discard(&CryptBuffer);
    }
    if (FreeKey)
    {
        KerbFreeKey(&SuppliedKey);
    }

    if (LogonSession != NULL)
    {
        KerbDereferenceLogonSession(LogonSession);
    }

    SafeAllocaFree(DecryptResponse);

    if (ClientResponse != NULL)
    {
        LsaFunctions->FreeClientBuffer(
            NULL,
            ClientResponse
            );
    }

    *ProtocolStatus = Status;

    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbAddBindingCacheEntry
//
//  Synopsis:   Adds an entry to the binding cache
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbAddBindingCacheEntry(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    NTSTATUS Status;
    SECPKG_CLIENT_INFO ClientInfo;
    PKERB_ADD_BINDING_CACHE_ENTRY_REQUEST BindingRequest = ( PKERB_ADD_BINDING_CACHE_ENTRY_REQUEST )ProtocolSubmitBuffer;
    PKERB_BINDING_CACHE_ENTRY CacheEntry = NULL;
    ULONG StructureSize = sizeof( KERB_ADD_BINDING_CACHE_ENTRY_REQUEST );

    //
    // Verify the request.
    //

    D_DebugLog(( DEB_TRACE, "Adding binding cache entry\n" ));

#if _WIN64

    SECPKG_CALL_INFO CallInfo;

    //
    // Return 32-bit cache entries if this is a WOW caller
    //

    if(!LsaFunctions->GetCallInfo( &CallInfo ))
    {
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) {

        StructureSize = sizeof( KERB_ADD_BINDING_CACHE_ENTRY_REQUEST_WOW64 );
    }

#endif  // _WIN64

    if ( SubmitBufferSize < StructureSize ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

#if _WIN64

    KERB_ADD_BINDING_CACHE_ENTRY_REQUEST LocalBindingRequest;

    if ( CallInfo.Attributes & SECPKG_CALL_WOWCLIENT ) {

        //
        // Thunk 32-bit pointers if this is a WOW caller
        //

        PKERB_ADD_BINDING_CACHE_ENTRY_REQUEST_WOW64 BindingRequestWOW =
            ( PKERB_ADD_BINDING_CACHE_ENTRY_REQUEST_WOW64 )BindingRequest;

        LocalBindingRequest.MessageType = BindingRequestWOW->MessageType;

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalBindingRequest.RealmName,
            &BindingRequestWOW->RealmName );

        UNICODE_STRING_FROM_WOW_STRING(
            &LocalBindingRequest.KdcAddress,
            &BindingRequestWOW->KdcAddress );

        LocalBindingRequest.AddressType = BindingRequestWOW->AddressType;

        BindingRequest = &LocalBindingRequest;
    }

#endif  // _WIN64

    //
    // Normalize the strings
    //

    NULL_RELOCATE_ONE( &BindingRequest->RealmName );
    NULL_RELOCATE_ONE( &BindingRequest->KdcAddress );

    //
    // Find the callers logon id & TCB status
    //

    Status = LsaFunctions->GetClientInfo( &ClientInfo );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    //
    // Require the caller to have TCB.
    //

    if ( !ClientInfo.HasTcbPrivilege ) {

        Status = STATUS_PRIVILEGE_NOT_HELD;
        goto Cleanup;
    }

    Status = KerbCacheBinding(
                 &BindingRequest->RealmName,
                 &BindingRequest->KdcAddress,
                 BindingRequest->AddressType,
                 0,
                 0,
                 0,
                 &CacheEntry
                 );

Cleanup:

    if ( CacheEntry != NULL ) {

        KerbDereferenceBindingCacheEntry( CacheEntry );
    }

    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;
    *ProtocolStatus = Status;

    return STATUS_SUCCESS;
}


NTSTATUS
VerifyCredentials(
    IN PUNICODE_STRING UserName,
    IN PUNICODE_STRING DomainName,
    IN PUNICODE_STRING Password
    )
{
    SAMPR_HANDLE UserHandle = NULL;
    PSAMPR_USER_INFO_BUFFER UserAllInfo = NULL;
    PSAMPR_USER_ALL_INFORMATION UserAll;
    SID_AND_ATTRIBUTES_LIST GroupMembership;

    NT_OWF_PASSWORD NtOwfPassword;
    BOOLEAN UpdateLogonStats = FALSE;
    NTSTATUS Status = STATUS_LOGON_FAILURE;

    GroupMembership.SidAndAttributes = NULL;


    //
    // lazy initialization of SAM handles.
    //

    if( KerbGlobalDomainHandle == NULL )
    {
        SAMPR_HANDLE SamHandle = NULL;
        SAMPR_HANDLE DomainHandle = NULL;
        PLSAPR_POLICY_INFORMATION PolicyInfo = NULL;

        //
        // Open SAM to get the account information
        //

        Status = SamIConnect(
                    NULL,                   // no server name
                    &SamHandle,
                    0,                      // no desired access
                    TRUE                    // trusted caller
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if(InterlockedCompareExchangePointer(
                        &KerbGlobalSamHandle,
                        SamHandle,
                        NULL
                        ) != NULL)
        {
            SamrCloseHandle( &SamHandle );
        }


        Status = LsaIQueryInformationPolicyTrusted(
                        PolicyAccountDomainInformation,
                        &PolicyInfo
                        );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        Status = SamrOpenDomain(
                        KerbGlobalSamHandle,
                        0,                  // no desired access
                        (PRPC_SID) PolicyInfo->PolicyAccountDomainInfo.DomainSid,
                        &DomainHandle
                        );

        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyAccountDomainInformation,
            PolicyInfo
            );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if(InterlockedCompareExchangePointer(
                        &KerbGlobalDomainHandle,
                        DomainHandle,
                        NULL
                        ) != NULL)
        {
            SamrCloseHandle( &DomainHandle );
        }
    }

    //
    // try by DN first, then by UPN/SAM accountname.
    //

    Status = SamIGetUserLogonInformationEx(
                KerbGlobalDomainHandle,
                SAM_OPEN_BY_DN | SAM_NO_MEMBERSHIPS,
                UserName,
                USER_ALL_OWFPASSWORD |          // OWFs
                USER_ALL_NTPASSWORDPRESENT |    // OWF present bits.
                USER_ALL_LMPASSWORDPRESENT |    // OWF present bits.
                USER_ALL_BADPASSWORDCOUNT |     // bad password count.
                USER_ALL_USERACCOUNTCONTROL,    // UserAccountControl - account disabled/etc.
                &UserAllInfo,
                &GroupMembership,
                &UserHandle
                );

    if (Status == STATUS_OBJECT_NAME_NOT_FOUND ||
        Status == STATUS_OBJECT_NAME_INVALID)
    {
        Status = SamIGetUserLogonInformationEx(
                    KerbGlobalDomainHandle,
                    SAM_OPEN_BY_UPN_OR_ACCOUNTNAME | SAM_NO_MEMBERSHIPS,
                    UserName,
                    USER_ALL_OWFPASSWORD |          // OWFs
                    USER_ALL_NTPASSWORDPRESENT |    // OWF present bits.
                    USER_ALL_LMPASSWORDPRESENT |    // OWF present bits.
                    USER_ALL_BADPASSWORDCOUNT |     // bad password count.
                    USER_ALL_USERACCOUNTCONTROL,    // UserAccountControl - account disabled/etc.
                    &UserAllInfo,
                    &GroupMembership,
                    &UserHandle
                    );
    }

    if ( !NT_SUCCESS(Status) ) {
        goto Cleanup;
    }

    UserAll = &UserAllInfo->All;


    Status = RtlCalculateNtOwfPassword(
                Password,
                &NtOwfPassword
                );

    if( !NT_SUCCESS(Status) )
    {
        goto Cleanup;
    }


    Status = STATUS_LOGON_FAILURE;

    if (UserAll->UserAccountControl & USER_ACCOUNT_DISABLED)
    {
        goto Cleanup;
    }

    if (UserAll->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED)
    {
        goto Cleanup;
    }

    if ( !UserAll->NtPasswordPresent )
    {
        if( UserAll->LmPasswordPresent )
        {
            goto Cleanup;
        }

        if (RtlCompareMemory(
                            &NtOwfPassword,
                            &KerbGlobalNullNtOwfPassword,
                            NT_OWF_PASSWORD_LENGTH
                            ) != NT_OWF_PASSWORD_LENGTH)
        {
            UpdateLogonStats = TRUE;
            goto Cleanup;
        }

    } else {

        if (RtlCompareMemory(
                            &NtOwfPassword,
                            UserAll->NtOwfPassword.Buffer,
                            NT_OWF_PASSWORD_LENGTH
                            ) != NT_OWF_PASSWORD_LENGTH)
        {
            UpdateLogonStats = TRUE;
            goto Cleanup;
        }
    }

    //
    // success!
    //

    if ( UserAll->BadPasswordCount )
    {
        //
        // successful logon, insure logon status gets updated for the lockout/bad password case.
        //

        UpdateLogonStats = TRUE;
    }

    Status = STATUS_SUCCESS;

Cleanup:

    RtlSecureZeroMemory( &NtOwfPassword, sizeof(NtOwfPassword) );

    if( UserAllInfo != NULL )
    {
        //
        // SamIFree zeroes the sensitive fields.
        //

        SamIFree_SAMPR_USER_INFO_BUFFER( UserAllInfo, UserAllInformation );
    }

    if( UpdateLogonStats )
    {
        SAM_LOGON_STATISTICS LogonStats;

        RtlZeroMemory(&LogonStats, sizeof(LogonStats));

        if( NT_SUCCESS(Status) )
        {
            LogonStats.StatisticsToApply = USER_LOGON_INTER_SUCCESS_LOGON;
        } else {
            LogonStats.StatisticsToApply = USER_LOGON_BAD_PASSWORD;
        }

        SamIUpdateLogonStatistics( UserHandle, &LogonStats );
    }

    if (UserHandle != NULL)
    {
        SamrCloseHandle( &UserHandle );
    }

    if (GroupMembership.SidAndAttributes != NULL)
    {
        SamIFreeSidAndAttributesList(&GroupMembership);
    }

    return Status;
}

NTSTATUS NTAPI
KerbVerifyCredentials(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{
    PKERB_VERIFY_CREDENTIALS_REQUEST VerifyRequest = NULL;
    NTSTATUS Status = STATUS_LOGON_FAILURE;


    //
    // Verify the request.
    //

    D_DebugLog((DEB_TRACE, "KerbVerifyCredentials\n"));

    //
    // only support in proc use of this interface.
    //

    if( ClientRequest != NULL )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    if (SubmitBufferSize < sizeof(KERB_VERIFY_CREDENTIALS_REQUEST))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    VerifyRequest = (PKERB_VERIFY_CREDENTIALS_REQUEST) ProtocolSubmitBuffer;


#if 0   // only needed if out-proc supported.
    //
    // Normalize the strings
    //

    if( ClientRequest != NULL )
    {
        NULL_RELOCATE_ONE(&VerifyRequest->UserName);
        NULL_RELOCATE_ONE(&VerifyRequest->DomainName);
        NULL_RELOCATE_ONE(&VerifyRequest->Password);
    }
#endif


    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;

    Status = VerifyCredentials(
                    &VerifyRequest->UserName,
                    &VerifyRequest->DomainName,
                    &VerifyRequest->Password
                    );

Cleanup:

    *ProtocolStatus = Status;
    return(STATUS_SUCCESS);
}






//+-------------------------------------------------------------------------
//
//  Function:   KerbQuerySupplementalCredentials
//
//  Synopsis:   Takes a marshalled credman blob, and gets
//              a TGT and pwd information.
//
//  Effects:
//
//  Arguments:  Same as Callpackage
//
//  Requires:   In process call only!
//
//  Returns:
//
//  Notes:  Free returned buffer using LsapFreeLsa'.
//
//
//--------------------------------------------------------------------------

NTSTATUS NTAPI
KerbQuerySupplementalCredentials(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    )
{

    PKERB_QUERY_SUPPLEMENTAL_CREDS_REQUEST Request = (PKERB_QUERY_SUPPLEMENTAL_CREDS_REQUEST) ProtocolSubmitBuffer;
    PKERB_QUERY_SUPPLEMENTAL_CREDS_RESPONSE Response = NULL;

    NTSTATUS            Status;
    HANDLE              ClientThreadToken = NULL;
    HANDLE              OldToken = NULL;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PKERB_CREDMAN_CRED  CredmanCredential = NULL;
    PKERB_PRIMARY_CREDENTIAL PrimaryCredentials = NULL;
    BOOLEAN             Impersonating = FALSE;
    UNICODE_STRING      TargetName;
    UNICODE_STRING      tmp;
    ULONG               ResponseSize = 0;
    ULONG               AdditionalCredFlags = 0;
    
    *ProtocolReturnBuffer = NULL;
    *ReturnBufferLength = 0;             

    D_DebugLog((DEB_TRACE_API, "KerbQuerySupplementalCredentials\n"));

    //
    // only support in proc use of this interface.
    //

    if (( ClientRequest != NULL ) ||
        ( SubmitBufferSize < sizeof(KERB_QUERY_SUPPLEMENTAL_CREDS_REQUEST) ) ||
        ( Request->MessageType != KerbQuerySupplementalCredentialsMessage ))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Must be a PKI cred, for now :).
    //
    if ( Request->MarshalledCreds->Type != CRED_TYPE_DOMAIN_CERTIFICATE)
    {
        D_DebugLog((DEB_ERROR, "Credential is not a pki credential\n"));
        Status = STATUS_INVALID_PARAMETER;
        DsysAssert(FALSE);                
        goto Cleanup;
    }

    //
    // We may not know about the logon session.  If not,
    // create a duplicate in the kerberos list.
    //
    LogonSession = KerbReferenceLogonSession(
                        &Request->LogonId,
                        FALSE
                        );

    if ( LogonSession == NULL )
    {
        SECPKG_CLIENT_INFO ClientInfo;
        BOOLEAN ClientImpersonating;
        SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
        HANDLE  hProcess = NULL;

        DebugLog((DEB_ERROR, "Missing logon session \n"));
        DsysAssert(FALSE);

        Status = LsaFunctions->GetClientInfo(&ClientInfo);
        if (!NT_SUCCESS(Status))
        {
            D_DebugLog((DEB_ERROR,"Failed to get client information: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }
        else if ((ClientInfo.ClientFlags & SECPKG_CLIENT_THREAD_TERMINATED) != 0)
        {
            Status = STATUS_ACCESS_DENIED;
            goto Cleanup;
        }

        ImpersonationLevel = ClientInfo.ImpersonationLevel; 
        ClientImpersonating = ClientInfo.Impersonating;
        hProcess = (HANDLE) LongToHandle(ClientInfo.ProcessID);

        Status = KerbCreateDummyLogonSession(
                        &Request->LogonId,
                        &LogonSession,
                        ImpersonationLevel,
                        ClientImpersonating,
                        hProcess
                        );

        if (!NT_SUCCESS( Status) )
        {
            DebugLog((DEB_ERROR, "Failed to create dummy logon session %x\n", Status ));
            DsysAssert(FALSE);
            goto Cleanup;    
        }
    }
                    

    //
    // These credman operations require that you impersonate.  Do that, but first
    // save off the old thread token.
    //
    Status = NtOpenThreadToken(
                NtCurrentThread(),
                TOKEN_QUERY | TOKEN_IMPERSONATE,
                TRUE,
                &OldToken
                );

    if (!NT_SUCCESS( Status ) && Status != STATUS_NO_TOKEN )
    {
        DebugLog((DEB_ERROR, "NtOpenThreadToken failed %x\n", Status));
        goto Cleanup;
    }
                     
    Status = LsaFunctions->OpenTokenByLogonId(
                            &LogonSession->LogonId,
                            &ClientThreadToken
                            );

    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR,"Unable to get the client token handle.\n"));
        goto Cleanup;
    }

    if(!SetThreadToken(NULL, ClientThreadToken))
    {
        D_DebugLog((DEB_ERROR,"Unable to impersonate the client token handle.\n"));
        Status = STATUS_CANNOT_IMPERSONATE;
        goto Cleanup;
    }

    Impersonating = TRUE;      

    //
    // Build a credman cred 
    //
    RtlInitUnicodeString(
            &TargetName,
            Request->MarshalledCreds->TargetName
            );       
    
    Status = KerbConvertCertCredential(
                    LogonSession,
                    Request->MarshalledCreds->UserName,
                    &TargetName,
                    &PrimaryCredentials
                    );

    if (!NT_SUCCESS( Status ))
    {
        D_DebugLog((DEB_ERROR, "KerbConvertCertCredential failed %x\n"));
        goto Cleanup;
    }   


    RtlInitUnicodeString(
        &tmp,
        CRED_SESSION_WILDCARD_NAME_W
        );


    if (RtlEqualUnicodeString(&tmp,&TargetName,TRUE))
    {
        AdditionalCredFlags |= RAS_CREDENTIAL;
    }


    KerbWriteLockLogonSessions(LogonSession);
    //
    // Add it to the logon session - this has a byproduct of asking for a TGT.
    //
    Status = KerbAddCredmanCredToLogonSession(
                LogonSession,
                PrimaryCredentials, // note: freed by this fn
                AdditionalCredFlags,
                &CredmanCredential
                );

    KerbUnlockLogonSessions(LogonSession);

    if (!NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR, "KerbAddCredmanCredToLogonSession failed %x\n", Status));
        goto Cleanup;
    }
                     

    //
    // Use the TGT in a U2U fashion - this has a by-product of returning the
    // supplemental credentials in a key we can decrypt with.
    //
    Status = KerbRetrieveOWF(
                    LogonSession,
                    NULL, // no supplied credentials...
                    CredmanCredential,
                    &TargetName,
                    &Response,
                    &ResponseSize
                    );

    if (!NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR, "KerbRetrieveOWF failed %x\n", Status));
        goto Cleanup;
    } 

        
    *ProtocolReturnBuffer = Response;
    *ReturnBufferLength = ResponseSize;  
    Response = NULL;
    
Cleanup:
    
    if ( Impersonating )
    {
        if ( OldToken )
        {
            SetThreadToken( NULL, OldToken );
        }
        else
        {                   
            RevertToSelf(); 
        }
    }

    if ( OldToken )
    {
        CloseHandle(OldToken);
    }

    if ( ClientThreadToken )
    {
        CloseHandle( ClientThreadToken );
    }

    if ( LogonSession )
    {
        KerbDereferenceLogonSession( LogonSession );
    }

    if ( Response )
    {                               
        LsaFunctions->FreeLsaHeap( Response );
    }    


    *ProtocolStatus = Status;
    return (STATUS_SUCCESS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\mitutil.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        mitutil.cxx
//
// Contents:    Routines for talking to MIT KDCs
//
//
// History:     4-March-1997    Created         MikeSw
//              26-Sep-1998   ChandanS
//                            Added more debugging support etc.
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

static HKEY     KerbMITRealmRootKey = NULL;
static HANDLE   hKerbMITRealmWaitEvent = NULL;
static HANDLE   hKerbMITRealmWaitObject = NULL;

KERBEROS_LIST KerbMitRealmList;

#define MAX_DOMAIN_NAME_LEN     128   // number of characters



//+-------------------------------------------------------------------------
//
//  Function:   KerbReadMitRealmList
//
//  Synopsis:   Loads the list of MIT realms from the registry
//
//  Effects:    Initialize and links domains to KerbMitRealmList
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbReadMitRealmList(
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG WinError;
    HKEY DomainKey = NULL;
    LPWSTR KdcNames = NULL;
    LPWSTR KpasswdNames = NULL;
    LPWSTR AlternateRealmNames = NULL;
    TCHAR DomainName[MAX_DOMAIN_NAME_LEN];    // max domain name length
    PKERB_MIT_REALM MitRealm = NULL;
    ULONG Index,Index2;
    ULONG Type;
    ULONG NameSize;
    ULONG KdcNameSize = 0;
    ULONG AltRealmSize = 0;
    ULONG KpasswdNameSize = 0;
    LPWSTR Where;
    ULONG NameCount, tmp;
    UNICODE_STRING TempString;
    ULONG Flags = 0;
    ULONG FlagSize = sizeof(ULONG);
    ULONG ApReqChecksumType = 0;
    ULONG PreAuthType = 0;
    BOOLEAN fListLocked = FALSE;

    //
    // If it is there, we now want to enumerate all the child keys.
    //
    KerbLockList(&KerbMitRealmList);
    fListLocked = TRUE;

    for (Index = 0; TRUE ; Index++ )
    {
        //
        // Enumerate through all the keys
        //
        NameSize = MAX_DOMAIN_NAME_LEN;
        WinError = RegEnumKeyEx(
                    KerbMITRealmRootKey,
                    Index,
                    DomainName,
                    &NameSize,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                    );

        if (WinError != ERROR_SUCCESS)
        {
            //
            // nothing more to do.
            //

            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

        //
        // Open the domain key to read the values under it
        //
        if( DomainKey != NULL )
        {
            RegCloseKey( DomainKey );
            DomainKey = NULL;
        }

        WinError = RegOpenKey(
                    KerbMITRealmRootKey,
                    DomainName,
                    &DomainKey
                    );
        if (WinError != ERROR_SUCCESS)
        {
            D_DebugLog((DEB_ERROR,"Failed to open key %ws \\ %ws: %d. %ws, line %d\n",
                KERB_DOMAINS_KEY, DomainName, WinError, THIS_FILE, __LINE__ ));

            //
            // keep going.
            //

            continue;
        }

        //
        // Now read the values from the domain
        //

        KdcNameSize = 0;
        WinError = RegQueryValueEx(
                    DomainKey,
                    KERB_DOMAIN_KDC_NAMES_VALUE,
                    NULL,
                    &Type,
                    NULL,
                    &KdcNameSize
                    );
        if (WinError == ERROR_SUCCESS)
        {
            KdcNames = (LPWSTR) KerbAllocate(KdcNameSize);
            if (KdcNames == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            WinError = RegQueryValueEx(
                        DomainKey,
                        KERB_DOMAIN_KDC_NAMES_VALUE,
                        NULL,
                        &Type,
                        (PUCHAR) KdcNames,
                        &KdcNameSize
                        );
            if (WinError != ERROR_SUCCESS || Type != REG_MULTI_SZ )
            {
                D_DebugLog((DEB_ERROR,"Failed to query value %ws\\%ws: %d. %ws, line %d\n",
                    DomainName, KERB_DOMAIN_KDC_NAMES_VALUE, WinError, THIS_FILE, __LINE__ ));
                continue; // keep reading...
            }
        }

        //
        // Now read the Kpasswd values from the domain
        //

        KpasswdNameSize = 0;
        WinError = RegQueryValueEx(
                    DomainKey,
                    KERB_DOMAIN_KPASSWD_NAMES_VALUE,
                    NULL,
                    &Type,
                    NULL,
                    &KpasswdNameSize
                    );
        if (WinError == ERROR_SUCCESS)
        {
            KpasswdNames = (LPWSTR) KerbAllocate(KpasswdNameSize);
            if (KpasswdNames == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            WinError = RegQueryValueEx(
                        DomainKey,
                        KERB_DOMAIN_KPASSWD_NAMES_VALUE,
                        NULL,
                        &Type,
                        (PUCHAR) KpasswdNames,
                        &KpasswdNameSize
                        );
            if (WinError != ERROR_SUCCESS || Type != REG_MULTI_SZ )
            {
                D_DebugLog((DEB_ERROR,"Failed to query value %ws\\%ws: %d. %ws, line %d\n",
                    DomainName, KERB_DOMAIN_KPASSWD_NAMES_VALUE, WinError, THIS_FILE, __LINE__ ));
                continue;   // keep reading
            }
        }

        //
        // Get any alternate domain names
        //

        AltRealmSize = 0;
        WinError = RegQueryValueEx(
                    DomainKey,
                    KERB_DOMAIN_ALT_NAMES_VALUE,
                    NULL,
                    &Type,
                    NULL,
                    &AltRealmSize
                    );
        if (WinError == ERROR_SUCCESS)
        {
            AlternateRealmNames = (LPWSTR) KerbAllocate(AltRealmSize);
            if (AlternateRealmNames == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            WinError = RegQueryValueEx(
                        DomainKey,
                        KERB_DOMAIN_ALT_NAMES_VALUE,
                        NULL,
                        &Type,
                        (PUCHAR) AlternateRealmNames,
                        &AltRealmSize
                        );

            if (WinError != ERROR_SUCCESS || Type != REG_MULTI_SZ)
            {
                D_DebugLog((DEB_ERROR,"Failed to query value %ws\\%ws: %d. %ws, line %d\n",
                    DomainName, KERB_DOMAIN_KDC_NAMES_VALUE, WinError, THIS_FILE, __LINE__ ));
                continue;
            }

        }

        //
        // Read the flags
        //

        FlagSize = sizeof(ULONG);
        Flags = 0;

        WinError = RegQueryValueEx(
                    DomainKey,
                    KERB_DOMAIN_FLAGS_VALUE,
                    NULL,
                    &Type,
                    (PUCHAR) &Flags,
                    &FlagSize
                    );
        if (WinError == ERROR_SUCCESS)
        {
            if (Type != REG_DWORD)
            {
                Flags = 0;
            }
        }

        //
        // Read the ApReq checksum type
        //

        FlagSize = sizeof(ULONG);
        ApReqChecksumType = KERB_DEFAULT_AP_REQ_CSUM;

        WinError = RegQueryValueEx(
                    DomainKey,
                    KERB_DOMAIN_AP_REQ_CSUM_VALUE,
                    NULL,
                    &Type,
                    (PUCHAR) &ApReqChecksumType,
                    &FlagSize
                    );
        if (WinError == ERROR_SUCCESS)
        {
            if (Type != REG_DWORD)
            {
                ApReqChecksumType = KERB_DEFAULT_AP_REQ_CSUM;
            }
        }

        //
        // Read the ApReq checksum type
        //

        FlagSize = sizeof(ULONG);
        PreAuthType = KERB_DEFAULT_PREAUTH_TYPE;;

        WinError = RegQueryValueEx(
                    DomainKey,
                    KERB_DOMAIN_PREAUTH_VALUE,
                    NULL,
                    &Type,
                    (PUCHAR) &PreAuthType,
                    &FlagSize
                    );
        if (WinError == ERROR_SUCCESS)
        {
            if (Type != REG_DWORD)
            {
                PreAuthType = KERB_DEFAULT_PREAUTH_TYPE;
            }
        }


        //
        // Now build the domain structure
        //

        MitRealm = (PKERB_MIT_REALM) KerbAllocate(sizeof(KERB_MIT_REALM));
        if (MitRealm == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        MitRealm->Flags = Flags;
        MitRealm->ApReqChecksumType = ApReqChecksumType;
        MitRealm->PreAuthType = PreAuthType;
#ifdef WIN32_CHICAGO
        RtlCreateUnicodeStringFromAsciiz(
            &TempString,
            DomainName
            );
#else // WIN32_CHICAGO
        RtlInitUnicodeString(
            &TempString,
            DomainName
            );
#endif // WIN32_CHICAGO

        Status = KerbDuplicateString(
                    &MitRealm->RealmName,
                    &TempString
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }


        //
        // Fill in the KDC names etc.
        //

        NameCount = 0;
        if ((AlternateRealmNames != NULL ) && (AltRealmSize != 0))
        {
            Where = AlternateRealmNames;
            NameCount ++;
            while (Where + wcslen(Where) + 1 < (AlternateRealmNames + AltRealmSize /sizeof(WCHAR)))
            {  
               NameCount++;
               Where += wcslen(Where)+1;
            }
            MitRealm->AlternateRealmNames = (PUNICODE_STRING) KerbAllocate(NameCount * sizeof(UNICODE_STRING));
            if (MitRealm->AlternateRealmNames == NULL)
            {
               Status = STATUS_INSUFFICIENT_RESOURCES;
               goto Cleanup;
            }

            MitRealm->RealmNameCount = NameCount;
            Where = AlternateRealmNames;
            for (Index2 = 0;Index2 < NameCount; Index2++)
            {
                RtlInitUnicodeString(
                    &MitRealm->AlternateRealmNames[Index2],
                    Where
                    );
                Where += MitRealm->AlternateRealmNames[Index2].Length / sizeof(WCHAR) + 1;
            }

            AlternateRealmNames = NULL;
        }

        NameCount = 0;
        if ((KdcNames != NULL ) && (KdcNameSize != 0))
        {
            Where = KdcNames;
            while (Where + wcslen(Where) + 1 < (KdcNames + KdcNameSize /sizeof(WCHAR)))
            {
               // There's a bug in ksetup which adds a couple of "" strings to this, so...
               tmp = (ULONG) wcslen(Where) + 1;
            
               if (tmp > 1)
               {
                  NameCount++;
               }
               Where += tmp;
            }
            MitRealm->KdcNames.ServerNames = (PUNICODE_STRING) KerbAllocate(NameCount * sizeof(UNICODE_STRING));
            if (MitRealm->KdcNames.ServerNames == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            
            MitRealm->KdcNames.ServerCount = NameCount;
            
            Where = KdcNames;
            for (Index2 = 0;Index2 < NameCount; Index2++)
            {
                RtlInitUnicodeString(
                    &MitRealm->KdcNames.ServerNames[Index2],
                    Where
                    );

                // ugh.  Didn't want to have to allocate, but keep it simple.
                MitRealm->KdcNames.ServerNames[Index2].Buffer =
                    (LPWSTR) KerbAllocate(sizeof(WCHAR) * ((ULONG) wcslen(Where) + 2));

                if (NULL == MitRealm->KdcNames.ServerNames[Index2].Buffer)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                wcscpy(MitRealm->KdcNames.ServerNames[Index2].Buffer, Where);
                Where += MitRealm->KdcNames.ServerNames[Index2].Length / sizeof(WCHAR) + 1;
            }
    
            KerbFree(KdcNames);
            KdcNames = NULL;
        }


        if (NameCount == 0)
        {
            MitRealm->Flags |= KERB_MIT_REALM_KDC_LOOKUP;
        }


        NameCount = 0;
        if ((KpasswdNames != NULL ) && (KpasswdNameSize != 0))
        {
            Where = KpasswdNames;
            NameCount ++;
            while (Where + wcslen(Where) + 1 - (KpasswdNames + KpasswdNameSize /sizeof(WCHAR)) > 0)
            {
                NameCount++;
                Where += wcslen(Where)+1;
            }
            MitRealm->KpasswdNames.ServerNames = (PUNICODE_STRING) KerbAllocate(NameCount * sizeof(UNICODE_STRING));
            if (MitRealm->KpasswdNames.ServerNames == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
            
            MitRealm->KpasswdNames.ServerCount = NameCount;
            
            Where = KpasswdNames;
            for (Index2 = 0;Index2 < NameCount; Index2++)
            {
                RtlInitUnicodeString(
                    &MitRealm->KpasswdNames.ServerNames[Index2],
                    Where
                    );

                // ugh.  Didn't want to have to allocate, but keep it simple.
                MitRealm->KpasswdNames.ServerNames[Index2].Buffer =
                    (LPWSTR) KerbAllocate(sizeof(WCHAR) * ((ULONG) wcslen(Where) + 2));

                if (NULL == MitRealm->KpasswdNames.ServerNames[Index2].Buffer)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }

                wcscpy(MitRealm->KpasswdNames.ServerNames[Index2].Buffer, Where);
                Where += MitRealm->KpasswdNames.ServerNames[Index2].Length / sizeof(WCHAR) + 1;
            }

            KerbFree(KpasswdNames);
            KpasswdNames = NULL;
        }

        if (NameCount == 0)
        {
            MitRealm->Flags |= KERB_MIT_REALM_KPWD_LOOKUP;
        }

        KerbInsertListEntry(
            &MitRealm->Next,
            &KerbMitRealmList
            );
        MitRealm = NULL;

    } // ** FOR **
    

Cleanup:

    if (fListLocked)
    {
        KerbUnlockList(&KerbMitRealmList);
    }

    if( DomainKey != NULL )
    {
        RegCloseKey( DomainKey );
    }

    if (KdcNames != NULL)
    {
        KerbFree(KdcNames);
    }
    if (KpasswdNames != NULL)
    {
        KerbFree(KpasswdNames);
    }
    if (AlternateRealmNames != NULL)
    {
        KerbFree(AlternateRealmNames);
    }
    if (MitRealm != NULL)
    {
        if (MitRealm->AlternateRealmNames != NULL)
        {
#if 0   // note: embededded buffers are all enclosed within AlternateRealmNames[0]
            for(Index = 0 ; Index < MitRealm->RealmNameCount ; Index++)
            {
                if (MitRealm->AlternateRealmNames[Index].Buffer != NULL)
                {
                    KerbFree(MitRealm->AlternateRealmNames[Index].Buffer);
                }
            }
#else
            if (MitRealm->AlternateRealmNames[0].Buffer != NULL)
            {
                KerbFree(MitRealm->AlternateRealmNames[0].Buffer);
            }
#endif

            KerbFree(MitRealm->AlternateRealmNames);
        }
        if (MitRealm->KdcNames.ServerNames != NULL)
        {
            LONG lIndex;

            for(lIndex = 0 ; lIndex < MitRealm->KdcNames.ServerCount ; lIndex++)
            {
                if (MitRealm->KdcNames.ServerNames[lIndex].Buffer != NULL)
                {
                    KerbFree(MitRealm->KdcNames.ServerNames[lIndex].Buffer);
                }
            }

            KerbFree(MitRealm->KdcNames.ServerNames);
        }
        if (MitRealm->KpasswdNames.ServerNames != NULL)
        {
            LONG lIndex;

            for(lIndex = 0 ; lIndex < MitRealm->KpasswdNames.ServerCount ; lIndex++)
            {
                if (MitRealm->KpasswdNames.ServerNames[lIndex].Buffer != NULL)
                {
                    KerbFree(MitRealm->KpasswdNames.ServerNames[lIndex].Buffer);
                }
            }

            KerbFree(MitRealm->KpasswdNames.ServerNames);
        }
        KerbFree(MitRealm);
    }
    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCleanupMitRealmList
//
//  Synopsis:   Frees the list of MIT realms
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbCleanupMitRealmList(
    )
{
    PKERB_MIT_REALM MitRealm;
    BOOLEAN ListLocked = FALSE;

    KerbLockList(&KerbMitRealmList);
    ListLocked = TRUE;

    if (KerbMitRealmList.List.Flink == NULL)
    {
        goto Cleanup;
    }

    while (!IsListEmpty(&KerbMitRealmList.List))
    {
        MitRealm = CONTAINING_RECORD(
                        KerbMitRealmList.List.Flink,
                        KERB_MIT_REALM,
                        Next
                            );

        KerbReferenceListEntry(
            &KerbMitRealmList,
            &MitRealm->Next,
            TRUE
            );

        if (MitRealm->AlternateRealmNames != NULL)
        {
            if (MitRealm->AlternateRealmNames[0].Buffer != NULL)
            {
                KerbFree(MitRealm->AlternateRealmNames[0].Buffer);
            }
            KerbFree(MitRealm->AlternateRealmNames);
        }

        if (MitRealm->KdcNames.ServerNames != NULL)
        {
            LONG lIndex;

            for(lIndex = 0 ; lIndex < MitRealm->KdcNames.ServerCount ; lIndex++)
            {
                if (MitRealm->KdcNames.ServerNames[lIndex].Buffer != NULL)
                {
                    KerbFree(MitRealm->KdcNames.ServerNames[lIndex].Buffer);
                }
            }

            KerbFree(MitRealm->KdcNames.ServerNames);
        }
        if (MitRealm->KpasswdNames.ServerNames != NULL)
        {
            LONG lIndex;

            for(lIndex = 0 ; lIndex < MitRealm->KpasswdNames.ServerCount ; lIndex++)
            {
                if (MitRealm->KpasswdNames.ServerNames[lIndex].Buffer != NULL)
                {
                    KerbFree(MitRealm->KpasswdNames.ServerNames[lIndex].Buffer);
                }
            }

            KerbFree(MitRealm->KpasswdNames.ServerNames);
        }

        if (MitRealm->RealmName.Buffer != NULL)
        {
           MIDL_user_free(MitRealm->RealmName.Buffer);        

        }
                                              
        KerbFree(MitRealm);
    }

    KerbUnlockList(&KerbMitRealmList);
    ListLocked = FALSE;

    //
    // Purge our old entries.
    //
    KerbCleanupBindingCache(FALSE);



Cleanup:
    if ( ListLocked )
    {   
        KerbUnlockList(&KerbMitRealmList);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbLookupMitRealm
//
//  Synopsis:   Looks up an MIT realm name
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbLookupMitRealm(
    IN PUNICODE_STRING RealmName,
    OUT OPTIONAL PKERB_MIT_REALM* MitRealm,
    OUT OPTIONAL PBOOLEAN UsedAlternateName
    )                                                                                                                     
{
    ULONG Index;
    PLIST_ENTRY ListEntry;
    PKERB_MIT_REALM CurrentRealm;
    BOOLEAN fReturn = FALSE;
    BOOLEAN fListLocked = FALSE;

    if (UsedAlternateName) 
    {
        *UsedAlternateName = FALSE;
    }

    if (MitRealm) 
    {
        *MitRealm = NULL;
    }

    if (RealmName->Length == 0)
    {
        goto Cleanup;
    }

    KerbLockList(&KerbMitRealmList);
    fListLocked = TRUE;

    for (ListEntry = KerbMitRealmList.List.Flink ;
         ListEntry != &KerbMitRealmList.List ;
         ListEntry = ListEntry->Flink )
    {
        CurrentRealm = CONTAINING_RECORD(ListEntry, KERB_MIT_REALM, Next);

        if (RtlEqualUnicodeString(
                RealmName,
                &CurrentRealm->RealmName,
                TRUE))
        {
            if (MitRealm) 
            {
                *MitRealm = CurrentRealm;
            }

            fReturn = TRUE;
            goto Cleanup;
        }

        //
        // Check for an alternate name for the realm
        //

        for (Index = 0; Index < CurrentRealm->RealmNameCount ; Index++ )
        {
            if (RtlEqualUnicodeString(
                    RealmName,
                    &CurrentRealm->AlternateRealmNames[Index],
                    TRUE))
            {
                if (UsedAlternateName) 
                {
                    *UsedAlternateName = TRUE;
                }

                if (MitRealm) 
                {
                    *MitRealm = CurrentRealm;
                }

                fReturn = TRUE;
                goto Cleanup;
            }
        }
    }
Cleanup:
    if (fListLocked)
    {
        KerbUnlockList(&KerbMitRealmList);
    }
    return(fReturn);

}

////////////////////////////////////////////////////////////////////
//
//  Name:       KerbWatchMITKey
//
//  Synopsis:   Sets RegNotifyChangeKeyValue() on MIT key and
//              utilizes thread pool to wait on changes to this
//              registry key.  Enables dynamic changing of MIT
//              realms as this function will also be callback
//              if the registry key is modified.
//
//  Arguments:  pCtxt is actually a HANDLE to an event.  This event
//              will be triggered when key is modified.
//
//  Notes:      
//

void
KerbWatchMITKey(PVOID    pCtxt,
                BOOLEAN  fWaitStatus)
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG Error;
   

    KerbCleanupMitRealmList();
    Status = KerbReadMitRealmList();
    if (!NT_SUCCESS(Status)) 
    {
        D_DebugLog((DEB_ERROR,"Debug reading MIT realm list failed: 0x%x\n", Status));
    }

    if (NULL != hKerbMITRealmWaitEvent)
    {
        Error = RegNotifyChangeKeyValue(
                    KerbMITRealmRootKey,
                    TRUE,
                    REG_NOTIFY_CHANGE_LAST_SET | REG_NOTIFY_CHANGE_NAME,
                    hKerbMITRealmWaitEvent,
                    TRUE);

        if (ERROR_SUCCESS != Error) 
        {
            D_DebugLog((DEB_ERROR,"Debug RegNotify setup failed: 0x%x\n", Status));
            // we're tanked now. No further notifications, so get this one
        }
    }

    return; 
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeMitRealmList
//
//  Synopsis:   Loads the list of MIT realms from the registry
//
//  Effects:    Initialize and links domains to KerbMitRealmList
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitializeMitRealmList(
    )
{
    ULONG Disposition;
    ULONG Error;
    HKEY RootKey = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Open the domains root key - if it is not there, so be it.
    //

    Error = RegCreateKeyEx(
                HKEY_LOCAL_MACHINE,
                KERB_DOMAINS_KEY,
                0,
                NULL,
                0,
                KEY_READ,
                NULL,
                &RootKey,
                &Disposition);

    if (ERROR_SUCCESS != Error)
    {
        D_DebugLog((DEB_WARN,"Failed to open MIT realm key: 0x%x\n", Status));
        Status = STATUS_UNSUCCESSFUL;
        goto Cleanup;
    }

    //
    // Initialize the list
    //
    Status = KerbInitializeList( &KerbMitRealmList, MIT_REALM_LIST_LOCK_ENUM );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_ERROR, "Intialization of MIT realm list failed - 0x%x\n", Status));
        goto Cleanup;
    }

    hKerbMITRealmWaitEvent = CreateEventW( NULL, FALSE, FALSE, NULL );

    if (NULL == hKerbMITRealmWaitEvent) 
    {
        D_DebugLog((DEB_ERROR, "CreateEvent for MIT realm list wait failed - 0x%x\n", GetLastError()));
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }


    KerbMITRealmRootKey = RootKey;
    RootKey = NULL;

    //
    // read in the list and setup the RegNotify
    //
    KerbWatchMITKey(NULL, FALSE);

    hKerbMITRealmWaitObject = RegisterWaitForSingleObjectEx(
                                    hKerbMITRealmWaitEvent,
                                    KerbWatchMITKey,
                                    NULL,
                                    INFINITE,
                                    0 // dwFlags
                                    );

Cleanup:

    if( RootKey != NULL )
    {
        RegCloseKey( RootKey );
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbUninitializeMitRealmList
//
//  Synopsis:   Loads the list of MIT realms from the registry
//
//  Effects:    Initialize and links domains to KerbMitRealmList
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbUninitializeMitRealmList(
    )
{
    if( hKerbMITRealmWaitObject )
        UnregisterWait( hKerbMITRealmWaitObject );

    if( hKerbMITRealmWaitEvent )
        CloseHandle( hKerbMITRealmWaitEvent );

    KerbCleanupMitRealmList();

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbLookupMitSrvRecords
//
//  Synopsis:   Looks up MIT KDCs / Kpassword in DNS
//
//  Effects:    Builds MIT_SERVER_LIST for specified realm, and adds it to
//              MIT REALM LIST
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
NTSTATUS
KerbLookupMitSrvRecords(IN PKERB_MIT_REALM RealmEntry,
                        IN BOOLEAN Kpasswd,
                        IN BOOLEAN UseTcp
                        )
{
   
   ANSI_STRING DnsRecordName; 
   ANSI_STRING AnsiRealmName;
   HANDLE SrvContext = NULL;
   BOOLEAN ListLocked = FALSE;
   NTSTATUS Status = STATUS_SUCCESS;
   ULONG AddressCount = 0, SrvCount = 0;
   ULONG Index = 0, uBuff = 0;
   LPSOCKET_ADDRESS Addresses = NULL;
   NET_API_STATUS NetApiStatus = NERR_Success;
   LPSTR pDnsName[MAX_SRV_RECORDS];
   
   PKERB_MIT_SERVER_LIST ServerList = NULL;
   PUNICODE_STRING       ServerNames = NULL;

   TimeStamp CurrentTime, Timeout;
   
   
   //
   // Test to see if we need to do a lookup, or if its time to try again
   //
   if (RealmEntry->LastLookup.QuadPart != 0 )
   {  
       GetSystemTimeAsFileTime((PFILETIME)  &CurrentTime );  
       KerbSetTimeInMinutes(&Timeout, DNS_LOOKUP_TIMEOUT);
      
       if (KerbGetTime(RealmEntry->LastLookup) + KerbGetTime(Timeout) < KerbGetTime(CurrentTime))
       {
          return STATUS_SUCCESS;
       }
   }
   // Kpasswd only uses UDP
   if (Kpasswd)
   {
      UseTcp = FALSE;
   } 
                           
   
   RtlInitAnsiString(&DnsRecordName,NULL);
   RtlInitAnsiString(&AnsiRealmName,NULL);
   DnsRecordName.Length = (RealmEntry->RealmName.Length / sizeof(WCHAR)) + DNS_MAX_PREFIX + 1;
   DnsRecordName.MaximumLength = DnsRecordName.Length;
   SafeAllocaAllocate(DnsRecordName.Buffer, DnsRecordName.Length);

   if (NULL == DnsRecordName.Buffer)
   {
      return STATUS_INSUFFICIENT_RESOURCES;
   }

   RtlUnicodeStringToAnsiString(
         &AnsiRealmName,
         &RealmEntry->RealmName,
         TRUE
         );


   sprintf(DnsRecordName.Buffer,
           "%s%s%s",
           (Kpasswd ? DNS_KPASSWD : DNS_KERBEROS),
           (UseTcp ? DNS_TCP : DNS_UDP),
           AnsiRealmName.Buffer
           );

   NetApiStatus = NetpSrvOpen(
                     DnsRecordName.Buffer,
                     0,
                     &SrvContext
                     );

   if (NERR_Success != NetApiStatus)
   {
      D_DebugLog((DEB_WARN, 
                "No SRV records for MIT Realm %wZ - %x\n", 
                RealmEntry->RealmName, 
                NetApiStatus
                ));
      
      Status = STATUS_SUCCESS;
      goto Cleanup;
   }  

   // Loop and update server list for realm 
   for (SrvCount = 0; SrvCount < MAX_SRV_RECORDS; SrvCount++)
   {

      NetApiStatus = NetpSrvNext(
                        SrvContext,
                        &AddressCount,
                        &Addresses,
                        &pDnsName[SrvCount]
                        );

      if (NERR_Success != NetApiStatus)
      {
        if( ERROR_NO_MORE_ITEMS == NetApiStatus) // we're through
        {
           NetApiStatus = NERR_Success;
           break;
        }

        D_DebugLog((DEB_ERROR, "NetpSrvNext failed: %s - %x\n",DnsRecordName.Buffer, NetApiStatus));
        Status = NetApiStatus;
        goto Cleanup;
      }
      
   }

   
   KerbLockList(&KerbMitRealmList);
   ListLocked = TRUE;
   // Loop through available server names, and copy
   if (Kpasswd)
   {
      ServerList = &RealmEntry->KpasswdNames;
   }
   else 
   {
      ServerList = &RealmEntry->KdcNames;
   }
   
   // reg entries are always at beginning of server list.
   uBuff = ( SrvCount  * sizeof(UNICODE_STRING));

   ServerNames = (PUNICODE_STRING) KerbAllocate(uBuff);

   if (NULL == ServerNames)
   {
      Status = STATUS_INSUFFICIENT_RESOURCES;
      goto Cleanup;
   }
   
                                              
   for (Index = 0; Index < SrvCount;Index++)
   {
      if (!KerbMbStringToUnicodeString(
                        &ServerNames[Index ],
                        pDnsName[Index]
                        )) 
      {
         D_DebugLog((DEB_ERROR,"KerbConvertMbStringToUnicodeString failed!\n"));
         continue; // let's keep going.  Maybe we're not hosed.
      }
   }
   
   KerbFreeServerNames(ServerList);
   ServerList->ServerCount = SrvCount;
   ServerList->ServerNames = ServerNames;

   RealmEntry->Flags 
       &= ~( Kpasswd ? KERB_MIT_REALM_KPWD_LOOKUP : KERB_MIT_REALM_KDC_LOOKUP );

Cleanup:
   
    // always update realm entry, even on failure
    if (!ListLocked)
    {   
        KerbLockList(&KerbMitRealmList);
        ListLocked = TRUE;
    }                    
    
    GetSystemTimeAsFileTime((PFILETIME)  &RealmEntry->LastLookup);
   
    if (ListLocked)
    {
        KerbUnlockList(&KerbMitRealmList);
    }
   
    if (AnsiRealmName.Buffer != NULL)
    {                                    
        RtlFreeAnsiString(&AnsiRealmName);
    }

    SafeAllocaFree(DnsRecordName.Buffer);

    if (SrvContext != NULL)
    {
        NetpSrvClose(SrvContext);
    }             

    return Status;

}

//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeServerNames
//
//  Synopsis:   Frees server names PUNICODE_STRING array
//
//  Effects:    
//              
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
void
KerbFreeServerNames(PKERB_MIT_SERVER_LIST ServerList)
{
   LONG Index = 0;

   for (Index = 0; Index < ServerList->ServerCount; Index++)
   {
      if (ServerList->ServerNames[Index].Buffer != NULL)
      {
         KerbFree(ServerList->ServerNames[Index].Buffer);
      }                                  
   }

   KerbFree(ServerList->ServerNames); // free UNICODE_STRING array
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbLookupMitRealmWithSrvLookup
//
//  Synopsis:   Frees server names PUNICODE_STRING array
//
//  Effects:    
//              
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
BOOLEAN
KerbLookupMitRealmWithSrvLookup(PUNICODE_STRING RealmName,
                                PKERB_MIT_REALM* MitRealm,
                                BOOLEAN   Kpasswd,
                                BOOLEAN   UseTcp)
{
   BOOLEAN  UsedAlternateName, fRet = FALSE;
   NTSTATUS Status;

   fRet = KerbLookupMitRealm(
            RealmName,
            MitRealm,
            &UsedAlternateName
            );
   
   //
   // Found an MIT realm.  See if its time to check on SRV records
   //
   if ( fRet )
   {    

       if ((((*MitRealm)->Flags & KERB_MIT_REALM_KDC_LOOKUP) && !Kpasswd ) ||
           (((*MitRealm)->Flags & KERB_MIT_REALM_KPWD_LOOKUP) && Kpasswd ))
       {              
          Status = KerbLookupMitSrvRecords(
                        (*MitRealm), 
                        Kpasswd,
                        UseTcp
                        );
       
          if (Status != STATUS_SUCCESS)
          {
              D_DebugLog((DEB_TRACE, "KerbLookupMitRealmWIthSrvLookup failed - %x\n", Status));
          }
       }
   }
                                                                                     
   return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\rpcutil.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        rpcutil.h
//
// Contents:    prototypes and structures for RPC utilities
//
//
// History:     19-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __RPCUTIL_H__
#define __RPCUTIL_H__

#define KERB_LOCATOR_FLAGS (DS_KDC_REQUIRED | DS_IP_REQUIRED)
NTSTATUS
KerbGetKdcBinding(
    IN PUNICODE_STRING Realm,
    IN PUNICODE_STRING PrincipalName,
    IN ULONG DesiredFlags,
    IN BOOLEAN FindKpasswd,
    IN BOOLEAN UseTcp,
    OUT PKERB_BINDING_CACHE_ENTRY * BindingCacheEntry
    );

BOOLEAN
ReadInitialDcRecord(PUNICODE_STRING uString,
                    PULONG RegAddressType,
                    PULONG RegFlags);


#ifndef WIN32_CHICAGO
NTSTATUS
KerbInitKdcData();

VOID
KerbFreeKdcData();

NTSTATUS
KerbInitNetworkChangeEvent();

VOID
KerbSetKdcData(BOOLEAN fNewDomain, BOOLEAN fRebooted);

#endif // WIN32_CHICAGO

#endif // __RPCUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\pkauth.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        pkauth.cxx
//
// Contents:    Routines for supporting public-key authentication
//
//
// History:     14-October-1997         Created         MikeSw
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>

//#ifndef WIN32_CHICAGO
extern "C"
{
#include <stdlib.h>
#include <cryptdll.h>
}
//#endif // WIN32_CHICAGO


#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

KERB_OBJECT_ID KerbSignatureAlg[10];
#define KERB_SCLOGON_DOMAIN_SUFFIX L"-sclogon"
#define KERB_SCLOGON_DOMAIN_SUFFIX_SIZE (sizeof(KERB_SCLOGON_DOMAIN_SUFFIX) - sizeof(WCHAR))

#ifndef SHA1DIGESTLEN
#define SHA1DIGESTLEN 20
#endif

NTSTATUS
KerbInitializeHProvFromCert(
    IN PKERB_PUBLIC_KEY_CREDENTIALS PkCreds
    );


//+-------------------------------------------------------------------------
//
//  Function:   KerbComparePublicKeyCreds
//
//  Synopsis:   Verfies a certificate is valid for the specified usage
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


BOOL
KerbComparePublicKeyCreds(
    IN PKERB_PUBLIC_KEY_CREDENTIALS PkCreds1,
    IN PKERB_PUBLIC_KEY_CREDENTIALS PkCreds2
    )
{

    return CertCompareCertificate(
                X509_ASN_ENCODING,
                PkCreds1->CertContext->pCertInfo,
                PkCreds2->CertContext->pCertInfo
                );

    // more later?

    //return (fRet);

}




//+-------------------------------------------------------------------------
//
//  Function:   KerbCheckCertificate
//
//  Synopsis:   Verfies a certificate is valid for the specified usage
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbCheckCertificate(
    IN PCCERT_CONTEXT  CertContext,
    IN LPSTR Usage,
    IN BOOLEAN LocalLogon // AllowRevocationCheckFailure
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    CERT_CHAIN_PARA ChainParameters = {0};
    PCCERT_CHAIN_CONTEXT ChainContext = NULL;

    ChainParameters.cbSize = sizeof(CERT_CHAIN_PARA);
    ChainParameters.RequestedUsage.dwType = USAGE_MATCH_TYPE_AND;
    ChainParameters.RequestedUsage.Usage.cUsageIdentifier = 1;
    ChainParameters.RequestedUsage.Usage.rgpszUsageIdentifier = &Usage;



    if (!CertGetCertificateChain(
                                HCCE_LOCAL_MACHINE,
                                CertContext,
                                NULL,                 // evaluate at current time
                                NULL,                 // no additional stores
                                &ChainParameters,
                                (LocalLogon?
                                CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY|CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT:
                                CERT_CHAIN_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT),
                                NULL,                 // reserved
                                &ChainContext
                                ))
    {
        DebugLog((DEB_WARN,"Failed to verify certificate chain: %0x%x\n",GetLastError()));
        Status = STATUS_PKINIT_FAILURE;
    }
    else
    {
        CERT_CHAIN_POLICY_PARA ChainPolicy;
        CERT_CHAIN_POLICY_STATUS PolicyStatus;
        ZeroMemory(&ChainPolicy, sizeof(ChainPolicy));

        ChainPolicy.cbSize = sizeof(ChainPolicy);
        if (LocalLogon)
        {
            ChainPolicy.dwFlags = CERT_CHAIN_POLICY_IGNORE_ALL_REV_UNKNOWN_FLAGS;
        }

        ZeroMemory(&PolicyStatus, sizeof(PolicyStatus));
        PolicyStatus.cbSize = sizeof(PolicyStatus);
        PolicyStatus.lChainIndex = -1;
        PolicyStatus.lElementIndex = -1;

        if (!CertVerifyCertificateChainPolicy(
                                        CERT_CHAIN_POLICY_BASE,
                                        ChainContext,
                                        &ChainPolicy,
                                        &PolicyStatus))
        {
            DebugLog((DEB_WARN,"CertVerifyCertificateChainPolicy failure: %0x%x\n", GetLastError()));
            Status = STATUS_PKINIT_FAILURE;
        }

        if(PolicyStatus.dwError != S_OK)
        {
            DebugLog((DEB_WARN,"CertVerifyCertificateChainPolicy - Chain Status failure: %0x%x\n",PolicyStatus.dwError));
            KerbReportPkinitError(
                PolicyStatus.dwError,
                CertContext
                );

            Status = KerbMapCertChainError(PolicyStatus.dwError, FALSE);
        }
    }

    if (ChainContext != NULL)
    {
        CertFreeCertificateChain(ChainContext);
    }

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifyPkAsReply
//
//  Synopsis:   Verifies the reply from the KDC and retrieves the
//              ticket encryption key
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbVerifyPkAsReply(
    IN PKERB_PA_DATA_LIST InputPaData,
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    IN ULONG Nonce,
    OUT PKERB_ENCRYPTION_KEY EncryptionKey,
    OUT PBOOLEAN Done
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    PKERB_PA_PK_AS_REP Reply = NULL;
    PCCERT_CONTEXT KdcCertContext = NULL;
    PBYTE EncodedKeyPackage = NULL;
    ULONG KeyPackageSize = 0;
    PKERB_SIGNED_REPLY_KEY_PACKAGE KeyPackage = NULL;
    PKERB_REPLY_KEY_PACKAGE ReplyKeyPackage = NULL;
    PBYTE PackedKeyPack = NULL;
    ULONG PackedKeyPackSize = 0;
    HCRYPTKEY PrivateKey = NULL;
    PKERB_ENCRYPTION_KEY TempKey = NULL;
    HCRYPTPROV KdcProvider = NULL;
    BOOLEAN InitializedPkCreds = FALSE;

    NTSTATUS TokenStatus = STATUS_SUCCESS;
    HANDLE ImpersonationToken = NULL;


    *Done = TRUE;

    //
    // Unpack the request
    //

    KerbErr = KerbUnpackData(
                InputPaData->value.preauth_data.value,
                InputPaData->value.preauth_data.length,
                KERB_PA_PK_AS_REP_PDU,
                (PVOID *) &Reply
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if (Reply->choice != key_package_chosen)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Now we need to verify the signature on the message
    //
    //
    // Make sure the csp data is available
    //

    if ((Credentials->PublicKeyCreds->InitializationInfo & CSP_DATA_INITIALIZED) == 0)
    {
        Status  = KerbInitializePkCreds(
                        Credentials->PublicKeyCreds
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        InitializedPkCreds = TRUE;

    }
    else if ((Credentials->PublicKeyCreds->InitializationInfo & CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS) != 0)
    {
        // need to set the PIN and this function does that
        Status  = KerbInitializeHProvFromCert(
                        Credentials->PublicKeyCreds
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Decode the contents as an encrypted data buffer
    //


    Status = __ScHelperDecryptMessage(
                &Credentials->PublicKeyCreds->Pin,
                Credentials->PublicKeyCreds->CspData,
                Credentials->PublicKeyCreds->KerbHProv,
                Credentials->PublicKeyCreds->CertContext,
                Reply->u.key_package.value,
                Reply->u.key_package.length,
                EncodedKeyPackage,
                &KeyPackageSize
                );


    if ((Status != STATUS_BUFFER_TOO_SMALL) && (Status != STATUS_SUCCESS))
    {
        DebugLog((DEB_ERROR,"Failed to decrypt pkcs message: %x\n",Status));
        goto Cleanup;
    }

    SafeAllocaAllocate(EncodedKeyPackage, KeyPackageSize);

    if (EncodedKeyPackage == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = __ScHelperDecryptMessage(
                &Credentials->PublicKeyCreds->Pin,
                Credentials->PublicKeyCreds->CspData,
                Credentials->PublicKeyCreds->KerbHProv,
                Credentials->PublicKeyCreds->CertContext,
                Reply->u.key_package.value,
                Reply->u.key_package.length,
                EncodedKeyPackage,
                &KeyPackageSize
                );


    if (Status != STATUS_SUCCESS)
    {
        DebugLog((DEB_ERROR,"Failed to decrypt pkcs message: %x\n",Status));
        goto Cleanup;
    }

    //
    // Verify the signature
    //

    Status = ScHelperVerifyPkcsMessage(
                Credentials->PublicKeyCreds->CspData,
                NULL,                                   // we don't care which CSP is used for the verification
                EncodedKeyPackage,
                KeyPackageSize,
                PackedKeyPack,
                &PackedKeyPackSize,
                NULL        // don't return certificate context
                );
    if ((Status != STATUS_BUFFER_TOO_SMALL) && (Status != STATUS_SUCCESS))
    {
        DebugLog((DEB_ERROR,"Failed to verify message: %x\n",Status));
        goto Cleanup;
    }

    PackedKeyPack = (PBYTE) MIDL_user_allocate(PackedKeyPackSize);
    if (PackedKeyPack == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    Status = ScHelperVerifyPkcsMessage(
                Credentials->PublicKeyCreds->CspData,
                NULL,                                   // we don't care which CSP is used for the verification
                EncodedKeyPackage,
                KeyPackageSize,
                PackedKeyPack,
                &PackedKeyPackSize,
                &KdcCertContext
                );
    if (Status != STATUS_SUCCESS)
    {
        DebugLog((DEB_ERROR,"Failed to verify message: %x\n",Status));
        goto Cleanup;
    }

    KerbErr = KerbUnpackData(
                PackedKeyPack,
                PackedKeyPackSize,
                KERB_REPLY_KEY_PACKAGE_PDU,
                (PVOID *) &ReplyKeyPackage
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        D_DebugLog((DEB_ERROR,"Failed to unpack reply key package\n"));
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }
    if (Nonce != (ULONG) ReplyKeyPackage->nonce)
    {
        D_DebugLog((DEB_ERROR,"Returned nonce is not correct: 0x%x instead of 0x%x. %ws, line %d\n",
            ReplyKeyPackage->nonce, Nonce, THIS_FILE, __LINE__ ));
        Status = STATUS_LOGON_FAILURE;
        goto Cleanup;
    }

    //
    // Finally, copy the encryption key out and return it.
    //

    if (!KERB_SUCCESS(KerbDuplicateKey(
            EncryptionKey,
            &ReplyKeyPackage->reply_key
            )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Verify the certificate
    //
    // If we're impersonating, revert, and save off old token.  This keeps us from
    // going recursive.
    //
    // Are we impersonating?
    //
    TokenStatus = NtOpenThreadToken(
                    NtCurrentThread(),
                    TOKEN_QUERY | TOKEN_IMPERSONATE,
                    TRUE,
                    &ImpersonationToken
                    );

    if( NT_SUCCESS(TokenStatus) )
    {
        RevertToSelf();
    }
    else if (TokenStatus != STATUS_NO_TOKEN)
    {
        Status = TokenStatus;
        goto Cleanup;
    }

    Status = KerbCheckCertificate(
                KdcCertContext,
                KERB_PKINIT_KDC_CERT_TYPE,
                FALSE                           // don't allow revocation failures
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to verify KDC certificate: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

Cleanup:

    //
    // re-impersonate
    //
    if( ImpersonationToken != NULL ) {

        //
        // put the thread token back if we were impersonating.
        //
        SetThreadToken( NULL, ImpersonationToken );
        NtClose( ImpersonationToken );
    }



    //
    // If we initialized these, reset them
    //
    if (InitializedPkCreds)
    {
        KerbReleasePkCreds(
            NULL,
            Credentials->PublicKeyCreds,
            FALSE
            );
    }

    if (Reply != NULL)
    {
        KerbFreeData(
            KERB_PA_PK_AS_REP_PDU,
            Reply
            );
    }

    if (KdcCertContext != NULL)
    {
        CertFreeCertificateContext(KdcCertContext);
    }
    if (KeyPackage != NULL)
    {
        KerbFreeData(
            KERB_SIGNED_REPLY_KEY_PACKAGE_PDU,
            KeyPackage
            );
    }
    if (ReplyKeyPackage != NULL)
    {
        KerbFreeData(
            KERB_REPLY_KEY_PACKAGE_PDU,
            ReplyKeyPackage
            );
    }
    if (PackedKeyPack != NULL)
    {
        MIDL_user_free(PackedKeyPack);
    }
    if (PrivateKey != NULL)
    {
        CryptDestroyKey(PrivateKey);
    }
    if (TempKey != NULL)
    {
        KerbFreeData(
            KERB_ENCRYPTION_KEY_PDU,
            TempKey
            );
    }
    if (KdcProvider != NULL)
    {
        CryptReleaseContext(
            KdcProvider,
            0   // no flags
            );
    }

    SafeAllocaFree(EncodedKeyPackage);

    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbFreePKCreds
//
//  Synopsis:   Frees the public key creds
//
//  Effects:
//
//  Arguments:  OkForReuse - Allows us to release info which may not be valid,
//              but that we can reuse to reaquire a good ScHelperHandle.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreePKCreds(
    IN PKERB_PUBLIC_KEY_CREDENTIALS PkCreds,
    IN BOOLEAN OkForReuse
    )
{
    if ( NULL != PkCreds )
    {
        if ((( PkCreds->InitializationInfo & CSP_DATA_INITIALIZED ) != 0) &&
            (( PkCreds->InitializationInfo &
               (CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS | CONTEXT_INITIALIZED_WITH_ACH) ) == 0))
        {
            __ScHelperRelease(
                PkCreds->CspData
                );

            PkCreds->InitializationInfo &= ~CSP_DATA_INITIALIZED;
        }
        if ( PkCreds->KerbHProv != NULL )
        {
            __ScHelper_CryptReleaseContext( PkCreds->KerbHProv );
            PkCreds->KerbHProv = NULL;
        }
        if ( PkCreds->CertContext != NULL )
        {
            CertFreeCertificateContext( PkCreds->CertContext );
            PkCreds->CertContext = NULL;
        }

        if ( !OkForReuse )
        {
            RtlSecureZeroMemory(PkCreds->Pin.Buffer, PkCreds->Pin.MaximumLength);
            KerbFreeString( &PkCreds->Pin );
            KerbFree( PkCreds );
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeHProvFromCert
//
//  Synopsis:   Initializes the out parameter phProv by getting the key
//              prov info from the cert context and acquiring a CSP context
//              given this information.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbInitializeHProvFromCert(
    IN PKERB_PUBLIC_KEY_CREDENTIALS PkCreds
    )
{

    ULONG cPin;
    LPWSTR pwszPin = NULL;
    LPSTR pszPin = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD dw;

    if (PkCreds->KerbHProv != NULL)
    {
        goto Cleanup;
    }

    //
    // This function validates that the cert matches the key on the smartcard.
    //
    Status = __ScHelper_CryptAcquireCertificatePrivateKey(
                        PkCreds->CertContext,
                        &PkCreds->KerbHProv,
                        &dw);

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,
                  "CryptAcquireCertificatePrivateKey failed - %x\n",
                  Status));
        goto Cleanup;
    }


    //
    // Convert the pin to ANSI, but only for creds acquired by ACH, as the
    // credman isn't "allowed" to cache pins anymore..
    //
    if (( PkCreds->InitializationInfo & CONTEXT_INITIALIZED_WITH_ACH ) != 0)
    {

        if (0 == PkCreds->Pin.Length)
        {
            Status = STATUS_LOGON_FAILURE;
            goto Cleanup;
        }

        SafeAllocaAllocate(pwszPin, PkCreds->Pin.Length + sizeof(WCHAR));

        if (NULL == pwszPin)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(pwszPin, PkCreds->Pin.Buffer, PkCreds->Pin.Length);
        pwszPin[PkCreds->Pin.Length / sizeof(WCHAR)] = L'\0';

        cPin = WideCharToMultiByte(
                    GetACP(),
                    0,
                    pwszPin,
                    -1,
                    NULL,
                    0,
                    NULL,
                    NULL);

        SafeAllocaAllocate(pszPin, (cPin + 1) * sizeof(CHAR));

        if (NULL == pszPin)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        cPin = WideCharToMultiByte(
                    GetACP(),
                    0,
                    pwszPin,
                    -1,
                    pszPin,
                    cPin,
                    NULL,
                    NULL);

        Status = __ScHelper_CryptSetProvParam(
                    PkCreds->KerbHProv,
                    pszPin,
                    &dw
                    );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "CryptSetProvParam failed %x\n", Status));
            goto Cleanup;
        }
    }



Cleanup:

    SafeAllocaFree(pwszPin);
    SafeAllocaFree(pszPin);

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializePkCreds
//
//  Synopsis:   Initializes or re-initailizes the smart card data in
//              the public key creds
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbInitializePkCreds(
    IN PKERB_PUBLIC_KEY_CREDENTIALS PkCreds
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if ((PkCreds->InitializationInfo & CSP_DATA_INITIALIZED) == 0)
    {

        //
        // Credman and explicit creds
        //

        if (((PkCreds->InitializationInfo & CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS) == 0) &&
            ((PkCreds->InitializationInfo & CONTEXT_INITIALIZED_WITH_ACH) == 0))
        {

            //
            // This is the default logon case - we're using data just handed to us
            // from LsaLogonUser().
            //
            Status  = __ScHelperInitializeContext(
                            PkCreds->CspData,
                            PkCreds->CspDataLength
                            );
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_ERROR,"ScHelperInitializeContext failed- %x\n", Status));
                goto Cleanup;
            }
            PkCreds->InitializationInfo |= CSP_DATA_INITIALIZED;
        }
        else
        {
            if (PkCreds->CertContext == NULL)
            {
                D_DebugLog((DEB_ERROR,"Using cred man creds but cert context is NULL.\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            PkCreds->InitializationInfo |= CSP_DATA_INITIALIZED;
        }

    }

    if (PkCreds->CertContext == NULL)
    {
        Status = __ScHelperGetCertFromLogonInfo(
                    PkCreds->CspData,
                    &PkCreds->Pin,
                    &PkCreds->CertContext
                    );

        if (Status != STATUS_SUCCESS)
        {
            DebugLog((DEB_ERROR,"Failed to get cert from logon info: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
            if (NT_SUCCESS(Status))
            {
                Status = STATUS_LOGON_FAILURE;
            }
            goto Cleanup;
        }

    }

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        if (((PkCreds->InitializationInfo & CSP_DATA_INITIALIZED) != 0) &&
            ((PkCreds->InitializationInfo & ( CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS | CONTEXT_INITIALIZED_WITH_ACH)) == 0))
        {
            __ScHelperRelease(
                PkCreds->CspData
                );

            PkCreds->InitializationInfo &= ~CSP_DATA_INITIALIZED;
        }
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReleasePkCreds
//
//  Synopsis:   Releaes smart-card resources in the public key creds.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbReleasePkCreds(
    IN OPTIONAL PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_PUBLIC_KEY_CREDENTIALS PkCreds,
    IN BOOLEAN  OkForReuse
    )
{

    if (ARGUMENT_PRESENT(LogonSession))
    {
        KerbWriteLockLogonSessions(
            LogonSession
            );
        PkCreds = LogonSession->PrimaryCredentials.PublicKeyCreds;
    }

    KerbFreePKCreds(PkCreds, OkForReuse);

    if (ARGUMENT_PRESENT(LogonSession))
    {
        if (!OkForReuse)
        {
            LogonSession->PrimaryCredentials.PublicKeyCreds = NULL;
        }
        else
        {
            LogonSession->PrimaryCredentials.PublicKeyCreds->InitializationInfo |= CSP_DATA_REUSED;
        }

        KerbUnlockLogonSessions(
            LogonSession
            );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbComputePkAuthenticatorSignature
//
//  Synopsis:   Computes the signature of the PK authenticator by
//              marshalling the authenticator, checksumming it, then
//              encrypting the checksum with the public key, more or less
//
//  Effects:
//
//  Arguments:  AuthPackage - authenticator to sign
//              Credentials - Client's credentials (containing keys)
//              Signature - receives signature
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbComputePkAuthenticatorSignature(
    IN PKERB_AUTH_PACKAGE AuthPackage,
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    OUT PKERB_SIGNATURE Signature
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERBERR KerbErr = KDC_ERR_NONE;
    PBYTE PackedAuthenticator = NULL;
    ULONG PackedAuthenticatorSize;
    BOOLEAN InitializedPkCreds = FALSE;
    PUNICODE_STRING TmpPin = NULL;

#define KERB_PK_MAX_SIGNATURE_SIZE 128
    BYTE PkSignature[KERB_PK_MAX_SIGNATURE_SIZE];
    ULONG PkSignatureLength = KERB_PK_MAX_SIGNATURE_SIZE;


    RtlZeroMemory(
        Signature,
        sizeof(KERB_SIGNATURE)
        );

    //
    // First marshall the auth package
    //

    KerbErr = KerbPackData(
                AuthPackage,
                KERB_AUTH_PACKAGE_PDU,
                &PackedAuthenticatorSize,
                &PackedAuthenticator
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    //
    // Make sure the csp data is available
    //

    if ((Credentials->PublicKeyCreds->InitializationInfo & CSP_DATA_INITIALIZED) == 0)
    {
        Status  = KerbInitializePkCreds(
                        Credentials->PublicKeyCreds
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        InitializedPkCreds = TRUE;

    }
    else if (((Credentials->PublicKeyCreds->InitializationInfo
               & (CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS | CONTEXT_INITIALIZED_WITH_ACH)) != 0))

    {
        // need to set the PIN and this function does that
        Status  = KerbInitializeHProvFromCert(
                        Credentials->PublicKeyCreds
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }



    // Initialize the PIN for ScHelperSignPkcs routines.
    if (((Credentials->PublicKeyCreds->InitializationInfo & CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS) == 0) &&
        (Credentials->PublicKeyCreds->Pin.Buffer != NULL))
    {
        TmpPin = &Credentials->PublicKeyCreds->Pin;
    }




    //
    // Now generate the checksum
    //


    Status = __ScHelperSignMessage(
                TmpPin,
                Credentials->PublicKeyCreds->CspData,
                Credentials->PublicKeyCreds->KerbHProv,
                KERB_PKINIT_SIGNATURE_ALG,
                PackedAuthenticator,
                PackedAuthenticatorSize,
                PkSignature,
                &PkSignatureLength
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to sign message with card: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Build the signature
    //


    Signature->signature_algorithm.algorithm = KerbSignatureAlg;

    //
    // Copy the temporary signature into the return structure
    //

    Signature->pkcs_signature.length = PkSignatureLength * 8; // because it is a bit string
    Signature->pkcs_signature.value = (PBYTE) KerbAllocate( PkSignatureLength );
    if (Signature->pkcs_signature.value == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    RtlCopyMemory(
        Signature->pkcs_signature.value,
        PkSignature,
        PkSignatureLength
        );


    Status = STATUS_SUCCESS;



Cleanup:
    if (InitializedPkCreds)
    {
        KerbReleasePkCreds(
            NULL,
            Credentials->PublicKeyCreds,
            FALSE
            );

    }



    if (PackedAuthenticator != NULL)
    {
        MIDL_user_free(PackedAuthenticator);
    }
    return(Status);

}

NTSTATUS
KerbGetProvParamWrapper(
    IN PUNICODE_STRING pPin,
    IN PBYTE pbLogonInfo,
    IN OPTIONAL ULONG_PTR KerbHProv,
    DWORD dwParam,
    BYTE*pbData,
    DWORD *pdwDataLen,
    DWORD dwFlags
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    Status = __ScHelperGetProvParam(
            pPin,
            pbLogonInfo,
            KerbHProv,
            dwParam,
            pbData,
            pdwDataLen,
            dwFlags
            );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failure in SC subsytem - %x\n",Status));
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetSmartCardAlgorithms
//
//  Synopsis:   Gets the supported encryption types from the
//              smart card provider
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetSmartCardAlgorithms(
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    OUT PKERB_CRYPT_LIST * CryptList
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PROV_ENUMALGS Data;
    ULONG DataSize;
    ULONG Flags = CRYPT_FIRST;
#define KERB_SUPPORTED_PK_CRYPT_COUNT 2

    ULONG CryptTypes[KERB_SUPPORTED_PK_CRYPT_COUNT];
    ULONG CryptCount = 0;

    //
    // Enumerate through to get the encrypt types
    //

    while (1)
    {
        DataSize = sizeof(Data);
        Status = KerbGetProvParamWrapper(
                    &Credentials->PublicKeyCreds->Pin,
                    Credentials->PublicKeyCreds->CspData,
                    Credentials->PublicKeyCreds->KerbHProv,
                    PP_ENUMALGS,
                    (BYTE *) &Data,
                    &DataSize,
                    Flags
                    );

        if (Status == STATUS_NO_MORE_ENTRIES)
        {
            Status = STATUS_SUCCESS;
            break;
        }

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "GetProvPram failed: 0x%x\n", Status));
            return(Status);
        }

        //
        // Reset the flags to enumerate though
        //

        Flags = 0;    // CRYPT_NEXT

        //
        // Check if it is an encryption algorithm. We only want
        // to know about 3des and RC4
        //


        if (GET_ALG_CLASS(Data.aiAlgid) == ALG_CLASS_DATA_ENCRYPT)
        {
            //
            // Check the type
            //

            if (GET_ALG_TYPE(Data.aiAlgid) == ALG_TYPE_BLOCK)
            {
                //
                // Check for 3des
                //

                if (GET_ALG_SID(Data.aiAlgid) == ALG_SID_3DES)
                {
                    //
                    // Add it to the list.
                    //
                    CryptTypes[CryptCount++] = KERB_ETYPE_DES_EDE3_CBC_ENV;
                }
                else if (GET_ALG_SID(Data.aiAlgid) == ALG_SID_RC2)
                {
                    //
                    // Add it to the list.
                    //
                    CryptTypes[CryptCount++] = KERB_ETYPE_RC2_CBC_ENV;
                }

            }
        }
        if (CryptCount == KERB_SUPPORTED_PK_CRYPT_COUNT)
        {
            break;
        }

    }

    //
    // Now, if there are any crypt types, convert them.
    //

    if (CryptCount != 0)
    {
        KERBERR KerbErr;

        KerbErr = KerbConvertArrayToCryptList(
                    CryptList,
                    CryptTypes,
                    CryptCount,
                    FALSE
                    );
        return(KerbMapKerbError(KerbErr));
    }
    else
    {
        //
        // We needed one of these, so bail now.
        //

        DebugLog((DEB_ERROR,"Smart card doesn't support rc2 or 3des for logon - failing out.\n"));

        return(STATUS_CRYPTO_SYSTEM_INVALID);
    }

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildPkinitPreAuthData
//
//  Synopsis:   Builds the pre-auth data for a PK-INIT AS request
//
//  Effects:
//
//  Arguments:  Credentials - Credentials to use for this request
//              InputPaData - Any PA data returned from DC on previous
//                      call
//              TimeSkew - Known time skew with KDC
//              ServiceName - Name for which we are requesting a ticket
//              RealmName - name of realm in which we are requesting a ticket
//              PreAuthData - receives new PA data
//              Done - if returned as TRUE, then routine need not be called
//                      again
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbBuildPkinitPreauthData(
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    IN OPTIONAL PKERB_PA_DATA_LIST InputPaData,
    IN PTimeStamp TimeSkew,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN PUNICODE_STRING RealmName,
    IN ULONG Nonce,
    OUT PKERB_PA_DATA_LIST * PreAuthData,
    OUT PKERB_ENCRYPTION_KEY EncryptionKey,
    OUT PKERB_CRYPT_LIST * CryptList,
    OUT PBOOLEAN Done
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    KERB_PA_PK_AS_REQ Request = {0};
    KERB_AUTH_PACKAGE AuthPack = {0};
    PKERB_PA_DATA_LIST ListElement = NULL;
    ULONG PackedRequestSize = 0;
    PBYTE PackedRequest = NULL;
    PBYTE PackedAuthPack = NULL;
    ULONG PackedAuthPackSize = 0;
    PBYTE SignedAuthPack = NULL;
    ULONG SignedAuthPackSize = 0;
    TimeStamp TimeNow;
    KERBERR KerbErr;
    BOOLEAN FreePkCreds = FALSE;
    CRYPT_ALGORITHM_IDENTIFIER CryptAlg = {0};
    PUNICODE_STRING TmpPin = NULL;
    BOOLEAN CleartextPin = FALSE;


    //
    // For the duration of this function, reveal the pin from 
    // its encrypted form.
    //

    if ( Credentials->PublicKeyCreds->Pin.Buffer )
    {
       KerbRevealPassword(&Credentials->PublicKeyCreds->Pin);   
       CleartextPin = TRUE;
    }


    //
    // If there is any input, check to see if we succeeded the last time
    // around
    //

    if (ARGUMENT_PRESENT(InputPaData))
    {
        Status = KerbVerifyPkAsReply(
                    InputPaData,
                    Credentials,
                    Nonce,
                    EncryptionKey,
                    Done
                    );
        goto Cleanup;
    }

    //
    // Make sure the csp data is available
    //

    if ((Credentials->PublicKeyCreds->InitializationInfo & CSP_DATA_INITIALIZED) == 0)
    {
        Status  = KerbInitializePkCreds(
                        Credentials->PublicKeyCreds
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // In some cases, we free up the cspdata, then reacquire it later.  This
        // is a hack for TS cases, where the SC rpc server dies when the temp
        // winlogon session goes away, thus invalidating the SChelper handle. But,
        // once we've reacquired it, we should hold onto it.
        //
        if ((Credentials->PublicKeyCreds->InitializationInfo & CSP_DATA_REUSED) == 0)
        {
            FreePkCreds = TRUE;
        }

    }
    else if (((Credentials->PublicKeyCreds->InitializationInfo
               & (CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS | CONTEXT_INITIALIZED_WITH_ACH)) != 0))
    {
        // need to set the PIN and this function does that
        Status  = KerbInitializeHProvFromCert(
                        Credentials->PublicKeyCreds
                        );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }


    // Initialize the PIN for ScHelperSignPkcs routines.
    if (((Credentials->PublicKeyCreds->InitializationInfo & CONTEXT_INITIALIZED_WITH_CRED_MAN_CREDS) == 0) &&
        (Credentials->PublicKeyCreds->Pin.Buffer != NULL))
    {
        TmpPin = &Credentials->PublicKeyCreds->Pin;
    }


    Status = KerbGetSmartCardAlgorithms(
                Credentials,
                CryptList
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to get crypt list for smart card: 0x%x\n",
            Status));
        goto Cleanup;
    }

    //
    // Do the new pa-pk-as-req
    //


    //
    // Now comes the hard part - the PK authenticator
    //

    //
    // First the KDC name
    //

    if (!KERB_SUCCESS(
            KerbConvertKdcNameToPrincipalName(
                &AuthPack.pk_authenticator.kdc_name,
                ServiceName
                )))
    {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Then the realm
    //

    if (!KERB_SUCCESS(
            KerbConvertUnicodeStringToRealm(
                &AuthPack.pk_authenticator.kdc_realm,
                RealmName)))
    {
        Status = STATUS_SUCCESS;
        goto Cleanup;
    }

    //
    // Now the time
    //

    GetSystemTimeAsFileTime((PFILETIME) &TimeNow);

#ifndef WIN32_CHICAGO
    TimeNow.QuadPart += TimeSkew->QuadPart;
#else // !WIN32_CHICAGO
    TimeNow += *TimeSkew;
#endif // WIN32_CHICAGO

    KerbConvertLargeIntToGeneralizedTimeWrapper(
        &AuthPack.pk_authenticator.client_time,
        &AuthPack.pk_authenticator.cusec,
        &TimeNow);

    //
    // And finally the nonce
    //

    AuthPack.pk_authenticator.nonce = Nonce;


    //
    // Pack up the auth pack so we can sign it
    //

    KerbErr = KerbPackData(
                &AuthPack,
                KERB_AUTH_PACKAGE_PDU,
                &PackedAuthPackSize,
                &PackedAuthPack
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to pack auth package\n"));
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Now sign it.
    //


    //
    // Now generate the checksum
    //


    CryptAlg.pszObjId = KERB_PKINIT_SIGNATURE_OID;


    Status = __ScHelperSignPkcsMessage(
                TmpPin,
                Credentials->PublicKeyCreds->CspData,
                Credentials->PublicKeyCreds->KerbHProv,
                Credentials->PublicKeyCreds->CertContext,
                &CryptAlg,
                CRYPT_MESSAGE_SILENT_KEYSET_FLAG, // dwSignMessageFlags
                PackedAuthPack,
                PackedAuthPackSize,
                SignedAuthPack,
                &SignedAuthPackSize
                );



    if ((Status != STATUS_BUFFER_TOO_SMALL) && (Status != STATUS_SUCCESS))
    {
        DebugLog((DEB_ERROR,"Failed to sign message: %x\n",Status));
        goto Cleanup;
    }

    SignedAuthPack = (PBYTE) MIDL_user_allocate(SignedAuthPackSize);
    if (SignedAuthPack == NULL)
    {
        KerbErr = KRB_ERR_GENERIC;
        goto Cleanup;
    }
    Status = __ScHelperSignPkcsMessage(
                TmpPin,
                Credentials->PublicKeyCreds->CspData,
                Credentials->PublicKeyCreds->KerbHProv,
                Credentials->PublicKeyCreds->CertContext,
                &CryptAlg,
                CRYPT_MESSAGE_SILENT_KEYSET_FLAG, // dwSignMessageFlags
                PackedAuthPack,
                PackedAuthPackSize,
                SignedAuthPack,
                &SignedAuthPackSize
                );

    if (Status != STATUS_SUCCESS)
    {
        DebugLog((DEB_ERROR,"Failed to sign pkcs message: 0x%x\n",Status));
        goto Cleanup;
    }

    Request.signed_auth_pack.value = SignedAuthPack;
    Request.signed_auth_pack.length = SignedAuthPackSize;

    //
    // Marshall the request
    //

    if (!KERB_SUCCESS(KerbPackData(
                        &Request,
                        KERB_PA_PK_AS_REQ_PDU,
                        &PackedRequestSize,
                        &PackedRequest)))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ListElement = (PKERB_PA_DATA_LIST) KerbAllocate(sizeof(KERB_PA_DATA_LIST));
    if (ListElement == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    ListElement->value.preauth_data_type = KRB5_PADATA_PK_AS_REP;
    ListElement->value.preauth_data.value = PackedRequest;
    ListElement->value.preauth_data.length = PackedRequestSize;
    PackedRequest = NULL;

    ListElement->next = *PreAuthData;
    *PreAuthData = ListElement;
    ListElement = NULL;

Cleanup:

    if (CleartextPin)
    {   
        KerbHidePassword( &Credentials->PublicKeyCreds->Pin );
    }

    KerbFreeRealm(
        &AuthPack.pk_authenticator.kdc_realm
        );
    KerbFreePrincipalName(
        &AuthPack.pk_authenticator.kdc_name
        );

    if (ListElement != NULL)
    {
        KerbFree(ListElement);
    }
    if (PackedRequest != NULL)
    {
        MIDL_user_free(PackedRequest);
    }
    if (PackedAuthPack != NULL)
    {
        MIDL_user_free(PackedAuthPack);
    }
    if (SignedAuthPack != NULL)
    {
        MIDL_user_free(SignedAuthPack);
    }
    if ( FreePkCreds )
    {
        KerbReleasePkCreds(
            NULL,
            Credentials->PublicKeyCreds,
            FALSE
            );
    }


    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbRetrieveDomainFromDn
//
//  Synopsis:   Looks for a subject DN in a smartcard, then calls DsCrackName
//              (local, no wire traffic) to determine the domain name.
//
//  Effects:    Allocates a unicode string
//
//  Arguments:      IN PCERT_CONTEXT smartcard cert
//                  IN OUT PUNICODE_STRING CrackedName (free w/ KerbFreeString)
//
//  Requires:
//
//  Returns:
//
//  Notes:      Returns STATUS_NOT_FOUND if the name is missing
//
//
//--------------------------------------------------------------------------
BOOLEAN
KerbRetrieveDomainFromDn(
    IN PCCERT_CONTEXT Cert,
    IN OUT PUNICODE_STRING CrackedDomain
    )
{

     LPWSTR             RDN = NULL;
     NTSTATUS           Status;
     PCERT_NAME_INFO    NameInfo = NULL;
     DWORD              Result, NameInfoLength = 0;
     LONG               i, LastPart = 0, FirstPart = 0xFFFFFFFF;
     PWCHAR             tmp;
     UNICODE_STRING     TmpString;
     BOOLEAN            fRet = FALSE;


     if (!CryptDecodeObjectEx(
                X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                X509_UNICODE_NAME,
                Cert->pCertInfo->Subject.pbData,
                Cert->pCertInfo->Subject.cbData,
                CRYPT_DECODE_ALLOC_FLAG,
                NULL,
                &NameInfo,
                &NameInfoLength
                ))
     {
         Result = GetLastError();
         DebugLog((DEB_ERROR, "CryptDecodeObject failed %x\n", Result));
         goto Cleanup;
     }

     //
     // Now walk through the NameInfoStruct, looking for DC=
     //
     NameInfoLength = 0;
     for ( i = 0; i < (LONG) NameInfo->cRDN ; i ++)
     {
         if (strcmp(NameInfo->rgRDN[i].rgRDNAttr->pszObjId,szOID_DOMAIN_COMPONENT))
         {
             continue;
         }

         if (FirstPart == 0xFFFFFFFF)
         {
             FirstPart = i;
         }

         NameInfoLength += NameInfo->rgRDN[i].rgRDNAttr->Value.cbData + sizeof(WCHAR);
         LastPart = i;
     }

     if (FirstPart == 0xFFFFFFFF)
     {
         DebugLog((DEB_ERROR, "No DC component in RDN\n"));
         KerbReportMissingRDN();
         DsysAssert(FALSE);
         goto Cleanup;
     }


     SafeAllocaAllocate(RDN, NameInfoLength);
     if ( RDN == NULL )
     {
         goto Cleanup;
     }

     //
     // The names are in reverse order, e.g. DC=COM, DC=MICROSOFT, DC=NTDEV
     //
     tmp = (PWCHAR) RDN;
     for ( i = LastPart  ; i >= 0 ; i-- )
     {

         RtlCopyMemory(
             tmp,
             NameInfo->rgRDN[i].rgRDNAttr->Value.pbData,
             NameInfo->rgRDN[i].rgRDNAttr->Value.cbData
             );


         tmp += ( NameInfo->rgRDN[i].rgRDNAttr->Value.cbData / sizeof(WCHAR) );

         if (i != FirstPart)
         {
             *tmp = L'.';
             tmp++;
         }
         else
         {
             *tmp = L'\0';
         }
     }


     RtlInitUnicodeString(
                &TmpString,
                RDN
                );

     Status = KerbDuplicateStringEx(
                    CrackedDomain,
                    &TmpString,
                    FALSE
                    );

     if (!NT_SUCCESS(Status))
     {
         goto Cleanup;
     }


     fRet = TRUE;

Cleanup:

    if ( NameInfo )
    {
        LocalFree( NameInfo );
    }


    SafeAllocaFree(RDN);

    return (fRet);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateSmartCardLogonSessionFromCertContext
//
//  Synopsis:   Creats a logon session from the cert context and passed in
//              data.  Retrieves the email name from the certificate.
//
//              This function is for use with LogonUser when a marshalled
//              smart card cert is passed in the user name and the PIN is
//              passed as the password.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateSmartCardLogonSessionFromCertContext(
    IN PCERT_CONTEXT *ppCertContext,
    IN PLUID pLogonId,
    IN PUNICODE_STRING pAuthorityName,
    IN PUNICODE_STRING pPin,
    IN PUCHAR pCspData,
    IN ULONG CspDataLength,
    OUT PKERB_LOGON_SESSION *ppLogonSession,
    OUT PUNICODE_STRING pAccountName
    )
{
    PKERB_LOGON_SESSION pLogonSession = NULL;
    PKERB_PUBLIC_KEY_CREDENTIALS PkCredentials = NULL;
    ULONG cbPkCreds = 0;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Get the client name from the cert.
    // Place it in the return location
    //
    Status = KerbGetPrincipalNameFromCertificate(*ppCertContext, pAccountName);
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Create a normal logon session. We willa add the public-key information
    // later
    //

    Status = KerbCreateLogonSession(
                pLogonId,
                pAccountName,
                pAuthorityName,
                NULL,           // no password
                NULL,           // no old password
                0,              // no flags
                KERB_LOGON_SMARTCARD,
                FALSE,          // don't allow dup.  This is a primary logon.
                &pLogonSession
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Now create the public key credentials to be put in the logon
    // session.
    //

    cbPkCreds = sizeof(KERB_PUBLIC_KEY_CREDENTIALS);
    if ((NULL != pCspData) && (0 != CspDataLength))
    {
        cbPkCreds += CspDataLength;
    }

    PkCredentials = (PKERB_PUBLIC_KEY_CREDENTIALS) KerbAllocate(cbPkCreds);
    if (PkCredentials == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    PkCredentials->CertContext = *ppCertContext;
    *ppCertContext = NULL;

    Status = KerbDuplicateString(
                &PkCredentials->Pin,
                pPin
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerbHidePassword(&PkCredentials->Pin); 

    //
    // Copy in the CSP data for later use
    //

    if ((NULL != pCspData) && (0 != CspDataLength))
    {
        PkCredentials->CspDataLength = CspDataLength;
        RtlCopyMemory(
            PkCredentials->CspData,
            pCspData,
            CspDataLength
            );
        PkCredentials->InitializationInfo |= CSP_DATA_INITIALIZED;
    }
    else
    {
        PkCredentials->InitializationInfo |= CSP_DATA_INITIALIZED | CONTEXT_INITIALIZED_WITH_ACH;
    }

    KerbWriteLockLogonSessions(pLogonSession);
    pLogonSession->PrimaryCredentials.PublicKeyCreds = PkCredentials;
    PkCredentials = NULL;
    KerbUnlockLogonSessions(pLogonSession);

    *ppLogonSession = pLogonSession;
    pLogonSession = NULL;
Cleanup:
    if (*ppCertContext != NULL)
    {
        CertFreeCertificateContext(*ppCertContext);
    }

    KerbFreePKCreds(PkCredentials, FALSE);


    if (pLogonSession != NULL)
    {
        KerbReferenceLogonSessionByPointer(pLogonSession, TRUE);
        KerbDereferenceLogonSession(pLogonSession);
        KerbDereferenceLogonSession(pLogonSession);
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbMapCertChainError
//
//  Synopsis:   We don't have good winerrors for chaining //
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMapCertChainError(ULONG ChainStatus, BOOLEAN Client)
{

    NTSTATUS Status;

    switch(ChainStatus)
    {

    case CRYPT_E_REVOKED:
        Status = (Client ? STATUS_SMARTCARD_CERT_REVOKED : STATUS_KDC_CERT_REVOKED);
        break;
    case CERT_E_EXPIRED:
        Status = (Client ? STATUS_SMARTCARD_CERT_EXPIRED : STATUS_KDC_CERT_EXPIRED);
        break;
    case CERT_E_UNTRUSTEDCA:
    case CERT_E_UNTRUSTEDROOT:
        Status = (Client ? STATUS_ISSUING_CA_UNTRUSTED :  STATUS_ISSUING_CA_UNTRUSTED_KDC);
        break;
    case CRYPT_E_REVOCATION_OFFLINE:
        Status = (Client ? STATUS_REVOCATION_OFFLINE_C : STATUS_REVOCATION_OFFLINE_KDC);
        break;

    // W2k or old whistler DC
    case ERROR_NOT_SUPPORTED:
    default:
        Status = (Client ? STATUS_PKINIT_CLIENT_FAILURE : STATUS_PKINIT_FAILURE);
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateSmardCardLogonSession
//
//  Synopsis:   Creats a logon session from the smart card logon info. It
//              creates a certificate context from the logon information,
//              retrieves the email name from the certificate, and then
//              uses that to create a context.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateSmartCardLogonSession(
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    IN SECURITY_LOGON_TYPE LogonType,
    OUT PKERB_LOGON_SESSION *ReturnedLogonSession,
    OUT PLUID ReturnedLogonId,
    OUT PUNICODE_STRING AccountName,
    OUT PUNICODE_STRING AuthorityName
    )
{
    PCERT_CONTEXT CertContext = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_SMART_CARD_LOGON LogonInfo = (PKERB_SMART_CARD_LOGON) ProtocolSubmitBuffer;
    LUID LogonId = {0};
    BOOLEAN InitializedContext = FALSE;


    //
    // We were passed a blob of data. First we need to update the pointers
    // to be in this address space
    //

    RELOCATE_ONE(&LogonInfo->Pin);

    LogonInfo->CspData = LogonInfo->CspData - (ULONG_PTR) ClientBufferBase + (ULONG_PTR) LogonInfo;

    //
    // Make sure it all fits in our address space
    //

    if ((LogonInfo->CspDataLength + LogonInfo->CspData) >
        ((PUCHAR) ProtocolSubmitBuffer + SubmitBufferSize))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // First, initialize the crypt context
    //

    Status = __ScHelperInitializeContext(
                LogonInfo->CspData,
                LogonInfo->CspDataLength
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to initialize context from csp data: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }
    InitializedContext = TRUE;

    //
    // The first thing to do is to convert the CSP data into a certificate
    // context
    //

    Status = __ScHelperGetCertFromLogonInfo(
                LogonInfo->CspData,
                &LogonInfo->Pin,
                (PCCERT_CONTEXT*)&CertContext
                );
    if (Status != STATUS_SUCCESS)
    {
        DebugLog((DEB_ERROR,"Failed to get cert from logon info: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        if (NT_SUCCESS(Status))
        {
            Status = STATUS_LOGON_FAILURE;
        }
        goto Cleanup;
    }

    RtlInitUnicodeString(
        AuthorityName,
        NULL
        );

    //
    // Now we have just about everything to create a logon session
    //

    Status = NtAllocateLocallyUniqueId( &LogonId );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to allocate locally unique ID: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // For win95, if there is a logon session in our list, remove it.
    // This is generated from the logon session dumped in the registry.
    // But, we are about to do a new logon. Get rid of the old logon.
    // If the new one does not succeed, too bad. But, that's by design.
    //

#ifdef WIN32_CHICAGO
    LsaApLogonTerminated(&LogonId);
#endif // WIN32_CHICAGO

    Status = KerbCreateSmartCardLogonSessionFromCertContext(
                &CertContext,
                &LogonId,
                AuthorityName,
                &LogonInfo->Pin,
                LogonInfo->CspData,
                LogonInfo->CspDataLength,
                ReturnedLogonSession,
                AccountName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    LogonInfo->CspDataLength = 0;

    *ReturnedLogonId = LogonId;
Cleanup:
    if (InitializedContext && LogonInfo->CspDataLength != 0)
    {
        __ScHelperRelease(
            LogonInfo->CspData
            );
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetCertificateName
//
//  Synopsis:   Gets a name from a certificate name blob. The name is:
//              subject@issuer
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetCertificateName(
    OUT PUNICODE_STRING Name,
    IN PCERT_INFO Certificate
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG IssuerLength;
    ULONG SubjectLength;

    RtlInitUnicodeString(
        Name,
        NULL
        );

    //
    // First find the size of the name. The lengths include the
    // null terminators.
    //


    SubjectLength = CertNameToStr(
                    X509_ASN_ENCODING,
                    &Certificate->Subject,
                    CERT_X500_NAME_STR,
                    NULL,
                    0
                    );
    if (SubjectLength == 0)
    {
        DebugLog((DEB_ERROR,"Failed to convert name: %0x%x. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
        Status = STATUS_PKINIT_FAILURE;
        goto Cleanup;
    }

    IssuerLength = CertNameToStr(
                    X509_ASN_ENCODING,
                    &Certificate->Issuer,
                    CERT_X500_NAME_STR,
                    NULL,
                    0
                    );
    if (IssuerLength == 0)
    {
        DebugLog((DEB_ERROR,"Failed to convert name: %0x%x. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
        Status = STATUS_PKINIT_FAILURE;
        goto Cleanup;
    }


    //
    // Remove the null terminator from one name, but leave space for a
    // ":" in the middle
    //

    Name->Buffer = (LPWSTR) KerbAllocate((SubjectLength + IssuerLength) * sizeof(WCHAR));
    if (Name->Buffer == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Now get the name itself
    //

    SubjectLength = CertNameToStr(
                    X509_ASN_ENCODING,
                    &Certificate->Subject,
                    CERT_X500_NAME_STR,
                    Name->Buffer,
                    SubjectLength
                    );
    if (SubjectLength == 0)
    {
        DebugLog((DEB_ERROR,"Failed to convert name: %0x%x. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
        KerbFree(Name->Buffer);
        Name->Buffer = NULL;
        Status = STATUS_PKINIT_FAILURE;
        goto Cleanup;
    }

    //
    // Put an "@" in the middle so it is recognized by MSV as a UPN (just in case)
    //

    Name->Buffer[SubjectLength-1] = L'@';


    IssuerLength = CertNameToStr(
                    X509_ASN_ENCODING,
                    &Certificate->Issuer,
                    CERT_X500_NAME_STR,
                    Name->Buffer + SubjectLength,
                    IssuerLength
                    );
    if (IssuerLength == 0)
    {
        DebugLog((DEB_ERROR,"Failed to convert name: %0x%x. %ws, line %d\n",GetLastError(), THIS_FILE, __LINE__));
        KerbFree(Name->Buffer);
        Name->Buffer = NULL;
        Status = STATUS_PKINIT_FAILURE;
        goto Cleanup;
    }

    RtlInitUnicodeString(
        Name,
        Name->Buffer
        );

Cleanup:
    return(Status);

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbLookupSmartCardCachedLogon
//
//  Synopsis:   Looks up a cached smart card logon in the MSV cache
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:      Free ValidationInfor with LocalFree
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbLookupSmartCardCachedLogon(
    IN PCCERT_CONTEXT Certificate,
    OUT PNETLOGON_VALIDATION_SAM_INFO4 * ValidationInfo,
    OUT PKERB_MESSAGE_BUFFER SupplementalCreds
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING IssuerName = {0};
    PMSV1_0_CACHE_LOOKUP_REQUEST CacheRequest = NULL;
    PMSV1_0_CACHE_LOOKUP_RESPONSE CacheResponse = NULL;
    UNICODE_STRING MsvPackageName = CONSTANT_UNICODE_STRING(TEXT(MSV1_0_PACKAGE_NAME));
    NTSTATUS SubStatus = STATUS_SUCCESS;
    ULONG OutputBufferSize = 0;
    ULONG RequestSize = 0;
    BOOLEAN Result = FALSE;

    SupplementalCreds->BufferSize = 0;
    SupplementalCreds->Buffer = NULL;

    RequestSize = sizeof( MSV1_0_CACHE_LOOKUP_REQUEST ) +
                    SHA1DIGESTLEN -
                    sizeof( UCHAR );

    SafeAllocaAllocate(CacheRequest, RequestSize);

    if ( CacheRequest == NULL )
    {
        return( FALSE );
    }

    RtlZeroMemory(CacheRequest, RequestSize);

    *ValidationInfo = NULL;

    //
    // Get the issuer & subject name from the cert. These will be used as
    // user name & domain name for the lookup
    //


    Status = KerbGetCertificateName(
                &IssuerName,
                Certificate->pCertInfo
                );

    if (NT_SUCCESS(Status))
    {
        Status = KerbGetCertificateHash(
                     CacheRequest->CredentialSubmitBuffer,
                     SHA1DIGESTLEN,
                     Certificate
                     );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    CacheRequest->MessageType = MsV1_0CacheLookup;
    CacheRequest->UserName = IssuerName;
    CacheRequest->CredentialType = MSV1_0_CACHE_LOOKUP_CREDTYPE_RAW;
    CacheRequest->CredentialInfoLength = SHA1DIGESTLEN;

    //
    // Leave the domain name portion blank.
    //

    //
    // Call MSV1_0 to do the work
    //
    Status = LsaFunctions->CallPackage(
                    &MsvPackageName,
                    CacheRequest,
                    RequestSize,
                    (PVOID *) &CacheResponse,
                    &OutputBufferSize,
                    &SubStatus
                    );
    if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus))
    {
        DebugLog((DEB_ERROR, "Failed to lookup cache credentials: 0x%x, 0x%x. %ws, line %d\n", Status, SubStatus, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    if (OutputBufferSize < sizeof(MSV1_0_CACHE_LOOKUP_RESPONSE))
    {
        DebugLog((DEB_ERROR, "Invalid response from cache lookup - return too small: %d bytes. %ws, line %d\n",
            OutputBufferSize, THIS_FILE, __LINE__ ));
        //
        // Free it here so we don't do too much freeing in the cleanup portion.
        // Don't free the internals as this is pretty bad.
        //

        LsaFunctions->FreeReturnBuffer(CacheResponse);
        CacheResponse = NULL;
        goto Cleanup;
    }

    if (CacheResponse->MessageType != MsV1_0CacheLookup)
    {
        DebugLog((DEB_ERROR, "Wrong message type from cache lookup: %d. %ws, line %d\n",
            CacheResponse->MessageType, THIS_FILE, __LINE__ ));
        //
        // Free it here so we don't do too much freeing in the cleanup portion.
        // Don't free the internals as this is pretty bad.
        //

        LsaFunctions->FreeReturnBuffer(CacheResponse);
        CacheResponse = NULL;
        goto Cleanup;
    }

    *ValidationInfo = (PNETLOGON_VALIDATION_SAM_INFO4) CacheResponse->ValidationInformation;
    CacheResponse->ValidationInformation = NULL;

    SupplementalCreds->Buffer = (PBYTE) CacheResponse->SupplementalCacheData;
    SupplementalCreds->BufferSize = CacheResponse->SupplementalCacheDataLength;
    CacheResponse->SupplementalCacheData = NULL;
    Result = TRUE;

Cleanup:

    SafeAllocaFree(CacheRequest);

    if (CacheResponse != NULL)
    {
        //
        // At this point we know it was a valid cache response, so we
        // can free the validation info if it is present.  NTLM uses
        // MIDL_user_allocate to allocate these.
        //

        if (CacheResponse->ValidationInformation != NULL)
        {
            MIDL_user_free(CacheResponse->ValidationInformation);
        }

        if (CacheResponse->SupplementalCacheData != NULL)
        {
            MIDL_user_free(CacheResponse->SupplementalCacheData);
        }

        LsaFunctions->FreeReturnBuffer(CacheResponse);
    }

    KerbFreeString(&IssuerName);

    return(Result);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbDoLocalSmartCardLogon
//
//  Synopsis:   Performs a local logon with the smart card by validating the
//              card and PIN & then trying to map the name locally
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbDoLocalSmartCardLogon(
    IN PKERB_LOGON_SESSION LogonSession,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *NewTokenInformation,
    OUT PULONG ProfileBufferLength,
    OUT PVOID * ProfileBuffer,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCredentials,
    IN  OUT PNETLOGON_VALIDATION_SAM_INFO4 * Validation4
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
#ifndef WIN32_CHICAGO
    PPACTYPE Pac = NULL;
    PPAC_INFO_BUFFER LogonInfo = NULL;
    PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo = NULL;
    PNETLOGON_VALIDATION_SAM_INFO4 MsvValidationInfo = NULL;
    PNETLOGON_VALIDATION_SAM_INFO3 PacValidationInfo = NULL;
    PLSA_TOKEN_INFORMATION_V2 TokenInformation = NULL;
    KERB_MESSAGE_BUFFER SupplementalCreds = {0};
#endif // !WIN32_CHICAGO
    PKERB_INTERNAL_NAME ClientName = NULL;
    PKERB_PUBLIC_KEY_CREDENTIALS PkCreds;
    PBYTE DecryptedCreds = NULL;
    ULONG DecryptedCredSize = 0;
    NETLOGON_VALIDATION_SAM_INFO3 ValidationInfo3 = {0};

    *Validation4 = NULL;
    PrimaryCredentials->Flags = 0;

    PkCreds = LogonSession->PrimaryCredentials.PublicKeyCreds;

    //
    // First, verify the card. This will verify the certificate as well
    // as verify the PIN & that the ceritifcate matches the private key on
    // the card.
    //

    if ((PkCreds->InitializationInfo & CSP_DATA_INITIALIZED) == 0)
    {
        Status = KerbInitializePkCreds(
                    PkCreds
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }


    //
    // Now build a PAC for the user
    //

    if (!KERB_SUCCESS(KerbConvertStringToKdcName(
                        &ClientName,
                        &LogonSession->PrimaryCredentials.UserName
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

#ifndef WIN32_CHICAGO
    //
    // First check for a cached logon entry
    //

    if (KerbLookupSmartCardCachedLogon(
            PkCreds->CertContext,
            &MsvValidationInfo,
            &SupplementalCreds))
    {
        MsvValidationInfo->UserFlags |= LOGON_CACHED_ACCOUNT;
        PrimaryCredentials->Flags |= PRIMARY_CRED_CACHED_LOGON;

        //
        // Strip the domain postfix
        //

        if (MsvValidationInfo->LogonDomainName.Length >= KERB_SCLOGON_DOMAIN_SUFFIX_SIZE)
        {
            MsvValidationInfo->LogonDomainName.Length -= KERB_SCLOGON_DOMAIN_SUFFIX_SIZE;
        }

        if ((SupplementalCreds.Buffer != NULL) &&
            (SupplementalCreds.BufferSize != 0))
        {
            DecryptedCredSize = SupplementalCreds.BufferSize;
            DecryptedCreds = (PBYTE) MIDL_user_allocate(DecryptedCredSize);
            if (DecryptedCreds == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }
        }

        //
        // NOTE: this makes use of the fact that _INFO3 and _INFO4 structures
        // expand the _INFO2 structure in different ways, so we're keeping the
        // common portion.  The rest of _INFO3 is zeroed out in the declaration,
        // so no ZeroMemory() call is necessary here
        //

        RtlCopyMemory(
            &ValidationInfo3,
            MsvValidationInfo,
            sizeof( NETLOGON_VALIDATION_SAM_INFO2 )
            );

        ValidationInfo = &ValidationInfo3;
    }
    else
    {
        //
        // Look for a name mapping
        //

        Status = KerbCreatePacForKerbClient(
                    &Pac,
                    ClientName,
                    &LogonSession->PrimaryCredentials.DomainName,
                    NULL
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // Find the SAM validation info
        //

        LogonInfo = PAC_Find(
                        Pac,
                        PAC_LOGON_INFO,
                        NULL
                        );
        if (LogonInfo == NULL)
        {
            DebugLog((DEB_ERROR, "Failed to find logon info! %ws, line %d\n", THIS_FILE, __LINE__));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Now unmarshall the validation info
        //


        Status = PAC_UnmarshallValidationInfo(
                    &PacValidationInfo,
                    LogonInfo->Data,
                    LogonInfo->cbBufferSize
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "Failed to unmarshall validation info: 0x%x. %ws, line %d\n",
                Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }
        ValidationInfo = PacValidationInfo;
    }


    KerbRevealPassword(&PkCreds->Pin);

    Status = __ScHelperVerifyCardAndCreds(
                &PkCreds->Pin,
                PkCreds->CertContext,
                PkCreds->CspData,
                SupplementalCreds.Buffer,
                SupplementalCreds.BufferSize,
                DecryptedCreds,
                &DecryptedCredSize
                );

    KerbHidePassword(&PkCreds->Pin);

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to verify card: 0x%x. %ws, line %d\n", Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    //
    // If we have any encrypted credentials, decode them here for return.
    //

    if (DecryptedCredSize != 0)
    {
        Status = PAC_UnmarshallCredentials(
                    CachedCredentials,
                    DecryptedCreds,
                    DecryptedCredSize
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Check to see if this is a non-user account. If so, don't allow the logon
    //

    if ((ValidationInfo->ExpansionRoom[SAMINFO_USER_ACCOUNT_CONTROL] & USER_MACHINE_ACCOUNT_MASK) != 0)
    {
        DebugLog((DEB_ERROR, "Logons to non-user accounts not allowed. UserAccountControl = 0x%x\n",
            ValidationInfo->ExpansionRoom[SAMINFO_USER_ACCOUNT_CONTROL] ));
        Status = STATUS_LOGON_TYPE_NOT_GRANTED;
        goto Cleanup;
    }

    //
    // Now we need to build a LSA_TOKEN_INFORMATION_V2 from the validation
    // information
    //

    Status = KerbMakeTokenInformationV2(
                ValidationInfo,
                FALSE,                  // not local system
                &TokenInformation
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to make token informatin v2: 0x%x\n",
            Status));
        goto Cleanup;
    }

    //
    // Allocate the client profile
    //

    Status = KerbAllocateInteractiveProfile(
                (PKERB_INTERACTIVE_PROFILE *) ProfileBuffer,
                ProfileBufferLength,
                ValidationInfo,
                LogonSession,
                NULL,
                NULL
                );
    if (!KERB_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Build the primary credential. We let someone else fill in the
    // password.
    //

    PrimaryCredentials->LogonId = LogonSession->LogonId;
    Status = KerbDuplicateString(
                &PrimaryCredentials->DownlevelName,
                &ValidationInfo->EffectiveName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = KerbDuplicateString(
                &PrimaryCredentials->DomainName,
                &ValidationInfo->LogonDomainName
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    Status = KerbDuplicateSid(
                &PrimaryCredentials->UserSid,
                TokenInformation->User.User.Sid
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    *Validation4 = MsvValidationInfo;
    MsvValidationInfo = NULL;

    *NewTokenInformation = TokenInformation;
    *TokenInformationType = LsaTokenInformationV2;

#endif // !WIN32_CHICAGO

Cleanup:

    if (PacValidationInfo != NULL)
    {
        MIDL_user_free(PacValidationInfo);
    }

    KerbFreeKdcName(
        &ClientName
        );

    if (MsvValidationInfo != NULL)
    {
        MIDL_user_free(MsvValidationInfo);
        MsvValidationInfo = NULL;
    }

    if (SupplementalCreds.Buffer != NULL)
    {
        MIDL_user_free(SupplementalCreds.Buffer);
        SupplementalCreds.Buffer = NULL;
    }

#ifndef WIN32_CHICAGO

    if (Pac != NULL)
    {
        MIDL_user_free(Pac);
    }

    if (!NT_SUCCESS(Status))
    {
        if (TokenInformation != NULL)
        {
            KerbFree( TokenInformation );
        }
        if (*ProfileBuffer != NULL)
        {
            LsaFunctions->FreeClientBuffer(NULL, *ProfileBuffer);
            *ProfileBuffer = NULL;
        }
        KerbFreeString(
            &PrimaryCredentials->DownlevelName
            );
        KerbFreeString(
            &PrimaryCredentials->DomainName
            );
        if (PrimaryCredentials->UserSid != NULL)
        {
            KerbFree(PrimaryCredentials->UserSid);
            PrimaryCredentials->UserSid = NULL;
        }
    }
#endif // WIN32_CHICAGO

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbCacheSmartCardLogon
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbCacheSmartCardLogon(
    IN PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo,
    IN OPTIONAL PUNICODE_STRING DnsDomainName,
    IN OPTIONAL PUNICODE_STRING UPN,
    IN PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PSECPKG_SUPPLEMENTAL_CRED_ARRAY CachedCredentials
    )
{
    NTSTATUS Status;
    UNICODE_STRING IssuerName = {0};
    UNICODE_STRING DomainName = {0};
    UNICODE_STRING TempLogonDomainName = {0};
    UNICODE_STRING LogonDomainName = {0};
    BYTE CertificateHash[ SHA1DIGESTLEN ];
    UNICODE_STRING CertificateHashString;
    ULONG EncodedCredSize = 0;
    PBYTE EncodedCreds = NULL;
    ULONG EncryptedCredSize = 0;
    PBYTE EncryptedCreds = NULL;
    BOOLEAN LogonSessionLocked = FALSE;
    BOOLEAN InitializedPkCreds = FALSE;
    BOOLEAN CleartextPin = FALSE;

    //
    // Build the temporary logon domain name that indicates this is a
    // smart card logon.
    //

    TempLogonDomainName.MaximumLength =
        TempLogonDomainName.Length =
            ValidationInfo->LogonDomainName.Length + KERB_SCLOGON_DOMAIN_SUFFIX_SIZE;

    TempLogonDomainName.Buffer = (LPWSTR) MIDL_user_allocate(TempLogonDomainName.Length);
    if (TempLogonDomainName.Buffer == NULL)
    {
        goto Cleanup;
    }

    //
    // Create the new name
    //

    RtlCopyMemory(
        TempLogonDomainName.Buffer,
        ValidationInfo->LogonDomainName.Buffer,
        ValidationInfo->LogonDomainName.Length
        );

    RtlCopyMemory(
        ((PUCHAR) TempLogonDomainName.Buffer) + ValidationInfo->LogonDomainName.Length,
        KERB_SCLOGON_DOMAIN_SUFFIX,
        KERB_SCLOGON_DOMAIN_SUFFIX_SIZE
        );

    LogonDomainName = ValidationInfo->LogonDomainName;
    ValidationInfo->LogonDomainName = TempLogonDomainName;

    //
    // Get the name under which to store this.
    //

    DsysAssert( !LogonSessionLocked );
    KerbReadLockLogonSessions(LogonSession);
    LogonSessionLocked = TRUE;

    Status = KerbGetCertificateName(
                &IssuerName,
                LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext->pCertInfo
                );

    if ( Status == STATUS_SUCCESS )
    {
        Status = KerbGetCertificateHash(
                     CertificateHash,
                     SHA1DIGESTLEN,
                     LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext
                     );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    CertificateHashString.Length = SHA1DIGESTLEN;
    CertificateHashString.Buffer = (LPWSTR)CertificateHash;
    CertificateHashString.MaximumLength = SHA1DIGESTLEN;

    if (ARGUMENT_PRESENT(CachedCredentials))
    {
        ScHelper_RandomCredBits RandomBits;

        Status = PAC_EncodeCredentialData(
                    CachedCredentials,
                    &EncodedCreds,
                    &EncodedCredSize
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        if ((LogonSession->PrimaryCredentials.PublicKeyCreds->InitializationInfo & CSP_DATA_INITIALIZED) == 0)
        {
            Status  = KerbInitializePkCreds(
                            LogonSession->PrimaryCredentials.PublicKeyCreds
                            );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
            InitializedPkCreds = TRUE;

        }

        Status = __ScHelperGenRandBits(
                    LogonSession->PrimaryCredentials.PublicKeyCreds->CspData,
                    &RandomBits
                    );
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to generate random bits: 0x%x\n",Status));
            goto Cleanup;
        }

        KerbRevealPassword( &LogonSession->PrimaryCredentials.PublicKeyCreds->Pin );
        CleartextPin = TRUE;

        Status = __ScHelperEncryptCredentials(
                     &LogonSession->PrimaryCredentials.PublicKeyCreds->Pin,
                     LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext,
                     &RandomBits,
                     LogonSession->PrimaryCredentials.PublicKeyCreds->CspData,
                     EncodedCreds,
                     EncodedCredSize,
                     NULL,
                     &EncryptedCredSize
                     );
        if ((Status != STATUS_SUCCESS) && (Status != STATUS_BUFFER_TOO_SMALL))
        {
            DebugLog((DEB_ERROR,"Failed to encrypt creds: 0x%x\n",Status));
            goto Cleanup;
        }

        EncryptedCreds = (PBYTE) KerbAllocate(EncryptedCredSize);
        if (EncryptedCreds == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        //
        // Do the real encryption
        //

        Status = __ScHelperEncryptCredentials(
                     &LogonSession->PrimaryCredentials.PublicKeyCreds->Pin,
                     LogonSession->PrimaryCredentials.PublicKeyCreds->CertContext,
                     &RandomBits,
                     LogonSession->PrimaryCredentials.PublicKeyCreds->CspData,
                     EncodedCreds,
                     EncodedCredSize,
                     EncryptedCreds,
                     &EncryptedCredSize
                     );
        if (Status != STATUS_SUCCESS)
        {
            DebugLog((DEB_ERROR,"Failed to encrypt creds: 0x%x\n",Status));
            goto Cleanup;
        }
    }

    DsysAssert( LogonSessionLocked );
    KerbUnlockLogonSessions(LogonSession);
    LogonSessionLocked = FALSE;

    KerbCacheLogonInformation(
        &IssuerName,            // used as username
        &DomainName,            // blank - no domain
        &CertificateHashString, // password is certificate hash,
        DnsDomainName,
        NULL, // UPN,
        NULL, // not MIT realm logon, do not need to pass in LogonSession
        MSV1_0_CACHE_LOGON_REQUEST_SMARTCARD_ONLY, // smartcard only
        ValidationInfo,
        EncryptedCreds,
        EncryptedCredSize
        );

Cleanup:

    if (CleartextPin)
    {
        KerbHidePassword(&LogonSession->PrimaryCredentials.PublicKeyCreds->Pin);
    }

    if (InitializedPkCreds)
    {
        KerbFreePKCreds(
            LogonSession->PrimaryCredentials.PublicKeyCreds,
            FALSE
            );
    }

    if (LogonSessionLocked)
    {
        KerbUnlockLogonSessions(LogonSession);
    }

    KerbFreeString(&IssuerName);
    KerbFreeString(&TempLogonDomainName);

    //
    // Restore the original logon domain name
    //

    if (LogonDomainName.Buffer != NULL)
    {
        ValidationInfo->LogonDomainName = LogonDomainName;
    }

    if (EncodedCreds != NULL)
    {
        MIDL_user_free(EncodedCreds);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializePkinit
//
//  Synopsis:   Inializes structures needed for PKINIT
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitializePkinit(
    VOID
    )
{
    ULONG Index;
    LPSTR StringCopy = NULL, TempString = NULL,EndPtr = NULL;

    //
    // Initialize the object IDs
    //

    Index = 0;

    SafeAllocaAllocate(StringCopy, (ULONG) strlen(KERB_PKINIT_SIGNATURE_OID) + 1);

    if (StringCopy == NULL)
    {
        return( STATUS_INSUFFICIENT_RESOURCES);

    }

    //
    // Scan the string for every '.' separated number
    //

    strcpy(
        StringCopy,
        KERB_PKINIT_SIGNATURE_OID
        );

    TempString = StringCopy;
    EndPtr = TempString;

    while (TempString != NULL)
    {
        ULONG Temp;

        while (*EndPtr != '\0' && *EndPtr != '.')
        {
            EndPtr++;
        }
        if (*EndPtr == '.')
        {
            *EndPtr = '\0';
            EndPtr++;
        }
        else
        {
            EndPtr = NULL;
        }

        if (0 == sscanf(TempString,"%u",&Temp))
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }
        KerbSignatureAlg[Index].value = (USHORT) Temp;
        KerbSignatureAlg[Index].next = &KerbSignatureAlg[Index+1];
        Index++;


        TempString = EndPtr;
    }

    DsysAssert(Index != 0);
    KerbSignatureAlg[Index-1].next = NULL;

    SafeAllocaFree(StringCopy);

    TempString = NULL;

    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\mitutil.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        mitutil.h
//
// Contents:    Prototypes & structures for MIT KDC support
//
//
// History:     4-March-1997    Created         MikeSw
//
//------------------------------------------------------------------------


#ifndef __MITUTIL_H__
#define __MITUTIL_H__

typedef struct _KERB_MIT_SERVER_LIST {
    LONG ServerCount;
    LONG LastServerUsed;
    PUNICODE_STRING ServerNames;
} KERB_MIT_SERVER_LIST, *PKERB_MIT_SERVER_LIST;

typedef struct _KERB_MIT_REALM {
    KERBEROS_LIST_ENTRY Next;
    ULONG Flags;
    ULONG ApReqChecksumType;
    ULONG PreAuthType;
    ULONG RealmNameCount;
    UNICODE_STRING RealmName;
    PUNICODE_STRING AlternateRealmNames;
    KERB_MIT_SERVER_LIST KdcNames;
    KERB_MIT_SERVER_LIST KpasswdNames;
    TimeStamp LastLookup;
} KERB_MIT_REALM, *PKERB_MIT_REALM;

#define KERB_MIT_REALM_SEND_ADDRESS 0x0001
#define KERB_MIT_REALM_TCP_SUPPORTED 0x0002
#define KERB_MIT_REALM_TRUSTED_FOR_DELEGATION 0x0004
#define KERB_MIT_REALM_DOES_CANONICALIZE 0x0008

// DNS lookup flags
#define KERB_MIT_REALM_KDC_LOOKUP             0x00010000
#define KERB_MIT_REALM_KPWD_LOOKUP            0x00020000

#define DNS_LOOKUP_TIMEOUT               120
#define DNS_TCP         "_tcp."
#define DNS_UDP         "_udp."
#define DNS_KERBEROS    "_kerberos."
#define DNS_KPASSWD     "_kpasswd."
#define DNS_MSKDC       "_kerberos._tcp.dc._msdcs."
#define DNS_MAX_PREFIX  128 // udp + kerberos char count
#define MAX_SRV_RECORDS 50  // maximum server records


#define KERB_DOMAINS_KEY TEXT("System\\CurrentControlSet\\Control\\Lsa\\Kerberos\\Domains")
#define KERB_DOMAIN_KDC_NAMES_VALUE TEXT("KdcNames")
#define KERB_DOMAIN_KPASSWD_NAMES_VALUE TEXT("KpasswdNames")
#define KERB_DOMAIN_ALT_NAMES_VALUE TEXT("AlternateDomainNames")
#define KERB_DOMAIN_FLAGS_VALUE TEXT("RealmFlags")
#define KERB_DOMAIN_AP_REQ_CSUM_VALUE TEXT("ApReqChecksumType")
#define KERB_DOMAIN_PREAUTH_VALUE TEXT("PreAuthType")


BOOLEAN
KerbLookupMitRealm(
    IN PUNICODE_STRING RealmName,
    OUT OPTIONAL PKERB_MIT_REALM* MitRealm,
    OUT OPTIONAL PBOOLEAN UsedAlternateName
    );

NTSTATUS
KerbInitializeMitRealmList(
    VOID
    );

VOID
KerbUninitializeMitRealmList(
    VOID
    );

VOID
KerbFreeServerNames(
   PKERB_MIT_SERVER_LIST ServerList
   );


BOOLEAN
KerbLookupMitRealmWithSrvLookup(
   PUNICODE_STRING RealmName,
   PKERB_MIT_REALM * MitRealm,
   BOOLEAN   Kpasswd,
   BOOLEAN   UseTcp
   );


#endif // __MITUTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\pkauth.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        pkauth.h
//
// Contents:    Structures and prototypes for public key kerberos
//
//
// History:     14-October-1997     Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __PKAUTH_H__
#define __PKAUTH_H__

VOID
KerbFreePKCreds(
    IN PKERB_PUBLIC_KEY_CREDENTIALS PkCreds,
    IN BOOLEAN OkForReuse
    );

BOOLEAN
KerbRetrieveDomainFromDn(
    IN PCCERT_CONTEXT Cert,
    IN OUT PUNICODE_STRING CrackedDomain
    );


BOOL
KerbComparePublicKeyCreds(
    IN PKERB_PUBLIC_KEY_CREDENTIALS PkCreds1,
    IN PKERB_PUBLIC_KEY_CREDENTIALS PkCreds2
    );


NTSTATUS
KerbBuildPkinitPreauthData(
    IN PKERB_PRIMARY_CREDENTIAL Credentials,
    IN OPTIONAL PKERB_PA_DATA_LIST InputPaData,
    IN PTimeStamp TimeSkew,
    IN PKERB_INTERNAL_NAME ServiceName,
    IN PUNICODE_STRING RealmName,
    IN ULONG Nonce,
    IN OUT PKERB_PA_DATA_LIST * PreAuthData,
    OUT PKERB_ENCRYPTION_KEY EncryptionKey,
    OUT PKERB_CRYPT_LIST * CryptList,
    OUT PBOOLEAN Done
    );

NTSTATUS
KerbCreateSmartCardLogonSessionFromCertContext(
    IN PCERT_CONTEXT *ppCertContext,
    IN PLUID pLogonId,
    IN PUNICODE_STRING pAuthorityName,
    IN PUNICODE_STRING pPin,
    IN PUCHAR pCspData,
    IN ULONG CspDataLength,
    OUT PKERB_LOGON_SESSION *ppLogonSession,
    OUT PUNICODE_STRING pAccountName
    );

NTSTATUS
KerbCreateSmartCardLogonSession(
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    IN SECURITY_LOGON_TYPE LogonType,
    OUT PKERB_LOGON_SESSION *ReturnedLogonSession,
    OUT PLUID ReturnedLogonId,
    OUT PUNICODE_STRING AccountName,
    OUT PUNICODE_STRING AuthorityName
    );


NTSTATUS
KerbDoLocalSmartCardLogon(
    IN PKERB_LOGON_SESSION LogonSession,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *NewTokenInformation,
    OUT PULONG ProfileBufferLength,
    OUT PVOID * ProfileBuffer,
    OUT PSECPKG_PRIMARY_CRED PrimaryCredentials,
    OUT PSECPKG_SUPPLEMENTAL_CRED_ARRAY * CachedCredentials,
    IN  OUT PNETLOGON_VALIDATION_SAM_INFO4 * Validation4
    );

VOID
KerbCacheSmartCardLogon(
    IN PNETLOGON_VALIDATION_SAM_INFO3 ValidationInfo,
    IN PUNICODE_STRING DnsDomain,
    IN OPTIONAL PUNICODE_STRING UPN,
    IN PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PSECPKG_SUPPLEMENTAL_CRED_ARRAY CachedCredentials
    );

NTSTATUS
KerbInitializePkinit(
    VOID
    );

NTSTATUS
KerbInitializePkCreds(
    IN PKERB_PUBLIC_KEY_CREDENTIALS PkCreds
    );

VOID
KerbReleasePkCreds(
    IN OPTIONAL PKERB_LOGON_SESSION LogonSession,
    IN OPTIONAL PKERB_PUBLIC_KEY_CREDENTIALS PkCreds,
    IN BOOLEAN OkForReuse
    );

NTSTATUS
KerbMapCertChainError(ULONG ChainStatus, BOOLEAN Client);

#endif // __PKAUTH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\rpcutil.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        rpcutil.cxx
//
// Contents:    Utilities for RPC for Kerberos package
//
//
// History:     19-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#include <kerb.hxx>

#include <kerbp.h>
                                                                             
#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

extern "C"
{
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>
#ifndef WIN32_CHICAGO
#include <netlibnt.h>
#endif // WIN32_CHICAGO
}


SOCKET KerbPNPSocket;
HANDLE KerbPNPSocketEvent = NULL;
HANDLE KerbPNPSocketWaitHandle = NULL;


#ifndef WIN32_CHICAGO
// The problem here is that  we need to read the domain info once after
// joining domain. (for rebootless join) and once after the reboot
// (if there was one). We can only delete the data after a reboot.

// This one controls whether I read the domain info that JoinDomain dumps
// in the registry.
BOOLEAN fNewDataAboutDomain = TRUE;

// This one controls when I should delete the domain info that JoinDomain
// dumps in the registry
BOOLEAN fRebootedSinceJoin = TRUE;

SAFE_CRITICAL_SECTION KerbCallKdcDataLock;
BOOLEAN KerbCallKdcDataInitialized = FALSE;

#define KerbLockKdcData() (SafeEnterCriticalSection(&KerbCallKdcDataLock))
#define KerbUnlockKdcData() (SafeLeaveCriticalSection(&KerbCallKdcDataLock))
#endif // WIN32_CHICAGO

#ifndef WIN32_CHICAGO
NTSTATUS
KerbInitKdcData()
{
    NTSTATUS Status = STATUS_SUCCESS;
    if (!KerbCallKdcDataInitialized)
    {
        Status = SafeInitializeCriticalSection(&KerbCallKdcDataLock, KDC_DATA_LOCK_ENUM);
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        KerbCallKdcDataInitialized = TRUE;
    }
Cleanup:
    return Status;
}

VOID
KerbFreeKdcData()
{
    if (KerbCallKdcDataInitialized)
    {
        SafeDeleteCriticalSection(&KerbCallKdcDataLock);
        KerbCallKdcDataInitialized = FALSE;
    }
}

VOID
KerbSetKdcData(BOOLEAN fNewDomain, BOOLEAN fRebooted)
{
    KerbLockKdcData();

    fNewDataAboutDomain = fNewDomain;
    fRebootedSinceJoin  = fRebooted;

    KerbUnlockKdcData();
}
#endif // WIN32_CHICAGO

//+-------------------------------------------------------------------------
//
//  Function:   MIDL_user_allocate
//
//  Synopsis:   Allocation routine for use by RPC client stubs
//
//  Effects:    allocates memory with LsaFunctions.AllocateLsaHeap
//
//  Arguments:  BufferSize - size of buffer, in bytes, to allocate
//
//  Requires:
//
//  Returns:    Buffer pointer or NULL on allocation failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------


PVOID
MIDL_user_allocate(
    IN size_t BufferSize
    )
{
    return (KerbAllocate( ROUND_UP_COUNT((ULONG) BufferSize, 8) ) );
}


//+-------------------------------------------------------------------------
//
//  Function:   MIDL_user_free
//
//  Synopsis:   Memory free routine for RPC client stubs
//
//  Effects:    frees the buffer with LsaFunctions.FreeLsaHeap
//
//  Arguments:  Buffer - Buffer to free
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
MIDL_user_free(
    IN PVOID Buffer
    )
{
    KerbFree( Buffer );
}

#ifndef WIN32_CHICAGO
#define NETSETUPP_NETLOGON_PARAMETERS                                     \
        L"SYSTEM\\CurrentControlSet\\Services\\Netlogon\\Parameters"
#define NETSETUPP_NETLOGON_KERB_JD\
        L"KerbIsDoneWithJoinDomainEntry"
#define NETSETUPP_NETLOGON_JD \
        L"SYSTEM\\CurrentControlSet\\Services\\Netlogon\\JoinDomain"
#define NETSETUPP_NETLOGON_JD_DCA   L"DomainControllerAddress"
#define NETSETUPP_NETLOGON_JD_DCAT  L"DomainControllerAddressType"
#define NETSETUPP_NETLOGON_JD_F     L"Flags"

BOOLEAN
ReadInitialDcRecord(PUNICODE_STRING uString,
                    PULONG RegAddressType,
                    PULONG RegFlags)
{
    ULONG WinError = ERROR_SUCCESS;
    HKEY hJoinKey = NULL, hParametersKey = NULL;
    ULONG Flags = 0, AddressType = 0, KdcNameSize = 0, dwTRUE = 1, Type =0;
    LPWSTR KdcName = NULL;
    BOOLEAN fReadCache = FALSE;
    ULONG dwsize = sizeof(ULONG);
    USHORT TempLen = 0;

    RtlInitUnicodeString(
            uString,
            NULL
            );

    *RegAddressType = 0;
    *RegFlags = 0;

    WinError = RegOpenKey( HKEY_LOCAL_MACHINE,
                            NETSETUPP_NETLOGON_JD,
                            &hJoinKey);

    if ( WinError != ERROR_SUCCESS) {
        goto Cleanup;
    }

    WinError = RegQueryValueEx( hJoinKey,
                           NETSETUPP_NETLOGON_JD_DCA,
                           0,
                           &Type,
                           NULL,
                           &KdcNameSize);

    if ( WinError != ERROR_SUCCESS) {
        goto Cleanup;
    }

    SafeAllocaAllocate(KdcName, KdcNameSize);

    if (KdcName == NULL)
    {
        goto Cleanup;
    }

    WinError = RegQueryValueEx( hJoinKey,
                           NETSETUPP_NETLOGON_JD_DCA,
                           0,
                           &Type,
                           (PUCHAR) KdcName,
                           &KdcNameSize);

    if ( WinError != ERROR_SUCCESS) {
        goto Cleanup;
    }

    WinError = RegQueryValueEx( hJoinKey,
                               NETSETUPP_NETLOGON_JD_DCAT,
                               0,
                               &Type,
                               (PUCHAR)&AddressType,
                               &dwsize );

    if ( WinError != ERROR_SUCCESS) {
        goto Cleanup;
    }

    WinError = RegQueryValueEx( hJoinKey,
                               NETSETUPP_NETLOGON_JD_F,
                               0,
                               &Type,
                               (PUCHAR)&Flags,
                               &dwsize);

    if ( WinError != ERROR_SUCCESS) {
        goto Cleanup;
    }

    TempLen = (USHORT)wcslen(KdcName+2);

    uString->Buffer = (PWSTR) KerbAllocate ((TempLen + 1) *sizeof(WCHAR));

    if (uString->Buffer == NULL)
    {
        goto Cleanup;
    }

    wcscpy(uString->Buffer,
          KdcName+2);

    uString->Length = TempLen * sizeof(WCHAR);
    uString->MaximumLength = uString->Length + sizeof(WCHAR);
    uString->Buffer[TempLen] = L'\0';

    *RegAddressType = AddressType;
    *RegFlags = Flags;

    // Now set the reg entry so that netlogon knows that we've read it.

    if (fRebootedSinceJoin)
    {
        WinError = RegOpenKey( HKEY_LOCAL_MACHINE,
                                NETSETUPP_NETLOGON_PARAMETERS,
                                &hParametersKey);

        if ( WinError != ERROR_SUCCESS) {
            goto Cleanup;
        }

        WinError = RegSetValueEx( hParametersKey,
                               NETSETUPP_NETLOGON_KERB_JD,
                               0,
                               REG_DWORD,
                               (PUCHAR)&dwTRUE,
                               sizeof(DWORD));

        if ( WinError != ERROR_SUCCESS) {
            goto Cleanup;
        }

        DebugLog((DEB_ERROR, "Setting DoneWJoin key!\n"));
    }

    fReadCache = TRUE;


Cleanup:

    KerbSetKdcData(FALSE, fRebootedSinceJoin);

    if (hJoinKey)
    {
        RegCloseKey( hJoinKey );
    }

    if (hParametersKey)
    {
        RegCloseKey( hParametersKey );
    }

    SafeAllocaFree(KdcName);

    return (fReadCache);
}
#endif // WIN32_CHICAGO






//+-------------------------------------------------------------------------
//
//  Function:   KerbSocketChangeHandler
//
//  Synopsis:   Simply setups up a WSA Pnp event, so that we catch network
//              changes.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbSocketChangeHandler(
              VOID* Context,
              BOOLEAN WaitStatus
              )
{
        
    WSAPROTOCOL_INFO *lpProtocolBuf = NULL;
    DWORD dwBufLen = 0;
    INT protocols[2];
    int nRet = 0;
    NTSTATUS Status;
    NET_API_STATUS  NetStatus;


    D_DebugLog((DEB_TRACE, "API: KerbSocketChangeHandler()\n"));

    //
    // Determine if TCP is installed.
    //
    protocols[0] = IPPROTO_TCP;                                             
    protocols[1] = NULL;   

    nRet = WSAEnumProtocols(protocols, lpProtocolBuf, &dwBufLen);           
    
    KerbGlobalWriteLock();
    if (nRet == 0)                                                          
    {                                                                       
        D_DebugLog((DEB_TRACE_SOCK, "Turning OFF! TCP %x\n", nRet));
        KerbGlobalNoTcpUdp = TRUE;                                             
    }
    else
    { 
        KerbGlobalNoTcpUdp = FALSE;
        if (nRet == SOCKET_ERROR) 
        {
            nRet = WSAGetLastError();
            D_DebugLog((DEB_TRACE_SOCK, "TCP problem? %x\n", nRet));
        }

        D_DebugLog((DEB_TRACE_SOCK, "Turning on TCP %x\n", nRet));
    }  
    KerbGlobalReleaseLock(); 

    //
    // Re-Register the wait - but make sure the values are init'd / correct.
    //
    KerbLockKdcData();

    if ( KerbPNPSocketWaitHandle && KerbPNPSocketEvent )
    {
        NetStatus = WSAEventSelect( 
                    KerbPNPSocket,
                    KerbPNPSocketEvent,
                    FD_ADDRESS_LIST_CHANGE
                    );

        if ( NetStatus != 0 ) 
        {
            NetStatus = WSAGetLastError();
            DebugLog(( DEB_ERROR, "Can't WSAEventSelect %ld\n", NetStatus ));
        }



        Status = RtlRegisterWait(
                        &KerbPNPSocketWaitHandle,
                        KerbPNPSocketEvent,
                        KerbSocketChangeHandler,
                        NULL,
                        INFINITE,
                        WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE
                        );
    
        if (!NT_SUCCESS( Status ))
        {
            DebugLog((DEB_ERROR, "RtlRegisterWait failed %x\n", Status));
        }  


        //
        // Issue the IOCTL, so we'll get notified.
        //
        NetStatus = WSAIoctl( 
                        KerbPNPSocket,
                        SIO_ADDRESS_LIST_CHANGE,
                        NULL, // No input buffer
                        0,    // No input buffer
                        NULL, // No output buffer
                        0,    // No output buffer
                        &dwBufLen,
                        NULL, // No overlapped,
                        NULL  // Not async
                        );   

        if ( NetStatus != 0 ) 
        {   
            NetStatus = WSAGetLastError();
            if ( NetStatus != WSAEWOULDBLOCK) 
            {
                DebugLog((DEB_ERROR, "WSAIOCTL failed %x\n", NetStatus));
                Status = STATUS_INTERNAL_ERROR;
            }
        } 

    }

    KerbUnlockKdcData();           
    KerbCleanupBindingCache(FALSE);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbInitNetworkChangeEvent
//
//  Synopsis:   Simply setups up a WSA Pnp event, so that we catch network
//              changes.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitNetworkChangeEvent()
{

    NET_API_STATUS  NetStatus;
    NTSTATUS        Status = STATUS_INTERNAL_ERROR;
    DWORD           BytesReturned;

    KerbLockKdcData();

    if ( KerbPNPSocket != NULL )
    {
        D_DebugLog((DEB_ERROR, "second init of network change event\n"));
        goto Cleanup;
    }

    //
    // Open a socket to get winsock PNP notifications on.
    //
    KerbPNPSocket = WSASocket( 
                        AF_INET,
                        SOCK_DGRAM,
                        0, // PF_INET,
                        NULL,
                        0,
                        0 
                        );  

    if ( KerbPNPSocket == INVALID_SOCKET ) 
    {  
        NetStatus = WSAGetLastError();
        if ( NetStatus == WSAEAFNOSUPPORT ) 
        {
            Status = STATUS_SUCCESS;
            goto Cleanup;
        }

        goto Cleanup;
    }  

    //
    // Open an event to wait on.
    //
    KerbPNPSocketEvent = CreateEvent(
                            NULL,     // No security ettibutes
                            FALSE,    // Auto reset
                            FALSE,    // Initially not signaled
                            NULL
                            );    
    if ( KerbPNPSocketEvent == NULL ) 
    {   
        DebugLog(( DEB_ERROR,"Cannot create Winsock PNP event %ld\n", GetLastError() ));
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }


    NetStatus = WSAEventSelect( 
                        KerbPNPSocket,
                        KerbPNPSocketEvent,
                        FD_ADDRESS_LIST_CHANGE
                        );

    if ( NetStatus != 0 ) 
    {
        NetStatus = WSAGetLastError();
        DebugLog(( DEB_ERROR, "Can't WSAEventSelect %ld\n", NetStatus ));
        goto Cleanup;
    }

    //
    // Register a wait.
    //
    Status = RtlRegisterWait(
                    &KerbPNPSocketWaitHandle,
                    KerbPNPSocketEvent,
                    KerbSocketChangeHandler,
                    NULL,
                    INFINITE,
                    WT_EXECUTEDEFAULT | WT_EXECUTEONLYONCE
                    );


    if (!NT_SUCCESS( Status ))
    {
        DebugLog((DEB_ERROR, "RtlRegisterWait failed %x\n", Status));
        goto Cleanup;
    }  

    //
    // Issue the IOCTL, so we'll get notified.
    //
    NetStatus = WSAIoctl( 
                    KerbPNPSocket,
                    SIO_ADDRESS_LIST_CHANGE,
                    NULL, // No input buffer
                    0,    // No input buffer
                    NULL, // No output buffer
                    0,    // No output buffer
                    &BytesReturned,
                    NULL, // No overlapped,
                    NULL  // Not async
                    );   

    if ( NetStatus != 0 ) 
    {   
        NetStatus = WSAGetLastError();
        if ( NetStatus != WSAEWOULDBLOCK) {
            DebugLog((DEB_ERROR, "WSAIOCTL failed %x\n", NetStatus));
            Status = STATUS_INTERNAL_ERROR;
        }
    }



Cleanup: 

    if (!NT_SUCCESS( Status ))
    {        
        if ( KerbPNPSocketWaitHandle  )
        {
            RtlDeregisterWait(KerbPNPSocketWaitHandle);
            KerbPNPSocketWaitHandle = NULL;
        }

        if ( KerbPNPSocketEvent )
        {
            CloseHandle( KerbPNPSocketEvent );
            KerbPNPSocketEvent = NULL;
        }    

        if ( KerbPNPSocket )
        {
            closesocket( KerbPNPSocket );
            KerbPNPSocket = NULL;
        }    
    } 

    KerbUnlockKdcData();
    return Status;
}



//
// This address type is used for talking to MIT KDCs
//

#define DS_UNKNOWN_ADDRESS_TYPE 0

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetKdcBinding
//
//  Synopsis:   Gets a binding to the KDC in the specified domain
//
//  Effects:
//
//  Arguments:  Realm - Domain in which to find KDC
//              PrincipalName - name of a principal that must be on the KDC
//              DesiredFlags - Flags to pass to the locator.
//              FindKpasswd - if domain is an MIT realm, then returns Kpasswd
//                      addresses instead of KDC addresses KDC
//              BindingCacheEntry - receives binding handle cache entry for
//                      TCP to the KDC
//
//  Requires:
//
//  Returns:    RPC errors, NET API errors
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetKdcBinding(
    IN PUNICODE_STRING RealmName,
    IN OPTIONAL PUNICODE_STRING PrincipalName,
    IN ULONG DesiredFlags,
    IN BOOLEAN FindKpasswd,
    IN BOOLEAN UseTcp,
    OUT PKERB_BINDING_CACHE_ENTRY * BindingCacheEntry
    )
{
    NTSTATUS Status = STATUS_NETLOGON_NOT_STARTED;
    NTSTATUS TempStatus = STATUS_SUCCESS;
    LPWSTR DomainName = NULL;
    LPWSTR AccountName = NULL;
    ULONG NetStatus = 0;
    ULONG AddressType = DS_INET_ADDRESS;
    UNICODE_STRING KdcNameString = {0};
    PDOMAIN_CONTROLLER_INFOW DcInfo = NULL;
    PKERB_MIT_REALM MitRealm = NULL;
    BOOLEAN CacheDc = FALSE;
    BOOLEAN CalledNetlogonDirectly = FALSE;
    KERBEROS_MACHINE_ROLE Role;
    ULONG ActualFlags = 0;
    ULONG CacheFlags = 0, DcFlags = 0;
#ifndef WIN32_CHICAGO
    ULONG CachedAddressType = DS_INET_ADDRESS;
    ULONG CachedFlags = 0;
    UNICODE_STRING CachedKdcNameString = {0};
    UNICODE_STRING LocalMachineName;
#endif // WIN32_CHICAGO

    Role = KerbGetGlobalRole();
#ifndef WIN32_CHICAGO

    LocalMachineName.Buffer = NULL;

    KerbGlobalReadLock();

    //
    // use TempStatus to retain initial Status value.
    //

    TempStatus = KerbDuplicateString( &LocalMachineName, &KerbGlobalMachineName );
    KerbGlobalReleaseLock();

    
    if(!NT_SUCCESS(TempStatus))
    {
        DebugLog((DEB_ERROR, "Failed to duplicate KerbGlobalMachineName\n"));
        Status = TempStatus;
        goto Cleanup;
    }

    if ((Role != KerbRoleDomainController) &&
         (RtlEqualDomainName(
            RealmName,
            &LocalMachineName
            )))
    {
        //
        // This is an attempt at a local logon on a workstation. We don't do that.
        //

        DebugLog((DEB_WARN, "Attempting to locate a KDC for the workstation - failing\n"));
        Status = STATUS_NO_LOGON_SERVERS;
        goto Cleanup;
    }

    //
    // If we are logging on for the first time after join domain, the
    // following registry entry should exist.
    // Cache that entry, we should try to get to that dc.
    // Don't cache the entry if we are a dc
    // Don't cache the entry if this is not for our domain
    //

    if ( fNewDataAboutDomain &&
         KerbGlobalRole != KerbRoleDomainController)
    {
      if (ReadInitialDcRecord(&CachedKdcNameString, &CachedAddressType, &CachedFlags))
      {
          KerbFreeString(&KerbGlobalInitialDcRecord);
          RtlInitUnicodeString(
             &KerbGlobalInitialDcRecord,
             CachedKdcNameString.Buffer
             );

          KerbGlobalInitialDcAddressType = CachedAddressType;
          KerbGlobalInitialDcFlags = CachedFlags;

          CacheDc = TRUE;
      }
      else if (KerbGlobalInitialDcRecord.Buffer != NULL)
      { 
          CacheDc = TRUE;
      }

      if (CacheDc && KerbIsThisOurDomain( RealmName))
      {
            PKERB_BINDING_CACHE_ENTRY TempBindingCacheEntry = NULL;

            TempStatus = KerbCacheBinding(
                               RealmName,
                               &KerbGlobalInitialDcRecord,
                               KerbGlobalInitialDcAddressType,
                               DesiredFlags,
                               KerbGlobalInitialDcFlags,
                               0,
                               &TempBindingCacheEntry
                               );

            if ( TempBindingCacheEntry ) {

                KerbDereferenceBindingCacheEntry( TempBindingCacheEntry );
            }

            KerbFreeString(&KerbGlobalInitialDcRecord);
       }
    }
#endif // WIN32_CHICAGO

    //
    // Check the cache if we don't want to force rediscovery
    //

    if ((DesiredFlags & DS_FORCE_REDISCOVERY) == 0)
    {   
        *BindingCacheEntry = KerbLocateBindingCacheEntry(
                                RealmName,
                                DesiredFlags,
                                FALSE
                                );
                                        
        
        if (NULL != *BindingCacheEntry)
        {
            //
            // For realmless workstations, we add negative cache entries.
            // This is because the netlogon service doesn't run on non-joined
            // machines, so we don't have the benefit of its negative caching.
            // The end result is that we need to do that ourselves.
            // 
            if (( Role == KerbRoleRealmlessWksta ) && 
               (( (*BindingCacheEntry)->CacheFlags & KERB_BINDING_NEGATIVE_ENTRY ) != 0))
            {
                DebugLog((DEB_TRACE_BND_CACHE, "Found negative entry for %wZ\n", RealmName));
                Status = STATUS_NO_LOGON_SERVERS;
            }
            else
            {
                Status = STATUS_SUCCESS;
            }                           

            goto Cleanup;
        }
    }


    //
    // If we are a domain controller, then we can simply use our global
    // computer name.
    //

#ifndef WIN32_CHICAGO
    if ((Role == KerbRoleDomainController) &&
        ((DesiredFlags & DS_PDC_REQUIRED) == 0) &&
        KerbIsThisOurDomain(
            RealmName
            ))
    {
        DsysAssert(LocalMachineName.Buffer[LocalMachineName.Length/sizeof(WCHAR)] == L'\0');


        if (!KerbKdcStarted)
        {
            Status = KerbWaitForKdc( KerbGlobalKdcWaitTime );      // wait for KerbGlobalKdcWaitTime seconds
            if (NT_SUCCESS(Status))
            {
                KerbKdcStarted = TRUE;
            }
            else
            {
                DebugLog((DEB_WARN, "Failed to wait for KDC to start: 0x%x\n",Status));
            }
        }

        if (KerbKdcStarted)
        {
            Status = STATUS_SUCCESS;
            KdcNameString = LocalMachineName;
            AddressType = DS_NETBIOS_ADDRESS;
            CacheFlags |=  KERB_BINDING_LOCAL;
            DcFlags |= DS_CLOSEST_FLAG; 
        }
    }
#endif // WIN32_CHICAGO

    //
    // Check to see if this is an MIT realm
    //
    
    if (!NT_SUCCESS(Status) &&
        KerbLookupMitRealmWithSrvLookup(
            RealmName,
            &MitRealm,
            FindKpasswd,
            UseTcp
            ))
    {
        LONG ServerIndex;
        PKERB_MIT_SERVER_LIST ServerList;

        if ((MitRealm->Flags & KERB_MIT_REALM_TCP_SUPPORTED) == 0)
        {
            CacheFlags |= KERB_BINDING_NO_TCP;
        }

        //
        // Pick which of the servers we want to use.
        //

        if (FindKpasswd)
        {
            ServerList = &MitRealm->KpasswdNames;
        }
        else
        {
            ServerList = &MitRealm->KdcNames;
        }

        //
        // If we aren't forcing rediscovery, use the last known KDC
        //
        if (ServerList->ServerCount <= 0)
        {
            Status = STATUS_NO_LOGON_SERVERS;
            goto Cleanup;
        }

        if ((DesiredFlags & DS_FORCE_REDISCOVERY) == 0)
        {
            ServerIndex = ServerList->LastServerUsed;
        }
        else
        {
            //
            // If we are forcing rediscovery, try the next realm in the list
            //

#ifndef WIN32_CHICAGO // Implement using a global & cs
            ServerIndex = InterlockedExchangeAdd(&ServerList->LastServerUsed, 1) + 1;
#else // WIN32_CHICAGO
            ServerIndex = ServerList->LastServerUsed + 1;
            (ServerList->LastServerUsed) ++;
#endif // WIN32_CHICAGO // Implement using a global & cs
            if (ServerIndex >= ServerList->ServerCount)
            {
                InterlockedExchange(&ServerList->LastServerUsed, 0);
            }
        }
        ServerIndex = ServerIndex % ServerList->ServerCount;

        KdcNameString = ServerList->ServerNames[ServerIndex];
        AddressType = DS_UNKNOWN_ADDRESS_TYPE;
        Status = STATUS_SUCCESS;
    }
    //
    // If we haven't yet found a KDC try DsGetDcName
    //
    
    if (!NT_SUCCESS(Status))
    {
        //
        // We are dependent on AFD, so wait for it to start
        //

#ifndef WIN32_CHICAGO
        if (!KerbAfdStarted)
        {
            Status = KerbWaitForService(L"LanmanWorkstation", NULL, KerbGlobalKdcWaitTime);
            if (!NT_SUCCESS(Status))
            {
                DebugLog((DEB_WARN, "Failed to wait forAFD: 0x%x\n",Status));
                goto Cleanup;
            }
            
            KerbAfdStarted = TRUE;         

            //
            // Setup for network change initialization.
            //
            KerbInitNetworkChangeEvent();  
        }

#endif  // WIN32_CHICAGO
       

        //
        // Build the null-terminated domain name.
        //

        SafeAllocaAllocate(DomainName, RealmName->Length + sizeof(WCHAR));

        if (DomainName == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        RtlCopyMemory(
            DomainName,
            RealmName->Buffer,
            RealmName->Length
            );
        DomainName[RealmName->Length/sizeof(WCHAR)] = L'\0';


        //
        // If a principal name was provided, pass it to Netlogon
        //

        if ((PrincipalName != NULL) && (PrincipalName->Length != 0))
        {
            SafeAllocaAllocate(AccountName, PrincipalName->Length + sizeof(WCHAR));

            if (AccountName == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto Cleanup;
            }

            RtlCopyMemory(
                AccountName,
                PrincipalName->Buffer,
                PrincipalName->Length
                );
            AccountName[PrincipalName->Length/sizeof(WCHAR)] = L'\0';
        }

        //
        // Actual flags that will be used.
        //

        if (DesiredFlags & DS_PDC_REQUIRED)
        {
            ActualFlags =  (DesiredFlags | KERB_LOCATOR_FLAGS) & ~DS_KDC_REQUIRED;
        }
        else
        {
            ActualFlags =  DesiredFlags | KERB_LOCATOR_FLAGS;
        }

        //
        // Find the name of a DC in this domain:
        //

#ifndef WIN32_CHICAGO
        //
        // Make sure that changes to the enumeration are 
        // taken into account here.
        //

        if ( !KerbNetlogonStarted && 
           ( Role > KerbRoleStandalone ) &&
           ( fRebootedSinceJoin ))
        {
            Status = KerbWaitForService(
                        SERVICE_NETLOGON,
                        NETLOGON_STARTED_EVENT,
                        KerbGlobalKdcWaitTime
                        );
            if (NT_SUCCESS(Status))
            {
                KerbNetlogonStarted = TRUE;
            }
            else
            {
                Status = STATUS_SUCCESS;
            }
        }


        if (KerbNetlogonStarted)
        {
            CalledNetlogonDirectly = TRUE;

            NetStatus = DsrGetDcNameEx2(
                            NULL,
                            AccountName,            // no account name
                            UF_ACCOUNT_TYPE_MASK,   // any account type
                            DomainName,
                            NULL,                   // no domain GUID
                            NULL,                   // no site GUID,
                            ActualFlags,
                            &DcInfo
                            );

        }
        else
#endif // WIN32_CHICAGO
        {
TryNetapi:
            NetStatus = DsGetDcNameW(
                            NULL,
                            DomainName,
                            NULL,           // no domain GUID
                            NULL,           // no site GUID,
                            ActualFlags,
                            &DcInfo
                            );
        }

        if (NetStatus != NO_ERROR)
        {
            if (NetStatus == STATUS_NETLOGON_NOT_STARTED ||
                NetStatus == ERROR_NETLOGON_NOT_STARTED )
            {   
                KerbNetlogonStarted = FALSE;
                if (CalledNetlogonDirectly)
                {
                    CalledNetlogonDirectly = FALSE;
                    goto TryNetapi;
                }

            }

            DebugLog((
                DEB_WARN,
                "No MS DC for domain %ws, account name %ws, locator flags 0x%x: %d. %ws, line %d\n",
                DomainName, 
                (AccountName ? AccountName : L"NULL"), 
                ActualFlags, 
                NetStatus, 
                THIS_FILE, 
                __LINE__
                ));

            if (NetStatus == ERROR_NETWORK_UNREACHABLE)
            {
                Status = STATUS_NETWORK_UNREACHABLE;
            }
            else
            {
                if ( Role == KerbRoleRealmlessWksta )
                {
                    DebugLog((DEB_TRACE_BND_CACHE, "NEG Caching realm %wZ\n", RealmName));
                    KerbCacheBinding(
                        RealmName,
                        &KdcNameString,
                        AddressType,
                        DesiredFlags,  
                        DcFlags,      
                        ( CacheFlags | KERB_BINDING_NEGATIVE_ENTRY ),   
                        BindingCacheEntry
                        );  
                }

                Status = STATUS_NO_LOGON_SERVERS;
            }
            
            KerbResetTransportCounter();
        }
        else  // no error
        {
           
           RtlInitUnicodeString(
               &KdcNameString,
               DcInfo->DomainControllerAddress+2
               );
   
           AddressType = DcInfo->DomainControllerAddressType;
           DcFlags |= DcInfo->Flags;
           Status = STATUS_SUCCESS;
        }

    }
    

    if (!NT_SUCCESS(Status))
    {
       DebugLog((
          DEB_TRACE,
          "No DC for domain %ws, account name %ws, locator flags 0x%x: %d. %ws, line %d\n",
          DomainName, 
          (AccountName ? AccountName : L"NULL"), 
          ActualFlags, 
          NetStatus,                                                                      
          THIS_FILE, 
          __LINE__
          ));

       goto Cleanup;
    }
                    
    //
    // Make a binding
    //

    //
    // If this is a local call so don't bother with the socket
    //
    
    Status = KerbCacheBinding(
                RealmName,
                &KdcNameString,
                AddressType,
                DesiredFlags,  // Flags that we would like to have
                DcFlags,      // This is what the dc has
                CacheFlags,   // Special kerberos flags so we don't use
                              // locator's bit space
                BindingCacheEntry
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


Cleanup:

    SafeAllocaFree(DomainName);
    SafeAllocaFree(AccountName);

#ifndef WIN32_CHICAGO

    if (DcInfo != NULL)
    {
        if (CalledNetlogonDirectly)
        {
            I_NetLogonFree(DcInfo);
        }
        else
        {
            NetApiBufferFree(DcInfo);
        }
    }

    KerbFreeString( &LocalMachineName );

#endif // WIN32_CHICAGO

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\spncache.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        bndcache.cxx
//
// Contents:    spn cache for Kerberos Package
//
//
// History:     13-August-1996  Created         MikeSw
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>
#include <spncache.h>

//
// TBD:  Switch this to a table & resource, or entries for 
// each SPN prefix.
//
BOOLEAN         KerberosSpnCacheInitialized = FALSE;
KERBEROS_LIST   KerbSpnCache;
LONG            SpnCount;

#define KerbWriteLockSpnCache()                         KerbLockList(&KerbSpnCache);
#define KerbReadLockSpnCache()                          KerbLockList(&KerbSpnCache);
#define KerbUnlockSpnCache()                            KerbUnlockList(&KerbSpnCache);
#define KerbWriteLockSpnCacheEntry(_x_)                 RtlAcquireResourceExclusive( &_x_->ResultLock, TRUE)
#define KerbReadLockSpnCacheEntry(_x_)                  RtlAcquireResourceShared( &_x_->ResultLock, TRUE)
#define KerbUnlockSpnCacheEntry(_x_)                    RtlReleaseResource( &_x_->ResultLock)
#define KerbConvertSpnCacheEntryReadToWriteLock(_x_)    RtlConvertSharedToExclusive( &_x_->ResultLock )


BOOLEAN HostToRealmUsed = FALSE;
BOOLEAN HostToRealmInitialized = FALSE;


RTL_AVL_TABLE HostToRealmTable;
SAFE_RESOURCE HostToRealmLock;
#define HostToRealmReadLock() SafeAcquireResourceShared(&HostToRealmLock, TRUE)  
#define HostToRealmWriteLock() SafeAcquireResourceExclusive(&HostToRealmLock, TRUE)
#define HostToRealmUnlock() SafeReleaseResource(&HostToRealmLock)



//
// Allocation Routines for our table.
//

PVOID
NTAPI
KerbTableAllocateRoutine(
    struct _RTL_AVL_TABLE * Table,
    CLONG ByteSize
    )
{
    UNREFERENCED_PARAMETER( Table );
    return KerbAllocate( ByteSize );
}


void
NTAPI
KerbTableFreeRoutine(
    struct _RTL_AVL_TABLE * Table,
    PVOID Buffer
    )
{
    UNREFERENCED_PARAMETER( Table ); 
    KerbFree( Buffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbStringComparisonRoutine
//
//  Synopsis:   Used in tables to compare unicode strings
//
//  Effects:    
//
//  Arguments:  
//              
//
//  Requires:   
//
//  Returns:    none
//
//  Notes:
//
//
//--


RTL_GENERIC_COMPARE_RESULTS
NTAPI
KerbTableStringComparisonRoutine(
    struct _RTL_AVL_TABLE * Table,
    PVOID FirstStruct,
    PVOID SecondStruct
    )
{
    INT Result;
    UNICODE_STRING *String1, *String2;

    UNREFERENCED_PARAMETER( Table );

    ASSERT( FirstStruct );
    ASSERT( SecondStruct );

    String1 = ( UNICODE_STRING * )FirstStruct;
    String2 = ( UNICODE_STRING * )SecondStruct;

    Result = RtlCompareUnicodeString(
                 String1,
                 String2,
                 TRUE
                 );

    if ( Result < 0 ) {

        return GenericLessThan;

    } else if ( Result > 0 ) {

        return GenericGreaterThan;

    } else {

        return GenericEqual;
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPurgeHostToRealmTable
//
//  Synopsis:   Creates an entry and puts it in the HostToRealmTable
//
//  Effects:   
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, other error codes on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbPurgeHostToRealmTable()
{
    PHOST_TO_REALM_KEY Key = NULL;
    BOOLEAN fDeleted;          

    HostToRealmWriteLock();

    HostToRealmUsed = FALSE;

    for ( Key = ( PHOST_TO_REALM_KEY  )RtlEnumerateGenericTableAvl( &HostToRealmTable, TRUE );
        Key != NULL;
        Key = ( PHOST_TO_REALM_KEY  )RtlEnumerateGenericTableAvl( &HostToRealmTable, TRUE )) 
    {
        
        fDeleted = RtlDeleteElementGenericTableAvl( &HostToRealmTable, (PVOID) &Key->SpnSuffix );
        DsysAssert( fDeleted );
    }    

    HostToRealmUnlock();
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbAddHostToRealmMapping
//
//  Synopsis:   Creates an entry and puts it in the HostToRealmTable
//
//  Effects:   
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, other error codes on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbAddHostToRealmMapping(
    HKEY  hKey,
    LPWSTR Realm
    )
{

    BOOLEAN             fRet = FALSE;
    ULONG               Type;
    ULONG               WinError = ERROR_SUCCESS;
    NTSTATUS            Status;
    
    PBYTE               Data = NULL;
    PWCHAR              pCh;
    ULONG               DataSize = 0;
    WCHAR               Value[] = KERB_HOST_TO_REALM_VAL;
    UNICODE_STRING      RealmString = {0};  
    ULONG               index, StringCount = 0;
    
    RtlInitUnicodeString(
        &RealmString,
        Realm
        );   

    Status = RtlUpcaseUnicodeString(
                    &RealmString,
                    &RealmString,
                    FALSE
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    
    //
    // First query the SPN strings under this realm key.
    //
    WinError = RegQueryValueEx(
                    hKey,
                    Value,
                    NULL,
                    &Type,
                    NULL,
                    &DataSize
                    );

    if ( Type != REG_MULTI_SZ )
    {
        D_DebugLog((DEB_ERROR, "Wrong registry type \n"));
        goto Cleanup;
    }                

    if ((WinError == ERROR_MORE_DATA) || (WinError == ERROR_SUCCESS))
    {  

        SafeAllocaAllocate( Data, DataSize );
        if (Data == NULL)
        {
            goto Cleanup;
        }

        WinError = RegQueryValueEx(
                        hKey,
                        Value,
                        NULL,
                        &Type,
                        Data,
                        &DataSize
                        );
    }
    
    if ( WinError != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    pCh = (PWCHAR) Data;

    //
    // Now parse out the reg_multi_sz to create the keys for the table.
    //
    for ( index = 0; index < DataSize; index += sizeof(WCHAR), pCh++ )
    {   
        if ( (*pCh) == L'\0' )
        {
            StringCount++;

            if (*(pCh+1) == L'\0')
            {
                break;
            }

                        
        } 
    }

    //
    // Build the keys, one for each SPN substring entry.
    // These keys are contigous blobs - to speed up table lookups, and 
    // confine them to a page of memory.
    //
    pCh = (PWCHAR) Data;

    for ( index = 0; index < StringCount ; index++ ) 
    {
        ULONG               uSize = (2*sizeof(UNICODE_STRING));
        UNICODE_STRING      SpnSuffix = {0};
        PHOST_TO_REALM_KEY  Key = NULL, NewKey = NULL;
        PBYTE               tmp;

        
        RtlInitUnicodeString(
                &SpnSuffix,
                pCh
                );

        Status = RtlUpcaseUnicodeString(
                        &SpnSuffix,
                        &SpnSuffix,
                        FALSE
                        );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }        

        uSize += ROUND_UP_COUNT(SpnSuffix.MaximumLength, ALIGN_LPDWORD);
        uSize += RealmString.MaximumLength;

        Key = (PHOST_TO_REALM_KEY) KerbAllocate(uSize);
        if (NULL == Key)
        {                
            goto Cleanup;
        }

        tmp = (PBYTE) &Key->NameBuffer;

        Key->SpnSuffix.Length = SpnSuffix.Length;
        Key->SpnSuffix.MaximumLength = SpnSuffix.MaximumLength;
        Key->SpnSuffix.Buffer = (PWCHAR) tmp;   

        RtlCopyMemory(
            tmp,
            SpnSuffix.Buffer,
            SpnSuffix.MaximumLength
            );

        tmp += ROUND_UP_COUNT(SpnSuffix.MaximumLength, ALIGN_LPDWORD);

        Key->TargetRealm.Length = RealmString.Length;
        Key->TargetRealm.MaximumLength = RealmString.MaximumLength;
        Key->TargetRealm.Buffer = (PWCHAR) tmp; 
       
        RtlCopyMemory(
            tmp,
            RealmString.Buffer,
            RealmString.MaximumLength
            );

        NewKey = (PHOST_TO_REALM_KEY) RtlInsertElementGenericTableAvl(
                                            &HostToRealmTable,
                                            Key,
                                            uSize,
                                            NULL
                                            );

        KerbFree(Key);
        if (NewKey == NULL)
        {
            D_DebugLog((DEB_ERROR, "Insert into table failed\n"));
            goto Cleanup;
        }  

        NewKey->SpnSuffix.Buffer = NewKey->NameBuffer;
        NewKey->TargetRealm.Buffer = NewKey->NameBuffer + 
                                        (ROUND_UP_COUNT(SpnSuffix.MaximumLength, ALIGN_LPDWORD) / sizeof(WCHAR));

        pCh += (SpnSuffix.MaximumLength / sizeof(WCHAR)); 
        
        DebugLog((DEB_TRACE_SPN_CACHE, "NewKey %p\n", NewKey));   

    }

    HostToRealmUsed = TRUE;
    fRet = TRUE;

Cleanup:

    SafeAllocaFree( Data );

    return fRet;

}



//+-------------------------------------------------------------------------
//
//  Function:   KerbRefreshHostToRealmTable
//
//  Synopsis:   Used as a registry callback routine for cleaning, and reusing
//              hosttorealm cache.
//  Effects:    
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    void
//
//  Notes:
//
//
//----
VOID
KerbRefreshHostToRealmTable()
{

    if (!HostToRealmInitialized)
    {
        return;
    }

    KerbPurgeHostToRealmTable();
    KerbCreateHostToRealmMappings();
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitHostToRealmTable
//
//  Synopsis:   Initializes the host to realm table.
//
//  Effects:    allocates a resources
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, other error codes on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitHostToRealmTable(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;;

    //
    // Initialize the host to realm mapping 
    // table
    //
    RtlInitializeGenericTableAvl(
        &HostToRealmTable,
        KerbTableStringComparisonRoutine,
        KerbTableAllocateRoutine,
        KerbTableFreeRoutine,
        NULL
        );      


    __try
    {
        SafeInitializeResource(&HostToRealmLock, HOST_2_REALM_LIST_LOCK);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status =  STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }     

    HostToRealmInitialized = TRUE;

    KerbCreateHostToRealmMappings();

Cleanup:
    
    return(Status);
}

#if DBG

#define MAX_NAMES 8

LPWSTR  Prefix[MAX_NAMES] = { L"CIFS", L"HTTP", L"RPCSS", L"HOST", L"GC", L"LDAP",  L"DNS", L"???"};
ULONG   NameCount[MAX_NAMES];
ULONG   Tracking[MAX_NAMES];

//
// Fester: Remove this when we figure out a good pattern of
// SPN usage.
//

VOID
KerbLogSpnStats(
    PKERB_INTERNAL_NAME Spn
    )
{
    ULONG i;
    UNICODE_STRING Namelist;
    
    if (Spn->NameCount < MAX_NAMES)
    {
        Tracking[Spn->NameCount]++;
    }
    
    for (i = 0; i < (MAX_NAMES - 1); i++)
    {
        RtlInitUnicodeString(
                &Namelist,
                Prefix[i]
                );
                        
        if (RtlEqualUnicodeString(
                    &Spn->Names[0],
                    &Namelist,
                    TRUE
                    ))
        {
            NameCount[i]++;
            return;
        }
    }

    //
    // Count this as a miss
    //

    NameCount[MAX_NAMES-1]++;
}

#endif

//+-------------------------------------------------------------------------
//
//  Function:   KerbInitSpnCache
//
//  Synopsis:   Initializes the SPN cache
//
//  Effects:    allocates a resources
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, other error codes on failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitSpnCache(
    VOID
    )
{
    NTSTATUS Status;

    Status = KerbInitializeList( &KerbSpnCache, SPN_CACHE_LOCK_ENUM );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }      

    Status =  KerbInitHostToRealmTable();
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    KerberosSpnCacheInitialized = TRUE;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KerbFreeList( &KerbSpnCache );
    }
    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbCleanupSpnCache
//
//  Synopsis:   Frees the Spn cache
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbCleanupSpnCache(
    VOID
    )
{
    PKERB_SPN_CACHE_ENTRY CacheEntry;

    DebugLog((DEB_TRACE_SPN_CACHE, "Cleaning up SPN cache\n"));

    if (KerberosSpnCacheInitialized)
    {
        KerbWriteLockSpnCache();
        while (!IsListEmpty(&KerbSpnCache.List))
        {
            CacheEntry = CONTAINING_RECORD(
                            KerbSpnCache.List.Flink,
                            KERB_SPN_CACHE_ENTRY,
                            ListEntry.Next
                            );

            KerbReferenceListEntry(
                &KerbSpnCache,
                &CacheEntry->ListEntry,
                TRUE
                );

            KerbDereferenceSpnCacheEntry(CacheEntry);
        }

        KerbUnlockSpnCache();
        
     }

}








//+-------------------------------------------------------------------------
//
//  Function:   KerbParseDnsName
//
//  Synopsis:   Parse Dns name from left to right, at each "."
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:   
//
//  Returns:    
//
//  Notes: The unicode string passed in will be modified - use a copy if
//         you still need the string.
//
//
//--

BOOLEAN
KerbParseDnsName(
    IN UNICODE_STRING * Name
    )
{
    USHORT Index;
    BOOLEAN Found = FALSE;

    ASSERT( Name );
    ASSERT( Name->Length > 0 );
    ASSERT( Name->Buffer != NULL );

    for ( Index = 0 ; Index < Name->Length ; Index += sizeof( WCHAR )) {

        if ( Name->Buffer[Index / sizeof( WCHAR )] == L'.' ) {

            Found = TRUE;
            Index += sizeof( WCHAR );
            break;
        }
    }

    ASSERT( !Found || Index < Name->Length );

    Name->Buffer += Index / sizeof( WCHAR );
    Name->Length = Name->Length - Index;
    Name->MaximumLength = Name->MaximumLength - Index;

    ASSERT( Found || Name->Length == 0 );

    return ( Found );
}





//+-------------------------------------------------------------------------
//
//  Function:   KerbSpnSubstringMatch
//
//  Synopsis:   Attempts to match an SPN to a known realm mapping
//
//  Effects:    Returns a new target realm.
//
//  Arguments:  decrements reference count and delets cache entry if it goes
//              to zero
//
//  Requires:   SpnCacheEntry - The spn cache entry to dereference.
//
//  Returns:    none
//
//  Notes:
//
//
//--
NTSTATUS
KerbSpnSubstringMatch(
    IN PKERB_INTERNAL_NAME Spn,
    IN OUT PUNICODE_STRING TargetRealm
    )
{
    
    UNICODE_STRING      RemainingParts ={0};
    NTSTATUS            Status = STATUS_SUCCESS;
    PHOST_TO_REALM_KEY  MatchedRealm = NULL; 
    PWCHAR              FreeMe;

    //
    // The SPN must have at least 2 parts (host / machine . realm )
    //
    if ( !HostToRealmUsed || Spn->NameCount < 2 )
    {                 
        Status = STATUS_NO_MATCH;
        return Status;
    }
    
    //
    // Try first component.
    //
    SafeAllocaAllocate( RemainingParts.Buffer, Spn->Names[1].MaximumLength );
        
    if ( RemainingParts.Buffer == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    FreeMe = RemainingParts.Buffer; // note: KerbParseDnsName will move buffer ptr.
                                                                             
    RtlCopyMemory(
        RemainingParts.Buffer,
        Spn->Names[1].Buffer,
        Spn->Names[1].MaximumLength
        );
    
    RemainingParts.Length = Spn->Names[1].Length;
    RemainingParts.MaximumLength = Spn->Names[1].MaximumLength;

    //
    // All realms are stored in UPPERCASE in the table.
    //
    if (!NT_SUCCESS(RtlUpcaseUnicodeString(&RemainingParts,&Spn->Names[1],FALSE)))
    {
        SafeAllocaFree( FreeMe );
        return STATUS_INTERNAL_ERROR;
    }


    HostToRealmReadLock();

    do
    {  
        MatchedRealm = (PHOST_TO_REALM_KEY) RtlLookupElementGenericTableAvl(
                                                        &HostToRealmTable,
                                                        &RemainingParts
                                                        );            



    } while (( MatchedRealm == NULL ) && KerbParseDnsName(&RemainingParts));

    SafeAllocaFree( FreeMe );
    
    if ( MatchedRealm == NULL )
    {
        D_DebugLog((DEB_TRACE_SPN_CACHE, "Missed cache for %wZ\n", &Spn->Names[1]));
        HostToRealmUnlock();
        return STATUS_NO_MATCH;
    }
    
    D_DebugLog((DEB_TRACE_SPN_CACHE, "HIT cache for %wZ\n", &Spn->Names[1]));
    D_DebugLog((DEB_TRACE_SPN_CACHE, "Realm %wZ\n", &MatchedRealm->TargetRealm)); 
    
    Status = KerbDuplicateString(
                TargetRealm,
                &MatchedRealm->TargetRealm
                );

    HostToRealmUnlock();
    return Status;
}







//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateSpnMappings
//
//  Synopsis:   Uses registry to create 
//
//  Effects:    Increments the reference count on the spn cache entry
//
//  Arguments:  SpnCacheEntry - spn cache entry  to reference
//
//  Requires:   The spn cache must be locked
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------
#define MAX_KEY_NAME 512
VOID
KerbCreateHostToRealmMappings()
{  
    DWORD WinError, KeyIndex = 0;
    NTSTATUS Status = STATUS_SUCCESS; 
    HKEY Key = NULL, SubKey = NULL;
    WCHAR KeyName[MAX_KEY_NAME];
    DWORD KeyNameSize = MAX_KEY_NAME;

    if (!HostToRealmInitialized)
    {
        DsysAssert(FALSE);
        return;
    }


    HostToRealmWriteLock();

    WinError = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    KERB_HOST_TO_REALM_KEY,
                    0,
                    KEY_READ,
                    &Key
                    );
    
    if (WinError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    while (TRUE)
    { 
        WinError = RegEnumKeyExW(
                        Key,
                        KeyIndex,
                        KeyName,
                        &KeyNameSize,
                        NULL,
                        NULL,
                        NULL,
                        NULL
                        );

        if (WinError != ERROR_SUCCESS)
        {   
            D_DebugLog((DEB_ERROR, "RegEnumKeyExW failed - %x\n", WinError));
            goto Cleanup;
        }

        WinError = RegOpenKeyExW(
                        Key,
                        KeyName,
                        0,
                        KEY_READ,
                        &SubKey
                        );

        if (WinError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        Status = KerbAddHostToRealmMapping(
                        SubKey,
                        KeyName
                        );

        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"KerbAddHostToRealmMapping failed! - %x\n", Status));
            goto LocalCleanup;
        }
                  
LocalCleanup:

        if (SubKey != NULL)
        {
            RegCloseKey(SubKey);
            SubKey = NULL;
        }
    
        KeyIndex++;
        KeyNameSize = MAX_KEY_NAME;


    } // ** WHILE **
        
     
Cleanup:
    
    if (SubKey != NULL)
    {
        RegCloseKey(SubKey);
    }

    if (Key != NULL)
    {
        RegCloseKey(Key);
    }  

    HostToRealmUnlock();


}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCleanupResult
//
//  Synopsis:   Cleans up result entry
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:   
//
//  Returns:    none
//
//  Notes:
//
//
//+-------------------------------------------------------------------------

VOID
KerbCleanupResult(
    IN PSPN_CACHE_RESULT Result
    )
{
    KerbFreeString(&Result->AccountRealm);
    KerbFreeString(&Result->TargetRealm);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbPurgeResultByIndex
//
//  Synopsis:   Removes 
//
//  Effects:    Dereferences the spn cache entry to make it go away
//              when it is no longer being used.
//
//  Arguments:  decrements reference count and delets cache entry if it goes
//              to zero
//
//  Requires:   SpnCacheEntry - The spn cache entry to dereference.
//
//  Returns:    none
//
//  Notes:
//
//
//+-------------------------------------------------------------------------
VOID
KerbPurgeResultByIndex(
    IN PKERB_SPN_CACHE_ENTRY CacheEntry,
    IN ULONG IndexToPurge
    )
{

    ULONG i;  
    DebugLog((DEB_ERROR, "Purging %p, %i\n", CacheEntry, IndexToPurge));
    
    KerbCleanupResult(&CacheEntry->Results[IndexToPurge]);

    CacheEntry->ResultCount--; 

    for (i = IndexToPurge; i < CacheEntry->ResultCount; i++)
    {   
        CacheEntry->Results[i] = CacheEntry->Results[i+1];
    } 

    //
    // Zero out fields in last entry so we don't leak on an error path (or free
    // bogus info) if we reuse the entry...
    //
    RtlZeroMemory(
            &CacheEntry->Results[i],
            sizeof(SPN_CACHE_RESULT)
            );
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceSpnCacheEntry
//
//  Synopsis:   Dereferences a spn cache entry
//
//  Effects:    Dereferences the spn cache entry to make it go away
//              when it is no longer being used.
//
//  Arguments:  decrements reference count and delets cache entry if it goes
//              to zero
//
//  Requires:   SpnCacheEntry - The spn cache entry to dereference.
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbDereferenceSpnCacheEntry(
    IN PKERB_SPN_CACHE_ENTRY SpnCacheEntry
    )
{
    
    if (KerbDereferenceListEntry(
            &SpnCacheEntry->ListEntry,
            &KerbSpnCache
            ) )
    {
        KerbFreeSpnCacheEntry(SpnCacheEntry);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceSpnCacheEntry
//
//  Synopsis:   References a spn cache entry
//
//  Effects:    Increments the reference count on the spn cache entry
//
//  Arguments:  SpnCacheEntry - spn cache entry  to reference
//
//  Requires:   The spn cache must be locked
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbReferenceSpnCacheEntry(
    IN PKERB_SPN_CACHE_ENTRY SpnCacheEntry,
    IN BOOLEAN RemoveFromList
    )
{
    KerbWriteLockSpnCache();

    KerbReferenceListEntry(
        &KerbSpnCache,
        &SpnCacheEntry->ListEntry,
        RemoveFromList
        );

    KerbUnlockSpnCache();
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbAgeResults
//
//  Synopsis:   Ages out a given cache entry's result list.  Used
//              to reduce the result list to a manageable size, and
//              as a scavenger to cleanup orphaned / unused entries.
//
//  Effects:    Increments the reference count on the spn cache entry
//
//  Arguments:  SpnCacheEntry - spn cache entry  to reference
//
//  Requires:   The spn cache must be locked
//
//  Returns:    none
//
//  Notes:
//
//
//+-------------------------------------------------------------------------
       
VOID
KerbAgeResults(
    IN PKERB_SPN_CACHE_ENTRY CacheEntry
    )
    
{
    TimeStamp CurrentTime, BackoffTime;                            
    ULONG i;
    LONG Interval;

    GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);

    //
    // Age out everything older than GlobalSpnCacheTimeout first.
    //
    for ( i = 0; i < CacheEntry->ResultCount; i++ )
    { 
        if (KerbGetTime(CacheEntry->Results[i].CacheStartTime) + KerbGetTime(KerbGlobalSpnCacheTimeout) < KerbGetTime(CurrentTime))
        {   
            D_DebugLog((DEB_TRACE_SPN_CACHE, "removing %x %p\n"));
            KerbPurgeResultByIndex(CacheEntry, i);
        }   
    }

    if ( CacheEntry->ResultCount < MAX_RESULTS )
    {   
        return; 
    }

    
    for ( Interval = 13; Interval > 0; Interval -= 4)
    {
       KerbSetTimeInMinutes(&BackoffTime, Interval);
       for ( i=0; i < CacheEntry->ResultCount ; i++ )
       { 
           if (KerbGetTime(CacheEntry->Results[i].CacheStartTime) + KerbGetTime(BackoffTime) < KerbGetTime(CurrentTime))
           {   
               D_DebugLog((DEB_TRACE_SPN_CACHE, "removing %x %p\n"));
               KerbPurgeResultByIndex(CacheEntry, i);
           }   
       }

       if ( CacheEntry->ResultCount < MAX_RESULTS )
       {    
            return; 
       }
    }

    //
    // Still have MAX_RESULTS after all that geezzz..  
    //
    DebugLog((DEB_ERROR, "Can't get below MAX_RESULTS (%p) \n", CacheEntry ));
    DsysAssert(FALSE);                                                     

    for ( i=0; i < CacheEntry->ResultCount ; i++ )                         
    {   
        KerbPurgeResultByIndex(CacheEntry, i);                
    } 

    return;           
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbTaskSpnCacheScavenger
//
//  Synopsis:   Cleans up any old SPN cache entries.  Triggered by 30 minute
//              task.
//
//  Effects:    
//
//  Arguments:  SpnCacheEntry - spn cache entry  to reference
//
//  Requires:   The spn cache entry must be locked
//
//  Returns:    none
//
//  Notes:
//
//
//
VOID
KerbSpnCacheScavenger()
{

    PKERB_SPN_CACHE_ENTRY CacheEntry = NULL;
    PLIST_ENTRY ListEntry;
    BOOLEAN     FreeMe = FALSE;  

    KerbWriteLockSpnCache();

    for (ListEntry = KerbSpnCache.List.Flink ;
         ListEntry !=  &KerbSpnCache.List ;
         ListEntry = ListEntry->Flink )
    {
        CacheEntry = CONTAINING_RECORD(ListEntry, KERB_SPN_CACHE_ENTRY, ListEntry.Next);

        KerbWriteLockSpnCacheEntry( CacheEntry );
        KerbAgeResults(CacheEntry);

        //
        // Time to pull this one from list.
        //
        if ( CacheEntry->ResultCount == 0 )
        {
            ListEntry = ListEntry->Blink;

            KerbReferenceSpnCacheEntry(
                    CacheEntry,
                    TRUE
                    );
            
            FreeMe = TRUE;
        }             
        
        KerbUnlockSpnCacheEntry( CacheEntry );  
 
        //
        // Pull the list reference.
        //
        if ( FreeMe )
        { 
            KerbDereferenceSpnCacheEntry( CacheEntry );        
            FreeMe = FALSE;
        }
    }

    KerbUnlockSpnCache();

}





//+-------------------------------------------------------------------------
//
//  Function:   KerbAddCacheResult
//
//  Synopsis:   Uses registry to create 
//
//  Effects:    Increments the reference count on the spn cache entry
//
//  Arguments:  SpnCacheEntry - spn cache entry  to reference
//
//  Requires:   The spn cache resource must be locked
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbAddCacheResult(
    IN PKERB_SPN_CACHE_ENTRY CacheEntry,
    IN PKERB_PRIMARY_CREDENTIAL AccountCredential,
    IN ULONG UpdateFlags,
    IN OPTIONAL PUNICODE_STRING NewRealm
    )
{

    NTSTATUS          Status = STATUS_SUCCESS;
    PSPN_CACHE_RESULT Result = NULL;
    
    D_DebugLog((DEB_TRACE_SPN_CACHE, "KerbAddCacheResult add domain %wZ to _KERB_SPN_CACHE_ENTRY %p (UpdateFlags %#x), NewRealm %wZ for ", &AccountCredential->DomainName, CacheEntry, UpdateFlags, NewRealm));
    D_KerbPrintKdcName((DEB_TRACE_SPN_CACHE, CacheEntry->Spn));

    //
    // If we don't have an account realm w/ this credential (e.g someone 
    // supplied you a UPN to acquirecredentialshandle, don't use the
    // spn cache.
    //
    if ( AccountCredential->DomainName.Length == 0 )
    {   
        return STATUS_NOT_SUPPORTED;
    }    


    //
    // First off, see if we're hitting the limits for our array.
    // We shouldn't ever get close to MAX_RESULTS, but if we do,
    // age out the least current CacheResult.
    //
    if ( (CacheEntry->ResultCount + 1) == MAX_RESULTS )
    {
        KerbAgeResults(CacheEntry);
    }

    Result = &CacheEntry->Results[CacheEntry->ResultCount];

    Status = KerbDuplicateStringEx( 
                &Result->AccountRealm,
                &AccountCredential->DomainName,
                FALSE
                );

    if (!NT_SUCCESS( Status ))
    {  
        goto Cleanup;
    }

    if (ARGUMENT_PRESENT( NewRealm ))
    {  
        D_DebugLog((DEB_TRACE_SPN_CACHE, "Known - realm %wZ\n", NewRealm));
        DsysAssert(UpdateFlags != KERB_SPN_UNKNOWN);

        Status = KerbDuplicateStringEx( 
                    &Result->TargetRealm,
                    NewRealm,
                    FALSE
                    );
    
        if (!NT_SUCCESS( Status ))
        {  
            goto Cleanup;
        }
    }

#if DBG

    else
    {
        DsysAssert(UpdateFlags != KERB_SPN_KNOWN);
    }

#endif

    Result->CacheFlags = UpdateFlags;
    GetSystemTimeAsFileTime((PFILETIME) &Result->CacheStartTime);
    CacheEntry->ResultCount++;


Cleanup:

    if (!NT_SUCCESS( Status ) )
    {   
        if ( Result != NULL )
        {
            KerbCleanupResult( Result );
        }
    }             

    return Status;
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbBuildSpnCacheEntry
//
//  Synopsis:   Builds a spn cache entry
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:   SpnCacheEntry - The spn cache entry to dereference.
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateSpnCacheEntry(
    IN PKERB_INTERNAL_NAME      Spn,
    IN PKERB_PRIMARY_CREDENTIAL AccountCredential,
    IN ULONG                    UpdateFlags,
    IN OPTIONAL PUNICODE_STRING NewRealm,
    IN OUT PKERB_SPN_CACHE_ENTRY* NewCacheEntry
    )
{

    NTSTATUS Status;          
    PKERB_SPN_CACHE_ENTRY CacheEntry = NULL;
    BOOLEAN               FreeResource = FALSE;

    *NewCacheEntry = NULL;    

    CacheEntry = (PKERB_SPN_CACHE_ENTRY) KerbAllocate( sizeof(KERB_SPN_CACHE_ENTRY) );
    if ( CacheEntry == NULL )
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }                                              

    Status = KerbDuplicateKdcName(
                &CacheEntry->Spn,
                Spn
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbAddCacheResult(
                CacheEntry,
                AccountCredential,
                UpdateFlags,
                NewRealm
                );

    if (!NT_SUCCESS( Status ))
    {
        goto Cleanup;
    }                

    KerbInitializeListEntry( &CacheEntry->ListEntry );

    __try
    {
        RtlInitializeResource( &CacheEntry->ResultLock );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        Status =  STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    } 

    FreeResource = TRUE;

    KerbInsertSpnCacheEntry(CacheEntry);

    *NewCacheEntry = CacheEntry; 
    CacheEntry = NULL;

    InterlockedIncrement( &SpnCount );

Cleanup:

    if (!NT_SUCCESS(Status) && ( CacheEntry ))
    {
       KerbCleanupResult(&CacheEntry->Results[0]);
       KerbFreeKdcName( &CacheEntry->Spn );
       
       if ( FreeResource )
       {
           RtlDeleteResource( &CacheEntry->ResultLock );
       }                                                

       KerbFree(CacheEntry);
    }                                             

    return Status;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbScanResults
//
//  Synopsis:   Scans result list.
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:   SpnCacheEntry - The spn cache entry to dereference.
//
//  Returns:    none
//
//  Notes:
//
//
//---

BOOLEAN
KerbScanResults(
    IN PKERB_SPN_CACHE_ENTRY CacheEntry,
    IN PUNICODE_STRING Realm,
    IN OUT PULONG Index
    )
{
    BOOLEAN Found = FALSE;
    ULONG i;
    
    for ( i=0; i < CacheEntry->ResultCount; i++)
    { 
        if (RtlEqualUnicodeString(
                &CacheEntry->Results[i].AccountRealm,
                Realm,
                TRUE
                ))
        {
            Found = TRUE;
            *Index = i;
            break;
        }
    }

    return Found;
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbUpdateSpnCacheEntry
//
//  Synopsis:   Updates a spn cache entry
//
//  Effects:    
//
//  Arguments:  
//
//  Requires:   SpnCacheEntry - The spn cache entry to dereference.
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbUpdateSpnCacheEntry(
    IN OPTIONAL PKERB_SPN_CACHE_ENTRY ExistingCacheEntry,
    IN PKERB_INTERNAL_NAME      Spn,
    IN PKERB_PRIMARY_CREDENTIAL AccountCredential,
    IN ULONG                    UpdateFlags,
    IN OPTIONAL PUNICODE_STRING NewRealm
    )
{
    PKERB_SPN_CACHE_ENTRY CacheEntry = ExistingCacheEntry;
    NTSTATUS              Status = STATUS_SUCCESS;
    BOOLEAN               Found = FALSE, Update = FALSE;
    ULONG                 Index = 0;

    //
    // We're not using SPN cache
    //
    if (KerbGlobalSpnCacheTimeout.QuadPart == 0 || !KerberosSpnCacheInitialized )
    {
        return STATUS_SUCCESS;
    }

    //
    // If we didn't have a cache entry before, see if we do now, or create
    // one if necessary.
    //
   
    if (!ARGUMENT_PRESENT( ExistingCacheEntry ))
    {
        KerbWriteLockSpnCache();
        CacheEntry = KerbLocateSpnCacheEntry( Spn );

        if ( CacheEntry == NULL)
        {
            Status = KerbCreateSpnCacheEntry(
                        Spn,
                        AccountCredential,
                        UpdateFlags,
                        NewRealm,
                        &CacheEntry
                        );

            if (NT_SUCCESS(Status))
            {
                //
                // All done, get outta here.
                //
                D_DebugLog((DEB_TRACE_SPN_CACHE, "Created new cache entry %p (%x) \n", CacheEntry, UpdateFlags));
                D_KerbPrintKdcName((DEB_TRACE_SPN_CACHE, Spn));
                D_DebugLog((DEB_TRACE_SPN_CACHE, "%wZ\n", &AccountCredential->DomainName));

                KerbDereferenceSpnCacheEntry( CacheEntry );
            }
            
            KerbUnlockSpnCache();
            return Status;
        }   

        KerbUnlockSpnCache();
    }


    //
    // Got an existing entry - update it.
    //
    KerbReadLockSpnCacheEntry( CacheEntry );  
    
    if (KerbScanResults(
                    CacheEntry,
                    &AccountCredential->DomainName,
                    &Index
                    ))
    {
        Found = TRUE;
        Update = (( CacheEntry->Results[Index].CacheFlags & UpdateFlags) != UpdateFlags);
    }

    KerbUnlockSpnCacheEntry( CacheEntry );

    //
    // To avoid always taking the write lock, we'll need to rescan the result
    // list under a write lock.
    //
    if ( Update )
    {
        KerbWriteLockSpnCacheEntry( CacheEntry );

        if (KerbScanResults(
                CacheEntry,
                &AccountCredential->DomainName,
                &Index
                ))
        {
            //
            // Hasn't been updated or removed in the small time slice above.  Update.
            //

            if (( CacheEntry->Results[Index].CacheFlags & UpdateFlags) != UpdateFlags )
            {
                D_DebugLog(( 
                     DEB_TRACE_SPN_CACHE, 
                     "KerbUpdateSpnCacheEntry changing _KERB_SPN_CACHE_ENTRY %p Result Index %#x: AccountRealm %wZ, TargetRealm %wZ, NewRealm %wZ, CacheFlags %#x to CacheFlags %#x for ", 
                     CacheEntry,
                     Index,
                     &CacheEntry->Results[Index].AccountRealm,
                     &CacheEntry->Results[Index].TargetRealm,
                     NewRealm,
                     CacheEntry->Results[Index].CacheFlags, 
                     UpdateFlags
                     ));
                D_KerbPrintKdcName((DEB_TRACE_SPN_CACHE, CacheEntry->Spn));

                CacheEntry->Results[Index].CacheFlags = UpdateFlags;
                GetSystemTimeAsFileTime( (LPFILETIME) &CacheEntry->Results[Index].CacheStartTime );

                KerbFreeString(&CacheEntry->Results[Index].TargetRealm);

                if (ARGUMENT_PRESENT( NewRealm ))
                {
                    DsysAssert( UpdateFlags == KERB_SPN_KNOWN );
                    Status = KerbDuplicateStringEx(
                                    &CacheEntry->Results[Index].TargetRealm,
                                    NewRealm,
                                    FALSE
                                    );

                    if (!NT_SUCCESS( Status ))
                    {
                        KerbUnlockSpnCacheEntry( CacheEntry );
                        goto Cleanup;
                    }                
                }                     
            }
        }
        else
        {
            Found = FALSE;
        }

        KerbUnlockSpnCacheEntry( CacheEntry ); 
    }

    if (!Found)
    {   
        KerbWriteLockSpnCacheEntry ( CacheEntry );

        //
        // Still not found
        //
        if (!KerbScanResults( CacheEntry, &AccountCredential->DomainName, &Index ))
        {
            Status = KerbAddCacheResult(
                        CacheEntry,
                        AccountCredential,
                        UpdateFlags,
                        NewRealm
                        );
        }

        KerbUnlockSpnCacheEntry( CacheEntry );

        if (!NT_SUCCESS(Status))
        {   
            goto Cleanup;
        }
    }  


Cleanup:
    
    //
    // Created a new cache entry, referenced w/i this function.
    //
    if (!ARGUMENT_PRESENT( ExistingCacheEntry ) && CacheEntry )
    {
        KerbDereferenceSpnCacheEntry( CacheEntry );
    }

    return Status;
}







//+-------------------------------------------------------------------------
//
//  Function:   KerbLocateSpnCacheEntry
//
//  Synopsis:   References a spn cache entry by name
//
//  Effects:    Increments the reference count on the spn cache entry
//
//  Arguments:  RealmName - Contains the name of the realm for which to
//                      obtain a binding handle.
//              DesiredFlags - Flags desired for binding, such as PDC required
//              RemoveFromList - Remove cache entry from cache when found.
//
//  Requires:
//
//  Returns:    The referenced cache entry or NULL if it was not found.
//
//  Notes:      If an invalid entry is found it may be dereferenced
//
//
//--------------------------------------------------------------------------

PKERB_SPN_CACHE_ENTRY
KerbLocateSpnCacheEntry(
    IN PKERB_INTERNAL_NAME Spn
    )
{
    PLIST_ENTRY ListEntry;
    PKERB_SPN_CACHE_ENTRY CacheEntry = NULL;
    BOOLEAN Found = FALSE;
    
    if (Spn->NameType != KRB_NT_SRV_INST)
    {
        return NULL;
    }

#if DBG
    
    KerbLogSpnStats(Spn);

#endif
    
    //
    // We're not using SPN cache
    //
    if (KerbGlobalSpnCacheTimeout.QuadPart == 0 || !KerberosSpnCacheInitialized )
    {
        return NULL;
    }
          

    //
    // Scale the cache by aging out old entries.
    //
    if ( SpnCount > MAX_CACHE_ENTRIES )
    {
        KerbSpnCacheScavenger();
    }                               

    KerbReadLockSpnCache();
    //
    // Go through the spn cache looking for the correct entry
    //

    for (ListEntry = KerbSpnCache.List.Flink ;
         ListEntry !=  &KerbSpnCache.List ;
         ListEntry = ListEntry->Flink )
    {   
        CacheEntry = CONTAINING_RECORD(ListEntry, KERB_SPN_CACHE_ENTRY, ListEntry.Next);
        
        if (KerbEqualKdcNames(CacheEntry->Spn,Spn))
        {                
            KerbReferenceSpnCacheEntry(
                    CacheEntry,
                    FALSE
                    ); 

            D_DebugLog((DEB_TRACE_SPN_CACHE, "SpnCacheEntry %p\n", CacheEntry));

            Found = TRUE;
            break;
        }
    }

    if (!Found)
    {
        CacheEntry = NULL;
    }

    

    KerbUnlockSpnCache();           
    return(CacheEntry);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCleanupResultList
//
//  Synopsis:   Frees memory associated with a result list
//
//  Effects:
//
//  Arguments:  SpnCacheEntry - The cache entry to free. It must be
//                      unlinked, and the Resultlock must be held.
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbCleanupResultList(
    IN PKERB_SPN_CACHE_ENTRY CacheEntry
    )
{
    for (ULONG i = 0; i < CacheEntry->ResultCount; i++)
    {
        KerbCleanupResult(&CacheEntry->Results[i]);
    }

    CacheEntry->ResultCount = 0;
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeSpnCacheEntry
//
//  Synopsis:   Frees memory associated with a spn cache entry
//
//  Effects:
//
//  Arguments:  SpnCacheEntry - The cache entry to free. It must be
//                      unlinked.
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbFreeSpnCacheEntry(
    IN PKERB_SPN_CACHE_ENTRY SpnCacheEntry
    )
{
    
    //
    // Must be unlinked..
    //
    DsysAssert(SpnCacheEntry->ListEntry.Next.Flink == NULL);
    DsysAssert(SpnCacheEntry->ListEntry.Next.Blink == NULL);
    
    KerbWriteLockSpnCacheEntry(SpnCacheEntry);    
    KerbCleanupResultList(SpnCacheEntry);         
    KerbUnlockSpnCacheEntry(SpnCacheEntry);
    
    RtlDeleteResource(&SpnCacheEntry->ResultLock);
    KerbFreeKdcName(&SpnCacheEntry->Spn);
    KerbFree(SpnCacheEntry);

    InterlockedDecrement( &SpnCount );
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInsertBinding
//
//  Synopsis:   Inserts a binding into the spn cache
//
//  Effects:    bumps reference count on binding
//
//  Arguments:  CacheEntry - Cache entry to insert
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS always
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInsertSpnCacheEntry(
    IN PKERB_SPN_CACHE_ENTRY CacheEntry
    )
{
    IF_DEBUG(DISABLE_SPN_CACHE) 
    {
        DebugLog((DEB_TRACE_SPN_CACHE, "KerbInsertSpnCacheEntry spn cache disabled\n"));
        return STATUS_SUCCESS;
    }   

    KerbInsertListEntry(
        &CacheEntry->ListEntry,
        &KerbSpnCache
        );

    return(STATUS_SUCCESS);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetSpnCacheStatus
//
//  Synopsis:   Gets the status of a cache entry for a given realm.
//
//  Effects:    Returns STATUS_NO_SAM_TRUST_RELATIONSHIP for unknown SPNs,
//              STATUS_NO_MATCH, if we're missing a realm result, or
//              STATUS_SUCCESS ++ dupe the SPNREalm for the "real" realm
//              of the SPN relative to the account realm.
//
//  Arguments:  CacheEntry - SPN cache entry from ProcessTargetName()
//              Credential - Primary cred for account realm.
//              SpnRealm - IN OUT Filled in w/ target realm of SPN
//              
//              
//  Requires:
//
//  Returns:     
//
//  Notes:      
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetSpnCacheStatus(
    IN PKERB_SPN_CACHE_ENTRY CacheEntry,
    IN PKERB_PRIMARY_CREDENTIAL Credential,
    IN OUT PUNICODE_STRING SpnRealm
    )
{   
    NTSTATUS        Status = STATUS_NO_MATCH;;
    ULONG           i;
    TimeStamp       CurrentTime;     
    BOOLEAN         Purge = FALSE;

    GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);  

    //
    // Read Lock the spn cache entry
    //
    KerbReadLockSpnCacheEntry( CacheEntry );    

    if (KerbScanResults(
            CacheEntry,
            &Credential->DomainName,
            &i
            ))
    {
        if (CacheEntry->Results[i].CacheFlags & KERB_SPN_UNKNOWN)
        { 
            //
            // Check and see if this timestamp has expired.
            //          
            if (KerbGetTime(CacheEntry->Results[i].CacheStartTime) + KerbGetTime(KerbGlobalSpnCacheTimeout) < KerbGetTime(CurrentTime))
            {   
                Purge = TRUE;            
                Status = STATUS_SUCCESS;
            }   
            else
            {
                Status = STATUS_NO_TRUST_SAM_ACCOUNT;
                DebugLog((DEB_WARN, "SPN not found\n"));
                KerbPrintKdcName(DEB_WARN, CacheEntry->Spn);
            }
        }
        else if (CacheEntry->Results[i].CacheFlags & KERB_SPN_KNOWN)
        {
            Status = KerbDuplicateStringEx(
                            SpnRealm,
                            &CacheEntry->Results[i].TargetRealm,
                            FALSE
                            );

            D_DebugLog((DEB_TRACE_SPN_CACHE, "Found %wZ\n", SpnRealm));
            D_KerbPrintKdcName((DEB_TRACE_SPN_CACHE, CacheEntry->Spn));
        }
    }

    KerbUnlockSpnCacheEntry( CacheEntry );

    if (!NT_SUCCESS( Status ))
    {
        return Status; 
    }

    //
    // Take the write lock, and verify that we still need to purge the above 
    // result.
    //
    if ( Purge )
    {
        KerbWriteLockSpnCacheEntry( CacheEntry );
        if (KerbScanResults(
              CacheEntry,
              &Credential->DomainName,
              &i
              ))
        {
            if (KerbGetTime(CacheEntry->Results[i].CacheStartTime) + 
                KerbGetTime(KerbGlobalSpnCacheTimeout) < KerbGetTime(CurrentTime))
            {
                D_DebugLog((DEB_TRACE_SPN_CACHE, "Purging %p due to time\n", &CacheEntry->Results[i]));
                KerbPurgeResultByIndex( CacheEntry, i ); 
            }                                            
        }

        KerbUnlockSpnCacheEntry( CacheEntry );
        Status = STATUS_NO_MATCH;
    }                                         

    return Status;                            
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\spncache.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        spncache.h
//
// Contents:    Prototypes and types for SPN cache
//
//
// History:     29-August-2000  Created         MikeSw
//
//------------------------------------------------------------------------
#ifndef __SPNCACHE_H__
#define __SPNCACHE_H__


extern BOOLEAN KerberosSpnCacheInitialized;
extern KERBEROS_LIST KerbSpnCache;

typedef struct _HOST_TO_REALM_KEY { 
        UNICODE_STRING SpnSuffix; // MUST be the first field
        UNICODE_STRING TargetRealm;
#pragma warning(disable:4200)
        WCHAR NameBuffer[];
#pragma warning(default:4200)
} HOST_TO_REALM_KEY, *PHOST_TO_REALM_KEY;
   

//
// The below value tells us when to start scavenging 
// our cache
//                           
#define MAX_CACHE_ENTRIES   350


typedef struct _SPN_CACHE_RESULT {
    UNICODE_STRING AccountRealm;
    UNICODE_STRING TargetRealm;
    ULONG          CacheFlags;
    TimeStamp      CacheStartTime;
} SPN_CACHE_RESULT, *PSPN_CACHE_RESULT;


#define MAX_RESULTS 16

typedef struct _KERB_SPN_CACHE_ENTRY {
    KERBEROS_LIST_ENTRY ListEntry;
    PKERB_INTERNAL_NAME Spn;
    RTL_RESOURCE        ResultLock;       
    ULONG               ResultCount;
    SPN_CACHE_RESULT    Results[MAX_RESULTS];
} KERB_SPN_CACHE_ENTRY, *PKERB_SPN_CACHE_ENTRY;


//
//  Valid CacheFlags
//
#define KERB_SPN_UNKNOWN   0x1
#define KERB_SPN_KNOWN     0x2

#define KERB_SPNCACHE_KEY L"System\\CurrentControlSet\\Control\\Lsa\\Kerberos\\SpnCache"
#define KERB_REALM_STRING L"Realm"
#define KERB_HOST_TO_REALM_KEY L"System\\CurrentControlSet\\Control\\Lsa\\Kerberos\\HostToRealm"
#define KERB_HOST_TO_REALM_VAL L"SpnMappings"



VOID
KerbCreateHostToRealmMappings();

VOID
KerbRefreshHostToRealmTable();

NTSTATUS
KerbGetSpnCacheStatus(
    IN PKERB_SPN_CACHE_ENTRY CacheEntry,
    IN PKERB_PRIMARY_CREDENTIAL Credential,
    IN OUT PUNICODE_STRING SpnRealm
    );

NTSTATUS
KerbSpnSubstringMatch(
    IN PKERB_INTERNAL_NAME Spn,
    IN OUT PUNICODE_STRING TargetRealm
    ); 
VOID
KerbCleanupSpnCache(
    VOID
    );

VOID
KerbFreeSpnCacheEntry(
    IN PKERB_SPN_CACHE_ENTRY SpnCacheEntry
    );

NTSTATUS
KerbInitSpnCache(
    VOID
    );



NTSTATUS
KerbInsertSpnCacheEntry(
    IN PKERB_SPN_CACHE_ENTRY CacheEntry
    );

VOID
KerbDereferenceSpnCacheEntry(
    IN PKERB_SPN_CACHE_ENTRY SpnCacheEntry
    );

PKERB_SPN_CACHE_ENTRY
KerbLocateSpnCacheEntry(
    IN PKERB_INTERNAL_NAME Spn
    );

NTSTATUS
KerbUpdateSpnCacheEntry(
    IN OPTIONAL PKERB_SPN_CACHE_ENTRY ExistingCacheEntry,
    IN PKERB_INTERNAL_NAME      Spn,
    IN PKERB_PRIMARY_CREDENTIAL AccountCredential,
    IN ULONG                    UpdateFlags,
    IN OPTIONAL PUNICODE_STRING NewRealm
    );


#endif // __TKTCACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\timesync.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        timesync.cxx
//
// Contents:    Code for logon and logoff for the Kerberos package
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------
#include <kerb.hxx>
#define TIMESYNC_ALLOCATE
#include <kerbp.h>
extern "C"
{
#include <w32timep.h>
}

#ifndef WIN32_CHICAGO



//+-------------------------------------------------------------------------
//
//  Function:   KerbTimeSyncWorker
//
//  Synopsis:   Does work of time sync
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


ULONG
KerbTimeSyncWorker(PVOID Dummy)
{
    HANDLE hTimeSlipEvent = NULL; 
    ULONG Status = STATUS_SUCCESS;

    D_DebugLog((DEB_TRACE_TIME, "Calling W32TimeSyncNow\n"));
    if (InterlockedIncrement(&KerbSkewState.ActiveSyncs) == 1)
    {
        // Use this named event instead of W32TimeSyncNow().  W32TimeSyncNow uses kerberos to 
        // make an authenticated RPC call, which can fail if there is a time skew.  We should
        // be able to set the named event regardless of skew.  
        hTimeSlipEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, W32TIME_NAMED_EVENT_SYSTIME_NOT_CORRECT); 
        if (NULL == hTimeSlipEvent) { 
            Status = GetLastError(); 
        } else { 
            if (!SetEvent(hTimeSlipEvent)) { 
                Status = GetLastError(); 
            }

            CloseHandle(hTimeSlipEvent); 
        }

        if (Status != ERROR_SUCCESS)
        {
            DebugLog((DEB_ERROR,"Failed to sync time: %d\n",Status));
        }
    }
    InterlockedDecrement(&KerbSkewState.ActiveSyncs);

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbKickoffTime
//
//  Synopsis:   Puts a item on scavenger queue to time sync
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbKickoffTimeSync(
    VOID
    )
{
    ULONG Index;

    //
    // Reset the time skew data so we don't sync too often.
    //

    for (Index = 0; Index < KerbSkewState.TotalRequests ; Index++ )
    {
        KerbSkewState.SkewEntries[Index].Skewed = FALSE;
        KerbSkewState.SkewEntries[Index].RequestTime = KerbGlobalWillNeverTime;

    }

    KerbSkewState.SkewedRequests = 0;
    KerbSkewState.SuccessRequests = KerbSkewState.TotalRequests;
    KerbSkewState.LastRequest = 0;

    LsaFunctions->RegisterNotification(
        KerbTimeSyncWorker,
        NULL,
        NOTIFIER_TYPE_IMMEDIATE,
        0,                       // no class
        NOTIFIER_FLAG_ONE_SHOT,
        0,
        NULL
        );
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbUpdateSkewTime
//
//  Synopsis:   Updates the statistics for time skew. If necessary, triggers
//              time skew in another thread
//
//  Effects:
//
//  Arguments:  Skewed  - The last request did not generate a time skew error
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbUpdateSkewTime(
    IN BOOLEAN Skewed
    )
{
    TimeStamp CurrentTime;

    SafeEnterCriticalSection(&KerbSkewState.Lock);

    //
    // If this changes the entry, update the counts
    //

    if (Skewed != KerbSkewState.SkewEntries[KerbSkewState.LastRequest].Skewed)
    {
        if (KerbSkewState.SkewEntries[KerbSkewState.LastRequest].Skewed)
        {
            KerbSkewState.SkewedRequests--;
            KerbSkewState.SuccessRequests++;
        }
        else
        {
            KerbSkewState.SkewedRequests++;
            KerbSkewState.SuccessRequests--;
        }

        KerbSkewState.SkewEntries[KerbSkewState.LastRequest].Skewed = Skewed;
    }

    D_DebugLog((DEB_TRACE_TIME,"Updating skew statistics: Skewed = %d, successful = %d, latest = %s\n",
        KerbSkewState.SkewedRequests,
        KerbSkewState.SuccessRequests,
        Skewed ? "Skewed" : "Success"
        ));

    GetSystemTimeAsFileTime((PFILETIME)
        &CurrentTime
        );

    KerbSkewState.SkewEntries[KerbSkewState.LastRequest].RequestTime = CurrentTime;

    KerbSkewState.LastRequest = (KerbSkewState.LastRequest + 1) % KerbSkewState.TotalRequests;

    //
    // Check to see if this triggers a time sync, in that we have enough
    // failure events and the last sync was a while ago
    //

    if ((KerbSkewState.SkewedRequests > KerbSkewState.SkewThreshold) && // enough events
        ((CurrentTime.QuadPart - KerbSkewState.LastSync.QuadPart) >
            KerbSkewState.MinimumSyncLapse.QuadPart ) &&                // last sync a while ago
         (KerbSkewState.SkewEntries[KerbSkewState.LastRequest].RequestTime.QuadPart >
            KerbSkewState.LastSync.QuadPart ) )                         // all events were since the last sync
    {
        KerbSkewState.LastSync = CurrentTime;
        KerbKickoffTimeSync();
    }
    SafeLeaveCriticalSection(&KerbSkewState.Lock);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitializeSkewState
//
//  Synopsis:   Initializes all state for the time-sync code
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbInitializeSkewState(
    VOID
    )
{
    ULONG Index;
    NTSTATUS Status = STATUS_SUCCESS;
    KerbSkewState.TotalRequests = sizeof(KerbSkewEntries) / sizeof(KERB_TIME_SKEW_ENTRY);
    Status = SafeInitializeCriticalSection(
        &KerbSkewState.Lock,
        KERB_SKEW_STATE_LOCK_ENUM
        );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Initialize the list of skew entries to show that we are very successful
    //

    KerbSkewState.SkewEntries = KerbSkewEntries;
    for (Index = 0; Index < KerbSkewState.TotalRequests ; Index++ )
    {
        KerbSkewState.SkewEntries[Index].Skewed = FALSE;
        KerbSkewState.SkewEntries[Index].RequestTime = KerbGlobalWillNeverTime;

    }

    KerbSkewState.SkewedRequests = 0;
    KerbSkewState.SuccessRequests = KerbSkewState.TotalRequests;
    KerbSkewState.LastRequest = 0;
    //
    // We need to have 1/2 failures to trigger a skew
    //

    KerbSkewState.SkewThreshold = KerbSkewState.TotalRequests / 2;
    KerbSkewState.MinimumSyncLapse.QuadPart =
        (LONGLONG) 10000000 * 60 * 60;          // don't sync more than every hour
    //
    // Start off last sync at zero
    //

    KerbSkewState.LastSync.QuadPart = 0;
    KerbSkewState.ActiveSyncs = 0;
Cleanup:
    return(Status);
}
#else // WIN32_CHICAGO

VOID
KerbUpdateSkewTime(
    IN BOOLEAN Skewed
    )
{
    return;
}

NTSTATUS
KerbInitializeSkewState(
    VOID
    )
{
    return(STATUS_SUCCESS);
}

#endif // WIN32_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\timesync.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        timesync.h
//
// Contents:    Prototypes for time-sync functions
//
//
// History:     3-Nov-1997      MikeSw          Created
//
//------------------------------------------------------------------------

#ifndef __TIMESYNC_H__
#define __TIMESYNC_H__

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef TIMESYNC_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

typedef struct _KERB_TIME_SKEW_ENTRY {
    TimeStamp RequestTime;
    BOOLEAN Skewed;
} KERB_TIME_SKEW_ENTRY, *PKERB_TIME_SKEW_ENTRY;

typedef struct _KERB_TIME_SKEW_STATE {
    TimeStamp LastSync;                 // time of last sync
    TimeStamp MinimumSyncLapse;         // Minimum allowed time between sync requests
    ULONG SkewThreshold;                // number of skews to trigger sync
    ULONG TotalRequests;                // Number of entries to track
    ULONG SkewedRequests;               // number of time skew events
    ULONG SuccessRequests;              // number of success events
    ULONG LastRequest;                  // index into next skew entry
    LONG ActiveSyncs;                   // number of threads doing a sync
    PKERB_TIME_SKEW_ENTRY SkewEntries;  // array of skew entries
    SAFE_CRITICAL_SECTION Lock;          // lock for skew state
} KERB_TIME_SKEW_STATE, *PKERB_TIME_SKEW_STATE;

EXTERN KERB_TIME_SKEW_ENTRY KerbSkewEntries[10];
EXTERN KERB_TIME_SKEW_STATE KerbSkewState;

VOID
KerbUpdateSkewTime(
    IN BOOLEAN Skewed
    );

NTSTATUS
KerbInitializeSkewState(
    VOID
    );

#endif // __TIMESYNC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\tktcache.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        tktcache.cxx
//
// Contents:    Ticket cache for Kerberos Package
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#include <kerb.hxx>

#define TKTCACHE_ALLOCATE
#include <kerbp.h>


#ifdef DEBUG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

//
// Statistics for tracking hits/misses in cache
//

#define UpdateCacheHits() (InterlockedIncrement(&KerbTicketCacheHits))
#define UpdateCacheMisses() (InterlockedIncrement(&KerbTicketCacheMisses))

//
// Ticket expiration/renewal
//

void
KerbScheduleTgtRenewal(
    IN KERB_TICKET_CACHE_ENTRY * CacheEntry
    );

void
KerbTgtRenewalTrigger(
    void * TaskHandle,
    void * TaskItem
    );

void
KerbTgtRenewalReaper(
    void * TaskItem
    );

#if DBG
LIST_ENTRY GlobalTicketList;
#endif

LONG GlobalTicketListSize;
ULONG ScavengedSessions = 60;

//+-------------------------------------------------------------------------
//
//  Function:   KerbScheduleTicketCleanup
//
//  Synopsis:   Schedules garbage collection for tickets.
//
//  Effects:
//
//  Arguments:  TaskItem - cache entry to destroy
//
//  Requires:
//
//  Returns:    Nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbScheduleTicketCleanup()
{
    NTSTATUS Status;                               
    ULONG Interval = KERB_TICKET_COLLECTOR_INTERVAL; // change to global
    
    if ( Interval > 0 ) 
    {
        Status = KerbAddScavengerTask(
                            TRUE,
                            Interval,
                            0, // no special processing flags
                            KerbTicketScavenger,
                            NULL,
                            NULL,
                            NULL
                            );
        if (!NT_SUCCESS( Status ))
        {
            D_DebugLog((DEB_ERROR, "ScheduleTicketCleanup failed %x\n", Status));
        }  
    }    
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitTicketCaching
//
//  Synopsis:   Initialize the ticket caching code
//
//  Effects:    Creates a SAFE_RESOURCE
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, NTSTATUS from Rtl routines
//              on error
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbInitTicketCaching(
    VOID
    )
{
    __try
    {
        SafeInitializeResource(&KerberosTicketCacheLock, TICKET_CACHE_LOCK_ENUM);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    KerberosTicketCacheInitialized = TRUE;
        
    KerbScheduleTicketCleanup();
                                        
    return STATUS_SUCCESS;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbInitTicketCache
//
//  Synopsis:   Initializes a single ticket cache
//
//  Effects:    initializes list entry
//
//  Arguments:  TicketCache - The ticket cache to initialize
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbInitTicketCache(
    IN PKERB_TICKET_CACHE TicketCache
    )
{
    InitializeListHead(&TicketCache->CacheEntries);
    GetSystemTimeAsFileTime(( PFILETIME )&TicketCache->LastCleanup );
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbFreeTicketCache
//
//  Synopsis:   Frees the ticket cache global data
//
//  Effects:
//
//  Arguments:  none
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------


VOID
KerbFreeTicketCache(
    VOID
    )
{
//    if (KerberosTicketCacheInitialized)
//    {
//        KerbWriteLockTicketCache();
//        RtlDeleteResource(&KerberosTicketCacheLock);
//    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbDereferenceTicketCacheEntry
//
//  Synopsis:   Dereferences a ticket cache entry
//
//  Effects:    Dereferences the ticket cache entry to make it go away
//              when it is no longer being used.
//
//  Arguments:  decrements reference count and delets cache entry if it goes
//              to zero
//
//  Requires:   TicketCacheEntry - The ticket cache entry to dereference.
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbDereferenceTicketCacheEntry(
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    )
{
    DsysAssert(TicketCacheEntry->ListEntry.ReferenceCount != 0);

#if DBG

    if (TicketCacheEntry->ListEntry.ReferenceCount >= 20)
    {
        D_DebugLog((DEB_WARN, "KerbDereferenceTicketCacheEntry TicketCacheEntry %p, ReferenceCount %#x\n",
                    TicketCacheEntry, TicketCacheEntry->ListEntry.ReferenceCount));
    }

#endif

    if ( 0 == InterlockedDecrement( (LONG *)&TicketCacheEntry->ListEntry.ReferenceCount )) {

        FRE_ASSERT( !TicketCacheEntry->Linked );

#if DBG
        KerbWriteLockTicketCache();
        RemoveEntryList( &TicketCacheEntry->GlobalListEntry );
        KerbUnlockTicketCache();
#endif

        InterlockedDecrement(&GlobalTicketListSize);
            

        DsysAssert( TicketCacheEntry->ScavengerHandle == NULL );
        KerbFreeKdcName(&TicketCacheEntry->ServiceName);
        KerbFreeString(&TicketCacheEntry->DomainName);
        KerbFreeString(&TicketCacheEntry->TargetDomainName);
        KerbFreeString(&TicketCacheEntry->AltTargetDomainName);
        KerbFreeString(&TicketCacheEntry->ClientDomainName);
        KerbFreeKdcName(&TicketCacheEntry->ClientName);
        KerbFreeKdcName(&TicketCacheEntry->AltClientName);
        KerbFreeKdcName(&TicketCacheEntry->TargetName);
        KerbFreeDuplicatedTicket(&TicketCacheEntry->Ticket);
        KerbFreeKey(&TicketCacheEntry->SessionKey);
        KerbFreeKey(&TicketCacheEntry->CredentialKey);
        KerbFree(TicketCacheEntry);
    }

    return;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReferenceTicketCacheEntry
//
//  Synopsis:   References a ticket cache entry
//
//  Effects:    Increments the reference count on the ticket cache entry
//
//  Arguments:  TicketCacheEntry - Ticket cache entry  to reference
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbReferenceTicketCacheEntry(
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    )
{
    DsysAssert(TicketCacheEntry->ListEntry.ReferenceCount != 0);

    InterlockedIncrement( (LONG *)&TicketCacheEntry->ListEntry.ReferenceCount );

#if DBG

    if (TicketCacheEntry->ListEntry.ReferenceCount >= 20)
    {
        D_DebugLog((DEB_WARN, "KerbReferenceTicketCacheEntry TicketCacheEntry %p, ReferenceCount %#x\n",
                    TicketCacheEntry, TicketCacheEntry->ListEntry.ReferenceCount));
    }

#endif
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbInsertTicketCachEntry
//
//  Synopsis:   Inserts a ticket cache entry onto a ticket cache
//
//  Effects:
//
//  Arguments:  TicketCache - The ticket cache on which to stick the ticket.
//              TicketCacheEntry - The entry to stick in the cache.
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbInsertTicketCacheEntry(
    IN PKERB_TICKET_CACHE TicketCache,
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    )
{
    InterlockedIncrement( (LONG *)&TicketCacheEntry->ListEntry.ReferenceCount );

    KerbWriteLockTicketCache();

    InsertHeadList(
        &TicketCache->CacheEntries,
        &TicketCacheEntry->ListEntry.Next
        );

    KerbUnlockTicketCache();

    if ( FALSE != InterlockedCompareExchange(
                      &TicketCacheEntry->Linked,
                      (LONG)TRUE,
                      (LONG)FALSE )) {

        //
        // Attempted to insert an already-linked entry
        //

        FRE_ASSERT( FALSE );
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbRemoveTicketCachEntry
//
//  Synopsis:   Removes a ticket cache entry from its ticket cache
//
//  Effects:
//
//  Arguments:  TicketCacheEntry - The entry to yank out of the cache.
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbRemoveTicketCacheEntry(
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    )
{
    //
    // An entry can only be unlinked from the cache once
    //

    if ( InterlockedCompareExchange(
             &TicketCacheEntry->Linked,
             (LONG)FALSE,
             (LONG)TRUE )) {

        HANDLE TaskHandle = NULL;

        DsysAssert(TicketCacheEntry->ListEntry.ReferenceCount != 0);

        KerbWriteLockTicketCache();

        RemoveEntryList(&TicketCacheEntry->ListEntry.Next);

        TaskHandle = TicketCacheEntry->ScavengerHandle;
        TicketCacheEntry->ScavengerHandle = NULL;

        KerbUnlockTicketCache();

        if ( TaskHandle ) {

            KerbTaskDoItNow( TaskHandle );
        }

        KerbDereferenceTicketCacheEntry(TicketCacheEntry);
    }
}

VOID
FORCEINLINE
ReplaceEntryList(
    IN PLIST_ENTRY OldEntry,
    IN PLIST_ENTRY NewEntry
    )
{
    PLIST_ENTRY Flink;
    PLIST_ENTRY Blink;

    Flink = NewEntry->Flink = OldEntry->Flink;
    Blink = NewEntry->Blink = OldEntry->Blink;
    Blink->Flink = NewEntry;
    Flink->Blink = NewEntry;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbReplaceTicketCachEntry
//
//  Synopsis:   Replaces a ticket cache entry with a new one
//
//  Effects:
//
//  Arguments:  OldTicketCacheEntry - The entry to yank out of the cache
//              NewTicketCacheEntry - The entry to put into old entry's place
//
//  Returns:    TRUE if the entry has been replaced
//              FALSE if the OldTicketCacheEntry was unlinked by someone else
//              before we got to it
//
//  Notes:
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbReplaceTicketCacheEntry(
    IN PKERB_TICKET_CACHE_ENTRY OldTicketCacheEntry,
    IN PKERB_TICKET_CACHE_ENTRY NewTicketCacheEntry
    )
{
    BOOLEAN Result = FALSE;

    //
    // An entry can only be unlinked from the cache once
    //

    if ( InterlockedCompareExchange(
             &OldTicketCacheEntry->Linked,
             (LONG)FALSE,
             (LONG)TRUE )) {

        Result = TRUE;

        DsysAssert( OldTicketCacheEntry->ListEntry.ReferenceCount != 0 );

        //
        // make sure the new ticket cache entry won't be deleted when purged
        //

        KerbReferenceTicketCacheEntry( NewTicketCacheEntry );

        FRE_ASSERT( !NewTicketCacheEntry->Linked );

        KerbWriteLockTicketCache();

        ReplaceEntryList(
            &OldTicketCacheEntry->ListEntry.Next,
            &NewTicketCacheEntry->ListEntry.Next
            );

        NewTicketCacheEntry->Linked = TRUE;

        KerbUnlockTicketCache();

        KerbDereferenceTicketCacheEntry( OldTicketCacheEntry );
    }

    return Result;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbCacheTicket
//
//  Synopsis:   Caches a ticket in the ticket cache
//
//  Effects:    creates a cache entry
//
//  Arguments:  Ticket - The ticket to cache
//              KdcReply - The KdcReply corresponding to the ticket cache
//              KdcReplyBody -
//              TargetName - Name of service supplied by client
//              TargetDomainname -
//              CacheFlags -
//              TicketCache - The cache in which to store the ticket
//                            not needed if ticket won't be linked.
//              NewCacheEntry - receives new cache entry (referenced)
//
//  Requires:
//
//  Returns:
//
//  Notes:      The ticket cache owner must be locked for write access
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateTicketCacheEntry(
    IN PKERB_KDC_REPLY KdcReply,
    IN OPTIONAL PKERB_ENCRYPTED_KDC_REPLY KdcReplyBody,
    IN OPTIONAL PKERB_INTERNAL_NAME TargetName,
    IN OPTIONAL PUNICODE_STRING TargetDomainName,
    IN ULONG CacheFlags,
    IN OPTIONAL PKERB_TICKET_CACHE TicketCache,
    IN OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey,
    OUT PKERB_TICKET_CACHE_ENTRY * NewCacheEntry
    )
{
    PKERB_TICKET_CACHE_ENTRY CacheEntry = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG OldCacheFlags = 0;

    *NewCacheEntry = NULL;

    CacheEntry = (PKERB_TICKET_CACHE_ENTRY)
        KerbAllocate(sizeof(KERB_TICKET_CACHE_ENTRY));
    if (CacheEntry == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    CacheEntry->ListEntry.ReferenceCount = 1;

#if DBG
    if ( CacheEntry ) {

        KerbWriteLockTicketCache();
        InsertHeadList(
            &GlobalTicketList,
            &CacheEntry->GlobalListEntry
            );
        KerbUnlockTicketCache();
    }
#endif

    InterlockedIncrement( &GlobalTicketListSize );

    //
    // Fill in the entries from the KDC reply
    //

    if (ARGUMENT_PRESENT(KdcReplyBody))
    {

        CacheEntry->TicketFlags = KerbConvertFlagsToUlong(&KdcReplyBody->flags);

        if (!KERB_SUCCESS(KerbDuplicateKey(
                            &CacheEntry->SessionKey,
                            &KdcReplyBody->session_key
                            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }


        if (KdcReplyBody->bit_mask & KERB_ENCRYPTED_KDC_REPLY_starttime_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &CacheEntry->StartTime,
                &KdcReplyBody->KERB_ENCRYPTED_KDC_REPLY_starttime,
                NULL
                );
        }
        else
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &CacheEntry->StartTime,
                &KdcReplyBody->authtime,
                NULL
                );
        }

        KerbConvertGeneralizedTimeToLargeInt(
            &CacheEntry->EndTime,
            &KdcReplyBody->endtime,
            NULL
            );

        if (KdcReplyBody->bit_mask & KERB_ENCRYPTED_KDC_REPLY_renew_until_present)
        {
            KerbConvertGeneralizedTimeToLargeInt(
                &CacheEntry->RenewUntil,
                &KdcReplyBody->KERB_ENCRYPTED_KDC_REPLY_renew_until,
                NULL
                );
        }

        //
        // Check to see if the ticket has already expired
        //

        if (KerbTicketIsExpiring(CacheEntry, FALSE))
        {
            DebugLog((DEB_ERROR,"Tried to cache an already-expired ticket\n"));
            Status = STATUS_TIME_DIFFERENCE_AT_DC;
            goto Cleanup;
        }
    }

    //
    // Fill in the FullServiceName which is the domain name concatenated with
    // the service name.
    //
    // The full service name is domain name '\' service name.
    //

    //
    // Fill in the domain name and service name separately in the
    // cache entry, using the FullServiceName buffer.
    //

    if (!KERB_SUCCESS(KerbConvertRealmToUnicodeString(
                        &CacheEntry->DomainName,
                        &KdcReply->ticket.realm
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    if (!KERB_SUCCESS(KerbConvertPrincipalNameToKdcName(
                        &CacheEntry->ServiceName,
                        &KdcReply->ticket.server_name
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    //
    // Extract the realm name from the principal name
    //

    Status = KerbExtractDomainName(
                &CacheEntry->TargetDomainName,
                CacheEntry->ServiceName,
                &CacheEntry->DomainName
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // The reply need not include the name
    //

    if (KdcReply->client_realm != NULL)
    {
        if (!KERB_SUCCESS(KerbConvertRealmToUnicodeString(
                    &CacheEntry->ClientDomainName,
                    &KdcReply->client_realm)))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }

    //
    // Fill in the target name the client provided, which may be
    // different then the service name
    //

    if (ARGUMENT_PRESENT(TargetName))
    {
        Status = KerbDuplicateKdcName(
                    &CacheEntry->TargetName,
                    TargetName
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    if (ARGUMENT_PRESENT(TargetDomainName))
    {
        Status = KerbDuplicateString(
                    &CacheEntry->AltTargetDomainName,
                    TargetDomainName
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Store the client name so we can use the right name
    // in later requests.
    //

    if (KdcReply->client_name.name_string != NULL)
    {
        if (!KERB_SUCCESS( KerbConvertPrincipalNameToKdcName(
                &CacheEntry->ClientName,
                &KdcReply->client_name)))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }

    if (!KERB_SUCCESS(KerbDuplicateTicket(
                        &CacheEntry->Ticket,
                        &KdcReply->ticket
                        )))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }


    if (ARGUMENT_PRESENT( CredentialKey ))
    {
        if (!KERB_SUCCESS(KerbDuplicateKey(
                            &CacheEntry->CredentialKey,
                            CredentialKey
                            )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
    }

    CacheEntry->CacheFlags = CacheFlags;

    //
    // Before we insert this ticket we want to remove any
    // previous instances of tickets to the same service.
    //
    if (TicketCache)
    {
        PKERB_TICKET_CACHE_ENTRY OldCacheEntry = NULL;

        if ((CacheFlags & (KERB_TICKET_CACHE_DELEGATION_TGT |
                           KERB_TICKET_CACHE_PRIMARY_TGT)) != 0)
        {
            OldCacheEntry = KerbLocateTicketCacheEntryByRealm(
                                TicketCache,
                                NULL,
                                CacheFlags
                                );
        }
        else
        {
            OldCacheEntry = KerbLocateTicketCacheEntry(
                                TicketCache,
                                CacheEntry->ServiceName,
                                &CacheEntry->DomainName
                                );
        }

        if (OldCacheEntry != NULL)
        {
            OldCacheFlags = OldCacheEntry->CacheFlags;
            KerbRemoveTicketCacheEntry( OldCacheEntry );
            KerbDereferenceTicketCacheEntry( OldCacheEntry );
            OldCacheEntry = NULL;
        }

        //
        // If the old ticket was the primary TGT, mark this one as the
        // primary TGT as well.
        //

        CacheEntry->CacheFlags |= (OldCacheFlags &
                                    (KERB_TICKET_CACHE_DELEGATION_TGT |
                                    KERB_TICKET_CACHE_PRIMARY_TGT));

        //
        // Insert the cache entry into the cache
        //

        KerbInsertTicketCacheEntry(
            TicketCache,
            CacheEntry
            );

        //
        // If this is the primary TGT, schedule pre-emptive ticket renewal
        //

        if (( CacheEntry->CacheFlags & KERB_TICKET_CACHE_PRIMARY_TGT ) &&
            ( CacheEntry->TicketFlags & KERB_TICKET_FLAGS_renewable )) {

            KerbScheduleTgtRenewal( CacheEntry );

        }
    }

    //
    // Update the statistics
    //

    UpdateCacheMisses();

    *NewCacheEntry = CacheEntry;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (NULL != CacheEntry)
        {
            KerbDereferenceTicketCacheEntry(CacheEntry);
        }
    }

    return(Status);

}


//+-------------------------------------------------------------------------
//
//  Function:   KerbDuplicateTicketCacheEntry
//
//  Synopsis:   Duplicate a ticket cache entry.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbDuplicateTicketCacheEntry(
    IN PKERB_TICKET_CACHE_ENTRY CacheEntry,
    IN OUT PKERB_TICKET_CACHE_ENTRY * NewCacheEntry
    )
{
    NTSTATUS Status;
    PKERB_TICKET_CACHE_ENTRY LocalEntry = NULL;

    *NewCacheEntry = NULL;

    LocalEntry = (PKERB_TICKET_CACHE_ENTRY) KerbAllocate(sizeof(KERB_TICKET_CACHE_ENTRY));
    if ( LocalEntry == NULL )
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory(
        LocalEntry,
        CacheEntry,
        sizeof(KERB_TICKET_CACHE_ENTRY)
        );

    LocalEntry->Linked = FALSE;
    LocalEntry->ListEntry.Next.Flink = NULL;
    LocalEntry->ListEntry.Next.Blink = NULL;
    LocalEntry->ListEntry.ReferenceCount = 1;
    LocalEntry->ScavengerHandle = NULL;
    LocalEntry->EvidenceLogonId = CacheEntry->EvidenceLogonId;

#if DBG
    if ( LocalEntry ) {
        KerbWriteLockTicketCache();
        InsertHeadList(
            &GlobalTicketList,
            &LocalEntry->GlobalListEntry
            );
        KerbUnlockTicketCache();
    }
#endif
    InterlockedIncrement( &GlobalTicketListSize );

    if (!KERB_SUCCESS(KerbDuplicateKey(
                        &LocalEntry->SessionKey,
                        &CacheEntry->SessionKey
                        )))
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    Status = KerbDuplicateKdcName(
                    &LocalEntry->ServiceName,
                    CacheEntry->ServiceName
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    if ( CacheEntry->TargetName != NULL )
    {
        Status = KerbDuplicateKdcName(
                        &LocalEntry->TargetName,
                        CacheEntry->TargetName
                        );
    
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    if ( CacheEntry->ClientName != NULL )
    {
        Status = KerbDuplicateKdcName(
                    &LocalEntry->ClientName,
                    CacheEntry->ClientName
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    if ( CacheEntry->AltClientName != NULL )
    {
        Status = KerbDuplicateKdcName(
                &LocalEntry->AltClientName,
                CacheEntry->AltClientName
                );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    if ( CacheEntry->DomainName.Buffer != NULL )
    {
        Status = KerbDuplicateStringEx(
                        &LocalEntry->DomainName,
                        &CacheEntry->DomainName,
                        FALSE
                        );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    if ( CacheEntry->TargetDomainName.Buffer != NULL )
    {
        Status = KerbDuplicateStringEx(
                        &LocalEntry->TargetDomainName,
                        &CacheEntry->TargetDomainName,
                        FALSE
                        );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    if ( CacheEntry->AltTargetDomainName.Buffer != NULL )
    {
        Status = KerbDuplicateStringEx(
                        &LocalEntry->AltTargetDomainName,
                        &CacheEntry->AltTargetDomainName,
                        FALSE
                        );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    if ( CacheEntry->ClientDomainName.Buffer != NULL )
    {
        Status = KerbDuplicateStringEx(
                        &LocalEntry->ClientDomainName,
                        &CacheEntry->ClientDomainName,
                        FALSE
                        );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Don't need session key.
    //

    if (!KERB_SUCCESS(KerbDuplicateTicket(
                            &LocalEntry->Ticket,
                            &CacheEntry->Ticket
                            )))
    {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    

    *NewCacheEntry = LocalEntry;
    LocalEntry = NULL;

Cleanup:

    if ((LocalEntry != NULL) &&
        (!NT_SUCCESS( Status )))
    {
        KerbDereferenceTicketCacheEntry( LocalEntry );
    }

    return Status;
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbPurgeTicketCache
//
//  Synopsis:   Purges a cache of all its tickets
//
//  Effects:    unreferences all tickets in the cache
//
//  Arguments:  Cache - Ticket cache to purge
//
//  Requires:
//
//  Returns:    none
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbPurgeTicketCache(
    IN PKERB_TICKET_CACHE Cache
    )
{
    PKERB_TICKET_CACHE_ENTRY CacheEntry;
    
    while (TRUE)
    {
        KerbWriteLockTicketCache();

        if (IsListEmpty(&Cache->CacheEntries))
        {
            KerbUnlockTicketCache();
            break;
        }

        CacheEntry = CONTAINING_RECORD(
                        Cache->CacheEntries.Flink,
                        KERB_TICKET_CACHE_ENTRY,
                        ListEntry.Next
                        );

        //
        // make sure CacheEntry won't be deleted by the ticket renewal thread
        //

        KerbReferenceTicketCacheEntry(CacheEntry);

        KerbUnlockTicketCache();

        KerbRemoveTicketCacheEntry(
            CacheEntry
            );

        KerbDereferenceTicketCacheEntry(CacheEntry);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbLocateTicketCacheEntry
//
//  Synopsis:   References a ticket cache entry by name
//
//  Effects:    Increments the reference count on the ticket cache entry
//
//  Arguments:  TicketCache - the ticket cache to search
//              FullServiceName - Optionally contains full service name
//                      of target, including domain name. If it is NULL,
//                      then the first element in the list is returned.
//              RealmName - Realm of service name. If length is zero, is not
//                      used for comparison.
//
//  Requires:
//
//  Returns:    The referenced cache entry or NULL if it was not found.
//
//  Notes:      If an invalid entry is found it may be dereferenced
//
//
//--------------------------------------------------------------------------

PKERB_TICKET_CACHE_ENTRY
KerbLocateTicketCacheEntry(
    IN PKERB_TICKET_CACHE TicketCache,
    IN PKERB_INTERNAL_NAME FullServiceName,
    IN PUNICODE_STRING RealmName
    )
{
    PLIST_ENTRY ListEntry;
    PKERB_TICKET_CACHE_ENTRY CacheEntry = NULL;
    BOOLEAN Found = FALSE;
    BOOLEAN Remove = FALSE;

    KerbReadLockTicketCache();

    //
    // Go through the ticket cache looking for the correct entry
    //

    for (ListEntry = TicketCache->CacheEntries.Flink ;
         ListEntry !=  &TicketCache->CacheEntries ;
         ListEntry = ListEntry->Flink )
    {
        CacheEntry = CONTAINING_RECORD(ListEntry, KERB_TICKET_CACHE_ENTRY, ListEntry.Next);
        if (!ARGUMENT_PRESENT(FullServiceName) ||
            KerbEqualKdcNames(
                CacheEntry->ServiceName,
                FullServiceName
                ) ||
            ((CacheEntry->TargetName != NULL) &&
             KerbEqualKdcNames(
                CacheEntry->TargetName,
                FullServiceName
                ) ) )
        {
            //
            // Make sure they are principals in the same realm
            //

            if ((RealmName->Length != 0) &&
                !RtlEqualUnicodeString(
                    RealmName,
                    &CacheEntry->DomainName,
                    TRUE                                // case insensitive
                    ) &&
                !RtlEqualUnicodeString(
                    RealmName,
                    &CacheEntry->AltTargetDomainName,
                    TRUE                                // case insensitive
                    ))
            {
                continue;
            }


            //
            // We don't want to return any special tickets.
            //

            if (CacheEntry->CacheFlags != 0)
            {
                continue;
            }

            //
            // Check to see if the entry has expired, or is not yet valid. If it has, just
            // remove it now.
            //

            if (KerbTicketIsExpiring(CacheEntry, FALSE ))
            {
                Remove = TRUE;
                Found = FALSE;
            }
            else
            {
                Found = TRUE;
            }

            KerbReferenceTicketCacheEntry(CacheEntry);

            break;
        }
    }

    KerbUnlockTicketCache();

    if (Remove)
    {
        KerbRemoveTicketCacheEntry(CacheEntry);
        KerbDereferenceTicketCacheEntry(CacheEntry);
    }

    if (!Found)
    {
        CacheEntry = NULL;
    }

    //
    // Update the statistics
    //

    if (Found)
    {
        UpdateCacheHits();
    }
    else
    {
        UpdateCacheMisses();
    }

    return(CacheEntry);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbLocateTicketCacheEntryByRealm
//
//  Synopsis:   References a ticket cache entry by realm name. This is used
//              only for the cache of TGTs
//
//  Effects:    Increments the reference count on the ticket cache entry
//
//  Arguments:  TicketCache - the ticket cache to search
//              RealmName - Optioanl realm of ticket - if NULL looks for
//                      initial ticket
//              RequiredFlags - any ticket cache flags the return ticket must
//                      have. If the caller asks for a primary TGT, then this
//                      API won't do expiration checking.
//
//  Requires:
//
//  Returns:    The referenced cache entry or NULL if it was not found.
//
//  Notes:      If an invalid entry is found it may be dereferenced
//              We we weren't given a RealmName, then we need to look
//              through the whole list for the ticket.
//
//
//--------------------------------------------------------------------------


PKERB_TICKET_CACHE_ENTRY
KerbLocateTicketCacheEntryByRealm(
    IN PKERB_TICKET_CACHE TicketCache,
    IN PUNICODE_STRING RealmName,
    IN ULONG RequiredFlags
    )
{
    PLIST_ENTRY ListEntry;
    PKERB_TICKET_CACHE_ENTRY CacheEntry = NULL;
    BOOLEAN Found = FALSE, NoRealmSupplied = FALSE;
    BOOLEAN Remove = FALSE;

    NoRealmSupplied = ((RealmName == NULL) || (RealmName->Length == 0));

    KerbReadLockTicketCache();

    //
    // Go through the ticket cache looking for the correct entry
    //

    for (ListEntry = TicketCache->CacheEntries.Flink ;
         ListEntry !=  &TicketCache->CacheEntries ;
         ListEntry = ListEntry->Flink )
    {
        CacheEntry = CONTAINING_RECORD(ListEntry, KERB_TICKET_CACHE_ENTRY, ListEntry.Next);

        //
        // Match if the caller supplied no realm name, the realm matches the
        // target domain name, or it matches the alt target domain name
        //

        if (((RealmName == NULL) || (RealmName->Length == 0)) ||
            ((CacheEntry->TargetDomainName.Length != 0) &&
            RtlEqualUnicodeString(
                &CacheEntry->TargetDomainName,
                RealmName,
                TRUE
                )) ||
            ((CacheEntry->AltTargetDomainName.Length != 0) &&
             RtlEqualUnicodeString(
                &CacheEntry->AltTargetDomainName,
                RealmName,
                TRUE
                )) )
        {

            //
            // Check the required flags are set.
            //

            if (((CacheEntry->CacheFlags & RequiredFlags) != RequiredFlags) ||
                (((CacheEntry->CacheFlags & KERB_TICKET_CACHE_DELEGATION_TGT) != 0) &&
                 ((RequiredFlags & KERB_TICKET_CACHE_DELEGATION_TGT) == 0)))
            {
                Found = FALSE;

                //
                // We need to continue looking
                //

                continue;
            }

            //
            // Check to see if the entry has expired. If it has, just
            // remove it now.
            //

            if (KerbTicketIsExpiring(CacheEntry, FALSE ))
            {
                //
                // if this is not the primary TGT, go ahead and remove it. We
                // want to save the primary TGT so we can renew it.
                //

                if ((CacheEntry->CacheFlags & KERB_TICKET_CACHE_PRIMARY_TGT) == 0)
                {
                    Remove = TRUE;
                    Found = FALSE;
                }
                else
                {
                    //
                    // If the caller was asking for the primary TGT,
                    // return it whether or not it expired.
                    //

                    if ((RequiredFlags & KERB_TICKET_CACHE_PRIMARY_TGT) != 0 )
                    {
                        Found = TRUE;
                    }
                    else
                    {
                        Found = FALSE;
                    }
                }

                if ( Remove || Found )
                {
                    KerbReferenceTicketCacheEntry(CacheEntry);
                }
            }
            else
            {
                KerbReferenceTicketCacheEntry(CacheEntry);

                Found = TRUE;
            }

            break;

        }
    }

    KerbUnlockTicketCache();

    if (Remove)
    {
        KerbRemoveTicketCacheEntry(CacheEntry);
        KerbDereferenceTicketCacheEntry(CacheEntry);
    }

    if (!Found)
    {
        CacheEntry = NULL;
    }

    //
    // Update the statistics
    //

    if (Found)
    {
        UpdateCacheHits();
    }
    else
    {
        UpdateCacheMisses();
    }

    return(CacheEntry);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbTicketIsExpiring
//
//  Synopsis:   Check if a ticket is expiring
//
//  Effects:
//
//  Arguments:  CacheEntry - Entry to check
//              AllowSkew - Expire ticket that aren't outside of skew of
//                      expiring
//
//  Requires:
//
//  Returns:
//
//  Notes:      Ticket cache lock must be held
//
//
//--------------------------------------------------------------------------

BOOLEAN
KerbTicketIsExpiring(
    IN PKERB_TICKET_CACHE_ENTRY CacheEntry,
    IN BOOLEAN AllowSkew
    )
{
    TimeStamp CutoffTime;

    GetSystemTimeAsFileTime((PFILETIME) &CutoffTime);

    //
    // We want to make sure we have at least skewtime left on the ticket
    //

    if (AllowSkew)
    {
        KerbSetTime(&CutoffTime, KerbGetTime(CutoffTime) + KerbGetTime(KerbGlobalSkewTime));
    }

    //
    // Adjust for server skew time.
    //

    KerbSetTime(&CutoffTime, KerbGetTime(CutoffTime) + KerbGetTime(CacheEntry->TimeSkew));

    if (KerbGetTime(CacheEntry->EndTime) < KerbGetTime(CutoffTime))
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbAgeTickets
//
//  Synopsis:   Removes stale, old tickets from caches in a ticket cache.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbAgeTickets(
    PKERB_TICKET_CACHE TicketCache
    )
{
    PKERB_TICKET_CACHE_ENTRY CacheEntry = NULL;
    PLIST_ENTRY ListEntry;
    
    KerbWriteLockTicketCache();
    for (ListEntry = TicketCache->CacheEntries.Flink ;
         ListEntry !=  &TicketCache->CacheEntries ;
         ListEntry = ListEntry->Flink )
    {
        CacheEntry = CONTAINING_RECORD(ListEntry, KERB_TICKET_CACHE_ENTRY, ListEntry.Next);
        if (KerbTicketIsExpiring(CacheEntry, FALSE ))
        {   
            D_DebugLog((DEB_TRACE, "Aging ticket %p\n", CacheEntry ));
            ListEntry = ListEntry->Blink;
            KerbRemoveTicketCacheEntry( CacheEntry );
        }
           
    }        

    GetSystemTimeAsFileTime(( PFILETIME )&TicketCache->LastCleanup );
    KerbUnlockTicketCache(); 
}





//+-------------------------------------------------------------------------
//
//  Function:   KerbAgeTicketsForLogonSession
//
//  Synopsis:   Removes stale, old tickets from a logon session
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------
VOID
KerbAgeTicketsForLogonSession( 
    PKERB_LOGON_SESSION LogonSession
    )
{   
    //
    // Don't age TGT cache.  Just S4U and service ticket caches.
    //
    KerbAgeTickets( &LogonSession->PrimaryCredentials.S4UTicketCache );
    KerbAgeTickets( &LogonSession->PrimaryCredentials.ServerTicketCache );
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbSetTicketCacheEntryTarget
//
//  Synopsis:   Sets target name for a cache entry
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

VOID
KerbSetTicketCacheEntryTarget(
    IN PUNICODE_STRING TargetName,
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    )
{
    KerbWriteLockTicketCache();
    KerbFreeString(&TicketCacheEntry->AltTargetDomainName);
    KerbDuplicateString(
        &TicketCacheEntry->AltTargetDomainName,
        TargetName
        );

    KerbUnlockTicketCache();
}

void
KerbScheduleTgtRenewal(
    IN KERB_TICKET_CACHE_ENTRY * CacheEntry
    )
{
    NTSTATUS Status;
    LONGLONG CurrentTime;
    LONGLONG RenewalTime;
    DWORD TgtRenewalTime = KerbGlobalTgtRenewalTime;
#if DBG
    FILETIME ft;
    SYSTEMTIME st;
#endif

    //
    // The only condition on which the TGT should be renewed
    //

    DsysAssert(
        CacheEntry &&
        ( CacheEntry->CacheFlags & KERB_TICKET_CACHE_PRIMARY_TGT ) &&
        ( CacheEntry->TicketFlags & KERB_TICKET_FLAGS_renewable )
        );

    DsysAssert( CacheEntry->ScavengerHandle == NULL );

    //
    // A renewal time of '0 before expiration' means renewing is turned off
    //

    if ( TgtRenewalTime == 0 ) {

        D_DebugLog((DEB_TRACE_TKT_RENEWAL, "Not scheduling ticket renewal for %p -- \n", CacheEntry));
        return;
    }

    //
    // The scavenger maintains a reference on the cache entry
    //

    KerbReferenceTicketCacheEntry( CacheEntry );

#if DBG
    FileTimeToLocalFileTime(( PFILETIME )&CacheEntry->EndTime.QuadPart, &ft );
    FileTimeToSystemTime( &ft, &st );

    D_DebugLog((DEB_TRACE_TKT_RENEWAL, "The end time on entry %p is %02d:%02d:%02d\n", CacheEntry, (ULONG)st.wHour, (ULONG)st.wMinute, (ULONG)st.wSecond));
#endif

    //
    // Compute how far in the future, in milliseconds, the renewal
    // should be attempted
    //

    GetSystemTimeAsFileTime(( PFILETIME )&CurrentTime );

#if DBG
    FileTimeToLocalFileTime(( PFILETIME )&CurrentTime, &ft );
    FileTimeToSystemTime( &ft, &st );

    D_DebugLog((DEB_TRACE_TKT_RENEWAL, "The current time is %02d:%02d:%02d\n", (ULONG)st.wHour, (ULONG)st.wMinute, (ULONG)st.wSecond));
#endif

    //
    // Convert renewal time from seconds to 100 ns intervals
    //

    RenewalTime = CacheEntry->EndTime.QuadPart - ((LONGLONG)TgtRenewalTime) * 1000 * 1000 * 10;

#if DBG
    FileTimeToLocalFileTime(( PFILETIME )&RenewalTime, &ft );
    FileTimeToSystemTime( &ft, &st );

    D_DebugLog((DEB_TRACE_TKT_RENEWAL, "Will try to schedule ticket renewal of %p for %02d:%02d:%02d\n", CacheEntry, (ULONG)st.wHour, (ULONG)st.wMinute, (ULONG)st.wSecond));
#endif

    if ( RenewalTime <= CurrentTime ) {

        Status = STATUS_INVALID_PARAMETER;
        D_DebugLog((DEB_TRACE_TKT_RENEWAL, "Not scheduling ticket renewal for %p -- too late\n", CacheEntry));

    } else {

        //
        // Scavenger tasks are timed in milliseconds
        //

        LONG Interval = ( LONG )(( RenewalTime - CurrentTime ) / ( 10 * 1000 ));

        D_DebugLog((DEB_TRACE_TKT_RENEWAL, "Ticket %p will be renewed %d seconds from now\n", CacheEntry, Interval / 1000 ));

        if ( Interval > 0 ) {

            Status = KerbAddScavengerTask(
                         FALSE,
                         Interval,
                         0, // no special processing flags
                         KerbTgtRenewalTrigger,
                         KerbTgtRenewalReaper,
                         CacheEntry,
                         &CacheEntry->ScavengerHandle
                         );

        } else {

            Status = STATUS_UNSUCCESSFUL;
        }
    }

    if ( !NT_SUCCESS( Status )) {

        KerbDereferenceTicketCacheEntry( CacheEntry );
        D_DebugLog((DEB_TRACE_TKT_RENEWAL, "Failed to schedule ticket renewal for %p (0x%x)\n", CacheEntry, Status));
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbTgtRenewalTrigger
//
//  Synopsis:   Handles a TGT renewal event
//
//  Effects:
//
//  Arguments:  TaskHandle - handle to the task (for rescheduling, etc.)
//              TaskItem   - task context
//
//  Requires:
//
//  Returns:    Nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------

void
KerbTgtRenewalTrigger(
    void * TaskHandle,
    void * TaskItem
    )
{
    NTSTATUS Status;
    KERB_TICKET_CACHE_ENTRY * CacheEntry = ( KERB_TICKET_CACHE_ENTRY * )TaskItem;
    BOOLEAN TicketCacheLocked = FALSE;
    ULONG CacheFlags;
    UNICODE_STRING ServiceRealm = NULL_UNICODE_STRING;
    PKERB_INTERNAL_NAME ServiceName = NULL;
    PKERB_KDC_REPLY KdcReply = NULL;
    PKERB_ENCRYPTED_KDC_REPLY KdcReplyBody = NULL;
    ULONG RetryFlags = 0;
    KERB_TICKET_CACHE_ENTRY * NewTicket;

    DsysAssert( CacheEntry );

    //
    // Optimization: do not attempt to renew unlinked entries
    //

    if ( !CacheEntry->Linked ) {

        D_DebugLog((DEB_TRACE_TKT_RENEWAL, "Not renewing %p -- already unlinked\n", CacheEntry));
        return;
    }

    //
    // Copy the names out of the input structures so we can
    // unlock the structures while going over the network.
    //

    DsysAssert( !TicketCacheLocked );
    KerbWriteLockTicketCache();
    TicketCacheLocked = TRUE;

    //
    // No scavenger handle means that this entry has been canceled
    // and does not need renewal
    //

    if ( CacheEntry->ScavengerHandle == NULL ) {

        Status = STATUS_UNSUCCESSFUL;
        D_DebugLog((DEB_TRACE_TKT_RENEWAL, "Not renewing %p -- previously canceled\n", CacheEntry));
        goto Cleanup;

    } else {

        CacheEntry->ScavengerHandle = NULL;
    }

    //
    // If the renew time is not much bigger than the end time, don't bother
    // renewing
    //

    if ( KerbGetTime( CacheEntry->EndTime ) +
         KerbGetTime( KerbGlobalSkewTime ) >=
         KerbGetTime( CacheEntry->RenewUntil )) {

        Status = STATUS_UNSUCCESSFUL;
        D_DebugLog((DEB_TRACE_TKT_RENEWAL, "Not renewing %p -- not much time left\n", CacheEntry));
        goto Cleanup;
    }

    if ( !( CacheEntry->TicketFlags & KERB_TICKET_FLAGS_renewable )) {

        Status = STATUS_ILLEGAL_FUNCTION;
        D_DebugLog((DEB_ERROR, "Trying to renew a non renewable ticket to "));
        D_KerbPrintKdcName((DEB_ERROR, CacheEntry->ServiceName));
        D_DebugLog((DEB_ERROR, " %ws, line %d\n", THIS_FILE, __LINE__));
        goto Cleanup;
    }

    CacheFlags = CacheEntry->CacheFlags;

    Status = KerbDuplicateString(
                 &ServiceRealm,
                 &CacheEntry->DomainName
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    Status = KerbDuplicateKdcName(
                 &ServiceName,
                 CacheEntry->ServiceName
                 );

    if ( !NT_SUCCESS( Status )) {

        goto Cleanup;
    }

    DsysAssert( TicketCacheLocked );
    KerbUnlockTicketCache();
    TicketCacheLocked = FALSE;

    Status = KerbGetTgsTicket(
                 &ServiceRealm,
                 CacheEntry,
                 ServiceName,
                 FALSE,
                 KERB_KDC_OPTIONS_renew,
                 0,                              // no encryption type
                 NULL,                           // no authorization data
                 NULL,                           // no pa data
                 NULL,                           // no tgt reply
                 NULL,                           // no evidence ticket
                 NULL,                           // let kdc determine end time
                 &KdcReply,
                 &KdcReplyBody,
                 &RetryFlags
                 );

    if ( !NT_SUCCESS( Status )) {

        DebugLog((DEB_WARN, "Failed to get TGS ticket for service 0x%x ", Status ));
        KerbPrintKdcName(DEB_WARN, ServiceName);
        DebugLog((DEB_WARN, " %ws, line %d\n", THIS_FILE, __LINE__));
        goto Cleanup;
    }

    Status = KerbCreateTicketCacheEntry(
                 KdcReply,
                 KdcReplyBody,
                 ServiceName,
                 &ServiceRealm,
                 CacheFlags,
                 NULL,
                 &CacheEntry->CredentialKey,
                 &NewTicket
                 );

    if ( !NT_SUCCESS( Status )) {

        DebugLog((DEB_WARN,"Failed to create a ticket cache entry for service 0x%x ", Status ));
        KerbPrintKdcName(DEB_WARN, ServiceName);
        DebugLog((DEB_WARN, " %ws, line %d\n", THIS_FILE, __LINE__));
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE_TKT_RENEWAL, "Entry %p renewed successfully.  New entry is %p\n", CacheEntry, NewTicket));

    if (( NewTicket->CacheFlags & KERB_TICKET_CACHE_PRIMARY_TGT ) &&
        ( NewTicket->TicketFlags & KERB_TICKET_FLAGS_renewable )) {

        if ( KerbReplaceTicketCacheEntry( CacheEntry, NewTicket )) {

            KerbScheduleTgtRenewal( NewTicket );
        }
    }

    KerbDereferenceTicketCacheEntry( NewTicket );

Cleanup:

    if ( TicketCacheLocked ) {

        KerbUnlockTicketCache();
    }

    KerbFreeTgsReply( KdcReply );
    KerbFreeKdcReplyBody( KdcReplyBody );
    KerbFreeKdcName( &ServiceName );
    KerbFreeString( &ServiceRealm );

    return;
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbTgtRenewalReaper
//
//  Synopsis:   Destroys a ticket renewal task
//
//  Effects:
//
//  Arguments:  TaskItem - cache entry to destroy
//
//  Requires:
//
//  Returns:    Nothing
//
//  Notes:
//
//
//--------------------------------------------------------------------------

void
KerbTgtRenewalReaper(
    void * TaskItem
    )
{
    KERB_TICKET_CACHE_ENTRY * CacheEntry = ( KERB_TICKET_CACHE_ENTRY * )TaskItem;

    if ( CacheEntry ) {

        KerbWriteLockTicketCache();
        CacheEntry->ScavengerHandle = NULL;
        KerbUnlockTicketCache();

        KerbDereferenceTicketCacheEntry( CacheEntry );
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   KerbScheduleTicketCleanup
//
//  Synopsis:   Schedules garbage collection for tickets.
//
//  Effects:
//
//  Arguments:  TaskItem - cache entry to destroy
//
//  Requires:
//
//  Returns:    Nothing
//
//  Notes:
//
//
//--

void
KerbTicketScavenger(
    void * TaskHandle,
    void * TaskItem
    )
{  

    PKERB_LOGON_SESSION *SessionsToAge = NULL;
    PKERB_LOGON_SESSION LogonSession = NULL;
    PLIST_ENTRY ListEntry;
    ULONG Count = 0;
    LUID SystemLuid = SYSTEM_LUID;
    LUID NetworkServiceLuid = NETWORKSERVICE_LUID;
    LONG Max = KerbGlobalMaxTickets;
    LONG Threshold = KerbGlobalMaxTickets / 2;


    D_DebugLog((DEB_TRACE, "Triggering ticket scavenger\n"));

    //
    // No reason to burn cycles w/ < XXXX tickets
    //
    if ( GlobalTicketListSize < Max )
    {
        return;
    }

    //
    // Ok - now we have some work to do
    //
    
    
    //
    // First, cleanup the expired tickets for the 3e7 and 3e4 logon sessions
    //
    LogonSession = KerbReferenceLogonSession( &SystemLuid, FALSE );
    if ( LogonSession )
    {
        KerbAgeTicketsForLogonSession( LogonSession );
        KerbDereferenceLogonSession( LogonSession );
    }

    
    LogonSession = KerbReferenceLogonSession( &NetworkServiceLuid, FALSE );
    if ( LogonSession )
    {
        KerbAgeTicketsForLogonSession( LogonSession );
        KerbDereferenceLogonSession( LogonSession );
    }
    
    if ( GlobalTicketListSize < Threshold )
    {
        return;
    }                               

    //
    // Now, iterate through the logon sessions, cleaning up tickets until
    // we've dropped below the threshhold, starting at the tail of the list
    //
    SafeAllocaAllocate( SessionsToAge, ( sizeof(PKERB_LOGON_SESSION) * ScavengedSessions ));
    if (SessionsToAge == NULL )
    {
        return;
    }
    
    KerbLockList(&KerbLogonSessionList);
    
    for ( ListEntry = KerbLogonSessionList.List.Blink ; 
          (( ListEntry->Blink !=  &KerbLogonSessionList.List ) && ( Count < ScavengedSessions )) ; 
          ListEntry = ListEntry->Blink, Count++ )
    {   
        
        SessionsToAge[Count] = CONTAINING_RECORD(ListEntry, KERB_LOGON_SESSION, ListEntry.Next);
        SessionsToAge[Count]->ListEntry.ReferenceCount++;
    } 

    KerbUnlockList(&KerbLogonSessionList);

    for ( ULONG i = 0; i < Count ; i++ )
    {
        KerbAgeTicketsForLogonSession( SessionsToAge[i] );
        KerbDereferenceLogonSession( SessionsToAge[i] );
    }

    SafeAllocaFree( SessionsToAge );

    if ( GlobalTicketListSize < Threshold )
    {
         return;
    }                               

    //
    // Hmm.. This can grow unbounded - is this a problem?
    //
    if ( Count == (ScavengedSessions - 1))
    {   
        ScavengedSessions += 30;
    }

    D_DebugLog((DEB_TRACE, "Dang it - we're hosed - up the number of logon sessions to %x\n", ScavengedSessions));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\tktlogon.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1999
//
// File:        tktlogon.cxx
//
// Contents:    Code for proxy logon for the Kerberos package
//
//
// History:     15-March        Created             MikeSw
//
//------------------------------------------------------------------------
#include <kerb.hxx>
#include <kerbp.h>

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

//+-------------------------------------------------------------------------
//
//  Function:   KerbCreateTicketLogonSession
//
//  Synopsis:   Does all the work for a ticket logon, removing it from
//              LsaApLogonUserEx2
//
//  Effects:
//
//  Arguments:  WorkstationTicket - ticket to workstation. The ticket
//                      cache entry is pretty much empty except for
//                      the ticket, and is not linked
//              ForwardedTgt - receives pointers into the Protocol
//                      SubmitBuffer to the forwarded TGT.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreateTicketLogonSession(
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    IN SECURITY_LOGON_TYPE LogonType,
    OUT PKERB_LOGON_SESSION * NewLogonSession,
    OUT PLUID LogonId,
    OUT PKERB_TICKET_CACHE_ENTRY * WorkstationTicket,
    OUT PKERB_MESSAGE_BUFFER ForwardedTgt
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_TICKET_LOGON LogonInfo = NULL;
    PKERB_LOGON_SESSION LogonSession = NULL;
    KERB_KDC_REPLY KdcReply = {0};
    ULONG_PTR Offset;
    UNICODE_STRING EmptyString = {0};
    PKERB_TICKET Ticket = NULL;
    KERBERR KerbErr;



    *WorkstationTicket = NULL;
    ForwardedTgt->Buffer = NULL;
    ForwardedTgt->BufferSize = 0;

    //
    // Pull the interesting information out of the submit buffer
    //

    if (SubmitBufferSize < sizeof(KERB_TICKET_LOGON))
    {
        DebugLog((DEB_ERROR,"Submit buffer to logon too small: %d. %ws, line %d\n",SubmitBufferSize, THIS_FILE, __LINE__));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    LogonInfo = (PKERB_TICKET_LOGON) ProtocolSubmitBuffer;

    DsysAssert((LogonInfo->MessageType == KerbTicketLogon) || (LogonInfo->MessageType == KerbTicketUnlockLogon));




    //
    // Relocate any pointers to be relative to 'LogonInfo'
    //


    Offset = ((PUCHAR) LogonInfo->ServiceTicket) - ((PUCHAR)ClientBufferBase);
    if ( (Offset >= SubmitBufferSize) ||
         (Offset + LogonInfo->ServiceTicketLength > SubmitBufferSize))
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    LogonInfo->ServiceTicket = (PUCHAR) ProtocolSubmitBuffer + Offset;

    if (LogonInfo->TicketGrantingTicketLength != 0)
    {
        if (LogonInfo->TicketGrantingTicket == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        Offset = ((PUCHAR) LogonInfo->TicketGrantingTicket) - ((PUCHAR)ClientBufferBase);
        if ( (Offset >= SubmitBufferSize) ||
             (Offset + LogonInfo->TicketGrantingTicketLength > SubmitBufferSize))
        {
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        LogonInfo->TicketGrantingTicket = (PUCHAR) ProtocolSubmitBuffer + Offset;
        ForwardedTgt->BufferSize = LogonInfo->TicketGrantingTicketLength;
        ForwardedTgt->Buffer = LogonInfo->TicketGrantingTicket;
    }


    //
    // Allocate a locally unique ID for this logon session. We will
    // create it in the LSA just before returning.
    //

    Status = NtAllocateLocallyUniqueId( LogonId );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to allocate locally unique ID: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    //
    // Build a logon session to hold all this information
    //

    Status = KerbCreateLogonSession(
                LogonId,
                &EmptyString,
                &EmptyString,
                NULL,                       // no password
                NULL,                       // no old password
                0,                          // no password options
                0,
                FALSE,                      // no dups - this is a primary logon
                &LogonSession
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Unpack the supplied service ticket
    //


    KerbErr = KerbUnpackData(
                LogonInfo->ServiceTicket,
                LogonInfo->ServiceTicketLength,
                KERB_TICKET_PDU,
                (PVOID *) &Ticket
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to unpack service ticket in ticket logon\n"));
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;
    }

    //
    // Build a ticket structure from the service ticket.
    //

    KdcReply.ticket = *Ticket;

    Status = KerbCreateTicketCacheEntry(
                &KdcReply,
                NULL,                   // no kdc reply
                NULL,                   // no target name
                NULL,                   // no target realm
                0,                      // no flags
                NULL,                   // no ticket cache
                NULL,                   // no credential key
                WorkstationTicket
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Return the new logon session.
    //

    *NewLogonSession = LogonSession;
    LogonSession = NULL;

Cleanup:

    if (!NT_SUCCESS(Status))
    {
        if (LogonSession != NULL)
        {
            KerbReferenceLogonSessionByPointer(LogonSession, TRUE);
            KerbDereferenceLogonSession(LogonSession);
        }
    }

    if (Ticket != NULL)
    {
        KerbFreeData(KERB_TICKET_PDU, Ticket);
    }

    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbExtractForwardedTgt
//
//  Synopsis:   Extracts a forwarded TGT from its encoded representation
//              and sticks it in the logon session ticket cache. This
//              also updates the user name & domain name in the
//              logon session, if they aren't present.
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbExtractForwardedTgt(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_MESSAGE_BUFFER ForwardedTgt,
    IN PKERB_ENCRYPTED_TICKET WorkstationTicket
    )
{
    PKERB_CRED KerbCred = NULL;
    PKERB_ENCRYPTED_CRED EncryptedCred = NULL;
    KERBERR KerbErr;
    NTSTATUS Status = STATUS_SUCCESS;

    D_DebugLog((DEB_TRACE, "Extracting a forwarded TGT\n"));

    KerbErr = KerbUnpackKerbCred(
                ForwardedTgt->Buffer,
                ForwardedTgt->BufferSize,
                &KerbCred
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_WARN, "Failed to unpack kerb cred for forwaded tgt\n"));
        Status = KerbMapKerbError(KerbErr);
        goto Cleanup;

    }

    //
    // Now decrypt the encrypted part of the KerbCred.
    //

    KerbErr = KerbDecryptDataEx(
                &KerbCred->encrypted_part,
                &WorkstationTicket->key,
                KERB_CRED_SALT,
                (PULONG) &KerbCred->encrypted_part.cipher_text.length,
                KerbCred->encrypted_part.cipher_text.value
                );


    if (!KERB_SUCCESS(KerbErr))
    {
        DebugLog((DEB_ERROR,"Failed to decrypt KERB_CRED: 0x%x. %ws, line %d\n",KerbErr, THIS_FILE, __LINE__));
        if (KerbErr == KRB_ERR_GENERIC)
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }
        else
        {
            Status = STATUS_LOGON_FAILURE;

            //
            // MIT clients don't encrypt the encrypted part, so drop through
            //

        }
    }

    //
    // Now unpack the encrypted part.
    //

    KerbErr = KerbUnpackEncryptedCred(
                KerbCred->encrypted_part.cipher_text.value,
                KerbCred->encrypted_part.cipher_text.length,
                &EncryptedCred
                );
    if (!KERB_SUCCESS(KerbErr))
    {
        //
        // Use the old status if it is available.
        //

        if (NT_SUCCESS(Status))
        {
            Status = KerbMapKerbError(KerbErr);
        }
        DebugLog((DEB_WARN, "Failed to unpack encrypted cred\n"));
        goto Cleanup;
    }

    //
    // Now build a logon session.
    //

    Status = KerbCreateLogonSessionFromKerbCred(
                NULL,
                WorkstationTicket,
                KerbCred,
                EncryptedCred,
                &LogonSession
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to create logon session from kerb cred: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

Cleanup:
    if (EncryptedCred != NULL)
    {
        KerbFreeEncryptedCred(EncryptedCred);
    }
    if (KerbCred != NULL)
    {
        KerbFreeKerbCred(KerbCred);
    }
    return(Status);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\tktlogon.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        tktlogon.h
//
// Contents:    Structures and prototypes for ticket logon
//
//
// History:     17-February-1999    Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __TKTLOGON_H__
#define __TKTLOGON_H__


NTSTATUS
KerbExtractForwardedTgt(
    IN PKERB_LOGON_SESSION LogonSession,
    IN PKERB_MESSAGE_BUFFER ForwardedTgt,
    IN PKERB_ENCRYPTED_TICKET WorkstationTicket
    );

NTSTATUS
KerbCreateTicketLogonSession(
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferSize,
    IN SECURITY_LOGON_TYPE LogonType,
    OUT PKERB_LOGON_SESSION * NewLogonSession,
    OUT PLUID LogonId,
    OUT PKERB_TICKET_CACHE_ENTRY * WorkstationTicket,
    OUT PKERB_MESSAGE_BUFFER ForwardedTgt
    );


#endif // __TKTLOGON_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\tktcache.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        tktcache.h
//
// Contents:    Prototypes and types for ticket cache
//
//
// History:     16-April-1996   Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __TKTCACHE_H__
#define __TKTCACHE_H__

//
// All global variables declared as EXTERN will be allocated in the file
// that defines TKTCACHE_ALLOCATE
//

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef TKTCACHE_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif

#ifdef WIN32_CHICAGO
EXTERN CRITICAL_SECTION KerberosTicketCacheLock;
#else // WIN32_CHICAGO
EXTERN SAFE_RESOURCE KerberosTicketCacheLock;
#endif // WIN32_CHICAGO
EXTERN BOOLEAN KerberosTicketCacheInitialized;
EXTERN LONG KerbTicketCacheHits;
EXTERN LONG KerbTicketCacheMisses;

#define KERB_TICKET_CACHE_PRIMARY_TGT           0x01             // ticket is primary TGT
#define KERB_TICKET_CACHE_DELEGATION_TGT        0x02             // ticket is delegation TGT
#define KERB_TICKET_CACHE_S4U_TICKET            0x04             // ticket is an S4U ticket
#define KERB_TICKET_CACHE_ASC_TICKET            0x08             // ticket is from AcceptSecurityContext
#define KERB_TICKET_CACHE_TKT_ENC_IN_SKEY       0x10             // ticket is encrypted with a session key


                                                    

#ifdef WIN32_CHICAGO
#define KerbWriteLockTicketCache() (EnterCriticalSection(&KerberosTicketCacheLock));g_lpLastLock = THIS_FILE;g_uLine = __LINE__
#define KerbReadLockTicketCache() (EnterCriticalSection(&KerberosTicketCacheLock));g_lpLastLock = THIS_FILE;g_uLine = __LINE__
#define KerbUnlockTicketCache() (LeaveCriticalSection(&KerberosTicketCacheLock));g_lpLastLock = NULL;g_uLine = 0
#else // WIN32_CHICAGO
#define KerbWriteLockTicketCache() (SafeAcquireResourceExclusive(&KerberosTicketCacheLock,TRUE));g_lpLastLock = THIS_FILE;g_uLine = __LINE__
#define KerbReadLockTicketCache() (SafeAcquireResourceShared(&KerberosTicketCacheLock, TRUE));g_lpLastLock = THIS_FILE;g_uLine = __LINE__
#define KerbUnlockTicketCache() (SafeReleaseResource(&KerberosTicketCacheLock));g_lpLastLock = NULL;g_uLine = 0
#endif // WIN32_CHICAGO

VOID
KerbReferenceTicketCacheEntry(
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    );

VOID
KerbDereferenceTicketCacheEntry(
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    );

NTSTATUS
KerbInitTicketCaching(
    VOID
    );

VOID
KerbAgeTickets( 
    IN PKERB_TICKET_CACHE TicketCache
    );

VOID
KerbFreeTicketCache(
    VOID
    );

NTSTATUS
KerbCreateTicketCacheEntry(
    IN PKERB_KDC_REPLY KdcReply,
    IN PKERB_ENCRYPTED_KDC_REPLY KdcReplyBody,
    IN OPTIONAL PKERB_INTERNAL_NAME TargetName,
    IN OPTIONAL PUNICODE_STRING TargetRealm,
    IN ULONG Flags,
    IN OPTIONAL PKERB_TICKET_CACHE TicketCache,
    IN OPTIONAL PKERB_ENCRYPTION_KEY CredentialKey,
    OUT PKERB_TICKET_CACHE_ENTRY * NewCacheEntry
    );

NTSTATUS
KerbDuplicateTicketCacheEntry(
    IN PKERB_TICKET_CACHE_ENTRY CacheEntry,
    IN OUT PKERB_TICKET_CACHE_ENTRY * NewCacheEntry
    );

VOID
KerbPurgeTicketCache(
    IN PKERB_TICKET_CACHE Cache
    );

VOID
KerbInitTicketCache(
    IN PKERB_TICKET_CACHE TicketCache
    );

PKERB_TICKET_CACHE_ENTRY
KerbLocateTicketCacheEntry(
    IN PKERB_TICKET_CACHE TicketCache,
    IN PKERB_INTERNAL_NAME FullServiceName,
    IN PUNICODE_STRING RealmName
    );

PKERB_TICKET_CACHE_ENTRY
KerbLocateTicketCacheEntryByRealm(
    IN PKERB_TICKET_CACHE TicketCache,
    IN PUNICODE_STRING RealmName,
    IN ULONG RequiredFlags
    );


VOID
KerbInsertTicketCacheEntry(
    IN PKERB_TICKET_CACHE TicketCache,
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    );

VOID
KerbRemoveTicketCacheEntry(
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    );

BOOLEAN
KerbTicketIsExpiring(
    IN PKERB_TICKET_CACHE_ENTRY CacheEntry,
    IN BOOLEAN AllowSkew
    );

VOID
KerbSetTicketCacheEntryTarget(
    IN PUNICODE_STRING TargetName,
    IN PKERB_TICKET_CACHE_ENTRY TicketCacheEntry
    );

VOID
KerbScheduleTgtRenewal(
    IN KERB_TICKET_CACHE_ENTRY * CacheEntry
    );


void
KerbTicketScavenger(
    void * TaskHandle,
    void * TaskItem
    );

#endif // __TKTCACHE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\userlist.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        userlist.h
//
// Contents:    Prototypes for user mapping functions
//
//
// History:     21-February-1997        Created         MikeSw
//
//------------------------------------------------------------------------


#ifndef __USERLIST_H__
#define __USERLIST_H__

#include <pac.hxx>

#define KERB_USERLIST_KEY L"System\\CurrentControlSet\\Control\\Lsa\\Kerberos\\UserList"
#define KERB_MATCH_ALL_NAME L"*"
#define KERB_ALL_USERS_VALUE L"*"

NTSTATUS
KerbCreatePacForKerbClient(
    OUT PPACTYPE * Pac,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm ,
    IN OPTIONAL PUNICODE_STRING MappedClientRealm
    );



NTSTATUS
KerbMapClientName(
    OUT PUNICODE_STRING MappedName,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm
    );



#endif // __USERLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\userapi.h ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        userapi.h
//
// Contents:    Structures and prototypes for user mode Kerberos functions
//
//
// History:     3-May-1996      Created         MikeSw
//
//------------------------------------------------------------------------

#ifndef __USERAPI_H__
#define __USERAPI_H__

#include "krbprgma.h"
#include <gssapiP.h>

#ifdef EXTERN
#undef EXTERN
#endif

#ifdef USERAPI_ALLOCATE
#define EXTERN
#else
#define EXTERN extern
#endif // USERAPI_ALLOCATE


#ifndef WIN32_CHICAGO
EXTERN PSID KerbGlobalLocalSystemSid;
EXTERN PSID KerbGlobalAliasAdminsSid;
#endif // WIN32_CHICAGO

extern gss_OID_desc * gss_mech_krb5;
extern gss_OID_desc * gss_mech_krb5_new;
extern gss_OID_desc * gss_mech_krb5_u2u;
extern gss_OID_desc * gss_mech_krb5_spnego;


typedef struct _KERB_GSS_SIGNATURE {
    BYTE SignatureAlgorithm[2];           // see below table for values
    union {
        BYTE SignFiller[4];               // filler, must be ff ff ff ff
        struct {
            BYTE SealAlgorithm[2];
            BYTE SealFiller[2];
        };
    };
    BYTE SequenceNumber[8];
    BYTE Checksum[8];
} KERB_GSS_SIGNATURE, *PKERB_GSS_SIGNATURE;

#define KERB_GSS_SIG_CONFOUNDER_SIZE    8

typedef struct _KERB_GSS_SEAL_SIGNATURE {
    KERB_GSS_SIGNATURE Signature;
    BYTE Confounder[KERB_GSS_SIG_CONFOUNDER_SIZE];
} KERB_GSS_SEAL_SIGNATURE, *PKERB_GSS_SEAL_SIGNATURE;

typedef ULONG KERB_NULL_SIGNATURE, *PKERB_NULL_SIGNATURE;



//
// This value goes in the second bye of the signature algorithm
//

#define KERB_GSS_SIG_SECOND 0x00

//
// These values go in the first byte
//

#define KERB_GSS_SIG_DES_MAC_MD5        0x00
#define KERB_GSS_SIG_MD25               0x01
#define KERB_GSS_SIG_DES_MAC            0x02


#define KERB_GSS_SIG_HMAC               0x11

//
// These are sealing algorithm values
//

#define KERB_GSS_SEAL_DES_CBC           0x00
#define KERB_GSS_SEAL_RC4_OLD           0x11
#define KERB_GSS_SEAL_RC4               0x10
#define KERB_GSS_NO_SEAL                0xff
#define KERB_GSS_NO_SEAL_SECOND         0xff

//
// These are the flags passed in to MakeSignature and VerifySignature
// corresponding to the above flags, taken from RFC 1964
//

#define GSS_KRB5_INTEG_C_QOP_DEFAULT    0x0
#define GSS_KRB5_INTEG_C_QOP_MD5        0x1
#define GSS_KRB5_INTEG_C_QOP_DES_MD5    0x2
#define GSS_KRB5_INTEG_C_QOP_DES_MAC    0x3


/** constants **/

#define CKSUMTYPE_KG_CB         0x8003

#define KG_TOK_CTX_AP_REQ       0x0100
#define KG_TOK_CTX_AP_REP       0x0200
#define KG_TOK_CTX_ERROR        0x0300
#define KG_TOK_SIGN_MSG         0x0101
#define KG_TOK_SEAL_MSG         0x0201
#define KG_TOK_MIC_MSG          0x0101
#define KG_TOK_WRAP_MSG         0x0201
#define KG_TOK_DEL_CTX          0x0102
#define KG_TOK_CTX_TGT_REQ      0x0400
#define KG_TOK_CTX_TGT_REP      0x0401

#define KRB5_GSS_FOR_CREDS_OPTION 1

#define KERB_SIGN_FLAGS (ISC_RET_INTEGRITY | ISC_RET_SEQUENCE_DETECT | ISC_RET_REPLAY_DETECT)

#define KERB_IS_DES_ENCRYPTION(_x_) ((((_x_) >= KERB_ETYPE_DES_CBC_CRC) && \
                                      ((_x_) <= KERB_ETYPE_DES_CBC_MD5)) || \
                                     ((_x_) == KERB_ETYPE_DES_PLAIN))
#endif // __USERAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\userlist.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1997
//
// File:        userlist.cxx
//
// Contents:    Routines for logging a client with a PAC onto an existing
//              NT account.
//
//
// History:     21-Febuary-1997         Created         MikeSw
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>
#ifndef WIN32_CHICAGO
extern "C"
{
#include <samrpc.h>
#include <lsaisrv.h>
#include <samisrv.h>
}
#include <userall.h>

//+-------------------------------------------------------------------------
//
//  Function:   KerbReadRegistryString
//
//  Synopsis:   Reads & allocates a string from the registry
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS - the value was found
//              STATUS_NO_SUCH_USER - the value was not found
//              STATUS_INSUFFICIENT_RESOURCES - memory allocation failure
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
KerbReadRegistryString(
    IN HKEY Key,
    IN LPWSTR Value,
    IN OUT PUNICODE_STRING String
    )
{
    ULONG Type;
    ULONG WinError = ERROR_SUCCESS;
    ULONG StringSize = 0;
    NTSTATUS Status = STATUS_NO_SUCH_USER;

    WinError = RegQueryValueEx(
                Key,
                Value,
                NULL,
                &Type,
                NULL,
                &StringSize
                );
    if ((WinError == ERROR_MORE_DATA) || (WinError == ERROR_SUCCESS))
    {
        //
        // The value exists - get the name from it
        //

        String->Buffer = (LPWSTR) KerbAllocate(StringSize);
        if (String->Buffer == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        WinError = RegQueryValueEx(
                    Key,
                    Value,
                    NULL,
                    &Type,
                    (PUCHAR) String->Buffer,
                    &StringSize
                    );
        if (WinError != ERROR_SUCCESS)
        {
            goto Cleanup;
        }

        RtlInitUnicodeString(
            String,
            String->Buffer
            );
        Status = STATUS_SUCCESS;
    }

Cleanup:
    if (!NT_SUCCESS(Status) && (String->Buffer != NULL))
    {
        KerbFreeString(String);
    }
    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbMapClientName
//
//  Synopsis:   Maps a Kerberos client name to an NT user name. First it
//              tries converting the name to a string and looking for a
//              value with that name. If that fails, it looks for a
//              value with the client realm name.
//
//  Effects:
//
//  Arguments:  MappedName - receives the name of the local account the
//                      client maps to
//              ClientName - Kerberos principal name of the client
//              ClientRealm - Kerberos realm of the client
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMapClientName(
    OUT PUNICODE_STRING MappedName,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm
    )
{

    LPWSTR UserName = NULL;
    DWORD WinError;
    NTSTATUS Status = STATUS_NO_SUCH_USER;
    HKEY Key = NULL;
    UNICODE_STRING ClientString = {0};

    EMPTY_UNICODE_STRING( MappedName );


    //
    // First convert the MIT client name to a registry value name. We do
    // this by adding a '/' between every component of the client name
    // and appending "@ClientRealm"
    //

    //
    // Make sure the client realm is null terminated
    //

    DsysAssert(ClientRealm->Length == 0 || (ClientRealm->MaximumLength >= ClientRealm->Length + sizeof(WCHAR)));
    DsysAssert(ClientRealm->Length == 0 || (ClientRealm->Buffer[ClientRealm->Length/sizeof(WCHAR)] == L'\0'));

    //
    // The value length is the length of all the components of the names,
    // all the '/' separtors, and the name of the domain name plus '@'
    //


    if (!KERB_SUCCESS(KerbConvertKdcNameToString(
            &ClientString,
            ClientName,
            ClientRealm)))
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    D_DebugLog((DEB_TRACE,"Mapping client name %wZ\n",&ClientString ));

    //
    // Also build just the username, which is used when users are mapped
    // back to their own name
    //

    UserName = (LPWSTR) KerbAllocate(ClientName->Names[0].Length + sizeof(WCHAR));
    if (UserName == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;

    }

    RtlCopyMemory(
        UserName,
        ClientName->Names[0].Buffer,
        ClientName->Names[0].Length
        );
    UserName[ClientName->Names[0].Length / sizeof(WCHAR)] = L'\0';

    //
    // Now check the registry for a mapping for this name
    //

    WinError = RegOpenKey(
                HKEY_LOCAL_MACHINE,
                KERB_USERLIST_KEY,
                &Key
                );
    if (WinError != ERROR_SUCCESS)
    {
        goto Cleanup;
    }

    //
    // Read out the value
    //

    Status = KerbReadRegistryString(
                Key,
                ClientString.Buffer,
                MappedName
                );
    if (Status == STATUS_NO_SUCH_USER)
    {

        //
        // Try again with just the domain name - this allows all users in
        // a domain to be mapped
        //
        Status = KerbReadRegistryString(
                    Key,
                    ClientRealm->Buffer,
                    MappedName
                    );

    }
    if (Status == STATUS_NO_SUCH_USER)
    {
        Status = KerbReadRegistryString(
                    Key,
                    KERB_ALL_USERS_VALUE,
                    MappedName
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If the mapped name is '*', then use the client's name
    //

    if (_wcsicmp(MappedName->Buffer,KERB_MATCH_ALL_NAME) == 0)
    {
        KerbFree(MappedName->Buffer);
        RtlInitUnicodeString(
            MappedName,
            UserName
            );
        UserName = NULL;
    }


    Status = STATUS_SUCCESS;

Cleanup:
    if (!NT_SUCCESS(Status))
    {
        KerbFreeString(MappedName);
    }
    KerbFreeString(&ClientString);
    if (UserName != NULL)
    {
        KerbFree(UserName);
    }
    if (Key != NULL)
    {
        RegCloseKey(Key);
    }
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbCreatePacForKerbClient
//
//  Synopsis:   Creates a PAC structure for a kerb client without a PAC
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbCreatePacForKerbClient(
    OUT PPACTYPE * Pac,
    IN PKERB_INTERNAL_NAME ClientName,
    IN PUNICODE_STRING ClientRealm,
    IN OPTIONAL PUNICODE_STRING MappedClientName
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PLSAPR_POLICY_INFORMATION PolicyInfo = NULL;
    SAMPR_HANDLE SamHandle = NULL;
    SAMPR_HANDLE DomainHandle = NULL;
    SAMPR_HANDLE UserHandle = NULL;
    PSAMPR_GET_GROUPS_BUFFER Groups = NULL;
    SID_AND_ATTRIBUTES_LIST TransitiveGroups = {0};
    PSAMPR_USER_INFO_BUFFER UserInfo = NULL;
    PPACTYPE LocalPac = NULL;
    SAMPR_ULONG_ARRAY RidArray;
    SAMPR_ULONG_ARRAY UseArray;
    SECPKG_CLIENT_INFO ClientInfo;

    //
    // local variables containing copy of globals.
    //

    UNICODE_STRING LocalMachineName;
    UNICODE_STRING LocalDomainName;
    UNICODE_STRING LocalAccountName = NULL_UNICODE_STRING;
    KERBEROS_MACHINE_ROLE LocalRole = KerbRoleWorkstation;
    BOOLEAN GlobalsLocked = FALSE;

    RidArray.Element = NULL;
    UseArray.Element = NULL;

    LocalMachineName.Buffer = NULL;
    LocalDomainName.Buffer = NULL;

    //
    // Verify that the caller has TCB privilege. Otherwise anyone can forge
    // a ticket to themselves to logon with any name in the list.
    //

    Status = LsaFunctions->GetClientInfo(&ClientInfo);
    if (!NT_SUCCESS(Status))
    {
        return(Status);
    }

    if (!ClientInfo.HasTcbPrivilege)
    {
        return(STATUS_PRIVILEGE_NOT_HELD);
    }

    //
    // If we are a domain controller, call SAM to do the mapping.
    // Otherwise, do it ourselves.
    //

    //
    // Common code for both wksta and DC - open SAM
    // However, if we're a realmless wksta, we know we have a client 
    // mapping to a local account so skip lookup on DC
    //

    //
    // Call the LSA to get our domain sid
    //

            
    Status = LsaIQueryInformationPolicyTrusted(
                    PolicyAccountDomainInformation,
                    &PolicyInfo
                    );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Open SAM to get the account information
    //


    Status = SamIConnect(
                NULL,                   // no server name
                &SamHandle,
                0,                      // no desired access
                TRUE                    // trusted caller
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = SamrOpenDomain(
                    SamHandle,
                    0,                      // no desired access
                    (PRPC_SID) PolicyInfo->PolicyAccountDomainInfo.DomainSid,
                    &DomainHandle
                    );
            
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // grab the globals while holding the lock.
    // ... then release the lock prior to making the call!
    //

    KerbGlobalReadLock();
    GlobalsLocked = TRUE;

    LocalRole = KerbGlobalRole;

    Status = KerbDuplicateString( &LocalMachineName, &KerbGlobalMachineName );
    if(!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to duplicate KerbGlobalMachineName\n"));
        goto Cleanup;
    }

    if( LocalRole == KerbRoleDomainController ) 
    {
        Status = KerbDuplicateString( &LocalDomainName, &KerbGlobalDomainName );
        if(!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR, "Failed to duplicate KerbGlobalDomainName\n"));
            goto Cleanup;
        }
    }

    KerbGlobalReleaseLock();
    GlobalsLocked = FALSE;

    //
    // If the is a DC, try to look up the name in SAM as an AltSecId.
    // If that fails, we will try looking at the registry mapping.
    //

    if (LocalRole == KerbRoleDomainController)
    {
        UNICODE_STRING AltSecId = {0};
        KERBERR KerbErr;

        KerbErr = KerbBuildAltSecId(
                        &AltSecId,
                        ClientName,
                        NULL,               // no unicode realm
                        ClientRealm
                        );

        if (!KERB_SUCCESS(KerbErr))
        {
            Status = KerbMapKerbError(KerbErr);
            goto Cleanup;
        }

        Status = SamIGetUserLogonInformationEx(
                        SamHandle,
                        SAM_OPEN_BY_ALTERNATE_ID,
                        &AltSecId,
                        USER_ALL_PAC_INIT,
                        &UserInfo,
                        &TransitiveGroups,
                        NULL                // no user handle
                        );

        KerbFreeString(&AltSecId);

    }
    
     

    if (!NT_SUCCESS(Status) || (UserInfo == NULL))
    {
        if (!ARGUMENT_PRESENT(MappedClientName) || MappedClientName->Buffer == NULL)
        {   
            Status = KerbMapClientName(
                        &LocalAccountName,
                        ClientName,
                        ClientRealm
                        );
        
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
        else
        {
            KerbDuplicateString(
                    &LocalAccountName,
                    MappedClientName
                    );               

        }

    
        Status = SamrLookupNamesInDomain(
                    DomainHandle,
                    1,
                    (PRPC_UNICODE_STRING) &LocalAccountName,
                    &RidArray,
                    &UseArray
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        if ((UseArray.Element[0] != SidTypeUser) &&
            (UseArray.Element[0] != SidTypeComputer))
        {
            Status = STATUS_NONE_MAPPED;
            goto Cleanup;
        }

        //
        // Finally open the user
        //
        Status = SamrOpenUser(
                    DomainHandle,
                    0,                      // no desired access,
                    RidArray.Element[0],
                    &UserHandle
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        Status = SamrQueryInformationUser(
                    UserHandle,
                    UserAllInformation,
                    &UserInfo
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        Status = SamrGetGroupsForUser(
                    UserHandle,
                    &Groups
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }


    }

    //
    // This is common code
    //


    //
    // Set the password must changes time to inifinite because we don't
    // want spurious password must change popups
    //

    UserInfo->All.PasswordMustChange = *(POLD_LARGE_INTEGER) &KerbGlobalWillNeverTime;

    //
    // Finally build the PAC
    //


    Status = PAC_Init(
                &UserInfo->All,
                Groups,
                &TransitiveGroups,   // no extra groups
                PolicyInfo->PolicyAccountDomainInfo.DomainSid,
                ((LocalRole == KerbRoleDomainController) ?
                    &LocalDomainName : &LocalMachineName),
                &LocalMachineName,
                0,      // no signature
                0,      // no additional data
                NULL,   // no additional data
                &LocalPac
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    *Pac = LocalPac;
    LocalPac = NULL;

Cleanup:

    if( GlobalsLocked )
    {
        KerbGlobalReleaseLock();
    }

    KerbFreeString( &LocalMachineName );
    KerbFreeString( &LocalDomainName );
    KerbFreeString( &LocalAccountName );
    

    if (UserHandle != NULL)
    {
        SamrCloseHandle( &UserHandle );
    }
    if (DomainHandle != NULL)
    {
        SamrCloseHandle( &DomainHandle );
    }
    if (SamHandle != NULL)
    {
        SamrCloseHandle( &SamHandle );
    }
    if (Groups != NULL)
    {
        SamIFree_SAMPR_GET_GROUPS_BUFFER( Groups );
    }

    SamIFreeSidAndAttributesList(&TransitiveGroups);

    if (UserInfo != NULL)
    {
        SamIFree_SAMPR_USER_INFO_BUFFER( UserInfo, UserAllInformation );
    }
    if (PolicyInfo != NULL)
    {
        LsaIFree_LSAPR_POLICY_INFORMATION(
            PolicyAccountDomainInformation,
            PolicyInfo
            );
    }
    SamIFree_SAMPR_ULONG_ARRAY( &UseArray );
    SamIFree_SAMPR_ULONG_ARRAY( &RidArray );

    if (LocalPac != NULL)
    {
        MIDL_user_free(LocalPac);
    }

    return(Status);

}
#endif // WIN32_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\userapi.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        userapi.cxx
//
// Contents:    User-mode APIs to Kerberos package
//
//
// History:     17-April-1996   Created         MikeSw
//              26-Sep-1998   ChandanS
//                            Added more debugging support etc.
//
//------------------------------------------------------------------------

/*
 * Copyright 1993 by OpenVision Technologies, Inc.
 *
 * Permission to use, copy, modify, distribute, and sell this software
 * and its documentation for any purpose is hereby granted without fee,
 * provided that the above copyright notice appears in all copies and
 * that both that copyright notice and this permission notice appear in
 * supporting documentation, and that the name of OpenVision not be used
 * in advertising or publicity pertaining to distribution of the software
 * without specific, written prior permission. OpenVision makes no
 * representations about the suitability of this software for any
 * purpose.  It is provided "as is" without express or implied warranty.
 *
 * OPENVISION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO
 * EVENT SHALL OPENVISION BE LIABLE FOR ANY SPECIAL, INDIRECT OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
 * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
 * PERFORMANCE OF THIS SOFTWARE.
*/

#include <kerb.hxx>

#define USERAPI_ALLOCATE
#include <kerbp.h>

#ifdef RETAIL_LOG_SUPPORT
static TCHAR THIS_FILE[]=TEXT(__FILE__);
#endif

#ifndef WIN32_CHICAGO
extern "C"
{
#include <cryptdll.h>
}
#endif // WIN32_CHICAGO
#include "userapi.h"

#define DONT_SUPPORT_OLD_TYPES_USER 1

#define ALIGN_SIZE      sizeof(PVOID)
#define ALIGN_SHIFT     (ALIGN_SIZE - 0x00000001)       // 0x00000007
#define IS_POINTER_ALIGNED(ptr)  (((UINT_PTR)(ptr) & ALIGN_SHIFT) == 0x00000000)

// can't sign or seal messages greater than this
#define KERB_MAX_MESSAGE_SIZE 0x40000000
//
// Common GSS object IDs, taken from MIT kerberos distribution.
//

gss_OID_desc oids[] = {
    {5, "\053\005\001\005\002"},                      // original mech id
    {9, "\052\206\110\206\367\022\001\002\002"},      // standard mech id
    {10, "\052\206\110\206\367\022\001\002\002\001"}, // krb5_name type
    {10, "\052\206\110\206\367\022\001\002\002\002"}, // krb5_principal type
    {10, "\052\206\110\206\367\022\001\002\002\003"}, // user2user mech id
    {9, "\052\206\110\202\367\022\001\002\002"},      // bogus mangled OID from spnego
};

gss_OID_desc * gss_mech_krb5 = oids;
gss_OID_desc * gss_mech_krb5_new = oids+1;
gss_OID_desc * gss_mech_krb5_u2u = oids+4;
gss_OID_desc * gss_mech_krb5_spnego = oids+5;

#ifndef WIN32_CHICAGO


//+-------------------------------------------------------------------------
//
//  Function:   SpUserModeInitialize
//
//  Synopsis:   Returns table of usermode functions to caller
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    SUCCESS if version is correct
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
SEC_ENTRY
SpUserModeInitialize(
    IN ULONG    LsaVersion,
    OUT PULONG  PackageVersion,
    OUT PSECPKG_USER_FUNCTION_TABLE * UserFunctionTable,
    OUT PULONG  pcTables)
{
    if (LsaVersion != SECPKG_INTERFACE_VERSION)
    {
        DebugLog((DEB_ERROR,"Invalid LSA version: %d. %ws, line %d\n", LsaVersion, THIS_FILE, __LINE__));
        return(STATUS_INVALID_PARAMETER);
    }

    *PackageVersion = SECPKG_INTERFACE_VERSION ;

    KerberosUserFunctionTable.InstanceInit = SpInstanceInit;
    KerberosUserFunctionTable.MakeSignature = SpMakeSignature;
    KerberosUserFunctionTable.VerifySignature = SpVerifySignature;
    KerberosUserFunctionTable.SealMessage = SpSealMessage;
    KerberosUserFunctionTable.UnsealMessage = SpUnsealMessage;
    KerberosUserFunctionTable.GetContextToken = SpGetContextToken;
    KerberosUserFunctionTable.QueryContextAttributes = SpQueryContextAttributes;
    KerberosUserFunctionTable.CompleteAuthToken = SpCompleteAuthToken;
    KerberosUserFunctionTable.InitUserModeContext = SpInitUserModeContext;
    KerberosUserFunctionTable.DeleteUserModeContext = SpDeleteUserModeContext;
    KerberosUserFunctionTable.FormatCredentials = SpFormatCredentials;
    KerberosUserFunctionTable.MarshallSupplementalCreds = SpMarshallSupplementalCreds;
    KerberosUserFunctionTable.ExportContext = SpExportSecurityContext;
    KerberosUserFunctionTable.ImportContext = SpImportSecurityContext;

    *pcTables = 1;

    *UserFunctionTable = &KerberosUserFunctionTable;

    if (KerberosState != KerberosLsaMode)
    {
        //
        // SafeAllocaInitialize was already called in SpLsaModeInitialize
        //

        SafeAllocaInitialize(SAFEALLOCA_USE_DEFAULT,
                             SAFEALLOCA_USE_DEFAULT,
                             KerbAllocate,
                             KerbFree);
    }

    return( STATUS_SUCCESS );

}
#endif // WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   SpInstanceInit
//
//  Synopsis:   Initialize an instance of the Kerberos package in a client's
//              address space
//
//  Effects:
//
//  Arguments:  Version - Version of the security dll loading the package
//              FunctionTable - Contains helper routines for use by Kerberos
//              UserFunctions - Receives a copy of Kerberos's user mode
//                  function table
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpInstanceInit(
    IN ULONG Version,
    IN PSECPKG_DLL_FUNCTIONS DllFunctionTable,
    OUT PVOID * UserFunctionTable
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    if (!KerbGlobalInitialized)
    {
        KerberosState = KerberosUserMode;

        Status = KerbInitGlobalVariables();
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to initialize global variables: 0x%x. %ws, line %d\n",
                Status, THIS_FILE, __LINE__ ));
            goto Cleanup;
        }

        Status = KerbInitContextList();
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to initialize context list: 0x%x. %ws, line %d\n",
                Status, THIS_FILE, __LINE__ ));
            goto Cleanup;
        }
    }
    else
    {
        D_DebugLog((DEB_TRACE,"Re-initializing kerberos from LSA mode to User Mode\n"));
    }

    UserFunctions = DllFunctionTable;

#ifndef WIN32_CHICAGO
    //
    // Build the two well known sids we need.
    //

    if( KerbGlobalLocalSystemSid == NULL )
    {
        Status = RtlAllocateAndInitializeSid(
                    &NtAuthority,
                    1,
                    SECURITY_LOCAL_SYSTEM_RID,
                    0,0,0,0,0,0,0,
                    &KerbGlobalLocalSystemSid
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    if( KerbGlobalAliasAdminsSid == NULL )
    {
        Status = RtlAllocateAndInitializeSid(
                    &NtAuthority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS,
                    0,0,0,0,0,0,
                    &KerbGlobalAliasAdminsSid
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }
#endif // WIN32_CHICAGO


    KerbGlobalInitialized = TRUE;

Cleanup:

    if( !KerbGlobalInitialized && !NT_SUCCESS(Status) )
    {
        if( KerbGlobalLocalSystemSid != NULL )
        {
            RtlFreeSid( KerbGlobalLocalSystemSid );
            KerbGlobalLocalSystemSid = NULL;
        }

        if( KerbGlobalAliasAdminsSid != NULL )
        {
            RtlFreeSid( KerbGlobalAliasAdminsSid );
            KerbGlobalAliasAdminsSid = NULL;
        }
    }

    return(Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   SpDeleteUserModeContext
//
//  Synopsis:   Deletes a user mode context by unlinking it and then
//              dereferencing it.
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa context handle of the context to delete
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS on success, STATUS_INVALID_HANDLE if the
//              context can't be located, SEC_I_NO_LSA_CONTEXT if this was
//              created from an exported context
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpDeleteUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CONTEXT Context = NULL;

    D_DebugLog((DEB_TRACE_API,"SpDeleteUserModeContext called\n"));

    Status = KerbReferenceContextByLsaHandle(
                ContextHandle,
                TRUE,
                &Context                // unlink it
                );
    if (!NT_SUCCESS(Status))
    {
        D_DebugLog((DEB_TRACE,"Failed to reference context 0x%x by lsa handle\n",
            ContextHandle));
        return(STATUS_SUCCESS); // no error code should be returned in this case
    }

    //
    // Make sure we don't try to call the LSA to delete imported contexts
    //

    KerbReadLockContexts();
    if ((Context->ContextAttributes & KERB_CONTEXT_IMPORTED) != 0)
    {
        Status = SEC_I_NO_LSA_CONTEXT;
    }
    KerbUnlockContexts();

    KerbDereferenceContext(
        Context
        );

    D_DebugLog((DEB_TRACE_API, "SpDeleteUserModeContext returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}


//+-------------------------------------------------------------------------
//
//  Function:   SpInitUserModeContext
//
//  Synopsis:   Creates a user-mode context from a packed LSA mode context
//
//  Effects:
//
//  Arguments:  ContextHandle - Lsa mode context handle for the context
//              PackedContext - A marshalled buffer containing the LSA
//                  mode context.
//
//  Requires:
//
//  Returns:    STATUS_SUCCESS or STATUS_INSUFFICIENT_RESOURCES
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpInitUserModeContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBuffer PackedContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CONTEXT Context = NULL;

    D_DebugLog((DEB_TRACE_API,"SpInitUserModeContext called\n"));

    Status = KerbCreateUserModeContext(
                ContextHandle,
                PackedContext,
                &Context
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to create user mode context: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

Cleanup:
    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }
    if (PackedContext->pvBuffer != NULL)
    {
        FreeContextBuffer(PackedContext->pvBuffer);
        PackedContext->pvBuffer = NULL;
    }

    D_DebugLog((DEB_TRACE_API, "SpInitUserModeContext returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}



//+-------------------------------------------------------------------------
//
//  Function:   SpExportSecurityContext
//
//  Synopsis:   Exports a security context to another process
//
//  Effects:    Allocates memory for output
//
//  Arguments:  ContextHandle - handle to context to export
//              Flags - Flags concerning duplication. Allowable flags:
//                      SECPKG_CONTEXT_EXPORT_DELETE_OLD - causes old context
//                              to be deleted.
//              PackedContext - Receives serialized context to be freed with
//                      FreeContextBuffer
//              TokenHandle - Optionally receives handle to context's token.
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
SpExportSecurityContext(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG Flags,
    OUT PSecBuffer PackedContext,
    OUT PHANDLE TokenHandle
    )
{
    PKERB_CONTEXT Context = NULL;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN MappedContext = FALSE;


    D_DebugLog((DEB_TRACE_API,"SpExportContext Called\n"));
    D_DebugLog((DEB_TRACE_USER,"Exporting context 0x%p, flags 0x%x\n",ContextHandle, Flags));

    //
    // We don't support reseting the context
    //

    if ((Flags & SECPKG_CONTEXT_EXPORT_RESET_NEW) != 0)
    {
        return(SEC_E_UNSUPPORTED_FUNCTION);
    }

    if (ARGUMENT_PRESENT(TokenHandle))
    {
        *TokenHandle = NULL;
    }

    PackedContext->pvBuffer = NULL;
    PackedContext->cbBuffer = 0;
    PackedContext->BufferType = 0;

    Status = KerbReferenceContextByLsaHandle(
                ContextHandle,
                FALSE,           // don't unlink
                &Context
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for ExportSecurityContext(%p) Status = 0x%x. %ws, line %d\n",
            ContextHandle, Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    Status = KerbMapContext(
                Context,
                &MappedContext,
                PackedContext
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    DsysAssert(MappedContext);

    //
    // We need to figure out if this was exported
    //

    ((PKERB_CONTEXT)PackedContext->pvBuffer)->ContextAttributes |= KERB_CONTEXT_EXPORTED;
    //
    // Now either duplicate the token or copy it.
    //

    if (ARGUMENT_PRESENT(TokenHandle))
    {
        KerbWriteLockContexts();
        if ((Flags & SECPKG_CONTEXT_EXPORT_DELETE_OLD) != 0)
        {
            *TokenHandle = Context->TokenHandle;
            Context->TokenHandle = NULL;
        }
        else
        {
            Status = NtDuplicateObject(
                        NtCurrentProcess(),
                        Context->TokenHandle,
                        NULL,
                        TokenHandle,
                        0,              // no new access
                        0,              // no handle attributes
                        DUPLICATE_SAME_ACCESS
                        );
        }
        KerbUnlockContexts();

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

    }

Cleanup:

    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }

    D_DebugLog((DEB_TRACE_API, "SpExportSecurityContext returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}


//+-------------------------------------------------------------------------
//
//  Function:   SpImportSecurityContext
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
SpImportSecurityContext(
    IN PSecBuffer PackedContext,
    IN HANDLE Token,
    OUT PLSA_SEC_HANDLE ContextHandle
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CONTEXT Context = NULL;

    D_DebugLog((DEB_TRACE_API,"SpImportSecurityContext called\n"));
        
    SecBuffer   TmpSecBuffer = (*PackedContext);

#if _WIN64

    PBYTE       TmpBuffer = NULL;

    //
    // See if this is an aligned buffer - SAP has some IPC mechanisms
    // which don't gaurantee that the pSecBuffer is actually 8 bit aligned, 
    // so we should.  Blech!           
    // 
    if (!IS_POINTER_ALIGNED(PackedContext->pvBuffer))
    {   

        TmpBuffer = (PBYTE) UserFunctions->AllocateHeap(((UNALIGNED SecBuffer *)PackedContext)->cbBuffer);

        if ( NULL == TmpBuffer )
        {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }


        //
        // Align it. Note that the members inside of this buffer were already 
        // aligned on export, so this should be all we need to do
        //
        RtlCopyMemory(
            TmpBuffer,
            PackedContext->pvBuffer,
            PackedContext->cbBuffer
            );

        TmpSecBuffer.pvBuffer = TmpBuffer;
    }   
          
    #endif // _WIN64 

    Status = KerbCreateUserModeContext(
                0,              // no lsa context
                &TmpSecBuffer,
                &Context
                );
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to create user mode context: 0x%x. %ws, line %d\n",
            Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }
    KerbWriteLockContexts();
    Context->TokenHandle = Token;
    Context->ContextAttributes |= KERB_CONTEXT_IMPORTED;




    *ContextHandle = KerbGetContextHandle(Context);
    //Context->LsaContextHandle = *ContextHandle;

    KerbUnlockContexts();

Cleanup:
    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }


#if _WIN64

    if ( TmpBuffer )
    {
        UserFunctions->FreeHeap(TmpBuffer);
    }

#endif // _WIN64 

    D_DebugLog((DEB_TRACE_API, "SpImportSecurityContext returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));
    D_DebugLog((DEB_TRACE_USER," Imported Context handle = 0x%x\n",*ContextHandle));
    return(KerbMapKerbNtStatusToNtStatus(Status));
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbGetChecksumAndEncryptionType
//
//  Synopsis:   Gets the ChecksumType and the EncryptionType
//
//  Effects:
//
//  Arguments:  Context - Context to use for signing
//              QualityOfProtection - flags indicating what kind of checksum
//                      to use
//              ChecksumType - Receives the type of checksum to use
//              EncryptionType - Receives the type of encryption to use
//
//  Requires:   The context must be write locked
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbGetChecksumAndEncryptionType(
    IN PKERB_CONTEXT Context,
    IN ULONG QualityOfProtection,
    OUT PLONG ChecksumType,
    OUT PLONG EncryptionType
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // If the keytype is an MS keytype, we need to use an MS encryption
    // scheme.
    //

    if (!KERB_IS_DES_ENCRYPTION(Context->SessionKey.keytype))
    {

#ifndef DONT_SUPPORT_OLD_TYPES_USER
        if (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_OLD)
        {
            *ChecksumType = KERB_CHECKSUM_HMAC_MD5;
            *EncryptionType = KERB_ETYPE_RC4_PLAIN_OLD;
        }
        else if (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_OLD_EXP)
        {
            *ChecksumType = KERB_CHECKSUM_HMAC_MD5;
            *EncryptionType = KERB_ETYPE_RC4_PLAIN_OLD_EXP;
        }
        else
#endif
        if (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_NT)
        {
            *ChecksumType = KERB_CHECKSUM_HMAC_MD5;
            *EncryptionType = KERB_ETYPE_RC4_PLAIN;
        }
        else
        {
            DsysAssert (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_NT_EXP);
            *ChecksumType = KERB_CHECKSUM_HMAC_MD5;
            *EncryptionType = KERB_ETYPE_RC4_PLAIN_EXP;
        }
    }
    else
    {
        //
        // Use the exportable version if necessasry
        //

        *EncryptionType = KERB_ETYPE_DES_PLAIN;

        switch(QualityOfProtection)
        {
        case GSS_KRB5_INTEG_C_QOP_MD5:
            *ChecksumType = KERB_CHECKSUM_MD25;
            break;
        case KERB_WRAP_NO_ENCRYPT:
        case GSS_KRB5_INTEG_C_QOP_DEFAULT:
        case GSS_KRB5_INTEG_C_QOP_DES_MD5:
            *ChecksumType = KERB_CHECKSUM_DES_MAC_MD5;
            break;
        case GSS_KRB5_INTEG_C_QOP_DES_MAC:
            *ChecksumType = KERB_CHECKSUM_DES_MAC;
            break;
        default:
            DebugLog((DEB_ERROR,"Invalid quality of protection sent to MakeSignature: %d. %ws, line %d\n",
                QualityOfProtection, THIS_FILE, __LINE__ ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }
Cleanup:
    return(Status);
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbMakeSignatureToken
//
//  Synopsis:   Makes the signature token for a signed or sealed message
//
//  Effects:
//
//  Arguments:  Context - Context to use for signing
//              QualityOfProtection - flags indicating what kind of checksum
//                      to use
//              SignatureBuffer - Buffer in which to place signature
//              TotalBufferSize - Total size of all buffers to be signed
//              Encrypt - if TRUE, then prepare a header for an encrypted buffer
//              SuppliedNonce - Nonce supplied by caller, used for datagram
//
//  Requires:   The context must be write locked
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbMakeSignatureToken(
    IN PKERB_CONTEXT Context,
    IN ULONG QualityOfProtection,
    IN PSecBuffer SignatureBuffer,
    IN ULONG TotalBufferSize,
    IN BOOLEAN Encrypt,
    IN ULONG SuppliedNonce,
    OUT PKERB_GSS_SIGNATURE * OutputSignature,
    OUT PULONG SequenceNumber
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_GSS_SIGNATURE Signature;
    PKERB_GSS_SEAL_SIGNATURE SealSignature;
    ULONG MessageSize;
    ULONG SignatureSize;
    PULONG Nonce;
    gss_OID MechUsed;
    BOOLEAN GssCompatible = TRUE;

    //
    // Compute the size of the header. For encryption headers, we need
    // to round up the size of the data & add 8 bytes for a confounder.
    //

    if ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) != 0 ||
        (Context->ContextFlags & ISC_RET_DATAGRAM) != 0)
    {
        GssCompatible = FALSE;
    }

    //
    // Since RPC doesn't carry around the size of the size of the
    // signature bufer, we use it in the header. This break rfc1964 compat.
    //

    if (!GssCompatible || !Encrypt)
    {
        TotalBufferSize = 0;
    }

    // D_DebugLog((DEB_TRACE, "KerbMakeSignatureToken ContextAttributes %#x\n", Context->ContextAttributes));

    if ((Context->ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
    {
        D_DebugLog((DEB_TRACE_U2U, "KerbMakeSignatureToken u2u oid used\n"));
        MechUsed = gss_mech_krb5_u2u;
    }
    else
    {
        MechUsed = gss_mech_krb5_new;
    }
    if (Encrypt)
    {
        //
        // NOTE: according to rfc1964, buffers that are an even multiple of
        // 8 bytes have 8 bytes of zeros appended. Because we cannot modify
        // the input buffers, the caller will have to do this for us.
        //


        MessageSize = TotalBufferSize + sizeof(KERB_GSS_SEAL_SIGNATURE);
    }
    else
    {
        MessageSize = TotalBufferSize + sizeof(KERB_GSS_SIGNATURE);
    }

    SignatureSize = g_token_size(MechUsed, MessageSize) - TotalBufferSize;


    //
    // Make Dave happy (verify that the supplied signature buffer is large
    // enough for a signature):
    //

    if (SignatureBuffer->cbBuffer < SignatureSize)
    {
        Status = STATUS_BUFFER_TOO_SMALL;
        goto Cleanup;
    }

    //
    // create the header with the GSS oid
    //

    Signature = (PKERB_GSS_SIGNATURE) SignatureBuffer->pvBuffer;
    g_make_token_header(
        MechUsed,
        MessageSize,
        (PUCHAR *) &Signature,
        (Encrypt ? KG_TOK_WRAP_MSG : KG_TOK_MIC_MSG)
        );

    //
    // Fill in the header information according to RFC1964
    //

    Signature->SignatureAlgorithm[1] = KERB_GSS_SIG_SECOND;

    //
    // If the keytype is an MS keytype, we need to use an MS encryption
    // scheme.
    //

    if (!KERB_IS_DES_ENCRYPTION(Context->SessionKey.keytype))
    {
#ifndef DONT_SUPPORT_OLD_TYPES_USER
        if (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_OLD)
        {
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_HMAC;
            if (Encrypt)
            {
                Signature->SealAlgorithm[1] = KERB_GSS_SIG_SECOND;
                Signature->SealAlgorithm[0] = KERB_GSS_SEAL_RC4_OLD;
            }
        }
        else if (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_OLD_EXP)
        {
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_HMAC;
            if (Encrypt)
            {
                Signature->SealAlgorithm[1] = KERB_GSS_SIG_SECOND;
                Signature->SealAlgorithm[0] = KERB_GSS_SEAL_RC4_OLD;
            }
        }
        else
#endif
        if (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_NT)
        {
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_HMAC;
            if (Encrypt)
            {
                Signature->SealAlgorithm[1] = KERB_GSS_SIG_SECOND;
                Signature->SealAlgorithm[0] = KERB_GSS_SEAL_RC4;
            }
        }
        else
        {
            DsysAssert (Context->SessionKey.keytype == KERB_ETYPE_RC4_HMAC_NT_EXP);
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_HMAC;
            if (Encrypt)
            {
                Signature->SealAlgorithm[1] = KERB_GSS_SIG_SECOND;
                Signature->SealAlgorithm[0] = KERB_GSS_SEAL_RC4;
            }
        }

        //
        // if we aren't actually encrypting, reset the encryption alg
        //

        if (QualityOfProtection == KERB_WRAP_NO_ENCRYPT)
        {
            if (!Encrypt)
            {
                DebugLog((DEB_ERROR,"KERB_WRAP_NO_ENCRYPT flag passed to MakeSignature!\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            //
            // In this case use the default, but we will not encrypt
            //

            Signature->SealAlgorithm[1] = KERB_GSS_NO_SEAL_SECOND;
            Signature->SealAlgorithm[0] = KERB_GSS_NO_SEAL;
        }
    }
    else
    {
        if (Encrypt)
        {
            Signature->SealAlgorithm[1] = KERB_GSS_SIG_SECOND;
            Signature->SealAlgorithm[0] = KERB_GSS_SEAL_DES_CBC;
        }

        //
        // Use the exportable version if necessasry
        //

        switch(QualityOfProtection)
        {
        case GSS_KRB5_INTEG_C_QOP_MD5:
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_MD25;
            break;
        case KERB_WRAP_NO_ENCRYPT:
            if (!Encrypt)
            {
                DebugLog((DEB_ERROR,"KERB_WRAP_NO_ENCRYPT flag passed to MakeSignature!\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto Cleanup;
            }

            //
            // In this case use the default, but we will not encrypt
            //

            Signature->SealAlgorithm[1] = KERB_GSS_NO_SEAL_SECOND;
            Signature->SealAlgorithm[0] = KERB_GSS_NO_SEAL;

        case GSS_KRB5_INTEG_C_QOP_DEFAULT:
        case GSS_KRB5_INTEG_C_QOP_DES_MD5:
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_DES_MAC_MD5;
            break;
        case GSS_KRB5_INTEG_C_QOP_DES_MAC:
            Signature->SignatureAlgorithm[0] = KERB_GSS_SIG_DES_MAC;
            break;
        default:
            DebugLog((DEB_ERROR,"Invalid quality of protection sent to MakeSignature: %d. %ws, line %d\n",
                QualityOfProtection, THIS_FILE, __LINE__ ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    //
    // Put in the filler - it is different for signing & sealing
    //

    if (Encrypt)
    {
        memset(Signature->SealFiller,0xff,2);
    }
    else
    {
        memset(Signature->SignFiller,0xff,4);
    }

    //
    // Inbound contexts get a high dword of 0xffffffff, outbound gets
    // 0x00000000.
    //

    Nonce = &Context->Nonce;

    if (Context->ContextAttributes & KERB_CONTEXT_INBOUND)
    {
        *(ULONG UNALIGNED *)(&Signature->SequenceNumber[4]) = 0xffffffff;
    }
    else
    {
        DsysAssert((Context->ContextAttributes & KERB_CONTEXT_OUTBOUND) != 0);
        *(ULONG UNALIGNED *)(&Signature->SequenceNumber[4]) = 0x00000000;
    }

    //
    // If this is datagram, or integrity without replay & sequence detection,
    // use the nonce from the caller
    //

    if (((Context->ContextFlags & ISC_RET_DATAGRAM) != 0) ||
        ((Context->ContextFlags & (ISC_RET_INTEGRITY | ISC_RET_SEQUENCE_DETECT | ISC_RET_REPLAY_DETECT)) == ISC_RET_INTEGRITY))

    {
        Nonce = &SuppliedNonce;
    }

    if (!KERB_IS_DES_ENCRYPTION(Context->SessionKey.keytype))
    {
        Signature->SequenceNumber[0] = (UCHAR) ((*Nonce & 0xff000000) >> 24);
        Signature->SequenceNumber[1] = (UCHAR) ((*Nonce & 0x00ff0000) >> 16);
        Signature->SequenceNumber[2] = (UCHAR) ((*Nonce & 0x0000ff00) >> 8);
        Signature->SequenceNumber[3] = (UCHAR)  (*Nonce & 0x000000ff);
    }
    else
    {
        Signature->SequenceNumber[3] = (UCHAR) ((*Nonce & 0xff000000) >> 24);
        Signature->SequenceNumber[2] = (UCHAR) ((*Nonce & 0x00ff0000) >> 16);
        Signature->SequenceNumber[1] = (UCHAR) ((*Nonce & 0x0000ff00) >> 8);
        Signature->SequenceNumber[0] = (UCHAR)  (*Nonce & 0x000000ff);
    }

    (*Nonce)++;
    *SequenceNumber = *(ULONG UNALIGNED *)Signature->SequenceNumber;

    D_DebugLog((DEB_TRACE_USER,"Makign signature buffer (encrypt = %d) with nonce 0x%x\n",
        Encrypt,
        *SequenceNumber
        ));

    //
    // If we are encrypting, add the confounder to the end of the signature
    //

    if (Encrypt)
    {
        SealSignature = (PKERB_GSS_SEAL_SIGNATURE) Signature;
        KerbRandomFill(
            SealSignature->Confounder,
            KERB_GSS_SIG_CONFOUNDER_SIZE
            );
    }

    //
    // Set the size of the signature
    //

    SignatureBuffer->cbBuffer = SignatureSize;
    *OutputSignature = Signature;

Cleanup:
    return (Status);
}

//+-------------------------------------------------------------------------
//
//  Function:   KerbVerifySignatureToken
//
//  Synopsis:   Verifies the header on a signed or sealed message
//
//  Effects:
//
//  Arguments:  Context - context to use for verification
//              SignatureBuffer - Buffer containing signature
//              TotalBufferSize - Size of all buffers signed/encrypted
//              Decrypt - TRUE if we are unsealing
//              SuppliedNonce - Nonce supplied by caller, used for datagram
//              QualityOfProtection - returns GSS quality of protection flags
//              ChecksumType - Type of checksum used in this signature
//              EncryptionType - Type of encryption used in this signature
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
KerbVerifySignatureToken(
    IN PKERB_CONTEXT Context,
    IN PSecBuffer SignatureBuffer,
    IN ULONG TotalBufferSize,
    IN BOOLEAN Decrypt,
    IN ULONG SuppliedNonce,
    OUT PKERB_GSS_SIGNATURE * OutputSignature,
    OUT PULONG QualityOfProtection,
    OUT PLONG ChecksumType,
    OUT PCRYPTO_SYSTEM * CryptSystem,
    OUT PULONG SequenceNumber
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG SignatureSize = 0;
    UCHAR Nonce[8];
    PCRYPT_STATE_BUFFER CryptBuffer = NULL;
    ULONG OutputSize;
    LONG  EncryptionType = 0;
    PCRYPTO_SYSTEM LocalCryptSystem = NULL ;
    PKERB_GSS_SIGNATURE Signature;
    PULONG ContextNonce;
    gss_OID MechUsed;

    //
    // Since RPC doesn't carry around the size of the size of the
    // signature bufer, we use it in the header. This break rfc1964 compat.
    //

    if (!Decrypt ||
       ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) != 0) ||
       ((Context->ContextFlags & ISC_RET_DATAGRAM) != 0))
    {
        TotalBufferSize = 0;
    }

    //
    // Verify the signature header
    //

    D_DebugLog((DEB_TRACE, "KerbVerifySignatureToken ContextAttributes %#x\n", Context->ContextAttributes));

    if ((Context->ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
    {
        D_DebugLog((DEB_TRACE_U2U, "KerbVerifySignatureToken MechUsed = gss_mech_krb5_u2u\n"));
        MechUsed = gss_mech_krb5_u2u;
    }
    else
    {
        MechUsed = gss_mech_krb5_new;
    }

    Signature = (PKERB_GSS_SIGNATURE) SignatureBuffer->pvBuffer;
    if (!g_verify_token_header(
            MechUsed,
            (INT *) &SignatureSize,
            (PUCHAR *) &Signature,
            (Decrypt ? KG_TOK_WRAP_MSG : KG_TOK_MIC_MSG),
            SignatureBuffer->cbBuffer + TotalBufferSize))
    {
        //Status = SEC_E_MESSAGE_ALTERED; bug 28448
        Status = SEC_E_INVALID_TOKEN;
    }

    //
    // If that didn't work, try with the old mech. Need this is for DCE clients
    // for whom we can't tell what mech they use.
    //

    if (!NT_SUCCESS(Status) && ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) != 0))
    {
        Signature = (PKERB_GSS_SIGNATURE) SignatureBuffer->pvBuffer;
        if (!g_verify_token_header(
                gss_mech_krb5,
                (INT *) &SignatureSize,
                (PUCHAR *) &Signature,
                (Decrypt ? KG_TOK_WRAP_MSG : KG_TOK_MIC_MSG),
                SignatureBuffer->cbBuffer + TotalBufferSize))
        {
           //Status = SEC_E_MESSAGE_ALTERED; bug 28448
           Status = SEC_E_INVALID_TOKEN;
        }
        else
        {
            D_DebugLog((DEB_TRACE, "KerbVerifySignatureToken Signature gss_mech_krb5\n"));
            Status = STATUS_SUCCESS;
        }
    }

    //
    // MS RPC clients don't send the size properly, so set the total size
    // to zero and try again.
    //

    if (Decrypt && !NT_SUCCESS(Status))
    {
        TotalBufferSize = 0;
        Signature = (PKERB_GSS_SIGNATURE) SignatureBuffer->pvBuffer;
        if (!g_verify_token_header(
                MechUsed,
                (INT *) &SignatureSize,
                (PUCHAR *) &Signature,
                (Decrypt ? KG_TOK_WRAP_MSG : KG_TOK_MIC_MSG),
                SignatureBuffer->cbBuffer + TotalBufferSize))
        {
           //Status = SEC_E_MESSAGE_ALTERED; bug 28448
           Status = SEC_E_INVALID_TOKEN;
        }
        else
        {
            D_DebugLog((DEB_TRACE, "KerbVerifySignatureToken Signature MechUsed\n"));
            Status = STATUS_SUCCESS;
        }

        //
        // If that didn't work, try with the old mech. Need this is for DCE clients
        // for whom we can't tell what mech they use.
        //

        if (!NT_SUCCESS(Status) && ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) != 0))
        {
            Signature = (PKERB_GSS_SIGNATURE) SignatureBuffer->pvBuffer;
            if (!g_verify_token_header(
                    gss_mech_krb5,
                    (INT *) &SignatureSize,
                    (PUCHAR *) &Signature,
                    (Decrypt ? KG_TOK_WRAP_MSG : KG_TOK_MIC_MSG),
                    SignatureBuffer->cbBuffer + TotalBufferSize))
            {
               //Status = SEC_E_MESSAGE_ALTERED; bug 28448
               Status = SEC_E_INVALID_TOKEN;
            }
            else
            {
                D_DebugLog((DEB_TRACE, "KerbVerifySignatureToken Signature gss_mech_krb5\n"));
                Status = STATUS_SUCCESS;
            }
        }
    }

    //
    // Protection from bad Signature Size
    //

    if (SignatureSize == 0)
    {
        D_DebugLog((DEB_ERROR, "Bad Signature %ws, %d\n", THIS_FILE, __LINE__));

        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }

    //
    // Subtract the total buffer size from Signature size to get the real
    // size of the signature.
    //

    SignatureSize -= TotalBufferSize;

    //
    // Make sure the signature is big enough. We can't enforce a strict
    // size because RPC will transmit the maximum number of bytes instead
    // of the actual number.
    //

    if ((Decrypt && (SignatureSize < sizeof(KERB_GSS_SEAL_SIGNATURE))) ||
        (!Decrypt && (SignatureSize < sizeof(KERB_GSS_SIGNATURE))))
    {
        //Status = SEC_E_MESSAGE_ALTERED; bug 28448
        Status = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    //
    // Verify the sequence number
    //

    if (Signature->SignatureAlgorithm[1] != KERB_GSS_SIG_SECOND)
    {
        D_DebugLog((DEB_ERROR, "Not KERB_GSS_SIG_SECOND %ws, %d\n", THIS_FILE, __LINE__));
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }
    //
    // Figure out the algorithm
    //

    switch(Context->SessionKey.keytype) {
    case KERB_ETYPE_DES_CBC_MD5:
    case KERB_ETYPE_DES_CBC_CRC:
        EncryptionType = KERB_ETYPE_DES_PLAIN;
        break;
    case KERB_ETYPE_RC4_HMAC_OLD_EXP:
        EncryptionType = KERB_ETYPE_RC4_PLAIN_OLD_EXP;
        break;
    case KERB_ETYPE_RC4_HMAC_OLD:
        EncryptionType = KERB_ETYPE_RC4_PLAIN_OLD;
        break;
    case KERB_ETYPE_RC4_HMAC_NT_EXP:
        EncryptionType = KERB_ETYPE_RC4_PLAIN_EXP;
        break;
    case KERB_ETYPE_RC4_HMAC_NT:
        EncryptionType = KERB_ETYPE_RC4_PLAIN;
        break;
    default:
        DebugLog((DEB_ERROR,"Unknown key type: %d. %ws, %d\n",
           Context->SessionKey.keytype,
           THIS_FILE, __LINE__ ));
        Status = STATUS_INTERNAL_ERROR;
        goto Cleanup;
    }

    //
    // if the key is exportable, make sure to use the exportable plain
    // version.
    //


    switch(Signature->SignatureAlgorithm[0]) {
    case KERB_GSS_SIG_MD25:
        *QualityOfProtection = GSS_KRB5_INTEG_C_QOP_MD5;
        *ChecksumType = KERB_CHECKSUM_MD25;
        break;
    case KERB_GSS_SIG_DES_MAC_MD5:
        *QualityOfProtection = GSS_KRB5_INTEG_C_QOP_DES_MD5;
        *ChecksumType = KERB_CHECKSUM_DES_MAC_MD5;
        break;
    case KERB_GSS_SIG_DES_MAC:
        *QualityOfProtection = GSS_KRB5_INTEG_C_QOP_DES_MAC;
        *ChecksumType = KERB_CHECKSUM_DES_MAC;
        break;
    case KERB_GSS_SIG_HMAC:
        *QualityOfProtection = GSS_KRB5_INTEG_C_QOP_DEFAULT;
        *ChecksumType = KERB_CHECKSUM_HMAC_MD5;
        break;
    default:
        DebugLog((DEB_ERROR,"Invalid signature type to VerifySignature: %d. %ws, line %d\n",
                Signature->SignatureAlgorithm[0], THIS_FILE, __LINE__ ));
        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;

    }

    if (Decrypt)
    {
        if ((Signature->SealAlgorithm[1] == KERB_GSS_NO_SEAL_SECOND) &&
            (Signature->SealAlgorithm[0] == KERB_GSS_NO_SEAL))
        {
            *QualityOfProtection = KERB_WRAP_NO_ENCRYPT;
        }
        else
        {
            if (Signature->SealAlgorithm[1] != KERB_GSS_SIG_SECOND)
            {
                D_DebugLog((DEB_ERROR, "Not KERB_GSS_SIG_SECOND %ws, %d\n", THIS_FILE, __LINE__));
                Status = SEC_E_MESSAGE_ALTERED;

                goto Cleanup;
            }

            //
            // Verify the seal algorithm
            //

            switch(EncryptionType) {
            case KERB_ETYPE_DES_PLAIN:
                if (Signature->SealAlgorithm[0] != KERB_GSS_SEAL_DES_CBC)
                {
                    DebugLog((DEB_ERROR,"Trying to mix encryption types. %ws, line %d\n", THIS_FILE, __LINE__));
                    Status = SEC_E_MESSAGE_ALTERED;
                    goto Cleanup;
                }
                break;
            case KERB_ETYPE_RC4_PLAIN_OLD_EXP:
            case KERB_ETYPE_RC4_PLAIN_OLD:
                if (Signature->SealAlgorithm[0] != KERB_GSS_SEAL_RC4_OLD)
                {
                    DebugLog((DEB_ERROR,"Trying to mix encryption types. %ws, line %d\n", THIS_FILE, __LINE__));
                    Status = SEC_E_MESSAGE_ALTERED;
                    goto Cleanup;
                }
                break;
            case KERB_ETYPE_RC4_PLAIN_EXP:
            case KERB_ETYPE_RC4_PLAIN:
                if (Signature->SealAlgorithm[0] != KERB_GSS_SEAL_RC4)
                {
                    DebugLog((DEB_ERROR, "Trying to mix encryption types. %ws, line %d\n", THIS_FILE, __LINE__));
                    Status = SEC_E_MESSAGE_ALTERED;
                    goto Cleanup;
                }
                break;
            default:
                DebugLog((DEB_ERROR,"Invalid seal type to VerifySignature: %d, %d. %ws, line %d\n",
                        Signature->SealAlgorithm[0], EncryptionType, THIS_FILE, __LINE__ ));
                Status = SEC_E_MESSAGE_ALTERED;
                goto Cleanup;
            }
        }

    }

    //
    // Check the filler
    //

    if ((Decrypt && (*(USHORT UNALIGNED *) Signature->SealFiller != 0xffff)) ||
        (!Decrypt && (*(ULONG UNALIGNED *) Signature->SignFiller != 0xffffffff)))
    {
        D_DebugLog((DEB_ERROR, "Bad filler %ws, %d\n", THIS_FILE, __LINE__));

        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }

    //
    // Verify the sequence number. To do this we need to decrypt it with
    // the session key with the checksum as the IV.
    //


    Status = CDLocateCSystem(EncryptionType, &LocalCryptSystem);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load %d crypt system: 0x%x. %ws, line %d\n",EncryptionType,Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Now we need to Decrypt the sequence number, using the checksum as the
    // IV
    //

    Status = LocalCryptSystem->Initialize(
                Context->SessionKey.keyvalue.value,
                Context->SessionKey.keyvalue.length,
                0,                      // no flags
                &CryptBuffer
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Set the initial vector
    //

    Status = LocalCryptSystem->Control(
                CRYPT_CONTROL_SET_INIT_VECT,
                CryptBuffer,
                Signature->Checksum,
                8
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Now encrypt the sequence number
    //

    OutputSize = 8;

    Status = LocalCryptSystem->Decrypt(
                CryptBuffer,
                Signature->SequenceNumber,
                8,
                Signature->SequenceNumber,
                &OutputSize
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // For datagram or integrity only, we use just the supplied nonce.
    //

    if (((Context->ContextFlags & ISC_RET_DATAGRAM) != 0) ||
        ((Context->ContextFlags & (ISC_RET_INTEGRITY | ISC_RET_SEQUENCE_DETECT | ISC_RET_REPLAY_DETECT)) == ISC_RET_INTEGRITY))
    {
        ContextNonce = &SuppliedNonce;
    }
    else
    {
        ContextNonce = &Context->ReceiveNonce;
    }

    if (!KERB_IS_DES_ENCRYPTION(Context->SessionKey.keytype))
    {
        Nonce[0] = (UCHAR) ((*ContextNonce & 0xff000000) >> 24);
        Nonce[1] = (UCHAR) ((*ContextNonce & 0x00ff0000) >> 16);
        Nonce[2] = (UCHAR) ((*ContextNonce & 0x0000ff00) >> 8);
        Nonce[3] = (UCHAR)      (*ContextNonce & 0x000000ff);
    }
    else
    {
        Nonce[3] = (UCHAR) ((*ContextNonce & 0xff000000) >> 24);
        Nonce[2] = (UCHAR) ((*ContextNonce & 0x00ff0000) >> 16);
        Nonce[1] = (UCHAR) ((*ContextNonce & 0x0000ff00) >> 8);
        Nonce[0] = (UCHAR)      (*ContextNonce & 0x000000ff);
    }

    *SequenceNumber = *(ULONG UNALIGNED *) Nonce;

    D_DebugLog((DEB_TRACE_USER,"Verifying signature buffer (decrypt = %d) with nonce 0x%x, message seq  0x%x\n",
        Decrypt,
        *(ULONG UNALIGNED *) Nonce,
        *(ULONG UNALIGNED *) Signature->SequenceNumber
        ));

    if (!RtlEqualMemory(
            Nonce,
            Signature->SequenceNumber,
            4))
    {
        Status = SEC_E_OUT_OF_SEQUENCE;
        goto Cleanup;
    }

    (*ContextNonce)++;

    //
    // Inbound contexts send a high dword of 0xffffffff, outbound gets
    // 0x00000000.
    //

    if (Context->ContextAttributes & KERB_CONTEXT_OUTBOUND)
    {
        if (*(ULONG UNALIGNED *)(&Signature->SequenceNumber[4]) != 0xffffffff)
        {
            D_DebugLog((DEB_ERROR, "Bad sequence number %ws, %d\n", THIS_FILE, __LINE__));

            Status = SEC_E_MESSAGE_ALTERED;
            goto Cleanup;
        }
    }
    else
    {
        DsysAssert((Context->ContextAttributes & KERB_CONTEXT_INBOUND) != 0);
        if (*(ULONG UNALIGNED *)(&Signature->SequenceNumber[4]) != 0)
        {
            Status = SEC_E_MESSAGE_ALTERED;
            goto Cleanup;
        }
    }

    if (ARGUMENT_PRESENT(CryptSystem))
    {
        *CryptSystem = LocalCryptSystem;
    }

    *OutputSignature = Signature;

Cleanup:
    if ( ( CryptBuffer != NULL ) &&
         ( LocalCryptSystem != NULL ) )
    {
        LocalCryptSystem->Discard(&CryptBuffer);
    }
    return(Status);
}

#define KERB_MAX_CHECKSUM_LENGTH    24
#define KERB_MAX_KEY_LENGTH         24
#define KERB_MAX_BLOCK_LENGTH       24


//+-------------------------------------------------------------------------
//
//  Function:   SpMakeSignature
//
//  Synopsis:   Signs a message buffer by calculatinga checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              QualityOfProtection - Unused flags.
//              MessageBuffers - Contains an array of buffers to sign and
//                      to store the signature.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found.
//              STATUS_BUFFER_TOO_SMALL - the signature buffer is too small
//                      to hold the signature
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpMakeSignature(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber                         
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CONTEXT Context = NULL;
    PCHECKSUM_FUNCTION Check;
    PCRYPTO_SYSTEM CryptSystem = NULL ;
    PSecBuffer SignatureBuffer = NULL;
    ULONG Index;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PCRYPT_STATE_BUFFER CryptBuffer = NULL;
    PKERB_GSS_SIGNATURE Signature;
    UCHAR LocalChecksum[KERB_MAX_CHECKSUM_LENGTH];
    LONG  ChecksumType = 0;
    LONG  EncryptType;
    ULONG TotalBufferSize = 0;
    ULONG OutputSize;
    ULONG SequenceNumber;


    D_DebugLog((DEB_TRACE_API,"SpMakeSignature Called\n"));
    D_DebugLog((DEB_TRACE_USER, "Make Signature handle = 0x%x\n",ContextHandle));

    Status = KerbReferenceContextByLsaHandle(
                ContextHandle,
                FALSE,           // don't unlink
                &Context
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for MakeSignature(0x%x) Status = 0x%x. %ws, line %d\n",
            ContextHandle, Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < MessageBuffers->cBuffers ; Index++ )
    {

        //
        // We can't allow a combination of the two readonly buffer types, or you'll just
        // get READONLY behavior.
        //
        if (( MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY ) &&
            ( MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY_WITH_CHECKSUM ))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "Can't have readonly & readonly_w_checksum\n"));
            goto Cleanup;
        }
               

        if (BUFFERTYPE(MessageBuffers->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            SignatureBuffer = &MessageBuffers->pBuffers[Index];
        }
        else if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY)))

        {
            TotalBufferSize += MessageBuffers->pBuffers[Index].cbBuffer;
        }
    }


    if (SignatureBuffer == NULL)
    {
        DebugLog((DEB_ERROR, "No signature buffer found. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // Verify that the context was created with the integrity bit
    //

    if ((Context->ContextFlags & KERB_SIGN_FLAGS) == 0)
    {
        if (SignatureBuffer->cbBuffer < sizeof(KERB_NULL_SIGNATURE))
        {
            Status = SEC_E_BUFFER_TOO_SMALL;
            goto Cleanup;
        }
        SignatureBuffer->cbBuffer = sizeof(KERB_NULL_SIGNATURE);
        *(PKERB_NULL_SIGNATURE) SignatureBuffer->pvBuffer = 0;

        Status = STATUS_SUCCESS;
        goto Cleanup;

    }

    Status = KerbGetChecksumAndEncryptionType(
                Context,
                QualityOfProtection,
                &ChecksumType,
                &EncryptType
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    Status = KerbMakeSignatureToken(
                Context,
                QualityOfProtection,
                SignatureBuffer,
                TotalBufferSize,
                FALSE,                  // don't encrypt
                MessageSequenceNumber,
                &Signature,
                &SequenceNumber
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Locate the checksum for the context, loading it if necessary from the
    // the crypto support DLL
    //

    Status = CDLocateCheckSum(ChecksumType, &Check);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load %d checksum: 0x%x. %ws, line %d\n",ChecksumType,Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    DsysAssert(Check->CheckSumSize <= sizeof(LocalChecksum));

    Status = CDLocateCSystem(EncryptType, &CryptSystem);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load %d crypt system: 0x%x. %ws, line %d\n",EncryptType,Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Generate a check sum of the message, and store it into the signature
    // buffer.
    //


    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    Context->SessionKey.keyvalue.value,
                    (ULONG) Context->SessionKey.keyvalue.length,
                    NULL,
                    KERB_SAFE_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    Context->SessionKey.keyvalue.value,
                    (ULONG) Context->SessionKey.keyvalue.length,
                    KERB_SAFE_SALT,
                    &CheckBuffer
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Sum in 8 bytes of the signature
    //

    Check->Sum(
        CheckBuffer,
        8,
        ((PUCHAR) Signature) -2
        );

    for (Index = 0; Index < MessageBuffers->cBuffers; Index++ )
    {
        if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY)) &&
            (MessageBuffers->pBuffers[Index].cbBuffer != 0))
        {

            Check->Sum(
                CheckBuffer,
                MessageBuffers->pBuffers[Index].cbBuffer,
                (PBYTE) MessageBuffers->pBuffers[Index].pvBuffer
                );
        }
    }

    (void) Check->Finalize(CheckBuffer, LocalChecksum);


    Status = Check->Finish(&CheckBuffer);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Copy in the first 8 bytes of the checksum
    //

    RtlCopyMemory(
        Signature->Checksum,
        LocalChecksum,
        8
        );

    //
    // Now we need to encrypt the sequence number, using the checksum as the
    // IV
    //

    Status = CryptSystem->Initialize(
                Context->SessionKey.keyvalue.value,
                Context->SessionKey.keyvalue.length,
                0,                                      // no options
                &CryptBuffer
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Set the initial vector
    //

    Status = CryptSystem->Control(
                CRYPT_CONTROL_SET_INIT_VECT,
                CryptBuffer,
                LocalChecksum,
                8
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Now encrypt the sequence number
    //

    Status = CryptSystem->Encrypt(
                CryptBuffer,
                Signature->SequenceNumber,
                8,
                Signature->SequenceNumber,
                &OutputSize
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


Cleanup:
    if ( ( CryptBuffer != NULL) &&
         ( CryptSystem != NULL ) )
    {
        CryptSystem->Discard(&CryptBuffer);
    }

    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }

    D_DebugLog((DEB_TRACE_API, "SpMakeSignature returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}

//+-------------------------------------------------------------------------
//
//  Function:   SpVerifySignature
//
//  Synopsis:   Verifies a signed message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the checksum
//              along with a nonce.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpVerifySignature(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CONTEXT Context = NULL;
    PCHECKSUM_FUNCTION Check;
    PSecBuffer SignatureBuffer = NULL;
    ULONG Index;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PKERB_GSS_SIGNATURE Signature;
    LONG  ChecksumType;
    UCHAR LocalChecksum[KERB_MAX_CHECKSUM_LENGTH];
    ULONG Protection;
    ULONG TotalBufferSize = 0;
    ULONG SequenceNumber;


    D_DebugLog((DEB_TRACE_API,"SpVerifySignature Called\n"));
    D_DebugLog((DEB_TRACE_USER, "Verify Signature handle = 0x%x\n",ContextHandle));

    Status = KerbReferenceContextByLsaHandle(
                ContextHandle,
                FALSE,           // don't unlink
                &Context
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for VerifySignature(0x%x) Status = 0x%x. %ws, line %d\n",
            ContextHandle, Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < MessageBuffers->cBuffers ; Index++ )
    {
        //
        // We can't allow a combination of the two readonly buffer types, or you'll just
        // get READONLY behavior.
        //
        if (( MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY ) &&
            ( MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY_WITH_CHECKSUM ))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "Can't have readonly & readonly_w_checksum\n"));
            goto Cleanup;
        }

        if (BUFFERTYPE(MessageBuffers->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            SignatureBuffer = &MessageBuffers->pBuffers[Index];
        }
        else if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY)))

        {
            TotalBufferSize += MessageBuffers->pBuffers[Index].cbBuffer;
        }
    }


    if (SignatureBuffer == NULL)
    {
        DebugLog((DEB_ERROR, "No signature buffer found. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Also, verify that the context was created with the integrity bit
    //

    if ((Context->ContextFlags & KERB_SIGN_FLAGS) == 0)
    {
        PKERB_NULL_SIGNATURE NullSignature = (PKERB_NULL_SIGNATURE) SignatureBuffer->pvBuffer;

        if (SignatureBuffer->cbBuffer >= sizeof(KERB_NULL_SIGNATURE) &&
            (*NullSignature == 0))
        {
            Status = STATUS_SUCCESS;
        }
        else
        {
            D_DebugLog((DEB_ERROR, "Bad signature %ws, %d\n", THIS_FILE, __LINE__));
            Status = SEC_E_MESSAGE_ALTERED;
        }
        goto Cleanup;

    }

    //
    // Verify the signature header
    //

    Status = KerbVerifySignatureToken(
                 Context,
                 SignatureBuffer,
                 TotalBufferSize,
                 FALSE,                 // don't decrypt
                 MessageSequenceNumber,
                 &Signature,
                 &Protection,
                 &ChecksumType,
                 NULL,                   // don't need crypt system
                 &SequenceNumber
                 );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to verify signature token: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Now compute the checksum and verify it
    //

    Status = CDLocateCheckSum(ChecksumType, &Check);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load MD5 checksum: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    DsysAssert(Check->CheckSumSize  <= sizeof(LocalChecksum));

    //
    // Generate a check sum of the message, and store it into the signature
    // buffer.
    //


    //
    // if available use the Ex2 version for keyed checksums where checksum
    // must be passed in on verification
    //
    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    Context->SessionKey.keyvalue.value,
                    (ULONG) Context->SessionKey.keyvalue.length,
                    Signature->Checksum,
                    KERB_SAFE_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    Context->SessionKey.keyvalue.value,
                    (ULONG) Context->SessionKey.keyvalue.length,
                    KERB_SAFE_SALT,
                    &CheckBuffer
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Sum in 8 bytes of the signature
    //

    Check->Sum(
        CheckBuffer,
        8,
        ((PUCHAR) Signature) -2
        );

    for (Index = 0; Index < MessageBuffers->cBuffers; Index++ )
    {
        if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY)) &&
            (MessageBuffers->pBuffers[Index].cbBuffer != 0))
        {

            Check->Sum(
                CheckBuffer,
                MessageBuffers->pBuffers[Index].cbBuffer,
                (PBYTE) MessageBuffers->pBuffers[Index].pvBuffer
                );
        }
    }

    (void) Check->Finalize(CheckBuffer, LocalChecksum);


    Status = Check->Finish(&CheckBuffer);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (!RtlEqualMemory(
            LocalChecksum,
            Signature->Checksum,
            8))
    {
        D_DebugLog((DEB_ERROR, "Bad checksum %ws, %d\n", THIS_FILE, __LINE__));

        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }
    if (ARGUMENT_PRESENT(QualityOfProtection))
    {
        *QualityOfProtection = Protection;
    }
Cleanup:

    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }

    D_DebugLog((DEB_TRACE_API, "SpVerifySignature returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}

#define STREAM_CIPHER_BLOCKLEN      1

//+-------------------------------------------------------------------------
//
//  Function:   SpSealMessage
//
//  Synopsis:   Seals a message buffer by calculating a checksum over all
//              the non-read only data buffers and encrypting the data, checksum
//              and a sequence number.
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              QualityOfProtection - Unused flags.
//              MessageBuffers - Contains an array of buffers to sign and
//                      to store the signature.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found.
//              STATUS_BUFFER_TOO_SMALL - the signature buffer is too small
//                      to hold the signature
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpSealMessage(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG QualityOfProtection,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CONTEXT Context = NULL;
    PCHECKSUM_FUNCTION Check = NULL ;
    PCRYPTO_SYSTEM CryptSystem = NULL ;
    PSecBuffer SignatureBuffer = NULL;
    ULONG Index;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PCRYPT_STATE_BUFFER CryptBuffer = NULL;
    PKERB_GSS_SEAL_SIGNATURE SealSignature;
    UCHAR LocalChecksum[KERB_MAX_CHECKSUM_LENGTH];
    UCHAR LocalKey[KERB_MAX_KEY_LENGTH];

    UCHAR LocalBlockBuffer[KERB_MAX_BLOCK_LENGTH];
    ULONG BeginBlockSize = 0;
    PBYTE BeginBlockPointer = NULL;
    ULONG EndBlockSize = 0;
    ULONG EncryptBufferSize = 0;
    PBYTE EncryptBuffer = NULL;

    BOOLEAN DoEncryption = TRUE;
    ULONG BlockSize = 1;
    LONG  ChecksumType = 0;
    LONG  EncryptType;
    ULONG TotalBufferSize = 0;
    ULONG OutputSize;
    ULONG ContextAttributes;
    ULONG SequenceNumber;


    D_DebugLog((DEB_TRACE_API,"SpSealMessage Called\n"));
    D_DebugLog((DEB_TRACE_USER, "SealMessage handle = 0x%x\n",ContextHandle));

    Status = KerbReferenceContextByLsaHandle(
                ContextHandle,
                FALSE,           // don't unlink
                &Context
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for SpSealMessage(0x%x) Status = 0x%x. %ws, line %d\n",
            ContextHandle, Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // get the encryption type for the context
    //

    Status = KerbGetChecksumAndEncryptionType(
                Context,
                QualityOfProtection,
                &ChecksumType,
                &EncryptType
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Locate the cryptsystem for the context, loading it if necessary from the
    // the crypto support DLL
    //

    Status = CDLocateCSystem(EncryptType, &CryptSystem);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load %d crypt system: 0x%x. %ws, line %d\n",EncryptType,Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    BlockSize = CryptSystem->BlockSize;

    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < MessageBuffers->cBuffers ; Index++ )
    {

        //
        // We can't allow a combination of the two readonly buffer types, or you'll just
        // get READONLY behavior.
        //
        if (( MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY ) &&
            ( MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY_WITH_CHECKSUM ))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "Can't have readonly & readonly_w_checksum\n"));
            goto Cleanup;
        } 
        
        if (BUFFERTYPE(MessageBuffers->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            SignatureBuffer = &MessageBuffers->pBuffers[Index];
        }
        else if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY )))

        {
            //
            // use real block size from crypt type
            //

            if (BUFFERTYPE(MessageBuffers->pBuffers[Index]) == SECBUFFER_PADDING)
            {
                if (STREAM_CIPHER_BLOCKLEN != BlockSize)
                {
                    TotalBufferSize = ROUND_UP_COUNT(TotalBufferSize+1,BlockSize);
                }
                else
                {
                    //
                    // For stream encryption, only 1 byte of padding
                    //

                    TotalBufferSize += BlockSize;
                }
            }
            else
            {
                TotalBufferSize += MessageBuffers->pBuffers[Index].cbBuffer;
            }

        }
    }


    if (SignatureBuffer == NULL)
    {
        DebugLog((DEB_ERROR, "No signature buffer found. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


    ContextAttributes = Context->ContextAttributes;

    //
    // If we are not encrypting, just wrapping, remember that
    //

    if (QualityOfProtection == KERB_WRAP_NO_ENCRYPT)
    {
        DoEncryption = FALSE;
        //
        // Reset the block size because we are not really encrypting
        //

    }

    //
    // Verify that the context was created with the integrity bit
    //

    if (DoEncryption && ((Context->ContextFlags & ISC_RET_CONFIDENTIALITY) == 0))
    {
        DebugLog((DEB_ERROR,"Trying to seal without asking for confidentiality. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;

    }

    Status = KerbMakeSignatureToken(
                Context,
                QualityOfProtection,
                SignatureBuffer,
                TotalBufferSize,
                TRUE,                  // do encrypt
                MessageSequenceNumber,
                (PKERB_GSS_SIGNATURE *) &SealSignature,
                &SequenceNumber
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Locate the checksum for the context, loading it if necessary from the
    // the crypto support DLL
    //

    Status = CDLocateCheckSum(ChecksumType, &Check);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load %d checksum: 0x%x. %ws, line %d\n",ChecksumType,Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    DsysAssert(Check->CheckSumSize <= sizeof(LocalChecksum));


    //
    // Generate a check sum of the message, and store it into the signature
    // buffer.
    //

    Status = Check->InitializeEx(
                Context->SessionKey.keyvalue.value,
                (ULONG) Context->SessionKey.keyvalue.length,
                KERB_PRIV_SALT,
                &CheckBuffer
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    if (DoEncryption)
    {

        //
        // Create the encryption key by xoring with 0xf0f0f0f0
        //
    
        DsysAssert(Context->SessionKey.keyvalue.length <= sizeof(LocalKey));
        if (Context->SessionKey.keyvalue.length > sizeof(LocalKey))
        {
            Status = SEC_E_UNSUPPORTED_FUNCTION;
            goto Cleanup;
        }
    
    
        for (Index = 0; Index < Context->SessionKey.keyvalue.length  ; Index++ )
        {
            LocalKey[Index] = Context->SessionKey.keyvalue.value[Index] ^ 0xf0;
        }
    
        Status = CryptSystem->Initialize(
                    LocalKey,
                    Context->SessionKey.keyvalue.length,
                    0,                                      // no options
                    &CryptBuffer
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Sum in 8 bytes of the signature
    //

    Check->Sum(
        CheckBuffer,
        8,
        ((PUCHAR) SealSignature) -2
        );

    //
    // Sum the confounder
    //

    Check->Sum(
        CheckBuffer,
        KERB_GSS_SIG_CONFOUNDER_SIZE,
        SealSignature->Confounder
        );

    if (DoEncryption)
    {   
        if ((EncryptType == KERB_ETYPE_RC4_PLAIN) ||
            (EncryptType == KERB_ETYPE_RC4_PLAIN_EXP))
        {
            Status = CryptSystem->Control(
                        CRYPT_CONTROL_SET_INIT_VECT,
                        CryptBuffer,
                        (PUCHAR) &SequenceNumber,
                        sizeof(ULONG)
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }
    
        //
        // Encrypt the 8 confounder bytes
        //
        Status = CryptSystem->Encrypt(
                    CryptBuffer,
                    SealSignature->Confounder,
                    KERB_GSS_SIG_CONFOUNDER_SIZE,
                    SealSignature->Confounder,
                    &OutputSize
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    for (Index = 0; Index < MessageBuffers->cBuffers; Index++ )
    {
        if ((BUFFERTYPE(MessageBuffers->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY )) &&
            (MessageBuffers->pBuffers[Index].cbBuffer != 0))
        {   
            //
            // If the SECBUFFER_READONLY_WITH_CHECKSUM is set, then don't encrypt the buffer, but be sure
            // to checksum it.  This is primarily for consistencies sake...
            //
            if (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY_WITH_CHECKSUM))
            {  
                //      
                // Take into account that the input buffers may not all be aligned
                // properly     
                //                  
                DsysAssert(BeginBlockSize < BlockSize);

                if (BeginBlockSize != 0)
                {
                    //                  
                    // We have a fragment we still need to encrypt
                    //                          

                    EncryptBuffer = (PBYTE) MessageBuffers->pBuffers[Index].pvBuffer +
                        (BlockSize - BeginBlockSize);
                    EncryptBufferSize = MessageBuffers->pBuffers[Index].cbBuffer -
                        (BlockSize - BeginBlockSize);
                }
                else
                {
                //              
                // There is no fragment to encrypt, so try to do the whole
                // buffer               
                //                          

                    EncryptBuffer = (PBYTE) MessageBuffers->pBuffers[Index].pvBuffer;
                    EncryptBufferSize = MessageBuffers->pBuffers[Index].cbBuffer;
                }
                EndBlockSize = EncryptBufferSize - ROUND_DOWN_COUNT(EncryptBufferSize,BlockSize);
                DsysAssert(EndBlockSize < BlockSize);
                EncryptBufferSize = EncryptBufferSize - EndBlockSize;


                //      
                // If this is padding, fill it in with the appropriate data &
                // length       
                //                  
                if (MessageBuffers->pBuffers[Index].BufferType == SECBUFFER_PADDING)
                {
                    if (MessageBuffers->pBuffers[Index].cbBuffer < BlockSize)
                    {
                        DebugLog((DEB_ERROR, "Pad buffer is too small: %d instead of %d. %ws, %d\n",
                                  MessageBuffers->pBuffers[Index].cbBuffer,
                                  BlockSize,
                                  THIS_FILE,
                                  __LINE__
                                  ));
                        Status = STATUS_INVALID_PARAMETER;
                        goto Cleanup;
                    }
                   
                    memset(
                        MessageBuffers->pBuffers[Index].pvBuffer,
                        BlockSize - BeginBlockSize,
                        BlockSize - BeginBlockSize
                        );
                    MessageBuffers->pBuffers[Index].cbBuffer = BlockSize - BeginBlockSize;

                    //      
                    // If there is a fragment, we will encrypt the padding with the fragment.
                    // Otherwise we will do just a padding buffer.
                    //                  
                    if (BeginBlockSize != 0)
                    {
                        EncryptBufferSize = 0;
                    }

                    //      
                    // The padding fixes up the end block.
                    //
                    EndBlockSize = 0;
                }
            }
        
            

            //
            // Checksum the whole buffer. We do this now to get the right amount of
            // padding.
            //              
            Check->Sum(
                CheckBuffer,
                MessageBuffers->pBuffers[Index].cbBuffer,
                (PBYTE) MessageBuffers->pBuffers[Index].pvBuffer
                );


            if (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY_WITH_CHECKSUM))            
            {   
                if (BeginBlockSize != 0)
                {
                    RtlCopyMemory(
                        LocalBlockBuffer+BeginBlockSize,
                        MessageBuffers->pBuffers[Index].pvBuffer,
                        BlockSize - BeginBlockSize
                        );

                    if (DoEncryption)
                    {
                        //              
                        // Now encrypt the buffer
                        //                      
    
                        Status = CryptSystem->Encrypt(
                                                CryptBuffer,
                                                LocalBlockBuffer,
                                                BlockSize,
                                                LocalBlockBuffer,
                                                &OutputSize
                                                );
                        if (!NT_SUCCESS(Status))
                        {
                            goto Cleanup;
                        }
                    }


                    
                    //      
                    // Copy the pieces back
                    //      
                    RtlCopyMemory(
                        BeginBlockPointer,
                        LocalBlockBuffer,
                        BeginBlockSize
                        );

                    RtlCopyMemory(
                        MessageBuffers->pBuffers[Index].pvBuffer,
                        LocalBlockBuffer + BeginBlockSize,
                        BlockSize - BeginBlockSize
                        );
                }

                if (DoEncryption && (EncryptBufferSize != 0))
                {
                    //              
                    // Now encrypt the buffer
                    //                      

                    Status = CryptSystem->Encrypt(
                                CryptBuffer,
                                EncryptBuffer,
                                EncryptBufferSize,
                                EncryptBuffer,
                                &OutputSize
                                );
                    if (!NT_SUCCESS(Status))
                    {
                        goto Cleanup;
                    }

                    DsysAssert(OutputSize == EncryptBufferSize);
                }

                //      
                // Prepare for the next go-round
                //              

                RtlCopyMemory(
                    LocalBlockBuffer,
                    EncryptBuffer+EncryptBufferSize,
                    EndBlockSize
                    );

                BeginBlockSize = EndBlockSize;
                BeginBlockPointer = (PBYTE) MessageBuffers->pBuffers[Index].pvBuffer +
                    MessageBuffers->pBuffers[Index].cbBuffer -
                    EndBlockSize;        
            }
        }
    }

    //
    // Make sure there are no left-over bits
    //

    if (BeginBlockSize != 0)
    {
        DebugLog((DEB_ERROR,"Non-aligned buffer size to SealMessage: %d extra bytes\n",
            BeginBlockSize ));
        Status = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    (void) Check->Finalize(CheckBuffer, LocalChecksum);


    Status = Check->Finish(&CheckBuffer);

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }
    CheckBuffer = NULL;


    //
    // Copy in the first 8 bytes of the checksum
    //

    RtlCopyMemory(
        SealSignature->Signature.Checksum,
        LocalChecksum,
        8
        );

    if (DoEncryption)
    {
        CryptSystem->Discard( &CryptBuffer );
    }

    //
    // Now we need to encrypt the sequence number, using the checksum as the
    // IV
    //

    Status = CryptSystem->Initialize(
                Context->SessionKey.keyvalue.value,
                Context->SessionKey.keyvalue.length,
                0,                                      // no options
                &CryptBuffer
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Set the initial vector
    //
    Status = CryptSystem->Control(
                CRYPT_CONTROL_SET_INIT_VECT,
                CryptBuffer,
                LocalChecksum,
                8
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Now encrypt the sequence number
    //

    Status = CryptSystem->Encrypt(
                CryptBuffer,
                SealSignature->Signature.SequenceNumber,
                8,
                SealSignature->Signature.SequenceNumber,
                &OutputSize
                );
    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


Cleanup:
    if ( ( CryptBuffer != NULL ) &&
         ( CryptSystem != NULL ) )
    {
        CryptSystem->Discard(&CryptBuffer);
    }
    if ( ( CheckBuffer != NULL ) &&
         ( Check != NULL ) )
    {
        Check->Finish(&CheckBuffer);
    }

    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }

    D_DebugLog((DEB_TRACE_API, "SpSealMessage returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}


//+-------------------------------------------------------------------------
//
//  Function:   KerbGetSealMessageBodySize
//
//  Synopsis:   From a input encrypted message, figures out where the
//              body starts
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:    0 on failure, # of bytes of data on success
//
//  Notes:
//
//
//--------------------------------------------------------------------------

ULONG
KerbGetSealMessageBodySize(
    IN OUT PVOID * InputBuffer,
    IN ULONG InputBufferSize
    )
{
   INT BufferSize = (INT) InputBufferSize;
   PBYTE Buffer = (PBYTE) *InputBuffer;
   INT DerBufferSize;
   INT OidLength;

   if ((BufferSize-=1) < 0)
      return(0);
   if (*(Buffer++) != 0x60)
      return(0);

   if ((DerBufferSize = der_read_length(&Buffer, &BufferSize)) < 0)
      return(0);

   if (DerBufferSize != BufferSize)
      return(0);

   if ((BufferSize-=1) < 0)
      return(0);
   if (*(Buffer++) != 0x06)
      return(0);

   if ((BufferSize-=1) < 0)
      return(0);
   OidLength = *(Buffer++);

   if ((OidLength & 0x7fffffff) != OidLength) /* Overflow??? */
      return(0);
   if ((BufferSize-= (int) OidLength) < 0)
      return(0);
   Buffer+=OidLength;


   if ((BufferSize-=2) < 0)
      return(0);
  Buffer += 2;


   //
   // take off size of header
   //

   if ((BufferSize -= sizeof(KERB_GSS_SEAL_SIGNATURE)) < 0)
   {
       return(0);
   }
   Buffer += sizeof(KERB_GSS_SEAL_SIGNATURE);
   *InputBuffer = Buffer;
   return((ULONG) BufferSize);
}


//+-------------------------------------------------------------------------
//
//  Function:   SpUnsealMessage
//
//  Synopsis:   Decrypts & Verifies an encrypted message according to
//              RFC 1964 Unwrap() API description
//
//  Effects:
//
//  Arguments:  ContextHandle - Handle of the context to use to sign the
//                      message.
//              MessageBuffers - Contains an array of signed buffers  and
//                      a signature buffer.
//              MessageSequenceNumber - Sequence number for this message,
//                      only used in datagram cases.
//              QualityOfProtection - Unused flags.
//
//  Requires:   STATUS_INVALID_HANDLE - the context could not be found or
//                      was not configured for message integrity.
//              STATUS_INVALID_PARAMETER - the signature buffer could not
//                      be found or was too small.
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------



NTSTATUS NTAPI
SpUnsealMessage(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc MessageBuffers,
    IN ULONG MessageSequenceNumber,
    OUT PULONG QualityOfProtection
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CONTEXT Context = NULL;
    PCHECKSUM_FUNCTION Check = NULL ;
    PCRYPTO_SYSTEM CryptSystem = NULL ;
    PSecBuffer SignatureBuffer = NULL;
    PSecBuffer StreamBuffer = NULL;
    SecBuffer LocalSignatureBuffer = {0};
    SecBuffer LocalDataBuffer = {0};
    SecBufferDesc LocalBufferDesc = {0};
    PSecBufferDesc BufferList = NULL;
    ULONG Index;
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PCRYPT_STATE_BUFFER CryptBuffer = NULL;
    PKERB_GSS_SEAL_SIGNATURE SealSignature;
    LONG  ChecksumType;
    UCHAR LocalChecksum[KERB_MAX_CHECKSUM_LENGTH];
    UCHAR LocalKey[KERB_MAX_KEY_LENGTH];

    UCHAR LocalBlockBuffer[KERB_MAX_BLOCK_LENGTH];
    ULONG BeginBlockSize = 0;
    PBYTE BeginBlockPointer = NULL;
    ULONG EndBlockSize = 0;
    ULONG EncryptBufferSize;
    PBYTE EncryptBuffer;

    BOOLEAN DoDecryption = TRUE;
    ULONG BlockSize = 1;
    ULONG Protection = 0;
    ULONG TotalBufferSize = 0;
    ULONG OutputSize;
    ULONG ContextAttributes;
    ULONG SequenceNumber;



    D_DebugLog((DEB_TRACE_API,"SpUnsealSignature Called\n"));
    D_DebugLog((DEB_TRACE_USER, "SealMessage handle = 0x%x\n",ContextHandle));

    Status = KerbReferenceContextByLsaHandle(
                ContextHandle,
                FALSE,           // don't unlink
                &Context
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for SpUnsealMessage (0x%x) Status = 0x%x. %ws, line %d\n",
            ContextHandle, Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }


    //
    // Find the body and signature SecBuffers from pMessage
    //

    for (Index = 0; Index < MessageBuffers->cBuffers ; Index++ )
    {
        //
        // We can't allow a combination of the two readonly buffer types, or you'll just
        // get READONLY behavior.
        //
        if (( MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY ) &&
            ( MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY_WITH_CHECKSUM ))
        {
            Status = SEC_E_INVALID_TOKEN;
            DebugLog((DEB_ERROR, "Can't have readonly & readonly_w_checksum\n"));
            goto Cleanup;
        }

        if (BUFFERTYPE(MessageBuffers->pBuffers[Index]) == SECBUFFER_TOKEN)
        {
            SignatureBuffer = &MessageBuffers->pBuffers[Index];
        }
        else if (BUFFERTYPE(MessageBuffers->pBuffers[Index]) == SECBUFFER_STREAM)
        {
            StreamBuffer = &MessageBuffers->pBuffers[Index];

            //
            // The total buffer size is everything in the stream buffer
            //

            TotalBufferSize = MessageBuffers->pBuffers[Index].cbBuffer;
        }
        else if ((MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY) == 0)

        {
            TotalBufferSize += MessageBuffers->pBuffers[Index].cbBuffer;
        }
    }

    //
    // Check for a stream buffer. If it is present, it contains the whole
    // message
    //

    if (StreamBuffer != NULL)
    {
        if (SignatureBuffer != NULL)
        {
            DebugLog((DEB_ERROR,"Both stream and signature buffer present. %ws, line %d\n",THIS_FILE, __LINE__));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Parse the stream to distinguish the header from the body
        //

        LocalSignatureBuffer = *StreamBuffer;
        LocalSignatureBuffer.BufferType = SECBUFFER_TOKEN;
        LocalDataBuffer = *StreamBuffer;
        LocalDataBuffer.BufferType = SECBUFFER_DATA;


        LocalDataBuffer.cbBuffer = KerbGetSealMessageBodySize(
                                    &LocalDataBuffer.pvBuffer,
                                    LocalDataBuffer.cbBuffer
                                    );
        if (LocalDataBuffer.cbBuffer == 0)
        {
            DebugLog((DEB_ERROR,"Failed to find header on stream buffer. %ws %d\n",
                THIS_FILE,__LINE__ ));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
        LocalSignatureBuffer.cbBuffer = StreamBuffer->cbBuffer - LocalDataBuffer.cbBuffer;
        SignatureBuffer = &LocalSignatureBuffer;
        LocalBufferDesc.cBuffers = 1;
        LocalBufferDesc.pBuffers = &LocalDataBuffer;
        BufferList = &LocalBufferDesc;
        //
        // Adjust the total buffer size to remove the signature
        //
        TotalBufferSize -= LocalSignatureBuffer.cbBuffer;

    }
    else if (SignatureBuffer == NULL)
    {
        DebugLog((DEB_ERROR, "No signature buffer found. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    else
    {
        BufferList = MessageBuffers;
    }

    ContextAttributes = Context->ContextAttributes;

    //
    // Verify the signature header
    //

    Status = KerbVerifySignatureToken(
                 Context,
                 SignatureBuffer,
                 TotalBufferSize,
                 TRUE,                  // do decrypt
                 MessageSequenceNumber,
                 (PKERB_GSS_SIGNATURE *) &SealSignature,
                 &Protection,
                 &ChecksumType,
                 &CryptSystem,
                 &SequenceNumber
                 );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Failed to verify signature token: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // If the protection level is no encryption, remember not to do the
    // decryption
    //

    if (Protection == KERB_WRAP_NO_ENCRYPT)
    {
        DoDecryption = FALSE;
    }

    //
    // Also, verify that the context was created with the Confidentiality bit
    //

    if ((DoDecryption && (Context->ContextFlags & ISC_RET_CONFIDENTIALITY) == 0))
    {
        DebugLog((DEB_ERROR,"Tried to decrypt using non-confidential context. %ws, line %d\n", THIS_FILE, __LINE__));
        Status = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;

    }

    BlockSize = CryptSystem->BlockSize;

    //
    // Now compute the checksum and verify it
    //

    Status = CDLocateCheckSum(ChecksumType, &Check);
    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR,"Failed to load MD5 checksum: 0x%x. %ws, line %d\n",Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Create the encryption key by xoring with 0xf0f0f0f0
    //

    DsysAssert(Context->SessionKey.keyvalue.length <= sizeof(LocalKey));
    if (Context->SessionKey.keyvalue.length > sizeof(LocalKey))
    {
        Status = SEC_E_UNSUPPORTED_FUNCTION;
        goto Cleanup;
    }

    //
    // Generate a check sum of the message, and store it into the signature
    // buffer.
    //

    if (NULL != Check->InitializeEx2)
    {
        Status = Check->InitializeEx2(
                    Context->SessionKey.keyvalue.value,
                    (ULONG) Context->SessionKey.keyvalue.length,
                    SealSignature->Signature.Checksum,
                    KERB_PRIV_SALT,
                    &CheckBuffer
                    );
    }
    else
    {
        Status = Check->InitializeEx(
                    Context->SessionKey.keyvalue.value,
                    (ULONG) Context->SessionKey.keyvalue.length,
                    KERB_PRIV_SALT,
                    &CheckBuffer
                    );
    }

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    for (Index = 0; Index < Context->SessionKey.keyvalue.length  ; Index++ )
    {
        LocalKey[Index] = Context->SessionKey.keyvalue.value[Index] ^ 0xf0;
    }
        
    //
    // Sum in 8 bytes of the signature
    //

    Check->Sum(
        CheckBuffer,
        8,
        ((PUCHAR) SealSignature) -2
        );

    if (DoDecryption)
    {
        Status = CryptSystem->Initialize(
                    LocalKey,
                    Context->SessionKey.keyvalue.length,
                    0,                                      // no options
                    &CryptBuffer
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }    

        //
        // Decrypt the confounder
        //
    
        if ((CryptSystem->EncryptionType == KERB_ETYPE_RC4_PLAIN) ||
            (CryptSystem->EncryptionType == KERB_ETYPE_RC4_PLAIN_EXP))
        {
            Status = CryptSystem->Control(
                        CRYPT_CONTROL_SET_INIT_VECT,
                        CryptBuffer,
                        (PUCHAR) &SequenceNumber,
                        sizeof(ULONG)
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }

        OutputSize = KERB_GSS_SIG_CONFOUNDER_SIZE;
        Status = CryptSystem->Decrypt(
                    CryptBuffer,
                    SealSignature->Confounder,
                    KERB_GSS_SIG_CONFOUNDER_SIZE,
                    SealSignature->Confounder,
                    &OutputSize
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }

    //
    // Sum the confounder
    //

    Check->Sum(
        CheckBuffer,
        KERB_GSS_SIG_CONFOUNDER_SIZE,
        SealSignature->Confounder
        );


    for (Index = 0; Index < BufferList->cBuffers; Index++ )
    {
        if ((BUFFERTYPE(BufferList->pBuffers[Index]) != SECBUFFER_TOKEN) &&
            (!(BufferList->pBuffers[Index].BufferType & SECBUFFER_READONLY )) &&
            (BufferList->pBuffers[Index].cbBuffer != 0))
        {   
            if (!(MessageBuffers->pBuffers[Index].BufferType & SECBUFFER_READONLY_WITH_CHECKSUM))
            {
            
                //
                // Take into account that the input buffers may not all be aligned
                // properly
                //
    
                //
                // If there is a fragment to decrypt, convert it to a block
                // size fragment
                //
    
                if (BeginBlockSize != 0)
                {
                    EncryptBuffer = (PBYTE) BufferList->pBuffers[Index].pvBuffer +
                                    (BlockSize - BeginBlockSize);
                    EncryptBufferSize = BufferList->pBuffers[Index].cbBuffer -
                                    (BlockSize - BeginBlockSize);
                }
                else
                {
                    EncryptBuffer = (PBYTE) BufferList->pBuffers[Index].pvBuffer;
                    EncryptBufferSize = BufferList->pBuffers[Index].cbBuffer;
                }
    
                EndBlockSize = EncryptBufferSize - ROUND_DOWN_COUNT(EncryptBufferSize,BlockSize);
                DsysAssert(EndBlockSize < BlockSize);
                EncryptBufferSize = EncryptBufferSize - EndBlockSize;
    
    
                if (BeginBlockSize != 0)
                {
                    RtlCopyMemory(
                        LocalBlockBuffer+BeginBlockSize,
                        BufferList->pBuffers[Index].pvBuffer,
                        BlockSize - BeginBlockSize
                        );
    
                    //
                    // Now decrypt the buffer
                    //
                    if (DoDecryption)
                    {
                        Status = CryptSystem->Decrypt(
                                    CryptBuffer,
                                    LocalBlockBuffer,
                                    BlockSize,
                                    LocalBlockBuffer,
                                    &OutputSize
                                    );
                        if (!NT_SUCCESS(Status))
                        {
                            goto Cleanup;
                        }
                    }
    
                    //
                    // Then checksum the buffer
                    //
    
                    Check->Sum(
                        CheckBuffer,
                        BlockSize,
                        LocalBlockBuffer
                        );
    
                    //
                    // Copy the pieces back
                    //
    
                    RtlCopyMemory(
                        BeginBlockPointer,
                        LocalBlockBuffer,
                        BeginBlockSize
                        );
    
                    RtlCopyMemory(
                        BufferList->pBuffers[Index].pvBuffer,
                        LocalBlockBuffer + BeginBlockSize,
                        BlockSize - BeginBlockSize
                        );
                }
    
                //
                // Decrypt the buffer first
                //
    
                if (DoDecryption)
                {
                    OutputSize = BufferList->pBuffers[Index].cbBuffer;
                    Status = CryptSystem->Decrypt(
                                CryptBuffer,
                                EncryptBuffer,
                                EncryptBufferSize,
                                EncryptBuffer,
                                &OutputSize
                                );
                    if (!NT_SUCCESS(Status))
                    {
                        goto Cleanup;
                    }
    
                    // DsysAssert(OutputSize == BufferList->pBuffers[Index].cbBuffer);
                }
    
                //
                // Prepare for the next go-round
                //
    
                RtlCopyMemory(
                    LocalBlockBuffer,
                    EncryptBuffer+EncryptBufferSize,
                    EndBlockSize
                    );
                BeginBlockSize = EndBlockSize;
                BeginBlockPointer = (PBYTE) MessageBuffers->pBuffers[Index].pvBuffer +
                                      MessageBuffers->pBuffers[Index].cbBuffer -
                                      EndBlockSize;

            
            }
            else
            {
                //
                // Just include the checksum of this buffer, its READONLY_WITH_CHECKSUM.
                //
                EncryptBuffer = (PBYTE) BufferList->pBuffers[Index].pvBuffer;
                EncryptBufferSize = BufferList->pBuffers[Index].cbBuffer;
            }

            //
            // Then checksum the buffer
            //
            Check->Sum(
                CheckBuffer,
                EncryptBufferSize,
                EncryptBuffer
                );
        }
    }

    (void) Check->Finalize(CheckBuffer, LocalChecksum);

    Status = Check->Finish(&CheckBuffer);
    CheckBuffer = NULL;

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Make sure there are no left-over bits
    //

    if (BeginBlockSize != 0)
    {
        DebugLog((DEB_ERROR,"Non-aligned buffer size to SealMessage: %d extra bytes\n",
            BeginBlockSize ));
        Status = SEC_E_INVALID_TOKEN;
        goto Cleanup;
    }

    if (!RtlEqualMemory(
            LocalChecksum,
            SealSignature->Signature.Checksum,
            8))
    {
        D_DebugLog((DEB_ERROR, "Bad checksum %ws, %d\n", THIS_FILE, __LINE__));

        Status = SEC_E_MESSAGE_ALTERED;
        goto Cleanup;
    }
    if (ARGUMENT_PRESENT(QualityOfProtection))
    {
        *QualityOfProtection = Protection;
    }

    //
    // If this was a stream input, return the data in the data buffer
    //

    if (StreamBuffer != NULL)
    {
        BYTE PaddingBytes;

        //
        // Pull the padding off the data buffer
        //

        if (LocalDataBuffer.cbBuffer < 1)
        {
            DebugLog((DEB_ERROR,"Data buffer is zero length!\n"));
            Status = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }

        PaddingBytes = *(((PBYTE)LocalDataBuffer.pvBuffer) + LocalDataBuffer.cbBuffer - 1 );

        //
        // Verify the padding:
        //

        if ((BlockSize >= PaddingBytes) &&
            (LocalDataBuffer.cbBuffer >= PaddingBytes))
        {

            LocalDataBuffer.cbBuffer -= PaddingBytes;
            for (Index = 0; Index < MessageBuffers->cBuffers; Index++ )
            {
                if (BUFFERTYPE(MessageBuffers->pBuffers[Index]) == SECBUFFER_DATA)
                {
                    MessageBuffers->pBuffers[Index] = LocalDataBuffer;
                    break;
                }
            }
        }
        else
        {
            DebugLog((DEB_ERROR,"Bad padding: %d bytes\n", PaddingBytes));
            Status = STATUS_INVALID_PARAMETER;
        }
    }

Cleanup:

    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }
    if ( ( CheckBuffer != NULL ) &&
         ( Check != NULL ) )
    {
        Check->Finish(&CheckBuffer);
    }
    if ( ( CryptBuffer != NULL ) &&
         ( CryptSystem != NULL ) )
    {
        CryptSystem->Discard(&CryptBuffer);
    }

    D_DebugLog((DEB_TRACE_API, "SpUnsealMessage returned 0x%x\n", KerbMapKerbNtStatusToNtStatus(Status)));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}


#ifndef WIN32_CHICAGO
//+-------------------------------------------------------------------------
//
//  Function:   SpGetContextToken
//
//  Synopsis:   returns a pointer to the token for a server-side context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpGetContextToken(
    IN LSA_SEC_HANDLE ContextHandle,
    OUT PHANDLE ImpersonationToken
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CONTEXT Context = NULL;
    LARGE_INTEGER CurrentTime;
    LARGE_INTEGER ContextExpires;


    D_DebugLog((DEB_TRACE_API,"SpGetContextToken called pid:0x%x, ctxt:0x%x\n", GetCurrentProcessId(), ContextHandle));

    if (ImpersonationToken == NULL)
    {
        Status = STATUS_INVALID_PARAMETER;
        DebugLog((DEB_ERROR, "Null token handle supplied for GetContextToken. %ws, line %d\n", THIS_FILE, __LINE__));
        goto Cleanup;
    }

    Status = KerbReferenceContextByLsaHandle(
                ContextHandle,
                FALSE,           // don't unlink
                &Context
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for GetContextToken(0x%x) Status = 0x%x. %ws, line %d\n",
            ContextHandle, Status, THIS_FILE, __LINE__));
    }

    GetSystemTimeAsFileTime((PFILETIME) &CurrentTime);

    KerbReadLockContexts();
    *ImpersonationToken = Context->TokenHandle;
    ContextExpires = Context->Lifetime;
    KerbUnlockContexts();

    if (KerbGlobalEnforceTime && ContextExpires.QuadPart < CurrentTime.QuadPart)
    {
        DebugLog((DEB_ERROR, "GetContextToken: Context 0x%x expired. %ws, line %d\n", ContextHandle, THIS_FILE, __LINE__));
        Status = SEC_E_CONTEXT_EXPIRED;
        *ImpersonationToken = NULL;
    }
    else if (*ImpersonationToken == NULL)
    {
        Status = SEC_E_NO_IMPERSONATION;
    }

    if (Context != NULL)
    {
        //
        // Note: once we dereference the context the handle we return
        // may go away or be re-used. That is the price we have to pay
        // to avoid duplicating it.
        //

        KerbDereferenceContext(Context);
    }

Cleanup:
    D_DebugLog((DEB_TRACE_API,"SpGetContextToken returned 0x%x, pid:0x%x, ctxt:0x%x\n", KerbMapKerbNtStatusToNtStatus(Status), GetCurrentProcessId(), ContextHandle));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}
#endif // WIN32_CHICAGO

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpQueryContextAttributes(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN OUT PVOID Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CONTEXT Context = NULL;
    PSecPkgContext_Sizes SizeInfo;
    PSecPkgContext_Names NameInfo;
    PSecPkgContext_DceInfo DceInfo;
    PSecPkgContext_Lifespan LifespanInfo;
    PSecPkgContext_Flags FlagsInfo;
    PSecPkgContext_PackageInfo PackageInfo;
    PSecPkgContext_NegotiationInfo NegInfo ;
    PSecPkgContext_SessionKey  SessionKeyInfo;
    PSecPkgContext_KeyInfo KeyInfo;
    PSecPkgContext_AccessToken AccessToken;
    PSecPkgContext_TargetInformation TargetInformation;
    ULONG PackageInfoSize = 0;
    UNICODE_STRING FullName;
    LONG  ChecksumType;
    LONG  EncryptType;
    PCRYPTO_SYSTEM CryptSystem = NULL ;
    TimeStamp CurrentTime;

    D_DebugLog((DEB_TRACE_API,"SpQueryContextAttributes called pid:0x%x, ctxt:0x%x, Attr:0x%x\n", GetCurrentProcessId(), ContextHandle, ContextAttribute));

    Status = KerbReferenceContextByLsaHandle(
                ContextHandle,
                FALSE,           // don't unlink
                &Context
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for QueryContextAttributes(0x%x) Status = 0x%x. %ws, line %d\n",
            ContextHandle, Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Return the appropriate information
    //

    switch(ContextAttribute)
    {
    case SECPKG_ATTR_SIZES:
        gss_OID_desc * MechId;
        UINT MessageSize;

        if ((Context->ContextAttributes & KERB_CONTEXT_USER_TO_USER) != 0)
        {
            MechId = gss_mech_krb5_u2u;
        }
        else
        {
            MechId = gss_mech_krb5_new;
        }

        //
        // The sizes returned are used by RPC to determine whether to call
        // MakeSignature or SealMessage. The signature size should be zero
        // if neither is to be called, and the block size and trailer size
        // should be zero if SignMessage is not to be called.
        //

        SizeInfo = (PSecPkgContext_Sizes) Buffer;
        SizeInfo->cbMaxToken = KerbGlobalMaxTokenSize;

        // If we need to be Gss Compatible, then the Signature buffer size is
        // dependent on the message size. So, we'll set it to be largest pad
        // for the largest message size, say 1G. But, don't tax dce style
        // callers with extra bytes.


        if (((Context->ContextFlags & ISC_RET_DATAGRAM) != 0) ||
            ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) != 0))
        {
            MessageSize = 0;
        }
        else
        {
            MessageSize = KERB_MAX_MESSAGE_SIZE;
        }

        if ((Context->ContextFlags & (KERB_SIGN_FLAGS | ISC_RET_CONFIDENTIALITY)) != 0)
        {
              SizeInfo->cbMaxSignature = g_token_size(MechId, sizeof(KERB_GSS_SIGNATURE));
        }
        else
        {
            SizeInfo->cbMaxSignature = sizeof(KERB_NULL_SIGNATURE);
        }

        //
        // get the encryption type for the context
        //

        Status = KerbGetChecksumAndEncryptionType(
                    Context,
                    KERB_WRAP_NO_ENCRYPT,   // checksum not needed so use hardcoded QOP
                    &ChecksumType,          // checksum not needed here
                    &EncryptType
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        //
        // Locate the cryptsystem for the context, loading it if necessary from the
        // the crypto support DLL
        //

        Status = CDLocateCSystem(EncryptType, &CryptSystem);
        if (!NT_SUCCESS(Status))
        {
            DebugLog((DEB_ERROR,"Failed to load %d crypt system: 0x%x. %ws, line %d\n",EncryptType,Status, THIS_FILE, __LINE__));
            goto Cleanup;
        }

        //
        // RPC keys off the trailer size to tell whether or not
        // to encrypt, not the flags from isc/asc. So, for dce style,
        // say the blocksize & trailersize are zero.
        //
        if (((Context->ContextFlags & ISC_RET_CONFIDENTIALITY) != 0) ||
            ((Context->ContextFlags & ISC_RET_USED_DCE_STYLE) == 0))
        {
            //
            // Use block size from crypto system
            //

            SizeInfo->cbBlockSize = CryptSystem->BlockSize;
            SizeInfo->cbSecurityTrailer =
                g_token_size(MechId, sizeof(KERB_GSS_SEAL_SIGNATURE) + MessageSize) - MessageSize;
        }
        else
        {

            SizeInfo->cbBlockSize = 0;
            SizeInfo->cbSecurityTrailer = 0;
        }
        break;
    case SECPKG_ATTR_SESSION_KEY:

           SessionKeyInfo = (PSecPkgContext_SessionKey) Buffer;
           SessionKeyInfo->SessionKeyLength = Context->SessionKey.keyvalue.length;
           if (SessionKeyInfo->SessionKeyLength != 0)
           {
               SessionKeyInfo->SessionKey = (PUCHAR)
                                         UserFunctions->AllocateHeap(
                                                         SessionKeyInfo->SessionKeyLength);
               if (SessionKeyInfo->SessionKey!=NULL)
               {
                   RtlCopyMemory(
                       SessionKeyInfo->SessionKey,
                       Context->SessionKey.keyvalue.value,
                       Context->SessionKey.keyvalue.length
                       );
               }
               else
               {
                  Status = STATUS_INSUFFICIENT_RESOURCES;
               }
           }
           else
           {
               SessionKeyInfo->SessionKey = (PUCHAR) UserFunctions->AllocateHeap(1);
               if (SessionKeyInfo->SessionKey!=NULL)
               {
                   *(PUCHAR) SessionKeyInfo->SessionKey = 0;
               }
               else
               {
                   Status = STATUS_INSUFFICIENT_RESOURCES;
               }
            }
        

        break;


    case SECPKG_ATTR_NAMES:
        NameInfo = (PSecPkgContext_Names) Buffer;
        if (!KERB_SUCCESS(KerbBuildFullServiceName(
                &Context->ClientRealm,
                &Context->ClientName,
                &FullName
                )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

#ifndef WIN32_CHICAGO
        NameInfo->sUserName = (LPWSTR) UserFunctions->AllocateHeap(FullName.Length + sizeof(WCHAR));
        if (NameInfo->sUserName != NULL)
        {
            RtlCopyMemory(
                NameInfo->sUserName,
                FullName.Buffer,
                FullName.Length
                );
            NameInfo->sUserName[FullName.Length/sizeof(WCHAR)] = L'\0';

        }
#else // WIN32_CHICAGO
        ANSI_STRING AnsiString;

        RtlUnicodeStringToAnsiString( &AnsiString,
                                      &FullName,
                                      TRUE);

        NameInfo->sUserName = (LPTSTR) UserFunctions->AllocateHeap(AnsiString.Length + sizeof(CHAR));
        if (NameInfo->sUserName != NULL)
        {
            RtlCopyMemory(
                NameInfo->sUserName,
                AnsiString.Buffer,
                AnsiString.Length
                );
            NameInfo->sUserName[AnsiString.Length] = '\0';

            RtlFreeAnsiString(&AnsiString);
        }
#endif // WIN32_CHICAGO
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        KerbFreeString(&FullName);

        break;
    case SECPKG_ATTR_DCE_INFO:
        DceInfo = (PSecPkgContext_DceInfo) Buffer;
        if (!KERB_SUCCESS(KerbBuildFullServiceName(
                &Context->ClientRealm,
                &Context->ClientName,
                &FullName
                )))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        DceInfo->AuthzSvc = RPC_C_AUTHZ_NAME;

#ifndef WIN32_CHICAGO
        DceInfo->pPac = UserFunctions->AllocateHeap(FullName.Length + sizeof(WCHAR));
        if (DceInfo->pPac != NULL)
        {
            RtlCopyMemory(
                DceInfo->pPac,
                FullName.Buffer,
                FullName.Length
                );
            ((LPWSTR)DceInfo->pPac)[FullName.Length/sizeof(WCHAR)] = L'\0';

        }
#else // WIN32_CHICAGO

        RtlUnicodeStringToAnsiString( &AnsiString,
                                      &FullName,
                                      TRUE);

        DceInfo->pPac = UserFunctions->AllocateHeap(AnsiString.Length + sizeof(CHAR));
        if (DceInfo->pPac != NULL)
        {
            RtlCopyMemory(
                DceInfo->pPac,
                AnsiString.Buffer,
                AnsiString.Length
                );
            ((LPTSTR) DceInfo->pPac)[AnsiString.Length] = '\0';

            RtlFreeAnsiString(&AnsiString);
        }
#endif // WIN32_CHICAGO
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        KerbFreeString(&FullName);

        break;

    case SECPKG_ATTR_TARGET_INFORMATION:
    {
        TargetInformation = (PSecPkgContext_TargetInformation) Buffer;

        if (TargetInformation == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        TargetInformation->MarshalledTargetInfo = NULL;

        if (Context->pbMarshalledTargetInfo == NULL)
        {
            TargetInformation->MarshalledTargetInfo = NULL;
            TargetInformation->MarshalledTargetInfoLength = 0;
            break;
        }

        TargetInformation->MarshalledTargetInfo = (PUCHAR) UserFunctions->AllocateHeap(
                                                                    Context->cbMarshalledTargetInfo
                                                                    );

        if (TargetInformation->MarshalledTargetInfo != NULL)
        {
            RtlCopyMemory(
                TargetInformation->MarshalledTargetInfo,
                Context->pbMarshalledTargetInfo,
                Context->cbMarshalledTargetInfo
                );

            TargetInformation->MarshalledTargetInfoLength = Context->cbMarshalledTargetInfo;
        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }

        break;
    }

    case SECPKG_ATTR_LIFESPAN:
        LifespanInfo = (PSecPkgContext_Lifespan) Buffer;

        if (KerbGetTime(Context->StartTime) != KerbGetTime(KerbGlobalHasNeverTime))
        {
           KerbUtcTimeToLocalTime(
              &LifespanInfo->tsStart,
              &(Context->StartTime)
              );

           D_DebugLog((DEB_TRACE, "Used context start time \n"));
        }
        else if (NULL != Context->TicketCacheEntry)
        {
           KerbUtcTimeToLocalTime(
              &LifespanInfo->tsStart,
              &(Context->TicketCacheEntry->StartTime)
              );

           KerbWriteLockContexts();
           Context->StartTime = Context->TicketCacheEntry->StartTime;
           KerbUnlockContexts();

           DebugLog((DEB_ERROR, "Used tkt cache entry start time \n"));

        }
        else  // set it to current time
        {
           // The context is not in a state where we've got a
           // tkt cache entry, so let's use current time.
           GetSystemTimeAsFileTime((PFILETIME)
                                   &CurrentTime
                                   );

           KerbUtcTimeToLocalTime(
              &LifespanInfo->tsStart,
              &CurrentTime
              );

           DebugLog((DEB_ERROR, "NO START TIME PRESENT IN CONTEXT, or CACHE ENTRY!\n"));
        }

        KerbUtcTimeToLocalTime(
            &LifespanInfo->tsExpiry,
            &Context->Lifetime
            );

        break;
    case SECPKG_ATTR_FLAGS:
        FlagsInfo = (PSecPkgContext_Flags) Buffer;

        if ((Context->ContextAttributes & KERB_CONTEXT_INBOUND) != 0)
        {
            FlagsInfo->Flags = KerbMapContextFlags( Context->ContextFlags );
        }
        else
        {
            FlagsInfo->Flags = Context->ContextFlags;
        }
        break;
#ifndef WIN32_CHICAGO
    case SECPKG_ATTR_KEY_INFO:
        PCRYPTO_SYSTEM CryptoSystem;
        KeyInfo = (PSecPkgContext_KeyInfo) Buffer;

        KeyInfo->KeySize = KerbIsKeyExportable(&Context->SessionKey) ? 56 : 128;
        KeyInfo->EncryptAlgorithm = Context->SessionKey.keytype;
        KeyInfo->SignatureAlgorithm = KERB_IS_DES_ENCRYPTION(Context->SessionKey.keytype) ? KERB_CHECKSUM_MD25 : KERB_CHECKSUM_HMAC_MD5;
        KeyInfo->sSignatureAlgorithmName = NULL;
        KeyInfo->sEncryptAlgorithmName = NULL;

        //
        // The checksum doesn't include a name, so don't fill it in - leave
        // it as an empty string, so callers don't die when they
        // try to manipulate it.
        //

        Status = CDLocateCSystem(KeyInfo->EncryptAlgorithm, &CryptoSystem);
        if (NT_SUCCESS(Status))
        {
            KeyInfo->sEncryptAlgorithmName = (LPWSTR)
                UserFunctions->AllocateHeap(sizeof(WCHAR) * ((ULONG) wcslen(CryptoSystem->Name) + 1));
            if (KeyInfo->sEncryptAlgorithmName != NULL)
            {
                wcscpy(
                    KeyInfo->sEncryptAlgorithmName,
                    CryptoSystem->Name
                    );
                KeyInfo->sSignatureAlgorithmName = (LPWSTR)
                    UserFunctions->AllocateHeap(sizeof(WCHAR));

                if (KeyInfo->sSignatureAlgorithmName != NULL)
                {
                    *KeyInfo->sSignatureAlgorithmName = L'\0';
                }
                else
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    UserFunctions->FreeHeap(KeyInfo->sEncryptAlgorithmName);
                    KeyInfo->sEncryptAlgorithmName = NULL;

                }
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        break;
#endif // WIN32_CHICAGO
    case SECPKG_ATTR_PACKAGE_INFO:
    case SECPKG_ATTR_NEGOTIATION_INFO:
        //
        // Return the information about this package. This is useful for
        // callers who used SPNEGO and don't know what package they got.
        //

        PackageInfo = (PSecPkgContext_PackageInfo) Buffer;
        PackageInfoSize = sizeof(SecPkgInfo) + sizeof(KERBEROS_PACKAGE_NAME) + sizeof(KERBEROS_PACKAGE_COMMENT);
        PackageInfo->PackageInfo = (PSecPkgInfo) UserFunctions->AllocateHeap(PackageInfoSize);
        if (PackageInfo->PackageInfo == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        PackageInfo->PackageInfo->Name = (LPTSTR) (PackageInfo->PackageInfo + 1);
        PackageInfo->PackageInfo->Comment = (LPTSTR) (((PBYTE) PackageInfo->PackageInfo->Name) + sizeof(KERBEROS_PACKAGE_NAME));
        lstrcpy(
            PackageInfo->PackageInfo->Name,
            KERBEROS_PACKAGE_NAME
            );

        lstrcpy(
            PackageInfo->PackageInfo->Comment,
            KERBEROS_PACKAGE_COMMENT
            );
        PackageInfo->PackageInfo->wVersion      = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
        PackageInfo->PackageInfo->wRPCID        = RPC_C_AUTHN_GSS_KERBEROS;
        PackageInfo->PackageInfo->fCapabilities = KERBEROS_CAPABILITIES;
        PackageInfo->PackageInfo->cbMaxToken    = KerbGlobalMaxTokenSize;
        if ( ContextAttribute == SECPKG_ATTR_NEGOTIATION_INFO )
        {
            NegInfo = (PSecPkgContext_NegotiationInfo) PackageInfo ;
            NegInfo->NegotiationState = Context->NegotiationInfo ;
        }
        break;

    case SECPKG_ATTR_ACCESS_TOKEN:
    {
        AccessToken = (PSecPkgContext_AccessToken) Buffer;
        //
        // ClientTokenHandle can be NULL, for instance:
        // 1. client side context.
        // 2. incomplete server context.
        //
        AccessToken->AccessToken = (void*)Context->TokenHandle;
        break;
    }

    default:
        Status = STATUS_NOT_SUPPORTED;
        break;
    }

Cleanup:
    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }

    D_DebugLog((DEB_TRACE_API,"SpQueryContextAttributes returned 0x%x, pid:0x%x, ctxt:0x%x, Attr:0x%x\n", KerbMapKerbNtStatusToNtStatus(Status), GetCurrentProcessId(), ContextHandle, ContextAttribute));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}

//+-------------------------------------------------------------------------
//
//  Function:   SpQueryLsaModeContextAttributes
//
//  Synopsis:   Querys attributes of the specified context
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpQueryLsaModeContextAttributes(
    IN LSA_SEC_HANDLE ContextHandle,
    IN ULONG ContextAttribute,
    IN OUT PVOID Buffer
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PKERB_CONTEXT Context = NULL;
    SecPkgContext_NativeNames NameInfo = {0};
    BOOLEAN ContextsLocked = FALSE;
    UNICODE_STRING ServerName = {0};
    UNICODE_STRING ClientName = {0};
    BOOLEAN IsClientContext = FALSE;
    BOOLEAN TicketCacheLocked = FALSE;

    SecPkgContext_NegotiationInfo NegInfo = {0};
    ULONG PackageInfoSize;

    D_DebugLog((DEB_TRACE_API,"SpQueryLsaModeContextAttributes called ctxt:0x%x, Attr:0x%x\n", ContextHandle, ContextAttribute));

    Status = KerbReferenceContext(
                ContextHandle,
                FALSE,           // don't unlink
                &Context
                );

    if (!NT_SUCCESS(Status))
    {
        DebugLog((DEB_ERROR, "Invalid handle supplied for QueryContextAttributes(0x%x) Status = 0x%x. %ws, line %d\n",
            ContextHandle, Status, THIS_FILE, __LINE__));
        goto Cleanup;
    }

    //
    // Ticket cache lock must be acquired prior to context lock according
    // to the documented locking order; it is going to be needed for SECPKG_ATTR_NATIVE_NAMES,
    // so grab it here to avoid a deadlock
    //

    if ( ContextAttribute == SECPKG_ATTR_NATIVE_NAMES )
    {
        KerbReadLockTicketCache();
        TicketCacheLocked = TRUE;
    }

    KerbReadLockContexts();
    ContextsLocked = TRUE;

    //
    // Return the appropriate information
    //

    switch(ContextAttribute)
    {

    case SECPKG_ATTR_NATIVE_NAMES:

        //
        // Get outbound names from the ticket
        //

        if (Context->ContextAttributes & KERB_CONTEXT_OUTBOUND)
        {
            IsClientContext = TRUE;
            if (Context->TicketCacheEntry != NULL)
            {
                KERBERR KerbErr = KDC_ERR_NONE;

                KerbErr = KerbConvertKdcNameToString(
                            &ServerName,
                            Context->TicketCacheEntry->ServiceName,
                            &Context->TicketCacheEntry->DomainName
                            );

                if (KERB_SUCCESS(KerbErr))
                {
                    KerbErr = KerbConvertKdcNameToString(
                                &ClientName,
                                Context->TicketCacheEntry->ClientName,
                                &Context->TicketCacheEntry->ClientDomainName
                                );
                }

                if (!KERB_SUCCESS(KerbErr))
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Cleanup;
                }
            }
            else
            {
                //
                // We couldn't find the names, so return an error
                //

                Status = STATUS_OBJECT_NAME_NOT_FOUND;
                goto Cleanup;
            }
        }
        else
        {
            //
            // We have a server context
            //

            ClientName = Context->ClientPrincipalName;
            ServerName = Context->ServerPrincipalName;
        }

        if (ServerName.Length != 0)
        {
            Status = LsaFunctions->AllocateClientBuffer(
                        NULL,
                        ServerName.Length + sizeof(WCHAR),
                        (PVOID *) &NameInfo.sServerName
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
            Status = LsaFunctions->CopyToClientBuffer(
                        NULL,
                        ServerName.Length + sizeof(WCHAR),
                        NameInfo.sServerName,
                        ServerName.Buffer
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }

        if (ClientName.Length != 0)
        {
            Status = LsaFunctions->AllocateClientBuffer(
                        NULL,
                        ClientName.Length + sizeof(WCHAR),
                        (PVOID *) &NameInfo.sClientName
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
            Status = LsaFunctions->CopyToClientBuffer(
                        NULL,
                        ClientName.Length + sizeof(WCHAR),
                        NameInfo.sClientName,
                        ClientName.Buffer
                        );
            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }

        //
        // Copy the whole structure
        //

#if _WIN64

        SECPKG_CALL_INFO CallInfo;

        if (!LsaFunctions->GetCallInfo(&CallInfo))
        {
            Status = STATUS_INTERNAL_ERROR;
            goto Cleanup;
        }

        if (CallInfo.Attributes & SECPKG_CALL_WOWCLIENT)
        {
            SecPkgContext_NativeNamesW_WOW64 NameInfoWOW64;

            NameInfoWOW64.sServerName = PtrToUlong(NameInfo.sServerName);
            NameInfoWOW64.sClientName = PtrToUlong(NameInfo.sClientName);

            Status = LsaFunctions->CopyToClientBuffer(
                        NULL,
                        sizeof(SecPkgContext_NativeNamesW_WOW64),
                        Buffer,
                        &NameInfoWOW64
                        );
        }
        else
        {

#endif // _WIN64

            Status = LsaFunctions->CopyToClientBuffer(
                        NULL,
                        sizeof(SecPkgContext_NativeNames),
                        Buffer,
                        &NameInfo
                        );

#if _WIN64

        }

#endif // _WIN64

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        break;

        case SECPKG_ATTR_NEGOTIATION_INFO:
        {
            PSecPkgInfo PackageInfo = NULL;
            SecPkgInfo  TmpInfo = {0};
            ULONG       Offset = sizeof(SecPkgInfo);

            PackageInfoSize = sizeof(SecPkgInfo) +
                                ROUND_UP_COUNT(sizeof(KERBEROS_PACKAGE_NAME), ALIGN_LPTSTR) +
                                ROUND_UP_COUNT(sizeof(KERBEROS_PACKAGE_COMMENT), ALIGN_LPTSTR);

            Status = LsaFunctions->AllocateClientBuffer(
                                        NULL,
                                        PackageInfoSize,
                                        (PVOID *) &PackageInfo
                                        );


            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }


            TmpInfo.Name = (SEC_WCHAR*) RtlOffsetToPointer(
                                                        PackageInfo,
                                                        Offset
                                                        );

            Status = LsaFunctions->CopyToClientBuffer(
                                        NULL,
                                        sizeof(KERBEROS_PACKAGE_NAME),
                                        TmpInfo.Name,
                                        KERBEROS_PACKAGE_NAME
                                        );

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }

            Offset += ROUND_UP_COUNT(sizeof(KERBEROS_PACKAGE_NAME), ALIGN_LPTSTR);

            TmpInfo.Comment = (SEC_WCHAR*) RtlOffsetToPointer(
                                                          PackageInfo,
                                                          Offset
                                                          );

            Status = LsaFunctions->CopyToClientBuffer(
                                        NULL,
                                        sizeof(KERBEROS_PACKAGE_COMMENT),
                                        TmpInfo.Comment,
                                        KERBEROS_PACKAGE_COMMENT
                                        );

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }



            TmpInfo.wVersion      = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
            TmpInfo.wRPCID        = RPC_C_AUTHN_GSS_KERBEROS;
            TmpInfo.fCapabilities = KERBEROS_CAPABILITIES;
            TmpInfo.cbMaxToken    = KerbGlobalMaxTokenSize;

            Status = LsaFunctions->CopyToClientBuffer(
                                        NULL,
                                        sizeof(SecPkgInfo),
                                        PackageInfo,
                                        &TmpInfo
                                        );

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }


            NegInfo.PackageInfo        = PackageInfo;
            NegInfo.NegotiationState   = Context->NegotiationInfo;

            Status = LsaFunctions->CopyToClientBuffer(
                                        NULL,
                                        sizeof(SecPkgContext_NegotiationInfo),
                                        Buffer,
                                        &NegInfo
                                        );

            if (!NT_SUCCESS(Status))
            {
                goto Cleanup;
            }
        }

        break;

    default:
        Status = STATUS_NOT_SUPPORTED;
        break;
    }

Cleanup:

    if (TicketCacheLocked)
    {
        KerbUnlockTicketCache();
    }

    if (ContextsLocked)
    {
        KerbUnlockContexts();
    }

    if (Context != NULL)
    {
        KerbDereferenceContext(Context);
    }

    if (IsClientContext)
    {
        KerbFreeString(
            &ClientName
            );

        KerbFreeString(
            &ServerName
            );
    }

    if (!NT_SUCCESS(Status))
    {
        if (NameInfo.sServerName != NULL)
        {
            LsaFunctions->FreeClientBuffer(
                NULL,
                NameInfo.sServerName
                );
        }

        if (NameInfo.sClientName != NULL)
        {
            LsaFunctions->FreeClientBuffer(
                NULL,
                NameInfo.sClientName
                );
        }
    }

    D_DebugLog((DEB_TRACE_API,"SpQueryLsaModeContextAttributes returned 0x%x, pid:0x%x, ctxt:0x%x, Attr:0x%x\n", KerbMapKerbNtStatusToNtStatus(Status), GetCurrentProcessId(), ContextHandle, ContextAttribute));

    return(KerbMapKerbNtStatusToNtStatus(Status));
}


//+-------------------------------------------------------------------------
//
//  Function:   SpCompleteAuthToken
//
//  Synopsis:   Completes a context (in Kerberos case, does nothing)
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS NTAPI
SpCompleteAuthToken(
    IN LSA_SEC_HANDLE ContextHandle,
    IN PSecBufferDesc InputBuffer
    )
{
    return(STATUS_SUCCESS);
}


#ifndef WIN32_CHICAGO
NTSTATUS NTAPI
SpFormatCredentials(
    IN PSecBuffer Credentials,
    OUT PSecBuffer FormattedCredentials
    )
{
    return(STATUS_NOT_SUPPORTED);
}

NTSTATUS NTAPI
SpMarshallSupplementalCreds(
    IN ULONG CredentialSize,
    IN PUCHAR Credentials,
    OUT PULONG MarshalledCredSize,
    OUT PVOID * MarshalledCreds
    )
{
    return(STATUS_NOT_SUPPORTED);
}

#endif // WIN32_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\chicago\cpcrypt.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cpcrypt.c

Abstract:

    include file for private\security\kerberos\common2\crypt.c

Author:

    Chandana Surlu (ChandanS) 09-Apr-1999

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1999 ChandanS
        Created.
--*/

#include "..\..\common2\crypt.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\chicago\cpkrb5.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cpkrb5.c

Abstract:

    include file for private\security\kerberos\common2\krb5.c

Author:

    Chandana Surlu (ChandanS) 09-Apr-1999

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1999 ChandanS
        Created.
--*/

#include "..\..\common2\krb5.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\chicago\cpnames.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cpnames.c

Abstract:

    include file for private\security\kerberos\common2\names.cxx

Author:

    Chandana Surlu (ChandanS) 09-Apr-1999

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1999 ChandanS
        Created.
--*/

#include "..\..\common2\names.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\chicago\cpkeygn.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cpkeygn.c

Abstract:

    include file for private\security\kerberos\common2\keygen.c

Author:

    Chandana Surlu (ChandanS) 09-Apr-1999

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1999 ChandanS
        Created.
--*/

#include "..\..\common2\keygen.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\chicago\cptick.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cptick.cxx

Abstract:

    include file for private\security\kerberos\common2\tickets.cxx

Author:

    Chandana Surlu (ChandanS) 09-Apr-1999

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1999 ChandanS
        Created.
--*/

#include "..\..\common2\tickets.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\chicago\cppaswd.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cppaswd.c

Abstract:

    include file for private\security\kerberos\common2\passwd.c

Author:

    Chandana Surlu (ChandanS) 09-Apr-1999

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1999 ChandanS
        Created.
--*/

#include "..\..\common2\passwd.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\chicago\cpsock.cxx ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    cpsock.c

Abstract:

    include file for private\security\kerberos\common2\sockets.cxx

Author:

    Chandana Surlu (ChandanS) 09-Apr-1999

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Apr-1999 ChandanS
        Created.
--*/

#include "..\..\common2\sockets.cxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\chicago\ntcalls.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        ntcalls.cxx
//
// Contents:    Code for rtl support on Win95
//
//
// History:     01-April-1997   Created        ChandanS
//
//------------------------------------------------------------------------

#include <kerb.hxx>
#include <kerbp.h>

/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Time.c

Abstract:

    This module implements the absolute time conversion routines for NT.

    Absolute LARGE_INTEGER in NT is represented by a 64-bit large integer accurate
    to 100ns resolution.  The smallest time resolution used by this package
    is One millisecond.  The basis for NT time is the start of 1601 which
    was chosen because it is the start of a new quadricentury.  Some facts
    to note are:

    o At 100ns resolution 32 bits is good for about 429 seconds (or 7 minutes)

    o At 100ns resolution a large integer (i.e., 63 bits) is good for
      about 29,247 years, or around 10,682,247 days.

    o At 1 second resolution 31 bits is good for about 68 years

    o At 1 second resolution 32 bits is good for about 136 years

    o 100ns Time (ignoring time less than a millisecond) can be expressed
      as two values, Days and Milliseconds.  Where Days is the number of
      whole days and Milliseconds is the number of milliseconds for the
      partial day.  Both of these values are ULONG.

    Given these facts most of the conversions are done by first splitting
    LARGE_INTEGER into Days and Milliseconds.

Author:

    Gary Kimura     [GaryKi]    26-Aug-1989

Environment:

    Pure utility routine

Revision History:

--*/



//
//  The following two tables map a day offset within a year to the month
//  containing the day.  Both tables are zero based.  For example, day
//  offset of 0 to 30 map to 0 (which is Jan).
//

UCHAR LeapYearDayToMonth[366] = {
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // January
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,        // February
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  // March
     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // April
     4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  // May
     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,     // June
     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,  // July
     7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,  // August
     8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,     // September
     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,  // October
    10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,     // November
    11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11}; // December

UCHAR NormalYearDayToMonth[365] = {
     0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  // January
     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,           // February
     2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,  // March
     3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,     // April
     4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,  // May
     5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,     // June
     6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,  // July
     7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,  // August
     8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,     // September
     9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9,  // October
    10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,     // November
    11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11}; // December

//
//  The following two tables map a month index to the number of days preceding
//  the month in the year.  Both tables are zero based.  For example, 1 (Feb)
//  has 31 days preceding it.  To help calculate the maximum number of days
//  in a month each table has 13 entries, so the number of days in a month
//  of index i is the table entry of i+1 minus the table entry of i.
//

CSHORT LeapYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+29,                             // March
    31+29+31,                          // April
    31+29+31+30,                       // May
    31+29+31+30+31,                    // June
    31+29+31+30+31+30,                 // July
    31+29+31+30+31+30+31,              // August
    31+29+31+30+31+30+31+31,           // September
    31+29+31+30+31+30+31+31+30,        // October
    31+29+31+30+31+30+31+31+30+31,     // November
    31+29+31+30+31+30+31+31+30+31+30,  // December
    31+29+31+30+31+30+31+31+30+31+30+31};

CSHORT NormalYearDaysPrecedingMonth[13] = {
    0,                                 // January
    31,                                // February
    31+28,                             // March
    31+28+31,                          // April
    31+28+31+30,                       // May
    31+28+31+30+31,                    // June
    31+28+31+30+31+30,                 // July
    31+28+31+30+31+30+31,              // August
    31+28+31+30+31+30+31+31,           // September
    31+28+31+30+31+30+31+31+30,        // October
    31+28+31+30+31+30+31+31+30+31,     // November
    31+28+31+30+31+30+31+31+30+31+30,  // December
    31+28+31+30+31+30+31+31+30+31+30+31};


//
//  The following definitions and declarations are some important constants
//  used in the time conversion routines
//

//
//  This is the week day that January 1st, 1601 fell on (a Monday)
//

#define WEEKDAY_OF_1601                  1

//
//  These are known constants used to convert 1970 and 1980 times to 1601
//  times.  They are the number of seconds from the 1601 base to the start
//  of 1970 and the start of 1980.  The number of seconds from 1601 to
//  1970 is 369 years worth, or (369 * 365) + 89 leap days = 134774 days, or
//  134774 * 864000 seconds, which is equal to the large integer defined
//  below.  The number of seconds from 1601 to 1980 is 379 years worth, or etc.
//

LARGE_INTEGER SecondsToStartOf1970 = {0xb6109100, 0x00000002};

LARGE_INTEGER SecondsToStartOf1980 = {0xc8df3700, 0x00000002};

//
//  These are the magic numbers needed to do our extended division.  The
//  only numbers we ever need to divide by are
//
//      10,000 = convert 100ns tics to millisecond tics
//
//      10,000,000 = convert 100ns tics to one second tics
//
//      86,400,000 = convert Millisecond tics to one day tics
//

LARGE_INTEGER Magic10000    = {0xe219652c, 0xd1b71758};
#define SHIFT10000                       13

LARGE_INTEGER Magic10000000 = {0xe57a42bd, 0xd6bf94d5};
#define SHIFT10000000                    23

LARGE_INTEGER Magic86400000 = {0xfa67b90e, 0xc6d750eb};
#define SHIFT86400000                    26

//
//  To make the code more readable we'll also define some macros to
//  do the actual division for use
//

#define Convert100nsToMilliseconds(LARGE_INTEGER) (                         \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000, SHIFT10000 )       \
    )

#define ConvertMillisecondsTo100ns(MILLISECONDS) (                 \
    RtlExtendedIntegerMultiply( (MILLISECONDS), 10000 )            \
    )

#define Convert100nsToSeconds(LARGE_INTEGER) (                              \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000000, SHIFT10000000 ) \
    )

#define ConvertSecondsTo100ns(SECONDS) (                           \
    RtlExtendedIntegerMultiply( (SECONDS), 10000000 )              \
    )

#define ConvertMillisecondsToDays(LARGE_INTEGER) (                          \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic86400000, SHIFT86400000 ) \
    )

#define ConvertDaysToMilliseconds(DAYS) (                          \
    Int32x32To64( (DAYS), 86400000 )                               \
    )


//
//  Local support routine
//

ULONG
ElapsedDaysToYears (
    IN ULONG ElapsedDays
    )

/*++

Routine Description:

    This routine computes the number of total years contained in the indicated
    number of elapsed days.  The computation is to first compute the number of
    400 years and subtract that it, then do the 100 years and subtract that out,
    then do the number of 4 years and subtract that out.  Then what we have left
    is the number of days with in a normalized 4 year block.  Normalized being that
    the first three years are not leap years.

Arguments:

    ElapsedDays - Supplies the number of days to use

Return Value:

    ULONG - Returns the number of whole years contained within the input number
        of days.

--*/

{
    ULONG NumberOf400s;
    ULONG NumberOf100s;
    ULONG NumberOf4s;
    ULONG Years;

    //
    //  A 400 year time block is 365*400 + 400/4 - 400/100 + 400/400 = 146097 days
    //  long.  So we simply compute the number of whole 400 year block and the
    //  the number days contained in those whole blocks, and subtract if from the
    //  elapsed day total
    //

    NumberOf400s = ElapsedDays / 146097;
    ElapsedDays -= NumberOf400s * 146097;

    //
    //  A 100 year time block is 365*100 + 100/4 - 100/100 = 36524 days long.
    //  The computation for the number of 100 year blocks is biased by 3/4 days per
    //  100 years to account for the extra leap day thrown in on the last year
    //  of each 400 year block.
    //

    NumberOf100s = (ElapsedDays * 100 + 75) / 3652425;
    ElapsedDays -= NumberOf100s * 36524;

    //
    //  A 4 year time block is 365*4 + 4/4 = 1461 days long.
    //

    NumberOf4s = ElapsedDays / 1461;
    ElapsedDays -= NumberOf4s * 1461;

    //
    //  Now the number of whole years is the number of 400 year blocks times 400,
    //  100 year blocks time 100, 4 year blocks times 4, and the number of elapsed
    //  whole years, taking into account the 3/4 day per year needed to handle the
    //  leap year.
    //

    Years = (NumberOf400s * 400) +
            (NumberOf100s * 100) +
            (NumberOf4s * 4) +
            (ElapsedDays * 100 + 75) / 36525;

    return Years;
}


//
//  ULONG
//  NumberOfLeapYears (
//      IN ULONG ElapsedYears
//      );
//
//  The number of leap years is simply the number of years divided by 4
//  minus years divided by 100 plus years divided by 400.  This says
//  that every four years is a leap year except centuries, and the
//  exception to the exception is the quadricenturies
//

#define NumberOfLeapYears(YEARS) (                    \
    ((YEARS) / 4) - ((YEARS) / 100) + ((YEARS) / 400) \
    )

//
//  ULONG
//  ElapsedYearsToDays (
//      IN ULONG ElapsedYears
//      );
//
//  The number of days contained in elapsed years is simply the number
//  of years times 365 (because every year has at least 365 days) plus
//  the number of leap years there are (i.e., the number of 366 days years)
//

#define ElapsedYearsToDays(YEARS) (            \
    ((YEARS) * 365) + NumberOfLeapYears(YEARS) \
    )

//
//  BOOLEAN
//  IsLeapYear (
//      IN ULONG ElapsedYears
//      );
//
//  If it is an even 400 or a non century leapyear then the
//  answer is true otherwise it's false
//

#define IsLeapYear(YEARS) (                        \
    (((YEARS) % 400 == 0) ||                       \
     ((YEARS) % 100 != 0) && ((YEARS) % 4 == 0)) ? \
        TRUE                                       \
    :                                              \
        FALSE                                      \
    )

//
//  ULONG
//  MaxDaysInMonth (
//      IN ULONG Year,
//      IN ULONG Month
//      );
//
//  The maximum number of days in a month depend on the year and month.
//  It is the difference between the days to the month and the days
//  to the following month
//

#define MaxDaysInMonth(YEAR,MONTH) (                                      \
    IsLeapYear(YEAR) ?                                                    \
        LeapYearDaysPrecedingMonth[(MONTH) + 1] -                         \
                                    LeapYearDaysPrecedingMonth[(MONTH)]   \
    :                                                                     \
        NormalYearDaysPrecedingMonth[(MONTH) + 1] -                       \
                                    NormalYearDaysPrecedingMonth[(MONTH)] \
    )



//
//  Internal Support routine
//

static
VOID
TimeToDaysAndFraction (
    IN PLARGE_INTEGER Time,
    OUT PULONG ElapsedDays,
    OUT PULONG Milliseconds
    )

/*++

Routine Description:

    This routine converts an input 64-bit time value to the number
    of total elapsed days and the number of milliseconds in the
    partial day.

Arguments:

    Time - Supplies the input time to convert from

    ElapsedDays - Receives the number of elapsed days

    Milliseconds - Receives the number of milliseconds in the partial day

Return Value:

    None

--*/

{
    LARGE_INTEGER TotalMilliseconds;
    LARGE_INTEGER Temp;

    //
    //  Convert the input time to total milliseconds
    //

    TotalMilliseconds = Convert100nsToMilliseconds( *(PLARGE_INTEGER)Time );

    //
    //  Convert milliseconds to total days
    //

    Temp = ConvertMillisecondsToDays( TotalMilliseconds );

    //
    //  Set the elapsed days from temp, we've divided it enough so that
    //  the high part must be zero.
    //

    *ElapsedDays = Temp.LowPart;

    //
    //  Calculate the exact number of milliseconds in the elapsed days
    //  and subtract that from the total milliseconds to figure out
    //  the number of milliseconds left in the partial day
    //

    Temp.QuadPart = ConvertDaysToMilliseconds( *ElapsedDays );

    Temp.QuadPart = TotalMilliseconds.QuadPart - Temp.QuadPart;

    //
    //  Set the fraction part from temp, the total number of milliseconds in
    //  a day guarantees that the high part must be zero.
    //

    *Milliseconds = Temp.LowPart;

    //
    //  And return to our caller
    //

    return;
}


//
//  Internal Support routine
//

//static
VOID
DaysAndFractionToTime (
    IN ULONG ElapsedDays,
    IN ULONG Milliseconds,
    OUT PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine converts an input elapsed day count and partial time
    in milliseconds to a 64-bit time value.

Arguments:

    ElapsedDays - Supplies the number of elapsed days

    Milliseconds - Supplies the number of milliseconds in the partial day

    Time - Receives the output time to value

Return Value:

    None

--*/

{
    LARGE_INTEGER Temp;
    LARGE_INTEGER Temp2;

    //
    //  Calculate the exact number of milliseconds in the elapsed days.
    //

    Temp.QuadPart = ConvertDaysToMilliseconds( ElapsedDays );

    //
    //  Convert milliseconds to a large integer
    //

    Temp2.LowPart = Milliseconds;
    Temp2.HighPart = 0;

    //
    //  add milliseconds to the whole day milliseconds
    //

    Temp.QuadPart = Temp.QuadPart + Temp2.QuadPart;

    //
    //  Finally convert the milliseconds to 100ns resolution
    //

    *(PLARGE_INTEGER)Time = ConvertMillisecondsTo100ns( Temp );

    //
    //  and return to our caller
    //

    return;
}


WCHAR
MyUpcaseChar (WCHAR wc)
//
// WARNING -- not DBCS safe
//
{
    CHAR sz[2];
    sz[0]= (CHAR) wc;
    sz[1]=0;

    AnsiUpper(sz);

    return (WCHAR) (sz[0]);

}

WCHAR
MyLowercaseChar (WCHAR wc)
//
// WARNING -- not DBCS safe
//
{
    CHAR sz[2];
    sz[0]= (CHAR) wc;
    sz[1]=0;

    AnsiLower(sz);

    return (WCHAR) (sz[0]);

}



VOID
MyRtlTimeToTimeFields (
    IN PLARGE_INTEGER Time,
    OUT PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This routine converts an input 64-bit LARGE_INTEGER variable to its corresponding
    time field record.  It will tell the caller the year, month, day, hour,
    minute, second, millisecond, and weekday corresponding to the input time
    variable.

Arguments:

    Time - Supplies the time value to interpret

    TimeFields - Receives a value corresponding to Time

Return Value:

    None

--*/

{
    ULONG Years;
    ULONG Month;
    ULONG Days;

    ULONG Hours;
    ULONG Minutes;
    ULONG Seconds;
    ULONG Milliseconds;

    //
    //  First divide the input time 64 bit time variable into
    //  the number of whole days and part days (in milliseconds)
    //

    TimeToDaysAndFraction( Time, &Days, &Milliseconds );

    //
    //  Compute which weekday it is and save it away now in the output
    //  variable.  We add the weekday of the base day to bias our computation
    //  which means that if one day has elapsed then we the weekday we want
    //  is the Jan 2nd, 1601.
    //

    TimeFields->Weekday = (CSHORT)((Days + WEEKDAY_OF_1601) % 7);

    //
    //  Calculate the number of whole years contained in the elapsed days
    //  For example if Days = 500 then Years = 1
    //

    Years = ElapsedDaysToYears( Days );

    //
    //  And subtract the number of whole years from our elapsed days
    //  For example if Days = 500, Years = 1, and the new days is equal
    //  to 500 - 365 (normal year).
    //

    Days = Days - ElapsedYearsToDays( Years );

    //
    //  Now test whether the year we are working on (i.e., The year
    //  after the total number of elapsed years) is a leap year
    //  or not.
    //

    if (IsLeapYear( Years + 1 )) {

        //
        //  The current year is a leap year, so figure out what month
        //  it is, and then subtract the number of days preceding the
        //  month from the days to figure out what day of the month it is
        //

        Month = LeapYearDayToMonth[Days];
        Days = Days - LeapYearDaysPrecedingMonth[Month];

    } else {

        //
        //  The current year is a normal year, so figure out the month
        //  and days as described above for the leap year case
        //

        Month = NormalYearDayToMonth[Days];
        Days = Days - NormalYearDaysPrecedingMonth[Month];

    }

    //
    //  Now we need to compute the elapsed hour, minute, second, milliseconds
    //  from the millisecond variable.  This variable currently contains
    //  the number of milliseconds in our input time variable that did not
    //  fit into a whole day.  To compute the hour, minute, second part
    //  we will actually do the arithmetic backwards computing milliseconds
    //  seconds, minutes, and then hours.  We start by computing the
    //  number of whole seconds left in the day, and then computing
    //  the millisecond remainder.
    //

    Seconds = Milliseconds / 1000;
    Milliseconds = Milliseconds % 1000;

    //
    //  Now we compute the number of whole minutes left in the day
    //  and the number of remainder seconds
    //

    Minutes = Seconds / 60;
    Seconds = Seconds % 60;

    //
    //  Now compute the number of whole hours left in the day
    //  and the number of remainder minutes
    //

    Hours = Minutes / 60;
    Minutes = Minutes % 60;

    //
    //  As our final step we put everything into the time fields
    //  output variable
    //

    TimeFields->Year         = (CSHORT)(Years + 1601);
    TimeFields->Month        = (CSHORT)(Month + 1);
    TimeFields->Day          = (CSHORT)(Days + 1);
    TimeFields->Hour         = (CSHORT)Hours;
    TimeFields->Minute       = (CSHORT)Minutes;
    TimeFields->Second       = (CSHORT)Seconds;
    TimeFields->Milliseconds = (CSHORT)Milliseconds;

    //
    //  and return to our caller
    //

    return;
}


BOOLEAN
MyRtlTimeFieldsToTime (
    IN PTIME_FIELDS TimeFields,
    OUT PLARGE_INTEGER Time
    )

/*++

Routine Description:

    This routine converts an input Time Field variable to a 64-bit NT time
    value.  It ignores the WeekDay of the time field.

Arguments:

    TimeFields - Supplies the time field record to use

    Time - Receives the NT Time corresponding to TimeFields

Return Value:

    BOOLEAN - TRUE if the Time Fields is well formed and within the
        range of time expressible by LARGE_INTEGER and FALSE otherwise.

--*/

{
    ULONG Year;
    ULONG Month;
    ULONG Day;
    ULONG Hour;
    ULONG Minute;
    ULONG Second;
    ULONG Milliseconds;

    ULONG ElapsedDays;
    ULONG ElapsedMilliseconds;

    //
    //  Load the time field elements into local variables.  This should
    //  ensure that the compiler will only load the input elements
    //  once, even if there are alias problems.  It will also make
    //  everything (except the year) zero based.  We cannot zero base the
    //  year because then we can't recognize cases where we're given a year
    //  before 1601.
    //

    Year         = TimeFields->Year;
    Month        = TimeFields->Month - 1;
    Day          = TimeFields->Day - 1;
    Hour         = TimeFields->Hour;
    Minute       = TimeFields->Minute;
    Second       = TimeFields->Second;
    Milliseconds = TimeFields->Milliseconds;

    //
    //  Check that the time field input variable contains
    //  proper values.
    //

    if ((TimeFields->Month < 1)                      ||
        (TimeFields->Day < 1)                        ||
        (Year < 1601)                                ||
        (Month > 11)                                 ||
        ((CSHORT)Day >= MaxDaysInMonth(Year, Month)) ||
        (Hour > 23)                                  ||
        (Minute > 59)                                ||
        (Second > 59)                                ||
        (Milliseconds > 999)) {

        return FALSE;

    }

    //
    //  Compute the total number of elapsed days represented by the
    //  input time field variable
    //

    ElapsedDays = ElapsedYearsToDays( Year - 1601 );

    if (IsLeapYear( Year - 1600 )) {

        ElapsedDays += LeapYearDaysPrecedingMonth[ Month ];

    } else {

        ElapsedDays += NormalYearDaysPrecedingMonth[ Month ];

    }

    ElapsedDays += Day;

    //
    //  Now compute the total number of milliseconds in the fractional
    //  part of the day
    //

    ElapsedMilliseconds = (((Hour*60) + Minute)*60 + Second)*1000 + Milliseconds;

    //
    //  Given the elapsed days and milliseconds we can now build
    //  the output time variable
    //

    DaysAndFractionToTime( ElapsedDays, ElapsedMilliseconds, Time );

    //
    //  And return to our caller
    //

    return TRUE;
}

VOID
MyRtlInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitUnicodeString function initializes an NT counted
    unicode string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated unicode string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PWSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = wcslen( SourceString ) * sizeof( WCHAR );
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
        }
    else {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
        }
}

VOID
MyRtlInitAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PCSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitAnsiString function initializes an NT counted string.
    The DestinationString is initialized to point to the SourceString
    and the Length and MaximumLength fields of DestinationString are
    initialized to the length of the SourceString, which is zero if
    SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = strlen(SourceString);
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length+1);
        }
    else {
        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        }
}

NTSTATUS
MyRtlAnsiStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PANSI_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified ansi source string into a
    Unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is equivalent to
        the ansi source string. The maximum length field is only
        set if AllocateDestinationString is TRUE.

    SourceString - Supplies the ansi source string that is to be
        converted to unicode.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG UnicodeLength;
    ULONG Index = 0;
    NTSTATUS st = STATUS_SUCCESS;

    UnicodeLength = (SourceString->Length + 1) * sizeof(WCHAR);
    if ( UnicodeLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(UnicodeLength - sizeof(UNICODE_NULL));
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)UnicodeLength;
        DestinationString->Buffer = (PWSTR) LocalAlloc(0, UnicodeLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    if (SourceString->Length != 0)
    {
        Index = MultiByteToWideChar(
             CP_ACP,
             MB_PRECOMPOSED,
             SourceString->Buffer,
             SourceString->Length,
             DestinationString->Buffer,
             DestinationString->MaximumLength
             );

        if (Index == 0) {
            if ( AllocateDestinationString ) {
                LocalFree(DestinationString->Buffer);
            }

            return STATUS_NO_MEMORY;
        }
    }

    DestinationString->Buffer[Index] = UNICODE_NULL;

    return st;
}

BOOLEAN
MyRtlCreateUnicodeStringFromAsciiz(
    OUT PUNICODE_STRING DestinationString,
    IN PCSTR SourceString
    )
{
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    if (!ARGUMENT_PRESENT(SourceString))
    {
        DestinationString->Buffer = NULL;
        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        return (TRUE);
    }

    MyRtlInitAnsiString( &AnsiString, SourceString );
    Status = MyRtlAnsiStringToUnicodeString( DestinationString, &AnsiString, TRUE );
    if (NT_SUCCESS( Status )) {
        return( TRUE );
        }
    else {
        return( FALSE );
        }
}


NTSTATUS
MyRtlUpcaseUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    upcased unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is the upcased equivalent
        to the unicode source string.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to being
        upcased.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG Index;
    ULONG StopIndex;


    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = SourceString->Length;
        DestinationString->Buffer = (LPWSTR)LocalAlloc(0, (ULONG)DestinationString->MaximumLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( SourceString->Length > DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    StopIndex = ((ULONG)SourceString->Length) / sizeof( WCHAR );

    for (Index = 0; Index < StopIndex; Index++) {
// WIN32_CHICAGO Use some other Upcase mechanism
//        DestinationString->Buffer[Index] = (WCHAR)NLS_UPCASE(SourceString->Buffer[Index]);
        WCHAR uc;
        uc  = MyUpcaseChar(SourceString->Buffer[Index]);
        DestinationString->Buffer[Index] = uc;
    }

    DestinationString->Length = SourceString->Length;

    return STATUS_SUCCESS;
}


NTSTATUS
RtlDowncaseUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into a
    downcased unicode string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns a unicode string that is the downcased
        equivalent to the unicode source string.  The maximum length field
        is only set if AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to being
        downcased.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG Index;
    ULONG StopIndex;

    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = SourceString->Length;
        DestinationString->Buffer = (LPWSTR)LocalAlloc(0, (ULONG)DestinationString->MaximumLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( SourceString->Length > DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    StopIndex = ((ULONG)SourceString->Length) / sizeof( WCHAR );

    for (Index = 0; Index < StopIndex; Index++) {
// WIN32_CHICAGO Use some other Downcase mechanism
//        DestinationString->Buffer[Index] = (WCHAR)NLS_DOWNCASE(SourceString->Buffer[Index]);
        WCHAR lc;
        WCHAR TempChar = SourceString->Buffer[Index];
        lc  = MyLowercaseChar(TempChar);
        DestinationString->Buffer[Index] = lc;
    }

    DestinationString->Length = SourceString->Length;

    return STATUS_SUCCESS;
}


VOID
MyRtlFreeAnsiString(
    IN OUT PANSI_STRING AnsiString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlUnicodeStringToAnsiString.  Note that only AnsiString->Buffer
    is free'd by this routine.

Arguments:

    AnsiString - Supplies the address of the ansi string whose buffer
        was previously allocated by RtlUnicodeStringToAnsiString.

Return Value:

    None.

--*/

{
    if (AnsiString->Buffer) {
        LocalFree(AnsiString->Buffer);
#if 0
        memset( AnsiString, 0, sizeof( *AnsiString ) );
#endif
        ZeroMemory( AnsiString, sizeof( *AnsiString ) );
        }
}

BOOLEAN
MyRtlEqualUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlEqualUnicodeString function compares two counted unicode strings for
    equality.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{

    PWCHAR s1, s2;
    ULONG n1, n2, Count;
    CHAR c1, c2;

    n1 = String1->Length;
    n2 = String2->Length;

    DsysAssert((n1 & 1) == 0);
    DsysAssert((n2 & 1) == 0);

    if (n1 == n2) {
        s1 = String1->Buffer;
        s2 = String2->Buffer;

#if 0
        DsysAssert(!(((((ULONG)s1 & 1) != 0) || (((ULONG)s2 & 1) != 0)) && (n1 != 0) && (n2 != 0)));

        Limit = (PWCHAR)((PCHAR)s1 + n1);
        if (CaseInSensitive) {
            while (s1 < Limit) {
                c1 = (CHAR) (*s1)++;
                c2 = (CHAR) (*s2)++;

// WIN32_CHICAGO Do something better than AnsiUpper
                uc1= AnsiUpper (&c1);
                uc2 = AnsiUpper (&c2);
                if ((c1 != c2) && ((*uc1) != *(uc2))) {
                    return FALSE;
                }
            }

            return TRUE;

        } else {
            while (s1 < Limit) {
                c1 = (CHAR) (*s1)++;
                c2 = (CHAR) (*s2)++;
                if (c1 != c2) {
                    return FALSE;
                }
            }

            return TRUE;
        }
#else // 0
        if (CaseInSensitive)
        {
            Count = 0;
            // Can't use wcsnicmp

            while (Count < (n1/sizeof(WCHAR)))
            {
                WCHAR uc1, uc2;
                uc1= MyUpcaseChar (*(s1 + Count));
                uc2 = MyUpcaseChar (*(s2 + Count));
                if (uc1 != uc2) {
                    return FALSE;
                }
                Count++;
            }
            return TRUE;
        }
        else
        {
            if (wcsncmp (s1, s2, (n1/sizeof(WCHAR))) == 0)
            {
                return TRUE;
            }
            else
            {
                return FALSE;
            }
        }
#endif // 0

    } else {
        return FALSE;
    }
}

NTSTATUS
MyRtlUnicodeStringToAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This functions converts the specified unicode source string into an
    ansi string. The translation is done with respect to the
    current system locale information.

Arguments:

    DestinationString - Returns an ansi string that is equivalent to the
        unicode source string.  If the translation can not be done,
        an error is returned.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to ansi.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    ULONG AnsiLength;
    ULONG Index = 0;
    NTSTATUS ReturnStatus = STATUS_SUCCESS;
    BOOL fUsed;

    AnsiLength = (SourceString->Length / sizeof(WCHAR)) + 1;
    if ( AnsiLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(AnsiLength - 1);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)AnsiLength;
        DestinationString->Buffer = (LPSTR)LocalAlloc(0, AnsiLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            /*
             * Return STATUS_BUFFER_OVERFLOW, but translate as much as
             * will fit into the buffer first.  This is the expected
             * behavior for routines such as GetProfileStringA.
             * Set the length of the buffer to one less than the maximum
             * (so that the trail byte of a double byte char is not
             * overwritten by doing DestinationString->Buffer[Index] = '\0').
             * RtlUnicodeToMultiByteN is careful not to truncate a
             * multibyte character.
             */
            if (!DestinationString->MaximumLength) {
                return STATUS_BUFFER_OVERFLOW;
            }
            ReturnStatus = STATUS_BUFFER_OVERFLOW;
            DestinationString->Length = DestinationString->MaximumLength - 1;
            }
        }

    if (SourceString->Length != 0)
    {
        Index = WideCharToMultiByte(
             CP_ACP,
             0, // WIN32_CHICAGO this is something else
             SourceString->Buffer,
             SourceString->Length / sizeof (WCHAR),
             DestinationString->Buffer,
             DestinationString->MaximumLength,
             NULL,
             &fUsed
             );

        if (Index == 0)
        { // WIN32_CHICAGO do something useful here
            if ( AllocateDestinationString ) {
                LocalFree(DestinationString->Buffer);
            }
            return STATUS_NO_MEMORY;
        }
    }

    DestinationString->Buffer[Index] = '\0';

    return ReturnStatus;
}

NTSTATUS
MyRtlUpcaseUnicodeStringToOemString(
    OUT POEM_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:

    This function upper cases the specified unicode source string and then
    converts it into an oem string. The translation is done with respect
    to the OEM code page (OCP).

Arguments:

    DestinationString - Returns an oem string that is equivalent to the
        unicode source string.  The maximum length field is only set if
        AllocateDestinationString is TRUE.

    SourceString - Supplies the unicode source string that is to be
        converted to oem.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeAnsiString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    !SUCCESS - The operation failed.  No storage was allocated and no
        conversion was done.  None.

--*/

{
    // NOTE: This routine is not DBCS safe yet!
    ULONG OemLength;
    ULONG Index;
    BOOL fUsed;
    NTSTATUS st = STATUS_SUCCESS;

    // Do not rely on callers to set MaximumLength as Length + 2
    OemLength = (SourceString->Length  / sizeof(WCHAR)) + 1;
    if ( OemLength > MAXUSHORT ) {
        return STATUS_INVALID_PARAMETER_2;
        }

    DestinationString->Length = (USHORT)(OemLength - 1);
    if ( AllocateDestinationString ) {
        DestinationString->MaximumLength = (USHORT)OemLength;
        DestinationString->Buffer = (LPSTR)LocalAlloc(0, OemLength);
        if ( !DestinationString->Buffer ) {
            return STATUS_NO_MEMORY;
            }
        }
    else {
        if ( DestinationString->Length >= DestinationString->MaximumLength ) {
            return STATUS_BUFFER_OVERFLOW;
            }
        }

    Index = WideCharToMultiByte(
             CP_OEMCP,
             0, // WIN32_CHICAGO this is something else
             SourceString->Buffer,
             SourceString->Length / sizeof (WCHAR),
             DestinationString->Buffer,
             DestinationString->MaximumLength,
             NULL,
             &fUsed
             );
    if (Index == 0)
    { // WIN32_CHICAGO do something useful here
        if ( AllocateDestinationString ) {
            LocalFree(DestinationString->Buffer);
        }
        return STATUS_NO_MEMORY;
    }
/*
    st = RtlUnicodeToMultiByteN(
                    DestinationString->Buffer,
                    DestinationString->Length,
                    &Index,
                    SourceString->Buffer,
                    SourceString->Length
                    );
    if (!NT_SUCCESS(st))
    {
        if ( AllocateDestinationString ) {
            LocalFree(DestinationString->Buffer);
        }
    }
*/

    DestinationString->Buffer[Index] = '\0';

    return st;
}


BOOLEAN
MyRtlEqualString(
    IN POEM_STRING String1,
    IN POEM_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlEqualString function compares two counted strings for equality.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{

    PUCHAR s1, s2, Limit;
    LONG n1, n2;
    UCHAR c1, c2;

    n1 = String1->Length;
    n2 = String2->Length;
    if (n1 == n2) {
        s1 = (PUCHAR)String1->Buffer;
        s2 = (PUCHAR)String2->Buffer;
        Limit = s1 + n1;
        if (CaseInSensitive) {
            while (s1 < Limit) {
                c1 = *s1++;
                c2 = *s2++;
                if (c1 != c2) {
                    WCHAR uc1, uc2;
 // WIN32_CHICAGO Use something better to upcase here
                    uc1 = MyUpcaseChar((WCHAR)c1);
                    uc2 = MyUpcaseChar((WCHAR)c2);
                    if (uc1 != uc2) {
                        return FALSE;
                    }
                }
            }

            return TRUE;

        } else {
            while (s1 < Limit) {
                c1 = *s1++;
                c2 = *s2++;
                if (c1 != c2) {
                    return FALSE;
                }
            }

            return TRUE;
        }

    } else {
        return FALSE;
    }
}

VOID
MyRtlFreeOemString(
    IN OUT POEM_STRING OemString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlUnicodeStringToOemString.  Note that only OemString->Buffer
    is free'd by this routine.

Arguments:

    OemString - Supplies the address of the oem string whose buffer
        was previously allocated by RtlUnicodeStringToOemString.

Return Value:

    None.

--*/

{
    if (OemString->Buffer) {
        LocalFree(OemString->Buffer);
        memset( OemString, 0, sizeof( *OemString ) );
        }
}


BOOLEAN
MyRtlEqualDomainName(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2
    )

/*++

Routine Description:

    The RtlEqualDomainName function compares two domain names for equality.

    The comparison is a case insensitive comparison of the OEM equivalent
    strings.

    The domain name is not validated for length nor invalid characters.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

Return Value:

    Boolean value that is TRUE if String1 equals String2 and FALSE otherwise.

--*/

{
    NTSTATUS Status;
    BOOLEAN ReturnValue = FALSE;
    OEM_STRING OemString1;
    OEM_STRING OemString2;

    //
    // Upper case and convert the first string to OEM
    //

    Status = MyRtlUpcaseUnicodeStringToOemString( &OemString1,
                                                String1,
                                                TRUE );   // Allocate Dest

    if ( NT_SUCCESS( Status ) ) {

        //
        // Upper case and convert the second string to OEM
        //

        Status = MyRtlUpcaseUnicodeStringToOemString( &OemString2,
                                                    String2,
                                                    TRUE );   // Allocate Dest

        if ( NT_SUCCESS( Status ) ) {

            //
            // Do a case insensitive comparison.
            //

            ReturnValue = MyRtlEqualString( &OemString1,
                                          &OemString2,
                                          FALSE );

            MyRtlFreeOemString( &OemString2 );
        }

        MyRtlFreeOemString( &OemString1 );
    }

    return ReturnValue;
}


VOID
MyRtlInitString(
    OUT PSTRING DestinationString,
    IN PCSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitString function initializes an NT counted string.
    The DestinationString is initialized to point to the SourceString
    and the Length and MaximumLength fields of DestinationString are
    initialized to the length of the SourceString, which is zero if
    SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = strlen(SourceString);
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length+1);
        }
}

LONG
MyRtlCompareUnicodeString(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN CaseInSensitive
    )

/*++

Routine Description:

    The RtlCompareUnicodeString function compares two counted strings.  The
    return value indicates if the strings are equal or String1 is less than
    String2 or String1 is greater than String2.

    The CaseInSensitive parameter specifies if case is to be ignored when
    doing the comparison.

Arguments:

    String1 - Pointer to the first string.

    String2 - Pointer to the second string.

    CaseInsensitive - TRUE if case should be ignored when doing the
        comparison.

Return Value:

    Signed value that gives the results of the comparison:

        Zero - String1 equals String2

        < Zero - String1 less than String2

        > Zero - String1 greater than String2


--*/

{

    PWCHAR s1, s2, Limit;
    LONG n1, n2;
    WCHAR c1, c2;

    s1 = String1->Buffer;
    s2 = String2->Buffer;
    n1 = String1->Length;
    n2 = String2->Length;

    DsysAssert((n1 & 1) == 0);
    DsysAssert((n2 & 1) == 0);
    DsysAssert(!(((((ULONG)s1 & 1) != 0) || (((ULONG)s2 & 1) != 0)) && (n1 != 0) && (n2 != 0)));

    Limit = (PWCHAR)((PCHAR)s1 + (n1 <= n2 ? n1 : n2));
    if (CaseInSensitive) {
        while (s1 < Limit) {
            c1 = *s1++;
            c2 = *s2++;
            if (c1 != c2) {
                WCHAR uc1, uc2;

                //
                // Note that this needs to reference the translation table!
                //

// WIN32_CHICAGO Need to do something better here
                uc1 = MyUpcaseChar(c1);
                uc2 = MyUpcaseChar(c2);
                if (uc1 != uc2) {
                    return (LONG)(c1) - (LONG)(c2);
                }
            }
        }

    } else {
        while (s1 < Limit) {
            c1 = *s1++;
            c2 = *s2++;
            if (c1 != c2) {
                return (LONG)(c1) - (LONG)(c2);
            }
        }
    }

    return n1 - n2;
}


VOID
MyRtlFreeUnicodeString(
    IN OUT PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This API is used to free storage allocated by
    RtlAnsiStringToUnicodeString.  Note that only UnicodeString->Buffer
    is free'd by this routine.

Arguments:

    UnicodeString - Supplies the address of the unicode string whose
        buffer was previously allocated by RtlAnsiStringToUnicodeString.

Return Value:

    None.

--*/

{

    if (UnicodeString->Buffer) {
        LocalFree(UnicodeString->Buffer);
        memset( UnicodeString, 0, sizeof( *UnicodeString ) );
        }
}


NTSTATUS
MyRtlConvertSidToUnicodeString(
    PUNICODE_STRING UnicodeString,
    PSID Sid,
    BOOLEAN AllocateDestinationString
    )

/*++

Routine Description:


    This function generates a printable unicode string representation
    of a SID.

    The resulting string will take one of two forms.  If the
    IdentifierAuthority value is not greater than 2^32, then
    the SID will be in the form:


        S-1-281736-12-72-9-110
              ^    ^^ ^^ ^ ^^^
              |     |  | |  |
              +-----+--+-+--+---- Decimal



    Otherwise it will take the form:


        S-1-0x173495281736-12-72-9-110
            ^^^^^^^^^^^^^^ ^^ ^^ ^ ^^^
             Hexidecimal    |  | |  |
                            +--+-+--+---- Decimal






Arguments:



    UnicodeString - Returns a unicode string that is equivalent to
        the SID. The maximum length field is only set if
        AllocateDestinationString is TRUE.

    Sid - Supplies the SID that is to be converted to unicode.

    AllocateDestinationString - Supplies a flag that controls whether or
        not this API allocates the buffer space for the destination
        string.  If it does, then the buffer must be deallocated using
        RtlFreeUnicodeString (note that only storage for
        DestinationString->Buffer is allocated by this API).

Return Value:

    SUCCESS - The conversion was successful

    STATUS_INVALID_SID - The sid provided does not have a valid structure,
        or has too many sub-authorities (more than SID_MAX_SUB_AUTHORITIES).

    STATUS_NO_MEMORY - There was not sufficient memory to allocate the
        target string.  This is returned only if AllocateDestinationString
        is specified as TRUE.

    STATUS_BUFFER_OVERFLOW - This is returned only if
        AllocateDestinationString is specified as FALSE.


--*/

{
    NTSTATUS Status;
    UCHAR Buffer[256];
    UCHAR String[256];

    UCHAR   i;
    ULONG   Tmp;

    PISID   iSid = (PISID)Sid;  // pointer to opaque structure

    ANSI_STRING AnsiString;

#ifndef WIN32_CHICAGO // Painful to do this
    if (RtlValidSid( Sid ) != TRUE) {
        return(STATUS_INVALID_SID);
    }
#endif // WIN32_CHICAGO


    _snprintf((CHAR *)Buffer, sizeof(Buffer), "S-%u-", (USHORT)iSid->Revision );
    strcpy((char *)String, (const char *)Buffer);

    if (  (iSid->IdentifierAuthority.Value[0] != 0)  ||
          (iSid->IdentifierAuthority.Value[1] != 0)     ){
        _snprintf((CHAR *) Buffer, sizeof(Buffer), "0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)iSid->IdentifierAuthority.Value[0],
                    (USHORT)iSid->IdentifierAuthority.Value[1],
                    (USHORT)iSid->IdentifierAuthority.Value[2],
                    (USHORT)iSid->IdentifierAuthority.Value[3],
                    (USHORT)iSid->IdentifierAuthority.Value[4],
                    (USHORT)iSid->IdentifierAuthority.Value[5] );
        strcat((char *) String, (const char *)Buffer);

    } else {

        Tmp = (ULONG)iSid->IdentifierAuthority.Value[5]          +
              (ULONG)(iSid->IdentifierAuthority.Value[4] <<  8)  +
              (ULONG)(iSid->IdentifierAuthority.Value[3] << 16)  +
              (ULONG)(iSid->IdentifierAuthority.Value[2] << 24);
        _snprintf((char *)Buffer, sizeof(Buffer), "%lu", Tmp);
        strcat((char *)String, (const char *)Buffer);
    }


    for (i=0;i<iSid->SubAuthorityCount ;i++ ) {
        _snprintf((char *) Buffer, sizeof(Buffer), "-%lu", iSid->SubAuthority[i]);
        strcat((char *)String, (const char *)Buffer);
    }

    //
    // Convert the string to a Unicode String
    //

    RtlInitString(&AnsiString, (PSZ) String);

    Status = RtlAnsiStringToUnicodeString( UnicodeString,
                                           &AnsiString,
                                           AllocateDestinationString
                                           );

    return(Status);
}


//
// Inline functions to convert between FILETIME and TimeStamp
//
#pragma warning( disable : 4035)    // Don't complain about no return

TimeStamp __inline
FileTimeToTimeStamp(
    const FILETIME *pft)
{
    _asm {
        mov edx, pft
        mov eax, [edx].dwLowDateTime
        mov edx, [edx].dwHighDateTime
    }
}

#pragma warning( default : 4035)    // Reenable warning

NTSTATUS
MyNtQuerySystemTime (
    OUT PTimeStamp SystemTimeStamp
    )
/*++

Routine Description:

    This routine returns the current system time (UTC), as a timestamp
    (a 64-bit unsigned integer, in 100-nanosecond increments).

Arguments:

    None.

Return Value:

    The current system time.

--*/

{
    SYSTEMTIME SystemTime;
    FILETIME FileTime;

    GetSystemTime(&SystemTime);
    SystemTimeToFileTime(&SystemTime, &FileTime);

    *SystemTimeStamp = FileTimeToTimeStamp(&FileTime);

    return STATUS_SUCCESS; // WIN32_CHICAGO do something useful here
}


NTSTATUS
MyNtAllocateLocallyUniqueId(
    OUT PLUID Luid
    )
{
    // WIN32_CHICAGO do something useful here
    Luid->HighPart = 1;
    Luid->LowPart = 1;
    return STATUS_SUCCESS;
}

NTSTATUS
GetClientInfo(
    OUT PSECPKG_CLIENT_INFO ClientInfo
    )
{
    // We don't care about these. Just fake it so that the common code does
    // look too unreadable.

    MyNtAllocateLocallyUniqueId (&ClientInfo->LogonId);
    ClientInfo->HasTcbPrivilege = TRUE;
    ClientInfo->ProcessID = 0;
    return STATUS_SUCCESS;
}

BOOLEAN
GetCallInfo(
    OUT PSECPKG_CALL_INFO CallInfo
    )
{
    ZeroMemory( CallInfo, sizeof( SECPKG_CALL_INFO ) );
    return(TRUE);
}


NTSTATUS
CopyFromClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID BufferToCopy,
    IN PVOID ClientBaseAddress
    )
{
    RtlCopyMemory(
        BufferToCopy,
        ClientBaseAddress,
        Length
        );
    return STATUS_SUCCESS;
}

NTSTATUS
AllocateClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG LengthRequired,
    OUT PVOID *ClientBaseAddress
    )
{
    *ClientBaseAddress = (PVOID)KerbAllocate(LengthRequired);
    if (ClientBaseAddress == NULL)
    {
        return STATUS_NO_MEMORY;
    }
    return STATUS_SUCCESS;
}

NTSTATUS
CopyToClientBuffer(
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID ClientBaseAddress,
    IN PVOID BufferToCopy
    )
{
    RtlCopyMemory(
        ClientBaseAddress,
        BufferToCopy,
        Length
        );

    return STATUS_SUCCESS;
}

NTSTATUS
FreeClientBuffer (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ClientBaseAddress
    )
{
    KerbFree(ClientBaseAddress);

    return STATUS_SUCCESS;
}

VOID
AuditLogon(
    IN NTSTATUS Status,
    IN NTSTATUS SubStatus,
    IN PUNICODE_STRING AccountName,
    IN PUNICODE_STRING AuthenticatingAuthority,
    IN PUNICODE_STRING WorkstationName,
    IN OPTIONAL PSID UserSid,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PTOKEN_SOURCE TokenSource,
    IN PLUID LogonId
    )
{
    // WIN32_CHICAGO do something useful here
}

ULONG
MyRtlLengthSid (
    PSID Sid
    )
{
    return 0;
}

BOOLEAN
MyRtlValidSid (
    PSID Sid
    )
{
    return TRUE;
}

NTSTATUS
MapBuffer(
    IN PSecBuffer InputBuffer,
    OUT PSecBuffer OutputBuffer
    )
{
    // WIN32_CHICAGO do something useful here
    return STATUS_SUCCESS;
}

NTSTATUS
MyNtClose(
    IN HANDLE Handle
    )
{
    return STATUS_SUCCESS;
}

NTSTATUS
KerbDuplicateHandle(
    IN HANDLE SourceHandle,
    OUT PHANDLE DestionationHandle
    )
{
    // WIN32_CHICAGO do something useful here
    return STATUS_SUCCESS;
}

PVOID
AllocateLsaHeap(
    IN ULONG Length
    )
{
    return LocalAlloc(0, Length);
}

VOID
FreeLsaHeap(
    IN PVOID Base
    )
{
    LocalFree(Base);
}

VOID
FreeReturnBuffer(
    IN PVOID Base
    )
{
    LocalFree(Base);
}

//+-------------------------------------------------------------------------
//
//  Function:   FreeContextBuffer
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

SECURITY_STATUS SEC_ENTRY
FreeContextBuffer(
    void SEC_FAR *      pvContextBuffer
    )
{
    LocalFree(pvContextBuffer);
    return(SEC_E_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\security\protocols\kerberos\client2\chicago\kerbstub.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    stub.c

Abstract:

    Kerberos Security Support Provider client stubs.

Author:

    Chandana Surlu (ChandanS) 11-Feb-1997

Environment:  Win9x User Mode

Revision History:

--*/

#include <kerb.hxx>

#include <rpc.h>          // PSEC_WINNT_AUTH_IDENTITY
#include <stdarg.h>       // Variable-length argument support

#define KERBSTUB_ALLOCATE

#include <kerbp.h>

SECPKG_DLL_FUNCTIONS UserFunctionTable;
VOID
KerbShutdownSecurityInterface(
    VOID
    );

VOID DumpLogonSession();

BOOL WINAPI DllMain(
    HINSTANCE hInstance,
    ULONG  dwReason,
    PVOID  lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        InitializeCriticalSection( &KerbDllCritSect );

#if DBG
        InitializeCriticalSection( &KerbGlobalLogFileCritSect );
        KerbInfoLevel = DEB_ERROR | DEB_WARN | DEB_TRACE | DEB_TRACE_API |
                        DEB_TRACE_CRED | DEB_TRACE_CTXT | DEB_TRACE_LOCKS |
                        DEB_TRACE_CTXT2 | DEB_TRACE_KDC | DEB_TRACE_LSESS |
                        DEB_TRACE_LOGON;
#endif // DBG
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        KerbShutdownSecurityInterface();
#if DBG
        DeleteCriticalSection( &KerbGlobalLogFileCritSect );
#endif // DBG

        DeleteCriticalSection( &KerbDllCritSect );
    }

    return TRUE;
}


PSecurityFunctionTable
InitSecurityInterfaceA(
    VOID
    )

/*++

Routine Description:

    RPC calls this function to get the addresses of all the other functions
    that it might call.

Arguments:

    None.

Return Value:

    A pointer to our static SecurityFunctionTable.  The caller need
    not deallocate this table.

--*/

{
    HKEY hRegKey;
    DWORD dwError = 0, dwSize = 0;
    DWORD dwType = REG_BINARY;
    LPWSTR pUserName = NULL, pDomainName = NULL;
    PKERB_LOGON_SESSION_CACHE RegLogonSession = NULL;
    PKERB_LOGON_SESSION LogonSession = NULL;
    SECURITY_STATUS Status = SEC_E_OK;

    // BUBUG Init this to something, we need Parameters.DomainName,
    // Parameters.DnsDomainName & Parameters.version at least
    SECPKG_PARAMETERS Parameters;
    PVOID ignored = NULL;

    DebugLog((DEB_TRACE_API, "Entering KerbInitSecurityInterface\n"));

    // Initialize the SecurityFunctionTable
    ZeroMemory( &KerbDllSecurityFunctionTable,
                sizeof(KerbDllSecurityFunctionTable) );

    KerbGlobalCapabilities  = KERBEROS_CAPABILITIES;

    KerberosState = KerberosUserMode;

    KerbDllSecurityFunctionTable.dwVersion = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;

    KerbDllSecurityFunctionTable.EnumerateSecurityPackages = KerbEnumerateSecurityPackages;
    KerbDllSecurityFunctionTable.AcquireCredentialsHandle = KerbAcquireCredentialsHandle;
    KerbDllSecurityFunctionTable.FreeCredentialHandle = KerbFreeCredentialsHandle;
    KerbDllSecurityFunctionTable.InitializeSecurityContext = KerbInitializeSecurityContext;
    KerbDllSecurityFunctionTable.QueryCredentialsAttributes = KerbQueryCredentialsAttributes;
    KerbDllSecurityFunctionTable.AcceptSecurityContext = NULL;
    KerbDllSecurityFunctionTable.CompleteAuthToken = KerbCompleteAuthToken;
    KerbDllSecurityFunctionTable.QueryContextAttributes = KerbQueryContextAttributes;
    KerbDllSecurityFunctionTable.SspiLogonUser = KerbSspiLogonUser;
    KerbDllSecurityFunctionTable.DeleteSecurityContext = KerbDeleteSecurityContext;
    KerbDllSecurityFunctionTable.ApplyControlToken = KerbApplyControlToken;
    KerbDllSecurityFunctionTable.ImpersonateSecurityContext = KerbImpersonateSecurityContext;
    KerbDllSecurityFunctionTable.RevertSecurityContext = KerbRevertSecurityContext;
    KerbDllSecurityFunctionTable.MakeSignature = KerbMakeSignature;
    KerbDllSecurityFunctionTable.VerifySignature = KerbVerifySignature;
    KerbDllSecurityFunctionTable.FreeContextBuffer = KerbFreeContextBuffer;
    KerbDllSecurityFunctionTable.QuerySecurityPackageInfo = KerbQuerySecurityPackageInfo;
    KerbDllSecurityFunctionTable.Reserved3 = KerbSealMessage;
    KerbDllSecurityFunctionTable.Reserved4 = KerbUnsealMessage;
    KerbDllSecurityFunctionTable.EncryptMessage = KerbSealMessage;
    KerbDllSecurityFunctionTable.DecryptMessage = KerbUnsealMessage;


// Before we call SpInitialize, fill a table of LsaFunctions that are
// imlemented locally. This is done so that the code does not look awful.
// Fill in dummy functions in case more functions are used so we don't
// av

//    FunctionTable.CreateLogonSession = CreateLogonSession;
//    FunctionTable.DeleteLogonSession = DeleteLogonSession;
//    FunctionTable.AddCredential     =  AddCredential;
//    FunctionTable.GetCredentials    =  GetCredentials;
//    FunctionTable.DeleteCredential   = DeleteCredential;
    FunctionTable.AllocateLsaHeap  =    AllocateLsaHeap;
    FunctionTable.FreeLsaHeap       =  FreeLsaHeap;
    FunctionTable.AllocateClientBuffer = AllocateClientBuffer;
    FunctionTable.FreeClientBuffer   = FreeClientBuffer;
    FunctionTable.CopyToClientBuffer = CopyToClientBuffer;
    FunctionTable.CopyFromClientBuffer = CopyFromClientBuffer;
//    FunctionTable.ImpersonateClient = ImperosnateClient;
//    FunctionTable.UnloadPackage = UnloadPackage;
    FunctionTable.DuplicateHandle = KerbDuplicateHandle;
//    FunctionTable.SaveSupplementalCredentials = SaveSupplementalCredentials;
//    FunctionTable.GetWindow = GetWindow;
//    FunctionTable.ReleaseWindow = ReleaseWindow;
//    FunctionTable.CreateThread = CreateThread;
    FunctionTable.GetClientInfo = GetClientInfo;
//    FunctionTable.RegisterNotification = RegisterNotification;
//    FunctionTable.CancelNotification = CancelNotification;
    FunctionTable.MapBuffer = MapBuffer;
//    FunctionTable.CreateToken = CreateToken;
    FunctionTable.AuditLogon = AuditLogon;
//    FunctionTable.CallPackage = CallPackage;
    FunctionTable.FreeReturnBuffer = FreeReturnBuffer;
    FunctionTable.GetCallInfo = GetCallInfo;
//    FunctionTable.CallPackageEx = CallPackageEx;
//    FunctionTable.CreateSharedMemory = CreateSharedMemory;
//    FunctionTable.AllocateSharedMemory = AllocateSharedMemory;
//    FunctionTable.FreeSharedMemory = FreeSharedMemory;
//    FunctionTable.DeleteSharedMemory = DeleteSharedMemory;
//    FunctionTable.OpenSamUser  = OpenSamUser;
//    FunctionTable.GetUserCredentials =  GetUserCredentials;
//    FunctionTable.GetUserAuthData  = GetUserAuthData;
//    FunctionTable.CloseSamUser  = CloseSamUser;
//    FunctionTable.ConvertAuthDataToTokenInfo = ConvertAuthDataToTokenInfo;

    // we call into the kerb routines
    Parameters.Version = SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION;
    Parameters.MachineState = SECPKG_STATE_STANDALONE;

    // NOTE - Yikes!
    Parameters.DomainName.Buffer = L"";
    Parameters.DomainName.Length = 0;
    Parameters.DomainName.MaximumLength = 2;
    Parameters.DnsDomainName.Buffer = L"";
    Parameters.DnsDomainName.Length = 0;
    Parameters.DnsDomainName.MaximumLength = 2;

    // If logon session data exists, load it

    if ( ERROR_SUCCESS != ( dwError = RegOpenKeyEx (
                               HKEY_LOCAL_MACHINE,
                               KERBEROS_TICKET_KEY,
                               0,
                               KEY_ALL_ACCESS,
                               &hRegKey ) ) )
    {
        DebugLog((DEB_ERROR, "Error opening KERBEROS_TICKET_KEY\n"));
        goto RestOfInit;
    }

    // get username size
    if ( ERROR_SUCCESS != ( dwError = RegQueryValueEx (
                               hRegKey,
                               KERBEROS_TICKET_USERNAME_KEY,
                               NULL,
                               &dwType,
                               NULL,
                               &dwSize )))
    {
        DebugLog((DEB_ERROR, "Error reading KERBEROS_TICKET_USERNAME_KEY size\n"));
        goto RestOfInit;
    }

    if (dwSize == 0 )
    {
        DebugLog((DEB_ERROR, "KERBEROS_TICKET_USERNAME_KEY contains 0 bytes\n"));
        goto RestOfInit;
    }

    pUserName = (LPWSTR) KerbAllocate(dwSize);

    if (pUserName == NULL)
    {
        DebugLog((DEB_ERROR, "Error allocing KERBEROS_TICKET_USERNAME_KEY \n"));
        goto RestOfInit;
    }
    // get username into LogonSession->PrimaryCredentials->Username
    if ( ERROR_SUCCESS != ( dwError = RegQueryValueEx (
                               hRegKey,
                               KERBEROS_TICKET_USERNAME_KEY,
                               NULL,
                               &dwType,
                               (PUCHAR) pUserName,
                               &dwSize )))
    {
        DebugLog((DEB_ERROR, "Error reading from KERBEROS_TICKET_USERNAME_KEY\n"));
        goto RestOfInit;
    }

    // get domainname
    if ( ERROR_SUCCESS != ( dwError = RegQueryValueEx (
                               hRegKey,
                               KERBEROS_TICKET_DOMAINNAME_KEY,
                               NULL,
                               &dwType,
                               NULL,
                               &dwSize )))
    {
        DebugLog((DEB_ERROR, "Error reading KERBEROS_TICKET_DOMAINNAME_KEY size\n"));
        goto RestOfInit;
    }
    if (dwSize == 0 )
    {
        DebugLog((DEB_ERROR, "KERBEROS_TICKET_DOMAINNAME_KEY contains 0 bytes\n"));
        goto RestOfInit;
    }

    pDomainName = (LPWSTR) KerbAllocate(dwSize);

    if (pDomainName == NULL)
    {
        DebugLog((DEB_ERROR, "Error allocing KERBEROS_TICKET_DOMAINNAME_KEY \n"));
        goto RestOfInit;
    }
    // get domainname into LogonSession->PrimaryCredentials->Domainname
    if ( ERROR_SUCCESS != ( dwError = RegQueryValueEx (
                               hRegKey,
                               KERBEROS_TICKET_DOMAINNAME_KEY,
                               NULL,
                               &dwType,
                               (PUCHAR) pDomainName,
                               &dwSize )))
    {
        DebugLog((DEB_ERROR, "Error reading from KERBEROS_TICKET_DOMAINNAME_KEY\n"));
        goto RestOfInit;
    }

    // get domainname into Parameters.DomainName
    Parameters.DomainName.Buffer = pDomainName;
    Parameters.DomainName.Length = (USHORT)dwSize;
    Parameters.DomainName.MaximumLength = (USHORT)dwSize;


    // get logon session data size
    if ( ERROR_SUCCESS != ( dwError = RegQueryValueEx (
                               hRegKey,
                               KERBEROS_TICKET_LOGONSESSION_KEY,
                               NULL,
                               &dwType,
                               NULL,
                               &dwSize )))
    {
        DebugLog((DEB_ERROR, "Error reading from KERBEROS_TICKET_LOGONSESSION_KEY\n"));
        goto RestOfInit;
    }

    if (dwSize == 0 )
    {
        DebugLog((DEB_ERROR, "KERBEROS_TICKET_LOGONSESSION_KEY contains 0 bytes\n"));
        goto RestOfInit;
    }

    RegLogonSession = (PKERB_LOGON_SESSION_CACHE) KerbAllocate(dwSize);

    if (RegLogonSession == NULL)
    {
        DebugLog((DEB_ERROR, "Error allocing KERBEROS_TICKET_LOGONSESSION_KEY \n"));
        goto RestOfInit;
    }
    // get logon session into LogonSession->PrimaryCredentials->Domainname
    if ( ERROR_SUCCESS != ( dwError = RegQueryValueEx (
                               hRegKey,
                               KERBEROS_TICKET_LOGONSESSION_KEY,
                               NULL,
                               &dwType,
                               (PUCHAR) RegLogonSession,
                               &dwSize )))
    {
        DebugLog((DEB_ERROR, "Error reading from KERBEROS_TICKET_LOGONSESSION_KEY\n"));
        goto RestOfInit;
    }


    if ( ERROR_SUCCESS != ( dwError = RegCloseKey ( hRegKey) ))
    {
        DebugLog((DEB_ERROR, "Error closing KERBEROS_TICKET_KEY\n"));
        goto RestOfInit;
    }

RestOfInit:

    Status = SpInitialize(1, &Parameters, &FunctionTable);

// Do the user mode init too
// Before we call SpInstanceInit, fill a table of functions that are
// imlemented locally. This is done so that the code does not look awful.
// Fill in dummy functions in case more functions are used so we don't
// av

    UserFunctionTable.FreeHeap = FreeLsaHeap;
    UserFunctionTable.AllocateHeap = AllocateLsaHeap;

    Status = SpInstanceInit(SECURITY_SUPPORT_PROVIDER_INTERFACE_VERSION,
                            &UserFunctionTable,
                            &ignored );


    // Now, copy the logon sessions (if they exist)
    // This is kina what KerbCreateLogonSession does, expect that we don't
    // have to build password list etc.

    if (RegLogonSession != NULL)
    {
        LUID LogonId;
        NTSTATUS Status;
        ULONG PasswordSize, EncryptKeySize, CredentialSize;
        ULONG Index;
        PUCHAR Base;
        UINT Offset;

       //
       // Allocate the new logon session
       //

       Status = NtAllocateLocallyUniqueId (&LogonId);

       if (!NT_SUCCESS(Status))
       {
           goto Cleanup;
       }

       Status = KerbAllocateLogonSession( &LogonSession );

       if (!NT_SUCCESS(Status))
       {
           goto Cleanup;
       }

       //
       // Fill in the logon session components
       //

       LogonSession->Lifetime = RegLogonSession->Lifetime;
       LogonSession->LogonSessionFlags = RegLogonSession->LogonSessionFlags;
       LogonSession->LogonId = LogonId;

       //
       // Munge RegLogonSession & ptrs for username & domainame
       //

       RegLogonSession->UserName.Buffer = (LPWSTR)((PUCHAR)RegLogonSession + (INT)(RegLogonSession->UserName.Buffer));

       RegLogonSession->DomainName.Buffer = (LPWSTR)((PUCHAR)RegLogonSession + (INT)(RegLogonSession->DomainName.Buffer));

       //
       // actually copy the username struct and alloc username.buffer
       //

       LogonSession->PrimaryCredentials.UserName.Buffer = (LPWSTR) KerbAllocate(RegLogonSession->UserName.MaximumLength);

       if (LogonSession->PrimaryCredentials.UserName.Buffer == NULL)
       {
            DebugLog((DEB_ERROR, "Error allocing KERBEROS_TICKET_LOGONSESSION_KEY \n"));
            goto Cleanup;
       }

       RtlCopyMemory(LogonSession->PrimaryCredentials.UserName.Buffer,
                     RegLogonSession->UserName.Buffer,
                     RegLogonSession->UserName.MaximumLength);

       Logon