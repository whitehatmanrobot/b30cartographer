   return(dwError);
}


DWORD
LdapDeleteS(
    HLDAP hLdapHandle,
    WCHAR *dn
    )
{
    DWORD dwError = 0;
    int ldaperr = 0;

    ldaperr = ldap_delete_s( hLdapHandle, dn );

    dwError = CheckAndSetExtendedError(hLdapHandle, ldaperr);

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\memory.h ===
#ifndef _MEMORY_H_INCLUDED_
#define _MEMORY_H_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif


LPVOID
ReallocPolMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
);

DWORD
AllocatePolString(
    LPWSTR pszString,
    LPWSTR * ppszNewString
    );

void
FreePolString(
    LPWSTR pszString
    );


#if DBG

extern LIST_ENTRY ADsMemList ;

extern CRITICAL_SECTION ADsMemCritSect ;

VOID InitPolMem(
    VOID
    ) ;

VOID AssertPolMemLeaks(
    VOID
    ) ;


VOID
DumpMemoryTracker();


#else

#define InitPolMem()
#define AssertPolMemLeaks()

#define DumpMemoryTracker()



#endif


#ifdef __cplusplus
}
#endif

/*
inline void * _CRTAPI1
operator new(size_t size)
{
    return AllocPolMem(size);
}

inline void  _CRTAPI1
operator delete(void * pv)
{
    FreePolMem(pv);
}*/


#endif // _MEMORY_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\memory.c ===
/*++


Copyright (c) 1990  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    This module provides all the memory management functions for all spooler
    components

Author:

    Krishna Ganugapati (KrishnaG) 03-Feb-1994

Revision History:

--*/

#include "precomp.h"

#define ADsAssert(x)    NULL

#define WORD_ALIGN_DOWN(addr) ((LPBYTE)((DWORD)addr &= ~1))

#define DWORD_ALIGN_UP(size) ((size+3)&~3)


#if DBG


DWORD dwMemLog = 0;

#define MAXDEPTH 10

typedef struct _ADSMEMTAG {
    DWORD Tag ;
    DWORD Size ;
    PVOID pvBackTrace[MAXDEPTH+1];
    LPSTR pszSymbol[MAXDEPTH+1];
    DWORD uDepth;
    LIST_ENTRY List ;
} ADSMEMTAG, *PADSMEMTAG ;

LIST_ENTRY       ADsMemList ;
DWORD            ADsMemCount ;
CRITICAL_SECTION ADsMemCritSect ;

/*++

Routine Description:

    This function initializes the ADs mem tracking code. Must be call
    during DLL load an ONLY during DLL load.

Arguments:

    None

Return Value:

    None.

--*/
VOID InitPolMem(
    VOID
)
{
    InitializeCriticalSection(&ADsMemCritSect) ;
    InitializeListHead(&ADsMemList) ;
    ADsMemCount = 0 ;
}

/*++

Routine Description:

    This function asserts that the mem list is empty on exit.

Arguments:

    None

Return Value:

    None.

--*/
VOID AssertPolMemLeaks(
    VOID
)
{
    ADsAssert(IsListEmpty(&ADsMemList)) ;
}

#endif

LPVOID
AllocPolMem(
    DWORD cb
)
/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    cb - The amount of memory to allocate

Return Value:

    NON-NULL - A pointer to the allocated memory

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
    return(LocalAlloc(LPTR, cb));

}

BOOL
FreePolMem(
   LPVOID pMem
)
{
    return(LocalFree(pMem) == NULL);
}

LPVOID
ReallocPolMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
)
{
    LPVOID pNewMem;

    pNewMem=AllocPolMem(cbNew);

    if (pOldMem && pNewMem) {
        memcpy(pNewMem, pOldMem, min(cbNew, cbOld));
        FreePolMem(pOldMem);
    }

    return pNewMem;
}

LPWSTR
AllocPolStr(
    LPCWSTR pStr
)
/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
   LPWSTR pMem;

   if (!pStr)
      return 0;

   if (pMem = (LPWSTR)AllocPolMem( wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR) ))
      wcscpy(pMem, pStr);

   return pMem;
}

BOOL
FreePolStr(
   LPWSTR pStr
)
{
   return pStr ? FreePolMem(pStr)
               : FALSE;
}

BOOL
ReallocPolStr(
   LPWSTR *ppStr,
   LPWSTR pStr
)
{
   FreePolStr(*ppStr);
   *ppStr=AllocPolStr(pStr);

   return TRUE;
}

DWORD
AllocatePolString(
    LPWSTR pszString,
    LPWSTR * ppszNewString
    )
{
    LPWSTR pszNewString = NULL;
    DWORD dwError = 0;

    pszNewString = AllocPolStr(pszString);

    if (!pszNewString) {
        dwError = GetLastError();
    }

    *ppszNewString = pszNewString;

    return(dwError);
}

void
FreePolString(
    LPWSTR pszString
    )
{
    if (pszString) {
        FreePolStr(pszString);
    }

    return;
}


DWORD
ReallocatePolMem(
    LPVOID * ppOldMem,
    DWORD cbOld,
    DWORD cbNew
    )
{
    DWORD dwError = 0;
    LPVOID pOldMem = NULL;
    LPVOID pNewMem = NULL;

    pOldMem = *ppOldMem;
    pNewMem = AllocPolMem(cbNew);

    if (!pNewMem) {
        dwError = ERROR_OUTOFMEMORY;
        return (dwError);
    }

    if (pOldMem && pNewMem) {
        memcpy(pNewMem, pOldMem, min(cbNew, cbOld));
        FreePolMem(pOldMem);
    }

    *ppOldMem = pNewMem;
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\persist.c ===
#include "precomp.h"

LPWSTR  gpszIpsecCacheKey = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Cache";


DWORD
CacheDirectorytoRegistry(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    )
{

    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecRegPolicyObject = NULL;

    //
    // Delete the existing cache.
    //

    DeleteRegistryCache();


    //
    // Create a copy of the directory policy in registry terms
    //


    dwError = CloneDirectoryPolicyObject(
                    pIpsecPolicyObject,
                    &pIpsecRegPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);



    //
    // Write the registry policy
    //


    dwError = PersistRegistryObject(
                    pIpsecRegPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

cleanup:

    if (pIpsecRegPolicyObject) {

        FreeIpsecPolicyObject(
            pIpsecRegPolicyObject
            );

    }

    return(dwError);

error:

    DeleteRegistryCache();

    goto cleanup;
}


DWORD
PersistRegistryObject(
    PIPSEC_POLICY_OBJECT pIpsecRegPolicyObject
    )
{
    DWORD dwError = 0;
    HKEY hRegistryKey = NULL;
    DWORD dwDisposition = 0;

    dwError = RegCreateKeyExW(
                    HKEY_LOCAL_MACHINE,
                    gpszIpsecCacheKey,
                    0,
                    NULL,
                    0,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hRegistryKey,
                    &dwDisposition
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecRegPolicyObject->ppIpsecFilterObjects) {

        dwError = PersistFilterObjects(
                            hRegistryKey,
                            pIpsecRegPolicyObject->ppIpsecFilterObjects,
                            pIpsecRegPolicyObject->NumberofFilters
                            );
        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (pIpsecRegPolicyObject->ppIpsecNegPolObjects) {

        dwError = PersistNegPolObjects(
                            hRegistryKey,
                            pIpsecRegPolicyObject->ppIpsecNegPolObjects,
                            pIpsecRegPolicyObject->NumberofNegPols
                            );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecRegPolicyObject->ppIpsecNFAObjects) {

        dwError = PersistNFAObjects(
                            hRegistryKey,
                            pIpsecRegPolicyObject->ppIpsecNFAObjects,
                            pIpsecRegPolicyObject->NumberofRulesReturned
                            );
        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (pIpsecRegPolicyObject->ppIpsecISAKMPObjects) {

        dwError = PersistISAKMPObjects(
                            hRegistryKey,
                            pIpsecRegPolicyObject->ppIpsecISAKMPObjects,
                            pIpsecRegPolicyObject->NumberofISAKMPs
                            );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = PersistPolicyObject(
                        hRegistryKey,
                        pIpsecRegPolicyObject
                        );

error:

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }


    return(dwError);
}



DWORD
PersistNegPolObjects(
    HKEY hRegistryKey,
    PIPSEC_NEGPOL_OBJECT *ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects
    )
{
    DWORD i = 0;
    DWORD dwError = 0;

    for (i = 0; i < dwNumNegPolObjects; i++) {

        dwError = PersistNegPolObject(
                            hRegistryKey,
                            *(ppIpsecNegPolObjects + i)
                            );
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    return(dwError);

}

DWORD
PersistFilterObjects(
    HKEY hRegistryKey,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects
    )
{
    DWORD i = 0;
    DWORD dwError = 0;


    for (i = 0; i < dwNumFilterObjects; i++) {

        dwError = PersistFilterObject(
                            hRegistryKey,
                            *(ppIpsecFilterObjects + i)
                            );
        BAIL_ON_WIN32_ERROR(dwError);
    }


error:

    return(dwError);

}


DWORD
PersistNFAObjects(
    HKEY hRegistryKey,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects,
    DWORD dwNumNFAObjects
    )
{
    DWORD i = 0;
    DWORD dwError = 0;

    for (i = 0; i < dwNumNFAObjects; i++) {

        dwError = PersistNFAObject(
                            hRegistryKey,
                            *(ppIpsecNFAObjects + i)
                            );
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    return(dwError);

}

DWORD
PersistISAKMPObjects(
    HKEY hRegistryKey,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects,
    DWORD dwNumISAKMPObjects
    )
{
    DWORD i = 0;
    DWORD dwError = 0;


    for (i = 0; i < dwNumISAKMPObjects; i++) {

        dwError = PersistISAKMPObject(
                            hRegistryKey,
                            *(ppIpsecISAKMPObjects + i)
                            );
        BAIL_ON_WIN32_ERROR(dwError);
    }


error:

    return(dwError);

}

DWORD
PersistPolicyObject(
    HKEY hRegistryKey,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    DWORD dwDisposition = 0;


    dwError = RegCreateKeyExW(
                    hRegistryKey,
                    pIpsecPolicyObject->pszIpsecOwnersReference,
                    0,
                    NULL,
                    0,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hRegKey,
                    &dwDisposition
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                   hRegKey,
                   L"ClassName",
                   0,
                   REG_SZ,
                   (LPBYTE) L"ipsecPolicy",
                   (wcslen(L"ipsecPolicy") + 1)*sizeof(WCHAR)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecPolicyObject->pszDescription) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"description",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecPolicyObject->pszDescription,
                        (wcslen(pIpsecPolicyObject->pszDescription) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);

    }
    else {
        (VOID) RegDeleteValueW(
                   hRegKey,
                   L"description"
                   );
    }

    if (pIpsecPolicyObject->pszIpsecOwnersReference) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"name",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecPolicyObject->pszIpsecOwnersReference,
                        (wcslen(pIpsecPolicyObject->pszIpsecOwnersReference) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecPolicyObject->pszIpsecName) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecName",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecPolicyObject->pszIpsecName,
                        (wcslen(pIpsecPolicyObject->pszIpsecName) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecPolicyObject->pszIpsecID) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecID",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecPolicyObject->pszIpsecID,
                        (wcslen(pIpsecPolicyObject->pszIpsecID) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }


    dwError = RegSetValueExW(
                    hRegKey,
                    L"ipsecDataType",
                    0,
                    REG_DWORD,
                    (LPBYTE)&pIpsecPolicyObject->dwIpsecDataType,
                    sizeof(DWORD)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecPolicyObject->pIpsecData) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecData",
                        0,
                        REG_BINARY,
                        pIpsecPolicyObject->pIpsecData,
                        pIpsecPolicyObject->dwIpsecDataLen
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecPolicyObject->pszIpsecISAKMPReference) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecISAKMPReference",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecPolicyObject->pszIpsecISAKMPReference,
                        (wcslen(pIpsecPolicyObject->pszIpsecISAKMPReference) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecPolicyObject->ppszIpsecNFAReferences) {


        dwError = RegWriteMultiValuedString(
                        hRegKey,
                        L"ipsecNFAReference",
                        pIpsecPolicyObject->ppszIpsecNFAReferences,
                        pIpsecPolicyObject->NumberofRules
                        );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    dwError = RegSetValueExW(
                    hRegKey,
                    L"whenChanged",
                    0,
                    REG_DWORD,
                    (LPBYTE)&pIpsecPolicyObject->dwWhenChanged,
                    sizeof(DWORD)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return(dwError);
}

DWORD
PersistNFAObject(
    HKEY hRegistryKey,
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    )
{

    HKEY hRegKey = NULL;
    DWORD dwError = 0;
    DWORD dwDisposition = 0;
    LPBYTE pMem = NULL;


    dwError = RegCreateKeyExW(
                    hRegistryKey,
                    pIpsecNFAObject->pszDistinguishedName,
                    0,
                    NULL,
                    0,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hRegKey,
                    &dwDisposition
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hRegKey,
                    L"ClassName",
                    0,
                    REG_SZ,
                    (LPBYTE) L"ipsecNFA",
                    (wcslen(L"ipsecNFA") + 1)*sizeof(WCHAR)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecNFAObject->pszDistinguishedName) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"name",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNFAObject->pszDistinguishedName,
                        (wcslen(pIpsecNFAObject->pszDistinguishedName) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNFAObject->pszIpsecName) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecName",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNFAObject->pszIpsecName,
                        (wcslen(pIpsecNFAObject->pszIpsecName) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNFAObject->pszDescription) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"description",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNFAObject->pszDescription,
                        (wcslen(pIpsecNFAObject->pszDescription) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);

    }
    else {
        (VOID) RegDeleteValueW(
                   hRegKey,
                   L"description"
                   );
    }

    if (pIpsecNFAObject->pszIpsecID) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecID",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNFAObject->pszIpsecID,
                        (wcslen(pIpsecNFAObject->pszIpsecID) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegSetValueExW(
                    hRegKey,
                    L"ipsecDataType",
                    0,
                    REG_DWORD,
                    (LPBYTE)&pIpsecNFAObject->dwIpsecDataType,
                    sizeof(DWORD)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecNFAObject->pIpsecData) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecData",
                        0,
                        REG_BINARY,
                        pIpsecNFAObject->pIpsecData,
                        pIpsecNFAObject->dwIpsecDataLen
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNFAObject->pszIpsecOwnersReference) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecOwnersReference",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNFAObject->pszIpsecOwnersReference,
                        (wcslen(pIpsecNFAObject->pszIpsecOwnersReference) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNFAObject->pszIpsecNegPolReference) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecNegotiationPolicyReference",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNFAObject->pszIpsecNegPolReference,
                        (wcslen(pIpsecNFAObject->pszIpsecNegPolReference) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNFAObject->pszIpsecFilterReference) {

        pMem = AllocPolMem(
                   (wcslen(pIpsecNFAObject->pszIpsecFilterReference) + 1 + 1)*sizeof(WCHAR)
                   );
        if (!pMem) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        memcpy(
            pMem,
            (LPBYTE) pIpsecNFAObject->pszIpsecFilterReference,
            (wcslen(pIpsecNFAObject->pszIpsecFilterReference) + 1)*sizeof(WCHAR)
            );

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecFilterReference",
                        0,
                        REG_MULTI_SZ,
                        pMem,
                        (wcslen(pIpsecNFAObject->pszIpsecFilterReference) + 1 + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);

        if (pMem) {
            FreePolMem(pMem);
        }

    }

    dwError = RegSetValueExW(
                    hRegKey,
                    L"whenChanged",
                    0,
                    REG_DWORD,
                    (LPBYTE)&pIpsecNFAObject->dwWhenChanged,
                    sizeof(DWORD)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hRegKey) {

        RegCloseKey(hRegKey);
    }

    return(dwError);
}


DWORD
PersistFilterObject(
    HKEY hRegistryKey,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    )
{
    HKEY hRegKey = NULL;
    DWORD dwError = 0;
    DWORD dwDisposition = 0;

    dwError = RegCreateKeyExW(
                    hRegistryKey,
                    pIpsecFilterObject->pszDistinguishedName,
                    0,
                    NULL,
                    0,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hRegKey,
                    &dwDisposition
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                   hRegKey,
                   L"ClassName",
                   0,
                   REG_SZ,
                   (LPBYTE) L"ipsecFilter",
                   (wcslen(L"ipsecFilter") + 1)*sizeof(WCHAR)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecFilterObject->pszDescription) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"description",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecFilterObject->pszDescription,
                        (wcslen(pIpsecFilterObject->pszDescription) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);

    }
    else {
        (VOID) RegDeleteValueW(
                   hRegKey,
                   L"description"
                   );
    }

    if (pIpsecFilterObject->pszDistinguishedName) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"name",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecFilterObject->pszDistinguishedName,
                        (wcslen(pIpsecFilterObject->pszDistinguishedName) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecFilterObject->pszIpsecName) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecName",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecFilterObject->pszIpsecName,
                        (wcslen(pIpsecFilterObject->pszIpsecName) + 1)* sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecFilterObject->pszIpsecID) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecID",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecFilterObject->pszIpsecID,
                        (wcslen(pIpsecFilterObject->pszIpsecID) + 1)* sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegSetValueExW(
                    hRegKey,
                    L"ipsecDataType",
                    0,
                    REG_DWORD,
                    (LPBYTE)&pIpsecFilterObject->dwIpsecDataType,
                    sizeof(DWORD)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecFilterObject->pIpsecData) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecData",
                        0,
                        REG_BINARY,
                        pIpsecFilterObject->pIpsecData,
                        pIpsecFilterObject->dwIpsecDataLen
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegSetValueExW(
                    hRegKey,
                    L"whenChanged",
                    0,
                    REG_DWORD,
                    (LPBYTE)&pIpsecFilterObject->dwWhenChanged,
                    sizeof(DWORD)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecFilterObject->ppszIpsecNFAReferences) {

        dwError = RegWriteMultiValuedString(
                        hRegKey,
                        L"ipsecOwnersReference",
                        pIpsecFilterObject->ppszIpsecNFAReferences,
                        pIpsecFilterObject->dwNFACount
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return(dwError);
}



DWORD
PersistNegPolObject(
    HKEY hRegistryKey,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    )
{
    DWORD dwError = 0;
    DWORD dwDisposition = 0;
    HKEY hRegKey = NULL;

    dwError = RegCreateKeyExW(
                    hRegistryKey,
                    pIpsecNegPolObject->pszDistinguishedName,
                    0,
                    NULL,
                    0,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hRegKey,
                    &dwDisposition
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                   hRegKey,
                   L"ClassName",
                   0,
                   REG_SZ,
                   (LPBYTE) L"ipsecNegotiationPolicy",
                   (wcslen(L"ipsecNegotiationPolicy") + 1)*sizeof(WCHAR)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecNegPolObject->pszDescription) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"description",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNegPolObject->pszDescription,
                        (wcslen(pIpsecNegPolObject->pszDescription) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);

    }
    else {
        (VOID) RegDeleteValueW(
                   hRegKey,
                   L"description"
                   );
    }

    if (pIpsecNegPolObject->pszDistinguishedName) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"name",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNegPolObject->pszDistinguishedName,
                        (wcslen(pIpsecNegPolObject->pszDistinguishedName) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (pIpsecNegPolObject->pszIpsecName) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecName",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNegPolObject->pszIpsecName,
                        (wcslen(pIpsecNegPolObject->pszIpsecName) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNegPolObject->pszIpsecID) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecID",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNegPolObject->pszIpsecID,
                        (wcslen(pIpsecNegPolObject->pszIpsecID) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNegPolObject->pszIpsecNegPolAction) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecNegotiationPolicyAction",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNegPolObject->pszIpsecNegPolAction,
                        (wcslen(pIpsecNegPolObject->pszIpsecNegPolAction) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNegPolObject->pszIpsecNegPolType) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecNegotiationPolicyType",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecNegPolObject->pszIpsecNegPolType,
                        (wcslen(pIpsecNegPolObject->pszIpsecNegPolType) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }


    dwError = RegSetValueExW(
                    hRegKey,
                    L"ipsecDataType",
                    0,
                    REG_DWORD,
                    (LPBYTE)&pIpsecNegPolObject->dwIpsecDataType,
                    sizeof(DWORD)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecNegPolObject->pIpsecData) {
        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecData",
                        0,
                        REG_BINARY,
                        pIpsecNegPolObject->pIpsecData,
                        pIpsecNegPolObject->dwIpsecDataLen
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNegPolObject->ppszIpsecNFAReferences) {

        dwError = RegWriteMultiValuedString(
                        hRegKey,
                        L"ipsecOwnersReference",
                        pIpsecNegPolObject->ppszIpsecNFAReferences,
                        pIpsecNegPolObject->dwNFACount
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegSetValueExW(
                    hRegKey,
                    L"whenChanged",
                    0,
                    REG_DWORD,
                    (LPBYTE)&pIpsecNegPolObject->dwWhenChanged,
                    sizeof(DWORD)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }


    return(dwError);
}

DWORD
PersistISAKMPObject(
    HKEY hRegistryKey,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    )
{
    HKEY hRegKey = NULL;
    DWORD dwError = 0;
    DWORD dwDisposition = 0;

    dwError = RegCreateKeyExW(
                    hRegistryKey,
                    pIpsecISAKMPObject->pszDistinguishedName,
                    0,
                    NULL,
                    0,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hRegKey,
                    &dwDisposition
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                   hRegKey,
                   L"ClassName",
                   0,
                   REG_SZ,
                   (LPBYTE) L"ipsecISAKMPPolicy",
                   (wcslen(L"ipsecISAKMPPolicy") + 1)*sizeof(WCHAR)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecISAKMPObject->pszDistinguishedName) {
        dwError = RegSetValueExW(
                        hRegKey,
                        L"name",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecISAKMPObject->pszDistinguishedName,
                        (wcslen(pIpsecISAKMPObject->pszDistinguishedName) + 1)*sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecISAKMPObject->pszIpsecName) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecName",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecISAKMPObject->pszIpsecName,
                        (wcslen(pIpsecISAKMPObject->pszIpsecName) + 1)* sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecISAKMPObject->pszIpsecID) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecID",
                        0,
                        REG_SZ,
                        (LPBYTE)pIpsecISAKMPObject->pszIpsecID,
                        (wcslen(pIpsecISAKMPObject->pszIpsecID) + 1)* sizeof(WCHAR)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegSetValueExW(
                    hRegKey,
                    L"ipsecDataType",
                    0,
                    REG_DWORD,
                    (LPBYTE)&pIpsecISAKMPObject->dwIpsecDataType,
                    sizeof(DWORD)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecISAKMPObject->pIpsecData) {

        dwError = RegSetValueExW(
                        hRegKey,
                        L"ipsecData",
                        0,
                        REG_BINARY,
                        pIpsecISAKMPObject->pIpsecData,
                        pIpsecISAKMPObject->dwIpsecDataLen
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegSetValueExW(
                    hRegKey,
                    L"whenChanged",
                    0,
                    REG_DWORD,
                    (LPBYTE)&pIpsecISAKMPObject->dwWhenChanged,
                    sizeof(DWORD)
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    if (pIpsecISAKMPObject->ppszIpsecNFAReferences) {

        dwError = RegWriteMultiValuedString(
                        hRegKey,
                        L"ipsecOwnersReference",
                        pIpsecISAKMPObject->ppszIpsecNFAReferences,
                        pIpsecISAKMPObject->dwNFACount
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }


error:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return(dwError);
}





DWORD
CloneDirectoryPolicyObject(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    PIPSEC_POLICY_OBJECT * ppIpsecRegPolicyObject
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecRegPolicyObject = NULL;

    //
    // Clone Filter Objects
    //

    pIpsecRegPolicyObject = (PIPSEC_POLICY_OBJECT)AllocPolMem(
                                        sizeof(IPSEC_POLICY_OBJECT)
                                        );
    if (!pIpsecRegPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecPolicyObject->ppIpsecFilterObjects) {

        dwError = CloneDirectoryFilterObjects(
                            pIpsecPolicyObject->ppIpsecFilterObjects,
                            pIpsecPolicyObject->NumberofFilters,
                            &pIpsecRegPolicyObject->ppIpsecFilterObjects
                            );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecRegPolicyObject->NumberofFilters = pIpsecPolicyObject->NumberofFilters;
    }

    //
    // Clone NegPol Objects
    //

    if (pIpsecPolicyObject->ppIpsecNegPolObjects) {

        dwError = CloneDirectoryNegPolObjects(
                            pIpsecPolicyObject->ppIpsecNegPolObjects,
                            pIpsecPolicyObject->NumberofNegPols,
                            &pIpsecRegPolicyObject->ppIpsecNegPolObjects
                            );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecRegPolicyObject->NumberofNegPols = pIpsecPolicyObject->NumberofNegPols;
    }


    //
    // Clone NFA Objects
    //

    if (pIpsecPolicyObject->ppIpsecNFAObjects) {

        dwError = CloneDirectoryNFAObjects(
                            pIpsecPolicyObject->ppIpsecNFAObjects,
                            pIpsecPolicyObject->NumberofRulesReturned,
                            &pIpsecRegPolicyObject->ppIpsecNFAObjects
                            );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecRegPolicyObject->NumberofRules = pIpsecPolicyObject->NumberofRules;
        pIpsecRegPolicyObject->NumberofRulesReturned = pIpsecPolicyObject->NumberofRulesReturned;
    }

    //
    // Clone ISAKMP Objects
    //

    if (pIpsecPolicyObject->ppIpsecISAKMPObjects) {

        dwError = CloneDirectoryISAKMPObjects(
                            pIpsecPolicyObject->ppIpsecISAKMPObjects,
                            pIpsecPolicyObject->NumberofISAKMPs,
                            &pIpsecRegPolicyObject->ppIpsecISAKMPObjects
                            );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecRegPolicyObject->NumberofISAKMPs = pIpsecPolicyObject->NumberofISAKMPs;
    }

    //
    // Now copy the rest of the data in the object
    //

    if (pIpsecPolicyObject->pszIpsecOwnersReference) {

        dwError = CopyPolicyDSToRegString(
                        pIpsecPolicyObject->pszIpsecOwnersReference,
                        &pIpsecRegPolicyObject->pszIpsecOwnersReference
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecPolicyObject->pszIpsecName) {

        pIpsecRegPolicyObject->pszIpsecName = AllocPolStr(
                                            pIpsecPolicyObject->pszIpsecName
                                            );
        if (!pIpsecRegPolicyObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecPolicyObject->pszIpsecID) {

        pIpsecRegPolicyObject->pszIpsecID = AllocPolStr(
                                            pIpsecPolicyObject->pszIpsecID
                                            );
        if (!pIpsecRegPolicyObject->pszIpsecID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecPolicyObject->pszIpsecISAKMPReference) {

        dwError = CopyISAKMPDSToFQRegString(
                        pIpsecPolicyObject->pszIpsecISAKMPReference,
                        &pIpsecRegPolicyObject->pszIpsecISAKMPReference
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pIpsecRegPolicyObject->dwIpsecDataType = pIpsecPolicyObject->dwIpsecDataType;

    if (pIpsecPolicyObject->pIpsecData) {

        dwError = CopyBinaryValue(
                            pIpsecPolicyObject->pIpsecData,
                            pIpsecPolicyObject->dwIpsecDataLen,
                            &pIpsecRegPolicyObject->pIpsecData
                            );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecRegPolicyObject->dwIpsecDataLen = pIpsecPolicyObject->dwIpsecDataLen;
    }



    if (pIpsecPolicyObject->ppszIpsecNFAReferences) {

        dwError = CloneNFAReferencesDSToRegistry(
                        pIpsecPolicyObject->ppszIpsecNFAReferences,
                        pIpsecPolicyObject->NumberofRules,
                        &(pIpsecRegPolicyObject->ppszIpsecNFAReferences),
                        &(pIpsecRegPolicyObject->NumberofRules)
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecPolicyObject->pszDescription) {

        pIpsecRegPolicyObject->pszDescription = AllocPolStr(
                                                pIpsecPolicyObject->pszDescription
                                                );
        if (!pIpsecRegPolicyObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    pIpsecRegPolicyObject->dwWhenChanged = pIpsecPolicyObject->dwWhenChanged;

    *ppIpsecRegPolicyObject = pIpsecRegPolicyObject;

    return(dwError);

error:

    if (pIpsecRegPolicyObject) {
        FreeIpsecPolicyObject(
                pIpsecRegPolicyObject
                );

    }

    *ppIpsecRegPolicyObject = NULL;

    return(dwError);
}



DWORD
CloneDirectoryNFAObjects(
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects,
    DWORD dwNumNFAObjects,
    PIPSEC_NFA_OBJECT ** pppIpsecRegNFAObjects
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_OBJECT * ppIpsecRegNFAObjects = NULL;
    PIPSEC_NFA_OBJECT pIpsecRegNFAObject = NULL;

    if (dwNumNFAObjects) {
        ppIpsecRegNFAObjects = (PIPSEC_NFA_OBJECT *)AllocPolMem(
                                        dwNumNFAObjects*sizeof(PIPSEC_NFA_OBJECT)
                                        );
        if (!ppIpsecRegNFAObjects) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumNFAObjects; i++) {

        dwError = CloneDirectoryNFAObject(
                            *(ppIpsecNFAObjects + i),
                            &pIpsecRegNFAObject
                            );
        BAIL_ON_WIN32_ERROR(dwError);

        *(ppIpsecRegNFAObjects + i) = pIpsecRegNFAObject;
    }


    *pppIpsecRegNFAObjects = ppIpsecRegNFAObjects;
    return(dwError);

error:

    if (ppIpsecRegNFAObjects) {
        FreeIpsecNFAObjects(
                ppIpsecRegNFAObjects,
                i
                );
    }

    *pppIpsecRegNFAObjects = NULL;
    return(dwError);
}


DWORD
CloneDirectoryFilterObjects(
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects,
    PIPSEC_FILTER_OBJECT ** pppIpsecRegFilterObjects
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_FILTER_OBJECT * ppIpsecRegFilterObjects = NULL;
    PIPSEC_FILTER_OBJECT pIpsecRegFilterObject = NULL;


    if (dwNumFilterObjects) {
        ppIpsecRegFilterObjects = (PIPSEC_FILTER_OBJECT *)AllocPolMem(
                                        dwNumFilterObjects*sizeof(PIPSEC_FILTER_OBJECT)
                                        );
       if (!ppIpsecRegFilterObjects) {
           dwError = ERROR_OUTOFMEMORY;
           BAIL_ON_WIN32_ERROR(dwError);
       }
    }

    for (i = 0; i < dwNumFilterObjects; i++) {

        dwError = CloneDirectoryFilterObject(
                            *(ppIpsecFilterObjects + i),
                            &pIpsecRegFilterObject
                            );
        BAIL_ON_WIN32_ERROR(dwError);

        *(ppIpsecRegFilterObjects + i) = pIpsecRegFilterObject;
    }


    *pppIpsecRegFilterObjects = ppIpsecRegFilterObjects;
    return(dwError);

error:

    if (ppIpsecRegFilterObjects) {
        FreeIpsecFilterObjects(
                ppIpsecRegFilterObjects,
                i
                );
    }

    *pppIpsecRegFilterObjects = NULL;
    return(dwError);
}

DWORD
CloneDirectoryISAKMPObjects(
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects,
    DWORD dwNumISAKMPObjects,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecRegISAKMPObjects
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_ISAKMP_OBJECT * ppIpsecRegISAKMPObjects = NULL;
    PIPSEC_ISAKMP_OBJECT pIpsecRegISAKMPObject = NULL;

    if (dwNumISAKMPObjects) {
        ppIpsecRegISAKMPObjects = (PIPSEC_ISAKMP_OBJECT *)AllocPolMem(
                                        dwNumISAKMPObjects*sizeof(PIPSEC_ISAKMP_OBJECT)
                                        );
        if (!ppIpsecRegISAKMPObjects) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumISAKMPObjects; i++) {

        dwError = CloneDirectoryISAKMPObject(
                            *(ppIpsecISAKMPObjects + i),
                            &pIpsecRegISAKMPObject
                            );
        BAIL_ON_WIN32_ERROR(dwError);

        *(ppIpsecRegISAKMPObjects + i) = pIpsecRegISAKMPObject;
    }


    *pppIpsecRegISAKMPObjects = ppIpsecRegISAKMPObjects;
    return(dwError);

error:

    if (ppIpsecRegISAKMPObjects) {
        FreeIpsecISAKMPObjects(
                ppIpsecRegISAKMPObjects,
                i
                );
    }

    *pppIpsecRegISAKMPObjects = NULL;
    return(dwError);
}


DWORD
CloneDirectoryNegPolObjects(
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecRegNegPolObjects
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NEGPOL_OBJECT * ppIpsecRegNegPolObjects = NULL;
    PIPSEC_NEGPOL_OBJECT pIpsecRegNegPolObject = NULL;

    if (dwNumNegPolObjects) {
        ppIpsecRegNegPolObjects = (PIPSEC_NEGPOL_OBJECT *)AllocPolMem(
                                        dwNumNegPolObjects*sizeof(PIPSEC_NEGPOL_OBJECT)
                                        );
        if (!ppIpsecRegNegPolObjects) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumNegPolObjects; i++) {

        dwError = CloneDirectoryNegPolObject(
                            *(ppIpsecNegPolObjects + i),
                            &pIpsecRegNegPolObject
                            );
        BAIL_ON_WIN32_ERROR(dwError);

        *(ppIpsecRegNegPolObjects + i) = pIpsecRegNegPolObject;
    }


    *pppIpsecRegNegPolObjects = ppIpsecRegNegPolObjects;
    return(dwError);

error:

    if (ppIpsecRegNegPolObjects) {
        FreeIpsecNegPolObjects(
                ppIpsecRegNegPolObjects,
                i
                );
    }

    *pppIpsecRegNegPolObjects = NULL;
    return(dwError);
}


DWORD
CloneDirectoryFilterObject(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PIPSEC_FILTER_OBJECT * ppIpsecRegFilterObject
    )
{

    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecRegFilterObject = NULL;

    pIpsecRegFilterObject = (PIPSEC_FILTER_OBJECT)AllocPolMem(
                                        sizeof(IPSEC_FILTER_OBJECT)
                                        );
    if (!pIpsecRegFilterObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecFilterObject->pszDistinguishedName) {
        dwError = CopyFilterDSToRegString(
                        pIpsecFilterObject->pszDistinguishedName,
                        &pIpsecRegFilterObject->pszDistinguishedName
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecFilterObject->pszDescription) {
        pIpsecRegFilterObject->pszDescription = AllocPolStr(
                                            pIpsecFilterObject->pszDescription
                                            );
        if (!pIpsecRegFilterObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecFilterObject->pszIpsecName) {
        pIpsecRegFilterObject->pszIpsecName = AllocPolStr(
                                            pIpsecFilterObject->pszIpsecName
                                            );
        if (!pIpsecRegFilterObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecFilterObject->pszIpsecID) {
        pIpsecRegFilterObject->pszIpsecID = AllocPolStr(
                                            pIpsecFilterObject->pszIpsecID
                                            );
        if (!pIpsecRegFilterObject->pszIpsecID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    pIpsecRegFilterObject->dwIpsecDataType = pIpsecFilterObject->dwIpsecDataType;

    if (pIpsecFilterObject->pIpsecData) {

        dwError = CopyBinaryValue(
                            pIpsecFilterObject->pIpsecData,
                            pIpsecFilterObject->dwIpsecDataLen,
                            &pIpsecRegFilterObject->pIpsecData
                            );
        BAIL_ON_WIN32_ERROR(dwError);

        pIpsecRegFilterObject->dwIpsecDataLen = pIpsecFilterObject->dwIpsecDataLen;
    }


    if (pIpsecFilterObject->ppszIpsecNFAReferences) {

        dwError = CloneNFAReferencesDSToRegistry(
                        pIpsecFilterObject->ppszIpsecNFAReferences,
                        pIpsecFilterObject->dwNFACount,
                        &pIpsecRegFilterObject->ppszIpsecNFAReferences,
                        &pIpsecRegFilterObject->dwNFACount
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }


    pIpsecRegFilterObject->dwWhenChanged = pIpsecFilterObject->dwWhenChanged;

    *ppIpsecRegFilterObject = pIpsecRegFilterObject;

    return(dwError);

error:

    if (pIpsecRegFilterObject) {
        FreeIpsecFilterObject(pIpsecRegFilterObject);
    }

    *ppIpsecRegFilterObject = NULL;

    return(dwError);
}


DWORD
CloneDirectoryNegPolObject(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PIPSEC_NEGPOL_OBJECT * ppIpsecRegNegPolObject
    )
{
    DWORD dwError = 0;

    PIPSEC_NEGPOL_OBJECT pIpsecRegNegPolObject = NULL;

    pIpsecRegNegPolObject = (PIPSEC_NEGPOL_OBJECT)AllocPolMem(
                                        sizeof(IPSEC_NEGPOL_OBJECT)
                                        );
    if (!pIpsecRegNegPolObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNegPolObject->pszDistinguishedName) {

        dwError = CopyNegPolDSToRegString(
                        pIpsecNegPolObject->pszDistinguishedName,
                        &pIpsecRegNegPolObject->pszDistinguishedName
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNegPolObject->pszIpsecName) {
        pIpsecRegNegPolObject->pszIpsecName = AllocPolStr(
                                            pIpsecNegPolObject->pszIpsecName
                                            );
        if (!pIpsecRegNegPolObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNegPolObject->pszDescription) {
        pIpsecRegNegPolObject->pszDescription = AllocPolStr(
                                            pIpsecNegPolObject->pszDescription
                                            );
        if (!pIpsecRegNegPolObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNegPolObject->pszIpsecID) {
        pIpsecRegNegPolObject->pszIpsecID = AllocPolStr(
                                            pIpsecNegPolObject->pszIpsecID
                                            );
        if (!pIpsecRegNegPolObject->pszIpsecID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    pIpsecRegNegPolObject->dwIpsecDataType = pIpsecNegPolObject->dwIpsecDataType;

    if (pIpsecNegPolObject->pIpsecData) {

        dwError = CopyBinaryValue(
                            pIpsecNegPolObject->pIpsecData,
                            pIpsecNegPolObject->dwIpsecDataLen,
                            &pIpsecRegNegPolObject->pIpsecData
                            );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecRegNegPolObject->dwIpsecDataLen = pIpsecNegPolObject->dwIpsecDataLen;
    }

    if (pIpsecNegPolObject->pszIpsecNegPolAction) {

        pIpsecRegNegPolObject->pszIpsecNegPolAction = AllocPolStr(
                                            pIpsecNegPolObject->pszIpsecNegPolAction
                                            );
        if (!pIpsecRegNegPolObject->pszIpsecNegPolAction) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNegPolObject->pszIpsecNegPolType) {

        pIpsecRegNegPolObject->pszIpsecNegPolType = AllocPolStr(
                                            pIpsecNegPolObject->pszIpsecNegPolType
                                            );
        if (!pIpsecRegNegPolObject->pszIpsecNegPolType) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }


    if (pIpsecNegPolObject->ppszIpsecNFAReferences) {

        dwError = CloneNFAReferencesDSToRegistry(
                        pIpsecNegPolObject->ppszIpsecNFAReferences,
                        pIpsecNegPolObject->dwNFACount,
                        &pIpsecRegNegPolObject->ppszIpsecNFAReferences,
                        &pIpsecRegNegPolObject->dwNFACount
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pIpsecRegNegPolObject->dwWhenChanged = pIpsecNegPolObject->dwWhenChanged;

    *ppIpsecRegNegPolObject = pIpsecRegNegPolObject;

    return(dwError);

error:

    if (pIpsecRegNegPolObject) {
        FreeIpsecNegPolObject(pIpsecRegNegPolObject);
    }

    *ppIpsecRegNegPolObject = NULL;

    return(dwError);
}

DWORD
CloneDirectoryNFAObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_NFA_OBJECT * ppIpsecRegNFAObject
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_OBJECT pIpsecRegNFAObject = NULL;


    pIpsecRegNFAObject = (PIPSEC_NFA_OBJECT)AllocPolMem(
                                        sizeof(IPSEC_NFA_OBJECT)
                                        );
    if (!pIpsecRegNFAObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (pIpsecNFAObject->pszDistinguishedName) {

        dwError = CopyNFADSToRegString(
                        pIpsecNFAObject->pszDistinguishedName,
                        &pIpsecRegNFAObject->pszDistinguishedName
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (pIpsecNFAObject->pszIpsecName) {

        pIpsecRegNFAObject->pszIpsecName = AllocPolStr(
                                            pIpsecNFAObject->pszIpsecName
                                            );
        if (!pIpsecRegNFAObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNFAObject->pszDescription) {

        pIpsecRegNFAObject->pszDescription = AllocPolStr(
                                            pIpsecNFAObject->pszDescription
                                            );
        if (!pIpsecRegNFAObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNFAObject->pszIpsecID) {

        pIpsecRegNFAObject->pszIpsecID = AllocPolStr(
                                            pIpsecNFAObject->pszIpsecID
                                            );
        if (!pIpsecRegNFAObject->pszIpsecID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }


    pIpsecRegNFAObject->dwIpsecDataType = pIpsecNFAObject->dwIpsecDataType;

    if (pIpsecNFAObject->pIpsecData) {

        dwError = CopyBinaryValue(
                            pIpsecNFAObject->pIpsecData,
                            pIpsecNFAObject->dwIpsecDataLen,
                            &pIpsecRegNFAObject->pIpsecData
                            );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecRegNFAObject->dwIpsecDataLen = pIpsecNFAObject->dwIpsecDataLen;
    }


    if (pIpsecNFAObject->pszIpsecOwnersReference) {

        dwError = CopyPolicyDSToFQRegString(
                        pIpsecNFAObject->pszIpsecOwnersReference,
                        &pIpsecRegNFAObject->pszIpsecOwnersReference
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNFAObject->pszIpsecFilterReference) {

        dwError = CopyFilterDSToFQRegString(
                        pIpsecNFAObject->pszIpsecFilterReference,
                        &pIpsecRegNFAObject->pszIpsecFilterReference
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNFAObject->pszIpsecNegPolReference) {

        dwError = CopyNegPolDSToFQRegString(
                        pIpsecNFAObject->pszIpsecNegPolReference,
                        &pIpsecRegNFAObject->pszIpsecNegPolReference
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pIpsecRegNFAObject->dwWhenChanged = pIpsecNFAObject->dwWhenChanged;


    *ppIpsecRegNFAObject = pIpsecRegNFAObject;

    return(dwError);

error:

    if (pIpsecRegNFAObject) {
        FreeIpsecNFAObject(pIpsecRegNFAObject);
    }

    *ppIpsecRegNFAObject = NULL;

    return(dwError);
}

DWORD
CloneDirectoryISAKMPObject(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PIPSEC_ISAKMP_OBJECT * ppIpsecRegISAKMPObject
    )
{

    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecRegISAKMPObject = NULL;

    pIpsecRegISAKMPObject = (PIPSEC_ISAKMP_OBJECT)AllocPolMem(
                                        sizeof(IPSEC_ISAKMP_OBJECT)
                                        );
    if (!pIpsecRegISAKMPObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecISAKMPObject->pszDistinguishedName) {

        dwError = CopyISAKMPDSToRegString(
                        pIpsecISAKMPObject->pszDistinguishedName,
                        &pIpsecRegISAKMPObject->pszDistinguishedName
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (pIpsecISAKMPObject->pszIpsecName) {

        pIpsecRegISAKMPObject->pszIpsecName = AllocPolStr(
                                            pIpsecISAKMPObject->pszIpsecName
                                            );
        if (!pIpsecRegISAKMPObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }


    if (pIpsecISAKMPObject->pszIpsecID) {

        pIpsecRegISAKMPObject->pszIpsecID = AllocPolStr(
                                            pIpsecISAKMPObject->pszIpsecID
                                            );
        if (!pIpsecRegISAKMPObject->pszIpsecID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    pIpsecRegISAKMPObject->dwIpsecDataType = pIpsecISAKMPObject->dwIpsecDataType;


    if (pIpsecISAKMPObject->pIpsecData) {

        dwError = CopyBinaryValue(
                            pIpsecISAKMPObject->pIpsecData,
                            pIpsecISAKMPObject->dwIpsecDataLen,
                            &pIpsecRegISAKMPObject->pIpsecData
                            );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pIpsecRegISAKMPObject->dwIpsecDataLen = pIpsecISAKMPObject->dwIpsecDataLen;


    if (pIpsecISAKMPObject->ppszIpsecNFAReferences) {

        dwError = CloneNFAReferencesDSToRegistry(
                        pIpsecISAKMPObject->ppszIpsecNFAReferences,
                        pIpsecISAKMPObject->dwNFACount,
                        &pIpsecRegISAKMPObject->ppszIpsecNFAReferences,
                        &pIpsecRegISAKMPObject->dwNFACount
                        );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pIpsecRegISAKMPObject->dwWhenChanged = pIpsecISAKMPObject->dwWhenChanged;

    *ppIpsecRegISAKMPObject = pIpsecRegISAKMPObject;

    return(dwError);

error:

    if (pIpsecRegISAKMPObject) {
        FreeIpsecISAKMPObject(pIpsecRegISAKMPObject);
    }

    *ppIpsecRegISAKMPObject = NULL;

    return(dwError);
}


DWORD
CopyBinaryValue(
    LPBYTE pMem,
    DWORD dwMemSize,
    LPBYTE * ppNewMem
    )
{
    LPBYTE pNewMem = NULL;
    DWORD dwError = 0;


    pNewMem = (LPBYTE)AllocPolMem(dwMemSize);
    if (!pNewMem) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(pNewMem, pMem, dwMemSize);


    *ppNewMem = pNewMem;

    return(dwError);

error:

    if (pNewMem) {

        FreePolMem(pNewMem);
    }

    *ppNewMem = NULL;

    return(dwError);
}


DWORD
CopyFilterDSToFQRegString(
    LPWSTR pszFilterDN,
    LPWSTR * ppszFilterName
    )
{

    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszFilterName = NULL;
    DWORD dwStringSize = 0;

    dwError = ComputePrelimCN(
                    pszFilterDN,
                    szCommonName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
                    szCommonName,
                    &pszGuidName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwStringSize = wcslen(gpszIpsecCacheKey);
    dwStringSize += 1;
    dwStringSize += wcslen(pszGuidName);
    dwStringSize += 1;

    pszFilterName = (LPWSTR)AllocPolMem(dwStringSize*sizeof(WCHAR));
    if (!pszFilterName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    wcscpy(pszFilterName, gpszIpsecCacheKey);
    wcscat(pszFilterName, L"\\");
    wcscat(pszFilterName, pszGuidName);

    *ppszFilterName = pszFilterName;

    return(dwError);

error:

    *ppszFilterName = NULL;
    return(dwError);

}


DWORD
CopyNFADSToFQRegString(
    LPWSTR pszNFADN,
    LPWSTR * ppszNFAName
    )
{

    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszNFAName = NULL;
    DWORD dwStringSize = 0;

    dwError = ComputePrelimCN(
                    pszNFADN,
                    szCommonName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
                    szCommonName,
                    &pszGuidName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwStringSize = wcslen(gpszIpsecCacheKey);
    dwStringSize += 1;
    dwStringSize += wcslen(pszGuidName);
    dwStringSize += 1;

    pszNFAName = (LPWSTR)AllocPolMem(dwStringSize*sizeof(WCHAR));
    if (!pszNFAName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    wcscpy(pszNFAName, gpszIpsecCacheKey);
    wcscat(pszNFAName, L"\\");
    wcscat(pszNFAName, pszGuidName);


    *ppszNFAName = pszNFAName;

    return(dwError);

error:

    *ppszNFAName = NULL;
    return(dwError);

}



DWORD
CopyNegPolDSToFQRegString(
    LPWSTR pszNegPolDN,
    LPWSTR * ppszNegPolName
    )
{

    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszNegPolName = NULL;
    DWORD dwStringSize = 0;

    dwError = ComputePrelimCN(
                    pszNegPolDN,
                    szCommonName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
                    szCommonName,
                    &pszGuidName
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    dwStringSize = wcslen(gpszIpsecCacheKey);
    dwStringSize += 1;
    dwStringSize += wcslen(pszGuidName);
    dwStringSize += 1;

    pszNegPolName = (LPWSTR)AllocPolMem(dwStringSize*sizeof(WCHAR));
    if (!pszNegPolName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    wcscpy(pszNegPolName, gpszIpsecCacheKey);
    wcscat(pszNegPolName, L"\\");
    wcscat(pszNegPolName, pszGuidName);

    *ppszNegPolName = pszNegPolName;

    return(dwError);

error:

    *ppszNegPolName = NULL;
    return(dwError);

}


DWORD
CopyPolicyDSToFQRegString(
    LPWSTR pszPolicyDN,
    LPWSTR * ppszPolicyName
    )
{

    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszPolicyName = NULL;
    DWORD dwStringSize = 0;

    dwError = ComputePrelimCN(
                    pszPolicyDN,
                    szCommonName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
                    szCommonName,
                    &pszGuidName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwStringSize = wcslen(gpszIpsecCacheKey);
    dwStringSize += 1;
    dwStringSize += wcslen(pszGuidName);
    dwStringSize += 1;

    pszPolicyName = (LPWSTR)AllocPolMem(dwStringSize*sizeof(WCHAR));
    if (!pszPolicyName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    wcscpy(pszPolicyName, gpszIpsecCacheKey);
    wcscat(pszPolicyName, L"\\");
    wcscat(pszPolicyName, pszGuidName);

    *ppszPolicyName = pszPolicyName;

    return(dwError);

error:

    *ppszPolicyName = NULL;
    return(dwError);

}

DWORD
CopyISAKMPDSToFQRegString(
    LPWSTR pszISAKMPDN,
    LPWSTR * ppszISAKMPName
    )
{

    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszISAKMPName = NULL;
    DWORD dwStringSize = 0;

    dwError = ComputePrelimCN(
                    pszISAKMPDN,
                    szCommonName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
                    szCommonName,
                    &pszGuidName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwStringSize = wcslen(gpszIpsecCacheKey);
    dwStringSize += 1;
    dwStringSize += wcslen(pszGuidName);
    dwStringSize += 1;

    pszISAKMPName = (LPWSTR)AllocPolMem(dwStringSize*sizeof(WCHAR));
    if (!pszISAKMPName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    wcscpy(pszISAKMPName, gpszIpsecCacheKey);
    wcscat(pszISAKMPName, L"\\");
    wcscat(pszISAKMPName, pszGuidName);


    *ppszISAKMPName = pszISAKMPName;

    return(dwError);

error:

    *ppszISAKMPName = NULL;
    return(dwError);

}


DWORD
ComputeGUIDName(
    LPWSTR szCommonName,
    LPWSTR * ppszGuidName
    )
{
    LPWSTR pszGuidName = NULL;
    DWORD dwError = 0;

    pszGuidName = wcschr(szCommonName, L'=');
    if (!pszGuidName) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszGuidName = (pszGuidName + 1);

    return(dwError);

error:

    *ppszGuidName = NULL;

    return(dwError);
}



DWORD
CloneNFAReferencesDSToRegistry(
    LPWSTR * ppszIpsecNFAReferences,
    DWORD dwNFACount,
    LPWSTR * * pppszIpsecRegNFAReferences,
    PDWORD pdwRegNFACount
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    LPWSTR * ppszIpsecRegNFAReferences = NULL;

    ppszIpsecRegNFAReferences = (LPWSTR *)AllocPolMem(
                                        sizeof(LPWSTR)*dwNFACount
                                        );
    if (!ppszIpsecRegNFAReferences) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwNFACount; i++) {


        dwError = CopyNFADSToFQRegString(
                        *(ppszIpsecNFAReferences + i),
                        (ppszIpsecRegNFAReferences + i)
                        );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    *pppszIpsecRegNFAReferences = ppszIpsecRegNFAReferences;
    *pdwRegNFACount = dwNFACount;

    return(dwError);

error:

    if (ppszIpsecRegNFAReferences) {
        FreeNFAReferences(
                    ppszIpsecRegNFAReferences,
                    i
                    );

    }

    *pppszIpsecRegNFAReferences = NULL;
    *pdwRegNFACount = 0;

    return(dwError);

}

DWORD
DeleteRegistryCache(
    )
{
    DWORD dwError = 0;
    HKEY hParentKey = NULL;
    WCHAR lpszName[MAX_PATH];
    DWORD dwSize = 0;

    dwError = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    gpszIpsecCacheKey,
                    0,
                    KEY_ALL_ACCESS,
                    &hParentKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    memset(lpszName, 0, sizeof(WCHAR)*MAX_PATH);
    dwSize =  MAX_PATH;

    while((RegEnumKeyExW(hParentKey, 0, lpszName,
                    &dwSize, NULL,
                    NULL, NULL,NULL)) == ERROR_SUCCESS) {

        dwError = RegDeleteKeyW(
                        hParentKey,
                        lpszName
                        );
        if (dwError != ERROR_SUCCESS) {
            break;
        }


        memset(lpszName, 0, sizeof(WCHAR)*MAX_PATH);
        dwSize =  MAX_PATH;
    }

error:

    if (hParentKey) {
        RegCloseKey(hParentKey);
    }

    return(dwError);
}


DWORD
RegWriteMultiValuedString(
    HKEY hRegKey,
    LPWSTR pszValueName,
    LPWSTR * ppszStringReferences,
    DWORD dwNumStringReferences
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    LPWSTR pMem = NULL;
    LPWSTR pszTemp = NULL;
    DWORD  dwSize = 0;

    if (!ppszStringReferences) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);

    }

    for (i = 0; i < dwNumStringReferences; i++) {

        dwSize += wcslen (*(ppszStringReferences + i));
        dwSize ++;
    }

    dwSize ++;

    pMem = (LPWSTR) AllocPolMem(dwSize*sizeof(WCHAR));

    if (!pMem) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pszTemp = pMem;

    for (i = 0; i < dwNumStringReferences; i++) {

        memcpy(pszTemp, *(ppszStringReferences + i), wcslen(*(ppszStringReferences + i))*sizeof(WCHAR));
        pszTemp += wcslen(pszTemp) + 1;

    }

    //*pszTemp = L'\0';

    dwError = RegSetValueExW(
                    hRegKey,
                    pszValueName,
                    0,
                    REG_MULTI_SZ,
                    (LPBYTE)pMem,
                    dwSize * sizeof(WCHAR)
                    );
    BAIL_ON_WIN32_ERROR(dwError);


error:

    if (pMem) {
        FreePolMem(pMem);
    }

    return(dwError);
}


DWORD
CopyFilterDSToRegString(
    LPWSTR pszFilterDN,
    LPWSTR * ppszFilterName
    )
{

    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszFilterName = NULL;

    dwError = ComputePrelimCN(
                    pszFilterDN,
                    szCommonName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
                    szCommonName,
                    &pszGuidName
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pszFilterName = AllocPolStr(pszGuidName);
    if (!pszFilterName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszFilterName = pszFilterName;

    return(dwError);

error:

    *ppszFilterName = NULL;
    return(dwError);

}


DWORD
CopyNFADSToRegString(
    LPWSTR pszNFADN,
    LPWSTR * ppszNFAName
    )
{

    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszNFAName = NULL;

    dwError = ComputePrelimCN(
                    pszNFADN,
                    szCommonName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
                    szCommonName,
                    &pszGuidName
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pszNFAName = AllocPolStr(pszGuidName);
    if (!pszNFAName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszNFAName = pszNFAName;

    return(dwError);

error:

    *ppszNFAName = NULL;
    return(dwError);

}



DWORD
CopyNegPolDSToRegString(
    LPWSTR pszNegPolDN,
    LPWSTR * ppszNegPolName
    )
{

    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszNegPolName = NULL;

    dwError = ComputePrelimCN(
                    pszNegPolDN,
                    szCommonName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
                    szCommonName,
                    &pszGuidName
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pszNegPolName = AllocPolStr(pszGuidName);
    if (!pszNegPolName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszNegPolName = pszNegPolName;

    return(dwError);

error:

    *ppszNegPolName = NULL;
    return(dwError);

}


DWORD
CopyPolicyDSToRegString(
    LPWSTR pszPolicyDN,
    LPWSTR * ppszPolicyName
    )
{

    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszPolicyName = NULL;

    dwError = ComputePrelimCN(
                    pszPolicyDN,
                    szCommonName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
                    szCommonName,
                    &pszGuidName
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pszPolicyName = AllocPolStr(pszGuidName);
    if (!pszPolicyName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszPolicyName = pszPolicyName;

    return(dwError);

error:

    *ppszPolicyName = NULL;
    return(dwError);

}

DWORD
CopyISAKMPDSToRegString(
    LPWSTR pszISAKMPDN,
    LPWSTR * ppszISAKMPName
    )
{

    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszISAKMPName = NULL;

    dwError = ComputePrelimCN(
                    pszISAKMPDN,
                    szCommonName
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
                    szCommonName,
                    &pszGuidName
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pszISAKMPName = AllocPolStr(pszGuidName);
    if (!pszISAKMPName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszISAKMPName = pszISAKMPName;

    return(dwError);

error:

    *ppszISAKMPName = NULL;
    return(dwError);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <time.h>
#include <windows.h>
#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>
#include <wchar.h>
#include <dsgetdc.h>
#include <lm.h>

#define UNICODE
#define COBJMACROS

#include <wbemidl.h>
#include <oleauto.h>

#include <winldap.h>
#include <ipsec.h>
#include <oakdefs.h>
#include <polstructs.h>

#include "ldaputil.h"

#include "memory.h"
#include "structs.h"
#include "dsstore.h"
#include "regstore.h"
#include "wmistore.h"
#include "persist.h"
#include "persist-w.h"
#include "procrule.h"
#include "utils.h"

#include "nsu.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\persist-w.h ===
HRESULT
PersistWMIObject(
    IWbemServices *pWbemServices,
    PIPSEC_POLICY_OBJECT pIpsecRegPolicyObject,
    PGPO_INFO pGPOInfo
    );

HRESULT
PersistNegPolObjectsEx(
    IWbemServices *pWbemServices,
    IWbemClassObject *pWbemClassObj,
    PIPSEC_NEGPOL_OBJECT *ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects,
    PGPO_INFO pGPOInfo
    );

HRESULT
PersistFilterObjectsEx(
    IWbemServices *pWbemServices,
    IWbemClassObject *pWbemClassObj,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects,
    PGPO_INFO pGPOInfo    
    );

HRESULT
PersistNFAObjectsEx(
    IWbemServices *pWbemServices,
    IWbemClassObject *pWbemClassObj,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects,
    DWORD dwNumNFAObjects,
    PGPO_INFO pGPOInfo
    );

HRESULT
PersistISAKMPObjectsEx(
    IWbemServices *pWbemServices,
    IWbemClassObject *pWbemClassObj,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects,
    DWORD dwNumISAKMPObjects,
    PGPO_INFO pGPOInfo
    );

HRESULT
PersistPolicyObjectEx(
    IWbemServices *pWbemServices,
    IWbemClassObject *pWbemClassObj,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    PGPO_INFO pGPOInfo
    );

HRESULT
PersistNFAObjectEx(
    IWbemServices *pWbemServices,
    IWbemClassObject *pWbemClassObj,
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PGPO_INFO pGPOInfo
    );


HRESULT
PersistFilterObjectEx(
    IWbemServices *pWbemServices,
    IWbemClassObject *pWbemClassObj,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PGPO_INFO pGPOInfo
    );


HRESULT
PersistNegPolObjectEx(
    IWbemServices *pWbemServices,
    IWbemClassObject *pWbemClassObj,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PGPO_INFO pGPOInfo
    );

HRESULT
PersistISAKMPObjectEx(
    IWbemServices *pWbemServices,
    IWbemClassObject *pWbemClassObj,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PGPO_INFO pGPOInfo
    );

HRESULT
PersistComnRSOPPolicySettings(
                  IWbemClassObject * pInstIPSECObj,
                  PGPO_INFO pGPOInfo
                  );

HRESULT
CloneDirectoryPolicyObjectEx(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    PIPSEC_POLICY_OBJECT * ppIpsecWMIPolicyObject
    );

DWORD
CloneDirectoryNFAObjectsEx(
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects,
    DWORD dwNumNFAObjects,
    PIPSEC_NFA_OBJECT ** pppIpsecWMINFAObjects
    );

DWORD
CloneDirectoryFilterObjectsEx(
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects,
    PIPSEC_FILTER_OBJECT ** pppIpsecWMIFilterObjects
    );


DWORD
CloneDirectoryISAKMPObjectsEx(
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects,
    DWORD dwNumISAKMPObjects,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecWMIISAKMPObjects
    );


DWORD
CloneDirectoryNegPolObjectsEx(
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecWMINegPolObjects
    );

DWORD
CloneDirectoryFilterObjectEx(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PIPSEC_FILTER_OBJECT * ppIpsecWMIFilterObject
    );


DWORD
CloneDirectoryNegPolObjectEx(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PIPSEC_NEGPOL_OBJECT * ppIpsecWMINegPolObject
    );

DWORD
CloneDirectoryNFAObjectEx(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_NFA_OBJECT * ppIpsecWMINFAObject
    );

DWORD
CloneDirectoryISAKMPObjectEx(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PIPSEC_ISAKMP_OBJECT * ppIpsecWMIISAKMPObject
    );

DWORD
CopyFilterDSToFQWMIString(
    LPWSTR pszFilterDN,
    LPWSTR * ppszFilterName
    );


DWORD
CopyNFADSToFQWMIString(
    LPWSTR pszNFADN,
    LPWSTR * ppszNFAName
    );

DWORD
CopyNegPolDSToFQWMIString(
    LPWSTR pszNegPolDN,
    LPWSTR * ppszNegPolName
    );

DWORD
CopyPolicyDSToFQWMIString(
    LPWSTR pszPolicyDN,
    LPWSTR * ppszPolicyName
    );

DWORD
CopyISAKMPDSToFQWMIString(
    LPWSTR pszISAKMPDN,
    LPWSTR * ppszISAKMPName
    );

DWORD
CloneNFAReferencesDSToWMI(
    LPWSTR * ppszIpsecNFAReferences,
    DWORD dwNFACount,
    LPWSTR * * pppszIpsecWMINFAReferences,
    PDWORD pdwWMINFACount
    );

HRESULT
WMIWriteMultiValuedString(
    IWbemClassObject *pInstWbemClassObject,
    LPWSTR pszValueName,
    LPWSTR * ppszStringReferences,
    DWORD dwNumStringReferences
    );

DWORD
CopyFilterDSToWMIString(
    LPWSTR pszFilterDN,
    LPWSTR * ppszFilterName
    );

DWORD
CopyNFADSToWMIString(
    LPWSTR pszNFADN,
    LPWSTR * ppszNFAName
    );

DWORD
CopyNegPolDSToWMIString(
    LPWSTR pszNegPolDN,
    LPWSTR * ppszNegPolName
    );

DWORD
CopyPolicyDSToWMIString(
    LPWSTR pszPolicyDN,
    LPWSTR * ppszPolicyName
    );

DWORD
CopyISAKMPDSToWMIString(
    LPWSTR pszISAKMPDN,
    LPWSTR * ppszISAKMPName
    );

HRESULT
LogBlobPropertyEx(
    IWbemClassObject *pInstance,
    BSTR bstrPropName,
    BYTE *pbBlob,
    DWORD dwLen
    );

HRESULT
DeleteWMIClassObject(
    IWbemServices *pWbemServices,
    LPWSTR pszIpsecWMIObject
    );

LPWSTR
AllocPolBstrStr(
    LPCWSTR pStr
);

HRESULT
PolSysAllocString( 
  BSTR * pbsStr,
  const OLECHAR * sz  
  );

#define SKIPL(pstr) (pstr+2)

#define IPSEC_RSOP_CLASSNAME L"RSOP_IPSECPolicySetting"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\persist-w.c ===
#include "precomp.h"

HRESULT
PolSysAllocString( 
  BSTR * pbsStr,
  const OLECHAR * sz  
  )
{
    *pbsStr = SysAllocString(sz);
    if (!pbsStr && sz && (*sz)) {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

HRESULT
PersistWMIObject(
    IWbemServices *pWbemServices,
    PIPSEC_POLICY_OBJECT pIpsecWMIPolicyObject,
    PGPO_INFO pGPOInfo
    )
{
    HRESULT hr;
    IWbemClassObject *pWbemIPSECObj = NULL;
    BSTR bstrIpsecWMIObject = NULL;

    // If this first GPO we are writing after a policy
    // update, clear the WMI store.
    if (pGPOInfo->uiPrecedence == pGPOInfo->uiTotalGPOs) {
        hr = DeleteWMIClassObject(
            pWbemServices,
            IPSEC_RSOP_CLASSNAME
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    bstrIpsecWMIObject = SysAllocString(IPSEC_RSOP_CLASSNAME);
    if(!bstrIpsecWMIObject) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    hr = IWbemServices_GetObject(pWbemServices,
                                      bstrIpsecWMIObject,
                                      WBEM_FLAG_RETURN_WBEM_COMPLETE,
                                      0,
                                      &pWbemIPSECObj,
                                      0);
    SysFreeString(bstrIpsecWMIObject);
    BAIL_ON_HRESULT_ERROR(hr);

    if (pIpsecWMIPolicyObject->ppIpsecFilterObjects) {
        hr = PersistFilterObjectsEx(
            pWbemServices,
            pWbemIPSECObj,
            pIpsecWMIPolicyObject->ppIpsecFilterObjects,
            pIpsecWMIPolicyObject->NumberofFilters,
            pGPOInfo
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecWMIPolicyObject->ppIpsecNegPolObjects) {
        hr = PersistNegPolObjectsEx(
            pWbemServices,
            pWbemIPSECObj,
            pIpsecWMIPolicyObject->ppIpsecNegPolObjects,
            pIpsecWMIPolicyObject->NumberofNegPols,
            pGPOInfo
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecWMIPolicyObject->ppIpsecNFAObjects) {
        hr = PersistNFAObjectsEx(
            pWbemServices,
            pWbemIPSECObj,
            pIpsecWMIPolicyObject->ppIpsecNFAObjects,
            pIpsecWMIPolicyObject->NumberofRulesReturned,
            pGPOInfo
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecWMIPolicyObject->ppIpsecISAKMPObjects) {
        hr = PersistISAKMPObjectsEx(
            pWbemServices,
            pWbemIPSECObj,
            pIpsecWMIPolicyObject->ppIpsecISAKMPObjects,
            pIpsecWMIPolicyObject->NumberofISAKMPs,
            pGPOInfo
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    hr = PersistPolicyObjectEx(
        pWbemServices,
        pWbemIPSECObj,
        pIpsecWMIPolicyObject,
        pGPOInfo
        );
    
 error:

    //close WMI?
    if(pWbemIPSECObj)
        IWbemClassObject_Release(pWbemIPSECObj);
    
    return (hr);

}


HRESULT
PersistNegPolObjectsEx(
    IWbemServices *pWbemServices,
    IWbemClassObject *pWbemClassObj,
    PIPSEC_NEGPOL_OBJECT *ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects,
    PGPO_INFO pGPOInfo
    )
{
    DWORD i = 0;
    HRESULT hr = S_OK;
    
    for (i = 0; i < dwNumNegPolObjects; i++) {
        hr = PersistNegPolObjectEx(
            pWbemServices,
            pWbemClassObj,
            *(ppIpsecNegPolObjects + i),
            pGPOInfo
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
 error:
    
    return(hr);

}


HRESULT
PersistFilterObjectsEx(
    IWbemServices *pWbemServices,
    IWbemClassObject *pWbemClassObj,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects,
    PGPO_INFO pGPOInfo
    )
{
    DWORD i = 0;
    HRESULT hr = S_OK;


    for (i = 0; i < dwNumFilterObjects; i++) {
        hr = PersistFilterObjectEx(
            pWbemServices,
            pWbemClassObj,
            *(ppIpsecFilterObjects + i),
            pGPOInfo
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

 error:
    
    return(hr);
    
}


HRESULT
PersistNFAObjectsEx(
    IWbemServices *pWbemServices,
    IWbemClassObject *pWbemClassObj,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects,
    DWORD dwNumNFAObjects,
    PGPO_INFO pGPOInfo
    )
{
    DWORD i = 0;
    HRESULT hr = S_OK;

    for (i = 0; i < dwNumNFAObjects; i++) {
        hr = PersistNFAObjectEx(
            pWbemServices,
            pWbemClassObj,
            *(ppIpsecNFAObjects + i),
            pGPOInfo
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
 error:

    return(hr);

}


HRESULT
PersistISAKMPObjectsEx(
    IWbemServices *pWbemServices,
    IWbemClassObject *pWbemClassObj,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects,
    DWORD dwNumISAKMPObjects,
    PGPO_INFO pGPOInfo
    )
{
    DWORD i = 0;
    HRESULT hr = S_OK;

    for (i = 0; i < dwNumISAKMPObjects; i++) {
        hr= PersistISAKMPObjectEx(
            pWbemServices,
            pWbemClassObj,
            *(ppIpsecISAKMPObjects + i),
            pGPOInfo
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

 error:
    
    return(hr);

}


HRESULT
PersistPolicyObjectEx(
    IWbemServices *pWbemServices,
    IWbemClassObject *pWbemClassObj,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    PGPO_INFO pGPOInfo
    )
{
    HRESULT hr = 0;
    IWbemClassObject *pInstIPSECObj = NULL;
    VARIANT var;

    VariantInit(&var);

    //start
    hr = IWbemClassObject_SpawnInstance(
        pWbemClassObj,
        0,
        &pInstIPSECObj
        );
    BAIL_ON_HRESULT_ERROR(hr);

    var.vt = VT_BSTR;
    var.bstrVal = SKIPL(pIpsecPolicyObject->pszIpsecOwnersReference);
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"id",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

    hr = PersistComnRSOPPolicySettings(
                  pInstIPSECObj, 
                  pGPOInfo
                  );
    BAIL_ON_HRESULT_ERROR(hr);

    var.vt = VT_BSTR;
    hr = PolSysAllocString(&var.bstrVal, L"ipsecPolicy");
    BAIL_ON_HRESULT_ERROR(hr);
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"ClassName",
        0,
        &var,
        0
        );
    VariantClear(&var);
    BAIL_ON_HRESULT_ERROR(hr);

    if (pIpsecPolicyObject->pszDescription) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecPolicyObject->pszDescription);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"description",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    } else {
        //delete description?
        var.vt = VT_BSTR;
        hr = PolSysAllocString(&var.bstrVal, L"");
        BAIL_ON_HRESULT_ERROR(hr);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"description",
            0,
            &var,
            0
            );
        VariantClear(&var);            
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecPolicyObject->pszIpsecOwnersReference) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecPolicyObject->pszIpsecOwnersReference);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"name",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecPolicyObject->pszIpsecName) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecPolicyObject->pszIpsecName);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"ipsecName",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecPolicyObject->pszIpsecID) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecPolicyObject->pszIpsecID);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"ipsecID",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    var.vt = VT_I4;
    var.lVal = pIpsecPolicyObject->dwIpsecDataType;
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"ipsecDataType",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

    if (pIpsecPolicyObject->pIpsecData) {
        hr = LogBlobPropertyEx(
            pInstIPSECObj,
            L"ipsecData",
            pIpsecPolicyObject->pIpsecData,
            pIpsecPolicyObject->dwIpsecDataLen
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecPolicyObject->pszIpsecISAKMPReference) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecPolicyObject->pszIpsecISAKMPReference);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"ipsecISAKMPReference",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecPolicyObject->ppszIpsecNFAReferences) {
        hr = WMIWriteMultiValuedString(
            pInstIPSECObj,
            L"ipsecNFAReference",
            pIpsecPolicyObject->ppszIpsecNFAReferences,
            pIpsecPolicyObject->NumberofRules
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    var.vt = VT_I4;
    var.lVal = pIpsecPolicyObject->dwWhenChanged;
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"whenChanged",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

    hr = IWbemServices_PutInstance(
        pWbemServices,
        pInstIPSECObj,
        WBEM_FLAG_CREATE_OR_UPDATE,
        0,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);
    
 error:
    if (pInstIPSECObj) {
        IWbemClassObject_Release(pInstIPSECObj);
    }
    
    return(hr);
}


HRESULT
PersistNFAObjectEx(
    IWbemServices *pWbemServices,
    IWbemClassObject *pWbemClassObj,
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PGPO_INFO pGPOInfo
    )
{
    HRESULT hr = S_OK;
    IWbemClassObject *pInstIPSECObj = NULL;
    VARIANT var;
    LPWSTR *pMem = NULL;
    
    VariantInit(&var);

    //start
    hr = IWbemClassObject_SpawnInstance(
        pWbemClassObj,
        0,
        &pInstIPSECObj
        );
    BAIL_ON_HRESULT_ERROR(hr);
    
    var.vt = VT_BSTR;
    var.bstrVal = SKIPL(pIpsecNFAObject->pszDistinguishedName);
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"id",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

    hr = PersistComnRSOPPolicySettings(
                  pInstIPSECObj, 
                  pGPOInfo
                  );
    BAIL_ON_HRESULT_ERROR(hr);

    var.vt = VT_BSTR;
    hr = PolSysAllocString(&var.bstrVal, L"ipsecNFA");
    BAIL_ON_HRESULT_ERROR(hr);
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"ClassName",
        0,
        &var,
        0
        );

    VariantClear(&var);
    BAIL_ON_HRESULT_ERROR(hr);

    if (pIpsecNFAObject->pszDistinguishedName) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecNFAObject->pszDistinguishedName);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"name",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecNFAObject->pszIpsecName) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecNFAObject->pszIpsecName);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"ipsecName",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecNFAObject->pszDescription) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecNFAObject->pszDescription);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"description",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    } else {
        var.vt = VT_BSTR;
        hr = PolSysAllocString(&var.bstrVal, L"");
        BAIL_ON_HRESULT_ERROR(hr);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"description",
            0,
            &var,
            0
            );
        VariantClear(&var);
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecNFAObject->pszIpsecID) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecNFAObject->pszIpsecID);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"ipsecID",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    var.vt = VT_I4;
    var.lVal = pIpsecNFAObject->dwIpsecDataType;
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"ipsecDataType",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

    if (pIpsecNFAObject->pIpsecData) {
        hr = LogBlobPropertyEx(
            pInstIPSECObj,
            L"ipsecData",
            pIpsecNFAObject->pIpsecData,
            pIpsecNFAObject->dwIpsecDataLen
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecNFAObject->pszIpsecOwnersReference) {
        pMem = &(pIpsecNFAObject->pszIpsecOwnersReference);
        hr = WMIWriteMultiValuedString(
            pInstIPSECObj,
            L"ipsecOwnersReference",
            //pMem,
            &(pIpsecNFAObject->pszIpsecOwnersReference),
            1
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    if (pIpsecNFAObject->pszIpsecNegPolReference) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecNFAObject->pszIpsecNegPolReference);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"ipsecNegotiationPolicyReference",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        pMem = &(pIpsecNFAObject->pszIpsecFilterReference);
        hr = WMIWriteMultiValuedString(
            pInstIPSECObj,
            L"ipsecFilterReference",
            //pMem,
            &(pIpsecNFAObject->pszIpsecFilterReference),
            1
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    var.vt = VT_I4;
    var.lVal = pIpsecNFAObject->dwWhenChanged;
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"whenChanged",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

    
    hr = IWbemServices_PutInstance(
        pWbemServices,
        pInstIPSECObj,
        WBEM_FLAG_CREATE_OR_UPDATE,
        0,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

error:
    if (pInstIPSECObj) {
        IWbemClassObject_Release(pInstIPSECObj);
    }

    return(hr);

}


HRESULT
PersistFilterObjectEx(
    IWbemServices *pWbemServices,
    IWbemClassObject *pWbemClassObj,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PGPO_INFO pGPOInfo
    )
{
    HRESULT hr = S_OK;
    IWbemClassObject *pInstIPSECObj = NULL;
    VARIANT var;
    VARIANT vNullBstr;
    
    VariantInit(&var);
    VariantInit(&vNullBstr);
    vNullBstr.vt = VT_BSTR;
    hr = PolSysAllocString(&vNullBstr.bstrVal, L"");
    BAIL_ON_HRESULT_ERROR(hr);
    
    //start
    hr = IWbemClassObject_SpawnInstance(
        pWbemClassObj,
        0,
        &pInstIPSECObj
        );
    BAIL_ON_HRESULT_ERROR(hr);

    var.vt = VT_BSTR;
    var.bstrVal = SKIPL(pIpsecFilterObject->pszDistinguishedName);
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"id",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

    hr = PersistComnRSOPPolicySettings(
                  pInstIPSECObj, 
                  pGPOInfo
                  );
    BAIL_ON_HRESULT_ERROR(hr);

    var.vt = VT_BSTR;
    hr = PolSysAllocString(&var.bstrVal, L"ipsecFilter");
    BAIL_ON_HRESULT_ERROR(hr);    
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"ClassName",
        0,
        &var,
        0
        );
    VariantClear(&var);
    BAIL_ON_HRESULT_ERROR(hr);

    if (pIpsecFilterObject->pszDescription) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecFilterObject->pszDescription);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"description",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    } else {
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"description",
            0,
            &vNullBstr,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecFilterObject->pszDistinguishedName) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecFilterObject->pszDistinguishedName);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"name",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecFilterObject->pszIpsecName) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecFilterObject->pszIpsecName);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"ipsecName",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    } else {
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"ipsecName",
            0,
            &vNullBstr,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }


    if (pIpsecFilterObject->pszIpsecID) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecFilterObject->pszIpsecID);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"ipsecID",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    var.vt = VT_I4;
    var.lVal = pIpsecFilterObject->dwIpsecDataType;
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"ipsecDataType",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

    if (pIpsecFilterObject->pIpsecData) {
        hr = LogBlobPropertyEx(
            pInstIPSECObj,
            L"ipsecData",
            pIpsecFilterObject->pIpsecData,
            pIpsecFilterObject->dwIpsecDataLen
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    var.vt = VT_I4;
    var.lVal = pIpsecFilterObject->dwWhenChanged;
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"whenChanged",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

    if (pIpsecFilterObject->ppszIpsecNFAReferences) {
        hr = WMIWriteMultiValuedString(
            pInstIPSECObj,
            L"ipsecOwnersReference",
            pIpsecFilterObject->ppszIpsecNFAReferences,
            pIpsecFilterObject->dwNFACount
            );
        BAIL_ON_HRESULT_ERROR(hr);
    } else {
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"ipsecOwnersReference",
            0,
            &vNullBstr,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    hr = IWbemServices_PutInstance(
        pWbemServices,
        pInstIPSECObj,
        WBEM_FLAG_CREATE_OR_UPDATE,
        0,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

 error:
    if (pInstIPSECObj) {
        IWbemClassObject_Release(pInstIPSECObj);
    }

    VariantClear(&vNullBstr);
    
    return(hr);
}


HRESULT
PersistNegPolObjectEx(
    IWbemServices *pWbemServices,
    IWbemClassObject *pWbemClassObj,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PGPO_INFO pGPOInfo
    )
{
    HRESULT hr = S_OK;
    IWbemClassObject *pInstIPSECObj = NULL;
    VARIANT var;
    
    VariantInit(&var);

    //start
    hr = IWbemClassObject_SpawnInstance(
        pWbemClassObj,
        0,
        &pInstIPSECObj
        );
    BAIL_ON_HRESULT_ERROR(hr);
    
    var.vt = VT_BSTR;
    var.bstrVal = SKIPL(pIpsecNegPolObject->pszDistinguishedName);
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"id",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

    hr = PersistComnRSOPPolicySettings(
                  pInstIPSECObj, 
                  pGPOInfo
                  );
    BAIL_ON_HRESULT_ERROR(hr);

    var.vt = VT_BSTR;
    hr = PolSysAllocString(&var.bstrVal, L"ipsecNegotiationPolicy");
    BAIL_ON_HRESULT_ERROR(hr);    
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"ClassName",
        0,
        &var,
        0
        );
    VariantClear(&var);
    BAIL_ON_HRESULT_ERROR(hr);

    if (pIpsecNegPolObject->pszDescription) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecNegPolObject->pszDescription);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"description",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    } else {
        var.vt = VT_BSTR;
        PolSysAllocString(&var.bstrVal, L"");
        BAIL_ON_HRESULT_ERROR(hr);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"description",
            0,
            &var,
            0
            );
        VariantClear(&var);
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecNegPolObject->pszDistinguishedName) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecNegPolObject->pszDistinguishedName);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"name",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }


    if (pIpsecNegPolObject->pszIpsecName) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecNegPolObject->pszIpsecName);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"ipsecName",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    if (pIpsecNegPolObject->pszIpsecID) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecNegPolObject->pszIpsecID);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"ipsecID",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecNegPolObject->pszIpsecNegPolAction) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecNegPolObject->pszIpsecNegPolAction);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"ipsecNegotiationPolicyAction",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecNegPolObject->pszIpsecNegPolType) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecNegPolObject->pszIpsecNegPolType);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"ipsecNegotiationPolicyType",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    var.vt = VT_I4;
    var.lVal = pIpsecNegPolObject->dwIpsecDataType;
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"ipsecDataType",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

    if (pIpsecNegPolObject->pIpsecData) {
        hr = LogBlobPropertyEx(
            pInstIPSECObj,
            L"ipsecData",
            pIpsecNegPolObject->pIpsecData,
            pIpsecNegPolObject->dwIpsecDataLen
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecNegPolObject->ppszIpsecNFAReferences) {
        hr = WMIWriteMultiValuedString(
            pInstIPSECObj,
            L"ipsecOwnersReference",
            pIpsecNegPolObject->ppszIpsecNFAReferences,
            pIpsecNegPolObject->dwNFACount
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    var.vt = VT_I4;
    var.lVal = pIpsecNegPolObject->dwWhenChanged;
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"whenChanged",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);
    
    hr = IWbemServices_PutInstance(
        pWbemServices,
        pInstIPSECObj,
        WBEM_FLAG_CREATE_OR_UPDATE,
        0,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

error:
    if (pInstIPSECObj) {
        IWbemClassObject_Release(pInstIPSECObj);
    }

    return(hr);

}


HRESULT
PersistISAKMPObjectEx(
    IWbemServices *pWbemServices,
    IWbemClassObject *pWbemClassObj,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PGPO_INFO pGPOInfo
    )
{
    HRESULT hr = S_OK;
    IWbemClassObject *pInstIPSECObj = NULL;
    VARIANT var;
    
    VariantInit(&var);

    //start
    hr = IWbemClassObject_SpawnInstance(
        pWbemClassObj,
        0,
        &pInstIPSECObj
        );
    BAIL_ON_HRESULT_ERROR(hr);
    
    var.vt = VT_BSTR;
    var.bstrVal = SKIPL(pIpsecISAKMPObject->pszDistinguishedName);
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"id",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

    hr = PersistComnRSOPPolicySettings(
                  pInstIPSECObj, 
                  pGPOInfo
                  );
    BAIL_ON_HRESULT_ERROR(hr);

    var.vt = VT_BSTR;
    hr = PolSysAllocString(&var.bstrVal, L"ipsecISAKMPPolicy");
    BAIL_ON_HRESULT_ERROR(hr);
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"ClassName",
        0,
        &var,
        0
        );
    VariantClear(&var);
    BAIL_ON_HRESULT_ERROR(hr);

    if (pIpsecISAKMPObject->pszDistinguishedName) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecISAKMPObject->pszDistinguishedName);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"name",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecISAKMPObject->pszIpsecName) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecISAKMPObject->pszIpsecName);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"ipsecName",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    if (pIpsecISAKMPObject->pszIpsecID) {
        var.vt = VT_BSTR;
        var.bstrVal = SKIPL(pIpsecISAKMPObject->pszIpsecID);
        hr = IWbemClassObject_Put(
            pInstIPSECObj,
            L"ipsecID",
            0,
            &var,
            0
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    var.vt = VT_I4;
    var.lVal = pIpsecISAKMPObject->dwIpsecDataType;
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"ipsecDataType",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

    if (pIpsecISAKMPObject->pIpsecData) {
        hr = LogBlobPropertyEx(
            pInstIPSECObj,
            L"ipsecData",
            pIpsecISAKMPObject->pIpsecData,
            pIpsecISAKMPObject->dwIpsecDataLen
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    var.vt = VT_I4;
    var.lVal = pIpsecISAKMPObject->dwWhenChanged;
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"whenChanged",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

    if (pIpsecISAKMPObject->ppszIpsecNFAReferences) {
        hr = WMIWriteMultiValuedString(
            pInstIPSECObj,
            L"ipsecOwnersReference",
            pIpsecISAKMPObject->ppszIpsecNFAReferences,
            pIpsecISAKMPObject->dwNFACount
            );
        BAIL_ON_HRESULT_ERROR(hr);
    }

    hr = IWbemServices_PutInstance(
        pWbemServices,
        pInstIPSECObj,
        WBEM_FLAG_CREATE_OR_UPDATE,
        0,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

error:
    if (pInstIPSECObj) {
        IWbemClassObject_Release(pInstIPSECObj);
    }

    return(hr);

}

HRESULT
PersistComnRSOPPolicySettings(
                  IWbemClassObject * pInstIPSECObj,
                  PGPO_INFO pGPOInfo
                  )
{
    HRESULT hr = S_OK;
    VARIANT var;
    
    VariantInit(&var);

    var.vt = VT_BSTR;
    var.bstrVal = pGPOInfo->bsCreationtime;
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"creationTime",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

  
    var.vt = VT_BSTR;
    var.bstrVal = pGPOInfo->bsGPOID;
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"GPOID",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

    var.vt = VT_I4;
    var.lVal = pGPOInfo->uiPrecedence;
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"precedence",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

    var.vt = VT_BSTR;
    var.bstrVal = pGPOInfo->bsSOMID;
    hr = IWbemClassObject_Put(
        pInstIPSECObj,
        L"SOMID",
        0,
        &var,
        0
        );
    BAIL_ON_HRESULT_ERROR(hr);

error:
    var.vt = VT_EMPTY;
    return hr;
}
                  
HRESULT
CloneDirectoryPolicyObjectEx(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    PIPSEC_POLICY_OBJECT * ppIpsecWMIPolicyObject
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecWMIPolicyObject = NULL;

    //malloc policy object
    pIpsecWMIPolicyObject = (PIPSEC_POLICY_OBJECT)AllocPolMem(
        sizeof(IPSEC_POLICY_OBJECT)
        );
    if (!pIpsecWMIPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    //
    // Clone Filter Objects
    //
    if (pIpsecPolicyObject->ppIpsecFilterObjects) {
        dwError = CloneDirectoryFilterObjectsEx(
            pIpsecPolicyObject->ppIpsecFilterObjects,
            pIpsecPolicyObject->NumberofFilters,
            &pIpsecWMIPolicyObject->ppIpsecFilterObjects
            );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecWMIPolicyObject->NumberofFilters = pIpsecPolicyObject->NumberofFilters;
    }

    //
    // Clone NegPol Objects
    //
    if (pIpsecPolicyObject->ppIpsecNegPolObjects) {
        dwError = CloneDirectoryNegPolObjectsEx(
            pIpsecPolicyObject->ppIpsecNegPolObjects,
            pIpsecPolicyObject->NumberofNegPols,
            &pIpsecWMIPolicyObject->ppIpsecNegPolObjects
            );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecWMIPolicyObject->NumberofNegPols = pIpsecPolicyObject->NumberofNegPols;
    }

    //
    // Clone NFA Objects
    //
    if (pIpsecPolicyObject->ppIpsecNFAObjects) {
        dwError = CloneDirectoryNFAObjectsEx(
            pIpsecPolicyObject->ppIpsecNFAObjects,
            pIpsecPolicyObject->NumberofRulesReturned,
            &pIpsecWMIPolicyObject->ppIpsecNFAObjects
            );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecWMIPolicyObject->NumberofRules = pIpsecPolicyObject->NumberofRules;
        pIpsecWMIPolicyObject->NumberofRulesReturned = pIpsecPolicyObject->NumberofRulesReturned;
    }

    //
    // Clone ISAKMP Objects
    //
    if (pIpsecPolicyObject->ppIpsecISAKMPObjects) {
        dwError = CloneDirectoryISAKMPObjectsEx(
            pIpsecPolicyObject->ppIpsecISAKMPObjects,
            pIpsecPolicyObject->NumberofISAKMPs,
            &pIpsecWMIPolicyObject->ppIpsecISAKMPObjects
            );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecWMIPolicyObject->NumberofISAKMPs = pIpsecPolicyObject->NumberofISAKMPs;
    }

    //
    // Now copy the rest of the data in the object
    //
    
    //copy owners ref
    if (pIpsecPolicyObject->pszIpsecOwnersReference) {
        dwError = CopyPolicyDSToWMIString(
            pIpsecPolicyObject->pszIpsecOwnersReference,
            &pIpsecWMIPolicyObject->pszIpsecOwnersReference
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //copy name
    if (pIpsecPolicyObject->pszIpsecName) {
        pIpsecWMIPolicyObject->pszIpsecName = AllocPolBstrStr(
            pIpsecPolicyObject->pszIpsecName
            );
        if (!pIpsecWMIPolicyObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //copy ipsecid
    if (pIpsecPolicyObject->pszIpsecID) {
        pIpsecWMIPolicyObject->pszIpsecID = AllocPolBstrStr(
            pIpsecPolicyObject->pszIpsecID
            );
        if (!pIpsecWMIPolicyObject->pszIpsecID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //copy isakmpref
    if (pIpsecPolicyObject->pszIpsecISAKMPReference) {
        dwError = CopyISAKMPDSToFQWMIString(
            pIpsecPolicyObject->pszIpsecISAKMPReference,
            &pIpsecWMIPolicyObject->pszIpsecISAKMPReference
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //copy datatype
    pIpsecWMIPolicyObject->dwIpsecDataType = pIpsecPolicyObject->dwIpsecDataType;

    //copy ipsecdata
    if (pIpsecPolicyObject->pIpsecData) {
        dwError = CopyBinaryValue(
            pIpsecPolicyObject->pIpsecData,
            pIpsecPolicyObject->dwIpsecDataLen,
            &pIpsecWMIPolicyObject->pIpsecData
            );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecWMIPolicyObject->dwIpsecDataLen = pIpsecPolicyObject->dwIpsecDataLen;
    }

    //copy nfaref
    if (pIpsecPolicyObject->ppszIpsecNFAReferences) {
        dwError = CloneNFAReferencesDSToWMI(
            pIpsecPolicyObject->ppszIpsecNFAReferences,
            pIpsecPolicyObject->NumberofRules,
            &(pIpsecWMIPolicyObject->ppszIpsecNFAReferences),
            &(pIpsecWMIPolicyObject->NumberofRules)
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //copy description
    if (pIpsecPolicyObject->pszDescription) {
        pIpsecWMIPolicyObject->pszDescription = AllocPolBstrStr(
            pIpsecPolicyObject->pszDescription
            );
        if (!pIpsecWMIPolicyObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //copy whenchanged
    pIpsecWMIPolicyObject->dwWhenChanged = pIpsecPolicyObject->dwWhenChanged;

    //commit & return
    *ppIpsecWMIPolicyObject = pIpsecWMIPolicyObject;

    return (HRESULT_FROM_WIN32(dwError));

 error:

    if (pIpsecWMIPolicyObject) {
        FreeIpsecPolicyObject(
            pIpsecWMIPolicyObject
            );
    }

    *ppIpsecWMIPolicyObject = NULL;
    
    return (HRESULT_FROM_WIN32(dwError));

}


DWORD
CloneDirectoryNFAObjectsEx(
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects,
    DWORD dwNumNFAObjects,
    PIPSEC_NFA_OBJECT ** pppIpsecWMINFAObjects
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_OBJECT * ppIpsecWMINFAObjects = NULL;
    PIPSEC_NFA_OBJECT pIpsecWMINFAObject = NULL;
    
    if (dwNumNFAObjects) {
        ppIpsecWMINFAObjects = (PIPSEC_NFA_OBJECT *)AllocPolMem(
            dwNumNFAObjects*sizeof(PIPSEC_NFA_OBJECT)
            );
        if (!ppIpsecWMINFAObjects) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    for (i = 0; i < dwNumNFAObjects; i++) {
        dwError = CloneDirectoryNFAObjectEx(
            *(ppIpsecNFAObjects + i),
            &pIpsecWMINFAObject
            );
        BAIL_ON_WIN32_ERROR(dwError);

        *(ppIpsecWMINFAObjects + i) = pIpsecWMINFAObject;
    }
    
    *pppIpsecWMINFAObjects = ppIpsecWMINFAObjects;
    
    return(dwError);
    
 error:

    if (ppIpsecWMINFAObjects) {
        FreeIpsecNFAObjects(
            ppIpsecWMINFAObjects,
            i
            );
    }
    
    *pppIpsecWMINFAObjects = NULL;

    return(dwError);

}


DWORD
CloneDirectoryFilterObjectsEx(
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects,
    PIPSEC_FILTER_OBJECT ** pppIpsecWMIFilterObjects
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_FILTER_OBJECT * ppIpsecWMIFilterObjects = NULL;
    PIPSEC_FILTER_OBJECT pIpsecWMIFilterObject = NULL;
    
    if (dwNumFilterObjects) {
        ppIpsecWMIFilterObjects = (PIPSEC_FILTER_OBJECT *)AllocPolMem(
            dwNumFilterObjects*sizeof(PIPSEC_FILTER_OBJECT)
            );
        if (!ppIpsecWMIFilterObjects) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    for (i = 0; i < dwNumFilterObjects; i++) {
        dwError = CloneDirectoryFilterObjectEx(
            *(ppIpsecFilterObjects + i),
            &pIpsecWMIFilterObject
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
        *(ppIpsecWMIFilterObjects + i) = pIpsecWMIFilterObject;
    }
    
    *pppIpsecWMIFilterObjects = ppIpsecWMIFilterObjects;
    
    return(dwError);
    
 error:
    
    if (ppIpsecWMIFilterObjects) {
        FreeIpsecFilterObjects(
            ppIpsecWMIFilterObjects,
            i
            );
    }
    
    *pppIpsecWMIFilterObjects = NULL;
    
    return(dwError);
}


DWORD
CloneDirectoryISAKMPObjectsEx(
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects,
    DWORD dwNumISAKMPObjects,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecWMIISAKMPObjects
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_ISAKMP_OBJECT * ppIpsecWMIISAKMPObjects = NULL;
    PIPSEC_ISAKMP_OBJECT pIpsecWMIISAKMPObject = NULL;
    
    if (dwNumISAKMPObjects) {
        ppIpsecWMIISAKMPObjects = (PIPSEC_ISAKMP_OBJECT *)AllocPolMem(
            dwNumISAKMPObjects*sizeof(PIPSEC_ISAKMP_OBJECT)
            );
        if (!ppIpsecWMIISAKMPObjects) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    for (i = 0; i < dwNumISAKMPObjects; i++) {
        dwError = CloneDirectoryISAKMPObjectEx(
            *(ppIpsecISAKMPObjects + i),
            &pIpsecWMIISAKMPObject
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
        *(ppIpsecWMIISAKMPObjects + i) = pIpsecWMIISAKMPObject;
    }
    
    *pppIpsecWMIISAKMPObjects = ppIpsecWMIISAKMPObjects;
    
    return(dwError);
    
 error:

    if (ppIpsecWMIISAKMPObjects) {
        FreeIpsecISAKMPObjects(
            ppIpsecWMIISAKMPObjects,
            i
            );
    }
    
    *pppIpsecWMIISAKMPObjects = NULL;

    return(dwError);
    
}


DWORD
CloneDirectoryNegPolObjectsEx(
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecWMINegPolObjects
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NEGPOL_OBJECT * ppIpsecWMINegPolObjects = NULL;
    PIPSEC_NEGPOL_OBJECT pIpsecWMINegPolObject = NULL;
    
    if (dwNumNegPolObjects) {
        ppIpsecWMINegPolObjects = (PIPSEC_NEGPOL_OBJECT *)AllocPolMem(
            dwNumNegPolObjects*sizeof(PIPSEC_NEGPOL_OBJECT)
            );
        if (!ppIpsecWMINegPolObjects) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    for (i = 0; i < dwNumNegPolObjects; i++) {
        dwError = CloneDirectoryNegPolObjectEx(
            *(ppIpsecNegPolObjects + i),
            &pIpsecWMINegPolObject
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
        *(ppIpsecWMINegPolObjects + i) = pIpsecWMINegPolObject;
    }

    *pppIpsecWMINegPolObjects = ppIpsecWMINegPolObjects;

    return(dwError);
    
 error:
    
    if (ppIpsecWMINegPolObjects) {
        FreeIpsecNegPolObjects(
            ppIpsecWMINegPolObjects,
            i
            );
    }
    
    *pppIpsecWMINegPolObjects = NULL;
    
    return(dwError);

}


DWORD
CloneDirectoryFilterObjectEx(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PIPSEC_FILTER_OBJECT * ppIpsecWMIFilterObject
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecWMIFilterObject = NULL;

    pIpsecWMIFilterObject = (PIPSEC_FILTER_OBJECT)AllocPolMem(
        sizeof(IPSEC_FILTER_OBJECT)
        );
    if (!pIpsecWMIFilterObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    if (pIpsecFilterObject->pszDistinguishedName) {
        dwError = CopyFilterDSToWMIString(
            pIpsecFilterObject->pszDistinguishedName,
            &pIpsecWMIFilterObject->pszDistinguishedName
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    if (pIpsecFilterObject->pszDescription) {
        pIpsecWMIFilterObject->pszDescription = AllocPolBstrStr(
            pIpsecFilterObject->pszDescription
            );
        if (!pIpsecWMIFilterObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    if (pIpsecFilterObject->pszIpsecName) {
        pIpsecWMIFilterObject->pszIpsecName = AllocPolBstrStr(
            pIpsecFilterObject->pszIpsecName
            );
        if (!pIpsecWMIFilterObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    if (pIpsecFilterObject->pszIpsecID) {
        pIpsecWMIFilterObject->pszIpsecID = AllocPolBstrStr(
            pIpsecFilterObject->pszIpsecID
            );
        if (!pIpsecWMIFilterObject->pszIpsecID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    pIpsecWMIFilterObject->dwIpsecDataType = pIpsecFilterObject->dwIpsecDataType;
    
    if (pIpsecFilterObject->pIpsecData) {
        dwError = CopyBinaryValue(
            pIpsecFilterObject->pIpsecData,
            pIpsecFilterObject->dwIpsecDataLen,
            &pIpsecWMIFilterObject->pIpsecData
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
        pIpsecWMIFilterObject->dwIpsecDataLen = pIpsecFilterObject->dwIpsecDataLen;
    }

    if (pIpsecFilterObject->ppszIpsecNFAReferences) {
        dwError = CloneNFAReferencesDSToWMI(
            pIpsecFilterObject->ppszIpsecNFAReferences,
            pIpsecFilterObject->dwNFACount,
            &pIpsecWMIFilterObject->ppszIpsecNFAReferences,
            &pIpsecWMIFilterObject->dwNFACount
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pIpsecWMIFilterObject->dwWhenChanged = pIpsecFilterObject->dwWhenChanged;

    *ppIpsecWMIFilterObject = pIpsecWMIFilterObject;

    return(dwError);

 error:

    if (pIpsecWMIFilterObject) {
        FreeIpsecFilterObject(pIpsecWMIFilterObject);
    }
    
    *ppIpsecWMIFilterObject = NULL;
    
    return(dwError);

}


DWORD
CloneDirectoryNegPolObjectEx(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PIPSEC_NEGPOL_OBJECT * ppIpsecWMINegPolObject
    )
{
    DWORD dwError = 0;
    
    PIPSEC_NEGPOL_OBJECT pIpsecWMINegPolObject = NULL;
    
    pIpsecWMINegPolObject = (PIPSEC_NEGPOL_OBJECT)AllocPolMem(
        sizeof(IPSEC_NEGPOL_OBJECT)
        );
    if (!pIpsecWMINegPolObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    if (pIpsecNegPolObject->pszDistinguishedName) {
        dwError = CopyNegPolDSToWMIString(
            pIpsecNegPolObject->pszDistinguishedName,
            &pIpsecWMINegPolObject->pszDistinguishedName
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    if (pIpsecNegPolObject->pszIpsecName) {
        pIpsecWMINegPolObject->pszIpsecName = AllocPolBstrStr(
            pIpsecNegPolObject->pszIpsecName
            );
        if (!pIpsecWMINegPolObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    if (pIpsecNegPolObject->pszDescription) {
        pIpsecWMINegPolObject->pszDescription = AllocPolBstrStr(
            pIpsecNegPolObject->pszDescription
            );
        if (!pIpsecWMINegPolObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    if (pIpsecNegPolObject->pszIpsecID) {
        pIpsecWMINegPolObject->pszIpsecID = AllocPolBstrStr(
            pIpsecNegPolObject->pszIpsecID
            );
        if (!pIpsecWMINegPolObject->pszIpsecID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    pIpsecWMINegPolObject->dwIpsecDataType = pIpsecNegPolObject->dwIpsecDataType;
    
    if (pIpsecNegPolObject->pIpsecData) {
        
        dwError = CopyBinaryValue(
            pIpsecNegPolObject->pIpsecData,
            pIpsecNegPolObject->dwIpsecDataLen,
            &pIpsecWMINegPolObject->pIpsecData
            );
        BAIL_ON_WIN32_ERROR(dwError);

        pIpsecWMINegPolObject->dwIpsecDataLen = pIpsecNegPolObject->dwIpsecDataLen;
    }
    
    if (pIpsecNegPolObject->pszIpsecNegPolAction) {
        pIpsecWMINegPolObject->pszIpsecNegPolAction = AllocPolBstrStr(
            pIpsecNegPolObject->pszIpsecNegPolAction
            );
        if (!pIpsecWMINegPolObject->pszIpsecNegPolAction) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    if (pIpsecNegPolObject->pszIpsecNegPolType) {
        pIpsecWMINegPolObject->pszIpsecNegPolType = AllocPolBstrStr(
            pIpsecNegPolObject->pszIpsecNegPolType
            );
        if (!pIpsecWMINegPolObject->pszIpsecNegPolType) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    
    if (pIpsecNegPolObject->ppszIpsecNFAReferences) {
        dwError = CloneNFAReferencesDSToWMI(
            pIpsecNegPolObject->ppszIpsecNFAReferences,
            pIpsecNegPolObject->dwNFACount,
            &pIpsecWMINegPolObject->ppszIpsecNFAReferences,
            &pIpsecWMINegPolObject->dwNFACount
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    pIpsecWMINegPolObject->dwWhenChanged = pIpsecNegPolObject->dwWhenChanged;
    
    *ppIpsecWMINegPolObject = pIpsecWMINegPolObject;
    
    return(dwError);

 error:
    
    if (pIpsecWMINegPolObject) {
        FreeIpsecNegPolObject(pIpsecWMINegPolObject);
    }
    
    *ppIpsecWMINegPolObject = NULL;

    return(dwError);
    
}


DWORD
CloneDirectoryNFAObjectEx(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_NFA_OBJECT * ppIpsecWMINFAObject
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_OBJECT pIpsecWMINFAObject = NULL;

    pIpsecWMINFAObject = (PIPSEC_NFA_OBJECT)AllocPolMem(
        sizeof(IPSEC_NFA_OBJECT)
        );
    if (!pIpsecWMINFAObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    if (pIpsecNFAObject->pszDistinguishedName) {
        dwError = CopyNFADSToWMIString(
            pIpsecNFAObject->pszDistinguishedName,
            &pIpsecWMINFAObject->pszDistinguishedName
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    if (pIpsecNFAObject->pszIpsecName) {
        pIpsecWMINFAObject->pszIpsecName = AllocPolBstrStr(
            pIpsecNFAObject->pszIpsecName
            );
        if (!pIpsecWMINFAObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    if (pIpsecNFAObject->pszDescription) {
        pIpsecWMINFAObject->pszDescription = AllocPolBstrStr(
            pIpsecNFAObject->pszDescription
            );
        if (!pIpsecWMINFAObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    if (pIpsecNFAObject->pszIpsecID) {
        pIpsecWMINFAObject->pszIpsecID = AllocPolBstrStr(
            pIpsecNFAObject->pszIpsecID
            );
        if (!pIpsecWMINFAObject->pszIpsecID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    pIpsecWMINFAObject->dwIpsecDataType = pIpsecNFAObject->dwIpsecDataType;
    
    if (pIpsecNFAObject->pIpsecData) {
        dwError = CopyBinaryValue(
            pIpsecNFAObject->pIpsecData,
            pIpsecNFAObject->dwIpsecDataLen,
            &pIpsecWMINFAObject->pIpsecData
            );
        BAIL_ON_WIN32_ERROR(dwError);

        pIpsecWMINFAObject->dwIpsecDataLen = pIpsecNFAObject->dwIpsecDataLen;
    }
    
    if (pIpsecNFAObject->pszIpsecOwnersReference) {
        dwError = CopyPolicyDSToFQWMIString(
            pIpsecNFAObject->pszIpsecOwnersReference,
            &pIpsecWMINFAObject->pszIpsecOwnersReference
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    if (pIpsecNFAObject->pszIpsecFilterReference) {
        dwError = CopyFilterDSToFQWMIString(
            pIpsecNFAObject->pszIpsecFilterReference,
            &pIpsecWMINFAObject->pszIpsecFilterReference
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNFAObject->pszIpsecNegPolReference) {
        dwError = CopyNegPolDSToFQWMIString(
            pIpsecNFAObject->pszIpsecNegPolReference,
            &pIpsecWMINFAObject->pszIpsecNegPolReference
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    pIpsecWMINFAObject->dwWhenChanged = pIpsecNFAObject->dwWhenChanged;

    *ppIpsecWMINFAObject = pIpsecWMINFAObject;

    return(dwError);
    
 error:

    if (pIpsecWMINFAObject) {
        FreeIpsecNFAObject(pIpsecWMINFAObject);
    }
    
    *ppIpsecWMINFAObject = NULL;

    return(dwError);

}


DWORD
CloneDirectoryISAKMPObjectEx(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PIPSEC_ISAKMP_OBJECT * ppIpsecWMIISAKMPObject
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecWMIISAKMPObject = NULL;
    
    pIpsecWMIISAKMPObject = (PIPSEC_ISAKMP_OBJECT)AllocPolMem(
        sizeof(IPSEC_ISAKMP_OBJECT)
        );
    if (!pIpsecWMIISAKMPObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    if (pIpsecISAKMPObject->pszDistinguishedName) {
        dwError = CopyISAKMPDSToWMIString(
            pIpsecISAKMPObject->pszDistinguishedName,
            &pIpsecWMIISAKMPObject->pszDistinguishedName
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (pIpsecISAKMPObject->pszIpsecName) {
        pIpsecWMIISAKMPObject->pszIpsecName = AllocPolBstrStr(
            pIpsecISAKMPObject->pszIpsecName
            );
        if (!pIpsecWMIISAKMPObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    if (pIpsecISAKMPObject->pszIpsecID) {
        pIpsecWMIISAKMPObject->pszIpsecID = AllocPolBstrStr(
            pIpsecISAKMPObject->pszIpsecID
            );
        if (!pIpsecWMIISAKMPObject->pszIpsecID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    pIpsecWMIISAKMPObject->dwIpsecDataType = pIpsecISAKMPObject->dwIpsecDataType;

    if (pIpsecISAKMPObject->pIpsecData) {
        dwError = CopyBinaryValue(
            pIpsecISAKMPObject->pIpsecData,
            pIpsecISAKMPObject->dwIpsecDataLen,
            &pIpsecWMIISAKMPObject->pIpsecData
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    pIpsecWMIISAKMPObject->dwIpsecDataLen = pIpsecISAKMPObject->dwIpsecDataLen;
    
    if (pIpsecISAKMPObject->ppszIpsecNFAReferences) {
        dwError = CloneNFAReferencesDSToWMI(
            pIpsecISAKMPObject->ppszIpsecNFAReferences,
            pIpsecISAKMPObject->dwNFACount,
            &pIpsecWMIISAKMPObject->ppszIpsecNFAReferences,
            &pIpsecWMIISAKMPObject->dwNFACount
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    pIpsecWMIISAKMPObject->dwWhenChanged = pIpsecISAKMPObject->dwWhenChanged;
    
    *ppIpsecWMIISAKMPObject = pIpsecWMIISAKMPObject;
    
    return(dwError);
    
 error:
    
    if (pIpsecWMIISAKMPObject) {
        FreeIpsecISAKMPObject(pIpsecWMIISAKMPObject);
    }
    
    *ppIpsecWMIISAKMPObject = NULL;
    
    return(dwError);
    
}


DWORD
CopyFilterDSToFQWMIString(
    LPWSTR pszFilterDN,
    LPWSTR * ppszFilterName
    )
{
    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszFilterName = NULL;
    DWORD dwStringSize = 0;

    dwError = ComputePrelimCN(
        pszFilterDN,
        szCommonName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = ComputeGUIDName(
        szCommonName,
        &pszGuidName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    //no need for path, guid is enuff
    dwStringSize = wcslen(pszGuidName);
    dwStringSize += 1;
    
    pszFilterName = (LPWSTR)AllocPolMem(dwStringSize*sizeof(WCHAR));
    if (!pszFilterName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    wcscpy(pszFilterName, pszGuidName);
    
    *ppszFilterName = pszFilterName;
    
    return(dwError);
    
 error:
    
    *ppszFilterName = NULL;
    
    return(dwError);

}


DWORD
CopyNFADSToFQWMIString(
    LPWSTR pszNFADN,
    LPWSTR * ppszNFAName
    )
{
    
    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszNFAName = NULL;
    DWORD dwStringSize = 0;
    
    dwError = ComputePrelimCN(
        pszNFADN,
        szCommonName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = ComputeGUIDName(
        szCommonName,
        &pszGuidName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwStringSize = wcslen(pszGuidName);
    dwStringSize += 1;

    // NFA References converted to BSTR before storage by
    // WMMIWriteMultiValuedString, so we don't convert them to
    // BSTRs here.
    pszNFAName = (LPWSTR)AllocPolMem(dwStringSize*sizeof(WCHAR));
    if (!pszNFAName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    wcscpy(pszNFAName, pszGuidName);
    
    *ppszNFAName = pszNFAName;

    return(dwError);

 error:

    *ppszNFAName = NULL;

    return(dwError);

}


DWORD
CopyNegPolDSToFQWMIString(
    LPWSTR pszNegPolDN,
    LPWSTR * ppszNegPolName
    )
{
    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszNegPolName = NULL;
    DWORD dwStringSize = 0;
    
    dwError = ComputePrelimCN(
        pszNegPolDN,
        szCommonName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = ComputeGUIDName(
        szCommonName,
        &pszGuidName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwStringSize = wcslen(pszGuidName);
    dwStringSize += 1;
    
    pszNegPolName = (LPWSTR)AllocPolBstrStr(pszGuidName);
    if (!pszNegPolName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    *ppszNegPolName = pszNegPolName;
    
    return(dwError);
    
 error:
    
    *ppszNegPolName = NULL;
    
    return(dwError);

}


DWORD
CopyPolicyDSToFQWMIString(
    LPWSTR pszPolicyDN,
    LPWSTR * ppszPolicyName
    )
{
    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszPolicyName = NULL;
    DWORD dwStringSize = 0;
    
    dwError = ComputePrelimCN(
        pszPolicyDN,
        szCommonName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = ComputeGUIDName(
        szCommonName,
        &pszGuidName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwStringSize = wcslen(pszGuidName);
    dwStringSize += 1;

    pszPolicyName = (LPWSTR)AllocPolMem(dwStringSize*sizeof(WCHAR));
    if (!pszPolicyName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    wcscpy(pszPolicyName, pszGuidName);
    
    *ppszPolicyName = pszPolicyName;
    
    return(dwError);
    
 error:
    
    *ppszPolicyName = NULL;
    
    return(dwError);

}


DWORD
CopyISAKMPDSToFQWMIString(
    LPWSTR pszISAKMPDN,
    LPWSTR * ppszISAKMPName
    )
{
    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszISAKMPName = NULL;
    DWORD dwStringSize = 0;
    
    dwError = ComputePrelimCN(
        pszISAKMPDN,
        szCommonName
        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
        szCommonName,
        &pszGuidName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    pszISAKMPName = (LPWSTR)AllocPolBstrStr(pszGuidName);
    if (!pszISAKMPName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszISAKMPName = pszISAKMPName;
    
    return(dwError);

 error:
    
    *ppszISAKMPName = NULL;
    
    return(dwError);

}


DWORD
CloneNFAReferencesDSToWMI(
    LPWSTR * ppszIpsecNFAReferences,
    DWORD dwNFACount,
    LPWSTR * * pppszIpsecWMINFAReferences,
    PDWORD pdwWMINFACount
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    LPWSTR * ppszIpsecWMINFAReferences = NULL;

    ppszIpsecWMINFAReferences = (LPWSTR *)AllocPolMem(
        sizeof(LPWSTR)*dwNFACount
        );
    if (!ppszIpsecWMINFAReferences) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwNFACount; i++) {
        dwError = CopyNFADSToFQWMIString(
            *(ppszIpsecNFAReferences + i),
            (ppszIpsecWMINFAReferences + i)
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    *pppszIpsecWMINFAReferences = ppszIpsecWMINFAReferences;
    
    *pdwWMINFACount = dwNFACount;

    return(dwError);

error:

    if (ppszIpsecWMINFAReferences) {
        FreeNFAReferences(
            ppszIpsecWMINFAReferences,
            i
            );
    }
    
    *pppszIpsecWMINFAReferences = NULL;
    
    *pdwWMINFACount = 0;
    
    return(dwError);

}


HRESULT
WMIWriteMultiValuedString(
    IWbemClassObject *pInstWbemClassObject,
    LPWSTR pszValueName,
    LPWSTR * ppszStringReferences,
    DWORD dwNumStringReferences
    )
{
    HRESULT hr = S_OK;
    SAFEARRAYBOUND arrayBound[1];
    SAFEARRAY *pSafeArray = NULL;
    VARIANT var;
    DWORD i = 0;
    BSTR Bstr = NULL;

    VariantInit(&var);
    
    if (!ppszStringReferences) {
        hr = E_INVALIDARG;
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    arrayBound[0].lLbound = 0;
    arrayBound[0].cElements = dwNumStringReferences;
    
    pSafeArray = SafeArrayCreate(VT_BSTR, 1, arrayBound);
    if (!pSafeArray)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    for (i = 0; i < dwNumStringReferences; i++)
    {
        Bstr = SysAllocString(*(ppszStringReferences + i));
        if(!Bstr) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_HRESULT_ERROR(hr);
        }
        
        hr = SafeArrayPutElement(pSafeArray, (long *)&i, Bstr);
        SysFreeString(Bstr);
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    var.vt = VT_ARRAY|VT_BSTR;
    var.parray = pSafeArray;
    hr = IWbemClassObject_Put(
        pInstWbemClassObject,
        pszValueName,
        0,
        &var,
        0
        );
    VariantClear(&var);
    BAIL_ON_HRESULT_ERROR(hr);
    

 error:

    return(hr);

}


DWORD
CopyFilterDSToWMIString(
    LPWSTR pszFilterDN,
    LPWSTR * ppszFilterName
    )
{
    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszFilterName = NULL;

    dwError = ComputePrelimCN(
        pszFilterDN,
        szCommonName
        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ComputeGUIDName(
        szCommonName,
        &pszGuidName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    pszFilterName = AllocPolBstrStr(pszGuidName);
    if (!pszFilterName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszFilterName = pszFilterName;
    
    return(dwError);
    
 error:
    
    *ppszFilterName = NULL;

    return(dwError);
    
}


DWORD
CopyNFADSToWMIString(
    LPWSTR pszNFADN,
    LPWSTR * ppszNFAName
    )
{
    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszNFAName = NULL;
    
    dwError = ComputePrelimCN(
        pszNFADN,
        szCommonName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = ComputeGUIDName(
        szCommonName,
        &pszGuidName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    pszNFAName = AllocPolBstrStr(pszGuidName);
    if (!pszNFAName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    *ppszNFAName = pszNFAName;
    
    return(dwError);
    
 error:
    
    *ppszNFAName = NULL;

    return(dwError);
    
}


DWORD
CopyNegPolDSToWMIString(
    LPWSTR pszNegPolDN,
    LPWSTR * ppszNegPolName
    )
{
    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszNegPolName = NULL;

    dwError = ComputePrelimCN(
        pszNegPolDN,
        szCommonName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = ComputeGUIDName(
        szCommonName,
        &pszGuidName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    pszNegPolName = AllocPolBstrStr(pszGuidName);
    if (!pszNegPolName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    *ppszNegPolName = pszNegPolName;
    
    return(dwError);
    
 error:
    
    *ppszNegPolName = NULL;

    return(dwError);

}


DWORD
CopyPolicyDSToWMIString(
    LPWSTR pszPolicyDN,
    LPWSTR * ppszPolicyName
    )
{
    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszPolicyName = NULL;
    
    dwError = ComputePrelimCN(
        pszPolicyDN,
        szCommonName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = ComputeGUIDName(
        szCommonName,
        &pszGuidName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    pszPolicyName = AllocPolBstrStr(pszGuidName);
    if (!pszPolicyName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    *ppszPolicyName = pszPolicyName;
    
    return(dwError);

 error:
    
    *ppszPolicyName = NULL;

    return(dwError);

}


DWORD
CopyISAKMPDSToWMIString(
    LPWSTR pszISAKMPDN,
    LPWSTR * ppszISAKMPName
    )
{
    DWORD dwError = 0;
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszGuidName = NULL;
    LPWSTR pszISAKMPName = NULL;

    dwError = ComputePrelimCN(
        pszISAKMPDN,
        szCommonName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = ComputeGUIDName(
        szCommonName,
        &pszGuidName
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    pszISAKMPName = AllocPolBstrStr(pszGuidName);
    if (!pszISAKMPName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    *ppszISAKMPName = pszISAKMPName;
    
    return(dwError);
    
 error:
    
    *ppszISAKMPName = NULL;

    return(dwError);

}


HRESULT
LogBlobPropertyEx(
    IWbemClassObject *pInstance,
    BSTR bstrPropName,
    BYTE *pbBlob,
    DWORD dwLen
    )
{
    HRESULT hr = S_OK;
    SAFEARRAYBOUND arrayBound[1];
    SAFEARRAY *pSafeArray = NULL;
    VARIANT var;
    DWORD i = 0;

    VariantInit(&var);
    
    arrayBound[0].lLbound = 0;
    arrayBound[0].cElements = dwLen;
    
    pSafeArray = SafeArrayCreate(VT_UI1, 1, arrayBound);
    if (!pSafeArray)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    for (i = 0; i < dwLen; i++)
    {
        hr = SafeArrayPutElement(pSafeArray, (long *)&i, &pbBlob[i]);
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    var.vt = VT_ARRAY|VT_UI1;
    var.parray = pSafeArray;
    hr = IWbemClassObject_Put(
        pInstance,
        bstrPropName,
        0,
        &var,
        0
        );
    VariantClear(&var);        
    BAIL_ON_HRESULT_ERROR(hr);
    
 error:

    return(hr);
    
}


HRESULT
DeleteWMIClassObject(
    IWbemServices *pWbemServices,
    LPWSTR pszIpsecWMIObject
    )
{
    HRESULT hr = S_OK;
    IEnumWbemClassObject *pEnum = NULL;
    IWbemClassObject *pObj = NULL;
    ULONG uReturned = 0;
    VARIANT var;
    BSTR bstrIpsecWMIObject = NULL;

    
    VariantInit(&var);

    bstrIpsecWMIObject = SysAllocString(pszIpsecWMIObject);
    if(!bstrIpsecWMIObject) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    hr = IWbemServices_CreateInstanceEnum(
        pWbemServices,
        bstrIpsecWMIObject,
        WBEM_FLAG_FORWARD_ONLY,
        0,
        &pEnum
        );
    SysFreeString(bstrIpsecWMIObject);
    BAIL_ON_HRESULT_ERROR(hr);

    uReturned = 1;
    while (SUCCEEDED(hr) && (uReturned == 1))
    {
        hr = IEnumWbemClassObject_Next(
            pEnum, 
            WBEM_INFINITE, 
            1, 
            &pObj, 
            &uReturned
            );
        if (SUCCEEDED(hr) && (uReturned == 1)) {
            hr = IWbemClassObject_Get(
                pObj,
                L"__RELPATH",
                0,
                &var,
                0,
                0
                );
            BAIL_ON_HRESULT_ERROR(hr);

            hr = IWbemServices_DeleteInstance(
                pWbemServices,
                var.bstrVal,
                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                NULL,
                NULL
                );
            BAIL_ON_HRESULT_ERROR(hr);
            
            //free
            if(pObj) {
                IWbemClassObject_Release(pObj);
                pObj = NULL;
            }
            VariantClear(&var);                
        } else {
            BAIL_ON_HRESULT_ERROR(hr);

            //
            // Even if SUCCEEDED(hr), loop will still terminate since uReturned != 1
            //  
        }
    }
    
    hr = S_OK;
    
 cleanup:
    
    if(pEnum)
        IEnumWbemClassObject_Release(pEnum);
    
    return(hr);
    
 error:
     if (pObj) {
        IWbemClassObject_Release(pObj);
        pObj = NULL;
     }
     VariantClear(&var);

    goto cleanup;
    
}

LPWSTR
AllocPolBstrStr(
    LPCWSTR pStr
)
{
   LPWSTR pMem=NULL;
   DWORD StrLen;

   if (!pStr)
      return 0;

   StrLen = wcslen(pStr);
   if (pMem = (LPWSTR)AllocPolMem( StrLen*sizeof(WCHAR) + sizeof(WCHAR)
        + sizeof(DWORD))) {
      wcscpy(pMem+2, pStr);  // Leaving 4 bytes for length
    }
    
    *(DWORD *)pMem = StrLen*sizeof(WCHAR);  

   return pMem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\procrule.c ===
#include "precomp.h"

DWORD
ProcessNFAs(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    DWORD dwStoreType,
    PDWORD pdwSlientErrorCode,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    DWORD NumberofRules = 0;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects = NULL;
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects = NULL;
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects = NULL;

    DWORD dwNumFilterObjects = 0;
    DWORD dwNumNegPolObjects = 0;

    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;

    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;

    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;

    DWORD dwNumNFACount = 0;


    NumberofRules = pIpsecPolicyObject->NumberofRulesReturned;

    ppIpsecNFAObjects = pIpsecPolicyObject->ppIpsecNFAObjects;
    ppIpsecFilterObjects = pIpsecPolicyObject->ppIpsecFilterObjects;
    ppIpsecNegPolObjects = pIpsecPolicyObject->ppIpsecNegPolObjects;

    dwNumFilterObjects = pIpsecPolicyObject->NumberofFilters;
    dwNumNegPolObjects = pIpsecPolicyObject->NumberofNegPols;



    __try {
    dwError = UnmarshallPolicyObject(
                    pIpsecPolicyObject,
                    dwStoreType,
                    &pIpsecPolicyData
                    );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = ERROR_INVALID_DATA;
    }
    BAIL_ON_WIN32_ERROR(dwError);


    __try {
    dwError = UnmarshallISAKMPObject(
                    *(pIpsecPolicyObject->ppIpsecISAKMPObjects),
                     &pIpsecPolicyData->pIpsecISAKMPData
                     );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = ERROR_INVALID_DATA;
    }
    BAIL_ON_WIN32_ERROR(dwError);


    ppIpsecNFAData = (PIPSEC_NFA_DATA *)AllocPolMem(
                                       sizeof(PIPSEC_NFA_DATA)* NumberofRules
                                       );
    if (!ppIpsecNFAData) {

        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);

    }

    for (i = 0; i < NumberofRules; i++) {

        pIpsecNFAObject = *(ppIpsecNFAObjects + i);


        dwError = ProcessNFA(
                        pIpsecNFAObject,
                        dwStoreType,
                        ppIpsecFilterObjects,
                        dwNumFilterObjects,
                        ppIpsecNegPolObjects,
                        dwNumNegPolObjects,
                        &pIpsecNFAData
                        );
        if (dwError == ERROR_SUCCESS) {

            if (pIpsecNFAData->dwActiveFlag != 0) {
                *(ppIpsecNFAData + dwNumNFACount) = pIpsecNFAData;
                dwNumNFACount++;
            }
            else {
                FreeIpsecNFAData(pIpsecNFAData);
            }
        }
        else {
            *pdwSlientErrorCode = dwError;
        }
    }

    pIpsecPolicyData->ppIpsecNFAData = ppIpsecNFAData;
    pIpsecPolicyData->dwNumNFACount  = dwNumNFACount;


    *ppIpsecPolicyData = pIpsecPolicyData;

    return(dwError);

error:

    if (pIpsecPolicyData) {

        FreeIpsecPolicyData(
                pIpsecPolicyData
                );
    }
    *ppIpsecPolicyData = NULL;


    return(dwError);

}

DWORD
ProcessNFA(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    DWORD dwStoreType,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;

    PIPSEC_NFA_DATA pIpsecNFAData = NULL;


    __try {
    dwError = UnmarshallNFAObject(
                    pIpsecNFAObject,
                    dwStoreType,
                    &pIpsecNFAData
                    );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = ERROR_INVALID_DATA;
    }
    BAIL_ON_WIN32_ERROR(dwError);


    if (pIpsecNFAObject->pszIpsecFilterReference &&
                        *pIpsecNFAObject->pszIpsecFilterReference) {


            dwError = FindIpsecFilterObject(
                            pIpsecNFAObject,
                            ppIpsecFilterObjects,
                            dwNumFilterObjects,
                            &pIpsecFilterObject
                            );
            BAIL_ON_WIN32_ERROR(dwError);

            __try {
            dwError = UnmarshallFilterObject(
                            pIpsecFilterObject,
                            &pIpsecNFAData->pIpsecFilterData
                            );
            } __except(EXCEPTION_EXECUTE_HANDLER) {
                dwError = ERROR_INVALID_DATA;
            }
            BAIL_ON_WIN32_ERROR(dwError);


    } else {

        //
        // We've received a NULL FilterReference or a NULL string FilterReference
        //
        //
        // This is acceptable - implies there is no filter associated
        //

        pIpsecNFAData->pIpsecFilterData = NULL;


    }

    dwError = FindIpsecNegPolObject(
                    pIpsecNFAObject,
                    ppIpsecNegPolObjects,
                    dwNumNegPolObjects,
                    &pIpsecNegPolObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    __try {
    dwError = UnmarshallNegPolObject(
                    pIpsecNegPolObject,
                    &pIpsecNFAData->pIpsecNegPolData
                    );
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        dwError = ERROR_INVALID_DATA;
    }
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecNFAData = pIpsecNFAData;

    return(dwError);


error:

    if (pIpsecNFAData) {

        FreeIpsecNFAData(
                pIpsecNFAData
                );
    }


    return(dwError);
}

DWORD
DeepCpyRsopInfo(
    PRSOP_INFO pDestRsop,
    PRSOP_INFO pSrcRsop
    )
{
    DWORD dwError = ERROR_SUCCESS;

    if (!pDestRsop || !pSrcRsop) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memset(pDestRsop, 0, sizeof(RSOP_INFO));    
    
    if (pSrcRsop->pszCreationtime && *pSrcRsop->pszCreationtime) {
        pDestRsop->pszCreationtime = AllocPolStr(
                                         pSrcRsop->pszCreationtime
                                         );
        if (!pDestRsop->pszCreationtime) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    if (pSrcRsop->pszID && *pSrcRsop->pszID) {    
        pDestRsop->pszID = AllocPolStr(
                             pSrcRsop->pszID
                             );
        if (!pDestRsop->pszID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    if (pSrcRsop->pszName && *pSrcRsop->pszName) {    
        pDestRsop->pszName = AllocPolStr(
                             pSrcRsop->pszName
                             );
        if (!pDestRsop->pszName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    pDestRsop->uiPrecedence = pSrcRsop->uiPrecedence;
    if (pSrcRsop->pszGPOID && *pSrcRsop->pszGPOID) {    
        pDestRsop->pszGPOID= AllocPolStr(
                             pSrcRsop->pszGPOID
                             );
        if (!pDestRsop->pszGPOID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    if (pSrcRsop->pszSOMID && *pSrcRsop->pszSOMID) {    
        pDestRsop->pszSOMID = AllocPolStr(
                             pSrcRsop->pszSOMID
                             );
        if (!pDestRsop->pszSOMID) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
error:
    return dwError;
}

DWORD SetPolstoreFlag(
    LPBYTE   pCur,
    LPBYTE   pStart,
    DWORD    dwLength,
    DWORD    LastError,
    DWORD  * pdwFlags
    )
{
    DWORD dwFlags = 0;
    LPBYTE pEnd;

    //
    // End of data is at end of buffer minus the NULL character
    //
    pEnd = pStart + dwLength - 1;
    
    if (LastError == ERROR_SUCCESS) {
        if (pCur + sizeof(GUID) >= pEnd) {
            dwFlags = POLSTORE_READWRITE;
        }
        else {
            dwFlags = POLSTORE_READONLY | POLSTORE_NEW_VER;
        }
    } else {
            dwFlags = POLSTORE_READONLY | POLSTORE_PARTIAL;
    }

    *pdwFlags = dwFlags;
    
    return ERROR_SUCCESS;
}
    

DWORD
UnmarshallPolicyObject(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    DWORD dwStoreType,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    LPBYTE pMem = NULL;
    LPWSTR pszIpsecISAKMPReference = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD dwPollingInterval = 0;
    DWORD dwFlags = 0;    
    DWORD dwError = 0;
    DWORD dwSkipSize = 0;

    // {6A1F5C6F-72B7-11d2-ACF0-0060B0ECCA17}
    GUID GUID_POLSTORE_VERSION_INFO =
    { 0x6a1f5c6f, 0x72b7, 0x11d2, { 0xac, 0xf0, 0x0, 0x60, 0xb0, 0xec, 0xca, 0x17 } };


    // {22202163-4F4C-11d1-863B-00A0248D3021}
    static const GUID GUID_IPSEC_POLICY_DATA_BLOB =
    { 0x22202163, 0x4f4c, 0x11d1, { 0x86, 0x3b, 0x0, 0xa0, 0x24, 0x8d, 0x30, 0x21 } };

    pMem = pIpsecPolicyObject->pIpsecData;
   
    //
    // Check if the first blob is the version.
    //

    if (!memcmp(pMem, &(GUID_POLSTORE_VERSION_INFO), sizeof(GUID))) {
        pMem += sizeof(GUID);

        memcpy(&dwSkipSize, pMem, sizeof(DWORD));
        pMem += sizeof(DWORD);
        pMem += dwSkipSize;
    }


    pMem += sizeof(GUID);
    pMem += sizeof(DWORD);


    memcpy((LPBYTE)&dwPollingInterval, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);

    (VOID) SetPolstoreFlag(
               pMem,
               pIpsecPolicyObject->pIpsecData,
               pIpsecPolicyObject->dwIpsecDataLen,
               ERROR_SUCCESS,
               &dwFlags
               );

    pIpsecPolicyData = (PIPSEC_POLICY_DATA)AllocPolMem(
                                sizeof(IPSEC_POLICY_DATA)
                                );
    if (!pIpsecPolicyData) {

        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (pIpsecPolicyObject->pszIpsecName && *(pIpsecPolicyObject->pszIpsecName)) {

        pIpsecPolicyData->pszIpsecName = AllocPolStr(
                                            pIpsecPolicyObject->pszIpsecName
                                            );
        if (!pIpsecPolicyData->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecPolicyObject->pszDescription && *(pIpsecPolicyObject->pszDescription)){

        pIpsecPolicyData->pszDescription = AllocPolStr(
                                            pIpsecPolicyObject->pszDescription
                                            );
        if (!pIpsecPolicyData->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    wGUIDFromString(pIpsecPolicyObject->pszIpsecID,
                    &pIpsecPolicyData->PolicyIdentifier
                    );

    switch(dwStoreType) {

    case IPSEC_WMI_PROVIDER:
        pIpsecPolicyData->pRsopInfo = (PRSOP_INFO)AllocPolMem(
                                sizeof(RSOP_INFO)
                                );
        if (!pIpsecPolicyData->pRsopInfo) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }    
        dwError = DeepCpyRsopInfo(
                      pIpsecPolicyData->pRsopInfo,
                      pIpsecPolicyObject->pRsopInfo
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        // no "break"; do everything we'd do for IPSEC_REGISTRY_PROVIDER as well.
    case IPSEC_REGISTRY_PROVIDER:
        dwError = GenGUIDFromRegISAKMPReference(
                      pIpsecPolicyObject->pszIpsecISAKMPReference,
                      &pIpsecPolicyData->ISAKMPIdentifier
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        break;
    case IPSEC_DIRECTORY_PROVIDER:
        dwError = CopyISAKMPDSToFQRegString(
                        pIpsecPolicyObject->pszIpsecISAKMPReference,
                        &pszIpsecISAKMPReference
                        );
        BAIL_ON_WIN32_ERROR(dwError);
        dwError = GenGUIDFromRegISAKMPReference(
                      pszIpsecISAKMPReference,
                      &pIpsecPolicyData->ISAKMPIdentifier
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    default:
         dwError = ERROR_INVALID_PARAMETER;
         BAIL_ON_WIN32_ERROR(dwError);

    }

    pIpsecPolicyData->dwWhenChanged = pIpsecPolicyObject->dwWhenChanged;

    pIpsecPolicyData->dwPollingInterval = dwPollingInterval;

    pIpsecPolicyData->dwFlags = dwFlags;

    *ppIpsecPolicyData = pIpsecPolicyData;

    if (pszIpsecISAKMPReference) {
        FreePolStr(pszIpsecISAKMPReference);
    }

    return(0);

error:

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    if (pszIpsecISAKMPReference) {
        FreePolStr(pszIpsecISAKMPReference);
    }

    *ppIpsecPolicyData = NULL;
    return(dwError);
}



DWORD
UnmarshallNFAObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    DWORD dwStoreType,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    )
{
    LPBYTE pMem = NULL;
    DWORD dwNumAuthMethods = 0;
    PIPSEC_AUTH_METHOD * ppIpsecAuthMethods = NULL;
    DWORD dwFlags = 0;    
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_AUTH_METHOD pIpsecAuthMethod = NULL;

    DWORD dwInterfaceType = 0;
    DWORD dwInterfaceNameLen = 0;
    LPWSTR pszInterfaceName = NULL;

    DWORD dwTunnelIpAddr = 0;
    DWORD dwTunnelFlags = 0;
    DWORD dwActiveFlag = 0;
    DWORD dwEndPointNameLen = 0;
    LPWSTR pszEndPointName = NULL;

    DWORD dwNumBytesAdvanced = 0;

    PIPSEC_NFA_DATA pIpsecNFAData = NULL;
    LPWSTR pszIpsecFilterReference = NULL;
    LPWSTR pszIpsecNegPolReference = NULL;

    // {11BBAC00-498D-11d1-8639-00A0248D3021}
    static const GUID GUID_IPSEC_NFA_BLOB =
    { 0x11bbac00, 0x498d, 0x11d1, { 0x86, 0x39, 0x0, 0xa0, 0x24, 0x8d, 0x30, 0x21 } };
    DWORD dwReadBytes = 0;
    GUID TmpGuid;
    DWORD dwNumAltAuthMethods = 0;


    pMem = pIpsecNFAObject->pIpsecData;

    pMem += sizeof(GUID);  // for the GUID
    pMem += sizeof(DWORD); // for the size

    memcpy((LPBYTE)&dwNumAuthMethods, pMem, sizeof(DWORD));


    pIpsecNFAData = (PIPSEC_NFA_DATA)AllocPolMem(
                                sizeof(IPSEC_NFA_DATA)
                                );
    if (!pIpsecNFAData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (dwNumAuthMethods) {
        ppIpsecAuthMethods  = (PIPSEC_AUTH_METHOD *) AllocPolMem(
                                sizeof(PIPSEC_AUTH_METHOD)*dwNumAuthMethods
                                );
        if (!ppIpsecAuthMethods) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    pMem += sizeof(DWORD);

    for (i = 0; i < dwNumAuthMethods;i++){


        __try {
        dwError = UnmarshallAuthMethods(
                        pMem,
                        &pIpsecAuthMethod,
                        &dwNumBytesAdvanced
                        );
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            dwError = ERROR_INVALID_DATA;
        }
        if (dwError) {

            pIpsecNFAData->dwAuthMethodCount = i;
            pIpsecNFAData->ppAuthMethods = ppIpsecAuthMethods;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pMem += dwNumBytesAdvanced;
        *(ppIpsecAuthMethods + i) = pIpsecAuthMethod;

    }
    pIpsecNFAData->dwAuthMethodCount =  dwNumAuthMethods;
    pIpsecNFAData->ppAuthMethods = ppIpsecAuthMethods;


    memcpy((LPBYTE)&dwInterfaceType, pMem, sizeof(DWORD));
    pIpsecNFAData->dwInterfaceType = dwInterfaceType;
    pMem += sizeof(DWORD);

    memcpy((LPBYTE)&dwInterfaceNameLen, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);

    if (dwInterfaceNameLen) {

        pszInterfaceName = AllocPolStr((LPWSTR)pMem);
        if (!pszInterfaceName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    pIpsecNFAData->pszInterfaceName = pszInterfaceName;
    pMem += dwInterfaceNameLen;


    memcpy((LPBYTE)&dwTunnelIpAddr, pMem, sizeof(DWORD));
    pIpsecNFAData->dwTunnelIpAddr = dwTunnelIpAddr;
    pMem += sizeof(DWORD);

    memcpy((LPBYTE)&dwTunnelFlags, pMem, sizeof(DWORD));
    pIpsecNFAData->dwTunnelFlags  = dwTunnelFlags;
    pMem += sizeof(DWORD);

    memcpy((LPBYTE)&dwActiveFlag, pMem, sizeof(DWORD));
    pIpsecNFAData->dwActiveFlag  = dwActiveFlag;
    pMem += sizeof(DWORD);


    memcpy((LPBYTE)&dwEndPointNameLen, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);

    if (dwEndPointNameLen) {
        pszEndPointName = AllocPolStr((LPWSTR)pMem);
        if (!pszEndPointName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    pIpsecNFAData->pszEndPointName = pszEndPointName;

    pMem += dwEndPointNameLen;

    __try {

    dwReadBytes = (DWORD) ((BYTE *) pMem - (BYTE *) pIpsecNFAObject->pIpsecData);

    if ((dwReadBytes < pIpsecNFAObject->dwIpsecDataLen) &&
        ((pIpsecNFAObject->dwIpsecDataLen - dwReadBytes) > sizeof(GUID))) {

        memset(&TmpGuid, 1, sizeof(GUID));

        if (memcmp(pMem, &TmpGuid, sizeof(GUID)) == 0) {

            pMem += sizeof(GUID);

            memcpy(&dwNumAltAuthMethods, pMem, sizeof(DWORD));
            pMem += sizeof(DWORD);

            if (dwNumAltAuthMethods == dwNumAuthMethods) {
                for (i = 0; i < dwNumAuthMethods; i++) {
                    dwError = UnmarshallAltAuthMethods(
                                  pMem,
                                  ppIpsecAuthMethods[i],
                                  &dwNumBytesAdvanced
                                  );
                    if (dwError) {
                        break;
                    }
                    pMem += dwNumBytesAdvanced;
                }
            }

        }

			dwReadBytes = (DWORD) ((BYTE *) pMem - (BYTE *) pIpsecNFAObject->pIpsecData);

			if ((dwReadBytes < pIpsecNFAObject->dwIpsecDataLen) &&
				((pIpsecNFAObject->dwIpsecDataLen - dwReadBytes) > sizeof(GUID))) {

				// Have V3 data
				pMem += sizeof(GUID);
				pMem += sizeof(DWORD);

				for (i=0; i < dwNumAuthMethods; i++) {
					memcpy(&((*ppIpsecAuthMethods[i]).dwAuthFlags),
						   pMem,
						   sizeof(DWORD));
					pMem += sizeof(DWORD);
				}

			}

    }

    } __except(EXCEPTION_EXECUTE_HANDLER) {

    }

    (VOID) SetPolstoreFlag(
               pMem,
               pIpsecNFAObject->pIpsecData,
               pIpsecNFAObject->dwIpsecDataLen,
               dwError,
               &dwFlags
               );

    dwError = ERROR_SUCCESS;

    //
    // Convert the ipsecID to its GUID format
    //

    wGUIDFromString(pIpsecNFAObject->pszIpsecID,
                    &pIpsecNFAData->NFAIdentifier
                    );

    if (pIpsecNFAObject->pszIpsecName && *(pIpsecNFAObject->pszIpsecName)) {

        pIpsecNFAData->pszIpsecName = AllocPolStr(
                                            pIpsecNFAObject->pszIpsecName
                                            );
        if (!pIpsecNFAData->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNFAObject->pszDescription && *(pIpsecNFAObject->pszDescription)) {

        pIpsecNFAData->pszDescription = AllocPolStr(
                                            pIpsecNFAObject->pszDescription
                                            );
        if (!pIpsecNFAData->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    switch(dwStoreType) {

    case IPSEC_WMI_PROVIDER:
    case IPSEC_REGISTRY_PROVIDER:

        dwError = GenGUIDFromRegFilterReference(
                      pIpsecNFAObject->pszIpsecFilterReference,
                      &pIpsecNFAData->FilterIdentifier
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = GenGUIDFromRegNegPolReference(
                      pIpsecNFAObject->pszIpsecNegPolReference,
                      &pIpsecNFAData->NegPolIdentifier
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        break;

    case IPSEC_DIRECTORY_PROVIDER:

        if (pIpsecNFAObject->pszIpsecFilterReference &&
            *pIpsecNFAObject->pszIpsecFilterReference) {
            dwError = CopyFilterDSToFQRegString(
                          pIpsecNFAObject->pszIpsecFilterReference,
                          &pszIpsecFilterReference
                          );
            BAIL_ON_WIN32_ERROR(dwError);
            dwError = GenGUIDFromRegFilterReference(
                          pszIpsecFilterReference,
                          &pIpsecNFAData->FilterIdentifier
                          );
            BAIL_ON_WIN32_ERROR(dwError);
        }

        dwError = CopyNegPolDSToFQRegString(
                      pIpsecNFAObject->pszIpsecNegPolReference,
                      &pszIpsecNegPolReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        dwError = GenGUIDFromRegNegPolReference(
                      pszIpsecNegPolReference,
                      &pIpsecNFAData->NegPolIdentifier
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        break;

    default:
         dwError = ERROR_INVALID_PARAMETER;
         BAIL_ON_WIN32_ERROR(dwError);

    }


    pIpsecNFAData->dwWhenChanged = pIpsecNFAObject->dwWhenChanged;
    pIpsecNFAData->dwFlags = dwFlags;

    *ppIpsecNFAData = pIpsecNFAData;

    if (pszIpsecFilterReference) {
        FreePolStr(pszIpsecFilterReference);
    }

    if (pszIpsecNegPolReference) {
        FreePolStr(pszIpsecNegPolReference);
    }

    return(0);

error:

    if (pIpsecNFAData) {
        FreeIpsecNFAData(pIpsecNFAData);
    }

    if (pszIpsecFilterReference) {
        FreePolStr(pszIpsecFilterReference);
    }

    if (pszIpsecNegPolReference) {
        FreePolStr(pszIpsecNegPolReference);
    }

    *ppIpsecNFAData = NULL;

    return(dwError);
}

DWORD
UnmarshallFilterObject(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    )
{

    LPBYTE pMem = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppIpsecFilterSpecs = NULL;
    PIPSEC_FILTER_SPEC  pIpsecFilterSpec = NULL;
    DWORD i = 0;
    DWORD dwNumBytesAdvanced = 0;
    DWORD dwFlags = 0;    
    
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    DWORD dwError = 0;

    // {80DC20B5-2EC8-11d1-A89E-00A0248D3021}
    static const GUID GUID_IPSEC_FILTER_BLOB =
    { 0x80dc20b5, 0x2ec8, 0x11d1, { 0xa8, 0x9e, 0x0, 0xa0, 0x24, 0x8d, 0x30, 0x21 } };


    pIpsecFilterData = (PIPSEC_FILTER_DATA)AllocPolMem(
                                sizeof(IPSEC_FILTER_DATA)
                                );
    if (!pIpsecFilterData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMem = pIpsecFilterObject->pIpsecData;

    pMem += sizeof(GUID);
    pMem += sizeof(DWORD);

    memcpy((LPBYTE)&dwNumFilterSpecs, pMem, sizeof(DWORD));

    if (dwNumFilterSpecs) {
        ppIpsecFilterSpecs  = (PIPSEC_FILTER_SPEC *)AllocPolMem(
                              sizeof(PIPSEC_FILTER_SPEC)*dwNumFilterSpecs
                              );
        if (!ppIpsecFilterSpecs) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    pMem += sizeof(DWORD);

    for (i = 0; i < dwNumFilterSpecs;i++){

        __try {
        dwError = UnmarshallFilterSpec(
                        pMem,
                        &pIpsecFilterSpec,
                        &dwNumBytesAdvanced
                        );
        } __except(EXCEPTION_EXECUTE_HANDLER) {
            dwError = ERROR_INVALID_DATA;
        }
        if (dwError) {

            pIpsecFilterData->dwNumFilterSpecs = i;
            pIpsecFilterData->ppFilterSpecs = ppIpsecFilterSpecs;
            BAIL_ON_WIN32_ERROR(dwError);
        }


        pMem += dwNumBytesAdvanced;
        *(ppIpsecFilterSpecs + i) = pIpsecFilterSpec;

    }
    pIpsecFilterData->dwNumFilterSpecs = dwNumFilterSpecs;
    pIpsecFilterData->ppFilterSpecs = ppIpsecFilterSpecs;
    (VOID) SetPolstoreFlag(
               pMem,
               pIpsecFilterObject->pIpsecData,
               pIpsecFilterObject->dwIpsecDataLen,
               ERROR_SUCCESS,
               &dwFlags
               );


    //
    // Convert the ipsecID to its GUID format
    //


    if (pIpsecFilterObject->pszIpsecName && *(pIpsecFilterObject->pszIpsecName)) {

        pIpsecFilterData->pszIpsecName = AllocPolStr(
                                            pIpsecFilterObject->pszIpsecName
                                            );
        if (!pIpsecFilterData->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecFilterObject->pszDescription && *(pIpsecFilterObject->pszDescription)) {

        pIpsecFilterData->pszDescription = AllocPolStr(
                                            pIpsecFilterObject->pszDescription
                                            );
        if (!pIpsecFilterData->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    wGUIDFromString(pIpsecFilterObject->pszIpsecID,
                    &pIpsecFilterData->FilterIdentifier
                    );
    pIpsecFilterData->dwWhenChanged = pIpsecFilterObject->dwWhenChanged;
    pIpsecFilterData->dwFlags = dwFlags;


    *ppIpsecFilterData = pIpsecFilterData;

    return(dwError);

error:

    if (pIpsecFilterData) {

        FreeIpsecFilterData(pIpsecFilterData);
    }

    *ppIpsecFilterData = NULL;

    return(dwError);
}

DWORD
UnmarshallNegPolObject(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    )
{

    LPBYTE pMem = NULL;
    DWORD dwNumSecurityOffers = 0;
    PIPSEC_SECURITY_METHOD pIpsecOffer = NULL;

    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    DWORD dwFlags = 0;    
    DWORD dwError = 0;

    // {80DC20B9-2EC8-11d1-A89E-00A0248D3021}
    static const GUID GUID_IPSEC_NEGPOLICY_BLOB =
    { 0x80dc20b9, 0x2ec8, 0x11d1, { 0xa8, 0x9e, 0x0, 0xa0, 0x24, 0x8d, 0x30, 0x21 } };



    pMem = pIpsecNegPolObject->pIpsecData;

    pIpsecNegPolData = (PIPSEC_NEGPOL_DATA)AllocPolMem(
                                sizeof(IPSEC_NEGPOL_DATA)
                                );
    if (!pIpsecNegPolData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    pMem += sizeof(GUID);
    pMem += sizeof(DWORD);


    memcpy((LPBYTE)&dwNumSecurityOffers, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);

    if (dwNumSecurityOffers) {

        pIpsecOffer = (PIPSEC_SECURITY_METHOD)AllocPolMem(
                                            sizeof(IPSEC_SECURITY_METHOD)*dwNumSecurityOffers
                                            );
        if (!pIpsecOffer) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        memcpy((LPBYTE)pIpsecOffer, pMem,
               sizeof(IPSEC_SECURITY_METHOD)*dwNumSecurityOffers);
               
        pMem += sizeof(IPSEC_SECURITY_METHOD)*dwNumSecurityOffers;
    }

    (VOID) SetPolstoreFlag(
               pMem,
               pIpsecNegPolObject->pIpsecData,
               pIpsecNegPolObject->dwIpsecDataLen,
               ERROR_SUCCESS,
               &dwFlags
               );

    //
    // Convert the ipsecID to its GUID format
    //



    if (pIpsecNegPolObject->pszIpsecName && *(pIpsecNegPolObject->pszIpsecName)) {

        pIpsecNegPolData->pszIpsecName = AllocPolStr(
                                            pIpsecNegPolObject->pszIpsecName
                                            );
        if (!pIpsecNegPolData->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNegPolObject->pszDescription && *(pIpsecNegPolObject->pszDescription)){

        pIpsecNegPolData->pszDescription = AllocPolStr(
                                            pIpsecNegPolObject->pszDescription
                                            );
        if (!pIpsecNegPolData->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    wGUIDFromString(pIpsecNegPolObject->pszIpsecID,
                    &pIpsecNegPolData->NegPolIdentifier
                    );

    wGUIDFromString(pIpsecNegPolObject->pszIpsecNegPolAction,
                    &pIpsecNegPolData->NegPolAction
                    );

    wGUIDFromString(pIpsecNegPolObject->pszIpsecNegPolType,
                    &pIpsecNegPolData->NegPolType
                    );

    pIpsecNegPolData->dwSecurityMethodCount = dwNumSecurityOffers;
    pIpsecNegPolData->pIpsecSecurityMethods = pIpsecOffer;

    pIpsecNegPolData->dwWhenChanged = pIpsecNegPolObject->dwWhenChanged;
    pIpsecNegPolData->dwFlags = dwFlags;

    *ppIpsecNegPolData = pIpsecNegPolData;
    return(0);

error:

    if (pIpsecOffer) {
        FreePolMem(pIpsecOffer);
    }

    if (pIpsecNegPolData) {
        FreeIpsecNegPolData(pIpsecNegPolData);
    }

    *ppIpsecNegPolData = NULL;
    return(dwError);
}

DWORD
ConvertBundleFlagToBundle(BYTE bBundleFlag,
                          PISAKMP_POLICY pIsakmpPolicy,
                          CRYPTO_BUNDLE *pBundle)
{

	if (bBundleFlag == BYTE_DES_MD5_2048) {
		pBundle->EncryptionAlgorithm.AlgorithmIdentifier = IPSEC_ESP_DES;
		pBundle->HashAlgorithm.AlgorithmIdentifier = IPSEC_AH_MD5;
		pBundle->OakleyGroup=DH_GROUP_2048;
	}
	if (bBundleFlag == BYTE_DES_SHA_2048) {
		pBundle->EncryptionAlgorithm.AlgorithmIdentifier = IPSEC_ESP_DES;
		pBundle->HashAlgorithm.AlgorithmIdentifier = IPSEC_AH_SHA;
		pBundle->OakleyGroup=DH_GROUP_2048;
	}
	if (bBundleFlag == BYTE_3DES_MD5_2048) {
		pBundle->EncryptionAlgorithm.AlgorithmIdentifier = IPSEC_ESP_3_DES;
		pBundle->HashAlgorithm.AlgorithmIdentifier = IPSEC_AH_MD5;
		pBundle->OakleyGroup=DH_GROUP_2048;
	}
	if (bBundleFlag == BYTE_3DES_SHA_2048) {
		pBundle->EncryptionAlgorithm.AlgorithmIdentifier = IPSEC_ESP_3_DES;
		pBundle->HashAlgorithm.AlgorithmIdentifier = IPSEC_AH_SHA;
		pBundle->OakleyGroup=DH_GROUP_2048;
	}

	pBundle->QuickModeLimit = pIsakmpPolicy->dwQMLimit;
	if (pBundle->QuickModeLimit == 1) {
		pBundle->PfsIdentityRequired = TRUE;
	}
	pBundle->Lifetime.Seconds = pIsakmpPolicy->dwLifetimeSec;

	return ERROR_SUCCESS;

}

DWORD
UnmarshallISAKMPObject(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    )
{

    LPBYTE pMem = NULL;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;

    DWORD dwNumISAKMPSecurityMethods = 0;
    PCRYPTO_BUNDLE pSecurityMethods = NULL;
    PCRYPTO_BUNDLE pSecurityMethod = NULL;
    DWORD dwFlags = 0;    
    DWORD i = 0;

    DWORD dwError = 0;

    DWORD dwNumLeadingBundles = 0;
    BYTE *pbLeadingBundleFlags = NULL;

    // {80DC20B8-2EC8-11d1-A89E-00A0248D3021}
    static const GUID GUID_IPSEC_ISAKMP_POLICY_BLOB =
    { 0x80dc20b8, 0x2ec8, 0x11d1, { 0xa8, 0x9e, 0x0, 0xa0, 0x24, 0x8d, 0x30, 0x21 } };

    // CHECK THIS PART

    pMem = pIpsecISAKMPObject->pIpsecData;

    pIpsecISAKMPData = (PIPSEC_ISAKMP_DATA) AllocPolMem(
                                sizeof(IPSEC_ISAKMP_DATA)
                                );
    if (!pIpsecISAKMPData) {

        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    pMem += sizeof(GUID);
    pMem += sizeof(DWORD);


    memcpy((LPBYTE)&pIpsecISAKMPData->ISAKMPPolicy, pMem, sizeof(ISAKMP_POLICY));
    pMem += sizeof(ISAKMP_POLICY);


    memcpy((LPBYTE)&dwNumISAKMPSecurityMethods, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);

    pbLeadingBundleFlags = pIpsecISAKMPData->ISAKMPPolicy.bLeadingBundleFlags;
    for (i=0; i < 4; i++) {
        if (pbLeadingBundleFlags[i] != 0) {
            dwNumLeadingBundles++;
        }
    }
            
    if (!dwNumISAKMPSecurityMethods && !dwNumLeadingBundles) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pSecurityMethods = (PCRYPTO_BUNDLE) AllocPolMem(
        sizeof(CRYPTO_BUNDLE)*(dwNumISAKMPSecurityMethods+dwNumLeadingBundles)
        );
    if (!pSecurityMethods) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwNumLeadingBundles; i++) {
        pSecurityMethod = pSecurityMethods + i;
        ConvertBundleFlagToBundle(pbLeadingBundleFlags[i],
                                  &pIpsecISAKMPData->ISAKMPPolicy, 
                                  pSecurityMethod);
    }

    for (i = 0; i < dwNumISAKMPSecurityMethods; i++) {

        pSecurityMethod = pSecurityMethods + (i + dwNumLeadingBundles);
        memcpy(pSecurityMethod, pMem, sizeof(CRYPTO_BUNDLE));
        if (pSecurityMethod->PseudoRandomFunction.Rounds) {
            ConvertBundleFlagToBundle((BYTE)pSecurityMethod->PseudoRandomFunction.Rounds,
                                      &pIpsecISAKMPData->ISAKMPPolicy,                                  
                                      pSecurityMethod);
            pSecurityMethod->PseudoRandomFunction.Rounds = 0;
        }
        pMem += sizeof(CRYPTO_BUNDLE);

    }
    pIpsecISAKMPData->dwNumISAKMPSecurityMethods = dwNumISAKMPSecurityMethods + dwNumLeadingBundles;
    pIpsecISAKMPData->pSecurityMethods = pSecurityMethods;
    
    (VOID) SetPolstoreFlag(
               pMem,
               pIpsecISAKMPObject->pIpsecData,
               pIpsecISAKMPObject->dwIpsecDataLen,
               ERROR_SUCCESS,
               &dwFlags
               );

    //
    // Convert the ipsecID to its GUID format
    //

    wGUIDFromString(pIpsecISAKMPObject->pszIpsecID,
                    &pIpsecISAKMPData->ISAKMPIdentifier
                    );

    pIpsecISAKMPData->dwWhenChanged = pIpsecISAKMPObject->dwWhenChanged;
    pIpsecISAKMPData->dwFlags = dwFlags;

    *ppIpsecISAKMPData = pIpsecISAKMPData;
    return(0);

error:

    if (pIpsecISAKMPData) {

        FreeIpsecISAKMPData(pIpsecISAKMPData);
    }

    *ppIpsecISAKMPData = NULL;
    return(dwError);

}


DWORD
FindIpsecFilterObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    )
{
    DWORD i = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;

    for (i = 0; i < dwNumFilterObjects; i++) {


        pIpsecFilterObject = *(ppIpsecFilterObjects + i);


        if (!_wcsicmp(pIpsecFilterObject->pszDistinguishedName,
                        pIpsecNFAObject->pszIpsecFilterReference)) {
            *ppIpsecFilterObject = pIpsecFilterObject;
            return(0);
        }

    }

    *ppIpsecFilterObject = NULL;
    return(ERROR_NOT_FOUND);
}


DWORD
FindIpsecNegPolObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObject
    )
{
    DWORD i = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;

    for (i = 0; i < dwNumNegPolObjects; i++) {


        pIpsecNegPolObject = *(ppIpsecNegPolObjects + i);


        if (!_wcsicmp(pIpsecNegPolObject->pszDistinguishedName,
                        pIpsecNFAObject->pszIpsecNegPolReference)) {
            *ppIpsecNegPolObject = pIpsecNegPolObject;
            return(0);
        }

    }

    *ppIpsecNegPolObject = NULL;
    return(ERROR_NOT_FOUND);
}

void
FreeIpsecFilterData(
    PIPSEC_FILTER_DATA pIpsecFilterData
    )
{

    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppIpsecFilterSpecs = NULL;
    DWORD i = 0;
    PIPSEC_FILTER_SPEC pIpsecFilterSpec = NULL;

    dwNumFilterSpecs = pIpsecFilterData->dwNumFilterSpecs;
    ppIpsecFilterSpecs = pIpsecFilterData->ppFilterSpecs;

    for (i = 0; i < dwNumFilterSpecs; i++) {

        pIpsecFilterSpec = *(ppIpsecFilterSpecs + i);

        if (pIpsecFilterSpec) {

            if (pIpsecFilterSpec->pszSrcDNSName){

                FreePolStr(pIpsecFilterSpec->pszSrcDNSName);
            }

            if (pIpsecFilterSpec->pszDestDNSName){

                FreePolStr(pIpsecFilterSpec->pszDestDNSName);
            }

            if (pIpsecFilterSpec->pszDescription){

                FreePolStr(pIpsecFilterSpec->pszDescription);
            }


            FreePolMem(pIpsecFilterSpec);

        }

    }

    FreePolMem(ppIpsecFilterSpecs);

    if (pIpsecFilterData->pszIpsecName) {
        FreePolStr(pIpsecFilterData->pszIpsecName);
    }

    if (pIpsecFilterData->pszDescription) {
        FreePolStr(pIpsecFilterData->pszDescription);
    }

    FreePolMem(pIpsecFilterData);

    return;
}




void
FreeIpsecISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    )
{
    if (pIpsecISAKMPData->pSecurityMethods) {
        FreePolMem(pIpsecISAKMPData->pSecurityMethods);

    }

    FreePolMem(pIpsecISAKMPData);
    return;
}



void
FreeIpsecNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    )
{
    if (pIpsecNegPolData->pIpsecSecurityMethods){

        FreePolMem(pIpsecNegPolData->pIpsecSecurityMethods);
    }

    if (pIpsecNegPolData->pszIpsecName) {
        FreePolStr(pIpsecNegPolData->pszIpsecName);
    }

    if (pIpsecNegPolData->pszDescription) {
        FreePolStr(pIpsecNegPolData->pszDescription);
    }

    FreePolMem(pIpsecNegPolData);

    return;
}


void
FreeIpsecNFAData(
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwNumAuthMethods = 0;
    PIPSEC_AUTH_METHOD * ppIpsecAuthMethods = NULL;
    DWORD i = 0;
    PIPSEC_AUTH_METHOD pIpsecAuthMethod = NULL;

    ppIpsecAuthMethods = pIpsecNFAData->ppAuthMethods;

    dwNumAuthMethods = pIpsecNFAData->dwAuthMethodCount;

    for (i = 0; i < dwNumAuthMethods; i++) {

        pIpsecAuthMethod = *(ppIpsecAuthMethods + i);

        if (pIpsecAuthMethod) {

            if (pIpsecAuthMethod->pszAuthMethod) {
                FreePolStr(pIpsecAuthMethod->pszAuthMethod);
            }
            if (pIpsecAuthMethod->pAltAuthMethod) {
                FreePolMem(pIpsecAuthMethod->pAltAuthMethod);
            }

            FreePolMem(pIpsecAuthMethod);

        }

    }

    if (pIpsecNFAData->ppAuthMethods) {
        FreePolMem(pIpsecNFAData->ppAuthMethods);
    }

    if (pIpsecNFAData->pszInterfaceName) {

        FreePolStr(pIpsecNFAData->pszInterfaceName);
    }


    if (pIpsecNFAData->pszEndPointName) {
        FreePolStr(pIpsecNFAData->pszEndPointName);
    }

    if (pIpsecNFAData->pIpsecFilterData) {
        FreeIpsecFilterData(pIpsecNFAData->pIpsecFilterData);
    }


    if (pIpsecNFAData->pIpsecNegPolData) {
        FreeIpsecNegPolData(pIpsecNFAData->pIpsecNegPolData);
    }

    if (pIpsecNFAData->pszIpsecName) {
        FreePolStr(pIpsecNFAData->pszIpsecName);
    }

    if (pIpsecNFAData->pszDescription) {
        FreePolStr(pIpsecNFAData->pszDescription);
    }

    FreePolMem(pIpsecNFAData);
}

void
FreeIpsecPolicyData(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD i = 0;
    DWORD dwNumNFACount = 0;
    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;

    dwNumNFACount = pIpsecPolicyData->dwNumNFACount;
    ppIpsecNFAData = pIpsecPolicyData->ppIpsecNFAData;
    pIpsecISAKMPData = pIpsecPolicyData->pIpsecISAKMPData;

    if (pIpsecISAKMPData) {
        FreeIpsecISAKMPData(
                pIpsecISAKMPData
                );
    }

    for (i = 0; i < dwNumNFACount; i++) {

        pIpsecNFAData = *(ppIpsecNFAData + i);

        if (pIpsecNFAData) {

            FreeIpsecNFAData(
                    pIpsecNFAData
                    );
        }

    }

    if (pIpsecPolicyData->ppIpsecNFAData) {
        FreePolMem(pIpsecPolicyData->ppIpsecNFAData);
    }

    if (pIpsecPolicyData->pszIpsecName) {
        FreePolStr(pIpsecPolicyData->pszIpsecName);
    }

    if (pIpsecPolicyData->pszDescription) {
        FreePolStr(pIpsecPolicyData->pszDescription);
    }

    if (pIpsecPolicyData->pRsopInfo) {
        FreeRsopInfo(
            pIpsecPolicyData->pRsopInfo
            );
    }

    if (pIpsecPolicyData) {
        FreePolMem(pIpsecPolicyData);
    }
}


DWORD
CopyIpsecPolicyData(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_DATA pNewIpsecPolicyData = NULL;

    DWORD dwNumberofRules = 0;
    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;

    PIPSEC_NFA_DATA pIpsecNFAData = NULL;
    PIPSEC_NFA_DATA pNewIpsecNFAData = NULL;

    PIPSEC_NFA_DATA * ppNewIpsecNFAData = NULL;

    DWORD i = 0;


    *ppIpsecPolicyData = NULL;

    pNewIpsecPolicyData = (PIPSEC_POLICY_DATA) AllocPolMem(
                                                sizeof(IPSEC_POLICY_DATA)
                                                );
    if (!pNewIpsecPolicyData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwNumberofRules = pIpsecPolicyData->dwNumNFACount;
    ppIpsecNFAData = pIpsecPolicyData->ppIpsecNFAData;

    if (dwNumberofRules) {
        ppNewIpsecNFAData = (PIPSEC_NFA_DATA *) AllocPolMem(
                                                       sizeof(PIPSEC_NFA_DATA)*
                                                       dwNumberofRules
                                                       );

        if (!ppNewIpsecNFAData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }

    for (i = 0; i < dwNumberofRules; i++) {

            pIpsecNFAData = *(ppIpsecNFAData + i);

            dwError = CopyIpsecNFAData(
                          pIpsecNFAData,
                          &pNewIpsecNFAData
                          );

            if (dwError) {
                pNewIpsecPolicyData->ppIpsecNFAData = ppNewIpsecNFAData;
                pNewIpsecPolicyData->dwNumNFACount = i;
                BAIL_ON_WIN32_ERROR(dwError);
            }

 	    *(ppNewIpsecNFAData + i) = pNewIpsecNFAData;
    }

    pNewIpsecPolicyData->ppIpsecNFAData = ppNewIpsecNFAData;
    pNewIpsecPolicyData->dwNumNFACount = dwNumberofRules;

    if (pIpsecPolicyData->pIpsecISAKMPData) {

        dwError = CopyIpsecISAKMPData(
                      pIpsecPolicyData->pIpsecISAKMPData,
                      &pNewIpsecPolicyData->pIpsecISAKMPData
                      );

        BAIL_ON_WIN32_ERROR(dwError);
    }

    pNewIpsecPolicyData->dwPollingInterval = pIpsecPolicyData->dwPollingInterval;
    pNewIpsecPolicyData->dwWhenChanged = pIpsecPolicyData->dwWhenChanged;
    pNewIpsecPolicyData->dwFlags = pIpsecPolicyData->dwFlags;
    memcpy(
        &(pNewIpsecPolicyData->PolicyIdentifier),
        &(pIpsecPolicyData->PolicyIdentifier),
        sizeof(GUID)
        );
    memcpy(
        &(pNewIpsecPolicyData->ISAKMPIdentifier),
        &(pIpsecPolicyData->ISAKMPIdentifier),
        sizeof(GUID)
        );

    if (pIpsecPolicyData->pszIpsecName &&
        *pIpsecPolicyData->pszIpsecName) {
        pNewIpsecPolicyData->pszIpsecName = AllocPolStr(
                                            pIpsecPolicyData->pszIpsecName
                                            );
        if (!pNewIpsecPolicyData->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecPolicyData->pszDescription &&
        *pIpsecPolicyData->pszDescription) {
        pNewIpsecPolicyData->pszDescription = AllocPolStr(
                                              pIpsecPolicyData->pszDescription
                                              );
        if (!pNewIpsecPolicyData->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecPolicyData->pRsopInfo) {
        pNewIpsecPolicyData->pRsopInfo = (PRSOP_INFO)AllocPolMem(
                                sizeof(RSOP_INFO)
                                );
        if (!pNewIpsecPolicyData->pRsopInfo) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }    
    
        dwError = DeepCpyRsopInfo(
                     pNewIpsecPolicyData->pRsopInfo,
                     pIpsecPolicyData->pRsopInfo
                     );
        BAIL_ON_WIN32_ERROR(dwError);
    }
        
    *ppIpsecPolicyData = pNewIpsecPolicyData;

    return (dwError);

error:

    if (pNewIpsecPolicyData) {
	FreeIpsecPolicyData(pNewIpsecPolicyData);
    }

    *ppIpsecPolicyData = NULL;

    return (dwError);

}

DWORD
CopyIpsecNFAData(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    )
{

    PIPSEC_NFA_DATA pNewIpsecNFAData = NULL;
    DWORD dwError = 0;
    DWORD i = 0;

    DWORD dwAuthMethodCount = 0;

    PIPSEC_AUTH_METHOD * ppAuthMethods = NULL;
    PIPSEC_AUTH_METHOD * ppNewAuthMethods = NULL;

    PIPSEC_AUTH_METHOD pAuthMethod = NULL;
    PIPSEC_AUTH_METHOD pNewAuthMethod = NULL;


    pNewIpsecNFAData = (PIPSEC_NFA_DATA) AllocPolMem(
                                                sizeof(IPSEC_NFA_DATA)
                                                );
    if (!pNewIpsecNFAData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);

    }

    dwAuthMethodCount = pIpsecNFAData->dwAuthMethodCount;
    ppAuthMethods = pIpsecNFAData->ppAuthMethods;

    if (dwAuthMethodCount) {
        ppNewAuthMethods = (PIPSEC_AUTH_METHOD *) AllocPolMem(
                                                       sizeof(PIPSEC_AUTH_METHOD)*
                                                       dwAuthMethodCount
                                                       );

        if (!ppNewAuthMethods) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }

    for (i = 0; i < dwAuthMethodCount; i++) {

            pAuthMethod = *(ppAuthMethods + i);

            dwError = CopyIpsecAuthMethod(
                          pAuthMethod,
                          &pNewAuthMethod
                          );

            if (dwError) {
                pNewIpsecNFAData->ppAuthMethods = ppNewAuthMethods;
                pNewIpsecNFAData->dwAuthMethodCount = i;
                BAIL_ON_WIN32_ERROR(dwError);
            }

 	    *(ppNewAuthMethods + i) = pNewAuthMethod;
    }

    pNewIpsecNFAData->ppAuthMethods = ppNewAuthMethods;
    pNewIpsecNFAData->dwAuthMethodCount = dwAuthMethodCount;


    if (pIpsecNFAData->pszIpsecName && *pIpsecNFAData->pszIpsecName) {
        pNewIpsecNFAData->pszIpsecName = AllocPolStr(
                                             pIpsecNFAData->pszIpsecName
                                             );

        if (!(pNewIpsecNFAData->pszIpsecName)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNFAData->pszDescription && *pIpsecNFAData->pszDescription) {
        pNewIpsecNFAData->pszDescription = AllocPolStr(
                                             pIpsecNFAData->pszDescription
                                             );

        if (!(pNewIpsecNFAData->pszDescription)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    memcpy(
        &(pNewIpsecNFAData->NFAIdentifier),
        &(pIpsecNFAData->NFAIdentifier),
        sizeof(GUID)
        );
    memcpy(
        &(pNewIpsecNFAData->FilterIdentifier),
        &(pIpsecNFAData->FilterIdentifier),
        sizeof(GUID)
        );
    memcpy(
        &(pNewIpsecNFAData->NegPolIdentifier),
        &(pIpsecNFAData->NegPolIdentifier),
        sizeof(GUID)
        );

    pNewIpsecNFAData->dwInterfaceType = pIpsecNFAData->dwInterfaceType;

    if (pIpsecNFAData->pszInterfaceName && *pIpsecNFAData->pszInterfaceName) {
        pNewIpsecNFAData->pszInterfaceName = AllocPolStr(
                                             pIpsecNFAData->pszInterfaceName
                                             );

        if (!(pNewIpsecNFAData->pszInterfaceName)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    pNewIpsecNFAData->dwTunnelIpAddr = pIpsecNFAData->dwTunnelIpAddr;
    pNewIpsecNFAData->dwTunnelFlags = pIpsecNFAData->dwTunnelFlags;
    pNewIpsecNFAData->dwActiveFlag = pIpsecNFAData->dwActiveFlag;

    if (pIpsecNFAData->pszEndPointName && *pIpsecNFAData->pszEndPointName) {
        pNewIpsecNFAData->pszEndPointName = AllocPolStr(
                                             pIpsecNFAData->pszEndPointName
                                             );

        if (!(pNewIpsecNFAData->pszEndPointName)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }


    if (pIpsecNFAData->pIpsecFilterData) {

        dwError = CopyIpsecFilterData(
                      pIpsecNFAData->pIpsecFilterData,
                      &pNewIpsecNFAData->pIpsecFilterData
                      );

        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (pIpsecNFAData->pIpsecNegPolData) {

        dwError = CopyIpsecNegPolData(
                      pIpsecNFAData->pIpsecNegPolData,
                      &pNewIpsecNFAData->pIpsecNegPolData
                      );

        BAIL_ON_WIN32_ERROR(dwError);
    }

    pNewIpsecNFAData->dwWhenChanged = pIpsecNFAData->dwWhenChanged;

    pNewIpsecNFAData->dwFlags = pIpsecNFAData->dwFlags;

    *ppIpsecNFAData = pNewIpsecNFAData;

    return(ERROR_SUCCESS);

error:

    if (pNewIpsecNFAData) {
        FreeIpsecNFAData(pNewIpsecNFAData);
    }

    *ppIpsecNFAData = NULL;

    return (dwError);

}


DWORD
CopyIpsecAuthMethod(
    PIPSEC_AUTH_METHOD   pAuthMethod,
    PIPSEC_AUTH_METHOD * ppAuthMethod
    )
{
    DWORD dwError = 0;
    PIPSEC_AUTH_METHOD pNewAuthMethod = NULL;

    pNewAuthMethod = (PIPSEC_AUTH_METHOD) AllocPolMem(
                                              sizeof(IPSEC_AUTH_METHOD)
                                              );

    if (!pNewAuthMethod) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pNewAuthMethod->dwAuthType = pAuthMethod->dwAuthType;
    pNewAuthMethod->dwAuthLen = pAuthMethod->dwAuthLen;

    if (pAuthMethod->pszAuthMethod) {
        pNewAuthMethod->pszAuthMethod = AllocPolStr(
                                            pAuthMethod->pszAuthMethod
                                            );

        if (!(pNewAuthMethod->pszAuthMethod)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    pNewAuthMethod->dwAltAuthLen = 0;
    pNewAuthMethod->pAltAuthMethod = NULL;

    if (pAuthMethod->dwAltAuthLen && pAuthMethod->pAltAuthMethod) {
        pNewAuthMethod->pAltAuthMethod = AllocPolMem(
                                             pAuthMethod->dwAltAuthLen
                                             );
        if (!(pNewAuthMethod->pAltAuthMethod)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        memcpy(
            pNewAuthMethod->pAltAuthMethod, 
            pAuthMethod->pAltAuthMethod,
            pAuthMethod->dwAltAuthLen
            );
        pNewAuthMethod->dwAltAuthLen = pAuthMethod->dwAltAuthLen;
    }
    pNewAuthMethod->dwAuthFlags = pAuthMethod->dwAuthFlags;


    *ppAuthMethod = pNewAuthMethod;

    return (ERROR_SUCCESS);

error:

    if (pNewAuthMethod) {
        if (pNewAuthMethod->pszAuthMethod) {
            FreePolStr(pNewAuthMethod->pszAuthMethod);
        }
        if (pNewAuthMethod->pAltAuthMethod) {
            FreePolMem(pNewAuthMethod->pAltAuthMethod);
        }
        FreePolMem(pNewAuthMethod);
    }

    *ppAuthMethod = NULL;

    return (dwError);

}


DWORD
CopyIpsecISAKMPData(
    PIPSEC_ISAKMP_DATA   pIpsecISAKMPData,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData = NULL;
    DWORD dwNumISAKMPSecurityMethods = 0;

    pNewIpsecISAKMPData = (PIPSEC_ISAKMP_DATA) AllocPolMem(
                                              sizeof(IPSEC_ISAKMP_DATA)
                                              );

    if (!pNewIpsecISAKMPData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    memcpy(
        &(pNewIpsecISAKMPData->ISAKMPIdentifier),
        &(pIpsecISAKMPData->ISAKMPIdentifier),
        sizeof(GUID)
        );

    memcpy(
        &(pNewIpsecISAKMPData->ISAKMPPolicy),
        &(pIpsecISAKMPData->ISAKMPPolicy),
        sizeof(ISAKMP_POLICY)
        );

    dwNumISAKMPSecurityMethods =
               pIpsecISAKMPData->dwNumISAKMPSecurityMethods;

    pNewIpsecISAKMPData->dwWhenChanged =
                         pIpsecISAKMPData->dwWhenChanged;

    pNewIpsecISAKMPData->dwFlags = 
               pIpsecISAKMPData->dwFlags;

    if (pIpsecISAKMPData->pSecurityMethods) {

        pNewIpsecISAKMPData->pSecurityMethods = (PCRYPTO_BUNDLE) AllocPolMem(
                                                                 sizeof(CRYPTO_BUNDLE) *
                                                                 dwNumISAKMPSecurityMethods
                                                                 );

        if (!(pNewIpsecISAKMPData->pSecurityMethods)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        memcpy(
            pNewIpsecISAKMPData->pSecurityMethods,
            pIpsecISAKMPData->pSecurityMethods,
            sizeof(CRYPTO_BUNDLE)*dwNumISAKMPSecurityMethods
            );
        pNewIpsecISAKMPData->dwNumISAKMPSecurityMethods =
                             pIpsecISAKMPData->dwNumISAKMPSecurityMethods;
    }
    else {
        pNewIpsecISAKMPData->pSecurityMethods = NULL;
        pNewIpsecISAKMPData->dwNumISAKMPSecurityMethods = 0;
    }

    *ppIpsecISAKMPData = pNewIpsecISAKMPData;

    return(ERROR_SUCCESS);

error:

    *ppIpsecISAKMPData = NULL;

    return (dwError);

}



DWORD
CopyIpsecFilterData(
    PIPSEC_FILTER_DATA pIpsecFilterData,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_FILTER_DATA pNewIpsecFilterData = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppFilterSpecs = NULL;
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs = NULL;

    PIPSEC_FILTER_SPEC pFilterSpecs = NULL;
    PIPSEC_FILTER_SPEC pNewFilterSpecs = NULL;


    pNewIpsecFilterData = (PIPSEC_FILTER_DATA) AllocPolMem(
                                                   sizeof(IPSEC_FILTER_DATA)
                                                   );

    if (!pNewIpsecFilterData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwNumFilterSpecs = pIpsecFilterData->dwNumFilterSpecs;
    ppFilterSpecs = pIpsecFilterData->ppFilterSpecs;

    if (dwNumFilterSpecs) {

        ppNewFilterSpecs = (PIPSEC_FILTER_SPEC *) AllocPolMem(
                                                   sizeof(PIPSEC_FILTER_SPEC)*
                                                   dwNumFilterSpecs
                                                   );
        if (!ppNewFilterSpecs) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumFilterSpecs; i++) {

            pFilterSpecs = *(ppFilterSpecs + i);

            dwError = CopyIpsecFilterSpec(
                          pFilterSpecs,
                          &pNewFilterSpecs
                          );

            if (dwError) {
                pNewIpsecFilterData->ppFilterSpecs = ppNewFilterSpecs;
                pNewIpsecFilterData->dwNumFilterSpecs = i;
                BAIL_ON_WIN32_ERROR(dwError);
            }

 	    *(ppNewFilterSpecs + i) = pNewFilterSpecs;
    }

    pNewIpsecFilterData->ppFilterSpecs = ppNewFilterSpecs;
    pNewIpsecFilterData->dwNumFilterSpecs = dwNumFilterSpecs;

    if (pIpsecFilterData->pszIpsecName && *pIpsecFilterData->pszIpsecName) {
        pNewIpsecFilterData->pszIpsecName = AllocPolStr(
                                             pIpsecFilterData->pszIpsecName
                                             );

        if (!(pNewIpsecFilterData->pszIpsecName)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecFilterData->pszDescription && *pIpsecFilterData->pszDescription) {
        pNewIpsecFilterData->pszDescription = AllocPolStr(
                                             pIpsecFilterData->pszDescription
                                             );

        if (!(pNewIpsecFilterData->pszDescription)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    memcpy(
        &(pNewIpsecFilterData->FilterIdentifier),
        &(pIpsecFilterData->FilterIdentifier),
        sizeof(GUID)
        );

    pNewIpsecFilterData->dwWhenChanged = pIpsecFilterData->dwWhenChanged;
    pNewIpsecFilterData->dwFlags = pIpsecFilterData->dwFlags;

    *ppIpsecFilterData = pNewIpsecFilterData;

    return(ERROR_SUCCESS);

error:

    if (pNewIpsecFilterData) {
        FreeIpsecFilterData(pNewIpsecFilterData);
    }
    *ppIpsecFilterData = NULL;
    return (dwError);

}


DWORD
CopyIpsecFilterSpec(
    PIPSEC_FILTER_SPEC   pFilterSpecs,
    PIPSEC_FILTER_SPEC * ppFilterSpecs
    )
{

   DWORD dwError = 0;
   PIPSEC_FILTER_SPEC   pNewFilterSpecs = NULL;

   pNewFilterSpecs = (PIPSEC_FILTER_SPEC) AllocPolMem(
                                              sizeof(IPSEC_FILTER_SPEC)
                                              );

   if (!pNewFilterSpecs) {
       dwError = ERROR_OUTOFMEMORY;
       BAIL_ON_WIN32_ERROR(dwError);
   }

   if (pFilterSpecs->pszSrcDNSName) {
        pNewFilterSpecs->pszSrcDNSName = AllocPolStr(
                                             pFilterSpecs->pszSrcDNSName
                                             );

        if (!(pNewFilterSpecs->pszSrcDNSName)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
   }

   if (pFilterSpecs->pszDestDNSName) {
        pNewFilterSpecs->pszDestDNSName = AllocPolStr(
                                             pFilterSpecs->pszDestDNSName
                                             );

        if (!(pNewFilterSpecs->pszDestDNSName)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
   }

   if (pFilterSpecs->pszDescription) {
        pNewFilterSpecs->pszDescription = AllocPolStr(
                                             pFilterSpecs->pszDescription
                                             );

        if (!(pNewFilterSpecs->pszDescription)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
   }

   memcpy(
       &(pNewFilterSpecs->FilterSpecGUID),
       &(pFilterSpecs->FilterSpecGUID),
       sizeof(GUID)
       );

   pNewFilterSpecs->dwMirrorFlag = pFilterSpecs->dwMirrorFlag;

   memcpy(
       &(pNewFilterSpecs->Filter),
       &(pFilterSpecs->Filter),
       sizeof(IPSEC_FILTER)
       );

   *ppFilterSpecs = pNewFilterSpecs;

   return(ERROR_SUCCESS);


error:

   if (pNewFilterSpecs) {
       if (pNewFilterSpecs->pszSrcDNSName){
            FreePolStr(pNewFilterSpecs->pszSrcDNSName);
       }
       if (pNewFilterSpecs->pszDestDNSName){
           FreePolStr(pNewFilterSpecs->pszDestDNSName);
       }
       if (pNewFilterSpecs->pszDescription){
           FreePolStr(pNewFilterSpecs->pszDescription);
       }
       FreePolMem(pNewFilterSpecs);
   }

   *ppFilterSpecs = NULL;

   return (dwError);

}


DWORD
CopyIpsecNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    )
{

    DWORD dwNumSecurityOffers = 0;

    PIPSEC_NEGPOL_DATA pNewIpsecNegPolData = NULL;
    DWORD dwError = 0;


    pNewIpsecNegPolData = (PIPSEC_NEGPOL_DATA) AllocPolMem(
                                                   sizeof(IPSEC_NEGPOL_DATA)
                                                   );
    if (!pNewIpsecNegPolData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwNumSecurityOffers = pIpsecNegPolData->dwSecurityMethodCount;

    if (dwNumSecurityOffers) {

        pNewIpsecNegPolData->pIpsecSecurityMethods = (PIPSEC_SECURITY_METHOD) AllocPolMem(
                                              sizeof(IPSEC_SECURITY_METHOD)*dwNumSecurityOffers
                                              );

        if (!(pNewIpsecNegPolData->pIpsecSecurityMethods)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        memcpy(
            (pNewIpsecNegPolData->pIpsecSecurityMethods),
            (pIpsecNegPolData->pIpsecSecurityMethods),
            sizeof(IPSEC_SECURITY_METHOD)*dwNumSecurityOffers
            );

        pNewIpsecNegPolData->dwSecurityMethodCount = dwNumSecurityOffers;

    }
    else {

        pNewIpsecNegPolData->dwSecurityMethodCount = 0;
        pNewIpsecNegPolData->pIpsecSecurityMethods = NULL;

    }

    if (pIpsecNegPolData->pszIpsecName && *pIpsecNegPolData->pszIpsecName) {
        pNewIpsecNegPolData->pszIpsecName = AllocPolStr(
                                             pIpsecNegPolData->pszIpsecName
                                             );

        if (!(pNewIpsecNegPolData->pszIpsecName)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNegPolData->pszDescription && *pIpsecNegPolData->pszDescription) {
        pNewIpsecNegPolData->pszDescription = AllocPolStr(
                                              pIpsecNegPolData->pszDescription
                                              );

        if (!(pNewIpsecNegPolData->pszDescription)) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //
    // Convert the ipsecID to its GUID format
    //

    memcpy(
        &(pNewIpsecNegPolData->NegPolIdentifier),
        &(pIpsecNegPolData->NegPolIdentifier),
        sizeof(GUID)
        );

    memcpy(
        &(pNewIpsecNegPolData->NegPolAction),
        &(pIpsecNegPolData->NegPolAction),
        sizeof(GUID)
        );

    memcpy(
        &(pNewIpsecNegPolData->NegPolType),
        &(pIpsecNegPolData->NegPolType),
        sizeof(GUID)
        );

    pNewIpsecNegPolData->dwWhenChanged = pIpsecNegPolData->dwWhenChanged;

    pNewIpsecNegPolData->dwFlags = pIpsecNegPolData->dwFlags;

    *ppIpsecNegPolData = pNewIpsecNegPolData;

    return (0);

error:

    if (pNewIpsecNegPolData) {
        FreeIpsecNegPolData(pNewIpsecNegPolData);
    }

    *ppIpsecNegPolData = NULL;

    return(dwError);

}


DWORD
UnmarshallFilterSpec(
    LPBYTE pMem,
    PIPSEC_FILTER_SPEC * ppIpsecFilterSpec,
    PDWORD pdwNumBytesAdvanced
    )
{
    DWORD dwSrcDNSNameLen = 0;
    LPWSTR pszSrcDNSName = NULL;
    DWORD dwDestDNSNameLen = 0;
    LPWSTR pszDestDNSName = NULL;
    DWORD dwDescriptionLen = 0;
    LPWSTR pszDescription = NULL;
    GUID FilterSpecGUID;
    DWORD dwMirrorFlag = 0;
    IPSEC_FILTER ipsecFilter;
    PIPSEC_FILTER_SPEC pIpsecFilterSpec = NULL;
    DWORD dwNumBytesAdvanced = 0;

    DWORD dwError = 0;

    *ppIpsecFilterSpec = NULL;
    *pdwNumBytesAdvanced = 0;

    memcpy((LPBYTE)&dwSrcDNSNameLen, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    dwNumBytesAdvanced += sizeof(DWORD);

    if (dwSrcDNSNameLen) {
        pszSrcDNSName = AllocPolStr((LPWSTR)pMem);
        if (!pszSrcDNSName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    pMem += dwSrcDNSNameLen;
    dwNumBytesAdvanced += dwSrcDNSNameLen;

    memcpy((LPBYTE)&dwDestDNSNameLen, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    dwNumBytesAdvanced += sizeof(DWORD);

    if (dwDestDNSNameLen) {
        pszDestDNSName = AllocPolStr((LPWSTR)pMem);
        if (!pszDestDNSName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    pMem += dwDestDNSNameLen;
    dwNumBytesAdvanced += dwDestDNSNameLen;

    memcpy((LPBYTE)&dwDescriptionLen, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    dwNumBytesAdvanced += sizeof(DWORD);

    if (dwDescriptionLen) {
        pszDescription = AllocPolStr((LPWSTR)pMem);
        if (!pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    pMem += dwDescriptionLen;
    dwNumBytesAdvanced += dwDescriptionLen;


    memcpy((LPBYTE)&FilterSpecGUID, pMem, sizeof(GUID));
    pMem += sizeof(GUID);
    dwNumBytesAdvanced += sizeof(GUID);

    memcpy((LPBYTE)&dwMirrorFlag, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    dwNumBytesAdvanced += sizeof(DWORD);

    memcpy((LPBYTE)&ipsecFilter, pMem, sizeof(IPSEC_FILTER));

    pIpsecFilterSpec = (PIPSEC_FILTER_SPEC)AllocPolMem(
                                sizeof(IPSEC_FILTER_SPEC)

                                 );
    if (!pIpsecFilterSpec) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    pMem += sizeof(IPSEC_FILTER);
    dwNumBytesAdvanced += sizeof(IPSEC_FILTER);

    pIpsecFilterSpec->pszSrcDNSName = pszSrcDNSName;
    pIpsecFilterSpec->pszDestDNSName = pszDestDNSName;
    pIpsecFilterSpec->pszDescription = pszDescription;
    pIpsecFilterSpec->dwMirrorFlag = dwMirrorFlag;

    memcpy((LPBYTE)&pIpsecFilterSpec->FilterSpecGUID, &FilterSpecGUID, sizeof(GUID));
    memcpy((LPBYTE)&pIpsecFilterSpec->Filter, &ipsecFilter, sizeof(IPSEC_FILTER));

    *ppIpsecFilterSpec = pIpsecFilterSpec;
    *pdwNumBytesAdvanced = dwNumBytesAdvanced;

    return(dwError);

error:

    if (pszSrcDNSName) {
        FreePolStr(pszSrcDNSName);
    }

    if (pszDestDNSName) {
        FreePolStr(pszDestDNSName);
    }


    if (pszDescription) {
        FreePolStr(pszDescription);
    }

    *ppIpsecFilterSpec = NULL;
    *pdwNumBytesAdvanced = 0;

    return(dwError);
}

DWORD
UnmarshallAuthMethods(
    LPBYTE pMem,
    PIPSEC_AUTH_METHOD * ppIpsecAuthMethod,
    PDWORD pdwNumBytesAdvanced
    )
{
    DWORD dwError = 0;
    DWORD dwAuthType = 0;
    DWORD dwAuthLen = 0;
    LPWSTR pszAuthMethod = NULL;
    PIPSEC_AUTH_METHOD pIpsecAuthMethod = NULL;
    DWORD dwNumBytesAdvanced = 0;

    pIpsecAuthMethod = (PIPSEC_AUTH_METHOD)AllocPolMem(
                                sizeof(IPSEC_AUTH_METHOD)
                                 );
    if (!pIpsecAuthMethod) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy((LPBYTE)&dwAuthType, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    dwNumBytesAdvanced += sizeof(DWORD);

    memcpy((LPBYTE)&dwAuthLen, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    dwNumBytesAdvanced += sizeof(DWORD);

    if (dwAuthLen) {

        pszAuthMethod = AllocPolStr((LPWSTR)pMem);
        if (!pszAuthMethod) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    pMem += dwAuthLen;
    dwNumBytesAdvanced += dwAuthLen;

    //
    // Unmarshall parameters.
    //

    pIpsecAuthMethod->dwAuthType = dwAuthType;
    pIpsecAuthMethod->dwAuthLen = (dwAuthLen - 2)/2;
    pIpsecAuthMethod->pszAuthMethod = pszAuthMethod;
    pIpsecAuthMethod->dwAltAuthLen = 0;
    pIpsecAuthMethod->pAltAuthMethod = NULL;

    *ppIpsecAuthMethod = pIpsecAuthMethod;
    *pdwNumBytesAdvanced = dwNumBytesAdvanced;

    return (dwError);

error:

    if (pszAuthMethod) {
        FreePolStr(pszAuthMethod);
    }

    if (pIpsecAuthMethod) {
        FreePolMem(pIpsecAuthMethod);
    }

    *ppIpsecAuthMethod = NULL;
    *pdwNumBytesAdvanced = 0;
    return (dwError);
}


DWORD
UnmarshallAltAuthMethods(
    LPBYTE pMem,
    PIPSEC_AUTH_METHOD pIpsecAuthMethod,
    PDWORD pdwNumBytesAdvanced
    )
{
    DWORD dwError = 0;
    DWORD dwAuthType = 0;
    DWORD dwAuthLen = 0;
    PBYTE pAltAuthMethod = NULL;
    DWORD dwNumBytesAdvanced = 0;


    memcpy((LPBYTE)&dwAuthType, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    dwNumBytesAdvanced += sizeof(DWORD);

    memcpy((LPBYTE)&dwAuthLen, pMem, sizeof(DWORD));
    pMem += sizeof(DWORD);
    dwNumBytesAdvanced += sizeof(DWORD);

    if (dwAuthLen) {
        pAltAuthMethod = (PBYTE) AllocPolMem(dwAuthLen);
        if (!pAltAuthMethod) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        memcpy(pAltAuthMethod, pMem, dwAuthLen);
    }
    pMem += dwAuthLen;
    dwNumBytesAdvanced += dwAuthLen;

    pIpsecAuthMethod->dwAltAuthLen = dwAuthLen;
    pIpsecAuthMethod->pAltAuthMethod = pAltAuthMethod;

    *pdwNumBytesAdvanced = dwNumBytesAdvanced;

    return (dwError);

error:

    if (pAltAuthMethod) {
        FreePolMem(pAltAuthMethod);
    }

    pIpsecAuthMethod->dwAltAuthLen = 0;
    pIpsecAuthMethod->pAltAuthMethod = NULL;

    *pdwNumBytesAdvanced = 0;
    return (dwError);
}

void
FreeRsopInfo(
    PRSOP_INFO pRsopInfo
    )
{
    if (pRsopInfo)  {
        FreePolStr(pRsopInfo->pszCreationtime);
        FreePolStr(pRsopInfo->pszID);
        FreePolStr(pRsopInfo->pszName);
        FreePolStr(pRsopInfo->pszGPOID);
        FreePolStr(pRsopInfo->pszSOMID);        
    }
}

void
FreeMulIpsecFilterData(
    PIPSEC_FILTER_DATA * ppIpsecFilterData,
    DWORD dwNumFilterObjects
    )
{
    DWORD i = 0;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;

    if (!ppIpsecFilterData) {
        return;
    }

    for (i = 0; i < dwNumFilterObjects; i++) {

        pIpsecFilterData = *(ppIpsecFilterData + i);

        if (pIpsecFilterData) {
            FreeIpsecFilterData(pIpsecFilterData);
        }
    }

    FreePolMem(ppIpsecFilterData);

    return;
}



void
FreeMulIpsecNegPolData(
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData,
    DWORD dwNumNegPolObjects
    )
{
    DWORD i = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;


    if (!ppIpsecNegPolData) {
        return;
    }

    for (i = 0; i < dwNumNegPolObjects; i++) {

        pIpsecNegPolData = *(ppIpsecNegPolData + i);

        if (pIpsecNegPolData) {
            FreeIpsecNegPolData(pIpsecNegPolData);
        }
    }

    FreePolMem(ppIpsecNegPolData);

    return;
}


void
FreeMulIpsecPolicyData(
    PIPSEC_POLICY_DATA * ppIpsecPolicyData,
    DWORD dwNumPolicyObjects
    )
{
    DWORD i = 0;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;


    if (!ppIpsecPolicyData) {
        return;
    }

    for (i = 0; i < dwNumPolicyObjects; i++) {

        pIpsecPolicyData = *(ppIpsecPolicyData + i);

        if (pIpsecPolicyData) {
            FreeIpsecPolicyData(pIpsecPolicyData);
        }
    }

    FreePolMem(ppIpsecPolicyData);

    return;
}


void
FreeMulIpsecNFAData(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFAObjects
    )
{
    DWORD i = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;


    if (!ppIpsecNFAData) {
        return;
    }

    for (i = 0; i < dwNumNFAObjects; i++) {

        pIpsecNFAData = *(ppIpsecNFAData + i);

        if (pIpsecNFAData) {
            FreeIpsecNFAData(pIpsecNFAData);
        }
    }

    FreePolMem(ppIpsecNFAData);

    return;
}


DWORD
GenGUIDFromRegFilterReference(
    LPWSTR pszIpsecFilterReference,
    GUID * FilterIdentifier
    )
{
    DWORD dwError = 0;
    LPWSTR pszGuid = NULL;

    if (pszIpsecFilterReference) {

        pszGuid = wcschr(pszIpsecFilterReference, L'{');

        if (!pszGuid) {
            dwError = ERROR_INVALID_DATA;
            return (dwError);
        }

        wGUIDFromString(pszGuid, FilterIdentifier);

    }else {
        memset(FilterIdentifier, 0, sizeof(GUID));
    }



    return(dwError);
}

DWORD
GenGUIDFromRegNegPolReference(
    LPWSTR pszIpsecNegPolReference,
    GUID * NegPolIdentifier
    )
{
    DWORD dwError = 0;
    LPWSTR pszGuid = NULL;

    if (pszIpsecNegPolReference) {

        pszGuid = wcschr(pszIpsecNegPolReference, L'{');

        if (!pszGuid) {
            dwError = ERROR_INVALID_DATA;
            return (dwError);
        }

        wGUIDFromString(pszGuid, NegPolIdentifier);


    }else {
        memset(NegPolIdentifier, 0, sizeof(GUID));
    }



    return(dwError);
}

DWORD
GenGUIDFromRegISAKMPReference(
    LPWSTR pszIpsecISAKMPReference,
    GUID * ISAKMPIdentifier
    )
{
    DWORD dwError = 0;
    LPWSTR pszGuid = NULL;

    if (pszIpsecISAKMPReference) {

        pszGuid = wcschr(pszIpsecISAKMPReference, L'{');

        if (!pszGuid) {
            dwError = ERROR_INVALID_DATA;
            return (dwError);
        }

        wGUIDFromString(pszGuid, ISAKMPIdentifier);

    }else {
        memset(ISAKMPIdentifier, 0, sizeof(GUID));
    }



    return(dwError);
}


void
FreeIpsecFilterSpecs(
    PIPSEC_FILTER_SPEC * ppIpsecFilterSpecs,
    DWORD dwNumFilterSpecs
    )
{

    DWORD i = 0;
    PIPSEC_FILTER_SPEC pIpsecFilterSpec = NULL;

    for (i = 0; i < dwNumFilterSpecs; i++) {

        pIpsecFilterSpec = *(ppIpsecFilterSpecs + i);

        if (pIpsecFilterSpec) {

            FreeIpsecFilterSpec(pIpsecFilterSpec);

        }

    }

    FreePolMem(ppIpsecFilterSpecs);
}

void
FreeIpsecFilterSpec(
    PIPSEC_FILTER_SPEC pIpsecFilterSpec
    )
{
    if (pIpsecFilterSpec->pszSrcDNSName){

        FreePolStr(pIpsecFilterSpec->pszSrcDNSName);
    }

    if (pIpsecFilterSpec->pszDestDNSName){

        FreePolStr(pIpsecFilterSpec->pszDestDNSName);
    }

    if (pIpsecFilterSpec->pszDescription){

        FreePolStr(pIpsecFilterSpec->pszDescription);
    }


    FreePolMem(pIpsecFilterSpec);

    return;
}


void
FreeMulIpsecISAKMPData(
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData,
    DWORD dwNumISAKMPObjects
    )
{
    DWORD i = 0;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;


    if (!ppIpsecISAKMPData) {
        return;
    }

    for (i = 0; i < dwNumISAKMPObjects; i++) {

        pIpsecISAKMPData = *(ppIpsecISAKMPData + i);

        if (pIpsecISAKMPData) {
            FreeIpsecISAKMPData(pIpsecISAKMPData);
        }
    }

    FreePolMem(ppIpsecISAKMPData);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\persist.h ===
DWORD
CacheDirectorytoRegistry(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    );

DWORD
PersistRegistryObject(
    PIPSEC_POLICY_OBJECT pIpsecRegPolicyObject
    );

DWORD
PersistNegPolObjects(
    HKEY hRegistryKey,
    PIPSEC_NEGPOL_OBJECT *ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects
    );


DWORD
PersistFilterObjects(
    HKEY hRegistryKey,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects
    );


DWORD
PersistNFAObjects(
    HKEY hRegistryKey,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects,
    DWORD dwNumNFAObjects
    );

DWORD
PersistISAKMPObjects(
    HKEY hRegistryKey,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects,
    DWORD dwNumISAKMPObjects
    );


DWORD
PersistPolicyObject(
    HKEY hRegistryKey,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    );

DWORD
PersistNFAObject(
    HKEY hRegistryKey,
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    );

DWORD
PersistFilterObject(
    HKEY hRegistryKey,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    );

DWORD
PersistNegPolObject(
    HKEY hRegistryKey,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    );

DWORD
PersistISAKMPObject(
    HKEY hRegistryKey,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    );



DWORD
CloneDirectoryPolicyObject(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    PIPSEC_POLICY_OBJECT * ppIpsecRegPolicyObject
    );

DWORD
CloneDirectoryNFAObjects(
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects,
    DWORD dwNumNFAObjects,
    PIPSEC_NFA_OBJECT ** pppIpsecRegNFAObjects
    );


DWORD
CloneDirectoryFilterObjects(
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects,
    PIPSEC_FILTER_OBJECT ** pppIpsecRegFilterObjects
    );


DWORD
CloneDirectoryNegPolObjects(
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecRegNegPolObjects
    );

DWORD
CloneDirectoryISAKMPObjects(
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects,
    DWORD dwNumISAKMPObjects,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecRegISAKMPObjects
    );

DWORD
CloneDirectoryFilterObject(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PIPSEC_FILTER_OBJECT * ppIpsecRegFilterObject
    );

DWORD
CloneDirectoryNegPolObject(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PIPSEC_NEGPOL_OBJECT * ppIpsecRegNegPolObject
    );

DWORD
CloneDirectoryNFAObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_NFA_OBJECT * ppIpsecRegNFAObject
    );

DWORD
CloneDirectoryISAKMPObject(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PIPSEC_ISAKMP_OBJECT * ppIpsecRegISAKMPObject
    );

DWORD
DeleteRegistryCache();

DWORD
CopyBinaryValue(
    LPBYTE pMem,
    DWORD dwMemSize,
    LPBYTE * ppNewMem
    );

DWORD
CopyFilterDSToRegString(
    LPWSTR pszFilterDN,
    LPWSTR * ppszFilterName
    );

DWORD
CopyNFADSToRegString(
    LPWSTR pszNFADN,
    LPWSTR * ppszNFAName
    );

DWORD
CopyNegPolDSToRegString(
    LPWSTR pszNegPolDN,
    LPWSTR * ppszNegPolName
    );

DWORD
CopyPolicyDSToRegString(
    LPWSTR pszPolicyDN,
    LPWSTR * ppszPolicyName
    );

DWORD
CopyISAKMPDSToRegString(
    LPWSTR pszISAKMPDN,
    LPWSTR * ppszISAKMPName
    );

DWORD
ComputeGUIDName(
    LPWSTR szCommonName,
    LPWSTR * ppszGuidName
    );

DWORD
CloneNFAReferencesDSToRegistry(
    LPWSTR * ppszIpsecNFAReferences,
    DWORD dwNFACount,
    LPWSTR * * pppszIpsecRegNFAReferences,
    PDWORD pdwRegNFACount
    );

DWORD
RegWriteMultiValuedString(
    HKEY hRegKey,
    LPWSTR pszValueName,
    LPWSTR * ppszStringReferences,
    DWORD dwNumStringReferences
    );

DWORD
CopyFilterDSToFQRegString(
    LPWSTR pszFilterDN,
    LPWSTR * ppszFilterName
    );

DWORD
CopyNFADSToFQRegString(
    LPWSTR pszNFADN,
    LPWSTR * ppszNFAName
    );

DWORD
CopyNegPolDSToFQRegString(
    LPWSTR pszNegPolDN,
    LPWSTR * ppszNegPolName
    );

DWORD
CopyPolicyDSToFQRegString(
    LPWSTR pszPolicyDN,
    LPWSTR * ppszPolicyName
    );

DWORD
CopyISAKMPDSToFQRegString(
    LPWSTR pszISAKMPDN,
    LPWSTR * ppszISAKMPName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\procrule.h ===
typedef struct _spec_buffer{
    DWORD dwSize;
    LPBYTE pMem;
} SPEC_BUFFER, *PSPEC_BUFFER;

void
FreeRsopInfo(
    PRSOP_INFO pRsopInfo
    );

DWORD
ProcessNFAs(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    DWORD dwStoreType,
    PDWORD pdwSlientErrorCode,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );

DWORD
ProcessNFA(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    DWORD dwStoreType,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    );


DWORD
UnmarshallPolicyObject(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    DWORD dwStoreType,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );

DWORD
UnmarshallNFAObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    DWORD dwStoreType,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    );

DWORD
UnmarshallFilterObject(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    );

DWORD
UnmarshallNegPolObject(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    );

DWORD
UnmarshallISAKMPObject(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    );


DWORD
FindIpsecFilterObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    );


DWORD
FindIpsecNegPolObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObject
    );


DWORD
UnmarshallFilterSpec(
    LPBYTE pMem,
    PIPSEC_FILTER_SPEC * ppIpsecFilterSpec,
    PDWORD pdwNumBytesAdvanced
    );

DWORD
UnmarshallAuthMethods(
    LPBYTE pMem,
    PIPSEC_AUTH_METHOD * ppIpsecAuthMethod,
    PDWORD pdwNumBytesAdvanced
    );

DWORD
UnmarshallAltAuthMethods(
    LPBYTE pMem,
    PIPSEC_AUTH_METHOD pIpsecAuthMethod,
    PDWORD pdwNumBytesAdvanced
    );

DWORD
GenGUIDFromRegFilterReference(
    LPWSTR pszIpsecFilterReference,
    GUID * FilterIdentifier
    );

DWORD
GenGUIDFromRegNegPolReference(
    LPWSTR pszIpsecNegPolReference,
    GUID * NegPolIdentifier
    );

DWORD
GenGUIDFromRegISAKMPReference(
    LPWSTR pszIpsecISAKMPReference,
    GUID * ISAKMPIdentifier
    );
DWORD SetPolstoreFlag(
    LPBYTE   pCur,
    LPBYTE   pStart,
    DWORD    dwLength,
    DWORD    LastError,
    DWORD  * pdwFlags
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\regstore.c ===
#include "precomp.h"

LPWSTR gpszIpsecRegContainer = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Local";


DWORD
OpenRegistryIPSECRootKey(
    LPWSTR pszServerName,
    LPWSTR pszIpsecRegRootContainer,
    HKEY * phRegistryKey
    )
{
    DWORD dwError = 0;

    dwError = RegOpenKeyExW(
                    HKEY_LOCAL_MACHINE,
                    (LPCWSTR) pszIpsecRegRootContainer,
                    0,
                    KEY_ALL_ACCESS,
                    phRegistryKey
                    );

    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
ReadPolicyObjectFromRegistry(
    HKEY hRegistryKey,
    LPWSTR pszPolicyDN,
    LPWSTR pszIpsecRegRootContainer,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    )
{

    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;

    DWORD dwNumNFAObjectsReturned = 0;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects = NULL;
    LPWSTR * ppszFilterReferences = NULL;
    DWORD dwNumFilterReferences = 0;
    LPWSTR * ppszNegPolReferences = NULL;
    DWORD dwNumNegPolReferences = 0;

    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects = NULL;
    DWORD dwNumFilterObjects = 0;

    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects = NULL;
    DWORD dwNumNegPolObjects = 0;

    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects = NULL;
    DWORD dwNumISAKMPObjects = 0;


    dwError = UnMarshallRegistryPolicyObject(
                    hRegistryKey,
                    pszIpsecRegRootContainer,
                    pszPolicyDN,
                    REG_FULLY_QUALIFIED_NAME,
                    &pIpsecPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ReadNFAObjectsFromRegistry(
                        hRegistryKey,
                        pszIpsecRegRootContainer,
                        pIpsecPolicyObject->pszIpsecOwnersReference,
                        pIpsecPolicyObject->ppszIpsecNFAReferences,
                        pIpsecPolicyObject->NumberofRules,
                        &ppIpsecNFAObjects,
                        &dwNumNFAObjectsReturned,
                        &ppszFilterReferences,
                        &dwNumFilterReferences,
                        &ppszNegPolReferences,
                        &dwNumNegPolReferences
                        );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = ReadFilterObjectsFromRegistry(
                        hRegistryKey,
                        pszIpsecRegRootContainer,
                        ppszFilterReferences,
                        dwNumFilterReferences,
                        &ppIpsecFilterObjects,
                        &dwNumFilterObjects
                        );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = ReadNegPolObjectsFromRegistry(
                        hRegistryKey,
                        pszIpsecRegRootContainer,
                        ppszNegPolReferences,
                        dwNumNegPolReferences,
                        &ppIpsecNegPolObjects,
                        &dwNumNegPolObjects
                        );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = ReadISAKMPObjectsFromRegistry(
                        hRegistryKey,
                        pszIpsecRegRootContainer,
                        &pIpsecPolicyObject->pszIpsecISAKMPReference,
                        1,
                        &ppIpsecISAKMPObjects,
                        &dwNumISAKMPObjects
                        );
    BAIL_ON_WIN32_ERROR(dwError);


    pIpsecPolicyObject->ppIpsecNFAObjects = ppIpsecNFAObjects;
    pIpsecPolicyObject->NumberofRulesReturned = dwNumNFAObjectsReturned;
    pIpsecPolicyObject->NumberofFilters = dwNumFilterObjects;
    pIpsecPolicyObject->ppIpsecFilterObjects = ppIpsecFilterObjects;
    pIpsecPolicyObject->ppIpsecNegPolObjects = ppIpsecNegPolObjects;
    pIpsecPolicyObject->NumberofNegPols = dwNumNegPolObjects;
    pIpsecPolicyObject->NumberofISAKMPs = dwNumISAKMPObjects;
    pIpsecPolicyObject->ppIpsecISAKMPObjects = ppIpsecISAKMPObjects;


    *ppIpsecPolicyObject = pIpsecPolicyObject;

cleanup:

    if (ppszFilterReferences) {

        FreeFilterReferences(
                ppszFilterReferences,
                dwNumFilterReferences
                );
    }

    if (ppszNegPolReferences) {

        FreeNegPolReferences(
                ppszNegPolReferences,
                dwNumNegPolReferences
                );
    }


    return(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
                pIpsecPolicyObject
                );
    }

    *ppIpsecPolicyObject = NULL;


    goto cleanup;

}

DWORD
ReadNFAObjectsFromRegistry(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecOwnerReference,
    LPWSTR * ppszNFADNs,
    DWORD dwNumNfaObjects,
    PIPSEC_NFA_OBJECT ** pppIpsecNFAObjects,
    PDWORD pdwNumNfaObjects,
    LPWSTR ** pppszFilterReferences,
    PDWORD pdwNumFilterReferences,
    LPWSTR ** pppszNegPolReferences,
    PDWORD pdwNumNegPolReferences
    )
{

    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject =  NULL;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects = NULL;
    LPWSTR * ppszFilterReferences = NULL;
    LPWSTR * ppszNegPolReferences = NULL;
    LPWSTR pszFilterReference = NULL;
    LPWSTR pszNegPolReference = NULL;
    DWORD dwNumFilterReferences = 0;
    DWORD dwNumNegPolReferences = 0;
    BOOL bNewNegPolReference = TRUE;

    DWORD dwNumNFAObjectsReturned = 0;

    *pppszNegPolReferences = NULL;
    *pdwNumFilterReferences = 0;
    *pppszFilterReferences = NULL;
    *pdwNumNegPolReferences = 0;
    *pppIpsecNFAObjects = NULL;
    *pdwNumNfaObjects = 0;

    ppIpsecNFAObjects  = (PIPSEC_NFA_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_NFA_OBJECT)*dwNumNfaObjects
                                            );
    if (!ppIpsecNFAObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    ppszFilterReferences = (LPWSTR *)AllocPolMem(
                                        sizeof(LPWSTR)*dwNumNfaObjects
                                        );
    if (!ppszFilterReferences) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppszNegPolReferences = (LPWSTR *)AllocPolMem(
                                        sizeof(LPWSTR)*dwNumNfaObjects
                                        );
    if (!ppszNegPolReferences) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwNumNfaObjects; i++) {


        dwError =UnMarshallRegistryNFAObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    *(ppszNFADNs + i),
                    &pIpsecNFAObject,
                    &pszFilterReference,
                    &pszNegPolReference
                    );

        if (dwError == ERROR_SUCCESS) {

            *(ppIpsecNFAObjects + dwNumNFAObjectsReturned) = pIpsecNFAObject;

            if (pszFilterReference) {

                *(ppszFilterReferences + dwNumFilterReferences) = pszFilterReference;
                dwNumFilterReferences++;

            }

            if (pszNegPolReference) {
                bNewNegPolReference = !(IsStringInArray(
                                            ppszNegPolReferences,
                                            pszNegPolReference,
                                            dwNumNegPolReferences
                                            ));
                
                if (bNewNegPolReference) {
                    *(ppszNegPolReferences + dwNumNegPolReferences) = pszNegPolReference;
                    dwNumNegPolReferences++;
                } else {
                    FreePolStr(pszNegPolReference);
                    pszNegPolReference = NULL;
                }    
            }

            dwNumNFAObjectsReturned++;

        }

    }

    if (dwNumNFAObjectsReturned == 0) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *pppszFilterReferences = ppszFilterReferences;
    *pppszNegPolReferences = ppszNegPolReferences;

    *pppIpsecNFAObjects = ppIpsecNFAObjects;
    *pdwNumNfaObjects = dwNumNFAObjectsReturned;
    *pdwNumNegPolReferences = dwNumNegPolReferences;
    *pdwNumFilterReferences = dwNumFilterReferences;




    dwError = ERROR_SUCCESS;

cleanup:

    return(dwError);

error:

    if (ppszNegPolReferences) {
        FreeNegPolReferences(
                ppszNegPolReferences,
                dwNumNFAObjectsReturned
                );
    }


    if (ppszFilterReferences) {
        FreeFilterReferences(
                ppszFilterReferences,
                dwNumNFAObjectsReturned
                );
    }

    if (ppIpsecNFAObjects) {

        FreeIpsecNFAObjects(
                ppIpsecNFAObjects,
                dwNumNFAObjectsReturned
                );

    }

    *pppszNegPolReferences = NULL;
    *pppszFilterReferences = NULL;
    *pppIpsecNFAObjects = NULL;
    *pdwNumNfaObjects = 0;
    *pdwNumNegPolReferences = 0;
    *pdwNumFilterReferences = 0;

    goto cleanup;
}


DWORD
ReadFilterObjectsFromRegistry(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszFilterDNs,
    DWORD dwNumFilterObjects,
    PIPSEC_FILTER_OBJECT ** pppIpsecFilterObjects,
    PDWORD pdwNumFilterObjects
    )
{

    DWORD dwError = 0;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject =  NULL;
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects = NULL;

    DWORD dwNumFilterObjectsReturned = 0;


    *pppIpsecFilterObjects = NULL;
    *pdwNumFilterObjects = 0;

    ppIpsecFilterObjects  = (PIPSEC_FILTER_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_FILTER_OBJECT)*dwNumFilterObjects
                                            );
    if (!ppIpsecFilterObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwNumFilterObjects; i++) {

        dwError =UnMarshallRegistryFilterObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    *(ppszFilterDNs + i),
                    REG_FULLY_QUALIFIED_NAME,
                    &pIpsecFilterObject
                    );
        if (dwError == ERROR_SUCCESS) {

            *(ppIpsecFilterObjects + dwNumFilterObjectsReturned) = pIpsecFilterObject;
            dwNumFilterObjectsReturned++;

        }


    }

    *pppIpsecFilterObjects = ppIpsecFilterObjects;
    *pdwNumFilterObjects = dwNumFilterObjectsReturned;

    dwError = ERROR_SUCCESS;

    return(dwError);

error:


    if (ppIpsecFilterObjects) {

        FreeIpsecFilterObjects(
                    ppIpsecFilterObjects,
                    dwNumFilterObjectsReturned
                    );
    }

    *pppIpsecFilterObjects = NULL;
    *pdwNumFilterObjects = 0;


    return(dwError);
}



DWORD
ReadNegPolObjectsFromRegistry(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszNegPolDNs,
    DWORD dwNumNegPolObjects,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecNegPolObjects,
    PDWORD pdwNumNegPolObjects
    )
{

    DWORD dwError = 0;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject =  NULL;
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects = NULL;

    DWORD dwNumNegPolObjectsReturned = 0;


    *pppIpsecNegPolObjects = NULL;
    *pdwNumNegPolObjects = 0;

    ppIpsecNegPolObjects  = (PIPSEC_NEGPOL_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_NEGPOL_OBJECT)*dwNumNegPolObjects
                                            );
    if (!ppIpsecNegPolObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwNumNegPolObjects; i++) {

        dwError =UnMarshallRegistryNegPolObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    *(ppszNegPolDNs + i),
                    REG_FULLY_QUALIFIED_NAME,
                    &pIpsecNegPolObject
                    );
        if (dwError == ERROR_SUCCESS) {

            *(ppIpsecNegPolObjects + dwNumNegPolObjectsReturned) = pIpsecNegPolObject;
            dwNumNegPolObjectsReturned++;

        }


    }

    if (dwNumNegPolObjectsReturned == 0) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *pppIpsecNegPolObjects = ppIpsecNegPolObjects;
    *pdwNumNegPolObjects = dwNumNegPolObjectsReturned;

    dwError = ERROR_SUCCESS;

    return(dwError);

error:


    if (ppIpsecNegPolObjects) {

        FreeIpsecNegPolObjects(
                    ppIpsecNegPolObjects,
                    dwNumNegPolObjectsReturned
                    );
    }

    *pppIpsecNegPolObjects = NULL;
    *pdwNumNegPolObjects = 0;


    return(dwError);
}

DWORD
ReadISAKMPObjectsFromRegistry(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszISAKMPDNs,
    DWORD dwNumISAKMPObjects,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecISAKMPObjects,
    PDWORD pdwNumISAKMPObjects
    )
{

    DWORD dwError = 0;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject =  NULL;
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects = NULL;

    DWORD dwNumISAKMPObjectsReturned = 0;


    *pppIpsecISAKMPObjects = NULL;
    *pdwNumISAKMPObjects = 0;

    ppIpsecISAKMPObjects  = (PIPSEC_ISAKMP_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_ISAKMP_OBJECT)*dwNumISAKMPObjects
                                            );
    if (!ppIpsecISAKMPObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwNumISAKMPObjects; i++) {

        dwError =UnMarshallRegistryISAKMPObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    *(ppszISAKMPDNs + i),
                    REG_FULLY_QUALIFIED_NAME,
                    &pIpsecISAKMPObject
                    );
        if (dwError == ERROR_SUCCESS) {

            *(ppIpsecISAKMPObjects + dwNumISAKMPObjectsReturned) = pIpsecISAKMPObject;
            dwNumISAKMPObjectsReturned++;

        }


    }

    if (dwNumISAKMPObjectsReturned == 0) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *pppIpsecISAKMPObjects = ppIpsecISAKMPObjects;
    *pdwNumISAKMPObjects = dwNumISAKMPObjectsReturned;

    dwError = ERROR_SUCCESS;

    return(dwError);

error:


    if (ppIpsecISAKMPObjects) {

        FreeIpsecISAKMPObjects(
                    ppIpsecISAKMPObjects,
                    dwNumISAKMPObjectsReturned
                    );
    }

    *pppIpsecISAKMPObjects = NULL;
    *pdwNumISAKMPObjects = 0;


    return(dwError);
}



DWORD
UnMarshallRegistryPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRegRootContainer,
    LPWSTR pszIpsecPolicyDN,
    DWORD  dwNameType,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    )
{

    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwIpsecDataType = 0;
    DWORD dwWhenChanged = 0;
    LPBYTE pBuffer = NULL;

    DWORD i = 0;
    DWORD dwCount = 0;
    DWORD dwError = 0;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszIpsecNFAName = NULL;
    LPWSTR pszTemp = NULL;
    LPWSTR pszString = NULL;
    LPWSTR pszIpsecNFAReference = NULL;
    LPWSTR pszRelativeName = NULL;
    DWORD dwRootPathLen = 0;


    if (!pszIpsecPolicyDN || !*pszIpsecPolicyDN) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (dwNameType == REG_FULLY_QUALIFIED_NAME) {
        dwRootPathLen =  wcslen(pszIpsecRegRootContainer);
        if (wcslen(pszIpsecPolicyDN) <= (dwRootPathLen+1)) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        pszRelativeName = pszIpsecPolicyDN + dwRootPathLen + 1;
    }else {
        pszRelativeName = pszIpsecPolicyDN;
    }

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszRelativeName,
                    0,
                    KEY_ALL_ACCESS,
                    &hRegKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject = (PIPSEC_POLICY_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_POLICY_OBJECT)
                                                    );
    if (!pIpsecPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    /*
    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"distinguishedName",
                    REG_SZ,
                    (LPBYTE *)&pIpsecPolicyObject->pszIpsecOwnersReference,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    */


    pIpsecPolicyObject->pszIpsecOwnersReference = AllocPolStr(
                                                pszIpsecPolicyDN
                                                );
    if (!pIpsecPolicyObject->pszIpsecOwnersReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }



    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecName",
                    REG_SZ,
                    (LPBYTE *)&pIpsecPolicyObject->pszIpsecName,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"description",
                    REG_SZ,
                    (LPBYTE *)&pIpsecPolicyObject->pszDescription,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);


    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecID",
                    REG_SZ,
                    (LPBYTE *)&pIpsecPolicyObject->pszIpsecID,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                    hRegKey,
                    L"ipsecDataType",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwIpsecDataType,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->dwIpsecDataType = dwIpsecDataType;


    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecData",
                    REG_BINARY,
                    &pIpsecPolicyObject->pIpsecData,
                    &pIpsecPolicyObject->dwIpsecDataLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecISAKMPReference",
                    REG_SZ,
                    (LPBYTE *)&pIpsecPolicyObject->pszIpsecISAKMPReference,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecNFAReference",
                    REG_MULTI_SZ,
                    (LPBYTE *)&pszIpsecNFAReference,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pszTemp = pszIpsecNFAReference;
    while (*pszTemp != L'\0') {

        pszTemp += wcslen(pszTemp) + 1;
        dwCount++;
    }


    ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                sizeof(LPWSTR)*dwCount
                                );
    if (!ppszIpsecNFANames) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pszTemp = pszIpsecNFAReference;
    for (i = 0; i < dwCount; i++) {

        pszString = AllocPolStr(pszTemp);
        if (!pszString) {
            dwError = ERROR_OUTOFMEMORY;
            pIpsecPolicyObject->ppszIpsecNFAReferences  = ppszIpsecNFANames;
            pIpsecPolicyObject->NumberofRules = i;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        *(ppszIpsecNFANames + i) = pszString;

        pszTemp += wcslen(pszTemp) + 1; //for the null terminator;

    }

    if (pszIpsecNFAReference) {
        FreePolStr(pszIpsecNFAReference);
    }

    pIpsecPolicyObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
    pIpsecPolicyObject->NumberofRules = dwCount;

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                    hRegKey,
                    L"whenChanged",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwWhenChanged,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->dwWhenChanged = dwWhenChanged;

    *ppIpsecPolicyObject = pIpsecPolicyObject;


    if (hRegKey) {
        RegCloseKey(hRegKey);
    }



    return(dwError);

error:

    *ppIpsecPolicyObject = NULL;

    if (pszIpsecNFAReference) {
        FreePolStr(pszIpsecNFAReference);
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }


    if (hRegKey) {
        RegCloseKey(hRegKey);
    }



    return(dwError);
}

DWORD
UnMarshallRegistryNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRegRootContainer,
    LPWSTR pszIpsecNFAReference,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject,
    LPWSTR * ppszFilterReference,
    LPWSTR * ppszNegPolReference
    )
{

    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwIpsecDataType = 0;
    DWORD dwWhenChanged = 0;
    LPBYTE pBuffer = NULL;

    DWORD i = 0;
    DWORD dwCount = 0;
    DWORD dwError = 0;
    LPWSTR  pszTempFilterReference = NULL;
    LPWSTR  pszTempNegPolReference = NULL;

    LPWSTR pszRelativeName = NULL;
    DWORD dwRootPathLen = 0;

    dwRootPathLen =  wcslen(pszIpsecRegRootContainer);

    if (!pszIpsecNFAReference || !*pszIpsecNFAReference) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (wcslen(pszIpsecNFAReference) <= (dwRootPathLen+1)) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pszRelativeName = pszIpsecNFAReference + dwRootPathLen + 1;


    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszRelativeName,
                    0,
                    KEY_ALL_ACCESS,
                    &hRegKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pIpsecNFAObject = (PIPSEC_NFA_OBJECT)AllocPolMem(
                                sizeof(IPSEC_NFA_OBJECT)
                                );
    if (!pIpsecNFAObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    /*
    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"distinguishedName",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNFAObject->pszDistinguishedName,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    */

    pIpsecNFAObject->pszDistinguishedName = AllocPolStr(
                                                pszIpsecNFAReference
                                                );
    if (!pIpsecNFAObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Client does not always write the Name for an NFA
    //

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecName",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNFAObject->pszIpsecName,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"description",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNFAObject->pszDescription,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecID",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNFAObject->pszIpsecID,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD;
    dwSize  = sizeof(DWORD);
    dwError = RegQueryValueExW(
                    hRegKey,
                    L"ipsecDataType",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwIpsecDataType,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNFAObject->dwIpsecDataType = dwIpsecDataType;

    //
    // unmarshall the ipsecData blob
    //

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecData",
                    REG_BINARY,
                    &pIpsecNFAObject->pIpsecData,
                    &pIpsecNFAObject->dwIpsecDataLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecOwnersReference",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNFAObject->pszIpsecOwnersReference,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);


    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecNegotiationPolicyReference",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNFAObject->pszIpsecNegPolReference,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecFilterReference",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNFAObject->pszIpsecFilterReference,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                    hRegKey,
                    L"whenChanged",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwWhenChanged,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNFAObject->dwWhenChanged = dwWhenChanged;

    if (pIpsecNFAObject->pszIpsecFilterReference && *(pIpsecNFAObject->pszIpsecFilterReference)) {
        pszTempFilterReference = AllocPolStr(
                                pIpsecNFAObject->pszIpsecFilterReference
                                );
        if (!pszTempFilterReference) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    pszTempNegPolReference = AllocPolStr(
                                 pIpsecNFAObject->pszIpsecNegPolReference
                                 );
    if (!pszTempNegPolReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszFilterReference = pszTempFilterReference;
    *ppszNegPolReference = pszTempNegPolReference;

    *ppIpsecNFAObject = pIpsecNFAObject;


cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }


    return(dwError);

error:

    if (pIpsecNFAObject) {

        FreeIpsecNFAObject(pIpsecNFAObject);

    }

    if (pszTempFilterReference) {
        FreePolStr(pszTempFilterReference);
    }

    if (pszTempNegPolReference) {
        FreePolStr(pszTempNegPolReference);
    }

    *ppIpsecNFAObject = NULL;
    *ppszFilterReference = NULL;
    *ppszNegPolReference = NULL;

    goto cleanup;
}


DWORD
UnMarshallRegistryFilterObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRegRootContainer,
    LPWSTR pszIpsecFilterReference,
    DWORD  dwNameType,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    )
{

    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwIpsecDataType = 0;
    DWORD dwWhenChanged = 0;
    LPBYTE pBuffer = NULL;

    DWORD dwCount = 0;
    DWORD i = 0;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszString = NULL;

    LPWSTR pszIpsecNFAReference = NULL;
    LPWSTR pszTemp = NULL;

    DWORD dwError = 0;
    LPWSTR pszRelativeName = NULL;
    DWORD dwRootPathLen = 0;

    if (!pszIpsecFilterReference || !*pszIpsecFilterReference) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (dwNameType == REG_FULLY_QUALIFIED_NAME) {
        dwRootPathLen =  wcslen(pszIpsecRegRootContainer);
        if (wcslen(pszIpsecFilterReference) <= (dwRootPathLen+1)) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        pszRelativeName = pszIpsecFilterReference + dwRootPathLen + 1;
    }else {
        pszRelativeName = pszIpsecFilterReference;
    }


    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszRelativeName,
                    0,
                    KEY_ALL_ACCESS,
                    &hRegKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pIpsecFilterObject = (PIPSEC_FILTER_OBJECT)AllocPolMem(
                                sizeof(IPSEC_FILTER_OBJECT)
                                );
    if (!pIpsecFilterObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    /*
    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"distinguishedName",
                    REG_SZ,
                    (LPBYTE *)&pIpsecFilterObject->pszDistinguishedName,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    */

    pIpsecFilterObject->pszDistinguishedName = AllocPolStr(
                                                pszIpsecFilterReference
                                                );
    if (!pIpsecFilterObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"description",
                    REG_SZ,
                    (LPBYTE *)&pIpsecFilterObject->pszDescription,
                    &dwSize
                    );
    //BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecName",
                    REG_SZ,
                    (LPBYTE *)&pIpsecFilterObject->pszIpsecName,
                    &dwSize
                    );
    //BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecID",
                    REG_SZ,
                    (LPBYTE *)&pIpsecFilterObject->pszIpsecID,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD,
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                    hRegKey,
                    L"ipsecDataType",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwIpsecDataType,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecFilterObject->dwIpsecDataType = dwIpsecDataType;


    //
    // unmarshall the ipsecData blob
    //

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecData",
                    dwType,
                    &pIpsecFilterObject->pIpsecData,
                    &pIpsecFilterObject->dwIpsecDataLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Owner's reference
    //

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecOwnersReference",
                    REG_MULTI_SZ,
                    (LPBYTE *)&pszIpsecNFAReference,
                    &dwSize
                    );
    //BAIL_ON_WIN32_ERROR(dwError);

    if (!dwError) {

        pszTemp = pszIpsecNFAReference;
        while (*pszTemp != L'\0') {

            pszTemp += wcslen(pszTemp) + 1;
            dwCount++;
        }


        ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                    sizeof(LPWSTR)*dwCount
                                    );
        if (!ppszIpsecNFANames) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pszTemp = pszIpsecNFAReference;
        for (i = 0; i < dwCount; i++) {

            pszString = AllocPolStr(pszTemp);
            if (!pszString) {
                dwError = ERROR_OUTOFMEMORY;
                pIpsecFilterObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
                pIpsecFilterObject->dwNFACount = i;

                if (pszIpsecNFAReference) {
                    FreePolStr(pszIpsecNFAReference);
                }

                BAIL_ON_WIN32_ERROR(dwError);

            }

            *(ppszIpsecNFANames + i) = pszString;

            pszTemp += wcslen(pszTemp) + 1; //for the null terminator;

        }
        if (pszIpsecNFAReference) {
            FreePolStr(pszIpsecNFAReference);
        }


        pIpsecFilterObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
        pIpsecFilterObject->dwNFACount = dwCount;


    }

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                    hRegKey,
                    L"whenChanged",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwWhenChanged,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecFilterObject->dwWhenChanged = dwWhenChanged;


    *ppIpsecFilterObject = pIpsecFilterObject;


cleanup:

    if (hRegKey) {

        RegCloseKey(hRegKey);
    }

    return(dwError);

error:

    if (pIpsecFilterObject) {

        FreeIpsecFilterObject(pIpsecFilterObject);

    }

    *ppIpsecFilterObject = NULL;

    goto cleanup;
}


DWORD
UnMarshallRegistryNegPolObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRegRootContainer,
    LPWSTR pszIpsecNegPolReference,
    DWORD  dwNameType,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObject
    )
{

    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwIpsecDataType = 0;
    DWORD dwWhenChanged = 0;
    LPBYTE pBuffer = NULL;

    DWORD dwCount = 0;
    DWORD i = 0;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszString = NULL;

    LPWSTR pszIpsecNFAReference = NULL;
    LPWSTR pszTemp = NULL;

    DWORD dwError = 0;

    LPWSTR pszRelativeName = NULL;
    DWORD dwRootPathLen = 0;

    if (!pszIpsecNegPolReference || !*pszIpsecNegPolReference) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (dwNameType == REG_FULLY_QUALIFIED_NAME) {
        dwRootPathLen =  wcslen(pszIpsecRegRootContainer);
        if (wcslen(pszIpsecNegPolReference) <= (dwRootPathLen+1)) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        pszRelativeName = pszIpsecNegPolReference + dwRootPathLen + 1;
    }else {
        pszRelativeName = pszIpsecNegPolReference;
    }

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszRelativeName,
                    0,
                    KEY_ALL_ACCESS,
                    &hRegKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pIpsecNegPolObject = (PIPSEC_NEGPOL_OBJECT)AllocPolMem(
                                sizeof(IPSEC_NEGPOL_OBJECT)
                                );
    if (!pIpsecNegPolObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    /*
    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"distinguishedName",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNegPolObject->pszDistinguishedName,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    */

    pIpsecNegPolObject->pszDistinguishedName = AllocPolStr(
                                                pszIpsecNegPolReference
                                                );
    if (!pIpsecNegPolObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Names do not get written on an NegPol Object
    //

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecName",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNegPolObject->pszIpsecName,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);


    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"description",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNegPolObject->pszDescription,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);



    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecID",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNegPolObject->pszIpsecID,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecNegotiationPolicyAction",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNegPolObject->pszIpsecNegPolAction,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecNegotiationPolicyType",
                    REG_SZ,
                    (LPBYTE *)&pIpsecNegPolObject->pszIpsecNegPolType,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                    hRegKey,
                    L"ipsecDataType",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwIpsecDataType,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNegPolObject->dwIpsecDataType = dwIpsecDataType;


    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecData",
                    REG_BINARY,
                    &pIpsecNegPolObject->pIpsecData,
                    &pIpsecNegPolObject->dwIpsecDataLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecOwnersReference",
                    REG_MULTI_SZ,
                    (LPBYTE *)&pszIpsecNFAReference,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    if (!dwError) {

        pszTemp = pszIpsecNFAReference;
        while (*pszTemp != L'\0') {

            pszTemp += wcslen(pszTemp) + 1;
            dwCount++;
        }


        ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                    sizeof(LPWSTR)*dwCount
                                    );
        if (!ppszIpsecNFANames) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pszTemp = pszIpsecNFAReference;
        for (i = 0; i < dwCount; i++) {

            pszString = AllocPolStr(pszTemp);
            if (!pszString) {
                dwError = ERROR_OUTOFMEMORY;
                pIpsecNegPolObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
                pIpsecNegPolObject->dwNFACount = i;


                if (pszIpsecNFAReference) {
                    FreePolStr(pszIpsecNFAReference);
                }

                BAIL_ON_WIN32_ERROR(dwError);
            }

            *(ppszIpsecNFANames + i) = pszString;

            pszTemp += wcslen(pszTemp) + 1; //for the null terminator;

        }

        if (pszIpsecNFAReference) {
            FreePolStr(pszIpsecNFAReference);
        }


        pIpsecNegPolObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
        pIpsecNegPolObject->dwNFACount = dwCount;
    }

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                    hRegKey,
                    L"whenChanged",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwWhenChanged,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNegPolObject->dwWhenChanged = dwWhenChanged;



    *ppIpsecNegPolObject = pIpsecNegPolObject;


cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }


    return(dwError);

error:

    if (pIpsecNegPolObject) {

        FreeIpsecNegPolObject(pIpsecNegPolObject);

    }

    *ppIpsecNegPolObject = NULL;

    goto cleanup;
}

DWORD
UnMarshallRegistryISAKMPObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRegRootContainer,
    LPWSTR pszIpsecISAKMPReference,
    DWORD  dwNameType,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObject
    )
{

    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwIpsecDataType = 0;
    DWORD dwWhenChanged = 0;
    LPBYTE pBuffer = NULL;

    DWORD dwCount = 0;
    DWORD i = 0;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszString = NULL;

    LPWSTR pszIpsecNFAReference = NULL;
    LPWSTR pszTemp = NULL;

    DWORD dwError = 0;


    LPWSTR pszRelativeName = NULL;
    DWORD dwRootPathLen = 0;

    if (!pszIpsecISAKMPReference || !*pszIpsecISAKMPReference) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (dwNameType == REG_FULLY_QUALIFIED_NAME) {
        dwRootPathLen =  wcslen(pszIpsecRegRootContainer);
        if (wcslen(pszIpsecISAKMPReference) <= (dwRootPathLen+1)) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        pszRelativeName = pszIpsecISAKMPReference + dwRootPathLen + 1;
    }else {
        pszRelativeName = pszIpsecISAKMPReference;
    }


    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszRelativeName,
                    0,
                    KEY_ALL_ACCESS,
                    &hRegKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    pIpsecISAKMPObject = (PIPSEC_ISAKMP_OBJECT)AllocPolMem(
                                sizeof(IPSEC_ISAKMP_OBJECT)
                                );
    if (!pIpsecISAKMPObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    /*
    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"distinguishedName",
                    REG_SZ,
                    (LPBYTE *)&pIpsecISAKMPObject->pszDistinguishedName,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    */

    pIpsecISAKMPObject->pszDistinguishedName = AllocPolStr(
                                                pszIpsecISAKMPReference
                                                );
    if (!pIpsecISAKMPObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Names are not set for ISAKMP objects
    //

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecName",
                    REG_SZ,
                    (LPBYTE *)&pIpsecISAKMPObject->pszIpsecName,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecID",
                    REG_SZ,
                    (LPBYTE *)&pIpsecISAKMPObject->pszIpsecID,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD,
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                    hRegKey,
                    L"ipsecDataType",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwIpsecDataType,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecISAKMPObject->dwIpsecDataType = dwIpsecDataType;


    //
    // unmarshall the ipsecData blob
    //
    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecData",
                    REG_BINARY,
                    &pIpsecISAKMPObject->pIpsecData,
                    &pIpsecISAKMPObject->dwIpsecDataLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    //
    // ipsecOwnersReference not written
    //


    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecOwnersReference",
                    REG_MULTI_SZ,
                    (LPBYTE *)&pszIpsecNFAReference,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);


    if (!dwError) {

        pszTemp = pszIpsecNFAReference;
        while (*pszTemp != L'\0') {

            pszTemp += wcslen(pszTemp) + 1;
            dwCount++;
        }


        ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                    sizeof(LPWSTR)*dwCount
                                    );
        if (!ppszIpsecNFANames) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pszTemp = pszIpsecNFAReference;
        for (i = 0; i < dwCount; i++) {

            pszString = AllocPolStr(pszTemp);
            if (!pszString) {
                dwError = ERROR_OUTOFMEMORY;
                pIpsecISAKMPObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
                pIpsecISAKMPObject->dwNFACount = i;

                if (pszIpsecNFAReference) {
                    FreePolStr(pszIpsecNFAReference);
                }



                BAIL_ON_WIN32_ERROR(dwError);
            }

            *(ppszIpsecNFANames + i) = pszString;

            pszTemp += wcslen(pszTemp) + 1; //for the null terminator;

        }

        if (pszIpsecNFAReference) {
            FreePolStr(pszIpsecNFAReference);
        }

        pIpsecISAKMPObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
        pIpsecISAKMPObject->dwNFACount = dwCount;
    }

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                    hRegKey,
                    L"whenChanged",
                    NULL,
                    &dwType,
                    (LPBYTE)&dwWhenChanged,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecISAKMPObject->dwWhenChanged = dwWhenChanged;


    *ppIpsecISAKMPObject = pIpsecISAKMPObject;


cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }


    return(dwError);

error:

    if (pIpsecISAKMPObject) {

        FreeIpsecISAKMPObject(pIpsecISAKMPObject);

    }

    *ppIpsecISAKMPObject = NULL;

    goto cleanup;
}


DWORD
RegstoreQueryValue(
    HKEY hRegKey,
    LPWSTR pszValueName,
    DWORD dwType,
    LPBYTE * ppValueData,
    LPDWORD pdwSize
    )
{
    DWORD dwSize = 0;
    LPWSTR pszValueData = NULL;
    DWORD dwError = 0;
    LPBYTE pBuffer = NULL;
    LPWSTR pszBuf = NULL;


    dwError = RegQueryValueExW(
                    hRegKey,
                    pszValueName,
                    NULL,
                    &dwType,
                    NULL,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwSize == 0) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pBuffer = (LPBYTE)AllocPolMem(dwSize);
    if (!pBuffer) {

        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegQueryValueExW(
                    hRegKey,
                    pszValueName,
                    NULL,
                    &dwType,
                    pBuffer,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);




    switch (dwType) {
    case REG_SZ:
        pszBuf = (LPWSTR) pBuffer;
        if (!pszBuf || !*pszBuf) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;

    default:
        break;
    }

    *ppValueData = pBuffer;
    *pdwSize = dwSize;
    return(dwError);

error:

    if (pBuffer) {
        FreePolMem(pBuffer);
    }

    *ppValueData = NULL;
    *pdwSize = 0;
    return(dwError);
}


VOID
FlushRegSaveKey(
    HKEY hRegistryKey
    )
{
    DWORD dwError = 0;
    WCHAR lpszName[MAX_PATH];
    DWORD dwSize = 0;


    memset(lpszName, 0, sizeof(WCHAR)*MAX_PATH);
    dwSize = MAX_PATH;

    while((RegEnumKeyExW(
              hRegistryKey,
              0,
              lpszName,
              &dwSize,
              NULL,
              NULL,
              NULL,
              NULL)) == ERROR_SUCCESS) {

        dwError = RegDeleteKeyW(
                      hRegistryKey,
                      lpszName
                      );
        if (dwError != ERROR_SUCCESS) {
            break;
        }

        memset(lpszName, 0, sizeof(WCHAR)*MAX_PATH);
        dwSize = MAX_PATH;

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\regstore.h ===
DWORD
OpenRegistryIPSECRootKey(
    LPWSTR pszServerName,
    LPWSTR pszIpsecRegRootContainer,
    HKEY * phRegistryKey
    );


DWORD
ReadPolicyObjectFromRegistry(
    HKEY hRegistryKey,
    LPWSTR pszPolicyDN,
    LPWSTR pszIpsecRegRootContainer,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    );

DWORD
ReadNFAObjectsFromRegistry(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecOwnerReference,
    LPWSTR * ppszNFADNs,
    DWORD dwNumNfaObjects,
    PIPSEC_NFA_OBJECT ** pppIpsecNFAObjects,
    PDWORD pdwNumNfaObjects,
    LPWSTR ** pppszFilterReferences,
    PDWORD pdwNumFilterReferences,
    LPWSTR ** pppszNegPolReferences,
    PDWORD pdwNumNegPolReferences
    );

DWORD
ReadFilterObjectsFromRegistry(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszFilterDNs,
    DWORD dwNumFilterObjects,
    PIPSEC_FILTER_OBJECT ** pppIpsecFilterObjects,
    PDWORD pdwNumFilterObjects
    );

DWORD
ReadNegPolObjectsFromRegistry(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszNegPolDNs,
    DWORD dwNumNegPolObjects,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecNegPolObjects,
    PDWORD pdwNumNegPolObjects
    );

DWORD
ReadISAKMPObjectsFromRegistry(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszISAKMPDNs,
    DWORD dwNumISAKMPObjects,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecISAKMPObjects,
    PDWORD pdwNumISAKMPObjects
    );

DWORD
UnMarshallRegistryPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRegRootContainer,
    LPWSTR pszIpsecPolicyDN,
    DWORD  dwNameType,
    PIPSEC_POLICY_OBJECT  * ppIpsecPolicyObject
    );

DWORD
UnMarshallRegistryNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRegRootContainer,
    LPWSTR pszIpsecNFAReference,
    PIPSEC_NFA_OBJECT * ppIpsecPolicyObject,
    LPWSTR * ppszFilterReference,
    LPWSTR * ppszNegPolReference
    );

DWORD
UnMarshallRegistryFilterObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRegRootContainer,
    LPWSTR pszIpsecFilterReference,
    DWORD  dwNameType,
    PIPSEC_FILTER_OBJECT * ppIpsecPolicyObject
    );

DWORD
UnMarshallRegistryNegPolObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRegRootContainer,
    LPWSTR pszIpsecNegPolReference,
    DWORD  dwNameType,
    PIPSEC_NEGPOL_OBJECT * ppIpsecPolicyObject
    );

DWORD
UnMarshallRegistryISAKMPObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRegRootContainer,
    LPWSTR pszIpsecISAKMPReference,
    DWORD  dwNameType,
    PIPSEC_ISAKMP_OBJECT * ppIpsecPolicyObject
    );


void
FreeIpsecNFAObject(
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    );

void
FreeIpsecPolicyObject(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    );

void
FreeIpsecFilterObject(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    );

void
FreeIpsecNegPolObject(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    );

void
FreeIpsecISAKMPObject(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    );

void
FreeNFAReferences(
    LPWSTR * ppszNFAReferences,
    DWORD dwNumNFAReferences
    );

void
FreeFilterReferences(
    LPWSTR * ppszFilterReferences,
    DWORD dwNumFilterReferences
    );

void
FreeNegPolReferences(
    LPWSTR * ppszNegPolReferences,
    DWORD dwNumNegPolReferences
    );

void
FreeIpsecNFAObjects(
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects,
    DWORD dwNumNFAObjects
    );

void
FreeIpsecFilterObjects(
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects,
    DWORD dwNumFilterObjects
    );

void
FreeIpsecNegPolObjects(
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects,
    DWORD dwNumNegPolObjects
    );

void
FreeIpsecISAKMPObjects(
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects,
    DWORD dwNumISAKMPObjects
    );

void
FreeIpsecPolicyObjects(
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObjects,
    DWORD dwNumPolicyObjects
    );

DWORD
RegstoreQueryValue(
    HKEY hRegKey,
    LPWSTR pszValueName,
    DWORD dwType,
    LPBYTE * ppValueData,
    LPDWORD pdwSize
    );

#define  REG_RELATIVE_NAME          0
#define  REG_FULLY_QUALIFIED_NAME   1

VOID
FlushRegSaveKey(
    HKEY hRegistryKey
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\structs.h ===
#define BAIL_ON_WIN32_ERROR(dwError) \
    if (dwError) {\
        goto error; \
    }

#define BAIL_ON_HRESULT_ERROR(hr) \
    if (FAILED(hr)) { \
        goto error; \
    }

#define BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError) { \
    dwError = Win32FromWmiHresult(hr); \
    if (dwError) {  \
        goto error; \
    } \
}
        
typedef struct _IPSEC_NFA_OBJECT{
    LPWSTR pszDistinguishedName;
    LPWSTR pszIpsecName;
    LPWSTR pszIpsecID;
    DWORD  dwIpsecDataType;
    LPBYTE pIpsecData;
    DWORD  dwIpsecDataLen;
    LPWSTR pszIpsecOwnersReference;
    LPWSTR pszIpsecFilterReference;
    LPWSTR pszIpsecNegPolReference;
    DWORD  dwWhenChanged;
    LPWSTR pszDescription;
}IPSEC_NFA_OBJECT, *PIPSEC_NFA_OBJECT;

typedef struct _IPSEC_ISAKMP_OBJECT{
    LPWSTR pszDistinguishedName;
    LPWSTR pszIpsecName;
    LPWSTR pszIpsecID;
    DWORD  dwIpsecDataType;
    LPBYTE pIpsecData;
    DWORD  dwIpsecDataLen;
    LPWSTR * ppszIpsecNFAReferences;
    DWORD  dwNFACount;
    DWORD dwWhenChanged;
}IPSEC_ISAKMP_OBJECT, *PIPSEC_ISAKMP_OBJECT;

typedef struct _IPSEC_FILTER_OBJECT{
    LPWSTR pszDistinguishedName;
    LPWSTR pszIpsecName;
    LPWSTR pszIpsecID;
    DWORD  dwIpsecDataType;
    LPBYTE pIpsecData;
    DWORD  dwIpsecDataLen;
    LPWSTR * ppszIpsecNFAReferences;
    DWORD  dwNFACount;
    DWORD dwWhenChanged;
    LPWSTR pszDescription;
}IPSEC_FILTER_OBJECT, *PIPSEC_FILTER_OBJECT;

typedef struct _IPSEC_NEGPOL_OBJECT{
    LPWSTR pszDistinguishedName;
    LPWSTR pszIpsecName;
    LPWSTR pszIpsecID;
    DWORD  dwIpsecDataType;
    LPBYTE pIpsecData;
    DWORD  dwIpsecDataLen;
    LPWSTR pszIpsecNegPolAction;
    LPWSTR pszIpsecNegPolType;
    LPWSTR * ppszIpsecNFAReferences;
    DWORD  dwNFACount;
    DWORD dwWhenChanged;
    LPWSTR pszDescription;
}IPSEC_NEGPOL_OBJECT, *PIPSEC_NEGPOL_OBJECT;

typedef struct _IPSEC_POLICY_OBJECT{
    LPWSTR pszIpsecOwnersReference;
    LPWSTR pszIpsecName;
    LPWSTR pszIpsecID;
    DWORD  dwIpsecDataType;
    LPBYTE pIpsecData;
    DWORD  dwIpsecDataLen;
    LPWSTR pszIpsecISAKMPReference;
    DWORD  NumberofRules;
    DWORD  NumberofRulesReturned;
    LPWSTR * ppszIpsecNFAReferences;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects;
    DWORD  NumberofFilters;
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects;
    DWORD  NumberofNegPols;
    PIPSEC_NEGPOL_OBJECT *ppIpsecNegPolObjects;
    DWORD  NumberofISAKMPs;
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects;
    DWORD dwWhenChanged;
    LPWSTR pszDescription;
    PRSOP_INFO pRsopInfo;
}IPSEC_POLICY_OBJECT, *PIPSEC_POLICY_OBJECT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\api.c ===
#include "precomp.h"


LPWSTR gpszRegLocalContainer = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Local";
LPWSTR gpszRegPersistentContainer = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Persistent";
LPWSTR gpszIpsecFileRootContainer = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Save";
LPWSTR gpszIPsecDirContainer  = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\GPTIPSECPolicy";
LPWSTR gpActivePolicyKey = L"ActivePolicy";
LPWSTR gpDirectoryPolicyPointerKey  = L"DSIPSECPolicyPath";

DWORD
IPSecEnumPolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    IWbemServices *pWbemServices = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegEnumPolicyData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        pppIpsecPolicyData,
                        pdwNumPolicyObjects
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirEnumPolicyData(
                        (pPolicyStore->hLdapBindHandle),
                        pPolicyStore->pszIpsecRootContainer,
                        pppIpsecPolicyData,
                        pdwNumPolicyObjects
                        );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = CreateIWbemServices(
            pPolicyStore->pszLocationName,
            &pWbemServices
            );
        
        if(dwError == ERROR_SUCCESS) {
            dwError = WMIEnumPolicyDataEx(
                pWbemServices,
                pppIpsecPolicyData,
                pdwNumPolicyObjects
                );
            
            IWbemServices_Release(pWbemServices);
        }
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;


    }

    return(dwError);
}


DWORD
IPSecSetPolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    dwError = ValidatePolicyData(
                  hPolicyStore,
                  pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegSetPolicyData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        pPolicyStore->pszLocationName,
                        pIpsecPolicyData
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirSetPolicyData(
                        (pPolicyStore->hLdapBindHandle),
                        pPolicyStore->pszIpsecRootContainer,
                        pIpsecPolicyData
                        );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecCreatePolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{

    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    dwError = ValidatePolicyData(
                  hPolicyStore,
                  pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegCreatePolicyData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        pIpsecPolicyData
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirCreatePolicyData(
                        (pPolicyStore->hLdapBindHandle),
                        pPolicyStore->pszIpsecRootContainer,
                        pIpsecPolicyData
                        );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecDeletePolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    dwError = ValidatePolicyDataDeletion(
                  hPolicyStore,
                  pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegDeletePolicyData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        pIpsecPolicyData
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirDeletePolicyData(
                        (pPolicyStore->hLdapBindHandle),
                        pPolicyStore->pszIpsecRootContainer,
                        pIpsecPolicyData
                        );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecEnumFilterData(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA ** pppIpsecFilterData,
    PDWORD pdwNumFilterObjects
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    IWbemServices *pWbemServices = NULL;


    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegEnumFilterData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        pppIpsecFilterData,
                        pdwNumFilterObjects
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirEnumFilterData(
                        (pPolicyStore->hLdapBindHandle),
                        (pPolicyStore->pszIpsecRootContainer),
                        pppIpsecFilterData,
                        pdwNumFilterObjects
                        );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = CreateIWbemServices(
            pPolicyStore->pszLocationName,
            &pWbemServices
            );
        
        if(dwError == ERROR_SUCCESS) {
            dwError = WMIEnumFilterDataEx(
                pWbemServices,
                pppIpsecFilterData,
                pdwNumFilterObjects
                );
            IWbemServices_Release(pWbemServices);
        }          
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecSetFilterData(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA pIpsecFilterData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegSetFilterData(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            pPolicyStore->pszLocationName,
                            pIpsecFilterData
                            );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirSetFilterData(
                            (pPolicyStore->hLdapBindHandle),
                            (pPolicyStore->pszIpsecRootContainer),
                            pIpsecFilterData
                            );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecCreateFilterData(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA pIpsecFilterData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegCreateFilterData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        pIpsecFilterData
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirCreateFilterData(
                        (pPolicyStore->hLdapBindHandle),
                        (pPolicyStore->pszIpsecRootContainer),
                        pIpsecFilterData
                        );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;
    }

    return(dwError);
}


DWORD
IPSecDeleteFilterData(
    HANDLE hPolicyStore,
    GUID FilterIdentifier
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    dwError = ValidateFilterDataDeletion(
                  hPolicyStore,
                  FilterIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegDeleteFilterData(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            FilterIdentifier
                            );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirDeleteFilterData(
                            (pPolicyStore->hLdapBindHandle),
                            (pPolicyStore->pszIpsecRootContainer),
                            FilterIdentifier
                            );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecEnumNegPolData(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA ** pppIpsecNegPolData,
    PDWORD pdwNumNegPolObjects
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    IWbemServices *pWbemServices = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegEnumNegPolData(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            pppIpsecNegPolData,
                            pdwNumNegPolObjects
                            );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirEnumNegPolData(
                            (pPolicyStore->hLdapBindHandle),
                            pPolicyStore->pszIpsecRootContainer,
                            pppIpsecNegPolData,
                            pdwNumNegPolObjects
                            );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = CreateIWbemServices(
            pPolicyStore->pszLocationName,
            &pWbemServices
            );

        if(dwError == ERROR_SUCCESS) {
            dwError = WMIEnumNegPolDataEx(
                pWbemServices,
                pppIpsecNegPolData,
                pdwNumNegPolObjects
                );
            IWbemServices_Release(pWbemServices);
        }
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecSetNegPolData(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    dwError = ValidateNegPolData(
                  pIpsecNegPolData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegSetNegPolData(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            pPolicyStore->pszLocationName,
                            pIpsecNegPolData
                            );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirSetNegPolData(
                            (pPolicyStore->hLdapBindHandle),
                            pPolicyStore->pszIpsecRootContainer,
                            pIpsecNegPolData
                            );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecCreateNegPolData(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    dwError = ValidateNegPolData(
                  pIpsecNegPolData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegCreateNegPolData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        pIpsecNegPolData
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirCreateNegPolData(
                        (pPolicyStore->hLdapBindHandle),
                        pPolicyStore->pszIpsecRootContainer,
                        pIpsecNegPolData
                        );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecDeleteNegPolData(
    HANDLE hPolicyStore,
    GUID NegPolIdentifier
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    dwError = ValidateNegPolDataDeletion(
                  hPolicyStore,
                  NegPolIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegDeleteNegPolData(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            NegPolIdentifier
                            );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirDeleteNegPolData(
                            (pPolicyStore->hLdapBindHandle),
                            pPolicyStore->pszIpsecRootContainer,
                            NegPolIdentifier
                            );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecCreateNFAData(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    dwError = ValidateNFAData(
                  hPolicyStore,
                  PolicyIdentifier,
                  pIpsecNFAData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch(pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegCreateNFAData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        PolicyIdentifier,
                        pPolicyStore->pszLocationName,
                        pIpsecNFAData
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirCreateNFAData(
                        (pPolicyStore->hLdapBindHandle),
                        pPolicyStore->pszIpsecRootContainer,
                        PolicyIdentifier,
                        pIpsecNFAData
                        );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecSetNFAData(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    dwError = ValidateNFAData(
                  hPolicyStore,
                  PolicyIdentifier,
                  pIpsecNFAData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegSetNFAData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        PolicyIdentifier,
                        pPolicyStore->pszLocationName,
                        pIpsecNFAData
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirSetNFAData(
                        (pPolicyStore->hLdapBindHandle),
                        pPolicyStore->pszIpsecRootContainer,
                        PolicyIdentifier,
                        pIpsecNFAData
                        );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecDeleteNFAData(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegDeleteNFAData(
                        (pPolicyStore->hRegistryKey),
                        (pPolicyStore->pszIpsecRootContainer),
                        PolicyIdentifier,
                        pPolicyStore->pszLocationName,
                        pIpsecNFAData
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirDeleteNFAData(
                        (pPolicyStore->hLdapBindHandle),
                        pPolicyStore->pszIpsecRootContainer,
                        PolicyIdentifier,
                        pIpsecNFAData
                        );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecEnumNFAData(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA ** pppIpsecNFAData,
    PDWORD pdwNumNFAObjects
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    IWbemServices *pWbemServices = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegEnumNFAData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        PolicyIdentifier,
                        pppIpsecNFAData,
                        pdwNumNFAObjects
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirEnumNFAData(
                        (pPolicyStore->hLdapBindHandle),
                        pPolicyStore->pszIpsecRootContainer,
                        PolicyIdentifier,
                        pppIpsecNFAData,
                        pdwNumNFAObjects
                        );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = CreateIWbemServices(
            pPolicyStore->pszLocationName,
            &pWbemServices
            );
        
        if(dwError == ERROR_SUCCESS) {
            dwError = WMIEnumNFADataEx(
                pWbemServices,
                PolicyIdentifier,
                pppIpsecNFAData,
                pdwNumNFAObjects
                );
            IWbemServices_Release(pWbemServices);
        }
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecGetFilterData(
    HANDLE hPolicyStore,
    GUID FilterGUID,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    IWbemServices *pWbemServices = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegGetFilterData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        FilterGUID,
                        ppIpsecFilterData
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirGetFilterData(
                        (pPolicyStore->hLdapBindHandle),
                        (pPolicyStore->pszIpsecRootContainer),
                        FilterGUID,
                        ppIpsecFilterData
                        );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = CreateIWbemServices(
            pPolicyStore->pszLocationName,
            &pWbemServices
            );

        if(dwError == ERROR_SUCCESS) {
            dwError = WMIGetFilterDataEx(
                pWbemServices,
                FilterGUID,
                ppIpsecFilterData
                );
            IWbemServices_Release(pWbemServices);
        }
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecGetNegPolData(
    HANDLE hPolicyStore,
    GUID NegPolGUID,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    IWbemServices *pWbemServices = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegGetNegPolData(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            NegPolGUID,
                            ppIpsecNegPolData
                            );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirGetNegPolData(
                            (pPolicyStore->hLdapBindHandle),
                            pPolicyStore->pszIpsecRootContainer,
                            NegPolGUID,
                            ppIpsecNegPolData
                            );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = CreateIWbemServices(
            pPolicyStore->pszLocationName,
            &pWbemServices
            );

        if(dwError == ERROR_SUCCESS) {
            dwError = WMIGetNegPolDataEx(
                pWbemServices,
                NegPolGUID,
                ppIpsecNegPolData
                );
            IWbemServices_Release(pWbemServices);
        }
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecEnumISAKMPData(
    HANDLE hPolicyStore,
    PIPSEC_ISAKMP_DATA ** pppIpsecISAKMPData,
    PDWORD pdwNumISAKMPObjects
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    IWbemServices *pWbemServices = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegEnumISAKMPData(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            pppIpsecISAKMPData,
                            pdwNumISAKMPObjects
                            );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirEnumISAKMPData(
                            (pPolicyStore->hLdapBindHandle),
                            pPolicyStore->pszIpsecRootContainer,
                            pppIpsecISAKMPData,
                            pdwNumISAKMPObjects
                            );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = CreateIWbemServices(
            pPolicyStore->pszLocationName,
            &pWbemServices
            );
        
        if(dwError == ERROR_SUCCESS) {
            dwError = WMIEnumISAKMPDataEx(
                pWbemServices,
                pppIpsecISAKMPData,
                pdwNumISAKMPObjects
                );
            IWbemServices_Release(pWbemServices);
        }
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecSetISAKMPData(
    HANDLE hPolicyStore,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;


    dwError = ValidateISAKMPData(
                  pIpsecISAKMPData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegSetISAKMPData(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            pPolicyStore->pszLocationName,
                            pIpsecISAKMPData
                            );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirSetISAKMPData(
                            (pPolicyStore->hLdapBindHandle),
                            pPolicyStore->pszIpsecRootContainer,
                            pIpsecISAKMPData
                            );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecCreateISAKMPData(
    HANDLE hPolicyStore,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;


    dwError = ValidateISAKMPData(
                  pIpsecISAKMPData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegCreateISAKMPData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        pIpsecISAKMPData
                        );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirCreateISAKMPData(
                        (pPolicyStore->hLdapBindHandle),
                        pPolicyStore->pszIpsecRootContainer,
                        pIpsecISAKMPData
                        );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecDeleteISAKMPData(
    HANDLE hPolicyStore,
    GUID ISAKMPIdentifier
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    dwError = ValidateISAKMPDataDeletion(
                  hPolicyStore,
                  ISAKMPIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegDeleteISAKMPData(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            ISAKMPIdentifier
                            );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirDeleteISAKMPData(
                            (pPolicyStore->hLdapBindHandle),
                            pPolicyStore->pszIpsecRootContainer,
                            ISAKMPIdentifier
                            );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecGetISAKMPData(
    HANDLE hPolicyStore,
    GUID ISAKMPGUID,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    IWbemServices *pWbemServices = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegGetISAKMPData(
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            ISAKMPGUID,
                            ppIpsecISAKMPData
                            );
        break;

    case IPSEC_DIRECTORY_PROVIDER:
        dwError = DirGetISAKMPData(
                            (pPolicyStore->hLdapBindHandle),
                            pPolicyStore->pszIpsecRootContainer,
                            ISAKMPGUID,
                            ppIpsecISAKMPData
                            );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = CreateIWbemServices(
            pPolicyStore->pszLocationName,
            &pWbemServices
            );

        if(dwError == ERROR_SUCCESS) {
            dwError = WMIGetISAKMPDataEx(
                pWbemServices,
                ISAKMPGUID,
                ppIpsecISAKMPData
                );
            IWbemServices_Release(pWbemServices);
        }
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecOpenPolicyStore(
    LPWSTR pszMachineName,
    DWORD dwTypeOfStore,
    LPWSTR pszFileName,
    HANDLE * phPolicyStore
    )
{
    DWORD dwError = 0;

    switch (dwTypeOfStore) {

    case IPSEC_REGISTRY_PROVIDER:

        dwError = RegOpenPolicyStore(
                      pszMachineName,
                      IPSEC_STORE_LOCAL,
                      phPolicyStore
                      );
        break;

    case IPSEC_DIRECTORY_PROVIDER:

        dwError = DirOpenPolicyStore(
                      pszMachineName,
                      phPolicyStore
                      );
        break;

    case IPSEC_FILE_PROVIDER:

        dwError = FileOpenPolicyStore(
                      pszMachineName,
                      pszFileName,
                      phPolicyStore
                      );
        break;

    case IPSEC_WMI_PROVIDER:

        dwError = WMIOpenPolicyStore(
                      pszMachineName,
                      phPolicyStore
                      );
        break;

    case IPSEC_PERSISTENT_PROVIDER:

        dwError = RegOpenPolicyStore(
                      pszMachineName,
                      IPSEC_STORE_PERSISTENT,
                      phPolicyStore
                      );
        break;

    default:

        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return (dwError);
}


DWORD
RegOpenPolicyStore(
    LPWSTR pszMachineName,
    IN DWORD dwStore,
    HANDLE * phPolicyStore
    )
{
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    DWORD dwError = 0;
    HKEY hParentRegistryKey = NULL;
    HKEY hRegistryKey = NULL;
    WCHAR szName[MAX_PATH];
    LPWSTR pszLocationName = NULL;
    LPWSTR pszIpsecRootContainer = NULL;

    switch (dwStore)
    {
        case IPSEC_STORE_LOCAL:
            pszIpsecRootContainer = AllocPolStr(gpszRegLocalContainer);
            break;

        case IPSEC_STORE_PERSISTENT:
            pszIpsecRootContainer = AllocPolStr(gpszRegPersistentContainer);
            break;
            
        default:
            dwError = ERROR_INVALID_PARAMETER;
            break;
    }

    BAIL_ON_WIN32_ERROR(dwError);
    
    if (!pszIpsecRootContainer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    szName[0] = L'\0';

    if (!pszMachineName || !*pszMachineName) {
        dwError = RegOpenKeyExW(
                      HKEY_LOCAL_MACHINE,
                      (LPCWSTR) pszIpsecRootContainer,
                      0,
                      KEY_ALL_ACCESS,
                      &hRegistryKey
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        pszLocationName = NULL;
    }
    else {

        wcscpy(szName, L"\\\\");
        wcscat(szName, pszMachineName);

        dwError = RegConnectRegistryW(
                      szName,
                      HKEY_LOCAL_MACHINE,
                      &hParentRegistryKey
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = RegOpenKeyExW(
                      hParentRegistryKey,
                      (LPCWSTR) pszIpsecRootContainer,
                      0,
                      KEY_ALL_ACCESS,
                      &hRegistryKey
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        pszLocationName = AllocPolStr(szName);
        if (!pszLocationName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }

    pPolicyStore = (PIPSEC_POLICY_STORE)AllocPolMem(
                            sizeof(IPSEC_POLICY_STORE)
                            );
    if (!pPolicyStore) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pPolicyStore->dwProvider = IPSEC_REGISTRY_PROVIDER;
    pPolicyStore->hParentRegistryKey = hParentRegistryKey;
    pPolicyStore->hRegistryKey = hRegistryKey;
    pPolicyStore->pszLocationName = pszLocationName;
    pPolicyStore->hLdapBindHandle = NULL;
    pPolicyStore->pszIpsecRootContainer = pszIpsecRootContainer;
    pPolicyStore->pszFileName = NULL;

    *phPolicyStore = pPolicyStore;

    return(dwError);

error:

    if (pszIpsecRootContainer) {
        FreePolStr(pszIpsecRootContainer);
    }

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }

    if (hParentRegistryKey) {
        RegCloseKey(hParentRegistryKey);
    }

    if (pszLocationName) {
        FreePolStr(pszLocationName);
    }

    if (pPolicyStore) {
        FreePolMem(pPolicyStore);
    }

    *phPolicyStore = NULL;

    return(dwError);
}


DWORD
WMIOpenPolicyStore(
    LPWSTR pszMachineName,
    HANDLE * phPolicyStore
    )
{
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    DWORD dwError = 0;
    LPWSTR pszLocationName = NULL;
    
    pPolicyStore = (PIPSEC_POLICY_STORE)AllocPolMem(
        sizeof(IPSEC_POLICY_STORE)
        );
    if (!pPolicyStore) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pszLocationName = AllocPolStr(pszMachineName);
    if (!pszLocationName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    pPolicyStore->dwProvider = IPSEC_WMI_PROVIDER;
    pPolicyStore->hParentRegistryKey = NULL;
    pPolicyStore->hRegistryKey = NULL;
    pPolicyStore->pszLocationName = pszLocationName;
    pPolicyStore->hLdapBindHandle = NULL;
    pPolicyStore->pszIpsecRootContainer = NULL;
    pPolicyStore->pszFileName = NULL;
    
    *phPolicyStore = pPolicyStore;

 cleanup:
    
    return(dwError);
    
 error:
    
    if (pPolicyStore) {
        FreePolMem(pPolicyStore);
    }
    
    *phPolicyStore = NULL;
    
    goto cleanup;
}


DWORD
DirOpenPolicyStore(
    LPWSTR pszDomain,
    HANDLE * phPolicyStore
    )
{
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    DWORD dwError = 0;
    LPWSTR pszIpsecRootContainer = NULL;
    HLDAP hLdapBindHandle = NULL;
    LPWSTR pszDefaultDirectory = NULL;
    LPWSTR pszCrackedDirectory = NULL;
    BOOL bCracked = FALSE;

    if (!pszDomain || !*pszDomain) {

        dwError = ComputeDefaultDirectory(
                      &pszDefaultDirectory
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = OpenDirectoryServerHandle(
                      pszDefaultDirectory,
                      389,
                      &hLdapBindHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = ComputeDirLocationName(
                      pszDefaultDirectory,
                      &pszIpsecRootContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }
    else {

        // Discover the domain name in the form ldap expects.
        //
        // If cracking the name fails, then try to connect using the caller 
        // supplied domain name anyway before failing altogether.
        //
        dwError = CrackDomainName(pszDomain, &bCracked, &pszCrackedDirectory);
        if (dwError == ERROR_SUCCESS) {
            if (bCracked) {
                pszDomain = pszCrackedDirectory;
            }
        }
        dwError = ERROR_SUCCESS;    

        dwError = OpenDirectoryServerHandle(
                      pszDomain,
                      389,
                      &hLdapBindHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = ComputeDirLocationName(
                      pszDomain,
                      &pszIpsecRootContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    pPolicyStore = (PIPSEC_POLICY_STORE)AllocPolMem(
                            sizeof(IPSEC_POLICY_STORE)
                            );
    if (!pPolicyStore) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pPolicyStore->dwProvider = IPSEC_DIRECTORY_PROVIDER;
    pPolicyStore->hParentRegistryKey = NULL;
    pPolicyStore->hRegistryKey = NULL;
    pPolicyStore->pszLocationName = NULL;
    pPolicyStore->hLdapBindHandle = hLdapBindHandle;
    pPolicyStore->pszIpsecRootContainer = pszIpsecRootContainer;
    pPolicyStore->pszFileName = NULL;

    *phPolicyStore = pPolicyStore;

cleanup:

    if (pszDefaultDirectory) {
        FreePolStr(pszDefaultDirectory);
    }
    if (pszCrackedDirectory) {
        NsuFree(&pszCrackedDirectory);
    }

    return(dwError);

error:

    if (hLdapBindHandle) {
        CloseDirectoryServerHandle(hLdapBindHandle);
    }

    if (pszIpsecRootContainer) {
        FreePolStr(pszIpsecRootContainer);
    }

    if (pPolicyStore) {
        FreePolMem(pPolicyStore);
    }

    *phPolicyStore = NULL;

    goto cleanup;
}


DWORD
FileOpenPolicyStore(
    LPWSTR pszMachineName,
    LPWSTR pszFileName,
    HANDLE * phPolicyStore
    )
{
    DWORD dwError = 0;
    LPWSTR pszIpsecRootContainer = NULL;
    HKEY hRegistryKey = NULL;
    LPWSTR pszTempFileName = NULL;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    DWORD dwDisposition = 0;


    pszIpsecRootContainer = AllocPolStr(gpszIpsecFileRootContainer);

    if (!pszIpsecRootContainer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!pszMachineName || !*pszMachineName) {
        dwError = RegCreateKeyExW(
                      HKEY_LOCAL_MACHINE,
                      (LPCWSTR) gpszIpsecFileRootContainer,
                      0,
                      NULL,
                      0,
                      KEY_ALL_ACCESS,
                      NULL,
                      &hRegistryKey,
                      &dwDisposition
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    else {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!pszFileName || !*pszFileName) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pszTempFileName = AllocPolStr(pszFileName);
    if (!pszTempFileName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
 
    pPolicyStore = (PIPSEC_POLICY_STORE)AllocPolMem(
                            sizeof(IPSEC_POLICY_STORE)
                            );
    if (!pPolicyStore) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pPolicyStore->dwProvider = IPSEC_FILE_PROVIDER;
    pPolicyStore->hParentRegistryKey = NULL;
    pPolicyStore->hRegistryKey = hRegistryKey;
    pPolicyStore->pszLocationName = NULL;
    pPolicyStore->hLdapBindHandle = NULL;
    pPolicyStore->pszIpsecRootContainer = pszIpsecRootContainer;
    pPolicyStore->pszFileName = pszTempFileName;

    *phPolicyStore = pPolicyStore;

    return(dwError);

error:

    if (pszIpsecRootContainer) {
        FreePolStr(pszIpsecRootContainer);
    }

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }

    if (pszTempFileName) {
        FreePolStr(pszTempFileName);
    }

    *phPolicyStore = NULL;

    return(dwError);
}


DWORD
IPSecClosePolicyStore(
    HANDLE hPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:

        if (pPolicyStore->hRegistryKey) {
            dwError = RegCloseKey(
                          pPolicyStore->hRegistryKey
                          );
            BAIL_ON_WIN32_ERROR(dwError);
        }

        if (pPolicyStore->hParentRegistryKey) {
            dwError = RegCloseKey(
                          pPolicyStore->hParentRegistryKey
                          );
            BAIL_ON_WIN32_ERROR(dwError);
        }
        if (pPolicyStore->pszLocationName) {
            FreePolStr(pPolicyStore->pszLocationName);
        }

        if (pPolicyStore->pszIpsecRootContainer) {
            FreePolStr(pPolicyStore->pszIpsecRootContainer);
        }

        break;

    case IPSEC_DIRECTORY_PROVIDER:

        if (pPolicyStore->hLdapBindHandle) {
            CloseDirectoryServerHandle(
                pPolicyStore->hLdapBindHandle
                );
        }

        if (pPolicyStore->pszIpsecRootContainer) {
            FreePolStr(pPolicyStore->pszIpsecRootContainer);
        }

        break;

    case IPSEC_FILE_PROVIDER:

        if (pPolicyStore->hRegistryKey) {
            dwError = RegCloseKey(
                          pPolicyStore->hRegistryKey
                          );
            BAIL_ON_WIN32_ERROR(dwError);
        }

        if (pPolicyStore->pszIpsecRootContainer) {
            FreePolStr(pPolicyStore->pszIpsecRootContainer);
        }

        if (pPolicyStore->pszFileName) {
            FreePolStr(pPolicyStore->pszFileName);
        }

        break;

    case IPSEC_WMI_PROVIDER:

        if(pPolicyStore->pszLocationName) {
            FreePolStr(pPolicyStore->pszLocationName);
        }

        break;

    default:

        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    if (pPolicyStore) {
        FreePolMem(pPolicyStore);
    }

error:

    return(dwError);
}


DWORD
IPSecAssignPolicy(
    HANDLE hPolicyStore,
    GUID PolicyGUID
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    HKEY hHKLMKey = 0;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        if (pPolicyStore->hParentRegistryKey) {
            hHKLMKey =  pPolicyStore->hParentRegistryKey;
        } else {
            hHKLMKey = HKEY_LOCAL_MACHINE;
        }
        dwError = RegAssignPolicy(
                            hHKLMKey,
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            PolicyGUID,
                            pPolicyStore->pszLocationName
                            );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecUnassignPolicy(
    HANDLE hPolicyStore,
    GUID PolicyGUID
    )
{
    DWORD dwError = 0;
    DWORD dwProvider = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    HKEY hHKLMKey = 0;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {
    case IPSEC_REGISTRY_PROVIDER:
        if (pPolicyStore->hParentRegistryKey) {
            hHKLMKey =  pPolicyStore->hParentRegistryKey;
        } else {
            hHKLMKey = HKEY_LOCAL_MACHINE;
        }
        dwError = RegUnassignPolicy(
                            hHKLMKey,
                            (pPolicyStore->hRegistryKey),
                            pPolicyStore->pszIpsecRootContainer,
                            PolicyGUID,
                            pPolicyStore->pszLocationName                       
                            );
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
ComputeDirLocationName(
    LPWSTR pszDirDomainName,
    LPWSTR * ppszDirFQPathName
    )
{
    DWORD dwError = 0;
    WCHAR szName[MAX_PATH];
    LPWSTR pszDotBegin = NULL;
    LPWSTR pszDotEnd = NULL;
    LPWSTR pszDirFQPathName = NULL;
    LPWSTR pszDirName = NULL;

    szName[0] = L'\0';
    wcscpy(szName, L"CN=IP Security,CN=System");

    pszDirName = AllocPolStr(pszDirDomainName);

    if (!pszDirName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
        
    pszDotBegin = pszDirName;
    pszDotEnd = wcschr(pszDirName, L'.');

    while (pszDotEnd) {

        *pszDotEnd = L'\0';

        wcscat(szName, L",DC=");
        wcscat(szName, pszDotBegin);

        *pszDotEnd = L'.';

        pszDotEnd += 1;
        pszDotBegin = pszDotEnd;

        pszDotEnd = wcschr(pszDotEnd, L'.');

    }

    wcscat(szName, L",DC=");
    wcscat(szName, pszDotBegin);

    pszDirFQPathName = AllocPolStr(szName);
    if (!pszDirFQPathName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszDirFQPathName = pszDirFQPathName;

cleanup:

    if (pszDirName) {
        FreePolStr(pszDirName);
    }

    return (dwError);

error:

    *ppszDirFQPathName = NULL;    
    goto cleanup;
}


DWORD
IPSecGetAssignedPolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;

    pPolicyStore = (PIPSEC_POLICY_STORE)hPolicyStore;

    switch (pPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:
        dwError = RegGetAssignedPolicyData(
                        (pPolicyStore->hRegistryKey),
                        pPolicyStore->pszIpsecRootContainer,
                        ppIpsecPolicyData
                        );
        break;

    case IPSEC_WMI_PROVIDER:
        ////*ppIpsecPolicyData = NULL;
        ////dwError = ERROR_NOT_SUPPORTED;
        dwError = ERROR_INVALID_PARAMETER;
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

    return(dwError);
}


DWORD
IPSecExportPolicies(
    HANDLE hSrcPolicyStore,
    HANDLE hDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pSrcPolicyStore = NULL;
    PIPSEC_POLICY_STORE pDesPolicyStore = NULL;


    pSrcPolicyStore = (PIPSEC_POLICY_STORE) hSrcPolicyStore;

    switch (pSrcPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:
    case IPSEC_DIRECTORY_PROVIDER:
        break;
    case IPSEC_WMI_PROVIDER:
        ////dwError = ERROR_NOT_SUPPORTED;
        ////BAIL_ON_WIN32_ERROR(dwError);
        break;
    default:
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;        
    }

    pDesPolicyStore = (PIPSEC_POLICY_STORE) hDesPolicyStore;

    switch (pDesPolicyStore->dwProvider) {

    case IPSEC_FILE_PROVIDER:
        dwError = ExportPoliciesToFile(
                      hSrcPolicyStore,
                      hDesPolicyStore
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

error:

    return(dwError);
}


DWORD
IPSecImportPolicies(
    HANDLE hSrcPolicyStore,
    HANDLE hDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pSrcPolicyStore = NULL;
    PIPSEC_POLICY_STORE pDesPolicyStore = NULL;


    pSrcPolicyStore = (PIPSEC_POLICY_STORE) hSrcPolicyStore;

    switch (pSrcPolicyStore->dwProvider) {

    case IPSEC_FILE_PROVIDER:
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    pDesPolicyStore = (PIPSEC_POLICY_STORE) hDesPolicyStore;

    switch (pDesPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:
    case IPSEC_DIRECTORY_PROVIDER:
        dwError = ImportPoliciesFromFile(
            hSrcPolicyStore,
            hDesPolicyStore
            );
        BAIL_ON_WIN32_ERROR(dwError);
        break;
    case IPSEC_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;
    default:
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;
        
    }
    
error:
    
    return(dwError);
}


DWORD
IPSecRestoreDefaultPolicies(
    HANDLE hPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;


    pPolicyStore = (PIPSEC_POLICY_STORE) hPolicyStore;

    switch (pPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:

        dwError = RegRestoreDefaults(
                      hPolicyStore,
                      pPolicyStore->hRegistryKey,
                      pPolicyStore->pszIpsecRootContainer,
                      pPolicyStore->pszLocationName
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    case IPSEC_DIRECTORY_PROVIDER:

        dwError = ERROR_INVALID_PARAMETER;
        break;

    case IPSEC_WMI_PROVIDER:
        dwError = ERROR_NOT_SUPPORTED;
        break;

    default:

        dwError = ERROR_INVALID_PARAMETER;
        break;

    }

error:

    return(dwError);
}


HRESULT
WriteDirectoryPolicyToWMI(
    LPWSTR pszMachineName,
    LPWSTR pszPolicyDN,
    PGPO_INFO pGPOInfo,
    IWbemServices *pWbemServices
    )
{
    DWORD dwError = 0;
    HRESULT hr = S_OK;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    BOOL bDeepRead;
    
    if (!pGPOInfo || !pWbemServices) {
        hr = E_INVALIDARG;
        BAIL_ON_HRESULT_ERROR(hr);
    }
    
    bDeepRead = (pGPOInfo->uiPrecedence == 1);
    
    hr = ReadPolicyObjectFromDirectoryEx(
        pszMachineName,
        pszPolicyDN,
        bDeepRead,
        &pIpsecPolicyObject
        );
    BAIL_ON_HRESULT_ERROR(hr);

    hr = WritePolicyObjectDirectoryToWMI(
        pWbemServices,
        pIpsecPolicyObject,
        pGPOInfo
        );
    BAIL_ON_HRESULT_ERROR(hr);

 error:
    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    return(hr);
}

HRESULT
IPSecClearWMIStore(
    IWbemServices *pWbemServices
    )
{
    HRESULT hr = S_OK;
    
    if (!pWbemServices) {
        hr = E_INVALIDARG;
        BAIL_ON_HRESULT_ERROR(hr);
    }

    hr = DeleteWMIClassObject(
        pWbemServices,
        IPSEC_RSOP_CLASSNAME
        );
    BAIL_ON_HRESULT_ERROR(hr);

 error:
    return(hr);
}

DWORD
IPSecChooseDriverBootMode(
    HKEY  hHKLMKey,
    DWORD dwStore,
    DWORD dwAction
    )
{

    BOOL bRegPolicyAssigned = FALSE;
    BOOL bPersistentPolicyAssigned = FALSE;
    BOOL bDirectoryPolicyAssigned = FALSE;
    BOOL bComplementaryPolicyAssigned = FALSE;
    BOOL bBootmodeValueExists = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    

     dwError = IsRegvalueExist(
                hHKLMKey,
                gpszRegLocalContainer,
                gpActivePolicyKey,
                &bRegPolicyAssigned
            );
     BAIL_ON_WIN32_ERROR(dwError);
           
     dwError = IsRegvalueExist(
                hHKLMKey,
                gpszRegPersistentContainer,
                gpActivePolicyKey,
                &bPersistentPolicyAssigned
            );
     BAIL_ON_WIN32_ERROR(dwError);
     
     dwError = IsRegvalueExist(
                hHKLMKey,
                gpszIPsecDirContainer,
                gpDirectoryPolicyPointerKey,
                &bDirectoryPolicyAssigned
                );
    BAIL_ON_WIN32_ERROR(dwError);
    
    bComplementaryPolicyAssigned =
         (dwStore == IPSEC_REGISTRY_PROVIDER   && (bPersistentPolicyAssigned || bDirectoryPolicyAssigned))
      || (dwStore == IPSEC_DIRECTORY_PROVIDER  && (bPersistentPolicyAssigned || bRegPolicyAssigned))
      || (dwStore == IPSEC_PERSISTENT_PROVIDER && (bDirectoryPolicyAssigned  || bRegPolicyAssigned));

    if (dwAction == POL_ACTION_ASSIGN && 
        !bComplementaryPolicyAssigned)  
        {
            dwError = IsRegvalueExist(
                        hHKLMKey,
                        REG_KEY_IPSEC_DRIVER_SERVICE,
                        REG_VAL_IPSEC_OPERATIONMODE,
                        &bBootmodeValueExists
                        );
            BAIL_ON_WIN32_ERROR(dwError);
            if (!bBootmodeValueExists) {
                dwError = IPSecSetDriverOperationMode(
                    hHKLMKey,
                    REG_IPSEC_DRIVER_STATEFULMODE
                    );        
                BAIL_ON_WIN32_ERROR(dwError);
            }
        }
    else if (dwAction == POL_ACTION_UNASSIGN &&
              !bComplementaryPolicyAssigned) 
        {
            dwError = IPSecRegDeleteValue(
                hHKLMKey,
                REG_KEY_IPSEC_DRIVER_SERVICE,
                REG_VAL_IPSEC_OPERATIONMODE
            );
            BAIL_ON_WIN32_ERROR(dwError);
        }
    return dwError;    
error:
    return dwError;
}


DWORD
IPSecSetDriverOperationMode(
    HKEY hHKLMKey,
    DWORD dwNewOperationMode
    )
{
    DWORD dwError = 0;
    HKEY hKey = NULL;
    
   dwError = RegOpenKeyExW(
                 hHKLMKey,
                 (LPCWSTR) REG_KEY_IPSEC_DRIVER_SERVICE,
                 0,
                 KEY_ALL_ACCESS,
                 &hKey
                 );    
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
               hKey,
               REG_VAL_IPSEC_OPERATIONMODE,
               0,
               REG_DWORD,
               (LPBYTE) &dwNewOperationMode,
               sizeof(DWORD)
               );
    BAIL_ON_WIN32_ERROR(dwError);
    
error:
    if (hKey) {
        RegCloseKey(hKey);
    }

    return (dwError);
}

DWORD
IsRegvalueExist(
    HKEY hHKLMKey,
    LPWSTR pszKey,
    LPWSTR pszValue,
    BOOL * pbValueExists
    )
{
    DWORD dwError = 0;
    HKEY hKey = NULL;
    DWORD dwtype = 0;
    BOOL bValueExists = FALSE;

   dwError = RegOpenKeyExW(
                 hHKLMKey,
                 (LPCWSTR) pszKey,
                 0,
                 KEY_ALL_ACCESS,
                 &hKey
                 );
   if (dwError == ERROR_FILE_NOT_FOUND) {
        // Container key doesn't exist so value doesn't exist anyway...
        //    

        dwError = ERROR_SUCCESS;
        bValueExists = FALSE;
    } else {
        BAIL_ON_WIN32_ERROR(dwError);
        
        dwError = RegQueryValueExW(
                      hKey,
                      pszValue,
                      0,
                      &dwtype,
                      NULL,
                      NULL
                      );
        if (dwError == ERROR_FILE_NOT_FOUND) {
            dwError = ERROR_SUCCESS;
            bValueExists = FALSE;
        } else {    
            BAIL_ON_WIN32_ERROR(dwError);

            // ERROR_SUCCESS means registry key found
            //
            bValueExists = TRUE;
        }
    }
    
    *pbValueExists = bValueExists;
error:
    if (hKey) {
        RegCloseKey(hKey);
    }

    return dwError;
}

DWORD
IPSecRegDeleteValue(
    HKEY hHKLMKey,
    LPWSTR pszKey,
    LPWSTR pszValue
    )
{
    HKEY hKey = NULL;
    DWORD dwtype = 0;
    DWORD dwError = 0;
   dwError = RegOpenKeyExW(
                 hHKLMKey,
                 (LPCWSTR) pszKey,
                 0,
                 KEY_ALL_ACCESS,
                 &hKey
                 );
  
    BAIL_ON_WIN32_ERROR(dwError);
    dwError = RegDeleteValueW(
                    hKey,
                    pszValue
                    );
    if (dwError == ERROR_FILE_NOT_FOUND) {
        dwError = ERROR_SUCCESS;
    }

    BAIL_ON_WIN32_ERROR(dwError);
    
error:
    if (hKey) {
        RegCloseKey(hKey);
    }

    return (dwError);
}


DWORD
IsAnyPolicyAssigned (
    HKEY hHKLMKey,
    BOOL * pbAnyPolicyAssigned    
    )    
{
    BOOL bAnyPolicyAssigned = FALSE;
    BOOL bRegPolicyAssigned = FALSE;
    BOOL bPersistentPolicyAssigned = FALSE;
    BOOL bDirectoryPolicyAssigned = FALSE;
    DWORD dwError = ERROR_SUCCESS;
    

    dwError = IsRegvalueExist(
            hHKLMKey,
            gpszRegLocalContainer,
            gpActivePolicyKey,
            &bRegPolicyAssigned
        );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!bRegPolicyAssigned) {   
        dwError = IsRegvalueExist(
                hHKLMKey,
                gpszRegPersistentContainer,
                gpActivePolicyKey,
                &bPersistentPolicyAssigned
            );
        BAIL_ON_WIN32_ERROR(dwError);

        if (!bPersistentPolicyAssigned) {
            dwError = IsRegvalueExist(
                    hHKLMKey,
                    gpszIPsecDirContainer,
                    gpDirectoryPolicyPointerKey,
                    &bDirectoryPolicyAssigned
                    );
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    bAnyPolicyAssigned = bRegPolicyAssigned ||
                         bPersistentPolicyAssigned ||
                         bDirectoryPolicyAssigned;

    *pbAnyPolicyAssigned = bAnyPolicyAssigned;
error:    
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\utils.h ===
BOOL
HexStringToDword(
    LPCWSTR lpsz,
    DWORD * RetValue,
    int cDigits,
    WCHAR chDelim
    );

BOOL
wUUIDFromString(
    LPCWSTR lpsz,
    LPGUID pguid
    );

BOOL
wGUIDFromString(
    LPCWSTR lpsz,
    LPGUID pguid
    );

DWORD
EnablePrivilege(
    LPCTSTR pszPrivilege
    );

BOOL 
IsStringInArray(
    LPWSTR * ppszStrings,
    LPWSTR pszKey,
    DWORD dwNumStrings
    );    

DWORD
GeneralizedTimeToTime(
    IN LPWSTR pszGenTime,
    OUT time_t * ptTime
    );

// Minumum string length of an LDAP generalized UTC time
//

#define MIN_GEN_UTC_LEN 15

//
// Macro to truncate time_t value to DWORD; necessary because on IA64, time_t is 
// 64-bit, but right now polstore can only deal with 32-bit version of time_t

#define TIME_T_TO_DWORD(_T) ((DWORD) _T)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\connui.c ===
#include "precomp.h"


LPWSTR gpszIpsecLocalPolicyKey = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Local";

LPWSTR gpszIpsecDSPolicyKey = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\GPTIPSECPolicy";

DWORD
IPSecIsDomainPolicyAssigned(
    PBOOL pbIsDomainPolicyAssigned
    )
{
    DWORD dwError = 0;
    BOOL bIsDomainPolicyAssigned = FALSE;
    HKEY hRegistryKey = NULL;
    DWORD dwType = 0;
    DWORD dwDSPolicyPathLength = 0;


    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  (LPCWSTR) gpszIpsecDSPolicyKey,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegistryKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegQueryValueExW(
                  hRegistryKey,
                  L"DSIPSECPolicyPath",
                  NULL,
                  &dwType,
                  NULL,
                  &dwDSPolicyPathLength
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwDSPolicyPathLength > 0) {
        bIsDomainPolicyAssigned = TRUE;
    }

    *pbIsDomainPolicyAssigned = bIsDomainPolicyAssigned;

cleanup:

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }

    return (dwError);

error:

    *pbIsDomainPolicyAssigned = FALSE;
 
    goto cleanup;
}


DWORD
IPSecIsLocalPolicyAssigned(
    PBOOL pbIsLocalPolicyAssigned
    )
{
    DWORD dwError = 0;
    BOOL bIsLocalPolicyAssigned = FALSE;
    HKEY hRegistryKey = NULL;
    DWORD dwType = 0;
    DWORD dwLocalPolicyPathLength = 0;


    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  (LPCWSTR) gpszIpsecLocalPolicyKey,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegistryKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegQueryValueExW(
                  hRegistryKey,
                  L"ActivePolicy",
                  NULL,
                  &dwType,
                  NULL,
                  &dwLocalPolicyPathLength
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwLocalPolicyPathLength > 0) {
        bIsLocalPolicyAssigned = TRUE;
    }

    *pbIsLocalPolicyAssigned = bIsLocalPolicyAssigned;

cleanup:

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }

    return (dwError);

error:

    *pbIsLocalPolicyAssigned = FALSE;
 
    goto cleanup;
}


DWORD
IPSecGetAssignedDomainPolicyName(
    LPWSTR * ppszAssignedDomainPolicyName
    )
{
    DWORD dwError = 0;
    LPWSTR pszAssignedDomainPolicyName = NULL;
    HKEY hRegistryKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;


    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  (LPCWSTR) gpszIpsecDSPolicyKey,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegistryKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hRegistryKey,
                  L"DSIPSECPolicyName",
                  REG_SZ,
                  (LPBYTE *)&pszAssignedDomainPolicyName,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppszAssignedDomainPolicyName = pszAssignedDomainPolicyName;

cleanup:

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }

    return (dwError);

error:

    *ppszAssignedDomainPolicyName = NULL;
 
    goto cleanup;
}


DWORD
RegGetAssignedPolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    DWORD dwError = 0;
    LPWSTR  pszIpsecPolicyName = NULL;
    DWORD dwSize = 0;
    LPWSTR  pszRelativeName = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;


    dwError = RegstoreQueryValue(
                  hRegistryKey,
                  L"ActivePolicy",
                  REG_SZ,
                  (LPBYTE *)&pszIpsecPolicyName,
                  &dwSize
                  );

    if (pszIpsecPolicyName && *pszIpsecPolicyName) {
        if (wcslen(pszIpsecPolicyName) >
            (wcslen(pszIpsecRootContainer) + 1)) {
            pszRelativeName = pszIpsecPolicyName
            + wcslen(pszIpsecRootContainer) + 1;

            dwError = UnMarshallRegistryPolicyObject(
                          hRegistryKey,
                          pszIpsecRootContainer,
                          pszRelativeName,
                          REG_RELATIVE_NAME,
                          &pIpsecPolicyObject
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            dwError = RegUnmarshallPolicyData(
                          pIpsecPolicyObject,
                          &pIpsecPolicyData
                          );
            BAIL_ON_WIN32_ERROR(dwError);

        }
    }

    *ppIpsecPolicyData = pIpsecPolicyData;

cleanup:

    if (pszIpsecPolicyName) {
        FreePolStr(pszIpsecPolicyName);
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
            pIpsecPolicyObject
            );
    }

    return (dwError);

error:

    *ppIpsecPolicyData = NULL;

    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\wmistore.c ===
#include "precomp.h"

LPWSTR gpszIpsecWMINamespace = L"root\\rsop\\computer";

DWORD
Win32FromWmiHresult(
    HRESULT hr
    )
{
   if (SUCCEEDED(hr)) {
       return ERROR_SUCCESS;
   } else {
       switch (hr) {
            case WBEM_E_ACCESS_DENIED:
                return ERROR_ACCESS_DENIED;

            case REGDB_E_CLASSNOTREG:
            case CLASS_E_NOAGGREGATION:
            case E_NOINTERFACE:
            case WBEM_E_INVALID_NAMESPACE:
            case WBEM_E_INVALID_PARAMETER:
            case WBEM_E_NOT_FOUND:
            case WBEM_E_INVALID_CLASS:
            case WBEM_E_INVALID_OBJECT_PATH:
                return ERROR_INVALID_PARAMETER;

            case WBEM_E_OUT_OF_MEMORY:
                return ERROR_OUTOFMEMORY;

            case WBEM_E_TRANSPORT_FAILURE:
                return RPC_S_CALL_FAILED;
                
            case WBEM_E_FAILED:
            default:
                return ERROR_WMI_TRY_AGAIN;
        }
   }
}

DWORD
UnMarshallWMIPolicyObject(
    IWbemClassObject *pWbemClassObject,
    PIPSEC_POLICY_OBJECT  * ppIpsecPolicyObject
    )
{

    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwIpsecDataType = 0;
    DWORD dwWhenChanged = 0;
    LPBYTE pBuffer = NULL;

    DWORD i = 0;
    DWORD dwCount = 0;
    DWORD dwError = 0;
    HRESULT hr = S_OK;    
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszIpsecNFAName = NULL;
    LPWSTR pszTemp = NULL;
    LPWSTR pszString = NULL;
    LPWSTR pszIpsecNFAReference = NULL;
    LPWSTR pszRelativeName = NULL;
    DWORD dwRootPathLen = 0;


    ////start
    VARIANT var; //contains pszIpsecPolicyDN
    
    VariantInit(&var);
    
    hr = IWbemClassObject_Get(pWbemClassObject,
                                   L"id",
                                   0,
                                   &var,
                                   0,
                                   0);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

    
    pIpsecPolicyObject = (PIPSEC_POLICY_OBJECT)AllocPolMem(sizeof(IPSEC_POLICY_OBJECT));
    if (!pIpsecPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pIpsecPolicyObject->pszIpsecOwnersReference = AllocPolStr((LPWSTR)var.bstrVal);
    VariantClear(&var);    
    if (!pIpsecPolicyObject->pszIpsecOwnersReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pIpsecPolicyObject->pRsopInfo = (PRSOP_INFO)AllocPolMem(sizeof(RSOP_INFO));
    if (!pIpsecPolicyObject->pRsopInfo) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    dwError = WMIstoreQueryValue(pWbemClassObject,
                                 L"creationtime",
                                 VT_BSTR,
                                 (LPBYTE *)&pIpsecPolicyObject->pRsopInfo->pszCreationtime,
                                 &dwSize);

    dwError = WMIstoreQueryValue(pWbemClassObject,
                                 L"GPOID",
                                 VT_BSTR,
                                 (LPBYTE *)&pIpsecPolicyObject->pRsopInfo->pszGPOID,
                                 &dwSize);

    dwError = WMIstoreQueryValue(pWbemClassObject,
                                 L"id",
                                 VT_BSTR,
                                 (LPBYTE *)&pIpsecPolicyObject->pRsopInfo->pszID,
                                 &dwSize);

    dwError = WMIstoreQueryValue(pWbemClassObject,
                                 L"name",
                                 VT_BSTR,
                                 (LPBYTE *)&pIpsecPolicyObject->pRsopInfo->pszName,
                                 &dwSize);

    dwError = WMIstoreQueryValue(pWbemClassObject,
                                 L"SOMID",
                                 VT_BSTR,
                                 (LPBYTE *)&pIpsecPolicyObject->pRsopInfo->pszSOMID,
                                 &dwSize);

    hr = IWbemClassObject_Get(pWbemClassObject,
                                   L"precedence",
                                   0,
                                   &var,
                                   0,
                                   0);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

    pIpsecPolicyObject->pRsopInfo->uiPrecedence = var.lVal;

    dwError = WMIstoreQueryValue(pWbemClassObject,
                                 L"ipsecName",
                                 VT_BSTR,
                                 (LPBYTE *)&pIpsecPolicyObject->pszIpsecName,
                                 &dwSize);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = WMIstoreQueryValue(pWbemClassObject,
                                 L"description",
                                 VT_BSTR,
                                 (LPBYTE *)&pIpsecPolicyObject->pszDescription,
                                 &dwSize);
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = WMIstoreQueryValue(pWbemClassObject,
                                 L"ipsecID",
                                 VT_BSTR,
                                 (LPBYTE *)&pIpsecPolicyObject->pszIpsecID,
                                 &dwSize);
    BAIL_ON_WIN32_ERROR(dwError);

    hr = IWbemClassObject_Get(pWbemClassObject,
                                   L"ipsecDataType",
                                   0,
                                   &var,
                                   0,
                                   0);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

    dwIpsecDataType = var.lVal;

    pIpsecPolicyObject->dwIpsecDataType = dwIpsecDataType;
    
    dwError = WMIstoreQueryValue(pWbemClassObject,
                                 L"ipsecData",
                                 VT_ARRAY|VT_UI1,
                                 &pIpsecPolicyObject->pIpsecData,
                                 &pIpsecPolicyObject->dwIpsecDataLen);
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = WMIstoreQueryValue(pWbemClassObject,
                                 L"ipsecISAKMPReference",
                                 VT_BSTR,
                                 (LPBYTE *)&pIpsecPolicyObject->pszIpsecISAKMPReference,
                                 &dwSize);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = WMIstoreQueryValue(pWbemClassObject,
                                 L"ipsecNFAReference",
                                 VT_ARRAY|VT_BSTR,
                                 (LPBYTE *)&pszIpsecNFAReference,
                                 &dwSize);
    BAIL_ON_WIN32_ERROR(dwError);

    ////errr, multi-string processing
    pszTemp = pszIpsecNFAReference;
    while (*pszTemp != L'\0') {
        pszTemp += wcslen(pszTemp) + 1;
        dwCount++;
    }

    ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(sizeof(LPWSTR)*dwCount);
    if (!ppszIpsecNFANames) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    pszTemp = pszIpsecNFAReference;
    for (i = 0; i < dwCount; i++) {
        pszString = AllocPolStr(pszTemp);
        if (!pszString) {
            dwError = ERROR_OUTOFMEMORY;
            pIpsecPolicyObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
            pIpsecPolicyObject->NumberofRules = i;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        *(ppszIpsecNFANames + i) = pszString;
        
        pszTemp += wcslen(pszTemp) + 1; //for the null terminator;

    }

    if (pszIpsecNFAReference) {
        FreePolStr(pszIpsecNFAReference);
    }

    pIpsecPolicyObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
    pIpsecPolicyObject->NumberofRules = dwCount;

    hr = IWbemClassObject_Get(pWbemClassObject,
                                   L"whenChanged",
                                   0,
                                   &var,
                                   0,
                                   0);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

    dwWhenChanged = var.lVal;
    
    pIpsecPolicyObject->dwWhenChanged = dwWhenChanged;
    
    *ppIpsecPolicyObject = pIpsecPolicyObject;

 cleanup:

    return(dwError);
    
 error:
    
    if (pszIpsecNFAReference) {
        FreePolStr(pszIpsecNFAReference);
    }
    
    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }
    
    *ppIpsecPolicyObject = NULL;

    goto cleanup;

}



DWORD
UnMarshallWMIFilterObject(
    IWbemClassObject *pWbemClassObject,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    )
{

    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwIpsecDataType = 0;
    DWORD dwWhenChanged = 0;
    LPBYTE pBuffer = NULL;

    DWORD dwCount = 0;
    DWORD i = 0;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszString = NULL;

    LPWSTR pszIpsecNFAReference = NULL;
    LPWSTR pszTemp = NULL;

    DWORD dwError = 0;
    HRESULT hr = S_OK;    
    LPWSTR pszRelativeName = NULL;
    DWORD dwRootPathLen = 0;

    //start
    VARIANT var; //=>pszIpsecFilterReference

    VariantInit(&var);
    
    hr = IWbemClassObject_Get(pWbemClassObject,
                                   L"id",
                                   0,
                                   &var,
                                   0,
                                   0);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
    
    pIpsecFilterObject = (PIPSEC_FILTER_OBJECT)AllocPolMem(
        sizeof(IPSEC_FILTER_OBJECT)
        );
    if (!pIpsecFilterObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    pIpsecFilterObject->pszDistinguishedName = AllocPolStr(
        (LPWSTR)var.bstrVal
        );
    VariantClear(&var);
    if (!pIpsecFilterObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"description",
        VT_BSTR,
        (LPBYTE *)&pIpsecFilterObject->pszDescription,
        &dwSize
        );
    //BAIL_ON_WIN32_ERROR(dwError);

    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"ipsecName",
        VT_BSTR,
        (LPBYTE *)&pIpsecFilterObject->pszIpsecName,
        &dwSize
        );
    //BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"ipsecID",
        VT_BSTR,
        (LPBYTE *)&pIpsecFilterObject->pszIpsecID,
        &dwSize
        );
    BAIL_ON_WIN32_ERROR(dwError);

    hr = IWbemClassObject_Get(pWbemClassObject,
                                   L"ipsecDataType",
                                   0,
                                   &var,
                                   0,
                                   0);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
    
    dwIpsecDataType = var.lVal;

    pIpsecFilterObject->dwIpsecDataType = dwIpsecDataType;


    //
    // unmarshall the ipsecData blob
    //

    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"ipsecData",
        VT_ARRAY|VT_UI1,
        &pIpsecFilterObject->pIpsecData,
        &pIpsecFilterObject->dwIpsecDataLen
        );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Owner's reference
    //

    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"ipsecOwnersReference",
        VT_ARRAY|VT_BSTR,
        (LPBYTE *)&pszIpsecNFAReference,
        &dwSize
        );
    //BAIL_ON_WIN32_ERROR(dwError);
    
    if (!dwError) { //no error
        pszTemp = pszIpsecNFAReference;
        while (*pszTemp != L'\0') {
            pszTemp += wcslen(pszTemp) + 1;
            dwCount++;
        }
        
        ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
            sizeof(LPWSTR)*dwCount
            );
        if (!ppszIpsecNFANames) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        pszTemp = pszIpsecNFAReference;
        for (i = 0; i < dwCount; i++) {
            pszString = AllocPolStr(pszTemp);
            if (!pszString) {
                dwError = ERROR_OUTOFMEMORY;
                pIpsecFilterObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
                pIpsecFilterObject->dwNFACount = i;
                if (pszIpsecNFAReference) {
                    FreePolStr(pszIpsecNFAReference);
                }
                BAIL_ON_WIN32_ERROR(dwError);
            }
            *(ppszIpsecNFANames + i) = pszString;
            pszTemp += wcslen(pszTemp) + 1; //for the null terminator;
        }
        if (pszIpsecNFAReference) {
            FreePolStr(pszIpsecNFAReference);
        }
        
        pIpsecFilterObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
        pIpsecFilterObject->dwNFACount = dwCount;
    }

    hr = IWbemClassObject_Get(pWbemClassObject,
                                   L"whenChanged",
                                   0,
                                   &var,
                                   0,
                                   0);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

    dwWhenChanged = var.lVal;
    
    pIpsecFilterObject->dwWhenChanged = dwWhenChanged;

    *ppIpsecFilterObject = pIpsecFilterObject;

 cleanup:
    
    return(dwError);
    
 error:
    
    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(pIpsecFilterObject);
    }

    *ppIpsecFilterObject = NULL;
    
    goto cleanup;
}


DWORD
UnMarshallWMINegPolObject(
    IWbemClassObject *pWbemClassObject,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObject
    )
{

    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwIpsecDataType = 0;
    DWORD dwWhenChanged = 0;
    LPBYTE pBuffer = NULL;

    DWORD dwCount = 0;
    DWORD i = 0;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszString = NULL;

    LPWSTR pszIpsecNFAReference = NULL;
    LPWSTR pszTemp = NULL;

    DWORD dwError = 0;
    HRESULT hr = S_OK;

    LPWSTR pszRelativeName = NULL;
    DWORD dwRootPathLen = 0;


    //start
    VARIANT var; //=>pszIpsecNegPolReference

    VariantInit(&var);

    hr = IWbemClassObject_Get(pWbemClassObject,
                                   L"id",
                                   0,
                                   &var,
                                   0,
                                   0);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
    
    pIpsecNegPolObject = (PIPSEC_NEGPOL_OBJECT)AllocPolMem(
        sizeof(IPSEC_NEGPOL_OBJECT)
        );
    if (!pIpsecNegPolObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pIpsecNegPolObject->pszDistinguishedName = AllocPolStr(
        (LPWSTR)var.bstrVal
        );
    VariantClear(&var);        
    if (!pIpsecNegPolObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    //
    // Names do not get written on an NegPol Object
    //

    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"ipsecName",
        VT_BSTR,
        (LPBYTE *)&pIpsecNegPolObject->pszIpsecName,
        &dwSize
        );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"description",
        VT_BSTR,
        (LPBYTE *)&pIpsecNegPolObject->pszDescription,
        &dwSize
        );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"ipsecID",
        VT_BSTR,
        (LPBYTE *)&pIpsecNegPolObject->pszIpsecID,
        &dwSize
        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"ipsecNegotiationPolicyAction",
        VT_BSTR,
        (LPBYTE *)&pIpsecNegPolObject->pszIpsecNegPolAction,
        &dwSize
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"ipsecNegotiationPolicyType",
        VT_BSTR,
        (LPBYTE *)&pIpsecNegPolObject->pszIpsecNegPolType,
        &dwSize
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    hr= IWbemClassObject_Get(pWbemClassObject,
                                   L"ipsecDataType",
                                   0,
                                   &var,
                                   0,
                                   0);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

    dwIpsecDataType = var.lVal;

    pIpsecNegPolObject->dwIpsecDataType = dwIpsecDataType;

    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"ipsecData",
        VT_ARRAY|VT_UI1,
        &pIpsecNegPolObject->pIpsecData,
        &pIpsecNegPolObject->dwIpsecDataLen
        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"ipsecOwnersReference",
        VT_ARRAY|VT_BSTR,
        (LPBYTE *)&pszIpsecNFAReference,
        &dwSize
        );
    // BAIL_ON_WIN32_ERROR(dwError);

    if (!dwError) {
        pszTemp = pszIpsecNFAReference;
        while (*pszTemp != L'\0') {
            pszTemp += wcslen(pszTemp) + 1;
            dwCount++;
        }

        ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
            sizeof(LPWSTR)*dwCount
            );
        if (!ppszIpsecNFANames) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pszTemp = pszIpsecNFAReference;
        for (i = 0; i < dwCount; i++) {
            pszString = AllocPolStr(pszTemp);
            if (!pszString) {
                dwError = ERROR_OUTOFMEMORY;
                pIpsecNegPolObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
                pIpsecNegPolObject->dwNFACount = i;
                if (pszIpsecNFAReference) {
                    FreePolStr(pszIpsecNFAReference);
                }
                BAIL_ON_WIN32_ERROR(dwError);
            }
            *(ppszIpsecNFANames + i) = pszString;
            pszTemp += wcslen(pszTemp) + 1; //for the null terminator;
        }

        if (pszIpsecNFAReference) {
            FreePolStr(pszIpsecNFAReference);
        }

        pIpsecNegPolObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
        pIpsecNegPolObject->dwNFACount = dwCount;
    }

    hr = IWbemClassObject_Get(pWbemClassObject,
                                   L"whenChanged",
                                   0,
                                   &var,
                                   0,
                                   0);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

    dwWhenChanged = var.lVal;

    pIpsecNegPolObject->dwWhenChanged = dwWhenChanged;

    *ppIpsecNegPolObject = pIpsecNegPolObject;

 cleanup:

    return(dwError);

 error:
    
    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(pIpsecNegPolObject);
    }

    *ppIpsecNegPolObject = NULL;

    goto cleanup;
}


DWORD
UnMarshallWMIISAKMPObject(
    IWbemClassObject *pWbemClassObject,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObject
    )
{

    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwIpsecDataType = 0;
    DWORD dwWhenChanged = 0;
    LPBYTE pBuffer = NULL;

    DWORD dwCount = 0;
    DWORD i = 0;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszString = NULL;

    LPWSTR pszIpsecNFAReference = NULL;
    LPWSTR pszTemp = NULL;

    DWORD dwError = 0;
    HRESULT hr = S_OK;

    LPWSTR pszRelativeName = NULL;
    DWORD dwRootPathLen = 0;


    //start
    VARIANT var; //=>pszIpsecISAKMPReference

    VariantInit(&var);

    hr = IWbemClassObject_Get(pWbemClassObject,
                                   L"id",
                                   0,
                                   &var,
                                   0,
                                   0);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

    pIpsecISAKMPObject = (PIPSEC_ISAKMP_OBJECT)AllocPolMem(
        sizeof(IPSEC_ISAKMP_OBJECT)
        );
    if (!pIpsecISAKMPObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pIpsecISAKMPObject->pszDistinguishedName = AllocPolStr(
        (LPWSTR)var.bstrVal
        );
    VariantClear(&var);        
    if (!pIpsecISAKMPObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    //
    // Names are not set for ISAKMP objects
    //

    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"ipsecName",
        VT_BSTR,
        (LPBYTE *)&pIpsecISAKMPObject->pszIpsecName,
        &dwSize
        );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"ipsecID",
        VT_BSTR,
        (LPBYTE *)&pIpsecISAKMPObject->pszIpsecID,
        &dwSize
        );
    BAIL_ON_WIN32_ERROR(dwError);

    hr = IWbemClassObject_Get(pWbemClassObject,
                                   L"ipsecDataType",
                                   0,
                                   &var,
                                   0,
                                   0);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

    dwIpsecDataType = var.lVal;

    pIpsecISAKMPObject->dwIpsecDataType = dwIpsecDataType;
    
    //
    // unmarshall the ipsecData blob
    //
    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"ipsecData",
        VT_ARRAY|VT_UI1,
        &pIpsecISAKMPObject->pIpsecData,
        &pIpsecISAKMPObject->dwIpsecDataLen
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    //
    // ipsecOwnersReference not written
    //

    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"ipsecOwnersReference",
        VT_ARRAY|VT_BSTR,
        (LPBYTE *)&pszIpsecNFAReference,
        &dwSize
        );
    // BAIL_ON_WIN32_ERROR(dwError);


    if (!dwError) {
        pszTemp = pszIpsecNFAReference;
        while (*pszTemp != L'\0') {
            pszTemp += wcslen(pszTemp) + 1;
            dwCount++;
        }
        
        ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
            sizeof(LPWSTR)*dwCount
            );
        if (!ppszIpsecNFANames) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        pszTemp = pszIpsecNFAReference;
        for (i = 0; i < dwCount; i++) {
            pszString = AllocPolStr(pszTemp);
            if (!pszString) {
                dwError = ERROR_OUTOFMEMORY;
                pIpsecISAKMPObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
                pIpsecISAKMPObject->dwNFACount = i;
                if (pszIpsecNFAReference) {
                    FreePolStr(pszIpsecNFAReference);
                }
                BAIL_ON_WIN32_ERROR(dwError);
            }
            *(ppszIpsecNFANames + i) = pszString;
            pszTemp += wcslen(pszTemp) + 1; //for the null terminator;
        }
        if (pszIpsecNFAReference) {
            FreePolStr(pszIpsecNFAReference);
        }
        pIpsecISAKMPObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
        pIpsecISAKMPObject->dwNFACount = dwCount;
    }

    hr = IWbemClassObject_Get(pWbemClassObject,
                                   L"whenChanged",
                                   0,
                                   &var,
                                   0,
                                   0);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

    dwWhenChanged = var.lVal;

    pIpsecISAKMPObject->dwWhenChanged = dwWhenChanged;
    
    *ppIpsecISAKMPObject = pIpsecISAKMPObject;
    
 cleanup:
   

    return(dwError);
    
 error:
    
    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(pIpsecISAKMPObject);
    }
    
    *ppIpsecISAKMPObject = NULL;
    
    goto cleanup;
}


DWORD
UnMarshallWMINFAObject(
    IWbemServices *pWbemServices,
    LPWSTR pszIpsecNFAReference,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject,
    LPWSTR * ppszFilterReference,
    LPWSTR * ppszNegPolReference
    )
{
    
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    DWORD dwIpsecDataType = 0;
    DWORD dwWhenChanged = 0;
    LPBYTE pBuffer = NULL;
    
    DWORD i = 0;
    DWORD dwCount = 0;
    DWORD dwError = 0;
    LPWSTR  pszTempFilterReference = NULL;
    LPWSTR  pszTempNegPolReference = NULL;
    
    LPWSTR pszRelativeName = NULL;
    DWORD dwRootPathLen = 0;
    HRESULT hr = S_OK;

    ////start
    VARIANT var; //=>pszIpsecNFAReference
    IWbemClassObject *pWbemClassObject = NULL;

    ////wbem
    IWbemClassObject *pObj = NULL;
    LPWSTR objPathA = L"RSOP_IPSECPolicySetting.id=";
    LPWSTR objPath = NULL;
    BSTR bstrObjPath = NULL;


    VariantInit(&var);
    
    ////keep
    if (!pszIpsecNFAReference || !*pszIpsecNFAReference) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    objPath = (LPWSTR)AllocPolMem(
        sizeof(WCHAR)*(wcslen(objPathA)+wcslen(pszIpsecNFAReference)+3)
        );
    if(!objPath) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    wcscpy(objPath, objPathA);
    wcscat(objPath, L"\"");
    wcscat(objPath, pszIpsecNFAReference);
    wcscat(objPath, L"\"");
    

    bstrObjPath = SysAllocString(objPath);
    if(!bstrObjPath) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    hr = IWbemServices_GetObject(
        pWbemServices,
        bstrObjPath,
        WBEM_FLAG_RETURN_WBEM_COMPLETE,
        0,
        &pObj,
        0
        );
    SysFreeString(bstrObjPath);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

    pWbemClassObject = pObj;
    
    pIpsecNFAObject = (PIPSEC_NFA_OBJECT)AllocPolMem(
        sizeof(IPSEC_NFA_OBJECT)
        );
    if (!pIpsecNFAObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    pIpsecNFAObject->pszDistinguishedName = AllocPolStr(
        pszIpsecNFAReference //(LPWSTR)var.bstrVal
        );
    if (!pIpsecNFAObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    //
    // Client does not always write the Name for an NFA
    //

    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"ipsecName",
        VT_BSTR,
        (LPBYTE *)&pIpsecNFAObject->pszIpsecName,
        &dwSize
        );
    // BAIL_ON_WIN32_ERROR(dwError); //req

    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"description",
        VT_BSTR,
        (LPBYTE *)&pIpsecNFAObject->pszDescription,
        &dwSize
        );
    // BAIL_ON_WIN32_ERROR(dwError); //req

    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"ipsecID",
        VT_BSTR,
        (LPBYTE *)&pIpsecNFAObject->pszIpsecID,
        &dwSize
        );
    BAIL_ON_WIN32_ERROR(dwError);

    hr = IWbemClassObject_Get(pWbemClassObject,
                                   L"ipsecDataType",
                                   0,
                                   &var,
                                   0,
                                   0);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

    dwIpsecDataType = var.lVal;

    pIpsecNFAObject->dwIpsecDataType = dwIpsecDataType;

    //
    // unmarshall the ipsecData blob
    //

    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"ipsecData",
        VT_ARRAY|VT_UI1,
        &pIpsecNFAObject->pIpsecData,
        &pIpsecNFAObject->dwIpsecDataLen
        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"ipsecOwnersReference",
        VT_ARRAY|VT_BSTR,
        (LPBYTE *)&pIpsecNFAObject->pszIpsecOwnersReference,
        &dwSize
        );
    // BAIL_ON_WIN32_ERROR(dwError); //req

    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"ipsecNegotiationPolicyReference",
        VT_BSTR,
        (LPBYTE *)&pIpsecNFAObject->pszIpsecNegPolReference,
        &dwSize
        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = WMIstoreQueryValue(
        pWbemClassObject,
        L"ipsecFilterReference",
        VT_ARRAY|VT_BSTR,
        (LPBYTE *)&pIpsecNFAObject->pszIpsecFilterReference,
        &dwSize
        );
    // BAIL_ON_WIN32_ERROR(dwError); //req

    hr = IWbemClassObject_Get(pWbemClassObject,
                                   L"whenChanged",
                                   0,
                                   &var,
                                   0,
                                   0);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

    dwWhenChanged = var.lVal;

    pIpsecNFAObject->dwWhenChanged = dwWhenChanged;
    
    if (pIpsecNFAObject->pszIpsecFilterReference && *(pIpsecNFAObject->pszIpsecFilterReference)) {
        pszTempFilterReference = AllocPolStr(
            pIpsecNFAObject->pszIpsecFilterReference
            );
        if (!pszTempFilterReference) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    pszTempNegPolReference = AllocPolStr(
        pIpsecNFAObject->pszIpsecNegPolReference
        );
    if (!pszTempNegPolReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    *ppszFilterReference = pszTempFilterReference;
    *ppszNegPolReference = pszTempNegPolReference;
    *ppIpsecNFAObject = pIpsecNFAObject;
    
 cleanup:

    if(objPath) {
        FreePolStr(objPath);
    }
    
    if(pWbemClassObject)
        IWbemClassObject_Release(pWbemClassObject);
    
    return(dwError);
    
 error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(pIpsecNFAObject);
    }

    if (pszTempFilterReference) {
        FreePolStr(pszTempFilterReference);
    }
    
    if (pszTempNegPolReference) {
        FreePolStr(pszTempNegPolReference);
    }

    *ppIpsecNFAObject = NULL;
    *ppszFilterReference = NULL;
    *ppszNegPolReference = NULL;

    goto cleanup;
}


DWORD
WMIstoreQueryValue(
    IWbemClassObject *pWbemClassObject,
    LPWSTR pszValueName,
    DWORD dwType,
    LPBYTE *ppValueData,
    LPDWORD pdwSize
    )
{
    DWORD dwSize = 0;
    LPWSTR pszValueData = NULL;
    DWORD dwError = 0;
    HRESULT hr = S_OK;
    LPBYTE pBuffer = NULL;
    LPWSTR pszBuf = NULL;
    
    SAFEARRAY *pSafeArray = NULL;
    VARIANT var;
    DWORD i = 0;
    DWORD dw = 0;
    LPWSTR pszTmp = NULL;
    WCHAR pszTemp[MAX_PATH];
    LPWSTR pszString = NULL;
    LPWSTR pMem = NULL;
    LPWSTR *ppszTmp = NULL;
    long lUbound = 0;
    DWORD dwCount = 0;
    LPBYTE pdw = NULL;
    BSTR HUGEP *pbstrTmp = NULL;
    BYTE HUGEP *pbyteTmp = NULL;

    VariantInit(&var);

    if(!pWbemClassObject) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    hr = IWbemClassObject_Get(pWbemClassObject,
                                   pszValueName,
                                   0,
                                   &var,
                                   0,
                                   0);
    if(hr == WBEM_E_NOT_FOUND) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
    
    ////sanity check
    if(dwType != var.vt) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    switch(dwType) {
    case VT_BSTR: 
        pszTmp = var.bstrVal;
        dwSize = wcslen(pszTmp)*sizeof(WCHAR);
        pBuffer = (LPBYTE)AllocPolStr(pszTmp);
        if (!pBuffer) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;
    case (VT_ARRAY|VT_UI1):
        pSafeArray = var.parray;
        if(!pSafeArray) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        hr = SafeArrayGetUBound(
            pSafeArray,
            1,
            &lUbound
            );
        BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
        
        dwSize = lUbound+1;
        if (dwSize == 0) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        pBuffer = (LPBYTE)AllocPolMem(dwSize);
        if (!pBuffer) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        for(i = 0; i < dwSize; i++) {
            hr = SafeArrayGetElement(pSafeArray, (long *)&i, &pBuffer[i]);
            BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
        }
        break;
    case (VT_ARRAY|VT_BSTR):
        pSafeArray = var.parray;
        if(!pSafeArray) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        hr = SafeArrayGetUBound(
            pSafeArray,
            1,
            &lUbound
            );
        BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
        
        dwCount = lUbound+1;
        if (dwCount == 0) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        ppszTmp = (LPWSTR *)AllocPolMem(
            sizeof(LPWSTR)*dwCount
            );
        if (!ppszTmp) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        
        hr = SafeArrayAccessData(
            pSafeArray,
            (void HUGEP**)&pbstrTmp
            );
        BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
        
        for(i = 0; i < dwCount; i++) {
            pszTmp = pbstrTmp[i];
            ppszTmp[i] = AllocPolStr(pszTmp);
            if (!ppszTmp[i]) {
                dwError = ERROR_OUTOFMEMORY;
                BAIL_ON_WIN32_ERROR(dwError);
            }
        }
        SafeArrayUnaccessData(pSafeArray);
        
        //ppszTmp => string array

        for(i = 0; i < dwCount; i++) {
            dwSize += wcslen(ppszTmp[i])+1;
        }
        dwSize++;
        
        pMem = (LPWSTR)AllocPolMem(sizeof(WCHAR)*dwSize);
        if (!pMem) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        //adjust dwSize to byte size
        dwSize *= sizeof(WCHAR);
        
        pszString = pMem;
        
        for(i = 0; i < dwCount; i++) {
            memcpy(pszString, ppszTmp[i], wcslen(ppszTmp[i])*sizeof(WCHAR));
            pszString += wcslen(pszString)+1;
        }
        pBuffer = (LPBYTE)pMem;
        break;
    default:
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;
    }
        
    switch(dwType) {
    case VT_BSTR:
        pszBuf = (LPWSTR)pBuffer;
        if (!pszBuf || !*pszBuf) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;
    default:
        break;
    }
    
    *ppValueData = pBuffer;
    *pdwSize = dwSize;

    VariantClear(&var); 

 cleanup:
    
    if(ppszTmp) {
        FreePolMem(ppszTmp);
    }
    
    return(dwError);
    
 error:
    
    if (pBuffer) {
        FreePolMem(pBuffer);
    }
    
    *ppValueData = NULL;
    *pdwSize = 0;
    
    goto cleanup;
}


HRESULT
ReadPolicyObjectFromDirectoryEx(
    LPWSTR pszMachineName,
    LPWSTR pszPolicyDN,
    BOOL   bDeepRead,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    )
{
    DWORD dwError = 0;
    HLDAP hLdapBindHandle = NULL;
    LPWSTR pszDefaultDirectory = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;


    if (!pszMachineName || !*pszMachineName) {
        dwError = ComputeDefaultDirectory(
            &pszDefaultDirectory
            );
        BAIL_ON_WIN32_ERROR(dwError);
        
        dwError = OpenDirectoryServerHandle(
            pszDefaultDirectory,
            389,
            &hLdapBindHandle
            );
        BAIL_ON_WIN32_ERROR(dwError);
    } else {
        dwError = OpenDirectoryServerHandle(
            pszMachineName,
            389,
            &hLdapBindHandle
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    
    if (bDeepRead) {
        dwError = ReadPolicyObjectFromDirectory(
            hLdapBindHandle,
            pszPolicyDN,
            &pIpsecPolicyObject
            );
        BAIL_ON_WIN32_ERROR(dwError);
    } else {
        dwError = ShallowReadPolicyObjectFromDirectory(
            hLdapBindHandle,
            pszPolicyDN,
            &pIpsecPolicyObject
            );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppIpsecPolicyObject = pIpsecPolicyObject;

 cleanup:
    
    if (pszDefaultDirectory) {
        FreePolStr(pszDefaultDirectory);
    }

    if (hLdapBindHandle) {
        CloseDirectoryServerHandle(hLdapBindHandle);
    }

    return (HRESULT_FROM_WIN32(dwError));

 error:
    
    *ppIpsecPolicyObject = NULL;
    
    goto cleanup;
    
}


HRESULT
WritePolicyObjectDirectoryToWMI(
    IWbemServices *pWbemServices,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    PGPO_INFO pGPOInfo
    )
{
    HRESULT hr = S_OK;
    PIPSEC_POLICY_OBJECT pIpsecWMIPolicyObject = NULL;

    //
    // Create a copy of the directory policy in WMI terms
    //
    hr = CloneDirectoryPolicyObjectEx(
                    pIpsecPolicyObject,
                    &pIpsecWMIPolicyObject
                    );
    BAIL_ON_HRESULT_ERROR(hr);

    //
    // Write the WMI policy
    //

    hr = PersistWMIObject(
        pWbemServices,
        pIpsecWMIPolicyObject,
        pGPOInfo
        );
    BAIL_ON_HRESULT_ERROR(hr);

 cleanup:
    
    if (pIpsecWMIPolicyObject) {
        FreeIpsecPolicyObject(
            pIpsecWMIPolicyObject
            );
    }

    return(hr);
    
 error:
    
    goto cleanup;

}


DWORD
CreateIWbemServices(
    LPWSTR pszIpsecWMINamespace,
    IWbemServices **ppWbemServices
    )
{
    DWORD dwError = 0;
    HRESULT hr = S_OK;
    IWbemLocator *pWbemLocator = NULL;
    LPWSTR pszIpsecWMIPath = NULL;
    BSTR bstrIpsecWMIPath = NULL;


    
    if(!pszIpsecWMINamespace || !*pszIpsecWMINamespace) {
        pszIpsecWMIPath = gpszIpsecWMINamespace;
    } else {
        pszIpsecWMIPath = pszIpsecWMINamespace;
    }
    
    hr = CoCreateInstance(
        &CLSID_WbemLocator,
        NULL,
        CLSCTX_INPROC_SERVER,
        &IID_IWbemLocator,
        &pWbemLocator
        );
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

    bstrIpsecWMIPath = SysAllocString(pszIpsecWMIPath);
    if(!bstrIpsecWMIPath) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    hr = IWbemLocator_ConnectServer(
        pWbemLocator,
        bstrIpsecWMIPath,
        NULL,
        NULL, 
        NULL,
        0,
        NULL,
        NULL,
        ppWbemServices
        );
    SysFreeString(bstrIpsecWMIPath);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
    
    if(pWbemLocator)
        IWbemLocator_Release(pWbemLocator);
    
 error:

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\wmistore.h ===
DWORD
UnMarshallWMIPolicyObject(
    IWbemClassObject *pWbemClassObject,
    PIPSEC_POLICY_OBJECT  * ppIpsecPolicyObject
    );

DWORD
UnMarshallWMIFilterObject(
    IWbemClassObject *pWbemClassObject,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    );

DWORD
UnMarshallWMINegPolObject(
    IWbemClassObject *pWbemClassObject,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObject
    );

DWORD
UnMarshallWMIISAKMPObject(
    IWbemClassObject *pWbemClassObject,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObject
    );

DWORD
UnMarshallWMINFAObject(
    IWbemServices *pWbemServices,
    LPWSTR pszIpsecNFAReference,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject,
    LPWSTR * ppszFilterReference,
    LPWSTR * ppszNegPolReference
    );

DWORD
WMIstoreQueryValue(
    IWbemClassObject *pWbemClassObject,
    LPWSTR pszValueName,
    DWORD dwType,
    LPBYTE *ppValueData,
    LPDWORD pdwSize
    );

HRESULT
ReadPolicyObjectFromDirectoryEx(
    LPWSTR pszMachineName,
    LPWSTR pszPolicyDN,
    BOOL   bDeepRead,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    );

HRESULT
WritePolicyObjectDirectoryToWMI(
    IWbemServices *pWbemServices,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    PGPO_INFO pGPOInfo
);
DWORD
CreateIWbemServices(
    LPWSTR pszIpsecWMINamespace,
    IWbemServices **ppWbemServices
    );

DWORD
Win32FromWmiHresult(
    HRESULT hr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\pastore\utils.c ===
#include "precomp.h"


//
// Taken from windows\wmi\mofcheck\mofcheck.c
//


//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword   (private)
//
//  Synopsis:   scan lpsz for a number of hex digits (at most 8); update lpsz
//              return value in Value; check for chDelim;
//
//  Arguments:  [lpsz]    - the hex string to convert
//              [Value]   - the returned value
//              [cDigits] - count of digits
//
//  Returns:    TRUE for success
//
//--------------------------------------------------------------------------
BOOL HexStringToDword(LPCWSTR lpsz, DWORD * RetValue,
                             int cDigits, WCHAR chDelim)
{
    int Count;
    DWORD Value;

    Value = 0;
    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
            Value = (Value << 4) + *lpsz - '0';
        else if (*lpsz >= 'A' && *lpsz <= 'F')
            Value = (Value << 4) + *lpsz - 'A' + 10;
        else if (*lpsz >= 'a' && *lpsz <= 'f')
            Value = (Value << 4) + *lpsz - 'a' + 10;
        else
            return(FALSE);
    }

    *RetValue = Value;
    
    if (chDelim != 0)
        return *lpsz++ == chDelim;
    else
        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wUUIDFromString    (internal)
//
//  Synopsis:   Parse UUID such as 00000000-0000-0000-0000-000000000000
//
//  Arguments:  [lpsz]  - Supplies the UUID string to convert
//              [pguid] - Returns the GUID.
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wUUIDFromString(LPCWSTR lpsz, LPGUID pguid)
{
        DWORD dw;

        if (!HexStringToDword(lpsz, &pguid->Data1, sizeof(DWORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(DWORD)*2 + 1;
        
        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data2 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(WORD)*2, '-'))
                return FALSE;
        lpsz += sizeof(WORD)*2 + 1;

        pguid->Data3 = (WORD)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[0] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, '-'))
                return FALSE;
        lpsz += sizeof(BYTE)*2+1;

        pguid->Data4[1] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[2] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[3] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[4] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[5] = (BYTE)dw;

        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[6] = (BYTE)dw;
        if (!HexStringToDword(lpsz, &dw, sizeof(BYTE)*2, 0))
                return FALSE;
        lpsz += sizeof(BYTE)*2;

        pguid->Data4[7] = (BYTE)dw;

        return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   wGUIDFromString    (internal)
//
//  Synopsis:   Parse GUID such as {00000000-0000-0000-0000-000000000000}
//
//  Arguments:  [lpsz]  - the guid string to convert
//              [pguid] - guid to return
//
//  Returns:    TRUE if successful
//
//--------------------------------------------------------------------------
BOOL wGUIDFromString(LPCWSTR lpsz, LPGUID pguid)
{
    DWORD dw;

    if (*lpsz == '{' )
        lpsz++;

    if(wUUIDFromString(lpsz, pguid) != TRUE)
        return FALSE;

    lpsz +=36;

    if (*lpsz == '}' )
        lpsz++;

    if (*lpsz != '\0')   // check for zero terminated string - test bug #18307
    {
       return FALSE;
    }

    return TRUE;
}


DWORD
EnablePrivilege(
    LPCTSTR pszPrivilege
    )
{
    DWORD dwError = 0;
    BOOL bStatus = FALSE;
    HANDLE hTokenHandle = NULL;
    TOKEN_PRIVILEGES NewState;
    TOKEN_PRIVILEGES PreviousState;
    DWORD dwReturnLength = 0;


    bStatus = OpenThreadToken(
                  GetCurrentThread(),
                  TOKEN_ALL_ACCESS,
                  TRUE,
                  &hTokenHandle
                  );
    if (!bStatus) {
        bStatus = OpenProcessToken(
                      GetCurrentProcess(),
                      TOKEN_ALL_ACCESS,
                      &hTokenHandle
                      );
        if (!bStatus) {
            dwError = GetLastError();
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    NewState.PrivilegeCount = 1;
    NewState.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    bStatus = LookupPrivilegeValue(
                  NULL,
                  pszPrivilege,
                  &NewState.Privileges[0].Luid
                  );
    if (!bStatus) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    bStatus = AdjustTokenPrivileges(
                  hTokenHandle,
                  FALSE,
                  &NewState,
                  sizeof(PreviousState),
                  &PreviousState,
                  &dwReturnLength
                  );
    if (!bStatus) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (hTokenHandle) {
        CloseHandle(hTokenHandle);
    }

    return (dwError);
}


BOOL 
IsStringInArray(
    LPWSTR * ppszStrings,
    LPWSTR pszKey,
    DWORD dwNumStrings
    )
{
    DWORD j = 0;
   
    for (j = 0; j < dwNumStrings; j++) {
        if (!_wcsicmp(*(ppszStrings+j), pszKey)) {
            return TRUE;
        }
    }

    return FALSE;
}                

// Description:
//
//      Pastore function that uses above time routine to convert
//      from LDAP UTC Generalized time coding to time_t
//      Generalized time syntax has the form
//          YYYYMMDDHHMMSS[.|,fraction][(+|-HHMM)|Z]
//          Z means UTC.
//
//
// Arguments:
//
//      pszGenTime: UTC time in generalized time format as above.
//      ptTime:     Converted time in time_t format.
//
// Assumptions:
//      Always assume UTC and never expect or check (+|-HHMM) 
//      since DC time returned is in UTC.
//
// Return value:
//      WIN32 error or ERROR_SUCCESS

DWORD
GeneralizedTimeToTime(
    IN LPWSTR pszGenTime,
    OUT time_t * ptTime
    )
{

    DWORD dwError = ERROR_SUCCESS;
    DWORD dwLen = 0;
    DWORD dwNumFields = 0;
    DWORD dwTrueYear = 0;
    struct tm tmTimeStruct;
    time_t tTime = 0;

    dwLen = wcslen(pszGenTime);
    if (dwLen < MIN_GEN_UTC_LEN || 
        !( pszGenTime[MIN_GEN_UTC_LEN-1] == L'.' ||
           pszGenTime[MIN_GEN_UTC_LEN-1] == L','))
    {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    // First convert to tm struct format
    //
    
    memset(&tmTimeStruct, 0, sizeof(struct tm));
    dwNumFields = _snwscanf(
                        pszGenTime, MIN_GEN_UTC_LEN, L"%04d%02d%02d%02d%02d%02d",
    	                &dwTrueYear, &tmTimeStruct.tm_mon, &tmTimeStruct.tm_mday,
    	                &tmTimeStruct.tm_hour, &tmTimeStruct.tm_min, &tmTimeStruct.tm_sec
	                );
    if (dwNumFields != 6 || dwTrueYear < 1900) 
    {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    tmTimeStruct.tm_year = dwTrueYear - 1900;

    // Month is zero-based so...
    //
    if (tmTimeStruct.tm_mon <= 0)
    {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }    
    tmTimeStruct.tm_mon--;
    
    // Now convert to time_t
    //
    
    tTime = _mkgmtime(&tmTimeStruct);
    if (tTime == (time_t) -1) 
    {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ptTime = tTime;

    return dwError;
error:    
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\connui.h ===
DWORD
IPSecIsLocalPolicyAssigned(
    PBOOL pbIsLocalPolicyAssigned
    );


DWORD
IPSecGetAssignedDomainPolicyName(
    LPWSTR * ppszAssignedDomainPolicyName
    );

DWORD
RegGetAssignedPolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\dllsvr.h ===
DWORD
DllRegisterServer(
    );

DWORD
DllUnregisterServer(
    );

BOOL
IsCleanInstall(
    );

BOOL
LocalIpsecInfoExists(
    HKEY hSourceParentKey,
    LPWSTR pszSourceKey
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\export.h ===
DWORD
ExportPoliciesToFile(
    HANDLE hSrcPolicyStore,
    HANDLE hDesPolicyStore
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\filters-f.c ===
#include "precomp.h"


DWORD
ExportFilterDataToFile(
    HANDLE hSrcPolicyStore,
    PIPSEC_POLICY_STORE pDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_DATA * ppIpsecFilterData = NULL;
    DWORD dwNumFilterObjects = 0;
    DWORD i = 0;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;


    dwError = IPSecEnumFilterData(
                  hSrcPolicyStore,
                  &ppIpsecFilterData,
                  &dwNumFilterObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    for (i = 0; i < dwNumFilterObjects; i++) {

        pIpsecFilterData = *(ppIpsecFilterData + i);

        dwError = RegCreateFilterData(
                      pDesPolicyStore->hRegistryKey,
                      pDesPolicyStore->pszIpsecRootContainer,
                      pIpsecFilterData
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (ppIpsecFilterData) {
        FreeMulIpsecFilterData(
            ppIpsecFilterData,
            dwNumFilterObjects
            );
    }

    return (dwError);
}


DWORD
ImportFilterDataFromFile(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_DATA * ppIpsecFilterData = NULL;
    DWORD dwNumFilterObjects = 0;
    DWORD i = 0;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;


    dwError = RegEnumFilterData(
                  pSrcPolicyStore->hRegistryKey,
                  pSrcPolicyStore->pszIpsecRootContainer,
                  &ppIpsecFilterData,
                  &dwNumFilterObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    for (i = 0; i < dwNumFilterObjects; i++) {

        pIpsecFilterData = *(ppIpsecFilterData + i);

        dwError = IPSecCreateFilterData(
                      hDesPolicyStore,
                      pIpsecFilterData
                      );
        if (dwError == ERROR_OBJECT_ALREADY_EXISTS) {
            dwError = IPSecSetFilterData(
                          hDesPolicyStore,
                          pIpsecFilterData
                          );
            BAIL_ON_WIN32_ERROR(dwError);
        }
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (ppIpsecFilterData) {
        FreeMulIpsecFilterData(
            ppIpsecFilterData,
            dwNumFilterObjects
            );
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\dllsvr.c ===
#include "precomp.h"

#define COUNTOF(x) (sizeof x/sizeof *x)
DWORD SetRegAcl(
    LPWSTR pszRegKey,
    DWORD dwAclFlags
    )
{
    DWORD dwError = 0;
    BOOL fSuccess = TRUE;
    HKEY hKey = NULL;
    PSECURITY_DESCRIPTOR pNewSecurityDescriptor = NULL;
    PACL pDacl = NULL;
    BOOL bDaclDefaulted = TRUE;
    BOOL bDaclPresent = TRUE;
    
    dwError = NsuAclDescriptorCreate(
                    &pNewSecurityDescriptor,
                    dwAclFlags
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    // Note that RegCreateKeyExW below will just open the key if it already exists
    //
    
    dwError = RegCreateKeyExW(
                  HKEY_LOCAL_MACHINE,   // handle to open key
                  pszRegKey,            // subkey name
                  0,                    // reserved
                  NULL,                 // class string
                  0,                    // special options
                  KEY_ALL_ACCESS,       // desired security access
                  NULL,                 // inheritance
                  &hKey,                // key handle 
                  NULL                  // disposition value buffer
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    fSuccess = GetSecurityDescriptorDacl(
                  pNewSecurityDescriptor, 
                  &bDaclPresent, 
                  &pDacl, 
                  &bDaclDefaulted
                );
    if (!fSuccess)
    {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    } else if (!pDacl) {
        // This shouldn't happen because we created the SD ourselves.
        // however, just to make sure we don't set NULL DACL by error.
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    dwError =  SetSecurityInfo(
                    hKey,
                    SE_REGISTRY_KEY,
                    DACL_SECURITY_INFORMATION |PROTECTED_DACL_SECURITY_INFORMATION,
                    NULL,
                    NULL,
                    pDacl, 
                    NULL
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    
error:
    if (hKey) {
        RegCloseKey(hKey);    
    }        
    
    if (pNewSecurityDescriptor) {
        (VOID) NsuAclDescriptorDestroy(&pNewSecurityDescriptor);
        // (VOID because don't want to ovewrite dwError)
    }
    
    return dwError;
}

DWORD SetDriverBootExemptList()
{
    DWORD dwError = 0;
    HKEY hKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    
    /* 
       Boot exempt list for DHCP
       ULONG Type; ULONG Size; 
       BYTE Protocol; BYTE Direction; USHORT SrcPort; USHORT DestPort; USHORT Reserved;
       See driver spec for "Boot time security" for more information
    */
    BYTE BootExemptList[] = {
                             0x01,0x00,0x00,0x00,0x10,0x00,0x00,0x00,
                             0x11,0x01,0x00,0x00,0x44,0x00,0x00,0x00
                            };
                            
    dwError = RegOpenKeyW(
                  HKEY_LOCAL_MACHINE,
                  REG_KEY_IPSEC_DRIVER_SERVICE,
                  &hKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

   
    dwSize = 0;  
    dwError = RegQueryValueExW(
                  hKey,
                  REG_VAL_IPSEC_BOOTEXEMPTLIST,
                  0,        // lpReserved
                  NULL,     // lpType
                  NULL,     // lpData
                  &dwSize   // lpcbData
                  );

    // If key does not exist
    //
    if (!(dwError == ERROR_SUCCESS || dwError == ERROR_MORE_DATA)) {
        dwError = ERROR_SUCCESS;

        dwError = RegSetValueExW(
                   hKey,
                   REG_VAL_IPSEC_BOOTEXEMPTLIST,
                   0,
                   REG_BINARY,
                   (LPBYTE) BootExemptList,
                   sizeof(BootExemptList)
                   );
        BAIL_ON_WIN32_ERROR(dwError);
    } else {
        dwError = ERROR_SUCCESS;
    }
    

error:
    if (hKey) {
        RegCloseKey(hKey);
    }

    return (dwError);
}


DWORD
DllRegisterServer(
    )
{
    DWORD dwError = 0;
    HKEY hRegistryKey = NULL;
    HKEY hOakleyKey = NULL;
    DWORD dwDisposition = 0;
    DWORD dwTypesSupported = 7;
    HKEY hPersistentPolicyLocationKey = NULL;
    HKEY hPolicyLocationKey = NULL;
    HANDLE hPolicyStore = NULL;
    BOOL bAnyPolicyAssigned = FALSE;

    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  (LPCWSTR) L"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application",
                  0,
                  KEY_ALL_ACCESS,
                  &hRegistryKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegCreateKeyExW(
                  hRegistryKey,
                  L"Oakley",
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hOakleyKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                   hOakleyKey,
                   L"EventMessageFile",
                   0,
                   REG_SZ,
                   (LPBYTE) L"%SystemRoot%\\System32\\oakley.dll",
                   (wcslen(L"%SystemRoot%\\System32\\oakley.dll") + 1)*sizeof(WCHAR)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                   hOakleyKey,
                   L"TypesSupported",
                   0,
                   REG_DWORD,
                   (LPBYTE) &dwTypesSupported,
                   sizeof(DWORD)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegCreateKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszRegPersistentContainer,
                  0,
                  NULL,
                  0,
                  KEY_ALL_ACCESS,
                  NULL,
                  &hPersistentPolicyLocationKey,
                  &dwDisposition
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (IsCleanInstall()) {

        dwError = RegCreateKeyExW(
                      HKEY_LOCAL_MACHINE,
                      gpszRegLocalContainer,
                      0,
                      NULL,
                      0,
                      KEY_ALL_ACCESS,
                      NULL,
                      &hPolicyLocationKey,
                      &dwDisposition
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = IPSecOpenPolicyStore(
                      NULL,
                      IPSEC_REGISTRY_PROVIDER,
                      NULL,
                      &hPolicyStore
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = GenerateDefaultInformation(
                      hPolicyStore
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } 

    dwError = SetDriverBootExemptList();
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = SetRegAcl(
                L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec",
                POLSTORE_POLICY_PERMISSIONS
                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SetRegAcl(
        L"SOFTWARE\\Microsoft\\IPSec",
        POLSTORE_POLICY_PERMISSIONS
        );
    BAIL_ON_WIN32_ERROR(dwError);

    // Set driver boot mode
    //
    
    dwError = IsAnyPolicyAssigned(
        HKEY_LOCAL_MACHINE,
        &bAnyPolicyAssigned
        );
    BAIL_ON_WIN32_ERROR(dwError);
    if (bAnyPolicyAssigned) {
        dwError = IPSecSetDriverOperationMode(
            HKEY_LOCAL_MACHINE,
            REG_IPSEC_DRIVER_STATEFULMODE
            );        
        BAIL_ON_WIN32_ERROR(dwError);
    }    
    

    WinExec("lodctr.exe ipsecprf.ini", SW_HIDE);

error:

    if (hPolicyStore) {
        (VOID) IPSecClosePolicyStore(
                   hPolicyStore
                   );
    }

    if (hPolicyLocationKey) {
        RegCloseKey(hPolicyLocationKey);
    }

    if (hPersistentPolicyLocationKey) {
        RegCloseKey(hPersistentPolicyLocationKey);
    }

    if (hOakleyKey) {
        RegCloseKey(hOakleyKey);
    }

    if (hRegistryKey) {
        RegCloseKey(hRegistryKey);
    }
  
    return (dwError);                
}


DWORD
DllUnregisterServer(
    )
{
    return (ERROR_SUCCESS);
}


BOOL
IsCleanInstall(
    )
{
    BOOL bStatus = FALSE;

    bStatus = LocalIpsecInfoExists(
                  HKEY_LOCAL_MACHINE,
                  L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Local"
                  );

    return (!bStatus);
}


BOOL
LocalIpsecInfoExists(
    HKEY hSourceParentKey,
    LPWSTR pszSourceKey
    )
{
    DWORD dwError = 0;
    HKEY hSourceKey = NULL;
    BOOL bStatus = FALSE;
    WCHAR lpszName[MAX_PATH];
    DWORD dwSize = 0;
    DWORD dwCount = 0;


    dwError = RegOpenKeyExW(
                  hSourceParentKey,
                  pszSourceKey,
                  0,
                  KEY_ALL_ACCESS,
                  &hSourceKey
                  );
    if (dwError != ERROR_SUCCESS) {
        return (bStatus);
    }

    memset(lpszName, 0, sizeof(WCHAR)*MAX_PATH);
    dwSize = COUNTOF(lpszName);

    if ((RegEnumKeyExW(
            hSourceKey,
            dwCount,
            lpszName,
            &dwSize,
            NULL,
            NULL,
            NULL,
            NULL)) == ERROR_SUCCESS) {
        bStatus = TRUE;
    }
    else {
        bStatus = FALSE;
    }

    RegCloseKey(hSourceKey);
    return (bStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\filters-f.h ===
DWORD
ExportFilterDataToFile(
    HANDLE hSrcPolicyStore,
    PIPSEC_POLICY_STORE pDesPolicyStore
    );

DWORD
ImportFilterDataFromFile(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\export.c ===
#include "precomp.h"


DWORD
ExportPoliciesToFile(
    HANDLE hSrcPolicyStore,
    HANDLE hDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pDesPolicyStore = NULL;
    PIPSEC_POLICY_DATA * ppIpsecPolicyData = NULL;
    DWORD dwNumPolicyObjects = 0;


    pDesPolicyStore = (PIPSEC_POLICY_STORE) hDesPolicyStore;


    dwError = ExportFilterDataToFile(
                  hSrcPolicyStore,
                  pDesPolicyStore
                  );

    dwError = ExportNegPolDataToFile(
                  hSrcPolicyStore,
                  pDesPolicyStore
                  );

    dwError = ExportISAKMPDataToFile(
                  hSrcPolicyStore,
                  pDesPolicyStore
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ExportPolicyDataToFile(
                  hSrcPolicyStore,
                  pDesPolicyStore,
                  &ppIpsecPolicyData,
                  &dwNumPolicyObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ExportNFADataToFile(
                  hSrcPolicyStore,
                  pDesPolicyStore,
                  ppIpsecPolicyData,
                  dwNumPolicyObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = EnablePrivilege(
                  SE_BACKUP_NAME
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    _wremove(pDesPolicyStore->pszFileName);

    dwError = RegSaveKeyW(
                  pDesPolicyStore->hRegistryKey,
                  pDesPolicyStore->pszFileName,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppIpsecPolicyData) {
        FreeMulIpsecPolicyData(
            ppIpsecPolicyData,
            dwNumPolicyObjects
            );
    }

    FlushRegSaveKey(
        pDesPolicyStore->hRegistryKey
        );

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\filters-d.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       filters-d.c
//
//  Contents:   Filter Management for directory.
//
//
//  History:    KrishnaG
//              AbhisheV
//
//----------------------------------------------------------------------------

#include "precomp.h"

extern LPWSTR FilterDNAttributes[];


DWORD
DirEnumFilterData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_DATA ** pppIpsecFilterData,
    PDWORD pdwNumFilterObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    PIPSEC_FILTER_DATA * ppIpsecFilterData = NULL;
    DWORD dwNumFilterObjects = 0;
    DWORD i = 0;
    DWORD j = 0;


    dwError = DirEnumFilterObjects(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    &ppIpsecFilterObjects,
                    &dwNumFilterObjects
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumFilterObjects) {
        ppIpsecFilterData = (PIPSEC_FILTER_DATA *) AllocPolMem(
                            dwNumFilterObjects*sizeof(PIPSEC_FILTER_DATA)
                            );
        if (!ppIpsecFilterData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumFilterObjects; i++) {

        dwError = DirUnmarshallFilterData(
                        *(ppIpsecFilterObjects + i),
                        &pIpsecFilterData
                        );
        if (!dwError) {
            *(ppIpsecFilterData + j) = pIpsecFilterData;
            j++;
        }
    }

    if (j == 0) {
        if (ppIpsecFilterData) {
            FreePolMem(ppIpsecFilterData);
            ppIpsecFilterData = NULL;
        }
    }

    *pppIpsecFilterData = ppIpsecFilterData;
    *pdwNumFilterObjects = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecFilterObjects) {
        FreeIpsecFilterObjects(
            ppIpsecFilterObjects,
            dwNumFilterObjects
            );
    }

    return(dwError);

error:

    if (ppIpsecFilterData) {
        FreeMulIpsecFilterData(
                ppIpsecFilterData,
                i
                );
    }

    *pppIpsecFilterData = NULL;
    *pdwNumFilterObjects = 0;

    goto cleanup;
}


DWORD
DirEnumFilterObjects(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT ** pppIpsecFilterObjects,
    PDWORD pdwNumFilterObjects
    )
{
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    DWORD dwError = 0;
    LPWSTR pszFilterString = NULL;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject =  NULL;
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects = NULL;

    DWORD dwNumFilterObjectsReturned = 0;

    dwError = GenerateAllFiltersQuery(
                    &pszFilterString
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszFilterString,
                  FilterDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                    hLdapBindHandle,
                    res
                    );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppIpsecFilterObjects  = (PIPSEC_FILTER_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_FILTER_OBJECT)*dwCount
                                            );
    if (!ppIpsecFilterObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwCount; i++) {

        if (i == 0) {

            dwError = LdapFirstEntry(
                            hLdapBindHandle,
                            res,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        } else {

            dwError = LdapNextEntry(
                            hLdapBindHandle,
                            e,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        }

        dwError = UnMarshallFilterObject(
                      hLdapBindHandle,
                      e,
                      &pIpsecFilterObject
                      );

        if (dwError == ERROR_SUCCESS) {
            *(ppIpsecFilterObjects + dwNumFilterObjectsReturned) = pIpsecFilterObject;
            dwNumFilterObjectsReturned++;
        }

    }

    *pppIpsecFilterObjects = ppIpsecFilterObjects;
    *pdwNumFilterObjects = dwNumFilterObjectsReturned;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszFilterString) {
        FreePolMem(pszFilterString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    return(dwError);

error:

    if (ppIpsecFilterObjects) {
        FreeIpsecFilterObjects(
            ppIpsecFilterObjects,
            dwNumFilterObjectsReturned
            );
    }

    *pppIpsecFilterObjects = NULL;
    *pdwNumFilterObjects = 0;

    goto cleanup;
}


DWORD
DirSetFilterData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_DATA pIpsecFilterData
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;

    dwError = DirMarshallFilterObject(
                    pIpsecFilterData,
                    pszIpsecRootContainer,
                    &pIpsecFilterObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirSetFilterObject(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    pIpsecFilterObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirBackPropIncChangesForFilterToNFA(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pIpsecFilterData->FilterIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(pIpsecFilterObject);
    }

    return(dwError);
}


DWORD
DirSetFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;

    dwError = DirMarshallSetFilterObject(
                        hLdapBindHandle,
                        pszIpsecRootContainer,
                        pIpsecFilterObject,
                        &ppLDAPModW
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pIpsecFilterObject->pszDistinguishedName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    //
    // Free the amods structures.
    //

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }


    return(dwError);
}


DWORD
DirCreateFilterData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_DATA pIpsecFilterData
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;

    dwError = DirMarshallFilterObject(
                        pIpsecFilterData,
                        pszIpsecRootContainer,
                        &pIpsecFilterObject
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirCreateFilterObject(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    pIpsecFilterObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(
            pIpsecFilterObject
            );
    }

    return(dwError);
}


DWORD
DirCreateFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;


    dwError = DirMarshallAddFilterObject(
                        hLdapBindHandle,
                        pszIpsecRootContainer,
                        pIpsecFilterObject,
                        &ppLDAPModW
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapAddS(
                    hLdapBindHandle,
                    pIpsecFilterObject->pszDistinguishedName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    //
    // Free the amods structures.
    //

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirDeleteFilterData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';

    dwError = UuidToString(
                  &FilterIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szDistinguishedName,L"CN=ipsecFilter");
    wcscat(szDistinguishedName, szGuid);
    wcscat(szDistinguishedName, L",");
    SecStrCatW(szDistinguishedName, pszIpsecRootContainer, MAX_PATH);

    dwError = LdapDeleteS(
                  hLdapBindHandle,
                  szDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);
}


DWORD
DirMarshallAddFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    LDAPModW *** pppLDAPModW
    )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 6;
    DWORD dwError = 0;
    WCHAR Buffer[64];


    if (!pIpsecFilterObject->pszIpsecName ||
        !*pIpsecFilterObject->pszIpsecName) {
        dwNumAttributes--;
    }

    if (!pIpsecFilterObject->pszDescription ||
        !*pIpsecFilterObject->pszDescription) {
        dwNumAttributes--;
    }

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // 0. objectClass
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"objectClass",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    L"ipsecFilter",
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 1. ipsecName
    //

    if (pIpsecFilterObject->pszIpsecName &&
        *pIpsecFilterObject->pszIpsecName) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"ipsecName",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecFilterObject->pszIpsecName,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 2. ipsecID
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecID",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecFilterObject->pszIpsecID,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 3. ipsecDataType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecDataType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( pIpsecFilterObject->dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                    Buffer,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 4. ipsecData
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecData",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPBinaryValue(
                    pIpsecFilterObject->pIpsecData,
                    pIpsecFilterObject->dwIpsecDataLen,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;

    i++;

    //
    // 5. description
    //

    if (pIpsecFilterObject->pszDescription &&
        *pIpsecFilterObject->pszDescription) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"description",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecFilterObject->pszDescription,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    *pppLDAPModW = ppLDAPModW;

    return(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    *pppLDAPModW = NULL;

    return(dwError);
}


DWORD
DirMarshallSetFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    LDAPModW *** pppLDAPModW
    )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 5;
    DWORD dwError = 0;
    WCHAR Buffer[64];


    if (!pIpsecFilterObject->pszIpsecName ||
        !*pIpsecFilterObject->pszIpsecName) {
        dwNumAttributes--;
    }

    if (!pIpsecFilterObject->pszDescription ||
        !*pIpsecFilterObject->pszDescription) {
        dwNumAttributes--;
    }

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // 1. ipsecName
    //

    if (pIpsecFilterObject->pszIpsecName &&
        *pIpsecFilterObject->pszIpsecName) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"ipsecName",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecFilterObject->pszIpsecName,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 2. ipsecID
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecID",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecFilterObject->pszIpsecID,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 3. ipsecDataType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecDataType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( pIpsecFilterObject->dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                    Buffer,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 4. ipsecData
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecData",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPBinaryValue(
                    pIpsecFilterObject->pIpsecData,
                    pIpsecFilterObject->dwIpsecDataLen,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;

    i++;

    //
    // 5. description
    //

    if (pIpsecFilterObject->pszDescription &&
        *pIpsecFilterObject->pszDescription) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"description",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecFilterObject->pszDescription,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    *pppLDAPModW = ppLDAPModW;

    return(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    *pppLDAPModW = NULL;

    return(dwError);
}


DWORD
GenerateAllFiltersQuery(
    LPWSTR * ppszFilterString
    )
{
    DWORD dwError = 0;
    DWORD dwLength = 0;
    LPWSTR pszFilterString = NULL;


    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(objectclass=ipsecFilter)");

    pszFilterString = (LPWSTR) AllocPolMem((dwLength + 1)*sizeof(WCHAR));

    if (!pszFilterString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Now fill in the buffer
    //

    wcscpy(pszFilterString, L"(objectclass=ipsecFilter)");

    *ppszFilterString = pszFilterString;

    return(0);

error:

    if (pszFilterString) {
        FreePolMem(pszFilterString);
    }

    *ppszFilterString = NULL;

    return(dwError);
}


DWORD
DirUnmarshallFilterData(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallFilterObject(
                  pIpsecFilterObject,
                  ppIpsecFilterData
                  );

    return(dwError);
}


DWORD
DirMarshallFilterObject(
    PIPSEC_FILTER_DATA pIpsecFilterData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';
    pIpsecFilterObject = (PIPSEC_FILTER_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_FILTER_OBJECT)
                                                    );
    if (!pIpsecFilterObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecFilterData->FilterIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    //
    // Fill in the distinguishedName
    //

    wcscpy(szDistinguishedName,L"CN=ipsecFilter");
    wcscat(szDistinguishedName, szGuid);
    wcscat(szDistinguishedName, L",");
    SecStrCatW(szDistinguishedName, pszIpsecRootContainer, MAX_PATH);

    pIpsecFilterObject->pszDistinguishedName = AllocPolStr(
                                                    szDistinguishedName
                                                    );
    if (!pIpsecFilterObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Fill in the ipsecName
    //

    if (pIpsecFilterData->pszIpsecName &&
        *pIpsecFilterData->pszIpsecName) {
        pIpsecFilterObject->pszIpsecName = AllocPolStr(
                                            pIpsecFilterData->pszIpsecName
                                            );
        if (!pIpsecFilterObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecFilterData->pszDescription &&
        *pIpsecFilterData->pszDescription) {
        pIpsecFilterObject->pszDescription = AllocPolStr(
                                             pIpsecFilterData->pszDescription
                                             );
        if (!pIpsecFilterObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //
    // Fill in the ipsecID
    //

    pIpsecFilterObject->pszIpsecID = AllocPolStr(
                                            szGuid
                                            );
    if (!pIpsecFilterObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Fill in the ipsecDataType
    //

    pIpsecFilterObject->dwIpsecDataType = 0x100;


    //
    // Marshall the pIpsecDataBuffer and the Length
    //

    dwError = MarshallFilterBuffer(
                    pIpsecFilterData,
                    &pBuffer,
                    &dwBufferLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecFilterObject->pIpsecData  = pBuffer;

    pIpsecFilterObject->dwIpsecDataLen = dwBufferLen;

    pIpsecFilterObject->dwWhenChanged = 0;

    *ppIpsecFilterObject = pIpsecFilterObject;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }

    return(dwError);

error:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(
            pIpsecFilterObject
            );
    }

    *ppIpsecFilterObject = NULL;
    goto cleanup;
}


DWORD
DirGetFilterData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID FilterGUID,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;


    dwError = DirGetFilterObject(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  FilterGUID,
                  &pIpsecFilterObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirUnmarshallFilterData(
                  pIpsecFilterObject,
                  &pIpsecFilterData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecFilterData = pIpsecFilterData;

cleanup:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(
            pIpsecFilterObject
            );
    }

    return(dwError);

error:

    *ppIpsecFilterData = NULL;

    goto cleanup;
}


DWORD
DirGetFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID FilterGUID,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    )
{
    DWORD dwError = 0;
    LPWSTR pszFilterString = NULL;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;
    LDAPMessage * e = NULL;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject =  NULL;


    dwError = GenerateSpecificFilterQuery(
                  FilterGUID,
                  &pszFilterString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszFilterString,
                  FilterDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallFilterObject(
                  hLdapBindHandle,
                  e,
                  &pIpsecFilterObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecFilterObject = pIpsecFilterObject;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszFilterString) {
        FreePolMem(pszFilterString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    return(dwError);

error:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(
            pIpsecFilterObject
            );
    }

    *ppIpsecFilterObject = NULL;

    goto cleanup;
}


DWORD
GenerateSpecificFilterQuery(
    GUID FilterIdentifier,
    LPWSTR * ppszFilterString
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;
    DWORD dwLength = 0;
    LPWSTR pszFilterString = NULL;


    szGuid[0] = L'\0';
    szCommonName[0] = L'\0';

    dwError = UuidToString(
                  &FilterIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szCommonName, L"cn=ipsecFilter");
    wcscat(szCommonName, szGuid);

    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(&(objectclass=ipsecFilter)");
    dwLength += wcslen(L"(");
    dwLength += wcslen(szCommonName);
    dwLength += wcslen(L"))");

    pszFilterString = (LPWSTR) AllocPolMem((dwLength + 1)*sizeof(WCHAR));

    if (!pszFilterString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    wcscpy(pszFilterString, L"(&(objectclass=ipsecFilter)");
    wcscat(pszFilterString, L"(");
    wcscat(pszFilterString, szCommonName);
    wcscat(pszFilterString, L"))");

    *ppszFilterString = pszFilterString;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    if (pszFilterString) {
        FreePolMem(pszFilterString);
    }

    *ppszFilterString = NULL;

    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\filters-d.h ===
DWORD
DirEnumFilterData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_DATA ** pppIpsecFilterData,
    PDWORD pdwNumFilterObjects
    );

DWORD
DirEnumFilterObjects(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT ** pppIpsecFilterObjects,
    PDWORD pdwNumFilterObjects
    );

DWORD
GenerateAllFiltersQuery(
    LPWSTR * ppszFilterString
    );

DWORD
DirSetFilterData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_DATA pIpsecFilterData
    );

DWORD
DirSetFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    );

DWORD
DirCreateFilterData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_DATA pIpsecFilterData
    );

DWORD
DirCreateFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    );

DWORD
DirDeleteFilterData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier
    );

DWORD
DirMarshallAddFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    LDAPModW *** pppLDAPModW
    );


DWORD
DirMarshallSetFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    LDAPModW *** pppLDAPModW
    );

DWORD
AllocateLDAPStringValue(
    LPWSTR pszString,
    PLDAPOBJECT * ppLdapObject
    );

DWORD
AllocateLDAPBinaryValue(
    LPBYTE pByte,
    DWORD dwNumBytes,
    PLDAPOBJECT * ppLdapObject
    );

void
FreeLDAPModWs(
    LDAPModW ** ppLDAPModW
    );

DWORD
DirUnmarshallFilterData(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    );

DWORD
DirMarshallFilterObject(
    PIPSEC_FILTER_DATA pIpsecFilterData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    );

DWORD
DirGetFilterData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID FilterGUID,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    );

DWORD
DirGetFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID FilterGUID,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    );

DWORD
GenerateSpecificFilterQuery(
    GUID FilterIdentifier,
    LPWSTR * ppszFilterString
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\filters-r.h ===
DWORD
RegEnumFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_DATA ** pppIpsecFilterData,
    PDWORD pdwNumFilterObjects
    );

DWORD
RegEnumFilterObjects(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT ** pppIpsecFilterObjects,
    PDWORD pdwNumFilterObjects
    );

DWORD
RegSetFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_FILTER_DATA pIpsecFilterData
    );

DWORD
RegSetFilterObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    );

DWORD
RegCreateFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_DATA pIpsecFilterData
    );

DWORD
RegCreateFilterObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    );

DWORD
RegDeleteFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier
    );

DWORD
RegUnmarshallFilterData(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    );

DWORD
RegMarshallFilterObject(
    PIPSEC_FILTER_DATA pIpsecFilterData,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    );

DWORD
MarshallFilterBuffer(
    PIPSEC_FILTER_DATA pIpsecFilterData,
    LPBYTE * ppBuffer,
    DWORD * pdwBufferLen
    );

DWORD
MarshallFilterSpecBuffer(
    PIPSEC_FILTER_SPEC pIpsecFilterSpec,
    LPBYTE * ppMem,
    DWORD * pdwSize
    );

DWORD
RegGetFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID FilterGUID,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    );

VOID
FreeSpecBuffer(
    PSPEC_BUFFER pSpecBuffer,
    DWORD dwNumFilterSpecs
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\filters-r.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       filters-r.c
//
//  Contents:   Filter management for registry.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//
//----------------------------------------------------------------------------

#include "precomp.h"

extern LPWSTR FilterDNAttributes[];


DWORD
RegEnumFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_DATA ** pppIpsecFilterData,
    PDWORD pdwNumFilterObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    PIPSEC_FILTER_DATA * ppIpsecFilterData = NULL;
    DWORD dwNumFilterObjects = 0;
    DWORD i = 0;
    DWORD j = 0;


    dwError = RegEnumFilterObjects(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    &ppIpsecFilterObjects,
                    &dwNumFilterObjects
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumFilterObjects) {
        ppIpsecFilterData = (PIPSEC_FILTER_DATA *) AllocPolMem(
                            dwNumFilterObjects*sizeof(PIPSEC_FILTER_DATA)
                            );
        if (!ppIpsecFilterData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumFilterObjects; i++) {

        dwError = RegUnmarshallFilterData(
                        *(ppIpsecFilterObjects + i),
                        &pIpsecFilterData
                        );
        if (!dwError) {
            *(ppIpsecFilterData + j) = pIpsecFilterData;
            j++;
        }
    }

    if (j == 0) {
        if (ppIpsecFilterData) {
            FreePolMem(ppIpsecFilterData);
            ppIpsecFilterData = NULL;
        }
    }

    *pppIpsecFilterData = ppIpsecFilterData;
    *pdwNumFilterObjects = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecFilterObjects) {
        FreeIpsecFilterObjects(
                ppIpsecFilterObjects,
                dwNumFilterObjects
                );
    }



    return(dwError);

error:

    if (ppIpsecFilterData) {
        FreeMulIpsecFilterData(
                ppIpsecFilterData,
                i
                );
    }

    *pppIpsecFilterData = NULL;
    *pdwNumFilterObjects = 0;

    goto cleanup;

}

DWORD
RegEnumFilterObjects(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT ** pppIpsecFilterObjects,
    PDWORD pdwNumFilterObjects
    )
{

    DWORD dwError = 0;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject =  NULL;
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects = NULL;

    DWORD dwNumFilterObjectsReturned = 0;
    DWORD dwIndex = 0;
    WCHAR szFilterName[MAX_PATH];
    DWORD dwSize = 0;

    *pppIpsecFilterObjects = NULL;
    *pdwNumFilterObjects = 0;

    while (1) {

        dwSize = MAX_PATH;
        szFilterName[0] = L'\0';

        dwError = RegEnumKeyExW(
                        hRegistryKey,
                        dwIndex,
                        szFilterName,
                        &dwSize,
                        NULL,
                        NULL,
                        0,
                        0
                        );
        if (dwError == ERROR_NO_MORE_ITEMS) {
            break;
        }
        BAIL_ON_WIN32_ERROR(dwError);

        if (!wcsstr(szFilterName, L"ipsecFilter")) {
            dwIndex++;
            continue;
        }

        pIpsecFilterObject = NULL;

        dwError =UnMarshallRegistryFilterObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    szFilterName,
                    REG_RELATIVE_NAME,
                    &pIpsecFilterObject
                    );
        if (dwError == ERROR_SUCCESS) {

            dwError = ReallocatePolMem(
                          (LPVOID *) &ppIpsecFilterObjects,
                          sizeof(PIPSEC_FILTER_OBJECT)*(dwNumFilterObjectsReturned),
                          sizeof(PIPSEC_FILTER_OBJECT)*(dwNumFilterObjectsReturned + 1)
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            *(ppIpsecFilterObjects + dwNumFilterObjectsReturned) = pIpsecFilterObject;

            dwNumFilterObjectsReturned++;

        }

        dwIndex++;

    }

    *pppIpsecFilterObjects = ppIpsecFilterObjects;
    *pdwNumFilterObjects = dwNumFilterObjectsReturned;

    dwError = ERROR_SUCCESS;

    return(dwError);

error:


    if (ppIpsecFilterObjects) {
        FreeIpsecFilterObjects(
                    ppIpsecFilterObjects,
                    dwNumFilterObjectsReturned
                    );
    }

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(
            pIpsecFilterObject
            );
    }

    *pppIpsecFilterObjects = NULL;
    *pdwNumFilterObjects = 0;


    return(dwError);
}


DWORD
RegSetFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_FILTER_DATA pIpsecFilterData
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;

    dwError = RegMarshallFilterObject(
                    pIpsecFilterData,
                    &pIpsecFilterObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetFilterObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    pIpsecFilterObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegBackPropIncChangesForFilterToNFA(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszLocationName,
                  pIpsecFilterObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(pIpsecFilterObject);
    }

    return(dwError);
}


DWORD
RegSetFilterObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    )
{
    DWORD dwError = 0;

    dwError = PersistFilterObject(
                    hRegistryKey,
                    pIpsecFilterObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegCreateFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_DATA pIpsecFilterData
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;

    dwError = RegMarshallFilterObject(
                        pIpsecFilterData,
                        &pIpsecFilterObject
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegCreateFilterObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    pIpsecFilterObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(
                pIpsecFilterObject
                );
    }

    return(dwError);
}

DWORD
RegCreateFilterObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    )
{

    DWORD dwError = 0;

    dwError = PersistFilterObject(
                    hRegistryKey,
                    pIpsecFilterObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegDeleteFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';

    dwError = UuidToString(
                  &FilterIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szDistinguishedName,L"ipsecFilter");
    wcscat(szDistinguishedName, szGuid);

    dwError = RegDeleteKeyW(
                  hRegistryKey,
                  szDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);
}


DWORD
RegUnmarshallFilterData(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallFilterObject(
                    pIpsecFilterObject,
                    ppIpsecFilterData
                    );


    return(dwError);
}

DWORD
RegMarshallFilterObject(
    PIPSEC_FILTER_DATA pIpsecFilterData,
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObject
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;
    time_t PresentTime;


    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';
    pIpsecFilterObject = (PIPSEC_FILTER_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_FILTER_OBJECT)
                                                    );
    if (!pIpsecFilterObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecFilterData->FilterIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    //
    // Fill in the distinguishedName
    //

    wcscpy(szDistinguishedName,L"ipsecFilter");
    wcscat(szDistinguishedName, szGuid);
    pIpsecFilterObject->pszDistinguishedName = AllocPolStr(
                                                    szDistinguishedName
                                                    );
    if (!pIpsecFilterObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Fill in the ipsecName
    //

    if (pIpsecFilterData->pszIpsecName &&
        *pIpsecFilterData->pszIpsecName) {
        pIpsecFilterObject->pszIpsecName = AllocPolStr(
                                            pIpsecFilterData->pszIpsecName
                                            );
        if (!pIpsecFilterObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecFilterData->pszDescription &&
        *pIpsecFilterData->pszDescription) {
        pIpsecFilterObject->pszDescription = AllocPolStr(
                                             pIpsecFilterData->pszDescription
                                             );
        if (!pIpsecFilterObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //
    // Fill in the ipsecID
    //

    pIpsecFilterObject->pszIpsecID = AllocPolStr(
                                            szGuid
                                            );
    if (!pIpsecFilterObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Fill in the ipsecDataType
    //

    pIpsecFilterObject->dwIpsecDataType = 0x100;


    //
    // Marshall the pIpsecDataBuffer and the Length
    //

    dwError = MarshallFilterBuffer(
                    pIpsecFilterData,
                    &pBuffer,
                    &dwBufferLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecFilterObject->pIpsecData  = pBuffer;

    pIpsecFilterObject->dwIpsecDataLen = dwBufferLen;

    time(&PresentTime);

    pIpsecFilterObject->dwWhenChanged = (DWORD) PresentTime;

    *ppIpsecFilterObject = pIpsecFilterObject;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }

    return(dwError);

error:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(
            pIpsecFilterObject
            );
    }

    *ppIpsecFilterObject = NULL;
    goto cleanup;
}


DWORD
MarshallFilterBuffer(
    PIPSEC_FILTER_DATA pIpsecFilterData,
    LPBYTE * ppBuffer,
    DWORD * pdwBufferLen
    )
{
    LPBYTE pMem = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppIpsecFilterSpecs = NULL;
    PIPSEC_FILTER_SPEC  pIpsecFilterSpec = NULL;
    DWORD i = 0;
    DWORD dwNumBytesAdvanced = 0;
    DWORD dwError = 0;
    LPBYTE pBuffer = NULL;
    LPBYTE pCurrentPos = NULL;
    PSPEC_BUFFER pSpecBuffer = NULL;
    DWORD dwSpecSize = 0;
    DWORD dwTotalSize = 0;
    DWORD dwEffectiveSize = 0;

    // {80DC20B5-2EC8-11d1-A89E-00A0248D3021}
    static const GUID GUID_IPSEC_FILTER_BLOB =
    { 0x80dc20b5, 0x2ec8, 0x11d1, { 0xa8, 0x9e, 0x0, 0xa0, 0x24, 0x8d, 0x30, 0x21 } };


    //
    // Advance by the GUID
    //

    dwTotalSize += sizeof(GUID);


    //
    // Advance by a DWORD - Total size of the buffer.
    //

    dwTotalSize += sizeof(DWORD);

    //
    // Advance by a DWORD - this is dwNumFilterSpecs;
    //

    dwTotalSize += sizeof(DWORD);

    dwNumFilterSpecs = pIpsecFilterData->dwNumFilterSpecs;

    pSpecBuffer = (PSPEC_BUFFER)AllocPolMem(
                        sizeof(SPEC_BUFFER)*dwNumFilterSpecs
                        );
    if (!pSpecBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwNumFilterSpecs;i++){

        dwError = MarshallFilterSpecBuffer(
                        *(pIpsecFilterData->ppFilterSpecs + i),
                        &pMem,
                        &dwSpecSize
                        );
        BAIL_ON_WIN32_ERROR(dwError);

        dwTotalSize += dwSpecSize;

        //
        // Fill in the spec size information
        //

        (pSpecBuffer + i)->dwSize = dwSpecSize;
        (pSpecBuffer + i)->pMem = pMem;

    }

    dwTotalSize++;

    pBuffer = AllocPolMem(dwTotalSize);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    pCurrentPos = pBuffer;

    //
    // Copy the GUID
    //
    memcpy(pCurrentPos, &GUID_IPSEC_FILTER_BLOB, sizeof(GUID));
    pCurrentPos += sizeof(GUID);

    dwEffectiveSize = dwTotalSize - sizeof(GUID) - sizeof(DWORD) - 1;

    memcpy(pCurrentPos, &dwEffectiveSize, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    memcpy(pCurrentPos, &dwNumFilterSpecs, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);


    for (i = 0; i < dwNumFilterSpecs; i++) {

        pMem = (pSpecBuffer + i)->pMem;
        dwSpecSize = (pSpecBuffer + i)->dwSize;

        memcpy(pCurrentPos, pMem, dwSpecSize);
        pCurrentPos += dwSpecSize;

    }

    *ppBuffer = pBuffer;
    *pdwBufferLen = dwTotalSize;

cleanup:

    if (pSpecBuffer) {
        FreeSpecBuffer(
            pSpecBuffer,
            dwNumFilterSpecs
            );
    }

    return(dwError);

error:

    if (pBuffer) {
        FreePolMem(pBuffer);
    }

    *ppBuffer = NULL;
    *pdwBufferLen = 0;

    goto cleanup;
}


DWORD
MarshallFilterSpecBuffer(
    PIPSEC_FILTER_SPEC pIpsecFilterSpec,
    LPBYTE * ppMem,
    DWORD * pdwSize
    )
{
    DWORD dwSrcDNSNameLen = 0;
    DWORD dwDestDNSNameLen = 0;
    DWORD dwDescriptionLen = 0;

    LPBYTE pMem = NULL;
    LPBYTE pCurrentPos = NULL;

    DWORD dwSize = 0;
    DWORD dwError = 0;


    dwSize += sizeof(DWORD);

    if (pIpsecFilterSpec->pszSrcDNSName && 
        *pIpsecFilterSpec->pszSrcDNSName) {
        dwSrcDNSNameLen = (wcslen(pIpsecFilterSpec->pszSrcDNSName) + 1)
                          *sizeof(WCHAR);
    }
    else {
        dwSrcDNSNameLen = sizeof(WCHAR);
    }

    if (dwSrcDNSNameLen) {
        dwSize += dwSrcDNSNameLen;
    }

    dwSize += sizeof(DWORD);

    if (pIpsecFilterSpec->pszDestDNSName && 
        *pIpsecFilterSpec->pszDestDNSName) {
        dwDestDNSNameLen = (wcslen(pIpsecFilterSpec->pszDestDNSName) + 1)
                          *sizeof(WCHAR);
    }
    else {
        dwDestDNSNameLen = sizeof(WCHAR);
    }

    if (dwDestDNSNameLen) {
        dwSize += dwDestDNSNameLen;
    }

    dwSize += sizeof(DWORD);

    if (pIpsecFilterSpec->pszDescription && 
        *pIpsecFilterSpec->pszDescription) {
        dwDescriptionLen = (wcslen(pIpsecFilterSpec->pszDescription) + 1)
                           *sizeof(WCHAR);
    }
    else {
        dwDescriptionLen = sizeof(WCHAR);
    }

    if (dwDescriptionLen) {
        dwSize += dwDescriptionLen;
    }

    //
    // Filter Spec GUID
    //

    dwSize += sizeof(GUID);

    //
    // dwMirrorFlag
    //
    dwSize += sizeof(DWORD);

    dwSize += sizeof(IPSEC_FILTER);


    pMem = (LPBYTE)AllocPolMem(dwSize);
    if (!pMem) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    pCurrentPos = pMem;

    memcpy(pCurrentPos, &(dwSrcDNSNameLen), sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    if (pIpsecFilterSpec->pszSrcDNSName &&
        *pIpsecFilterSpec->pszSrcDNSName) {
        memcpy(pCurrentPos, pIpsecFilterSpec->pszSrcDNSName, dwSrcDNSNameLen);
    }
    pCurrentPos += dwSrcDNSNameLen;

    memcpy(pCurrentPos, &(dwDestDNSNameLen), sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    if (pIpsecFilterSpec->pszDestDNSName &&
        *pIpsecFilterSpec->pszDestDNSName) {
        memcpy(pCurrentPos, pIpsecFilterSpec->pszDestDNSName, dwDestDNSNameLen);
    }
    pCurrentPos += dwDestDNSNameLen;


    memcpy(pCurrentPos, &(dwDescriptionLen), sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    if (pIpsecFilterSpec->pszDescription &&
        *pIpsecFilterSpec->pszDescription) {
        memcpy(pCurrentPos, pIpsecFilterSpec->pszDescription, dwDescriptionLen);
    }
    pCurrentPos += dwDescriptionLen;

    memcpy(pCurrentPos, &(pIpsecFilterSpec->FilterSpecGUID), sizeof(GUID));
    pCurrentPos += sizeof(GUID);

    memcpy(pCurrentPos, &(pIpsecFilterSpec->dwMirrorFlag), sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    memcpy(pCurrentPos, &(pIpsecFilterSpec->Filter), sizeof(IPSEC_FILTER));

    *ppMem = pMem;
    *pdwSize = dwSize;

    return(dwError);

error:

    *ppMem = NULL;
    *pdwSize = 0;
    return(dwError);
}


DWORD
RegGetFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID FilterGUID,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    WCHAR szIpsecFilterName[MAX_PATH];
    LPWSTR pszFilterName = NULL;

    szIpsecFilterName[0] = L'\0';
    wcscpy(szIpsecFilterName, L"ipsecFilter");

    dwError = UuidToString(&FilterGUID, &pszFilterName);
    BAIL_ON_WIN32_ERROR(dwError);

    wcscat(szIpsecFilterName, L"{");
    wcscat(szIpsecFilterName, pszFilterName);
    wcscat(szIpsecFilterName, L"}");

    dwError =UnMarshallRegistryFilterObject(
                hRegistryKey,
                pszIpsecRootContainer,
                szIpsecFilterName,
                REG_RELATIVE_NAME,
                &pIpsecFilterObject
                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegUnmarshallFilterData(
                    pIpsecFilterObject,
                    &pIpsecFilterData
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(
                pIpsecFilterObject
                );

    }

    if (pszFilterName) {
        RpcStringFree(&pszFilterName);
    }

    *ppIpsecFilterData = pIpsecFilterData;

    return(dwError);
}


VOID
FreeSpecBuffer(
    PSPEC_BUFFER pSpecBuffer,
    DWORD dwNumFilterSpecs
    )
{
    DWORD i = 0;

    if (pSpecBuffer) {
        for (i = 0; i < dwNumFilterSpecs; i++) {
            if ((pSpecBuffer+i)->pMem) {
                FreePolMem((pSpecBuffer+i)->pMem);
            }
        }
        FreePolMem(pSpecBuffer);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\filters-w.h ===
DWORD
WMIEnumFilterDataEx(
    IWbemServices *pWbemServices,
    PIPSEC_FILTER_DATA ** pppIpsecFilterData,
    PDWORD pdwNumFilterObjects
    );

DWORD
WMIEnumFilterObjectsEx(
    IWbemServices *pWbemServices,
    PIPSEC_FILTER_OBJECT ** pppIpsecFilterObjects,
    PDWORD pdwNumFilterObjects
    );

DWORD
WMIUnmarshallFilterData(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    );

DWORD
WMIGetFilterDataEx(
    IWbemServices *pWbemServices,
    GUID FilterGUID,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\filters-w.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       filters-w.c
//
//  Contents:   Filter management for WMI.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//              t-hhsu
//
//----------------------------------------------------------------------------

#include "precomp.h"

//extern LPWSTR FilterDNAttributes[];


DWORD
WMIEnumFilterDataEx(
    IWbemServices *pWbemServices,
    PIPSEC_FILTER_DATA ** pppIpsecFilterData,
    PDWORD pdwNumFilterObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    PIPSEC_FILTER_DATA * ppIpsecFilterData = NULL;
    DWORD dwNumFilterObjects = 0;
    DWORD i = 0;
    DWORD j = 0;



    dwError = WMIEnumFilterObjectsEx(
        pWbemServices,
        &ppIpsecFilterObjects,
        &dwNumFilterObjects
        );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumFilterObjects) {
        ppIpsecFilterData = (PIPSEC_FILTER_DATA *) AllocPolMem(
            dwNumFilterObjects*sizeof(PIPSEC_FILTER_DATA)
            );
        if (!ppIpsecFilterData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumFilterObjects; i++) {
        dwError = WMIUnmarshallFilterData(
            *(ppIpsecFilterObjects + i),
            &pIpsecFilterData
            );
        if (!dwError) {
            *(ppIpsecFilterData + j) = pIpsecFilterData;
            j++;
        }
    }
    
    if (j == 0) {
        if (ppIpsecFilterData) {
            FreePolMem(ppIpsecFilterData);
            ppIpsecFilterData = NULL;
        }
    }

    *pppIpsecFilterData = ppIpsecFilterData;
    *pdwNumFilterObjects = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecFilterObjects) {
        FreeIpsecFilterObjects(
            ppIpsecFilterObjects,
            dwNumFilterObjects
            );
    }

    return(dwError);

error:

    if (ppIpsecFilterData) {
        FreeMulIpsecFilterData(
            ppIpsecFilterData,
            i
            );
    }
    
    *pppIpsecFilterData = NULL;
    *pdwNumFilterObjects = 0;
    
    goto cleanup;
}


DWORD
WMIEnumFilterObjectsEx(
    IWbemServices *pWbemServices,
    PIPSEC_FILTER_OBJECT ** pppIpsecFilterObjects,
    PDWORD pdwNumFilterObjects
    )
{

    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject =  NULL;
    PIPSEC_FILTER_OBJECT * ppIpsecFilterObjects = NULL;
    DWORD dwNumFilterObjectsReturned = 0;
    HRESULT hr = S_OK;
    
    ///wbem
    IEnumWbemClassObject *pEnum = NULL;
    IWbemClassObject *pObj = NULL;
    ULONG uReturned = 0;
    VARIANT var;
    LPWSTR tmpStr = NULL;
    BSTR bstrTmp = NULL;



    *pppIpsecFilterObjects = NULL;
    *pdwNumFilterObjects = 0;

    VariantInit(&var);

    bstrTmp = SysAllocString(L"RSOP_IPSECPolicySetting");
    if(!bstrTmp) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    //get enum
    hr = IWbemServices_CreateInstanceEnum(
        pWbemServices,
        bstrTmp,
        WBEM_FLAG_FORWARD_ONLY,
        0,
        &pEnum
        );
    SysFreeString(bstrTmp);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

    uReturned = 1;
    while (SUCCEEDED(hr) && (uReturned == 1))
    {
        hr = IEnumWbemClassObject_Next(pEnum, WBEM_INFINITE, 1, &pObj, &uReturned);
        
        if (SUCCEEDED(hr) && (uReturned == 1))
        {
            hr = IWbemClassObject_Get(
                pObj,
                L"id",
                0,
                &var,
                0,
                0
                );
            BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

            tmpStr = var.bstrVal;

            if (!wcsstr(tmpStr, L"ipsecFilter")) {
                IWbemClassObject_Release(pObj);
                VariantClear(&var);
                continue;
            }

            pIpsecFilterObject = NULL;
            
            dwError = UnMarshallWMIFilterObject(
                pObj,
                &pIpsecFilterObject
                );
            
            if (dwError == ERROR_SUCCESS) {
                dwError = ReallocatePolMem(
                    (LPVOID *) &ppIpsecFilterObjects,
                    sizeof(PIPSEC_FILTER_OBJECT)*(dwNumFilterObjectsReturned),
                    sizeof(PIPSEC_FILTER_OBJECT)*(dwNumFilterObjectsReturned + 1)
                    );
                BAIL_ON_WIN32_ERROR(dwError);
                
                *(ppIpsecFilterObjects + dwNumFilterObjectsReturned) = pIpsecFilterObject;
                dwNumFilterObjectsReturned++;
            }
            
            //free
            IWbemClassObject_Release(pObj);
            pObj = NULL;
            VariantClear(&var);
        } else {
            BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

            //
            // Even if SUCCEEDED(hr), loop will still terminate since uReturned != 1
            //  
        }
    }

    *pppIpsecFilterObjects = ppIpsecFilterObjects;
    *pdwNumFilterObjects = dwNumFilterObjectsReturned;

    dwError = ERROR_SUCCESS;

 cleanup:
    
    if(pEnum)
        IEnumWbemClassObject_Release(pEnum);
    
    return(dwError);

 error:
     if (pObj) {
        IWbemClassObject_Release(pObj);
        pObj = NULL;
     }
     VariantClear(&var);

    if (ppIpsecFilterObjects) {
        FreeIpsecFilterObjects(
            ppIpsecFilterObjects,
            dwNumFilterObjectsReturned
            );
    }
    
    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(
            pIpsecFilterObject
            );
    }
    
    *pppIpsecFilterObjects = NULL;
    *pdwNumFilterObjects = 0;
    
    goto cleanup;

}


DWORD
WMIUnmarshallFilterData(
    PIPSEC_FILTER_OBJECT pIpsecFilterObject,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallFilterObject(
        pIpsecFilterObject,
        ppIpsecFilterData
        );
    BAIL_ON_WIN32_ERROR(dwError);    
    if (*ppIpsecFilterData) {
        (*ppIpsecFilterData)->dwFlags |= POLSTORE_READONLY;
    }
error:    
    return(dwError);
}


DWORD
WMIGetFilterDataEx(
    IWbemServices *pWbemServices,
    GUID FilterGUID,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    )
{
    DWORD dwError = 0;
    HRESULT hr = S_OK;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    WCHAR szIpsecFilterName[MAX_PATH];
    LPWSTR pszFilterName = NULL;

    ///wbem
    IWbemClassObject *pObj = NULL;
    LPWSTR objPathA = L"RSOP_IPSECPolicySetting.id=";
    LPWSTR objPath = NULL;
    BSTR bstrObjPath = NULL;



    szIpsecFilterName[0] = L'\0';
    wcscpy(szIpsecFilterName, L"ipsecFilter");
    
    dwError = UuidToString(&FilterGUID, &pszFilterName);
    BAIL_ON_WIN32_ERROR(dwError);
    
    wcscat(szIpsecFilterName, L"{");
    wcscat(szIpsecFilterName, pszFilterName);
    wcscat(szIpsecFilterName, L"}");
    
    objPath = (LPWSTR)AllocPolMem(
        sizeof(WCHAR)*(wcslen(objPathA)+wcslen(szIpsecFilterName)+3)
        );
    if(!objPath) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    wcscpy(objPath, objPathA);
    wcscat(objPath, L"\"");
    wcscat(objPath, szIpsecFilterName);
    wcscat(objPath, L"\"");
    
    bstrObjPath = SysAllocString(objPath);
    if(!bstrObjPath) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    hr = IWbemServices_GetObject(
        pWbemServices,
        bstrObjPath,
        WBEM_FLAG_RETURN_WBEM_COMPLETE,
        0,
        &pObj,
        0
        );
    SysFreeString(bstrObjPath);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
    
    dwError = UnMarshallWMIFilterObject(
        pObj,
        &pIpsecFilterObject
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = WMIUnmarshallFilterData(
        pIpsecFilterObject,
        &pIpsecFilterData
        );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecFilterData = pIpsecFilterData;

 cleanup:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(
                pIpsecFilterObject
                );

    }

    if (pszFilterName) {
        RpcStringFree(&pszFilterName);
    }
    
    if(pObj)
        IWbemClassObject_Release(pObj);
    
    if(objPath) {
        FreePolStr(objPath);
    }
    
    return(dwError);

 error:
    
    *ppIpsecFilterData = NULL;

    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\init.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation
All rights reserved

Module Name:

    init.c

Abstract:

    Holds initialization code for polstore.dll

Author:

Environment:

    User Mode

Revision History:
--*/


#include "precomp.h"

HANDLE hInst;


BOOL
InitializeDll(
    IN PVOID hmod,
    IN DWORD Reason,
    IN PCONTEXT pctx OPTIONAL)
{
    DBG_UNREFERENCED_PARAMETER(pctx);

    switch (Reason) {
    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls((HMODULE)hmod);
        hInst = hmod;
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\import.h ===
DWORD
ImportPoliciesFromFile(
    HANDLE hSrcPolicyStore,
    HANDLE hDesPolicyStore
    );


DWORD
DeleteDuplicatePolicyDataBeforeImport(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore
    );


DWORD
IPSecDeletePolicy(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );


DWORD
RegDeletePolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    GUID PolicyGUID
    );


DWORD
DirDeletePolicyBeforeImport(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier
    );


DWORD
DirDeleteDynamicDefaultNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolGUID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\isakmp-d.h ===
DWORD
DirEnumISAKMPData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_DATA ** pppIpsecISAKMPData,
    PDWORD pdwNumISAKMPObjects
    );

DWORD
DirEnumISAKMPObjects(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecISAKMPObjects,
    PDWORD pdwNumISAKMPObjects
    );

DWORD
DirSetISAKMPData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    );

DWORD
DirSetISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    );

DWORD
DirCreateISAKMPData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    );

DWORD
DirCreateISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    );

DWORD
DirDeleteISAKMPData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier
    );

DWORD
DirMarshallAddISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    LDAPModW *** pppLDAPModW
    );

DWORD
DirMarshallSetISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    LDAPModW *** pppLDAPModW
    );

DWORD
GenerateAllISAKMPsQuery(
    LPWSTR * ppszISAKMPString
    );

DWORD
DirUnmarshallISAKMPData(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    );

DWORD
DirMarshallISAKMPObject(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObject
    );

DWORD
DirGetISAKMPData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPGUID,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    );

DWORD
DirGetISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPGUID,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObject
    );

DWORD
GenerateSpecificISAKMPQuery(
    GUID ISAKMPIdentifier,
    LPWSTR * ppszISAKMPString
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\isakmp-f.c ===
#include "precomp.h"


DWORD
ExportISAKMPDataToFile(
    HANDLE hSrcPolicyStore,
    PIPSEC_POLICY_STORE pDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData = NULL;
    DWORD dwNumISAKMPObjects = 0;
    DWORD i = 0;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;


    dwError = IPSecEnumISAKMPData(
                  hSrcPolicyStore,
                  &ppIpsecISAKMPData,
                  &dwNumISAKMPObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    for (i = 0; i < dwNumISAKMPObjects; i++) {

        pIpsecISAKMPData = *(ppIpsecISAKMPData + i);

        dwError = RegCreateISAKMPData(
                      pDesPolicyStore->hRegistryKey,
                      pDesPolicyStore->pszIpsecRootContainer,
                      pIpsecISAKMPData
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (ppIpsecISAKMPData) {
        FreeMulIpsecISAKMPData(
            ppIpsecISAKMPData,
            dwNumISAKMPObjects
            );
    }

    return (dwError);
}


DWORD
ImportISAKMPDataFromFile(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData = NULL;
    DWORD dwNumISAKMPObjects = 0;
    DWORD i = 0;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;


    dwError = RegEnumISAKMPData(
                  pSrcPolicyStore->hRegistryKey,
                  pSrcPolicyStore->pszIpsecRootContainer,
                  &ppIpsecISAKMPData,
                  &dwNumISAKMPObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    for (i = 0; i < dwNumISAKMPObjects; i++) {

        pIpsecISAKMPData = *(ppIpsecISAKMPData + i);

        dwError = IPSecCreateISAKMPData(
                      hDesPolicyStore,
                      pIpsecISAKMPData
                      );
        if (dwError == ERROR_OBJECT_ALREADY_EXISTS) {
            dwError = IPSecSetISAKMPData(
                          hDesPolicyStore,
                          pIpsecISAKMPData
                          );
            BAIL_ON_WIN32_ERROR(dwError);
        }
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (ppIpsecISAKMPData) {
        FreeMulIpsecISAKMPData(
            ppIpsecISAKMPData,
            dwNumISAKMPObjects
            );
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\isakmp-d.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       isakmp-d.c
//
//  Contents:   ISAKMP Management for directory.
//
//
//  History:    AbhisheV
//
//----------------------------------------------------------------------------

#include "precomp.h"

extern LPWSTR ISAKMPDNAttributes[];


DWORD
DirEnumISAKMPData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_DATA ** pppIpsecISAKMPData,
    PDWORD pdwNumISAKMPObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects = NULL;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData = NULL;
    DWORD dwNumISAKMPObjects = 0;
    DWORD i = 0;
    DWORD j = 0;


    dwError = DirEnumISAKMPObjects(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    &ppIpsecISAKMPObjects,
                    &dwNumISAKMPObjects
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumISAKMPObjects) {
        ppIpsecISAKMPData = (PIPSEC_ISAKMP_DATA *) AllocPolMem(
                            dwNumISAKMPObjects*sizeof(PIPSEC_ISAKMP_DATA)
                            );
        if (!ppIpsecISAKMPData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumISAKMPObjects; i++) {

        dwError = DirUnmarshallISAKMPData(
                        *(ppIpsecISAKMPObjects + i),
                        &pIpsecISAKMPData
                        );
        if (!dwError) {
            *(ppIpsecISAKMPData + j) = pIpsecISAKMPData;
            j++;
        }
    }

    if (j == 0) {
        if (ppIpsecISAKMPData) {
            FreePolMem(ppIpsecISAKMPData);
            ppIpsecISAKMPData = NULL;
        }
    }

    *pppIpsecISAKMPData = ppIpsecISAKMPData;
    *pdwNumISAKMPObjects = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecISAKMPObjects) {
        FreeIpsecISAKMPObjects(
            ppIpsecISAKMPObjects,
            dwNumISAKMPObjects
            );
    }

    return(dwError);

error:

    if (ppIpsecISAKMPData) {
        FreeMulIpsecISAKMPData(
                ppIpsecISAKMPData,
                i
                );
    }

    *pppIpsecISAKMPData = NULL;
    *pdwNumISAKMPObjects = 0;

    goto cleanup;
}


DWORD
DirEnumISAKMPObjects(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecISAKMPObjects,
    PDWORD pdwNumISAKMPObjects
    )
{
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    DWORD dwError = 0;
    LPWSTR pszISAKMPString = NULL;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject =  NULL;
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects = NULL;

    DWORD dwNumISAKMPObjectsReturned = 0;

    dwError = GenerateAllISAKMPsQuery(
                    &pszISAKMPString
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszISAKMPString,
                  ISAKMPDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                    hLdapBindHandle,
                    res
                    );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppIpsecISAKMPObjects  = (PIPSEC_ISAKMP_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_ISAKMP_OBJECT)*dwCount
                                            );
    if (!ppIpsecISAKMPObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwCount; i++) {

        if (i == 0) {

            dwError = LdapFirstEntry(
                            hLdapBindHandle,
                            res,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        } else {

            dwError = LdapNextEntry(
                            hLdapBindHandle,
                            e,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        }

        dwError = UnMarshallISAKMPObject(
                      hLdapBindHandle,
                      e,
                      &pIpsecISAKMPObject
                      );

        if (dwError == ERROR_SUCCESS) {
            *(ppIpsecISAKMPObjects + dwNumISAKMPObjectsReturned) = pIpsecISAKMPObject;
            dwNumISAKMPObjectsReturned++;
        }

    }

    *pppIpsecISAKMPObjects = ppIpsecISAKMPObjects;
    *pdwNumISAKMPObjects = dwNumISAKMPObjectsReturned;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszISAKMPString) {
        FreePolMem(pszISAKMPString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    return(dwError);

error:

    if (ppIpsecISAKMPObjects) {
        FreeIpsecISAKMPObjects(
            ppIpsecISAKMPObjects,
            dwNumISAKMPObjectsReturned
            );
    }

    *pppIpsecISAKMPObjects = NULL;
    *pdwNumISAKMPObjects = 0;

    goto cleanup;
}


DWORD
DirSetISAKMPData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;

    dwError = DirMarshallISAKMPObject(
                    pIpsecISAKMPData,
                    pszIpsecRootContainer,
                    &pIpsecISAKMPObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirSetISAKMPObject(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    pIpsecISAKMPObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirBackPropIncChangesForISAKMPToPolicy(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pIpsecISAKMPData->ISAKMPIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(pIpsecISAKMPObject);
    }

    return(dwError);
}


DWORD
DirSetISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;

    dwError = DirMarshallSetISAKMPObject(
                        hLdapBindHandle,
                        pszIpsecRootContainer,
                        pIpsecISAKMPObject,
                        &ppLDAPModW
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pIpsecISAKMPObject->pszDistinguishedName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    //
    // Free the amods structures.
    //

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }


    return(dwError);
}


DWORD
DirCreateISAKMPData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;

    dwError = DirMarshallISAKMPObject(
                        pIpsecISAKMPData,
                        pszIpsecRootContainer,
                        &pIpsecISAKMPObject
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirCreateISAKMPObject(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    pIpsecISAKMPObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(
            pIpsecISAKMPObject
            );
    }

    return(dwError);
}


DWORD
DirCreateISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;


    dwError = DirMarshallAddISAKMPObject(
                        hLdapBindHandle,
                        pszIpsecRootContainer,
                        pIpsecISAKMPObject,
                        &ppLDAPModW
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapAddS(
                    hLdapBindHandle,
                    pIpsecISAKMPObject->pszDistinguishedName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    //
    // Free the amods structures.
    //

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirDeleteISAKMPData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';

    dwError = UuidToString(
                  &ISAKMPIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szDistinguishedName,L"CN=ipsecISAKMPPolicy");
    wcscat(szDistinguishedName, szGuid);
    wcscat(szDistinguishedName, L",");
    SecStrCatW(szDistinguishedName, pszIpsecRootContainer, MAX_PATH);

    dwError = LdapDeleteS(
                  hLdapBindHandle,
                  szDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);
}


DWORD
DirMarshallAddISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    LDAPModW *** pppLDAPModW
    )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 5;
    DWORD dwError = 0;
    WCHAR Buffer[64];


    if (!pIpsecISAKMPObject->pszIpsecName ||
        !*pIpsecISAKMPObject->pszIpsecName) {
        dwNumAttributes--;
    }

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // 0. objectClass
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"objectClass",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    L"ipsecISAKMPPolicy",
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 1. ipsecName
    //

    if (pIpsecISAKMPObject->pszIpsecName &&
        *pIpsecISAKMPObject->pszIpsecName) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"ipsecName",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecISAKMPObject->pszIpsecName,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 2. ipsecID
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecID",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecISAKMPObject->pszIpsecID,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 3. ipsecDataType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecDataType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( pIpsecISAKMPObject->dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                    Buffer,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 4. ipsecData
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecData",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPBinaryValue(
                    pIpsecISAKMPObject->pIpsecData,
                    pIpsecISAKMPObject->dwIpsecDataLen,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;

    i++;

    *pppLDAPModW = ppLDAPModW;

    return(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    *pppLDAPModW = NULL;

    return(dwError);
}


DWORD
DirMarshallSetISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    LDAPModW *** pppLDAPModW
    )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 4;
    DWORD dwError = 0;
    WCHAR Buffer[64];


    if (!pIpsecISAKMPObject->pszIpsecName ||
        !*pIpsecISAKMPObject->pszIpsecName) {
        dwNumAttributes--;
    }

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // 1. ipsecName
    //

    if (pIpsecISAKMPObject->pszIpsecName &&
        *pIpsecISAKMPObject->pszIpsecName) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"ipsecName",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecISAKMPObject->pszIpsecName,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 2. ipsecID
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecID",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecISAKMPObject->pszIpsecID,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 3. ipsecDataType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecDataType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( pIpsecISAKMPObject->dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                    Buffer,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 4. ipsecData
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecData",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPBinaryValue(
                    pIpsecISAKMPObject->pIpsecData,
                    pIpsecISAKMPObject->dwIpsecDataLen,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;

    i++;

    *pppLDAPModW = ppLDAPModW;

    return(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    *pppLDAPModW = NULL;

    return(dwError);
}


DWORD
GenerateAllISAKMPsQuery(
    LPWSTR * ppszISAKMPString
    )
{
    DWORD dwError = 0;
    DWORD dwLength = 0;
    LPWSTR pszISAKMPString = NULL;


    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(objectclass=ipsecISAKMPPolicy)");

    pszISAKMPString = (LPWSTR) AllocPolMem((dwLength + 1)*sizeof(WCHAR));

    if (!pszISAKMPString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Now fill in the buffer
    //

    wcscpy(pszISAKMPString, L"(objectclass=ipsecISAKMPPolicy)");

    *ppszISAKMPString = pszISAKMPString;

    return(0);

error:

    if (pszISAKMPString) {
        FreePolMem(pszISAKMPString);
    }

    *ppszISAKMPString = NULL;

    return(dwError);
}


DWORD
DirUnmarshallISAKMPData(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallISAKMPObject(
                  pIpsecISAKMPObject,
                  ppIpsecISAKMPData
                  );

    return(dwError);
}


DWORD
DirMarshallISAKMPObject(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObject
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';
    pIpsecISAKMPObject = (PIPSEC_ISAKMP_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_ISAKMP_OBJECT)
                                                    );
    if (!pIpsecISAKMPObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecISAKMPData->ISAKMPIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    //
    // Fill in the distinguishedName
    //

    wcscpy(szDistinguishedName,L"CN=ipsecISAKMPPolicy");
    wcscat(szDistinguishedName, szGuid);
    wcscat(szDistinguishedName, L",");
    SecStrCatW(szDistinguishedName, pszIpsecRootContainer, MAX_PATH);

    pIpsecISAKMPObject->pszDistinguishedName = AllocPolStr(
                                                    szDistinguishedName
                                                    );
    if (!pIpsecISAKMPObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Fill in the ipsecName.
    // ISAKMPData doesn't have a name.
    //

    pIpsecISAKMPObject->pszIpsecName = NULL;

    /*
    if (pIpsecISAKMPData->pszIpsecName &&
        *pIpsecISAKMPData->pszIpsecName) {
        pIpsecISAKMPObject->pszIpsecName = AllocPolStr(
                                           pIpsecISAKMPData->pszIpsecName
                                           );
        if (!pIpsecISAKMPObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    */

    //
    // Fill in the ipsecID
    //

    pIpsecISAKMPObject->pszIpsecID = AllocPolStr(
                                         szGuid
                                         );
    if (!pIpsecISAKMPObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Fill in the ipsecDataType
    //

    pIpsecISAKMPObject->dwIpsecDataType = 0x100;


    //
    // Marshall the pIpsecDataBuffer and the Length
    //

    dwError = MarshallISAKMPBuffer(
                    pIpsecISAKMPData,
                    &pBuffer,
                    &dwBufferLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecISAKMPObject->pIpsecData  = pBuffer;

    pIpsecISAKMPObject->dwIpsecDataLen = dwBufferLen;

    pIpsecISAKMPObject->dwWhenChanged = 0;

    *ppIpsecISAKMPObject = pIpsecISAKMPObject;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }

    return(dwError);

error:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(
            pIpsecISAKMPObject
            );
    }

    *ppIpsecISAKMPObject = NULL;
    goto cleanup;
}


DWORD
DirGetISAKMPData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPGUID,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;


    dwError = DirGetISAKMPObject(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  ISAKMPGUID,
                  &pIpsecISAKMPObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirUnmarshallISAKMPData(
                  pIpsecISAKMPObject,
                  &pIpsecISAKMPData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecISAKMPData = pIpsecISAKMPData;

cleanup:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(
            pIpsecISAKMPObject
            );
    }

    return(dwError);

error:

    *ppIpsecISAKMPData = NULL;

    goto cleanup;
}


DWORD
DirGetISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPGUID,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObject
    )
{
    DWORD dwError = 0;
    LPWSTR pszISAKMPString = NULL;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;
    LDAPMessage * e = NULL;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject =  NULL;


    dwError = GenerateSpecificISAKMPQuery(
                  ISAKMPGUID,
                  &pszISAKMPString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszISAKMPString,
                  ISAKMPDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallISAKMPObject(
                  hLdapBindHandle,
                  e,
                  &pIpsecISAKMPObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecISAKMPObject = pIpsecISAKMPObject;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszISAKMPString) {
        FreePolMem(pszISAKMPString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    return(dwError);

error:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(
            pIpsecISAKMPObject
            );
    }

    *ppIpsecISAKMPObject = NULL;

    goto cleanup;
}


DWORD
GenerateSpecificISAKMPQuery(
    GUID ISAKMPIdentifier,
    LPWSTR * ppszISAKMPString
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;
    DWORD dwLength = 0;
    LPWSTR pszISAKMPString = NULL;


    szGuid[0] = L'\0';
    szCommonName[0] = L'\0';

    dwError = UuidToString(
                  &ISAKMPIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szCommonName, L"cn=ipsecISAKMPPolicy");
    wcscat(szCommonName, szGuid);

    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(&(objectclass=ipsecISAKMPPolicy)");
    dwLength += wcslen(L"(");
    dwLength += wcslen(szCommonName);
    dwLength += wcslen(L"))");

    pszISAKMPString = (LPWSTR) AllocPolMem((dwLength + 1)*sizeof(WCHAR));

    if (!pszISAKMPString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    wcscpy(pszISAKMPString, L"(&(objectclass=ipsecISAKMPPolicy)");
    wcscat(pszISAKMPString, L"(");
    wcscat(pszISAKMPString, szCommonName);
    wcscat(pszISAKMPString, L"))");

    *ppszISAKMPString = pszISAKMPString;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    if (pszISAKMPString) {
        FreePolMem(pszISAKMPString);
    }

    *ppszISAKMPString = NULL;

    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\import.c ===
#include "precomp.h"


DWORD
ImportPoliciesFromFile(
    HANDLE hSrcPolicyStore,
    HANDLE hDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pSrcPolicyStore = NULL;
    PIPSEC_POLICY_DATA * ppIpsecPolicyData = NULL;
    DWORD dwNumPolicyObjects = 0;
    PIPSEC_POLICY_STORE pDesPolicyStore = NULL;


    pSrcPolicyStore = (PIPSEC_POLICY_STORE) hSrcPolicyStore;

    dwError = EnablePrivilege(
                  SE_RESTORE_NAME
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegRestoreKeyW(
                  pSrcPolicyStore->hRegistryKey,
                  pSrcPolicyStore->pszFileName,
                  0
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DeleteDuplicatePolicyDataBeforeImport(
                  pSrcPolicyStore,
                  hDesPolicyStore
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ImportFilterDataFromFile(
                  pSrcPolicyStore,
                  hDesPolicyStore
                  );

    dwError = ImportNegPolDataFromFile(
                  pSrcPolicyStore,
                  hDesPolicyStore
                  );

    dwError = ImportISAKMPDataFromFile(
                  pSrcPolicyStore,
                  hDesPolicyStore
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ImportPolicyDataFromFile(
                  pSrcPolicyStore,
                  hDesPolicyStore,
                  &ppIpsecPolicyData,
                  &dwNumPolicyObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ImportNFADataFromFile(
                  pSrcPolicyStore,
                  hDesPolicyStore,
                  ppIpsecPolicyData,
                  dwNumPolicyObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pDesPolicyStore = (PIPSEC_POLICY_STORE) hDesPolicyStore;

    if (pDesPolicyStore->dwProvider == IPSEC_REGISTRY_PROVIDER) {
        (VOID) RegPingPASvcForActivePolicy(
                  pDesPolicyStore->hRegistryKey,
                  pDesPolicyStore->pszIpsecRootContainer,
                  pDesPolicyStore->pszLocationName
                  );
    }

error:

    if (ppIpsecPolicyData) {
        FreeMulIpsecPolicyData(
            ppIpsecPolicyData,
            dwNumPolicyObjects
            );
    }

    FlushRegSaveKey(
        pSrcPolicyStore->hRegistryKey
        );

    return (dwError);
}


DWORD
DeleteDuplicatePolicyDataBeforeImport(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_DATA * ppIpsecPolicyData = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD dwNumPolicyObjects = 0;
    DWORD i = 0;


    dwError = RegEnumPolicyData(
                  pSrcPolicyStore->hRegistryKey,
                  pSrcPolicyStore->pszIpsecRootContainer,
                  &ppIpsecPolicyData,
                  &dwNumPolicyObjects
                  );

    for (i = 0; i < dwNumPolicyObjects; i++) {

        pIpsecPolicyData = * (ppIpsecPolicyData + i);

        dwError = VerifyPolicyDataExistence(
                      hDesPolicyStore,
                      pIpsecPolicyData->PolicyIdentifier
                      );

        if (!dwError) {
            dwError = IPSecDeletePolicy(
                          hDesPolicyStore,
                          pIpsecPolicyData
                          ); 
        }

    }

    if (ppIpsecPolicyData) {
        FreeMulIpsecPolicyData(
            ppIpsecPolicyData,
            dwNumPolicyObjects
            );
    }

    dwError = ERROR_SUCCESS;

    return (dwError);
}


DWORD
IPSecDeletePolicy(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;


    pPolicyStore = (PIPSEC_POLICY_STORE) hPolicyStore;

    switch (pPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:

        dwError = RegDeletePolicy(
                      pPolicyStore->hRegistryKey,
                      pPolicyStore->pszIpsecRootContainer,
                      pPolicyStore->pszLocationName,
                      pIpsecPolicyData->PolicyIdentifier
                      );
        BAIL_ON_WIN32_ERROR (dwError);
        break;

    case IPSEC_DIRECTORY_PROVIDER:

        dwError = DirDeletePolicyBeforeImport(
                      pPolicyStore->hLdapBindHandle,
                      pPolicyStore->pszIpsecRootContainer,
                      pIpsecPolicyData->PolicyIdentifier
                      );
        BAIL_ON_WIN32_ERROR (dwError);
        break;

    }

error:

    return (dwError);
}


DWORD
RegDeletePolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    GUID PolicyGUID
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;
    DWORD dwNumNFAObjects = 0;
    DWORD i = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;


    dwError = RegGetPolicyData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  PolicyGUID,
                  &pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegEnumNFAData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  PolicyGUID,
                  &ppIpsecNFAData,
                  &dwNumNFAObjects
                  );

    for (i = 0; i < dwNumNFAObjects; i++) {

        pIpsecNFAData = *(ppIpsecNFAData + i);

        dwError = RegDeleteNFAData(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      PolicyGUID,
                      pszLocationName,
                      pIpsecNFAData
                      );

        dwError = RegDeleteDynamicDefaultNegPolData(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      pszLocationName,
                      pIpsecNFAData->NegPolIdentifier
                      );

    }

    dwError = RegDeletePolicyData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegDeleteISAKMPData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pIpsecPolicyData->ISAKMPIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppIpsecNFAData) {
        FreeMulIpsecNFAData(
            ppIpsecNFAData,
            dwNumNFAObjects
            );
    }

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(
            pIpsecPolicyData
            );
    }

    return (dwError);
}


DWORD
DirDeletePolicyBeforeImport(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD dwNumNFAObjects = 0;
    DWORD i = 0;


    dwError = DirGetPolicyData(
                 hLdapBindHandle,
                 pszIpsecRootContainer,
                 PolicyIdentifier,
                 &pIpsecPolicyData
                 );
    BAIL_ON_WIN32_ERROR (dwError);

    dwError = DirEnumNFAData(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  PolicyIdentifier,
                  &ppIpsecNFAData,
                  &dwNumNFAObjects
                  );

    for (i = 0; i < dwNumNFAObjects; i++) {

        pIpsecNFAData = *(ppIpsecNFAData + i);

        dwError = DirDeleteNFAData(
                     hLdapBindHandle,
                     pszIpsecRootContainer,
                     PolicyIdentifier,
                     pIpsecNFAData
                     );

        dwError = DirDeleteDynamicDefaultNegPolData(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pIpsecNFAData->NegPolIdentifier
                      );

    }

    dwError = DirDeleteISAKMPData(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pIpsecPolicyData->ISAKMPIdentifier
                  );
    BAIL_ON_WIN32_ERROR (dwError);

error:

    if (ppIpsecNFAData) {
        FreeMulIpsecNFAData(
            ppIpsecNFAData,
            dwNumNFAObjects
            );
    }

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(
            pIpsecPolicyData
            );
    }

    return (dwError); 
}


DWORD
DirDeleteDynamicDefaultNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolGUID
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;


    dwError = DirGetNegPolData(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  NegPolGUID,
                  &pIpsecNegPolData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!memcmp(
            &(pIpsecNegPolData->NegPolType),
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {

        dwError = DirDeleteNegPolData(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      NegPolGUID
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (pIpsecNegPolData) {
        FreeIpsecNegPolData(
            pIpsecNegPolData
            );
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\isakmp-f.h ===
DWORD
ExportISAKMPDataToFile(
    HANDLE hSrcPolicyStore,
    PIPSEC_POLICY_STORE pDesPolicyStore
    );

DWORD
ImportISAKMPDataFromFile(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\isakmp-r.h ===
DWORD
RegEnumISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_DATA ** pppIpsecISAKMPData,
    PDWORD pdwNumISAKMPObjects
    );


DWORD
RegEnumISAKMPObjects(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecISAKMPObjects,
    PDWORD pdwNumISAKMPObjects
    );


DWORD
RegSetISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    );


DWORD
RegSetISAKMPObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    );


DWORD
RegCreateISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    );


DWORD
RegCreateISAKMPObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    );


DWORD
RegDeleteISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier
    );


DWORD
RegUnmarshallISAKMPData(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    );

DWORD
RegMarshallISAKMPObject(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObject
    );


DWORD
MarshallISAKMPBuffer(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    LPBYTE * ppBuffer,
    DWORD * pdwBufferLen
    );


DWORD
RegGetISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPGUID,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\isakmp-r.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       isakmp-r.c
//
//  Contents:   ISAKMP management for registry.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//
//----------------------------------------------------------------------------

#include "precomp.h"

extern LPWSTR ISAKMPDNAttributes[];


DWORD
RegEnumISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_DATA ** pppIpsecISAKMPData,
    PDWORD pdwNumISAKMPObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects = NULL;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData = NULL;
    DWORD dwNumISAKMPObjects = 0;
    DWORD i = 0;
    DWORD j = 0;


    dwError = RegEnumISAKMPObjects(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    &ppIpsecISAKMPObjects,
                    &dwNumISAKMPObjects
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumISAKMPObjects) {
        ppIpsecISAKMPData = (PIPSEC_ISAKMP_DATA *) AllocPolMem(
                        dwNumISAKMPObjects*sizeof(PIPSEC_ISAKMP_DATA));
        if (!ppIpsecISAKMPData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumISAKMPObjects; i++) {

        dwError = RegUnmarshallISAKMPData(
                        *(ppIpsecISAKMPObjects + i),
                        &pIpsecISAKMPData
                        );
        if (!dwError) {
            *(ppIpsecISAKMPData + j) = pIpsecISAKMPData;
            j++;
        }
    }

    if (j == 0) {
        if (ppIpsecISAKMPData) {
            FreePolMem(ppIpsecISAKMPData);
            ppIpsecISAKMPData = NULL;
        }
    }

    *pppIpsecISAKMPData = ppIpsecISAKMPData;
    *pdwNumISAKMPObjects = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecISAKMPObjects) {
        FreeIpsecISAKMPObjects(
                ppIpsecISAKMPObjects,
                dwNumISAKMPObjects
                );
    }

    return(dwError);


error:

    if (ppIpsecISAKMPData) {
        FreeMulIpsecISAKMPData(
                ppIpsecISAKMPData,
                i
                );
    }

    *pppIpsecISAKMPData = NULL;
    *pdwNumISAKMPObjects = 0;

    goto cleanup;
}

DWORD
RegEnumISAKMPObjects(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecISAKMPObjects,
    PDWORD pdwNumISAKMPObjects
    )
{

    DWORD dwError = 0;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject =  NULL;
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects = NULL;

    DWORD dwNumISAKMPObjectsReturned = 0;
    DWORD dwIndex = 0;
    WCHAR szISAKMPName[MAX_PATH];
    DWORD dwSize = 0;
    DWORD dwReserved = 0;

    *pppIpsecISAKMPObjects = NULL;
    *pdwNumISAKMPObjects = 0;

    while (1) {

        dwSize = MAX_PATH;
        dwReserved = 0;
        szISAKMPName[0] = L'\0';

        dwError = RegEnumKeyExW(
                        hRegistryKey,
                        dwIndex,
                        szISAKMPName,
                        &dwSize,
                        NULL,
                        NULL,
                        0,
                        0
                        );
        if (dwError == ERROR_NO_MORE_ITEMS) {
            break;
        }
        BAIL_ON_WIN32_ERROR(dwError);

        if (!wcsstr(szISAKMPName, L"ipsecISAKMPPolicy")) {
            dwIndex++;
            continue;
        }

        pIpsecISAKMPObject = NULL;

        dwError =UnMarshallRegistryISAKMPObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    szISAKMPName,
                    REG_RELATIVE_NAME,
                    &pIpsecISAKMPObject
                    );
        if (dwError == ERROR_SUCCESS) {

            dwError = ReallocatePolMem(
                          (LPVOID *) &ppIpsecISAKMPObjects,
                          sizeof(PIPSEC_ISAKMP_OBJECT)*(dwNumISAKMPObjectsReturned),
                          sizeof(PIPSEC_ISAKMP_OBJECT)*(dwNumISAKMPObjectsReturned + 1)
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            *(ppIpsecISAKMPObjects + dwNumISAKMPObjectsReturned) = pIpsecISAKMPObject;

            dwNumISAKMPObjectsReturned++;

        }

        dwIndex++;

    }

    *pppIpsecISAKMPObjects = ppIpsecISAKMPObjects;
    *pdwNumISAKMPObjects = dwNumISAKMPObjectsReturned;

    dwError = ERROR_SUCCESS;

    return(dwError);

error:

    if (ppIpsecISAKMPObjects) {
        FreeIpsecISAKMPObjects(
            ppIpsecISAKMPObjects,
            dwNumISAKMPObjectsReturned
            );
    }

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(
            pIpsecISAKMPObject
            );
    }

    *pppIpsecISAKMPObjects = NULL;
    *pdwNumISAKMPObjects = 0;


    return(dwError);
}


DWORD
RegSetISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;

    dwError = RegMarshallISAKMPObject(
                    pIpsecISAKMPData,
                    &pIpsecISAKMPObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetISAKMPObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    pIpsecISAKMPObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegBackPropIncChangesForISAKMPToPolicy(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszLocationName,
                  pIpsecISAKMPObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(pIpsecISAKMPObject);
    }

    return(dwError);
}


DWORD
RegSetISAKMPObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    )
{
    DWORD dwError = 0;

    dwError = PersistISAKMPObject(
                    hRegistryKey,
                    pIpsecISAKMPObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegCreateISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;

    dwError = RegMarshallISAKMPObject(
                        pIpsecISAKMPData,
                        &pIpsecISAKMPObject
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegCreateISAKMPObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    pIpsecISAKMPObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(
                pIpsecISAKMPObject
                );
    }

    return(dwError);
}

DWORD
RegCreateISAKMPObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    )
{

    DWORD dwError = 0;

    dwError = PersistISAKMPObject(
                    hRegistryKey,
                    pIpsecISAKMPObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegDeleteISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';

    dwError = UuidToString(
                  &ISAKMPIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szDistinguishedName,L"ipsecISAKMPPolicy");
    wcscat(szDistinguishedName, szGuid);

    dwError = RegDeleteKeyW(
                  hRegistryKey,
                  szDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);
}


DWORD
RegUnmarshallISAKMPData(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallISAKMPObject(
                    pIpsecISAKMPObject,
                    ppIpsecISAKMPData
                    );


    return(dwError);
}

DWORD
RegMarshallISAKMPObject(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObject
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;
    time_t PresentTime;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';
    pIpsecISAKMPObject = (PIPSEC_ISAKMP_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_ISAKMP_OBJECT)
                                                    );
    if (!pIpsecISAKMPObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecISAKMPData->ISAKMPIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    //
    // Fill in the distinguishedName
    //

    wcscpy(szDistinguishedName,L"ipsecISAKMPPolicy");
    wcscat(szDistinguishedName, szGuid);
    pIpsecISAKMPObject->pszDistinguishedName = AllocPolStr(
                                                    szDistinguishedName
                                                    );
    if (!pIpsecISAKMPObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Fill in the ipsecName.
    // ISAKMPData doesn't have a name.
    //

    pIpsecISAKMPObject->pszIpsecName = NULL;

    /*
    if (pIpsecISAKMPData->pszIpsecName &&
        *pIpsecISAKMPData->pszIpsecName) {
        pIpsecISAKMPObject->pszIpsecName = AllocPolStr(
                                           pIpsecISAKMPData->pszIpsecName
                                           );
        if (!pIpsecISAKMPObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    */

    //
    // Fill in the ipsecID
    //

    pIpsecISAKMPObject->pszIpsecID = AllocPolStr(
                                         szGuid
                                         );
    if (!pIpsecISAKMPObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Fill in the ipsecDataType
    //

    pIpsecISAKMPObject->dwIpsecDataType = 0x100;


    //
    // Marshall the pIpsecDataBuffer and the Length
    //

    dwError = MarshallISAKMPBuffer(
                    pIpsecISAKMPData,
                    &pBuffer,
                    &dwBufferLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecISAKMPObject->pIpsecData  = pBuffer;

    pIpsecISAKMPObject->dwIpsecDataLen = dwBufferLen;

    time(&PresentTime);

    pIpsecISAKMPObject->dwWhenChanged = (DWORD) PresentTime;

    *ppIpsecISAKMPObject = pIpsecISAKMPObject;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }

    return(dwError);

error:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(
            pIpsecISAKMPObject
            );
    }

    *ppIpsecISAKMPObject = NULL;
    goto cleanup;
}


DWORD MapBundleToBYTE(PCRYPTO_BUNDLE pBundle,
                      BYTE *pByte)
{


	if (pBundle->EncryptionAlgorithm.AlgorithmIdentifier == IPSEC_ESP_DES &&
		pBundle->HashAlgorithm.AlgorithmIdentifier == IPSEC_AH_MD5 &&
		pBundle->OakleyGroup == DH_GROUP_2048) {
		*pByte = BYTE_DES_MD5_2048; 
	}

	if (pBundle->EncryptionAlgorithm.AlgorithmIdentifier == IPSEC_ESP_DES &&
		pBundle->HashAlgorithm.AlgorithmIdentifier == IPSEC_AH_SHA &&
		pBundle->OakleyGroup == DH_GROUP_2048) {
		*pByte = BYTE_DES_SHA_2048; 
	}

	if (pBundle->EncryptionAlgorithm.AlgorithmIdentifier == IPSEC_ESP_3_DES &&
		pBundle->HashAlgorithm.AlgorithmIdentifier == IPSEC_AH_MD5 &&
		pBundle->OakleyGroup == DH_GROUP_2048) {
		*pByte = BYTE_3DES_MD5_2048; 
	}

	if (pBundle->EncryptionAlgorithm.AlgorithmIdentifier == IPSEC_ESP_3_DES &&
		pBundle->HashAlgorithm.AlgorithmIdentifier == IPSEC_AH_SHA &&
		pBundle->OakleyGroup == DH_GROUP_2048) {
		*pByte = BYTE_3DES_SHA_2048; 
	}


	return ERROR_SUCCESS;

}

DWORD 
ConvertCryptoBundle(
    PCRYPTO_BUNDLE pInBundle,
    DWORD dwInNumMethods,
    DWORD *pdwOutNumMethods,
    PCRYPTO_BUNDLE *pOutBundle,
    BYTE *bLeadingBundles
    )
{

    DWORD dwError = 0;
    DWORD i = 0;
    BOOL  bNonExtDHFound=FALSE;

    DWORD dwNumExtLeading=0;
    DWORD dwNumExtInternal=0;
    DWORD dwNumMethods;

    DWORD dwCurIndex=0;

    PCRYPTO_BUNDLE pTmpBundle;
    PCRYPTO_BUNDLE pPrevNonExtBundle=NULL;

    for (i=0; i < dwInNumMethods; i++) {

        if (pInBundle[i].OakleyGroup != DH_GROUP_2048) {
            bNonExtDHFound = TRUE;
        } else { 
		    if (dwNumExtLeading >= 4) {
   			   // Error.  UI should disallow this case 
			   continue;
			}
            if (bNonExtDHFound == FALSE) {
                MapBundleToBYTE(&pInBundle[i],
                                &bLeadingBundles[dwNumExtLeading]);
                dwNumExtLeading++;
            } else {
                dwNumExtInternal++;
            }
        }
    }

    dwNumMethods = dwInNumMethods - dwNumExtLeading;
    
    pTmpBundle = (CRYPTO_BUNDLE *)AllocPolMem(dwNumMethods * sizeof(CRYPTO_BUNDLE));
    if (pTmpBundle == NULL) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    bNonExtDHFound = FALSE;

    for (i=0; i < dwInNumMethods; i++) {
        
        if ((pInBundle[i].OakleyGroup == DH_GROUP_2048) && !bNonExtDHFound) {
            continue;
        }
        if (pInBundle[i].OakleyGroup != DH_GROUP_2048) {
            memcpy(&pTmpBundle[dwCurIndex],
                   &pInBundle[i],
                   sizeof(CRYPTO_BUNDLE));
            bNonExtDHFound = TRUE;
            pPrevNonExtBundle=&pInBundle[i];
            dwCurIndex++;
        } else {
            memcpy(&pTmpBundle[dwCurIndex],
                   pPrevNonExtBundle,
                   sizeof(CRYPTO_BUNDLE));
            MapBundleToBYTE(&pInBundle[i],(BYTE*)&pTmpBundle[dwCurIndex].PseudoRandomFunction.Rounds);
            dwCurIndex++;
        }
    }

    *pOutBundle=pTmpBundle;
    *pdwOutNumMethods = dwNumMethods;

    return ERROR_SUCCESS;

error:
    *pOutBundle= NULL;
    *pdwOutNumMethods = 0;

    if (pTmpBundle) {
        FreePolMem(pTmpBundle);
    }        

    return dwError;
    

}

DWORD
MarshallISAKMPBuffer(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    LPBYTE * ppBuffer,
    DWORD * pdwBufferLen
    )
{
    LPBYTE pCurrentPos = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwSize = 0;
    DWORD dwError = 0;
    DWORD i = 0;
    DWORD dwNumISAKMPSecurityMethods = 0;
    PCRYPTO_BUNDLE pSecurityMethods = NULL;
    PCRYPTO_BUNDLE pSecurityMethod = NULL;
    ISAKMP_POLICY * pISAKMPPolicy = NULL;
    DWORD dwEffectiveSize = 0;
    PCRYPTO_BUNDLE pConvertedMethods = NULL;
    BYTE bLeadingBundleFlags[4];

    // {80DC20B8-2EC8-11d1-A89E-00A0248D3021}
    static const GUID GUID_IPSEC_ISAKMP_POLICY_BLOB =
    { 0x80dc20b8, 0x2ec8, 0x11d1, { 0xa8, 0x9e, 0x0, 0xa0, 0x24, 0x8d, 0x30, 0x21 } };


    memset(bLeadingBundleFlags,0,sizeof(BYTE)*4);

    dwNumISAKMPSecurityMethods =pIpsecISAKMPData->dwNumISAKMPSecurityMethods;
    pISAKMPPolicy = &(pIpsecISAKMPData->ISAKMPPolicy);
    pSecurityMethods = pIpsecISAKMPData->pSecurityMethods;

    dwError = ConvertCryptoBundle(pSecurityMethods,
                                  pIpsecISAKMPData->dwNumISAKMPSecurityMethods,
                                  &dwNumISAKMPSecurityMethods,
                                  &pConvertedMethods,
                                  bLeadingBundleFlags);

    BAIL_ON_WIN32_ERROR(dwError);    

    dwSize += sizeof(GUID);

    dwSize += sizeof(DWORD);

    dwSize += sizeof(ISAKMP_POLICY);

    dwSize += sizeof(DWORD);

    dwSize += sizeof(CRYPTO_BUNDLE)*dwNumISAKMPSecurityMethods;
    dwSize++;

    pBuffer = (LPBYTE)AllocPolMem(dwSize);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pCurrentPos = pBuffer;

    memcpy(pCurrentPos, &GUID_IPSEC_ISAKMP_POLICY_BLOB, sizeof(GUID));
    pCurrentPos += sizeof(GUID);

    dwEffectiveSize = dwSize - sizeof(GUID) - sizeof(DWORD) - 1;

    memcpy(pCurrentPos, &dwEffectiveSize, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    memcpy(pISAKMPPolicy->bLeadingBundleFlags,
           bLeadingBundleFlags,
           sizeof(BYTE)*4);

    pISAKMPPolicy->dwQMLimit = pSecurityMethods->QuickModeLimit;
    pISAKMPPolicy->dwLifetimeSec = pSecurityMethods->Lifetime.Seconds;
    

    memcpy(pCurrentPos, pISAKMPPolicy, sizeof(ISAKMP_POLICY));
    pCurrentPos += sizeof(ISAKMP_POLICY);

    memcpy(pCurrentPos, &dwNumISAKMPSecurityMethods, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    for (i = 0; i < dwNumISAKMPSecurityMethods; i++) {

        pSecurityMethod = pConvertedMethods + i;
        memcpy(pCurrentPos, pSecurityMethod, sizeof(CRYPTO_BUNDLE));
        pCurrentPos += sizeof(CRYPTO_BUNDLE);

    }

    *ppBuffer = pBuffer;
    *pdwBufferLen = dwSize;

    if (pConvertedMethods) {
        FreePolMem(pConvertedMethods);
    }

    return(dwError);

error:

    if (pConvertedMethods) {
        FreePolMem(pConvertedMethods);
    }

    if (pBuffer) {
        FreePolMem(pBuffer);
    }

    *ppBuffer = NULL;
    *pdwBufferLen = 0;
    return(dwError);
}


DWORD
RegGetISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPGUID,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;
    WCHAR szIpsecISAKMPName[MAX_PATH];
    LPWSTR pszISAKMPName = NULL;

    szIpsecISAKMPName[0] = L'\0';
    wcscpy(szIpsecISAKMPName, L"ipsecISAKMPPolicy");

    dwError = UuidToString(&ISAKMPGUID, &pszISAKMPName);
    BAIL_ON_WIN32_ERROR(dwError);

    wcscat(szIpsecISAKMPName, L"{");
    wcscat(szIpsecISAKMPName, pszISAKMPName);
    wcscat(szIpsecISAKMPName, L"}");


    dwError =UnMarshallRegistryISAKMPObject(
                hRegistryKey,
                pszIpsecRootContainer,
                szIpsecISAKMPName,
                REG_RELATIVE_NAME,
                &pIpsecISAKMPObject
                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegUnmarshallISAKMPData(
                    pIpsecISAKMPObject,
                    &pIpsecISAKMPData
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(
                pIpsecISAKMPObject
                );
    }

    if (pszISAKMPName) {
        RpcStringFree(&pszISAKMPName);
    }

    *ppIpsecISAKMPData = pIpsecISAKMPData;

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\negpols-d.h ===
DWORD
DirEnumNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_DATA ** pppIpsecNegPolData,
    PDWORD pdwNumNegPolObjects
    );

DWORD
DirEnumNegPolObjects(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecNegPolObjects,
    PDWORD pdwNumNegPolObjects
    );

DWORD
GenerateAllNegPolsQuery(
    LPWSTR * ppszNegPolString
    );

DWORD
DirSetNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    );

DWORD
DirSetNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    );

DWORD
DirCreateNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    );

DWORD
DirCreateNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    );

DWORD
DirDeleteNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier
    );

DWORD
DirMarshallAddNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    LDAPModW *** pppLDAPModW
    );

DWORD
DirMarshallSetNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    LDAPModW *** pppLDAPModW
    );

DWORD
DirUnmarshallNegPolData(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    );

DWORD
DirMarshallNegPolObject(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObject
    );

DWORD
DirGetNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolGUID,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    );

DWORD
DirGetNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolGUID,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObject
    );

DWORD
GenerateSpecificNegPolQuery(
    GUID NegPolIdentifier,
    LPWSTR * ppszNegPolString
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\negpols-d.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       negpols-d.c
//
//  Contents:   NegPol management for directory.
//
//
//  History:    KrishnaG
//              AbhisheV
//
//----------------------------------------------------------------------------

#include "precomp.h"


extern LPWSTR NegPolDNAttributes[];

DWORD
DirEnumNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_DATA ** pppIpsecNegPolData,
    PDWORD pdwNumNegPolObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData = NULL;
    DWORD dwNumNegPolObjects = 0;
    DWORD i = 0;
    DWORD j = 0;


    dwError = DirEnumNegPolObjects(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    &ppIpsecNegPolObjects,
                    &dwNumNegPolObjects
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumNegPolObjects) {
        ppIpsecNegPolData = (PIPSEC_NEGPOL_DATA *) AllocPolMem(
                            dwNumNegPolObjects*sizeof(PIPSEC_NEGPOL_DATA));
        if (!ppIpsecNegPolData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumNegPolObjects; i++) {

        dwError = DirUnmarshallNegPolData(
                        *(ppIpsecNegPolObjects + i),
                        &pIpsecNegPolData
                        );
        if (!dwError) {
            *(ppIpsecNegPolData + j) = pIpsecNegPolData;
            j++;
        }
    }

    if (j == 0) {
        if (ppIpsecNegPolData) {
            FreePolMem(ppIpsecNegPolData);
            ppIpsecNegPolData = NULL;
        }
    }

    *pppIpsecNegPolData = ppIpsecNegPolData;
    *pdwNumNegPolObjects = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecNegPolObjects) {
        FreeIpsecNegPolObjects(
                ppIpsecNegPolObjects,
                dwNumNegPolObjects
                );
    }

    return(dwError);

error:

    if (ppIpsecNegPolData) {
        FreeMulIpsecNegPolData(
                ppIpsecNegPolData,
                i
                );
    }

    *pppIpsecNegPolData = NULL;
    *pdwNumNegPolObjects = 0;

    goto cleanup;
}


DWORD
DirEnumNegPolObjects(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecNegPolObjects,
    PDWORD pdwNumNegPolObjects
    )
{
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    DWORD dwError = 0;
    LPWSTR pszNegPolString = NULL;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject =  NULL;
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects = NULL;

    DWORD dwNumNegPolObjectsReturned = 0;

    dwError = GenerateAllNegPolsQuery(
                    &pszNegPolString
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszNegPolString,
                  NegPolDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                    hLdapBindHandle,
                    res
                    );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppIpsecNegPolObjects  = (PIPSEC_NEGPOL_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_NEGPOL_OBJECT)*dwCount
                                            );
    if (!ppIpsecNegPolObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwCount; i++) {

        if (i == 0) {

            dwError = LdapFirstEntry(
                            hLdapBindHandle,
                            res,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        } else {

            dwError = LdapNextEntry(
                            hLdapBindHandle,
                            e,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        }

        dwError =UnMarshallNegPolObject(
                     hLdapBindHandle,
                     e,
                     &pIpsecNegPolObject
                     );
        if (dwError == ERROR_SUCCESS) {
            *(ppIpsecNegPolObjects + dwNumNegPolObjectsReturned) = pIpsecNegPolObject;
            dwNumNegPolObjectsReturned++;
        }

    }

    *pppIpsecNegPolObjects = ppIpsecNegPolObjects;
    *pdwNumNegPolObjects = dwNumNegPolObjectsReturned;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszNegPolString) {
        FreePolMem(pszNegPolString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    return(dwError);

error:

    if (ppIpsecNegPolObjects) {
        FreeIpsecNegPolObjects(
            ppIpsecNegPolObjects,
            dwNumNegPolObjectsReturned
            );
    }

    *pppIpsecNegPolObjects = NULL;
    *pdwNumNegPolObjects = 0;

    goto cleanup;
}


DWORD
DirSetNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;

    dwError = DirMarshallNegPolObject(
                    pIpsecNegPolData,
                    pszIpsecRootContainer,
                    &pIpsecNegPolObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirSetNegPolObject(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    pIpsecNegPolObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirBackPropIncChangesForNegPolToNFA(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pIpsecNegPolData->NegPolIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(pIpsecNegPolObject);
    }

    return(dwError);
}


DWORD
DirSetNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;

    dwError = DirMarshallSetNegPolObject(
                        hLdapBindHandle,
                        pszIpsecRootContainer,
                        pIpsecNegPolObject,
                        &ppLDAPModW
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pIpsecNegPolObject->pszDistinguishedName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    //
    // Free the amods structures.
    //

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirCreateNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;

    dwError = DirMarshallNegPolObject(
                        pIpsecNegPolData,
                        pszIpsecRootContainer,
                        &pIpsecNegPolObject
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirCreateNegPolObject(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    pIpsecNegPolObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(
            pIpsecNegPolObject
            );
    }

    return(dwError);
}


DWORD
DirCreateNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;


    dwError = DirMarshallAddNegPolObject(
                        hLdapBindHandle,
                        pszIpsecRootContainer,
                        pIpsecNegPolObject,
                        &ppLDAPModW
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapAddS(
                    hLdapBindHandle,
                    pIpsecNegPolObject->pszDistinguishedName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    //
    // Free the amods structures.
    //

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirDeleteNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';

    dwError = UuidToString(
                  &NegPolIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szDistinguishedName,L"CN=ipsecNegotiationPolicy");
    wcscat(szDistinguishedName, szGuid);
    wcscat(szDistinguishedName, L",");
    SecStrCatW(szDistinguishedName, pszIpsecRootContainer, MAX_PATH);

    dwError = LdapDeleteS(
                  hLdapBindHandle,
                  szDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);
}


DWORD
DirMarshallAddNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    LDAPModW *** pppLDAPModW
    )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 8;
    DWORD dwError = 0;
    WCHAR Buffer[64];


    if (!pIpsecNegPolObject->pszIpsecName ||
        !*pIpsecNegPolObject->pszIpsecName) {
        dwNumAttributes--;
    }

    if (!pIpsecNegPolObject->pszDescription ||
        !*pIpsecNegPolObject->pszDescription) {
        dwNumAttributes--;
    }

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // 0. objectClass
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"objectClass",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    L"ipsecNegotiationPolicy",
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 1. ipsecName
    //

    if (pIpsecNegPolObject->pszIpsecName &&
        *pIpsecNegPolObject->pszIpsecName) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"ipsecName",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecNegPolObject->pszIpsecName,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 2. ipsecID
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecID",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecNegPolObject->pszIpsecID,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 3. ipsecDataType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecDataType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( pIpsecNegPolObject->dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                    Buffer,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 4. ipsecData
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecData",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPBinaryValue(
                    pIpsecNegPolObject->pIpsecData,
                    pIpsecNegPolObject->dwIpsecDataLen,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;

    i++;

    //
    // 5. description
    //

    if (pIpsecNegPolObject->pszDescription &&
        *pIpsecNegPolObject->pszDescription) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"description",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecNegPolObject->pszDescription,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 6. ipsecNegotiationPolicyAction
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecNegotiationPolicyAction",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecNegPolObject->pszIpsecNegPolAction,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 7. ipsecNegotiationPolicyType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecNegotiationPolicyType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecNegPolObject->pszIpsecNegPolType,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    *pppLDAPModW = ppLDAPModW;

    return(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    *pppLDAPModW = NULL;

    return(dwError);
}


DWORD
DirMarshallSetNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    LDAPModW *** pppLDAPModW
    )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 7;
    DWORD dwError = 0;
    WCHAR Buffer[64];


    if (!pIpsecNegPolObject->pszIpsecName ||
        !*pIpsecNegPolObject->pszIpsecName) {
        dwNumAttributes--;
    }

    if (!pIpsecNegPolObject->pszDescription ||
        !*pIpsecNegPolObject->pszDescription) {
        dwNumAttributes--;
    }

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // 1. ipsecName
    //

    if (pIpsecNegPolObject->pszIpsecName &&
        *pIpsecNegPolObject->pszIpsecName) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"ipsecName",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecNegPolObject->pszIpsecName,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 2. ipsecID
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecID",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecNegPolObject->pszIpsecID,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 3. ipsecDataType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecDataType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( pIpsecNegPolObject->dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                    Buffer,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 4. ipsecData
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecData",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPBinaryValue(
                    pIpsecNegPolObject->pIpsecData,
                    pIpsecNegPolObject->dwIpsecDataLen,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;

    i++;

    //
    // 5. description
    //

    if (pIpsecNegPolObject->pszDescription &&
        *pIpsecNegPolObject->pszDescription) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"description",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecNegPolObject->pszDescription,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 6. ipsecNegotiationPolicyAction
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecNegotiationPolicyAction",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecNegPolObject->pszIpsecNegPolAction,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 7. ipsecNegotiationPolicyType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecNegotiationPolicyType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecNegPolObject->pszIpsecNegPolType,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    *pppLDAPModW = ppLDAPModW;

    return(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    *pppLDAPModW = NULL;

    return(dwError);
}


DWORD
GenerateAllNegPolsQuery(
    LPWSTR * ppszNegPolString
    )
{
    DWORD dwError = 0;
    DWORD dwLength = 0;
    LPWSTR pszNegPolString = NULL;


    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(objectclass=ipsecNegotiationPolicy)");

    pszNegPolString = (LPWSTR) AllocPolMem((dwLength + 1)*sizeof(WCHAR));

    if (!pszNegPolString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Now fill in the buffer
    //

    wcscpy(pszNegPolString, L"(objectclass=ipsecNegotiationPolicy)");

    *ppszNegPolString = pszNegPolString;

    return(0);

error:

    if (pszNegPolString) {
        FreePolMem(pszNegPolString);
    }

    *ppszNegPolString = NULL;

    return(dwError);
}


DWORD
DirUnmarshallNegPolData(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallNegPolObject(
                  pIpsecNegPolObject,
                  ppIpsecNegPolData
                  );

    return(dwError);
}


DWORD
DirMarshallNegPolObject(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObject
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;
    LPWSTR pszNegPolActionUuid = NULL;
    LPWSTR pszNegPolTypeUuid = NULL;
    WCHAR szGuidAction[MAX_PATH];
    WCHAR szGuidType[MAX_PATH];


    szGuidAction[0] = L'\0';
    szGuidType[0] = L'\0';
    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';
    pIpsecNegPolObject = (PIPSEC_NEGPOL_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_NEGPOL_OBJECT)
                                                    );
    if (!pIpsecNegPolObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecNegPolData->NegPolIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    //
    // Fill in the distinguishedName
    //

    wcscpy(szDistinguishedName,L"CN=ipsecNegotiationPolicy");
    wcscat(szDistinguishedName, szGuid);
    wcscat(szDistinguishedName, L",");
    SecStrCatW(szDistinguishedName, pszIpsecRootContainer, MAX_PATH);

    pIpsecNegPolObject->pszDistinguishedName = AllocPolStr(
                                                    szDistinguishedName
                                                    );
    if (!pIpsecNegPolObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Fill in the ipsecName
    //

    if (pIpsecNegPolData->pszIpsecName &&
        *pIpsecNegPolData->pszIpsecName) {
        pIpsecNegPolObject->pszIpsecName = AllocPolStr(
                                           pIpsecNegPolData->pszIpsecName
                                           );
        if (!pIpsecNegPolObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNegPolData->pszDescription &&
        *pIpsecNegPolData->pszDescription) {
        pIpsecNegPolObject->pszDescription = AllocPolStr(
                                             pIpsecNegPolData->pszDescription
                                             );
        if (!pIpsecNegPolObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //
    // Fill in the ipsecID
    //

    pIpsecNegPolObject->pszIpsecID = AllocPolStr(
                                         szGuid
                                         );
    if (!pIpsecNegPolObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecNegPolData->NegPolAction,
                    &pszNegPolActionUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szGuidAction, L"{");
    wcscat(szGuidAction, pszNegPolActionUuid);
    wcscat(szGuidAction, L"}");

    pIpsecNegPolObject->pszIpsecNegPolAction = AllocPolStr(
                                                    szGuidAction
                                                    );
    if (!pIpsecNegPolObject->pszIpsecNegPolAction) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecNegPolData->NegPolType,
                    &pszNegPolTypeUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szGuidType, L"{");
    wcscat(szGuidType, pszNegPolTypeUuid);
    wcscat(szGuidType, L"}");

    pIpsecNegPolObject->pszIpsecNegPolType = AllocPolStr(
                                                 szGuidType
                                                 );
    if (!pIpsecNegPolObject->pszIpsecNegPolType) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Fill in the ipsecDataType
    //

    pIpsecNegPolObject->dwIpsecDataType = 0x100;


    //
    // Marshall the pIpsecDataBuffer and the Length
    //

    dwError = MarshallNegPolBuffer(
                    pIpsecNegPolData,
                    &pBuffer,
                    &dwBufferLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNegPolObject->pIpsecData  = pBuffer;

    pIpsecNegPolObject->dwIpsecDataLen = dwBufferLen;

    pIpsecNegPolObject->dwWhenChanged = 0;

    *ppIpsecNegPolObject = pIpsecNegPolObject;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }
    if (pszNegPolActionUuid) {
        RpcStringFree(
            &pszNegPolActionUuid
            );
    }
    if (pszNegPolTypeUuid) {
        RpcStringFree(
            &pszNegPolTypeUuid
            );
    }

    return(dwError);

error:

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(
                pIpsecNegPolObject
                );
    }

    *ppIpsecNegPolObject = NULL;
    goto cleanup;
}


DWORD
DirGetNegPolData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolGUID,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;


    dwError = DirGetNegPolObject(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  NegPolGUID,
                  &pIpsecNegPolObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirUnmarshallNegPolData(
                  pIpsecNegPolObject,
                  &pIpsecNegPolData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecNegPolData = pIpsecNegPolData;

cleanup:

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(
            pIpsecNegPolObject
            );
    }

    return(dwError);

error:

    *ppIpsecNegPolData = NULL;

    goto cleanup;
}


DWORD
DirGetNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolGUID,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObject
    )
{
    DWORD dwError = 0;
    LPWSTR pszNegPolString = NULL;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;
    LDAPMessage * e = NULL;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject =  NULL;


    dwError = GenerateSpecificNegPolQuery(
                  NegPolGUID,
                  &pszNegPolString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszNegPolString,
                  NegPolDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallNegPolObject(
                  hLdapBindHandle,
                  e,
                  &pIpsecNegPolObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecNegPolObject = pIpsecNegPolObject;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszNegPolString) {
        FreePolMem(pszNegPolString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    return(dwError);

error:

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(
            pIpsecNegPolObject
            );
    }

    *ppIpsecNegPolObject = NULL;

    goto cleanup;
}


DWORD
GenerateSpecificNegPolQuery(
    GUID NegPolIdentifier,
    LPWSTR * ppszNegPolString
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;
    DWORD dwLength = 0;
    LPWSTR pszNegPolString = NULL;


    szGuid[0] = L'\0';
    szCommonName[0] = L'\0';

    dwError = UuidToString(
                  &NegPolIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szCommonName, L"cn=ipsecNegotiationPolicy");
    wcscat(szCommonName, szGuid);

    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(&(objectclass=ipsecNegotiationPolicy)");
    dwLength += wcslen(L"(");
    dwLength += wcslen(szCommonName);
    dwLength += wcslen(L"))");

    pszNegPolString = (LPWSTR) AllocPolMem((dwLength + 1)*sizeof(WCHAR));

    if (!pszNegPolString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    wcscpy(pszNegPolString, L"(&(objectclass=ipsecNegotiationPolicy)");
    wcscat(pszNegPolString, L"(");
    wcscat(pszNegPolString, szCommonName);
    wcscat(pszNegPolString, L"))");

    *ppszNegPolString = pszNegPolString;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    if (pszNegPolString) {
        FreePolMem(pszNegPolString);
    }

    *ppszNegPolString = NULL;

    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\isakmp-w.h ===
DWORD
WMIEnumISAKMPDataEx(
    IWbemServices *pWbemServices,
    PIPSEC_ISAKMP_DATA ** pppIpsecISAKMPData,
    PDWORD pdwNumISAKMPObjects
    );

DWORD
WMIEnumISAKMPObjectsEx(
    IWbemServices *pWbemServices,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecISAKMPObjects,
    PDWORD pdwNumISAKMPObjects
    );

DWORD
WMIUnmarshallISAKMPData(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    );

DWORD
WMIGetISAKMPDataEx(
    IWbemServices *pWbemServices,
    GUID ISAKMPGUID,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\isakmp-w.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       isakmp-w.c
//
//  Contents:   ISAKMP management for WMI.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//              t-hhsu
//
//----------------------------------------------------------------------------

#include "precomp.h"

//extern LPWSTR ISAKMPDNAttributes[];


DWORD
WMIEnumISAKMPDataEx(
    IWbemServices *pWbemServices,
    PIPSEC_ISAKMP_DATA ** pppIpsecISAKMPData,
    PDWORD pdwNumISAKMPObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects = NULL;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData = NULL;
    DWORD dwNumISAKMPObjects = 0;
    DWORD i = 0;
    DWORD j = 0;



    dwError = WMIEnumISAKMPObjectsEx(
        pWbemServices,
        &ppIpsecISAKMPObjects,
        &dwNumISAKMPObjects
        );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumISAKMPObjects) {
        ppIpsecISAKMPData = (PIPSEC_ISAKMP_DATA *) AllocPolMem(
            dwNumISAKMPObjects*sizeof(PIPSEC_ISAKMP_DATA));
        if (!ppIpsecISAKMPData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    for (i = 0; i < dwNumISAKMPObjects; i++) {
        dwError = WMIUnmarshallISAKMPData(
            *(ppIpsecISAKMPObjects + i),
            &pIpsecISAKMPData
            );
        if (!dwError) {
            *(ppIpsecISAKMPData + j) = pIpsecISAKMPData;
            j++;
        }
    }
    
    if (j == 0) {
        if (ppIpsecISAKMPData) {
            FreePolMem(ppIpsecISAKMPData);
            ppIpsecISAKMPData = NULL;
        }
    }
    
    *pppIpsecISAKMPData = ppIpsecISAKMPData;
    *pdwNumISAKMPObjects = j;
    
    dwError = ERROR_SUCCESS;
    
 cleanup:
    
    if (ppIpsecISAKMPObjects) {
        FreeIpsecISAKMPObjects(
            ppIpsecISAKMPObjects,
            dwNumISAKMPObjects
            );
    }
    
    return(dwError);
    
    
 error:
    
    if (ppIpsecISAKMPData) {
        FreeMulIpsecISAKMPData(
            ppIpsecISAKMPData,
            i
            );
    }
    
    *pppIpsecISAKMPData = NULL;
    *pdwNumISAKMPObjects = 0;
    
    goto cleanup;
}


DWORD
WMIEnumISAKMPObjectsEx(
    IWbemServices *pWbemServices,
    PIPSEC_ISAKMP_OBJECT ** pppIpsecISAKMPObjects,
    PDWORD pdwNumISAKMPObjects
    )
{
    DWORD dwError = 0;
    HRESULT hr = S_OK;    
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject =  NULL;
    PIPSEC_ISAKMP_OBJECT * ppIpsecISAKMPObjects = NULL;
    DWORD dwNumISAKMPObjectsReturned = 0;

    ///wbem
    IEnumWbemClassObject *pEnum = NULL;
    IWbemClassObject *pObj = NULL;
    ULONG uReturned = 0;
    VARIANT var;
    LPWSTR tmpStr = NULL;
    BSTR bstrTmp = NULL;



    *pppIpsecISAKMPObjects = NULL;
    *pdwNumISAKMPObjects = 0;

    VariantInit(&var);
    
    bstrTmp = SysAllocString(L"RSOP_IPSECPolicySetting");
    if(!bstrTmp) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //get enum
    hr = IWbemServices_CreateInstanceEnum(
        pWbemServices,
        bstrTmp, //L"RSOP_IPSECPolicySetting"
        WBEM_FLAG_FORWARD_ONLY,
        0,
        &pEnum
        );
    SysFreeString(bstrTmp);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

    uReturned = 1;
    while (SUCCEEDED(hr) && (uReturned == 1))
    {
        hr = IEnumWbemClassObject_Next(pEnum, WBEM_INFINITE, 1, &pObj, &uReturned);
        
        if (SUCCEEDED(hr) && (uReturned == 1))
        {
            hr = IWbemClassObject_Get(
                pObj,
                L"id",
                0,
                &var,
                0,
                0
                );
            BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
            
            tmpStr = var.bstrVal;

            if (!wcsstr(tmpStr, L"ipsecISAKMPPolicy")) {
                IWbemClassObject_Release(pObj);
                VariantClear(&var);
                continue;
            }
            
            pIpsecISAKMPObject = NULL;
            
            dwError = UnMarshallWMIISAKMPObject(
                pObj,
                &pIpsecISAKMPObject
                );
            if (dwError == ERROR_SUCCESS) {
                dwError = ReallocatePolMem(
                    (LPVOID *) &ppIpsecISAKMPObjects,
                    sizeof(PIPSEC_ISAKMP_OBJECT)*(dwNumISAKMPObjectsReturned),
                    sizeof(PIPSEC_ISAKMP_OBJECT)*(dwNumISAKMPObjectsReturned + 1)
                    );
                BAIL_ON_WIN32_ERROR(dwError);
                
                *(ppIpsecISAKMPObjects + dwNumISAKMPObjectsReturned) = pIpsecISAKMPObject;
                dwNumISAKMPObjectsReturned++;
            }
            IWbemClassObject_Release(pObj);
            pObj = NULL;
            VariantClear(&var);
        } else {
            BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

            //
            // Even if SUCCEEDED(hr), loop will still terminate since uReturned != 1
            //  
        }
    }

    *pppIpsecISAKMPObjects = ppIpsecISAKMPObjects;
    *pdwNumISAKMPObjects = dwNumISAKMPObjectsReturned;

    dwError = ERROR_SUCCESS;

 cleanup:
    
    if(pEnum)
        IEnumWbemClassObject_Release(pEnum);

    return(dwError);

 error:
     if (pObj) {
        IWbemClassObject_Release(pObj);
        pObj = NULL;
     }
     VariantClear(&var);

    if (ppIpsecISAKMPObjects) {
        FreeIpsecISAKMPObjects(
            ppIpsecISAKMPObjects,
            dwNumISAKMPObjectsReturned
            );
    }
    
    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(
            pIpsecISAKMPObject
            );
    }
    
    *pppIpsecISAKMPObjects = NULL;
    *pdwNumISAKMPObjects = 0;
    
    goto cleanup;

}


DWORD
WMIUnmarshallISAKMPData(
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallISAKMPObject(
                    pIpsecISAKMPObject,
                    ppIpsecISAKMPData
                    );
    BAIL_ON_WIN32_ERROR(dwError);                    
    if (*ppIpsecISAKMPData) {
        (*ppIpsecISAKMPData)->dwFlags |= POLSTORE_READONLY;
    }
error:    
    return(dwError);
}


DWORD
WMIGetISAKMPDataEx(
    IWbemServices *pWbemServices,
    GUID ISAKMPGUID,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;
    WCHAR szIpsecISAKMPName[MAX_PATH];
    LPWSTR pszISAKMPName = NULL;
    HRESULT hr = S_OK;

    ///wbem
    IWbemClassObject *pObj = NULL;
    LPWSTR objPathA = L"RSOP_IPSECPolicySetting.id=";
    LPWSTR objPath = NULL;
    BSTR bstrObjPath = NULL;



    szIpsecISAKMPName[0] = L'\0';
    wcscpy(szIpsecISAKMPName, L"ipsecISAKMPPolicy");
    
    dwError = UuidToString(&ISAKMPGUID, &pszISAKMPName);
    BAIL_ON_WIN32_ERROR(dwError);
    
    wcscat(szIpsecISAKMPName, L"{");
    wcscat(szIpsecISAKMPName, pszISAKMPName);
    wcscat(szIpsecISAKMPName, L"}");
    
    objPath = (LPWSTR)AllocPolMem(
        sizeof(WCHAR)*(wcslen(objPathA)+wcslen(szIpsecISAKMPName)+3)
        );
    if(!objPath) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    wcscpy(objPath, objPathA);
    wcscat(objPath, L"\"");
    wcscat(objPath, szIpsecISAKMPName);
    wcscat(objPath, L"\"");
    
    bstrObjPath = SysAllocString(objPath);
    if(!bstrObjPath) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    hr = IWbemServices_GetObject(
        pWbemServices,
        bstrObjPath,
        WBEM_FLAG_RETURN_WBEM_COMPLETE,
        0,
        &pObj,
        0
        );
    SysFreeString(bstrObjPath);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

    dwError = UnMarshallWMIISAKMPObject(
        pObj,
        &pIpsecISAKMPObject
        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = WMIUnmarshallISAKMPData(
        pIpsecISAKMPObject,
        &pIpsecISAKMPData
        );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecISAKMPData = pIpsecISAKMPData;

 cleanup:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(
                pIpsecISAKMPObject
                );
    }

    if (pszISAKMPName) {
        RpcStringFree(&pszISAKMPName);
    }

    if(pObj)
        IWbemClassObject_Release(pObj);
    
    if(objPath) {
        FreePolStr(objPath);
    }

    return(dwError);

 error: 
    
    *ppIpsecISAKMPData = NULL;
    
    goto cleanup;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\negpols-f.c ===
#include "precomp.h"


DWORD
ExportNegPolDataToFile(
    HANDLE hSrcPolicyStore,
    PIPSEC_POLICY_STORE pDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData = NULL;
    DWORD dwNumNegPolObjects = 0;
    DWORD i = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;


    dwError = IPSecEnumNegPolData(
                  hSrcPolicyStore,
                  &ppIpsecNegPolData,
                  &dwNumNegPolObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    for (i = 0; i < dwNumNegPolObjects; i++) {

        pIpsecNegPolData = *(ppIpsecNegPolData + i);

        dwError = RegCreateNegPolData(
                      pDesPolicyStore->hRegistryKey,
                      pDesPolicyStore->pszIpsecRootContainer,
                      pIpsecNegPolData
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (ppIpsecNegPolData) {
        FreeMulIpsecNegPolData(
            ppIpsecNegPolData,
            dwNumNegPolObjects
            );
    }

    return (dwError);
}


DWORD
ImportNegPolDataFromFile(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData = NULL;
    DWORD dwNumNegPolObjects = 0;
    DWORD i = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;


    dwError = RegEnumNegPolData(
                  pSrcPolicyStore->hRegistryKey,
                  pSrcPolicyStore->pszIpsecRootContainer,
                  &ppIpsecNegPolData,
                  &dwNumNegPolObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    for (i = 0; i < dwNumNegPolObjects; i++) {

        pIpsecNegPolData = *(ppIpsecNegPolData + i);

        dwError = IPSecCreateNegPolData(
                      hDesPolicyStore,
                      pIpsecNegPolData
                      );
        if (dwError == ERROR_OBJECT_ALREADY_EXISTS) {
            dwError = IPSecSetNegPolData(
                          hDesPolicyStore,
                          pIpsecNegPolData
                          );
            BAIL_ON_WIN32_ERROR(dwError);
        }
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (ppIpsecNegPolData) {
        FreeMulIpsecNegPolData(
            ppIpsecNegPolData,
            dwNumNegPolObjects
            );
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\memory.c ===
#include "precomp.h"


LPVOID
IPSecAllocPolMem(
    DWORD cb
    )
{
    return AllocPolMem(cb);
}


BOOL
IPSecFreePolMem(
    LPVOID pMem
    )
{
    return FreePolMem(pMem);
}


LPWSTR
IPSecAllocPolStr(
    LPCWSTR pStr
    )
{
    return AllocPolStr(pStr);
}


BOOL
IPSecFreePolStr(
    LPWSTR pStr
    )
{
    return FreePolStr(pStr);
}


DWORD
IPSecReallocatePolMem(
    LPVOID * ppOldMem,
    DWORD cbOld,
    DWORD cbNew
    )
{
    return ReallocatePolMem(ppOldMem, cbOld, cbNew);
}


BOOL
IPSecReallocatePolStr(
    LPWSTR *ppStr,
    LPWSTR pStr
    )
{
    return ReallocPolStr(ppStr, pStr);
}


void
IPSecFreePolicyData(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    FreeIpsecPolicyData(pIpsecPolicyData);
}


void
IPSecFreeNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    )
{
    FreeIpsecNegPolData(pIpsecNegPolData);
}


void
IPSecFreeFilterData(
    PIPSEC_FILTER_DATA pIpsecFilterData
    )
{
    FreeIpsecFilterData(pIpsecFilterData);
}


void
IPSecFreeISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    )
{
    FreeIpsecISAKMPData(pIpsecISAKMPData);
}


void
IPSecFreeNFAData(
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    FreeIpsecNFAData(pIpsecNFAData);
}


DWORD
IPSecCopyPolicyData(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    return CopyIpsecPolicyData(pIpsecPolicyData, ppIpsecPolicyData);
}


DWORD
IPSecCopyNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    )
{
    return CopyIpsecNegPolData(pIpsecNegPolData, ppIpsecNegPolData);
}


DWORD
IPSecCopyFilterData(
    PIPSEC_FILTER_DATA pIpsecFilterData,
    PIPSEC_FILTER_DATA * ppIpsecFilterData
    )
{
    return CopyIpsecFilterData(pIpsecFilterData, ppIpsecFilterData);
}


DWORD
IPSecCopyFilterSpec(
    PIPSEC_FILTER_SPEC   pFilterSpecs,
    PIPSEC_FILTER_SPEC * ppFilterSpecs
    )
{
    return CopyIpsecFilterSpec(pFilterSpecs, ppFilterSpecs);
}


DWORD
IPSecCopyISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    )
{
    return CopyIpsecISAKMPData(pIpsecISAKMPData, ppIpsecISAKMPData);
}


DWORD
IPSecCopyNFAData(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    )
{
    return CopyIpsecNFAData(pIpsecNFAData, ppIpsecNFAData);
}


DWORD
IPSecCopyAuthMethod(
    PIPSEC_AUTH_METHOD   pAuthMethod,
    PIPSEC_AUTH_METHOD * ppAuthMethod
    )
{
    return CopyIpsecAuthMethod(pAuthMethod, ppAuthMethod);
}


void
IPSecFreeMulPolicyData(
    PIPSEC_POLICY_DATA * ppIpsecPolicyData,
    DWORD dwNumPolicyObjects
    )
{
    FreeMulIpsecPolicyData(ppIpsecPolicyData, dwNumPolicyObjects);
}


void
IPSecFreeMulNegPolData(
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData,
    DWORD dwNumNegPolObjects
    )
{
    FreeMulIpsecNegPolData(ppIpsecNegPolData, dwNumNegPolObjects);
}


void
IPSecFreeMulFilterData(
    PIPSEC_FILTER_DATA * ppIpsecFilterData,
    DWORD dwNumFilterObjects
    )
{
    FreeMulIpsecFilterData(ppIpsecFilterData, dwNumFilterObjects);
}


void
IPSecFreeFilterSpecs(
    PIPSEC_FILTER_SPEC * ppIpsecFilterSpecs,
    DWORD dwNumFilterSpecs
    )
{
    FreeIpsecFilterSpecs(ppIpsecFilterSpecs, dwNumFilterSpecs);
}


void
IPSecFreeFilterSpec(
    PIPSEC_FILTER_SPEC pIpsecFilterSpec
    )
{
    FreeIpsecFilterSpec(pIpsecFilterSpec);
}


void
IPSecFreeMulISAKMPData(
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData,
    DWORD dwNumISAKMPObjects
    )
{
    FreeMulIpsecISAKMPData(ppIpsecISAKMPData, dwNumISAKMPObjects);
}


void
IPSecFreeMulNFAData(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFAObjects
    )
{
    FreeMulIpsecNFAData(ppIpsecNFAData, dwNumNFAObjects);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\ldaputils.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       ldaputils.c
//
//  Contents:   Utilities for LDAP.
//
//
//  History:    KrishnaG
//              AbhisheV
//
//----------------------------------------------------------------------------


#include "precomp.h"


void
FreeLDAPModWs(
    struct ldapmodW ** AttributeList
    )
{
    DWORD i = 0;
    PLDAPModW attr = NULL;
    DWORD dwValCount = 0;
    PLDAP_BERVAL berValue = NULL;
    PWCHAR strValue = NULL;


    if (AttributeList == NULL) {
        return;
    }

    while (AttributeList[i] != NULL) {

        attr = AttributeList[i++];

        if (attr->mod_type != NULL) {
            FreePolStr(attr->mod_type);
        }

        if (attr->mod_op & LDAP_MOD_BVALUES) {

            if (attr->mod_vals.modv_bvals != NULL) {

                dwValCount = 0;

                while (attr->mod_vals.modv_bvals[dwValCount]) {

                    berValue = attr->mod_vals.modv_bvals[dwValCount++];
                    FreePolMem(berValue);

                }

                FreePolMem(attr->mod_vals.modv_bvals);

            }

        } else {

            if (attr->mod_vals.modv_strvals != NULL) {

                dwValCount = 0;

                while (attr->mod_vals.modv_strvals[dwValCount]) {

                    strValue = attr->mod_vals.modv_strvals[dwValCount];
                    FreePolMem(strValue);
                    dwValCount++;

                }

                FreePolMem(attr->mod_vals.modv_strvals);

            }

        }

    }

    FreePolMem(AttributeList[0]);

    FreePolMem(AttributeList);

    return;
}


DWORD
AllocateLDAPStringValue(
    LPWSTR pszString,
    PLDAPOBJECT * ppLdapObject
    )
{
    PLDAPOBJECT pLdapObject = NULL;
    DWORD dwError = 0;
    LPWSTR pszNewString = NULL;

    pLdapObject = (PLDAPOBJECT)AllocPolMem(
                                    (1 + 1)*sizeof(LDAPOBJECT)
                                    );
    if (!pLdapObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = AllocatePolString(
                    pszString,
                    &pszNewString
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    LDAPOBJECT_STRING(pLdapObject) = pszNewString;

    *ppLdapObject = pLdapObject;

    return(dwError);

error:

    *ppLdapObject = NULL;
    if (pLdapObject) {
        FreePolMem(
            pLdapObject
            );
    }

    return(dwError);
}


DWORD
AllocateLDAPBinaryValue(
    LPBYTE pByte,
    DWORD dwNumBytes,
    PLDAPOBJECT * ppLdapObject
    )
{
    PLDAPOBJECT pLdapObject = NULL;
    DWORD dwError = 0;
    LPBYTE pNewMem = NULL;

    pLdapObject = (PLDAPOBJECT)AllocPolMem(
                                    (1 + 1)*sizeof(LDAPOBJECT)
                                    );
    if (!pLdapObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    LDAPOBJECT_BERVAL(pLdapObject) =
        (struct berval *) AllocPolMem( sizeof(struct berval) + dwNumBytes );

    if (!LDAPOBJECT_BERVAL(pLdapObject)) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    LDAPOBJECT_BERVAL_LEN(pLdapObject) = dwNumBytes;
    LDAPOBJECT_BERVAL_VAL(pLdapObject) = (CHAR *) ((LPBYTE) LDAPOBJECT_BERVAL(pLdapObject) + sizeof(struct berval));

    memcpy( LDAPOBJECT_BERVAL_VAL(pLdapObject),
            pByte,
            dwNumBytes );

    *ppLdapObject = pLdapObject;

    return(dwError);

error:

    *ppLdapObject = NULL;
    if (pLdapObject) {
        FreePolMem(
            pLdapObject
            );
    }

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\negpols-f.h ===
DWORD
ExportNegPolDataToFile(
    HANDLE hSrcPolicyStore,
    PIPSEC_POLICY_STORE pDesPolicyStore
    );

DWORD
ImportNegPolDataFromFile(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\negpols-w.h ===
DWORD
WMIEnumNegPolDataEx(
    IWbemServices *pWbemServices,
    PIPSEC_NEGPOL_DATA ** pppIpsecNegPolData,
    PDWORD pdwNumNegPolObjects
    );

DWORD
WMIEnumNegPolObjectsEx(
    IWbemServices *pWbemServices,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecNegPolObjects,
    PDWORD pdwNumNegPolObjects
    );

DWORD
WMIUnmarshallNegPolData(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    );

DWORD
WMIGetNegPolDataEx(
    IWbemServices *pWbemServices,
    GUID NegPolGUID,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\policy-f.h ===
DWORD
ExportPolicyDataToFile(
    HANDLE hSrcPolicyStore,
    PIPSEC_POLICY_STORE pDesPolicyStore,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    );

DWORD
ImportPolicyDataFromFile(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\negpols-r.h ===
DWORD
RegEnumNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_DATA ** pppIpsecNegPolData,
    PDWORD pdwNumNegPolObjects
    );

DWORD
RegEnumNegPolObjects(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecNegPolObjects,
    PDWORD pdwNumNegPolObjects
    );

DWORD
RegSetNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    );

DWORD
RegSetNegPolObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    );

DWORD
RegCreateNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    );

DWORD
RegCreateNegPolObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    );

DWORD
RegDeleteNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier
    );

DWORD
RegUnmarshallNegPolData(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    );

DWORD
RegMarshallNegPolObject(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObject
    );


DWORD
MarshallNegPolBuffer(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    LPBYTE * ppBuffer,
    DWORD * pdwBufferLen
    );


DWORD
RegGetNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolGUID,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\negpols-w.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       negpols-w.c
//
//  Contents:   Negotiation Policy management for WMI.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//              t-hhsu
//
//----------------------------------------------------------------------------

#include "precomp.h"

//extern LPWSTR NegPolDNAttributes[];


DWORD
WMIEnumNegPolDataEx(
    IWbemServices *pWbemServices,
    PIPSEC_NEGPOL_DATA ** pppIpsecNegPolData,
    PDWORD pdwNumNegPolObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData = NULL;
    DWORD dwNumNegPolObjects = 0;
    DWORD i = 0;
    DWORD j = 0;



    dwError = WMIEnumNegPolObjectsEx(
        pWbemServices,
        &ppIpsecNegPolObjects,
        &dwNumNegPolObjects
        );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumNegPolObjects) {
        ppIpsecNegPolData = (PIPSEC_NEGPOL_DATA *) AllocPolMem(
            dwNumNegPolObjects*sizeof(PIPSEC_NEGPOL_DATA));
        if (!ppIpsecNegPolData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    for (i = 0; i < dwNumNegPolObjects; i++) {
        dwError = WMIUnmarshallNegPolData(
            *(ppIpsecNegPolObjects + i),
            &pIpsecNegPolData
            );
        if (!dwError) {
            *(ppIpsecNegPolData + j) = pIpsecNegPolData;
            j++;
        }
    }
    
    if (j == 0) {
        if (ppIpsecNegPolData) {
            FreePolMem(ppIpsecNegPolData);
            ppIpsecNegPolData = NULL;
        }
    }

    *pppIpsecNegPolData = ppIpsecNegPolData;
    *pdwNumNegPolObjects = j;
    
    dwError = ERROR_SUCCESS;

 cleanup:

    if (ppIpsecNegPolObjects) {
        FreeIpsecNegPolObjects(
            ppIpsecNegPolObjects,
            dwNumNegPolObjects
            );
    }

    return(dwError);
    
 error:
    
    if (ppIpsecNegPolData) {
        FreeMulIpsecNegPolData(
            ppIpsecNegPolData,
            i
            );
    }

    *pppIpsecNegPolData = NULL;
    *pdwNumNegPolObjects = 0;
    
    goto cleanup;
}


DWORD
WMIEnumNegPolObjectsEx(
    IWbemServices *pWbemServices,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecNegPolObjects,
    PDWORD pdwNumNegPolObjects
    )
{
    DWORD dwError = 0;
    HRESULT hr = S_OK;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject =  NULL;
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects = NULL;
    DWORD dwNumNegPolObjectsReturned = 0;

    ///wbem
    IEnumWbemClassObject *pEnum = NULL;
    IWbemClassObject *pObj = NULL;
    ULONG uReturned = 0;
    VARIANT var;
    LPWSTR tmpStr = NULL;
    BSTR bstrTmp = NULL;



    *pppIpsecNegPolObjects = NULL;
    *pdwNumNegPolObjects = 0;

    VariantInit(&var);

    bstrTmp = SysAllocString(L"RSOP_IPSECPolicySetting");
    if(!bstrTmp) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //get enum
    hr = IWbemServices_CreateInstanceEnum(
        pWbemServices,
        bstrTmp, //L"RSOP_IPSECPolicySetting"
        WBEM_FLAG_FORWARD_ONLY,
        0,
        &pEnum
        );
    SysFreeString(bstrTmp);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

    
    uReturned = 1;
    while (SUCCEEDED(hr) && (uReturned == 1))
    {
        hr = IEnumWbemClassObject_Next(pEnum, WBEM_INFINITE, 1, &pObj, &uReturned);
        
        if (SUCCEEDED(hr) && (uReturned == 1))
        {
            hr = IWbemClassObject_Get(
                pObj,
                L"id",
                0,
                &var,
                0,
                0
                );
            BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
            
            tmpStr = var.bstrVal;
            
            if (!wcsstr(tmpStr, L"ipsecNegotiationPolicy")) {
                IWbemClassObject_Release(pObj);
                VariantClear(&var);
                continue;
            }

            pIpsecNegPolObject = NULL;

            dwError = UnMarshallWMINegPolObject(
                pObj,
                &pIpsecNegPolObject
                );
            if (dwError == ERROR_SUCCESS) {
                dwError = ReallocatePolMem(
                    (LPVOID *) &ppIpsecNegPolObjects,
                    sizeof(PIPSEC_NEGPOL_OBJECT)*(dwNumNegPolObjectsReturned),
                    sizeof(PIPSEC_NEGPOL_OBJECT)*(dwNumNegPolObjectsReturned + 1)
                    );
                BAIL_ON_WIN32_ERROR(dwError);
                
                *(ppIpsecNegPolObjects + dwNumNegPolObjectsReturned) = pIpsecNegPolObject;
                
                dwNumNegPolObjectsReturned++;
            }
            
            //free
            IWbemClassObject_Release(pObj);
            pObj = NULL;
            VariantClear(&var);
        } else {
            BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

            //
            // Even if SUCCEEDED(hr), loop will still terminate since uReturned != 1
            //  
        }
    }
    
    *pppIpsecNegPolObjects = ppIpsecNegPolObjects;
    *pdwNumNegPolObjects = dwNumNegPolObjectsReturned;
    
    dwError = ERROR_SUCCESS;
    
 cleanup:

    if(pEnum)
        IEnumWbemClassObject_Release(pEnum);
    
    return(dwError);

 error:
     if (pObj) {
        IWbemClassObject_Release(pObj);
        pObj = NULL;
     }
     VariantClear(&var);
  
    if (ppIpsecNegPolObjects) {
        FreeIpsecNegPolObjects(
            ppIpsecNegPolObjects,
            dwNumNegPolObjectsReturned
            );
    }
    
    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(
            pIpsecNegPolObject
            );
    }
    
    *pppIpsecNegPolObjects = NULL;
    *pdwNumNegPolObjects = 0;
    
    goto cleanup;

}


DWORD
WMIUnmarshallNegPolData(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallNegPolObject(
                    pIpsecNegPolObject,
                    ppIpsecNegPolData
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    if (*ppIpsecNegPolData) {
        (*ppIpsecNegPolData)->dwFlags |= POLSTORE_READONLY;
    }
error:    
    return(dwError);
}


DWORD
WMIGetNegPolDataEx(
    IWbemServices *pWbemServices,
    GUID NegPolGUID,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    )
{
    DWORD dwError = 0;
    HRESULT hr = S_OK;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    WCHAR szIpsecNegPolName[MAX_PATH];
    LPWSTR pszNegPolName = NULL;

    ///wbem
    IWbemClassObject *pObj = NULL;
    LPWSTR objPathA = L"RSOP_IPSECPolicySetting.id=";
    LPWSTR objPath = NULL;
    BSTR bstrObjPath = NULL;


    
    szIpsecNegPolName[0] = L'\0';
    wcscpy(szIpsecNegPolName, L"ipsecNegotiationPolicy");
    
    dwError = UuidToString(&NegPolGUID, &pszNegPolName);
    BAIL_ON_WIN32_ERROR(dwError);
    
    wcscat(szIpsecNegPolName, L"{");
    wcscat(szIpsecNegPolName, pszNegPolName);
    wcscat(szIpsecNegPolName, L"}");
    
    objPath = (LPWSTR)AllocPolMem(
        sizeof(WCHAR)*(wcslen(objPathA)+wcslen(szIpsecNegPolName)+3)
        );
    if(!objPath) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    wcscpy(objPath, objPathA);
    wcscat(objPath, L"\"");
    wcscat(objPath, szIpsecNegPolName);
    wcscat(objPath, L"\"");
    
    bstrObjPath = SysAllocString(objPath);
    if(!bstrObjPath) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    hr = IWbemServices_GetObject(
        pWbemServices,
        bstrObjPath,
        WBEM_FLAG_RETURN_WBEM_COMPLETE,
        0,
        &pObj,
        0
        );
    SysFreeString(bstrObjPath);

    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
    
    dwError = UnMarshallWMINegPolObject(
        pObj,
        &pIpsecNegPolObject
        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = WMIUnmarshallNegPolData(
        pIpsecNegPolObject,
        &pIpsecNegPolData
        );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecNegPolData = pIpsecNegPolData;
    
 cleanup:
    
    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(
            pIpsecNegPolObject
            );
    }
    
    if (pszNegPolName) {
        RpcStringFree(&pszNegPolName);
    }

    if(pObj)
        IWbemClassObject_Release(pObj);
    
    if(objPath) {
        FreePolStr(objPath);
    }
    
    return(dwError);
    
 error:

    *ppIpsecNegPolData = NULL;
    
    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\policy-f.c ===
#include "precomp.h"


DWORD
ExportPolicyDataToFile(
    HANDLE hSrcPolicyStore,
    PIPSEC_POLICY_STORE pDesPolicyStore,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_DATA * ppIpsecPolicyData = NULL;
    DWORD dwNumPolicyObjects = 0;
    DWORD i = 0;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;


    dwError = IPSecEnumPolicyData(
                  hSrcPolicyStore,
                  &ppIpsecPolicyData,
                  &dwNumPolicyObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    for (i = 0; i < dwNumPolicyObjects; i++) {

        pIpsecPolicyData = *(ppIpsecPolicyData + i);

        dwError = RegCreatePolicyData(
                      pDesPolicyStore->hRegistryKey,
                      pDesPolicyStore->pszIpsecRootContainer,
                      pIpsecPolicyData
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    *pppIpsecPolicyData = ppIpsecPolicyData;
    *pdwNumPolicyObjects = dwNumPolicyObjects;
    return (dwError);

error:

    if (ppIpsecPolicyData) {
        FreeMulIpsecPolicyData(
            ppIpsecPolicyData,
            dwNumPolicyObjects
            );
    }

    *pppIpsecPolicyData = NULL;
    *pdwNumPolicyObjects = 0;

    return (dwError);
}


DWORD
ImportPolicyDataFromFile(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_DATA * ppIpsecPolicyData = NULL;
    DWORD dwNumPolicyObjects = 0;
    DWORD i = 0;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;


    dwError = RegEnumPolicyData(
                  pSrcPolicyStore->hRegistryKey,
                  pSrcPolicyStore->pszIpsecRootContainer,
                  &ppIpsecPolicyData,
                  &dwNumPolicyObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    for (i = 0; i < dwNumPolicyObjects; i++) {

        pIpsecPolicyData = *(ppIpsecPolicyData + i);

        dwError = IPSecCreatePolicyData(
                      hDesPolicyStore,
                      pIpsecPolicyData
                      );
        if (dwError == ERROR_OBJECT_ALREADY_EXISTS) {
            dwError = IPSecSetPolicyData(
                          hDesPolicyStore,
                          pIpsecPolicyData
                          );
            BAIL_ON_WIN32_ERROR(dwError);
        }
        BAIL_ON_WIN32_ERROR(dwError);

    }

    *pppIpsecPolicyData = ppIpsecPolicyData;
    *pdwNumPolicyObjects = dwNumPolicyObjects;
    return (dwError);

error:

    if (ppIpsecPolicyData) {
        FreeMulIpsecPolicyData(
            ppIpsecPolicyData,
            dwNumPolicyObjects
            );
    }

    *pppIpsecPolicyData = NULL;
    *pdwNumPolicyObjects = 0;

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\negpols-r.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       negpols-r.c
//
//  Contents:   Negotiation Policy management for registry.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//
//----------------------------------------------------------------------------

#include "precomp.h"

extern LPWSTR NegPolDNAttributes[];


DWORD
RegEnumNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_DATA ** pppIpsecNegPolData,
    PDWORD pdwNumNegPolObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData = NULL;
    DWORD dwNumNegPolObjects = 0;
    DWORD i = 0;
    DWORD j = 0;


    dwError = RegEnumNegPolObjects(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    &ppIpsecNegPolObjects,
                    &dwNumNegPolObjects
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumNegPolObjects) {
        ppIpsecNegPolData = (PIPSEC_NEGPOL_DATA *) AllocPolMem(
                            dwNumNegPolObjects*sizeof(PIPSEC_NEGPOL_DATA));
        if (!ppIpsecNegPolData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumNegPolObjects; i++) {

        dwError = RegUnmarshallNegPolData(
                        *(ppIpsecNegPolObjects + i),
                        &pIpsecNegPolData
                        );
        if (!dwError) {
            *(ppIpsecNegPolData + j) = pIpsecNegPolData;
            j++;
        }
    }

    if (j == 0) {
        if (ppIpsecNegPolData) {
            FreePolMem(ppIpsecNegPolData);
            ppIpsecNegPolData = NULL;
        }
    }

    *pppIpsecNegPolData = ppIpsecNegPolData;
    *pdwNumNegPolObjects = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecNegPolObjects) {
        FreeIpsecNegPolObjects(
                ppIpsecNegPolObjects,
                dwNumNegPolObjects
                );
    }

    return(dwError);


error:

    if (ppIpsecNegPolData) {
        FreeMulIpsecNegPolData(
                ppIpsecNegPolData,
                i
                );
    }

    *pppIpsecNegPolData = NULL;
    *pdwNumNegPolObjects = 0;

    goto cleanup;
}

DWORD
RegEnumNegPolObjects(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT ** pppIpsecNegPolObjects,
    PDWORD pdwNumNegPolObjects
    )
{

    DWORD dwError = 0;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject =  NULL;
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObjects = NULL;

    DWORD dwNumNegPolObjectsReturned = 0;
    DWORD dwIndex = 0;
    WCHAR szNegPolName[MAX_PATH];
    DWORD dwSize = 0;
    DWORD dwReserved = 0;

    *pppIpsecNegPolObjects = NULL;
    *pdwNumNegPolObjects = 0;

    while (1) {

        dwSize = MAX_PATH;
        dwReserved = 0;
        szNegPolName[0] = L'\0';

        dwError = RegEnumKeyExW(
                        hRegistryKey,
                        dwIndex,
                        szNegPolName,
                        &dwSize,
                        NULL,
                        NULL,
                        0,
                        0
                        );
        if (dwError == ERROR_NO_MORE_ITEMS) {
            break;
        }
        BAIL_ON_WIN32_ERROR(dwError);

        if (!wcsstr(szNegPolName, L"ipsecNegotiationPolicy")) {
            dwIndex++;
            continue;
        }

        pIpsecNegPolObject = NULL;

        dwError =UnMarshallRegistryNegPolObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    szNegPolName,
                    REG_RELATIVE_NAME,
                    &pIpsecNegPolObject
                    );
        if (dwError == ERROR_SUCCESS) {

            dwError = ReallocatePolMem(
                          (LPVOID *) &ppIpsecNegPolObjects,
                          sizeof(PIPSEC_NEGPOL_OBJECT)*(dwNumNegPolObjectsReturned),
                          sizeof(PIPSEC_NEGPOL_OBJECT)*(dwNumNegPolObjectsReturned + 1)
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            *(ppIpsecNegPolObjects + dwNumNegPolObjectsReturned) = pIpsecNegPolObject;

            dwNumNegPolObjectsReturned++;

        }

        dwIndex++;

    }

    *pppIpsecNegPolObjects = ppIpsecNegPolObjects;
    *pdwNumNegPolObjects = dwNumNegPolObjectsReturned;

    dwError = ERROR_SUCCESS;

    return(dwError);

error:


    if (ppIpsecNegPolObjects) {

        FreeIpsecNegPolObjects(
                    ppIpsecNegPolObjects,
                    dwNumNegPolObjectsReturned
                    );
    }

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(
            pIpsecNegPolObject
            );
    }

    *pppIpsecNegPolObjects = NULL;
    *pdwNumNegPolObjects = 0;


    return(dwError);
}


DWORD
RegSetNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;

    dwError = RegMarshallNegPolObject(
                    pIpsecNegPolData,
                    &pIpsecNegPolObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetNegPolObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    pIpsecNegPolObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegBackPropIncChangesForNegPolToNFA(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszLocationName,
                  pIpsecNegPolObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(pIpsecNegPolObject);
    }

    return(dwError);
}


DWORD
RegSetNegPolObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    )
{
    DWORD dwError = 0;

    dwError = PersistNegPolObject(
                    hRegistryKey,
                    pIpsecNegPolObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegCreateNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;

    dwError = RegMarshallNegPolObject(
                        pIpsecNegPolData,
                        &pIpsecNegPolObject
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegCreateNegPolObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    pIpsecNegPolObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(
                pIpsecNegPolObject
                );
    }

    return(dwError);
}

DWORD
RegCreateNegPolObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    )
{

    DWORD dwError = 0;

    dwError = PersistNegPolObject(
                    hRegistryKey,
                    pIpsecNegPolObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegDeleteNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';

    dwError = UuidToString(
                  &NegPolIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szDistinguishedName,L"ipsecNegotiationPolicy");
    wcscat(szDistinguishedName, szGuid);

    dwError = RegDeleteKeyW(
                  hRegistryKey,
                  szDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);
}


DWORD
RegUnmarshallNegPolData(
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallNegPolObject(
                    pIpsecNegPolObject,
                    ppIpsecNegPolData
                    );


    return(dwError);
}

DWORD
RegMarshallNegPolObject(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NEGPOL_OBJECT * ppIpsecNegPolObject
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;
    LPWSTR pszNegPolActionUuid = NULL;
    LPWSTR pszNegPolTypeUuid = NULL;
    time_t PresentTime;
    WCHAR szGuidAction[MAX_PATH];
    WCHAR szGuidType[MAX_PATH];


    szGuidAction[0] = L'\0';
    szGuidType[0] = L'\0';
    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';
    pIpsecNegPolObject = (PIPSEC_NEGPOL_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_NEGPOL_OBJECT)
                                                    );
    if (!pIpsecNegPolObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecNegPolData->NegPolIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    //
    // Fill in the distinguishedName
    //

    wcscpy(szDistinguishedName,L"ipsecNegotiationPolicy");
    wcscat(szDistinguishedName, szGuid);
    pIpsecNegPolObject->pszDistinguishedName = AllocPolStr(
                                                    szDistinguishedName
                                                    );
    if (!pIpsecNegPolObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Fill in the ipsecName
    //

    if (pIpsecNegPolData->pszIpsecName &&
        *pIpsecNegPolData->pszIpsecName) {
        pIpsecNegPolObject->pszIpsecName = AllocPolStr(
                                           pIpsecNegPolData->pszIpsecName
                                           );
        if (!pIpsecNegPolObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNegPolData->pszDescription &&
        *pIpsecNegPolData->pszDescription) {
        pIpsecNegPolObject->pszDescription = AllocPolStr(
                                             pIpsecNegPolData->pszDescription
                                             );
        if (!pIpsecNegPolObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //
    // Fill in the ipsecID
    //

    pIpsecNegPolObject->pszIpsecID = AllocPolStr(
                                         szGuid
                                         );
    if (!pIpsecNegPolObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecNegPolData->NegPolAction,
                    &pszNegPolActionUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szGuidAction, L"{");
    wcscat(szGuidAction, pszNegPolActionUuid);
    wcscat(szGuidAction, L"}");

    pIpsecNegPolObject->pszIpsecNegPolAction = AllocPolStr(
                                                    szGuidAction
                                                    );
    if (!pIpsecNegPolObject->pszIpsecNegPolAction) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecNegPolData->NegPolType,
                    &pszNegPolTypeUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(szGuidType, L"{");
    wcscat(szGuidType, pszNegPolTypeUuid);
    wcscat(szGuidType, L"}");

    pIpsecNegPolObject->pszIpsecNegPolType = AllocPolStr(
                                                 szGuidType
                                                 );
    if (!pIpsecNegPolObject->pszIpsecNegPolType) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Fill in the ipsecDataType
    //

    pIpsecNegPolObject->dwIpsecDataType = 0x100;


    //
    // Marshall the pIpsecDataBuffer and the Length
    //

    dwError = MarshallNegPolBuffer(
                    pIpsecNegPolData,
                    &pBuffer,
                    &dwBufferLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNegPolObject->pIpsecData  = pBuffer;

    pIpsecNegPolObject->dwIpsecDataLen = dwBufferLen;

    time(&PresentTime);

    pIpsecNegPolObject->dwWhenChanged = (DWORD) PresentTime;

    *ppIpsecNegPolObject = pIpsecNegPolObject;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }
    if (pszNegPolActionUuid) {
        RpcStringFree(
            &pszNegPolActionUuid
            );
    }
    if (pszNegPolTypeUuid) {
        RpcStringFree(
            &pszNegPolTypeUuid
            );
    }

    return(dwError);

error:

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(
                pIpsecNegPolObject
                );
    }

    *ppIpsecNegPolObject = NULL;
    goto cleanup;
}


DWORD
MarshallNegPolBuffer(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    LPBYTE * ppBuffer,
    DWORD * pdwBufferLen
    )
{
    LPBYTE pCurrentPos = NULL;
    LPBYTE pBuffer = NULL;
    DWORD dwSize = 0;
    DWORD dwError = 0;
    DWORD dwNumSecurityOffers = 0;
    IPSEC_SECURITY_METHOD * pIpsecOffer = NULL;
    DWORD i = 0;
    DWORD dwEffectiveSize = 0;

    // {80DC20B9-2EC8-11d1-A89E-00A0248D3021}
    static const GUID GUID_IPSEC_NEGPOLICY_BLOB =
    { 0x80dc20b9, 0x2ec8, 0x11d1, { 0xa8, 0x9e, 0x0, 0xa0, 0x24, 0x8d, 0x30, 0x21 } };

    dwNumSecurityOffers = pIpsecNegPolData->dwSecurityMethodCount;
    pIpsecOffer = pIpsecNegPolData->pIpsecSecurityMethods;

    dwSize += sizeof(GUID);

    dwSize += sizeof(DWORD);

    dwSize += sizeof(DWORD);


    for (i = 0; i < dwNumSecurityOffers; i++) {

        dwSize += sizeof(IPSEC_SECURITY_METHOD);

    }
    dwSize++;

    pBuffer = (LPBYTE)AllocPolMem(dwSize);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pCurrentPos = pBuffer;

    memcpy(pCurrentPos, &GUID_IPSEC_NEGPOLICY_BLOB, sizeof(GUID));
    pCurrentPos += sizeof(GUID);
 
    dwEffectiveSize = dwSize - sizeof(GUID) - sizeof(DWORD) - 1;

    memcpy(pCurrentPos, &dwEffectiveSize, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    memcpy(pCurrentPos, &dwNumSecurityOffers, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    for (i = 0; i < dwNumSecurityOffers; i++) {

        memcpy(pCurrentPos, pIpsecOffer + i, sizeof(IPSEC_SECURITY_METHOD));
        pCurrentPos += sizeof(IPSEC_SECURITY_METHOD);
    }


    *ppBuffer = pBuffer;
    *pdwBufferLen = dwSize;

    return(dwError);

error:

    if (pBuffer) {
        FreePolMem(pBuffer);
    }

    *ppBuffer = NULL;
    *pdwBufferLen = 0;
    return(dwError);
}


DWORD
RegGetNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolGUID,
    PIPSEC_NEGPOL_DATA * ppIpsecNegPolData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    WCHAR szIpsecNegPolName[MAX_PATH];
    LPWSTR pszNegPolName = NULL;

    szIpsecNegPolName[0] = L'\0';
    wcscpy(szIpsecNegPolName, L"ipsecNegotiationPolicy");

    dwError = UuidToString(&NegPolGUID, &pszNegPolName);
    BAIL_ON_WIN32_ERROR(dwError);

    wcscat(szIpsecNegPolName, L"{");
    wcscat(szIpsecNegPolName, pszNegPolName);
    wcscat(szIpsecNegPolName, L"}");


    dwError =UnMarshallRegistryNegPolObject(
                hRegistryKey,
                pszIpsecRootContainer,
                szIpsecNegPolName,
                REG_RELATIVE_NAME,
                &pIpsecNegPolObject
                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegUnmarshallNegPolData(
                    pIpsecNegPolObject,
                    &pIpsecNegPolData
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(
                pIpsecNegPolObject
                );
    }

    if (pszNegPolName) {
        RpcStringFree(&pszNegPolName);
    }

    *ppIpsecNegPolData = pIpsecNegPolData;

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\policy-d.h ===
DWORD
DirEnumPolicyData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    );

DWORD
DirEnumPolicyObjects(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT ** pppIpsecPolicyObjects,
    PDWORD pdwNumPolicyObjects
    );

DWORD
GenerateAllPolicyQuery(
    LPWSTR * ppszPolicyString
    );

DWORD
UnMarshallPolicyObject2(
    HLDAP hLdapBindHandle,
    LDAPMessage *e,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    );

DWORD
DirUnmarshallPolicyData(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );

DWORD
DirCreatePolicyData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
DirMarshallPolicyObject(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    );

DWORD
ConvertGuidToDirISAKMPString(
    GUID ISAKMPIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecISAKMPReference
    );

DWORD
DirCreatePolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    );

DWORD
DirMarshallAddPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    LDAPModW *** pppLDAPModW
    );

DWORD
DirSetPolicyData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
DirSetPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    );

DWORD
DirMarshallSetPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    LDAPModW *** pppLDAPModW
    );

DWORD
DirGetPolicyExistingISAKMPRef(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    LPWSTR * ppszIpsecISAKMPName
    );

DWORD
GenerateSpecificPolicyQuery(
    GUID PolicyIdentifier,
    LPWSTR * ppszPolicyString
    );

DWORD
DirDeletePolicyData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
ConvertGuidToDirPolicyString(
    GUID PolicyIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecPolicyReference
    );

DWORD
DirGetPolicyData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\policy-d.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       policy-d.c
//
//  Contents:   Policy management for directory.
//
//
//  History:    AbhisheV (05/11/00)
//
//----------------------------------------------------------------------------


#include "precomp.h"

extern LPWSTR PolicyDNAttributes[];

DWORD
DirEnumPolicyData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObjects = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    PIPSEC_POLICY_DATA * ppIpsecPolicyData = NULL;
    DWORD dwNumPolicyObjects = 0;
    DWORD i = 0;
    DWORD j = 0;


    dwError = DirEnumPolicyObjects(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    &ppIpsecPolicyObjects,
                    &dwNumPolicyObjects
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumPolicyObjects) {
        ppIpsecPolicyData = (PIPSEC_POLICY_DATA *) AllocPolMem(
                        dwNumPolicyObjects*sizeof(PIPSEC_POLICY_DATA));
        if (!ppIpsecPolicyData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumPolicyObjects; i++) {

        dwError = DirUnmarshallPolicyData(
                        *(ppIpsecPolicyObjects + i),
                        &pIpsecPolicyData
                        );
        if (!dwError) {
            *(ppIpsecPolicyData + j) = pIpsecPolicyData;
            j++;
        }
    }

    if (j == 0) {
        if (ppIpsecPolicyData) {
            FreePolMem(ppIpsecPolicyData);
            ppIpsecPolicyData = NULL;
        }
    }

    *pppIpsecPolicyData = ppIpsecPolicyData;
    *pdwNumPolicyObjects = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecPolicyObjects) {
        FreeIpsecPolicyObjects(
                ppIpsecPolicyObjects,
                dwNumPolicyObjects
                );
    }

    return(dwError);

error:

    if (ppIpsecPolicyData) {
        FreeMulIpsecPolicyData(
                ppIpsecPolicyData,
                i
                );
    }

    *pppIpsecPolicyData = NULL;
    *pdwNumPolicyObjects = 0;

    goto cleanup;
}


DWORD
DirEnumPolicyObjects(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT ** pppIpsecPolicyObjects,
    PDWORD pdwNumPolicyObjects
    )
{
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    DWORD dwError = 0;
    LPWSTR pszPolicyString = NULL;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject =  NULL;
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObjects = NULL;

    DWORD dwNumPolicyObjectsReturned = 0;

    dwError = GenerateAllPolicyQuery(
                    &pszPolicyString
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszPolicyString,
                  PolicyDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                    hLdapBindHandle,
                    res
                    );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppIpsecPolicyObjects  = (PIPSEC_POLICY_OBJECT *)AllocPolMem(
                                            sizeof(PIPSEC_POLICY_OBJECT)*dwCount
                                            );

    if (!ppIpsecPolicyObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwCount; i++) {

        if (i == 0) {

            dwError = LdapFirstEntry(
                            hLdapBindHandle,
                            res,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        } else {

            dwError = LdapNextEntry(
                            hLdapBindHandle,
                            e,
                            &e
                            );
            BAIL_ON_WIN32_ERROR(dwError);

        }

        dwError = UnMarshallPolicyObject2(
                      hLdapBindHandle,
                      e,
                      &pIpsecPolicyObject
                      );
        if (dwError == ERROR_SUCCESS) {
            *(ppIpsecPolicyObjects + dwNumPolicyObjectsReturned) = pIpsecPolicyObject;
            dwNumPolicyObjectsReturned++;
        }

    }

    *pppIpsecPolicyObjects = ppIpsecPolicyObjects;
    *pdwNumPolicyObjects = dwNumPolicyObjectsReturned;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszPolicyString) {
        FreePolMem(pszPolicyString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    return(dwError);

error:

    if (ppIpsecPolicyObjects) {
        FreeIpsecPolicyObjects(
            ppIpsecPolicyObjects,
            dwNumPolicyObjectsReturned
            );
    }

    *pppIpsecPolicyObjects = NULL;
    *pdwNumPolicyObjects = 0;

    goto cleanup;
}


DWORD
GenerateAllPolicyQuery(
    LPWSTR * ppszPolicyString
    )
{
    DWORD dwError = 0;
    DWORD dwLength = 0;
    LPWSTR pszPolicyString = NULL;


    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(objectclass=ipsecPolicy)");

    pszPolicyString = (LPWSTR) AllocPolMem((dwLength + 1)*sizeof(WCHAR));

    if (!pszPolicyString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Now fill in the buffer
    //

    wcscpy(pszPolicyString, L"(objectclass=ipsecPolicy)");

    *ppszPolicyString = pszPolicyString;

    return(0);

error:

    if (pszPolicyString) {
        FreePolMem(pszPolicyString);
    }

    *ppszPolicyString = NULL;

    return(dwError);
}


DWORD
UnMarshallPolicyObject2(
    HLDAP hLdapBindHandle,
    LDAPMessage *e,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    )
{
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    DWORD dwCount = 0;
    DWORD dwLen = 0;
    LPBYTE pBuffer = NULL;
    DWORD i = 0;
    DWORD dwError = 0;
    WCHAR **strvalues = NULL;
    struct berval ** bvalues = NULL;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszIpsecNFAName = NULL;
    LPWSTR * ppszTemp = NULL;


    pIpsecPolicyObject = (PIPSEC_POLICY_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_POLICY_OBJECT)
                                                    );
    if (!pIpsecPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"distinguishedName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pszIpsecOwnersReference = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszIpsecOwnersReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecName",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pszIpsecName = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszIpsecName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"description",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    if (strvalues && LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)) {

        pIpsecPolicyObject->pszDescription = AllocPolStr(
                                            LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                            );
        if (!pIpsecPolicyObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        LdapValueFree(strvalues);

    } else {
        pIpsecPolicyObject->pszDescription = NULL;
    }


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecID",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pszIpsecID = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecDataType",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    pIpsecPolicyObject->dwIpsecDataType = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"whenChanged",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    pIpsecPolicyObject->dwWhenChanged = _wtol(LDAPOBJECT_STRING((PLDAPOBJECT)strvalues));
    LdapValueFree(strvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecISAKMPReference",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pszIpsecISAKMPReference = AllocPolStr(
                                        LDAPOBJECT_STRING((PLDAPOBJECT)strvalues)
                                        );
    if (!pIpsecPolicyObject->pszIpsecISAKMPReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    LdapValueFree(strvalues);


    //
    // unmarshall the ipsecData blob
    //

    dwError = LdapGetValuesLen(
                    hLdapBindHandle,
                    e,
                    L"ipsecData",
                    (struct berval ***)&bvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwLen = LDAPOBJECT_BERVAL_LEN((PLDAPOBJECT)bvalues);
    pBuffer = (LPBYTE)AllocPolMem(dwLen);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    memcpy( pBuffer, LDAPOBJECT_BERVAL_VAL((PLDAPOBJECT)bvalues), dwLen );
    pIpsecPolicyObject->pIpsecData = pBuffer;
    pIpsecPolicyObject->dwIpsecDataLen = dwLen;
    LdapValueFreeLen(bvalues);


    strvalues = NULL;
    dwError = LdapGetValues(
                    hLdapBindHandle,
                    e,
                    L"ipsecNFAReference",
                    (WCHAR ***)&strvalues,
                    (int *)&dwCount
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                sizeof(LPWSTR)*dwCount
                                );
    if (!ppszIpsecNFANames) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwCount; i++) {

        ppszTemp = (strvalues + i);
        //
        // Unmarshall all the values you can possibly have
        //
        pszIpsecNFAName = AllocPolStr(*ppszTemp);
        if (!pszIpsecNFAName) {
            dwError = ERROR_OUTOFMEMORY;

            pIpsecPolicyObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
            pIpsecPolicyObject->NumberofRules = i;

            BAIL_ON_WIN32_ERROR(dwError);
        }

        *(ppszIpsecNFANames + i) = pszIpsecNFAName;

    }


    pIpsecPolicyObject->ppszIpsecNFAReferences = ppszIpsecNFANames;
    pIpsecPolicyObject->NumberofRules = dwCount;
    LdapValueFree(strvalues);

    *ppIpsecPolicyObject = pIpsecPolicyObject;

    return(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    *ppIpsecPolicyObject = NULL;

    return(dwError);
}


DWORD
DirUnmarshallPolicyData(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallPolicyObject(
                  pIpsecPolicyObject,
                  IPSEC_DIRECTORY_PROVIDER,
                  ppIpsecPolicyData
                  );

    return(dwError);
}


DWORD
DirCreatePolicyData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;

    dwError = DirMarshallPolicyObject(
                        pIpsecPolicyData,
                        pszIpsecRootContainer,
                        &pIpsecPolicyObject
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirCreatePolicyObject(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    pIpsecPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Write the ISAKMP object reference.
    //

    dwError = DirAddPolicyReferenceToISAKMPObject(
                  hLdapBindHandle,
                  pIpsecPolicyObject->pszIpsecISAKMPReference,
                  pIpsecPolicyObject->pszIpsecOwnersReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Write the Policy object reference.
    //

    dwError = DirAddISAKMPReferenceToPolicyObject(
                  hLdapBindHandle,
                  pIpsecPolicyObject->pszIpsecOwnersReference,
                  pIpsecPolicyObject->pszIpsecISAKMPReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
            pIpsecPolicyObject
            );
    }

    return(dwError);
}


DWORD
DirMarshallPolicyObject(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;
    LPWSTR pszIpsecISAKMPReference = NULL;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';
    pIpsecPolicyObject = (PIPSEC_POLICY_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_POLICY_OBJECT)
                                                    );
    if (!pIpsecPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecPolicyData->PolicyIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    //
    // Fill in the distinguishedName
    //

    wcscpy(szDistinguishedName,L"CN=ipsecPolicy");
    wcscat(szDistinguishedName, szGuid);
    wcscat(szDistinguishedName, L",");
    SecStrCatW(szDistinguishedName, pszIpsecRootContainer, MAX_PATH);

    pIpsecPolicyObject->pszIpsecOwnersReference = AllocPolStr(
                                                    szDistinguishedName
                                                    );
    if (!pIpsecPolicyObject->pszIpsecOwnersReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Fill in the ipsecName
    //

    if (pIpsecPolicyData->pszIpsecName &&
        *pIpsecPolicyData->pszIpsecName) {

        pIpsecPolicyObject->pszIpsecName = AllocPolStr(
                                           pIpsecPolicyData->pszIpsecName
                                           );
        if (!pIpsecPolicyObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecPolicyData->pszDescription &&
        *pIpsecPolicyData->pszDescription) {

        pIpsecPolicyObject->pszDescription = AllocPolStr(
                                             pIpsecPolicyData->pszDescription
                                             );
        if (!pIpsecPolicyObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //
    // Fill in the ipsecID
    //

    pIpsecPolicyObject->pszIpsecID = AllocPolStr(
                                         szGuid
                                         );
    if (!pIpsecPolicyObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Fill in the ipsecDataType
    //

    pIpsecPolicyObject->dwIpsecDataType = 0x100;


    //
    // Marshall the pIpsecDataBuffer and the Length
    //

    dwError = MarshallPolicyBuffer(
                    pIpsecPolicyData,
                    &pBuffer,
                    &dwBufferLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pIpsecData  = pBuffer;
    pIpsecPolicyObject->dwIpsecDataLen = dwBufferLen;

    dwError = ConvertGuidToDirISAKMPString(
                  pIpsecPolicyData->ISAKMPIdentifier,
                  pszIpsecRootContainer,
                  &pszIpsecISAKMPReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    pIpsecPolicyObject->pszIpsecISAKMPReference = pszIpsecISAKMPReference;

    pIpsecPolicyObject->dwWhenChanged = 0;

    *ppIpsecPolicyObject = pIpsecPolicyObject;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }

    return(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
                pIpsecPolicyObject
                );
    }

    *ppIpsecPolicyObject = NULL;
    goto cleanup;
}


DWORD
ConvertGuidToDirISAKMPString(
    GUID ISAKMPIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecISAKMPReference
    )
{
    DWORD dwError = 0;
    LPWSTR pszStringUuid = NULL;
    WCHAR szGuidString[MAX_PATH];
    WCHAR szISAKMPReference[MAX_PATH];
    LPWSTR pszIpsecISAKMPReference = NULL;


    dwError = UuidToString(
                  &ISAKMPIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szGuidString[0] = L'\0';
    wcscpy(szGuidString, L"{");
    wcscat(szGuidString, pszStringUuid);
    wcscat(szGuidString, L"}");

    szISAKMPReference[0] = L'\0';
    wcscpy(szISAKMPReference,L"CN=ipsecISAKMPPolicy");
    wcscat(szISAKMPReference, szGuidString);
    wcscat(szISAKMPReference, L",");
    SecStrCatW(szISAKMPReference, pszIpsecRootContainer, MAX_PATH);

    pszIpsecISAKMPReference = AllocPolStr(
                                    szISAKMPReference
                                    );
    if (!pszIpsecISAKMPReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszIpsecISAKMPReference = pszIpsecISAKMPReference;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    *ppszIpsecISAKMPReference = NULL;

    goto cleanup;
}


DWORD
DirCreatePolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;


    dwError = DirMarshallAddPolicyObject(
                        hLdapBindHandle,
                        pszIpsecRootContainer,
                        pIpsecPolicyObject,
                        &ppLDAPModW
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapAddS(
                    hLdapBindHandle,
                    pIpsecPolicyObject->pszIpsecOwnersReference,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    //
    // Free the amods structures.
    //

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirMarshallAddPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    LDAPModW *** pppLDAPModW
    )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 6;
    DWORD dwError = 0;
    WCHAR Buffer[64];


    if (!pIpsecPolicyObject->pszIpsecName ||
        !*pIpsecPolicyObject->pszIpsecName) {
        dwNumAttributes--;
    }

    if (!pIpsecPolicyObject->pszDescription ||
        !*pIpsecPolicyObject->pszDescription) {
        dwNumAttributes--;
    }

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // 0. objectClass
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"objectClass",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    L"ipsecPolicy",
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 1. ipsecName
    //

    if (pIpsecPolicyObject->pszIpsecName &&
        *pIpsecPolicyObject->pszIpsecName) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"ipsecName",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecPolicyObject->pszIpsecName,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 2. ipsecID
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecID",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecPolicyObject->pszIpsecID,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 3. ipsecDataType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecDataType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( pIpsecPolicyObject->dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                    Buffer,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 4. ipsecData
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecData",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPBinaryValue(
                    pIpsecPolicyObject->pIpsecData,
                    pIpsecPolicyObject->dwIpsecDataLen,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;

    i++;

    //
    // 5. description
    //

    if (pIpsecPolicyObject->pszDescription &&
        *pIpsecPolicyObject->pszDescription) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"description",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecPolicyObject->pszDescription,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    *pppLDAPModW = ppLDAPModW;

    return(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    *pppLDAPModW = NULL;

    return(dwError);
}


DWORD
DirSetPolicyData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    LPWSTR pszOldIpsecISAKMPReference = NULL;


    dwError = DirMarshallPolicyObject(
                    pIpsecPolicyData,
                    pszIpsecRootContainer,
                    &pIpsecPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirGetPolicyExistingISAKMPRef(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pIpsecPolicyData,
                  &pszOldIpsecISAKMPReference
                  );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirSetPolicyObject(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    pIpsecPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pszOldIpsecISAKMPReference && *pszOldIpsecISAKMPReference) {
        dwError = DirRemovePolicyReferenceFromISAKMPObject(
                      hLdapBindHandle,
                      pszOldIpsecISAKMPReference,
                      pIpsecPolicyObject->pszIpsecOwnersReference
                      );
        // BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = DirAddPolicyReferenceToISAKMPObject(
                  hLdapBindHandle,
                  pIpsecPolicyObject->pszIpsecISAKMPReference,
                  pIpsecPolicyObject->pszIpsecOwnersReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirUpdateISAKMPReferenceInPolicyObject(
                  hLdapBindHandle,
                  pIpsecPolicyObject->pszIpsecOwnersReference,
                  pszOldIpsecISAKMPReference,
                  pIpsecPolicyObject->pszIpsecISAKMPReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    if (pszOldIpsecISAKMPReference) {
        FreePolStr(pszOldIpsecISAKMPReference);
    }

    return(dwError);
}


DWORD
DirSetPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;

    dwError = DirMarshallSetPolicyObject(
                        hLdapBindHandle,
                        pszIpsecRootContainer,
                        pIpsecPolicyObject,
                        &ppLDAPModW
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pIpsecPolicyObject->pszIpsecOwnersReference,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    //
    // Free the amods structures.
    //

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }


    return(dwError);
}


DWORD
DirMarshallSetPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    LDAPModW *** pppLDAPModW
    )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 5;
    DWORD dwError = 0;
    WCHAR Buffer[64];


    if (!pIpsecPolicyObject->pszIpsecName ||
        !*pIpsecPolicyObject->pszIpsecName) {
        dwNumAttributes--;
    }

    if (!pIpsecPolicyObject->pszDescription ||
        !*pIpsecPolicyObject->pszDescription) {
        dwNumAttributes--;
    }

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // 1. ipsecName
    //

    if (pIpsecPolicyObject->pszIpsecName &&
        *pIpsecPolicyObject->pszIpsecName) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"ipsecName",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecPolicyObject->pszIpsecName,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 2. ipsecID
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecID",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecPolicyObject->pszIpsecID,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 3. ipsecDataType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecDataType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( pIpsecPolicyObject->dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                    Buffer,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 4. ipsecData
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecData",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPBinaryValue(
                    pIpsecPolicyObject->pIpsecData,
                    pIpsecPolicyObject->dwIpsecDataLen,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;

    i++;

    //
    // 5. description
    //

    if (pIpsecPolicyObject->pszDescription &&
        *pIpsecPolicyObject->pszDescription) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"description",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecPolicyObject->pszDescription,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    *pppLDAPModW = ppLDAPModW;

    return(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    *pppLDAPModW = NULL;

    return(dwError);
}


DWORD
DirGetPolicyExistingISAKMPRef(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    LPWSTR * ppszIpsecISAKMPName
    )
{
    DWORD dwError = 0;
    LPWSTR pszPolicyString = NULL;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;
    LDAPMessage * e = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject =  NULL;
    LPWSTR pszIpsecISAKMPName = NULL;


    dwError = GenerateSpecificPolicyQuery(
                  pIpsecPolicyData->PolicyIdentifier,
                  &pszPolicyString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszPolicyString,
                  PolicyDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallPolicyObject2(
                  hLdapBindHandle,
                  e,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pszIpsecISAKMPName = AllocPolStr(
                             pIpsecPolicyObject->pszIpsecISAKMPReference
                             );
    if (!pszIpsecISAKMPName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszIpsecISAKMPName = pszIpsecISAKMPName;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszPolicyString) {
        FreePolMem(pszPolicyString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    return(dwError);

error:

    *ppszIpsecISAKMPName = NULL;

    goto cleanup;
}


DWORD
GenerateSpecificPolicyQuery(
    GUID PolicyIdentifier,
    LPWSTR * ppszPolicyString
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;
    DWORD dwLength = 0;
    LPWSTR pszPolicyString = NULL;


    szGuid[0] = L'\0';
    szCommonName[0] = L'\0';

    dwError = UuidToString(
                  &PolicyIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szCommonName, L"cn=ipsecPolicy");
    wcscat(szCommonName, szGuid);

    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(&(objectclass=ipsecPolicy)");
    dwLength += wcslen(L"(");
    dwLength += wcslen(szCommonName);
    dwLength += wcslen(L"))");

    pszPolicyString = (LPWSTR) AllocPolMem((dwLength + 1)*sizeof(WCHAR));

    if (!pszPolicyString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    wcscpy(pszPolicyString, L"(&(objectclass=ipsecPolicy)");
    wcscat(pszPolicyString, L"(");
    wcscat(pszPolicyString, szCommonName);
    wcscat(pszPolicyString, L"))");

    *ppszPolicyString = pszPolicyString;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    if (pszPolicyString) {
        FreePolMem(pszPolicyString);
    }

    *ppszPolicyString = NULL;

    goto cleanup;
}


DWORD
DirDeletePolicyData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;


    dwError = DirMarshallPolicyObject(
                  pIpsecPolicyData,
                  pszIpsecRootContainer,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirRemovePolicyReferenceFromISAKMPObject(
                  hLdapBindHandle,
                  pIpsecPolicyObject->pszIpsecISAKMPReference,
                  pIpsecPolicyObject->pszIpsecOwnersReference
                  );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapDeleteS(
                  hLdapBindHandle,
                  pIpsecPolicyObject->pszIpsecOwnersReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    return(dwError);
}


DWORD
ConvertGuidToDirPolicyString(
    GUID PolicyIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecPolicyReference
    )
{
    DWORD dwError = 0;
    LPWSTR pszStringUuid = NULL;
    WCHAR szGuidString[MAX_PATH];
    WCHAR szPolicyReference[MAX_PATH];
    LPWSTR pszIpsecPolicyReference = NULL;


    dwError = UuidToString(
                  &PolicyIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szGuidString[0] = L'\0';
    wcscpy(szGuidString, L"{");
    wcscat(szGuidString, pszStringUuid);
    wcscat(szGuidString, L"}");

    szPolicyReference[0] = L'\0';
    wcscpy(szPolicyReference,L"CN=ipsecPolicy");
    wcscat(szPolicyReference, szGuidString);
    wcscat(szPolicyReference, L",");
    SecStrCatW(szPolicyReference, pszIpsecRootContainer, MAX_PATH);

    pszIpsecPolicyReference = AllocPolStr(
                                    szPolicyReference
                                    );
    if (!pszIpsecPolicyReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszIpsecPolicyReference = pszIpsecPolicyReference;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    *ppszIpsecPolicyReference = NULL;

    goto cleanup;
}


DWORD
DirGetPolicyData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    DWORD dwError = 0;
    LPWSTR pszPolicyString = NULL;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;
    LDAPMessage * e = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject =  NULL;


    *ppIpsecPolicyData = NULL;

    dwError = GenerateSpecificPolicyQuery(
                  PolicyIdentifier,
                  &pszPolicyString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszPolicyString,
                  PolicyDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallPolicyObject2(
                  hLdapBindHandle,
                  e,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirUnmarshallPolicyData(
                  pIpsecPolicyObject,
                  ppIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszPolicyString) {
        FreePolStr(pszPolicyString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\policy-r.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       policy-r.c
//
//  Contents:   Policy management for registry.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//
//----------------------------------------------------------------------------

#include "precomp.h"

extern LPWSTR PolicyDNAttributes[];

DWORD
RegEnumPolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObjects = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    PIPSEC_POLICY_DATA * ppIpsecPolicyData = NULL;
    DWORD dwNumPolicyObjects = 0;
    DWORD i = 0;
    DWORD j = 0;


    dwError = RegEnumPolicyObjects(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    &ppIpsecPolicyObjects,
                    &dwNumPolicyObjects
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumPolicyObjects) {
        ppIpsecPolicyData = (PIPSEC_POLICY_DATA *) AllocPolMem(
                        dwNumPolicyObjects*sizeof(PIPSEC_POLICY_DATA));
        if (!ppIpsecPolicyData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumPolicyObjects; i++) {

        dwError = RegUnmarshallPolicyData(
                        *(ppIpsecPolicyObjects + i),
                        &pIpsecPolicyData
                        );
        if (!dwError) {
            *(ppIpsecPolicyData + j) = pIpsecPolicyData;
            j++;
        }
    }

    if (j == 0) {
        if (ppIpsecPolicyData) {
            FreePolMem(ppIpsecPolicyData);
            ppIpsecPolicyData = NULL;
        }
    }

    *pppIpsecPolicyData = ppIpsecPolicyData;
    *pdwNumPolicyObjects = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecPolicyObjects) {
        FreeIpsecPolicyObjects(
                ppIpsecPolicyObjects,
                dwNumPolicyObjects
                );
    }

    return(dwError);

error:

    if (ppIpsecPolicyData) {
        FreeMulIpsecPolicyData(
                ppIpsecPolicyData,
                i
                );
    }

    *pppIpsecPolicyData = NULL;
    *pdwNumPolicyObjects = 0;

    goto cleanup;

}

DWORD
RegEnumPolicyObjects(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT ** pppIpsecPolicyObjects,
    PDWORD pdwNumPolicyObjects
    )
{

    DWORD dwError = 0;
    DWORD i = 0;
    DWORD dwCount = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject =  NULL;
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObjects = NULL;

    DWORD dwNumPolicyObjectsReturned = 0;
    DWORD dwIndex = 0;
    WCHAR szPolicyName[MAX_PATH];
    DWORD dwSize = 0;

    *pppIpsecPolicyObjects = NULL;
    *pdwNumPolicyObjects = 0;

    while (1) {

        dwSize = MAX_PATH;
        szPolicyName[0] = L'\0';

        dwError = RegEnumKeyExW(
                        hRegistryKey,
                        dwIndex,
                        szPolicyName,
                        &dwSize,
                        NULL,
                        NULL,
                        0,
                        0
                        );
        if (dwError == ERROR_NO_MORE_ITEMS) {
            break;
        }
        BAIL_ON_WIN32_ERROR(dwError);

        if (!wcsstr(szPolicyName, L"ipsecPolicy")) {
            dwIndex++;
            continue;
        }

        pIpsecPolicyObject = NULL;

        dwError =UnMarshallRegistryPolicyObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    szPolicyName,
                    REG_RELATIVE_NAME,
                    &pIpsecPolicyObject
                    );
        if (dwError == ERROR_SUCCESS) {


            dwError = ReallocatePolMem(
                          (LPVOID *) &ppIpsecPolicyObjects,
                          sizeof(PIPSEC_POLICY_OBJECT)*(dwNumPolicyObjectsReturned),
                          sizeof(PIPSEC_POLICY_OBJECT)*(dwNumPolicyObjectsReturned + 1)
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            *(ppIpsecPolicyObjects + dwNumPolicyObjectsReturned) = pIpsecPolicyObject;

            dwNumPolicyObjectsReturned++;

        }

        dwIndex++;

    }

    *pppIpsecPolicyObjects = ppIpsecPolicyObjects;
    *pdwNumPolicyObjects = dwNumPolicyObjectsReturned;

    dwError = ERROR_SUCCESS;

    return(dwError);

error:


    if (ppIpsecPolicyObjects) {
        FreeIpsecPolicyObjects(
            ppIpsecPolicyObjects,
            dwNumPolicyObjectsReturned
            );
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
            pIpsecPolicyObject
            );
    }

    *pppIpsecPolicyObjects = NULL;
    *pdwNumPolicyObjects = 0;


    return(dwError);
}


DWORD
RegSetPolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    LPWSTR pszAbsOldISAKMPRef = NULL;
    LPWSTR pszRelOldISAKMPRef = NULL;
    WCHAR szAbsPolicyReference[MAX_PATH];
    LPWSTR pszRelISAKMPReference = NULL;
    DWORD dwRootPathLen = 0;
    BOOL bIsActive = FALSE;


    dwRootPathLen =  wcslen(pszIpsecRootContainer);

    dwError = RegGetPolicyExistingISAKMPRef(
                   hRegistryKey,
                   pIpsecPolicyData,
                   &pszAbsOldISAKMPRef
                   );                    
    // BAIL_ON_WIN32_ERROR(dwError);

    if (pszAbsOldISAKMPRef && *pszAbsOldISAKMPRef) {
        pszRelOldISAKMPRef = pszAbsOldISAKMPRef + dwRootPathLen + 1;
    }

    dwError = RegMarshallPolicyObject(
                    pIpsecPolicyData,
                    pszIpsecRootContainer,
                    &pIpsecPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetPolicyObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    pIpsecPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    szAbsPolicyReference[0] = L'\0';
    wcscpy(szAbsPolicyReference, pszIpsecRootContainer);
    wcscat(szAbsPolicyReference, L"\\");
    wcscat(szAbsPolicyReference, pIpsecPolicyObject->pszIpsecOwnersReference);

    pszRelISAKMPReference = pIpsecPolicyObject->pszIpsecISAKMPReference
                            + dwRootPathLen + 1;

    if (pszRelOldISAKMPRef) {
        dwError = RegRemovePolicyReferenceFromISAKMPObject(
                      hRegistryKey,
                      pszRelOldISAKMPRef,
                      szAbsPolicyReference
                      );
        // BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegAddPolicyReferenceToISAKMPObject(
                  hRegistryKey,
                  pszRelISAKMPReference,
                  szAbsPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegUpdateISAKMPReferenceInPolicyObject(
                  hRegistryKey,
                  pIpsecPolicyObject->pszIpsecOwnersReference,
                  pszAbsOldISAKMPRef,
                  pIpsecPolicyObject->pszIpsecISAKMPReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IsRegPolicyCurrentlyActive(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pIpsecPolicyData->PolicyIdentifier,
                  &bIsActive
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (bIsActive) {
        dwError = PingPolicyAgentSvc(pszLocationName);
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    if (pszAbsOldISAKMPRef) {
        FreePolStr(pszAbsOldISAKMPRef);
    }

    return(dwError);
}


DWORD
RegSetPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    )
{
    DWORD dwError = 0;

    dwError = PersistPolicyObject(
                    hRegistryKey,
                    pIpsecPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegCreatePolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    WCHAR szAbsPolicyReference[MAX_PATH];
    LPWSTR pszRelISAKMPReference = NULL;
    DWORD dwRootPathLen = 0;


    dwRootPathLen =  wcslen(pszIpsecRootContainer);

    dwError = RegMarshallPolicyObject(
                        pIpsecPolicyData,
                        pszIpsecRootContainer,
                        &pIpsecPolicyObject
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegCreatePolicyObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    pIpsecPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    szAbsPolicyReference[0] = L'\0';
    wcscpy(szAbsPolicyReference, pszIpsecRootContainer);
    wcscat(szAbsPolicyReference, L"\\");
    wcscat(szAbsPolicyReference, pIpsecPolicyObject->pszIpsecOwnersReference);

    pszRelISAKMPReference = pIpsecPolicyObject->pszIpsecISAKMPReference
                            + dwRootPathLen + 1;

    //
    // Write the ISAKMP object reference.
    //

    dwError = RegAddPolicyReferenceToISAKMPObject(
                  hRegistryKey,
                  pszRelISAKMPReference,
                  szAbsPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Write the Policy object reference.
    //

    dwError = RegAddISAKMPReferenceToPolicyObject(
                  hRegistryKey,
                  pIpsecPolicyObject->pszIpsecOwnersReference,
                  pIpsecPolicyObject->pszIpsecISAKMPReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
                pIpsecPolicyObject
                );
    }

    return(dwError);
}


DWORD
RegCreatePolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    )
{

    DWORD dwError = 0;

    dwError = PersistPolicyObject(
                    hRegistryKey,
                    pIpsecPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegDeletePolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = ERROR_SUCCESS;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    WCHAR szAbsPolicyReference[MAX_PATH];
    LPWSTR pszRelISAKMPReference = NULL;
    DWORD dwRootPathLen = 0;
    BOOL bIsActive = FALSE;


    dwError = IsRegPolicyCurrentlyActive(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pIpsecPolicyData->PolicyIdentifier,
                  &bIsActive
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (bIsActive) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwRootPathLen = wcslen(pszIpsecRootContainer);

    dwError = RegMarshallPolicyObject(
                    pIpsecPolicyData,
                    pszIpsecRootContainer,
                    &pIpsecPolicyObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    szAbsPolicyReference[0] = L'\0';
    wcscpy(szAbsPolicyReference, pszIpsecRootContainer);
    wcscat(szAbsPolicyReference, L"\\");
    wcscat(szAbsPolicyReference, pIpsecPolicyObject->pszIpsecOwnersReference);

    pszRelISAKMPReference = pIpsecPolicyObject->pszIpsecISAKMPReference
                            + dwRootPathLen + 1;

    dwError = RegRemovePolicyReferenceFromISAKMPObject(
                  hRegistryKey,
                  pszRelISAKMPReference,
                  szAbsPolicyReference
                  );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegDeleteKeyW(
                  hRegistryKey,
                  pIpsecPolicyObject->pszIpsecOwnersReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    return(dwError);
}


DWORD
RegUnmarshallPolicyData(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallPolicyObject(
                    pIpsecPolicyObject,
                    IPSEC_REGISTRY_PROVIDER,
                    ppIpsecPolicyData
                    );


    return(dwError);
}

DWORD
RegMarshallPolicyObject(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;
    LPWSTR pszIpsecISAKMPReference = NULL;
    time_t PresentTime;

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';
    pIpsecPolicyObject = (PIPSEC_POLICY_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_POLICY_OBJECT)
                                                    );
    if (!pIpsecPolicyObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecPolicyData->PolicyIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    //
    // Fill in the distinguishedName
    //

    wcscpy(szDistinguishedName,L"ipsecPolicy");
    wcscat(szDistinguishedName, szGuid);
    pIpsecPolicyObject->pszIpsecOwnersReference = AllocPolStr(
                                                    szDistinguishedName
                                                    );
    if (!pIpsecPolicyObject->pszIpsecOwnersReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Fill in the ipsecName
    //

    if (pIpsecPolicyData->pszIpsecName && 
        *pIpsecPolicyData->pszIpsecName) {

        pIpsecPolicyObject->pszIpsecName = AllocPolStr(
                                           pIpsecPolicyData->pszIpsecName
                                           );
        if (!pIpsecPolicyObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecPolicyData->pszDescription && 
        *pIpsecPolicyData->pszDescription) {

        pIpsecPolicyObject->pszDescription = AllocPolStr(
                                             pIpsecPolicyData->pszDescription
                                             );
        if (!pIpsecPolicyObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //
    // Fill in the ipsecID
    //

    pIpsecPolicyObject->pszIpsecID = AllocPolStr(
                                         szGuid
                                         );
    if (!pIpsecPolicyObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Fill in the ipsecDataType
    //

    pIpsecPolicyObject->dwIpsecDataType = 0x100;


    //
    // Marshall the pIpsecDataBuffer and the Length
    //

    dwError = MarshallPolicyBuffer(
                    pIpsecPolicyData,
                    &pBuffer,
                    &dwBufferLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyObject->pIpsecData  = pBuffer;
    pIpsecPolicyObject->dwIpsecDataLen = dwBufferLen;

    dwError = ConvertGuidToISAKMPString(
                  pIpsecPolicyData->ISAKMPIdentifier,
                  pszIpsecRootContainer,
                  &pszIpsecISAKMPReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    pIpsecPolicyObject->pszIpsecISAKMPReference = pszIpsecISAKMPReference;

    time(&PresentTime);

    pIpsecPolicyObject->dwWhenChanged = (DWORD) PresentTime;

    *ppIpsecPolicyObject = pIpsecPolicyObject;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }

    return(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
                pIpsecPolicyObject
                );
    }

    *ppIpsecPolicyObject = NULL;
    goto cleanup;

}


DWORD
MarshallPolicyBuffer(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    LPBYTE * ppBuffer,
    DWORD * pdwBufferLen
    )
{
    LPBYTE pBuffer = NULL;
    DWORD dwSize = 0;
    DWORD dwError = 0;
    DWORD dwPollingInterval = 0;
    LPBYTE pCurrentPos = NULL;
    DWORD dwEffectiveSize = 0;

    // {22202163-4F4C-11d1-863B-00A0248D3021}
    static const GUID GUID_IPSEC_POLICY_DATA_BLOB =
    { 0x22202163, 0x4f4c, 0x11d1, { 0x86, 0x3b, 0x0, 0xa0, 0x24, 0x8d, 0x30, 0x21 } };


    dwSize += sizeof(GUID);
    dwSize += sizeof(DWORD);

    dwSize += sizeof(DWORD);
    dwSize++;


    pBuffer = AllocPolMem(dwSize);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pCurrentPos = pBuffer;

    memcpy(pCurrentPos, &GUID_IPSEC_POLICY_DATA_BLOB, sizeof(GUID));
    pCurrentPos += sizeof(GUID);

    dwEffectiveSize = dwSize - sizeof(GUID) - sizeof(DWORD) - 1;

    memcpy(pCurrentPos, &dwEffectiveSize, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    dwPollingInterval = pIpsecPolicyData->dwPollingInterval;
    memcpy(pCurrentPos, &dwPollingInterval, sizeof(DWORD));


    *ppBuffer = pBuffer;
    *pdwBufferLen = dwSize;
    return(dwError);

error:

    if (pBuffer) {
        FreePolMem(pBuffer);
    }

    *ppBuffer = NULL;
    *pdwBufferLen = 0;
    return(dwError);
}


DWORD
ConvertGuidToISAKMPString(
    GUID ISAKMPIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecISAKMPReference
    )
{
    DWORD dwError = 0;
    WCHAR szISAKMPReference[MAX_PATH];
    LPWSTR pszIpsecISAKMPReference = NULL;
    WCHAR szGuidString[MAX_PATH];
    LPWSTR pszStringUuid = NULL;


    dwError = UuidToString(
                  &ISAKMPIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szGuidString[0] = L'\0';
    wcscpy(szGuidString, L"{");
    wcscat(szGuidString, pszStringUuid);
    wcscat(szGuidString, L"}");

    szISAKMPReference[0] = L'\0';
    SecStrCatW(szISAKMPReference, pszIpsecRootContainer, MAX_PATH);
    wcscat(szISAKMPReference, L"\\");
    wcscat(szISAKMPReference, L"ipsecISAKMPPolicy");
    wcscat(szISAKMPReference, szGuidString);

    pszIpsecISAKMPReference = AllocPolStr(
                                    szISAKMPReference
                                    );
    if (!pszIpsecISAKMPReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszIpsecISAKMPReference = pszIpsecISAKMPReference;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    *ppszIpsecISAKMPReference = NULL;

    goto cleanup;
}


DWORD
RegGetPolicyExistingISAKMPRef(
    HKEY hRegistryKey,
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    LPWSTR * ppszISAKMPName
    )
{
    DWORD dwError = 0;
    LPWSTR pszStringUuid = NULL;
    WCHAR szRelativeName[MAX_PATH];
    HKEY hRegKey = NULL;
    DWORD dwSize = 0;


    szRelativeName[0] = L'\0';
    dwError = UuidToString(
                    &pIpsecPolicyData->PolicyIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szRelativeName, L"ipsecPolicy");
    wcscat(szRelativeName, L"{");
    wcscat(szRelativeName, pszStringUuid);
    wcscat(szRelativeName, L"}");

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    szRelativeName,
                    0,
                    KEY_ALL_ACCESS,
                    &hRegKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecISAKMPReference",
                    REG_SZ,
                    (LPBYTE *)ppszISAKMPName,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return (dwError);
}


DWORD
RegAssignPolicy(
    HKEY hHKLMKey,
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    LPWSTR pszLocationName
    )
{
    DWORD dwError = 0;
    WCHAR szRelativeName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;
    WCHAR szAbsPolicyRef[MAX_PATH];
    DWORD dwRealProvider = 0;


    szRelativeName[0] = L'\0';
    dwError = UuidToString(
                  &PolicyIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szRelativeName, L"ipsecPolicy");
    wcscat(szRelativeName, L"{");
    wcscat(szRelativeName, pszStringUuid);
    wcscat(szRelativeName, L"}");

    szAbsPolicyRef[0] = L'\0';
    SecStrCatW(szAbsPolicyRef, pszIpsecRootContainer, MAX_PATH);
    wcscat(szAbsPolicyRef, L"\\");
    wcscat(szAbsPolicyRef, szRelativeName);

    dwError = RegSetValueExW(
                  hRegistryKey,
                  L"ActivePolicy",
                  0,
                  REG_SZ,
                  (LPBYTE) szAbsPolicyRef,
                  (wcslen(szAbsPolicyRef) + 1)*sizeof(WCHAR)
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    // dwProvider store is actually wrong because it's set to IPSEC_REGISTRY_PROVIDER for
    // both perstent and registry policy.  Therefore check Container to determine
    // actual location of store.
    //
    if (wcscmp(pszIpsecRootContainer, gpszRegPersistentContainer) == 0) {
        dwRealProvider = IPSEC_PERSISTENT_PROVIDER;
    } else {
        dwRealProvider = IPSEC_REGISTRY_PROVIDER;
    }
     
    dwError = IPSecChooseDriverBootMode(
                hHKLMKey,
                dwRealProvider,
                POL_ACTION_ASSIGN
                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = PingPolicyAgentSvc(pszLocationName);
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return (dwError);
}


DWORD
RegUnassignPolicy(
    HKEY hHKLMKey,
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    LPWSTR pszLocationName
    )
{
    DWORD dwError = 0;
    DWORD dwRealProvider = 0;

    dwError = RegDeleteValueW(
                  hRegistryKey,
                  L"ActivePolicy"
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    // dwProvider in store is actually wrong because it's set to IPSEC_REGISTRY_PROVIDER for
    // both perstent and registry policy.  Therefore check Container to determine
    // actual location of store.
    //
    if (wcscmp(pszIpsecRootContainer, gpszRegPersistentContainer) == 0) {
        dwRealProvider = IPSEC_PERSISTENT_PROVIDER;
    } else {
        dwRealProvider = IPSEC_REGISTRY_PROVIDER;
    }
     
    dwError = IPSecChooseDriverBootMode(
                hHKLMKey,
                dwRealProvider,
                POL_ACTION_UNASSIGN
                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = PingPolicyAgentSvc(pszLocationName);
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}


DWORD
PingPolicyAgentSvc(
    LPWSTR pszLocationName
    )
{
    SC_HANDLE ServiceDatabase = NULL;
    SC_HANDLE ServiceHandle   = NULL;
    BOOL bStatus = FALSE;
    DWORD dwError = 0;
    SERVICE_STATUS IpsecStatus;


    memset(&IpsecStatus, 0, sizeof(SERVICE_STATUS));

    ServiceDatabase = OpenSCManagerW(
                          pszLocationName,
                          NULL,
                          SC_MANAGER_ALL_ACCESS
                          );
    if (ServiceDatabase == NULL) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ServiceHandle = OpenService(
                        ServiceDatabase,
                        "PolicyAgent",
                        SERVICE_ALL_ACCESS
                        );
    if (ServiceHandle == NULL) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    bStatus = QueryServiceStatus(
                  ServiceHandle,
                  &IpsecStatus
                  );
    if (bStatus == FALSE) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (IpsecStatus.dwCurrentState == SERVICE_STOPPED) {
        bStatus = StartService(
                      ServiceHandle,
                      0,
                      NULL
                      );
        if (bStatus == FALSE) {
            dwError = GetLastError();
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    else if (IpsecStatus.dwCurrentState == SERVICE_RUNNING) {
        bStatus = ControlService(
                      ServiceHandle,
                      129,
                      &IpsecStatus
                      );
        if (bStatus == FALSE) {
            dwError = GetLastError();
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

error:

    if (ServiceDatabase != NULL) {
        CloseServiceHandle(ServiceDatabase);
    }

    if (ServiceHandle != NULL) {
        CloseServiceHandle(ServiceHandle);
    }

    return (dwError);
}


DWORD
IsRegPolicyCurrentlyActive(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PBOOL pbIsActive
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;


    *pbIsActive = FALSE;

    dwError = RegGetAssignedPolicyData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  &pIpsecPolicyData
                  );
    if (pIpsecPolicyData) {
        if (!memcmp(
                &PolicyIdentifier,
                &pIpsecPolicyData->PolicyIdentifier,
                sizeof(GUID))) {
            *pbIsActive = TRUE;
        }
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    dwError = ERROR_SUCCESS;

    return (dwError);
}


DWORD
RegGetPolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyGUID,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    WCHAR szIpsecPolicyName[MAX_PATH];
    LPWSTR pszPolicyName = NULL;

    szIpsecPolicyName[0] = L'\0';
    wcscpy(szIpsecPolicyName, L"ipsecPolicy");

    dwError = UuidToString(&PolicyGUID, &pszPolicyName);
    BAIL_ON_WIN32_ERROR(dwError);

    wcscat(szIpsecPolicyName, L"{");
    wcscat(szIpsecPolicyName, pszPolicyName);
    wcscat(szIpsecPolicyName, L"}");

    dwError = UnMarshallRegistryPolicyObject(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  szIpsecPolicyName,
                  REG_RELATIVE_NAME,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegUnmarshallPolicyData(
                  pIpsecPolicyObject,
                  &pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
            pIpsecPolicyObject
            );
    }

    if (pszPolicyName) {
        RpcStringFree(&pszPolicyName);
    }

    *ppIpsecPolicyData = pIpsecPolicyData;

    return(dwError);
}


DWORD
RegPingPASvcForActivePolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    WCHAR szIpsecPolicyName[MAX_PATH];
    LPWSTR pszPolicyName = NULL;
    WCHAR szAbsPolicyReference[MAX_PATH];


    dwError = RegGetAssignedPolicyData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  &pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!pIpsecPolicyData) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    szIpsecPolicyName[0] = L'\0';
    wcscpy(szIpsecPolicyName, L"ipsecPolicy");

    dwError = UuidToString(&pIpsecPolicyData->PolicyIdentifier, &pszPolicyName);
    BAIL_ON_WIN32_ERROR(dwError);

    wcscat(szIpsecPolicyName, L"{");
    wcscat(szIpsecPolicyName, pszPolicyName);
    wcscat(szIpsecPolicyName, L"}");

    szAbsPolicyReference[0] = L'\0';
    wcscpy(szAbsPolicyReference, pszIpsecRootContainer);
    wcscat(szAbsPolicyReference, L"\\");
    wcscat(szAbsPolicyReference, szIpsecPolicyName);

    dwError = RegUpdatePolicy(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  szAbsPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = PingPolicyAgentSvc(pszLocationName);
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    if (pszPolicyName) {
        RpcStringFree(&pszPolicyName);
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\policy-r.h ===
DWORD
RegEnumPolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    );

DWORD
RegEnumPolicyObjects(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT ** pppIpsecPolicyObjects,
    PDWORD pdwNumPolicyObjects
    );

DWORD
RegSetPolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
RegSetPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    );

DWORD
RegCreatePolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
RegCreatePolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject
    );

DWORD
RegDeletePolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
RegUnmarshallPolicyData(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );

DWORD
RegMarshallPolicyObject(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    );

DWORD
MarshallPolicyBuffer(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    LPBYTE * ppBuffer,
    DWORD * pdwBufferLen
    );

DWORD
ConvertGuidToISAKMPString(
    GUID ISAKMPIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecISAKMPReference
    );

DWORD
RegGetPolicyExistingISAKMPRef(
    HKEY hRegistryKey,
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    LPWSTR * ppszISAKMPName
    );


DWORD
RegAssignPolicy(
    HKEY hHKLMKey,
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    LPWSTR pszLocationName
    );

DWORD
RegUnassignPolicy(
    HKEY hHKLMKey,
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    LPWSTR pszLocationName
    );

DWORD
PingPolicyAgentSvc(
    LPWSTR pszLocationName
    );

DWORD
IsRegPolicyCurrentlyActive(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PBOOL pbIsActive
    );

DWORD
RegGetPolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyGUID,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );

DWORD
RegPingPASvcForActivePolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\policy-w.h ===
DWORD
WMIEnumPolicyDataEx(
    IWbemServices *pWbemServices,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    );

DWORD
WMIEnumPolicyObjectsEx(
    IWbemServices *pWbemServices,
    PIPSEC_POLICY_OBJECT ** pppIpsecPolicyObjects,
    PDWORD pdwNumPolicyObjects
    );

DWORD
WMIUnmarshallPolicyData(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );

DWORD
WMIUnmarshallPolicyObject(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    DWORD dwStoreType,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\policy-w.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       policy-w.c
//
//  Contents:   Policy management for WMI.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//              t-hhsu
//
//----------------------------------------------------------------------------

#include "precomp.h"

//extern LPWSTR PolicyDNAttributes[];


DWORD
WMIEnumPolicyDataEx(
    IWbemServices *pWbemServices,
    PIPSEC_POLICY_DATA ** pppIpsecPolicyData,
    PDWORD pdwNumPolicyObjects
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObjects = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    PIPSEC_POLICY_DATA * ppIpsecPolicyData = NULL;
    DWORD dwNumPolicyObjects = 0;
    DWORD i = 0;
    DWORD j = 0;



    dwError = WMIEnumPolicyObjectsEx(
        pWbemServices,
        &ppIpsecPolicyObjects,
        &dwNumPolicyObjects
        );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumPolicyObjects) {
        ppIpsecPolicyData = (PIPSEC_POLICY_DATA *) AllocPolMem(
            dwNumPolicyObjects*sizeof(PIPSEC_POLICY_DATA));
        if (!ppIpsecPolicyData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    for (i = 0; i < dwNumPolicyObjects; i++) {
        dwError = WMIUnmarshallPolicyData(
            *(ppIpsecPolicyObjects + i),
            &pIpsecPolicyData
            );
        if (!dwError) {
            *(ppIpsecPolicyData + j) = pIpsecPolicyData;
            j++;
        }
    }
    
    if (j == 0) {
        if (ppIpsecPolicyData) {
            FreePolMem(ppIpsecPolicyData);
            ppIpsecPolicyData = NULL;
        }
    }
    
    *pppIpsecPolicyData = ppIpsecPolicyData;
    *pdwNumPolicyObjects = j;
    
    dwError = ERROR_SUCCESS;

 cleanup:

    if (ppIpsecPolicyObjects) {
        FreeIpsecPolicyObjects(
                ppIpsecPolicyObjects,
                dwNumPolicyObjects
                );
    }

    return(dwError);

 error:

    if (ppIpsecPolicyData) {
        FreeMulIpsecPolicyData(
                ppIpsecPolicyData,
                i
                );
    }

    *pppIpsecPolicyData = NULL;
    *pdwNumPolicyObjects = 0;

    goto cleanup;

}


DWORD
WMIEnumPolicyObjectsEx(
    IWbemServices *pWbemServices,
    PIPSEC_POLICY_OBJECT ** pppIpsecPolicyObjects,
    PDWORD pdwNumPolicyObjects
    )
{

    DWORD dwError = 0;
    HRESULT hr = S_OK;
    DWORD dwNumPolicyObjectsReturned = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject =  NULL;
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObjects = NULL;
    
    ///wbem
    IEnumWbemClassObject *pEnum = NULL;
    IWbemClassObject *pObj = NULL;
    ULONG uReturned = 0;
    VARIANT var;
    LPWSTR tmpStr = NULL;
    BSTR bstrTmp = NULL;


    
    *pppIpsecPolicyObjects = NULL;
    *pdwNumPolicyObjects = 0;

    VariantInit(&var);
    
    bstrTmp = SysAllocString(L"RSOP_IPSECPolicySetting");
    if(!bstrTmp) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    //get enum
    hr = IWbemServices_CreateInstanceEnum(
        pWbemServices,
        bstrTmp, //L"RSOP_IPSECPolicySetting"
        WBEM_FLAG_FORWARD_ONLY,
        0,
        &pEnum
        );
    SysFreeString(bstrTmp);
    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
    
    //process
    uReturned = 1;
    while (SUCCEEDED(hr) && (uReturned == 1))
    {
        hr = IEnumWbemClassObject_Next(pEnum, WBEM_INFINITE, 1, &pObj, &uReturned);
        
        if (SUCCEEDED(hr) && (uReturned == 1))
        {
            hr = IWbemClassObject_Get(
                pObj,
                L"id",
                0,
                &var,
                0,
                0
                );
            BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);
            
            tmpStr = var.bstrVal;
            
            if (!wcsstr(tmpStr, L"ipsecPolicy")) {
                IWbemClassObject_Release(pObj);
                VariantClear(&var);
                continue;
            }
            
            pIpsecPolicyObject = NULL;
            
            dwError = UnMarshallWMIPolicyObject(
                pObj,
                &pIpsecPolicyObject
                );
            
            if (dwError == ERROR_SUCCESS) {
                
                dwError = ReallocatePolMem(
                    (LPVOID *) &ppIpsecPolicyObjects,
                    sizeof(PIPSEC_POLICY_OBJECT)*(dwNumPolicyObjectsReturned),
                    sizeof(PIPSEC_POLICY_OBJECT)*(dwNumPolicyObjectsReturned + 1)
                    );
                BAIL_ON_WIN32_ERROR(dwError);
                
                *(ppIpsecPolicyObjects + dwNumPolicyObjectsReturned) = pIpsecPolicyObject;
                dwNumPolicyObjectsReturned++;
            }
            
            //free
            IWbemClassObject_Release(pObj);
            pObj = NULL;
            VariantClear(&var);
        } else {
            BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

            //
            // Even if SUCCEEDED(hr), loop will still terminate since uReturned != 1
            //  
        }
    }
    
    *pppIpsecPolicyObjects = ppIpsecPolicyObjects;
    *pdwNumPolicyObjects = dwNumPolicyObjectsReturned;
    
    dwError = ERROR_SUCCESS;

 cleanup:
    
    if(pEnum)
        IEnumWbemClassObject_Release(pEnum);
    
    return(dwError);
    
 error:
     if (pObj) {
        IWbemClassObject_Release(pObj);
        pObj = NULL;
     }
     VariantClear(&var);
    
    if (ppIpsecPolicyObjects) {
        FreeIpsecPolicyObjects(
            ppIpsecPolicyObjects,
            dwNumPolicyObjectsReturned
            );
    }
    
    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
            pIpsecPolicyObject
            );
    }
    
    *pppIpsecPolicyObjects = NULL;
    *pdwNumPolicyObjects = 0;

    goto cleanup;

}


DWORD
WMIUnmarshallPolicyData(
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallPolicyObject(
        pIpsecPolicyObject,
        IPSEC_WMI_PROVIDER, //(procrule.h)
        ppIpsecPolicyData
        );
    BAIL_ON_WIN32_ERROR(dwError);
    if (*ppIpsecPolicyData) {
       (*ppIpsecPolicyData)->dwFlags |= POLSTORE_READONLY;
    }
    
error:    
    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\refer-d.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       refer-d.c
//
//  Contents:   Reference Management for directory.
//
//
//  History:    KrishnaG
//              AbhishEV
//
//----------------------------------------------------------------------------


#include "precomp.h"


DWORD
DirAddNFAReferenceToPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecNFAReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszIpsecNFAName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_ADD;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecPolicyName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirRemoveNFAReferenceFromPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecNFAReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszIpsecNFAName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_DELETE;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecPolicyName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirAddPolicyReferenceToNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecPolicyName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecOwnersReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszIpsecPolicyName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_ADD;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecNFAName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirAddNegPolReferenceToNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecNegPolName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecNegotiationPolicyReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszIpsecNegPolName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_REPLACE;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecNFAName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirUpdateNegPolReferenceInNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszOldIpsecNegPolName,
    LPWSTR pszNewIpsecNegPolName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecNegotiationPolicyReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszNewIpsecNegPolName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_REPLACE;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecNFAName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirAddFilterReferenceToNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecFilterName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecFilterReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszIpsecFilterName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_REPLACE;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecNFAName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirUpdateFilterReferenceInNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszOldIpsecFilterName,
    LPWSTR pszNewIpsecFilterName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecFilterReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszNewIpsecFilterName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_REPLACE;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecNFAName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirAddNFAReferenceToFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecFilterName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecOwnersReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszIpsecNFAName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_ADD;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecFilterName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirDeleteNFAReferenceInFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecFilterName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecOwnersReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszIpsecNFAName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_DELETE;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecFilterName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirAddNFAReferenceToNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNegPolName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecOwnersReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszIpsecNFAName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_ADD;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecNegPolName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirDeleteNFAReferenceInNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNegPolName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecOwnersReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszIpsecNFAName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_DELETE;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecNegPolName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirAddPolicyReferenceToISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecISAKMPName,
    LPWSTR pszIpsecPolicyName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;


    ppLDAPModW = (LDAPModW **) AllocPolMem(
                               (dwNumAttributes+1)*sizeof(LDAPModW*)
                               );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                             dwNumAttributes*sizeof(LDAPModW)
                             );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                  L"ipsecOwnersReference",
                  &(pLDAPModW +i)->mod_type
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                  pszIpsecPolicyName,
                  (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_ADD;

    dwError = LdapModifyS(
                  hLdapBindHandle,
                  pszIpsecISAKMPName,
                  ppLDAPModW
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirAddISAKMPReferenceToPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecISAKMPName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;


    ppLDAPModW = (LDAPModW **) AllocPolMem(
                               (dwNumAttributes+1)*sizeof(LDAPModW*)
                               );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                             dwNumAttributes*sizeof(LDAPModW)
                             );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                  L"ipsecISAKMPReference",
                  &(pLDAPModW +i)->mod_type
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                  pszIpsecISAKMPName,
                  (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_REPLACE;

    dwError = LdapModifyS(
                  hLdapBindHandle,
                  pszIpsecPolicyName,
                  ppLDAPModW
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirRemovePolicyReferenceFromISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecISAKMPName,
    LPWSTR pszIpsecPolicyName
    )
{
    DWORD dwError = 0;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;


    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecOwnersReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                  pszIpsecPolicyName,
                  (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_DELETE;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecISAKMPName,
                    ppLDAPModW
                    );
    //
    // ipsecOwnersReference may be empty for ISAKMP object.
    //
    if (dwError == ERROR_DS_NO_ATTRIBUTE_OR_VALUE) {
        dwError = 0;
    }
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirUpdateISAKMPReferenceInPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszOldIpsecISAKMPName,
    LPWSTR pszNewIpsecISAKMPName
    )
{
    DWORD dwError = 0;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;


    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecISAKMPReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pszNewIpsecISAKMPName,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pLDAPModW[i].mod_op |= LDAP_MOD_REPLACE;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecPolicyName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirRemoveFilterReferenceInNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                    L"ipsecFilterReference",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW +i)->mod_values = NULL;

    pLDAPModW[i].mod_op |= LDAP_MOD_DELETE;

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pszIpsecNFAName,
                    ppLDAPModW
                    );
    if (dwError == ERROR_DS_NO_ATTRIBUTE_OR_VALUE) {
        dwError = 0;
    }
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\precomp.h ===
//
// System Includes
//

#include "nsu.h"
#include <windows.h>

//
// CRunTime Includes
//

#include <stdlib.h>
#include <limits.h>
#include <io.h>
#include <stdio.h>
#include <wchar.h>

#include <dsgetdc.h>
#include <lm.h>

#define UNICODE
#define COBJMACROS

#include <rpc.h>
#include <winldap.h>
#include <time.h>
#include <ipsec.h>
#include <oakdefs.h>
#include <wbemidl.h>
#include <oleauto.h>
#include <objbase.h>

#include "polstore2.h"

#include "ldaputil.h"
#include "memory.h"
#include "structs.h"
#include "dsstore.h"
#include "regstore.h"
#include "wmistore.h"
#include "persist.h"
#include "persist-w.h"
#include "procrule.h"
#include "utils.h"

#include "policy-d.h"
#include "policy-r.h"
#include "policy-w.h"
#include "filters-d.h"
#include "filters-r.h"
#include "filters-w.h"
#include "negpols-d.h"
#include "negpols-r.h"
#include "negpols-w.h"
#include "rules-d.h"
#include "rules-r.h"
#include "rules-w.h"
#include "refer-d.h"
#include "refer-r.h"
#include "isakmp-d.h"
#include "isakmp-r.h"
#include "isakmp-w.h"

#include "connui.h"
#include "reginit.h"
#include "dllsvr.h"
#include "update-d.h"
#include "update-r.h"

#include "polstmsg.h"

#include "safestr.h"

typedef struct _IPSEC_POLICY_STORE {
    DWORD dwProvider;
    HKEY  hParentRegistryKey;
    HKEY  hRegistryKey;
    LPWSTR pszLocationName;
    HLDAP hLdapBindHandle;
    LPWSTR pszIpsecRootContainer;
    LPWSTR pszFileName;
    IWbemServices *pWbemServices;
}IPSEC_POLICY_STORE, *PIPSEC_POLICY_STORE;

#include "import.h"
#include "export.h"
#include "policy-f.h"
#include "filters-f.h"
#include "negpols-f.h"
#include "isakmp-f.h"
#include "rules-f.h"
#include "restore-r.h"
#include "validate.h"

#include "nsuacl.h"

#define POLSTORE_POLICY_PERMISSIONS NSU_ACL_F_AdminFull | NSU_ACL_F_LocalSystemFull

#define REG_VAL_IPSEC_OPERATIONMODE L"OperationMode"
#define REG_VAL_IPSEC_BOOTEXEMPTLIST L"BootExemptList"
#define REG_KEY_IPSEC_DRIVER_SERVICE L"SYSTEM\\CurrentControlSet\\Services\\IPSec"

#define SZAPPNAME L"polstore.dll"

//
// These are declared in API.C

extern LPWSTR gpszRegLocalContainer;
extern LPWSTR gpszRegPersistentContainer;
extern LPWSTR gpszIpsecFileRootContainer;
extern LPWSTR gpszIPsecDirContainer;
extern LPWSTR gpActivePolicyKey;
extern LPWSTR gpDirectoryPolicyPointerKey;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\refer-d.h ===
DWORD
DirAddNFAReferenceToPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecNFAName
    );

DWORD
DirRemoveNFAReferenceFromPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecNFAName
    );

DWORD
DirAddPolicyReferenceToNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecPolicyName
    );

DWORD
DirAddNegPolReferenceToNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecNegPolName
    );

DWORD
DirUpdateNegPolReferenceInNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszOldIpsecNegPolName,
    LPWSTR pszNewIpsecNegPolName
    );

DWORD
DirAddFilterReferenceToNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecFilterName
    );

DWORD
DirUpdateFilterReferenceInNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszOldIpsecFilterName,
    LPWSTR pszNewIpsecFilterName
    );

DWORD
DirAddNFAReferenceToFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNegPolName,
    LPWSTR pszIpsecNFAName
    );

DWORD
DirDeleteNFAReferenceInFilterObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecFilterName,
    LPWSTR pszIpsecNFAName
    );

DWORD
DirAddNFAReferenceToNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNegPolName,
    LPWSTR pszIpsecNFAName
    );

DWORD
DirDeleteNFAReferenceInNegPolObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNegPolName,
    LPWSTR pszIpsecNFAName
    );

DWORD
DirAddPolicyReferenceToISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecISAKMPName,
    LPWSTR pszIpsecPolicyName
    );

DWORD
DirAddISAKMPReferenceToPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecISAKMPName
    );

DWORD
DirRemovePolicyReferenceFromISAKMPObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecISAKMPName,
    LPWSTR pszIpsecPolicyName
    );

DWORD
DirUpdateISAKMPReferenceInPolicyObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszOldIpsecISAKMPName,
    LPWSTR pszNewIpsecISAKMPName
    );

DWORD
DirRemoveFilterReferenceInNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecNFAName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\refer-r.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       refer-r.c
//
//  Contents:   Reference management for registry.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//
//----------------------------------------------------------------------------


#include "precomp.h"


//
// Policy Object References
//

DWORD
RegAddNFAReferenceToPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecNFADistinguishedName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pValueData = NULL;
    LPBYTE pNewValueData = NULL;
    DWORD dwSize = 0;
    DWORD dwNewSize = 0;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecPolicyName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hKey,
                    L"ipsecNFAReference",
                    REG_MULTI_SZ,
                    &pValueData,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = AddValueToMultiSz(
                    pValueData,
                    dwSize,
                    pszIpsecNFADistinguishedName,
                    &pNewValueData,
                    &dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecNFAReference",
                    0,
                    REG_MULTI_SZ,
                    (LPBYTE)pNewValueData,
                    dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (pValueData) {
        FreePolMem(pValueData);
    }

    if (pNewValueData) {
        FreePolMem(pNewValueData);
    }

    return(dwError);
}


DWORD
RegRemoveNFAReferenceFromPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pValueData = NULL;
    LPBYTE pNewValueData = NULL;
    DWORD dwSize = 0;
    DWORD dwNewSize = 0;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecPolicyName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hKey,
                    L"ipsecNFAReference",
                    REG_MULTI_SZ,
                    &pValueData,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DeleteValueFromMultiSz(
                    pValueData,
                    dwSize,
                    pszIpsecNFAName,
                    &pNewValueData,
                    &dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pNewValueData && *pNewValueData) {
        dwError = RegSetValueExW(
                      hKey,
                      L"ipsecNFAReference",
                      0,
                      REG_MULTI_SZ,
                      (LPBYTE)pNewValueData,
                      dwNewSize
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    else {
        dwError = RegDeleteValueW(
                      hKey,
                      L"ipsecNFAReference"
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (pValueData) {
        FreePolMem(pValueData);
    }

    if (pNewValueData) {
        FreePolMem(pNewValueData);
    }

    return(dwError);
}

//
// NFA Object References
//

DWORD
RegAddPolicyReferenceToNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecPolicyName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pValueData = NULL;
    LPBYTE pNewValueData = NULL;
    DWORD dwSize = 0;
    DWORD dwNewSize = 0;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecNFAName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hKey,
                    L"ipsecOwnersReference",
                    REG_MULTI_SZ,
                    &pValueData,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = AddValueToMultiSz(
                    pValueData,
                    dwSize,
                    pszIpsecPolicyName,
                    &pNewValueData,
                    &dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecOwnersReference",
                    0,
                    REG_MULTI_SZ,
                    (LPBYTE)pNewValueData,
                    dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (pValueData) {
        FreePolMem(pValueData);
    }

    if (pNewValueData) {
        FreePolMem(pNewValueData);
    }

    return(dwError);
}


DWORD
RegAddNegPolReferenceToNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecNegPolName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecNFAName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecNegotiationPolicyReference",
                    0,
                    REG_SZ,
                    (LPBYTE)pszIpsecNegPolName,
                    (wcslen(pszIpsecNegPolName) + 1)*sizeof(WCHAR)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    return(dwError);
}


DWORD
RegUpdateNegPolReferenceInNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszOldIpsecNegPolName,
    LPWSTR pszNewIpsecNegPolName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecNFAName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecNegotiationPolicyReference",
                    0,
                    REG_SZ,
                    (LPBYTE)pszNewIpsecNegPolName,
                    (wcslen(pszNewIpsecNegPolName) + 1)*sizeof(WCHAR)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    return(dwError);
}


DWORD
RegAddFilterReferenceToNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecFilterName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pMem = NULL;


    pMem = AllocPolMem(
               (wcslen(pszIpsecFilterName) + 1 + 1)*sizeof(WCHAR)
               );
    if (!pMem) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        pMem,
        (LPBYTE) pszIpsecFilterName,
        (wcslen(pszIpsecFilterName) + 1)*sizeof(WCHAR)
        );

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecNFAName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecFilterReference",
                    0,
                    REG_MULTI_SZ,
                    pMem,
                    (wcslen(pszIpsecFilterName) + 1 + 1)*sizeof(WCHAR)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pMem) {
        FreePolMem(pMem);
    }

    if (hKey) {
        RegCloseKey(hKey);
    }

    return(dwError);
}


DWORD
RegUpdateFilterReferenceInNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszOldIpsecFilterName,
    LPWSTR pszNewIpsecFilterName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pMem = NULL;


    pMem = AllocPolMem(
               (wcslen(pszNewIpsecFilterName) + 1 + 1)*sizeof(WCHAR)
               );
    if (!pMem) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        pMem,
        (LPBYTE) pszNewIpsecFilterName,
        (wcslen(pszNewIpsecFilterName) + 1)*sizeof(WCHAR)
        );

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecNFAName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecFilterReference",
                    0,
                    REG_MULTI_SZ,
                    pMem,
                    (wcslen(pszNewIpsecFilterName) + 1 + 1)*sizeof(WCHAR)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pMem) {
        FreePolMem(pMem);
    }

    if (hKey) {
        RegCloseKey(hKey);
    }

    return(dwError);
}

//
// Filter Object References
//

DWORD
RegAddNFAReferenceToFilterObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecFilterName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pValueData = NULL;
    LPBYTE pNewValueData = NULL;
    DWORD dwSize = 0;
    DWORD dwNewSize = 0;


    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecFilterName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hKey,
                    L"ipsecOwnersReference",
                    REG_MULTI_SZ,
                    &pValueData,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = AddValueToMultiSz(
                    pValueData,
                    dwSize,
                    pszIpsecNFAName,
                    &pNewValueData,
                    &dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecOwnersReference",
                    0,
                    REG_MULTI_SZ,
                    (LPBYTE)pNewValueData,
                    dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (pValueData) {
        FreePolMem(pValueData);
    }

    if (pNewValueData) {
        FreePolMem(pNewValueData);
    }

    return(dwError);
}

DWORD
RegDeleteNFAReferenceInFilterObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecFilterName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pValueData = NULL;
    LPBYTE pNewValueData = NULL;
    DWORD dwSize = 0;
    DWORD dwNewSize = 0;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecFilterName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hKey,
                    L"ipsecOwnersReference",
                    REG_MULTI_SZ,
                    &pValueData,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DeleteValueFromMultiSz(
                    pValueData,
                    dwSize,
                    pszIpsecNFAName,
                    &pNewValueData,
                    &dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pNewValueData && *pNewValueData) {
        dwError = RegSetValueExW(
                      hKey,
                      L"ipsecOwnersReference",
                      0,
                      REG_MULTI_SZ,
                      (LPBYTE)pNewValueData,
                      dwNewSize
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    else {
        dwError = RegDeleteValueW(
                      hKey,
                      L"ipsecOwnersReference"
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (pValueData) {
        FreePolMem(pValueData);
    }

    if (pNewValueData) {
        FreePolMem(pNewValueData);
    }

    return(dwError);
}


//
// NegPol Object References
//


DWORD
RegAddNFAReferenceToNegPolObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNegPolName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pValueData = NULL;
    LPBYTE pNewValueData = NULL;
    DWORD dwSize = 0;
    DWORD dwNewSize = 0;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecNegPolName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hKey,
                    L"ipsecOwnersReference",
                    REG_MULTI_SZ,
                    &pValueData,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = AddValueToMultiSz(
                    pValueData,
                    dwSize,
                    pszIpsecNFAName,
                    &pNewValueData,
                    &dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecOwnersReference",
                    0,
                    REG_MULTI_SZ,
                    (LPBYTE)pNewValueData,
                    dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (pValueData) {
        FreePolMem(pValueData);
    }

    if (pNewValueData) {
        FreePolMem(pNewValueData);
    }

    return(dwError);
}


DWORD
RegDeleteNFAReferenceInNegPolObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNegPolName,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pValueData = NULL;
    LPBYTE pNewValueData = NULL;
    DWORD dwSize = 0;
    DWORD dwNewSize = 0;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecNegPolName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hKey,
                    L"ipsecOwnersReference",
                    REG_MULTI_SZ,
                    &pValueData,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DeleteValueFromMultiSz(
                    pValueData,
                    dwSize,
                    pszIpsecNFAName,
                    &pNewValueData,
                    &dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pNewValueData && *pNewValueData) {
        dwError = RegSetValueExW(
                      hKey,
                      L"ipsecOwnersReference",
                      0,
                      REG_MULTI_SZ,
                      (LPBYTE)pNewValueData,
                      dwNewSize
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    else {
        dwError = RegDeleteValueW(
                      hKey,
                      L"ipsecOwnersReference"
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (pValueData) {
        FreePolMem(pValueData);
    }

    if (pNewValueData) {
        FreePolMem(pNewValueData);
    }

    return(dwError);
}


DWORD
AddValueToMultiSz(
    LPBYTE pValueData,
    DWORD dwSize,
    LPWSTR pszValuetoAdd,
    LPBYTE * ppNewValueData,
    DWORD * pdwNewSize
    )
{
    DWORD dwError = ERROR_SUCCESS;
    LPBYTE pNewValueData = NULL;
    LPBYTE pNewPtr = NULL;
    DWORD dwLen = 0;
    DWORD dwAddSize = 0;
    DWORD dwNewSize = 0;
    BOOL bFound = FALSE;
    LPWSTR pszTemp = NULL;


    *ppNewValueData = NULL;
    *pdwNewSize = 0;

    dwLen = wcslen(pszValuetoAdd);
    dwLen ++;
    dwAddSize = dwLen*sizeof(WCHAR);

    if (pValueData) {

        pszTemp = (LPWSTR) pValueData;
        while (*pszTemp != L'\0') {
            if (!_wcsicmp(pszTemp, pszValuetoAdd)) {
                bFound = TRUE;
                break;
            }
            pszTemp += wcslen(pszTemp) + 1;
        }

        if (bFound) {
            dwNewSize = dwSize;
        }
        else {
            dwNewSize = dwSize + dwAddSize;
        }

    }
    else {
        dwNewSize = dwAddSize + sizeof(WCHAR);
    }

    pNewValueData = (LPBYTE)AllocPolMem(dwNewSize);
    if (!pNewValueData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!bFound) {
        wcscpy((LPWSTR)pNewValueData, pszValuetoAdd);
        pNewPtr = pNewValueData + dwAddSize;
    }
    else {
        pNewPtr = pNewValueData;
    }

    if (pValueData) {
        memcpy(pNewPtr, pValueData, dwSize);
    }

    *ppNewValueData = pNewValueData;
    *pdwNewSize = dwNewSize;

error:

    return(dwError);
}

DWORD
DeleteValueFromMultiSz(
    LPBYTE pValueData,
    DWORD dwSize,
    LPWSTR pszValuetoDel,
    LPBYTE * ppNewValueData,
    DWORD * pdwNewSize
    )
{
    DWORD dwError = ERROR_SUCCESS;
    LPBYTE pNewValueData = NULL;
    LPBYTE pNew = NULL;
    DWORD dwLen = 0;
    DWORD dwDelSize = 0;
    DWORD dwNewSize = 0;
    BOOL bFound = FALSE;
    LPWSTR pszTemp = NULL;


    *ppNewValueData = NULL;
    *pdwNewSize = 0;

    if (!pValueData || !dwSize) {
        return (ERROR_INVALID_PARAMETER);
    }

    pszTemp = (LPWSTR) pValueData;
    while (*pszTemp != L'\0') {
        if (!_wcsicmp(pszTemp, pszValuetoDel)) {
            bFound = TRUE;
            break;
        }
        pszTemp += wcslen(pszTemp) + 1;
    }

    if (!bFound) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwLen = wcslen(pszValuetoDel);
    dwLen ++;
    dwDelSize = dwLen*sizeof(WCHAR);


    if (dwSize == dwDelSize) {
        return (ERROR_SUCCESS);
    }

    dwNewSize = dwSize - dwDelSize;

    pNewValueData = (LPBYTE)AllocPolMem(dwNewSize);
    if (!pNewValueData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pszTemp = (LPWSTR) pValueData;
    pNew = pNewValueData;
    while (*pszTemp != L'\0') {
        if (!_wcsicmp(pszTemp, pszValuetoDel)) {
            pszTemp += wcslen(pszTemp) + 1;
        }
        else {
            memcpy(pNew, (LPBYTE) pszTemp, (wcslen(pszTemp)+1)*sizeof(WCHAR));
            pNew += (wcslen(pszTemp)+1)*sizeof(WCHAR);
            pszTemp += wcslen(pszTemp) + 1;
        }
    }

    *ppNewValueData = pNewValueData;
    *pdwNewSize = dwNewSize;

error:

    return(dwError);
}


DWORD
RegDelFilterRefValueOfNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecNFAName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegDeleteValueW(
                    hKey,
                    L"ipsecFilterReference"
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    return(dwError);
}

//
// ISAKMP Object References.
//

DWORD
RegAddPolicyReferenceToISAKMPObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecISAKMPName,
    LPWSTR pszIpsecPolicyDistinguishedName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pValueData = NULL;
    LPBYTE pNewValueData = NULL;
    DWORD dwSize = 0;
    DWORD dwNewSize = 0;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecISAKMPName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hKey,
                    L"ipsecOwnersReference",
                    REG_MULTI_SZ,
                    &pValueData,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = AddValueToMultiSz(
                    pValueData,
                    dwSize,
                    pszIpsecPolicyDistinguishedName,
                    &pNewValueData,
                    &dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecOwnersReference",
                    0,
                    REG_MULTI_SZ,
                    (LPBYTE)pNewValueData,
                    dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (pValueData) {
        FreePolMem(pValueData);
    }

    if (pNewValueData) {
        FreePolMem(pNewValueData);
    }

    return(dwError);
}


DWORD
RegRemovePolicyReferenceFromISAKMPObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecISAKMPName,
    LPWSTR pszIpsecPolicyName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;
    LPBYTE pValueData = NULL;
    LPBYTE pNewValueData = NULL;
    DWORD dwSize = 0;
    DWORD dwNewSize = 0;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecISAKMPName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hKey,
                    L"ipsecOwnersReference",
                    REG_MULTI_SZ,
                    &pValueData,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DeleteValueFromMultiSz(
                    pValueData,
                    dwSize,
                    pszIpsecPolicyName,
                    &pNewValueData,
                    &dwNewSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pNewValueData && *pNewValueData) {
        dwError = RegSetValueExW(
                      hKey,
                      L"ipsecOwnersReference",
                      0,
                      REG_MULTI_SZ,
                      (LPBYTE)pNewValueData,
                      dwNewSize
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    else {
        dwError = RegDeleteValueW(
                      hKey,
                      L"ipsecOwnersReference"
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (pValueData) {
        FreePolMem(pValueData);
    }

    if (pNewValueData) {
        FreePolMem(pNewValueData);
    }

    return(dwError);
}

//
// Policy Object Reference to the ISAKMP object.
//

DWORD
RegAddISAKMPReferenceToPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecISAKMPName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecPolicyName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecISAKMPReference",
                    0,
                    REG_SZ,
                    (LPBYTE)pszIpsecISAKMPName,
                    (wcslen(pszIpsecISAKMPName) + 1)*sizeof(WCHAR)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    return(dwError);
}


DWORD
RegUpdateISAKMPReferenceInPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszOldIpsecISAKMPName,
    LPWSTR pszNewIpsecISAKMPName
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HKEY hKey = NULL;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecPolicyName,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegSetValueExW(
                    hKey,
                    L"ipsecISAKMPReference",
                    0,
                    REG_SZ,
                    (LPBYTE)pszNewIpsecISAKMPName,
                    (wcslen(pszNewIpsecISAKMPName) + 1)*sizeof(WCHAR)
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hKey) {
        RegCloseKey(hKey);
    }

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\restore-r.h ===
DWORD
RegRestoreDefaults(
    HANDLE hPolicyStore,
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName
    );

DWORD
RegRemoveDefaults(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName
    );

DWORD
RegDeleteDefaultPolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    GUID PolicyGUID
    );

DWORD
RegDeleteDynamicDefaultNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    GUID NegPolGUID
    );

DWORD
RegRemoveOwnersReferenceInFilter(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    );

DWORD
RegRemoveOwnersReferenceInNegPol(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    );

DWORD
RegRemoveOwnersReferenceInISAKMP(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    );

DWORD
RegDeleteDefaultFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    );

DWORD
RegDeleteDefaultNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    );

DWORD
RegDeleteDefaultISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    );

DWORD
RegUpdateFilterOwnersReference(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier,
    LPWSTR * ppszIpsecNFAReferences,
    DWORD dwNumNFAReferences
    );


DWORD
RegUpdateNegPolOwnersReference(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier,
    LPWSTR * ppszIpsecNFAReferences,
    DWORD dwNumNFAReferences
    );


DWORD
RegUpdateISAKMPOwnersReference(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier,
    LPWSTR * ppszIpsecPolicyReferences,
    DWORD dwNumPolicyReferences
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\reginit.h ===
DWORD
GenerateDefaultInformation(
    HANDLE hPolicyStore
    );

DWORD
CreateAllFilter(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA * ppAllFilter
    );

DWORD
CreateAllICMPFilter(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA * ppAllICMPFilter
    );

DWORD
CreatePermitNegPol(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA * ppPermitNegPol
    );

DWORD
CreateRequestSecurityNegPol(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA * ppRequestSecurityNegPol
    );

DWORD
CreateRequireSecurityNegPol(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA * ppRequireSecurityNegPol
    );

DWORD
CreateClientPolicy(
    HANDLE hPolicyStore
    );

DWORD
CreateRequestSecurityPolicy(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA pAllFilter,
    PIPSEC_FILTER_DATA pAllICMPFilter,
    PIPSEC_NEGPOL_DATA pPermitNegPol,
    PIPSEC_NEGPOL_DATA pRequestSecurityNegPol
    );

DWORD
CreateRequireSecurityPolicy(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA pAllFilter,
    PIPSEC_FILTER_DATA pAllICMPFilter,
    PIPSEC_NEGPOL_DATA pPermitNegPol,
    PIPSEC_NEGPOL_DATA pRequireSecurityNegPol
    );

DWORD
CreateISAKMP(
    HANDLE hPolicyStore,
    GUID ISAKMPIdentifier,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    );

DWORD
CreateDefaultNegPol(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA * ppDefaultNegPol
    );

DWORD
CreateNFA(
    HANDLE hPolicyStore,
    GUID NFAIdentifier,
    GUID PolicyIdentifier,
    GUID FilterIdentifier,
    GUID NegPolIdentifier,
    LPWSTR pszNFAName,
    LPWSTR pszNFADescription
    );

DWORD
MapIdAndCreateNFA(
    HANDLE hPolicyStore,
    GUID NFAIdentifier,
    GUID PolicyIdentifier,
    GUID FilterIdentifier,
    GUID NegPolIdentifier,
    DWORD dwNFANameID,
    DWORD dwNFADescriptionID
    );

DWORD
MapAndAllocPolStr(
    LPWSTR * plpStr,
    DWORD dwStrID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\restore-r.c ===
#include "precomp.h"


DWORD
RegRestoreDefaults(
    HANDLE hPolicyStore,
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName
    )
{
    DWORD dwError = 0;

    LPWSTR * ppszIpsecAllFilterNFAReferences = NULL;
    DWORD dwNumAllFilterNFAReferences = 0;
    LPWSTR * ppszIpsecAllICMPFilterNFAReferences = NULL;
    DWORD dwNumAllICMPFilterNFAReferences = 0;

    LPWSTR * ppszIpsecPermitNegPolNFAReferences = NULL;
    DWORD dwNumPermitNegPolNFAReferences = 0;
    LPWSTR * ppszIpsecSecIniNegPolNFAReferences = NULL;
    DWORD dwNumSecIniNegPolNFAReferences = 0;
    LPWSTR * ppszIpsecLockdownNegPolNFAReferences = NULL;
    DWORD dwNumLockdownNegPolNFAReferences = 0;


    LPWSTR * ppszIpsecLockdownISAKMPPolicyReferences = NULL;
    DWORD dwNumLockdownISAKMPPolicyReferences = 0;
    LPWSTR * ppszIpsecSecIniISAKMPPolicyReferences = NULL;
    DWORD dwNumSecIniISAKMPPolicyReferences = 0;
    LPWSTR * ppszIpsecResponderISAKMPPolicyReferences = NULL;
    DWORD dwNumResponderISAKMPPolicyReferences = 0;
    LPWSTR * ppszIpsecDefaultISAKMPPolicyReferences = NULL;
    DWORD dwNumDefaultISAKMPPolicyReferences = 0;

    static const GUID GUID_ALL_FILTER=
    { 0x7238523a, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    static const GUID GUID_ALL_ICMP_FILTER =
    { 0x72385235, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    static const GUID GUID_PERMIT_NEGPOL =
    { 0x7238523b, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    static const GUID GUID_SECURE_INITIATOR_NEGPOL =
    { 0x72385233, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    static const GUID GUID_LOCKDOWN_NEGPOL =
    { 0x7238523f, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };
 
    static const GUID GUID_RESPONDER_ISAKMP =
    { 0x72385237, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    static const GUID GUID_SECURE_INITIATOR_ISAKMP =
    { 0x72385231, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    static const GUID GUID_LOCKDOWN_ISAKMP =
    { 0x7238523d, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    static const GUID GUID_DEFAULT_ISAKMP=
    { 0x72385234, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


    dwError = RegRemoveDefaults(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszLocationName
                  );

    dwError = RegDeleteDefaultFilterData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_ALL_FILTER,
                  &ppszIpsecAllFilterNFAReferences,
                  &dwNumAllFilterNFAReferences
                  );

    dwError = RegDeleteDefaultFilterData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_ALL_ICMP_FILTER,
                  &ppszIpsecAllICMPFilterNFAReferences,
                  &dwNumAllICMPFilterNFAReferences
                  );

    dwError = RegDeleteDefaultNegPolData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_PERMIT_NEGPOL,
                  &ppszIpsecPermitNegPolNFAReferences,
                  &dwNumPermitNegPolNFAReferences
                  );

    dwError = RegDeleteDefaultNegPolData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_SECURE_INITIATOR_NEGPOL,
                  &ppszIpsecSecIniNegPolNFAReferences,
                  &dwNumSecIniNegPolNFAReferences
                  );

    dwError = RegDeleteDefaultNegPolData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_LOCKDOWN_NEGPOL,
                  &ppszIpsecLockdownNegPolNFAReferences,
                  &dwNumLockdownNegPolNFAReferences
                  );

    dwError = RegDeleteDefaultISAKMPData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_LOCKDOWN_ISAKMP,
                  &ppszIpsecLockdownISAKMPPolicyReferences,
                  &dwNumLockdownISAKMPPolicyReferences
                  );

    dwError = RegDeleteDefaultISAKMPData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_SECURE_INITIATOR_ISAKMP,
                  &ppszIpsecSecIniISAKMPPolicyReferences,
                  &dwNumSecIniISAKMPPolicyReferences
                  );

    dwError = RegDeleteDefaultISAKMPData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_RESPONDER_ISAKMP,
                  &ppszIpsecResponderISAKMPPolicyReferences,
                  &dwNumResponderISAKMPPolicyReferences
                  );

    dwError = RegDeleteDefaultISAKMPData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_DEFAULT_ISAKMP,
                  &ppszIpsecDefaultISAKMPPolicyReferences,
                  &dwNumDefaultISAKMPPolicyReferences
                  );

    dwError = GenerateDefaultInformation(
                  hPolicyStore
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegUpdateFilterOwnersReference(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_ALL_FILTER,
                  ppszIpsecAllFilterNFAReferences,
                  dwNumAllFilterNFAReferences
                  );

    dwError = RegUpdateFilterOwnersReference(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_ALL_ICMP_FILTER,
                  ppszIpsecAllICMPFilterNFAReferences,
                  dwNumAllICMPFilterNFAReferences
                  );

    dwError = RegUpdateNegPolOwnersReference(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_LOCKDOWN_NEGPOL,
                  ppszIpsecLockdownNegPolNFAReferences,
                  dwNumLockdownNegPolNFAReferences
                  );

    dwError = RegUpdateNegPolOwnersReference(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_SECURE_INITIATOR_NEGPOL,
                  ppszIpsecSecIniNegPolNFAReferences,
                  dwNumSecIniNegPolNFAReferences
                  );

    dwError = RegUpdateNegPolOwnersReference(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_PERMIT_NEGPOL,
                  ppszIpsecPermitNegPolNFAReferences,
                  dwNumPermitNegPolNFAReferences
                  );

    dwError = RegUpdateISAKMPOwnersReference(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_LOCKDOWN_ISAKMP,
                  ppszIpsecLockdownISAKMPPolicyReferences,
                  dwNumLockdownISAKMPPolicyReferences
                  );

    dwError = RegUpdateISAKMPOwnersReference(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_SECURE_INITIATOR_ISAKMP,
                  ppszIpsecSecIniISAKMPPolicyReferences,
                  dwNumSecIniISAKMPPolicyReferences
                  );

    dwError = RegUpdateISAKMPOwnersReference(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_RESPONDER_ISAKMP,
                  ppszIpsecResponderISAKMPPolicyReferences,
                  dwNumResponderISAKMPPolicyReferences
                  );

    dwError = RegUpdateISAKMPOwnersReference(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  GUID_DEFAULT_ISAKMP,
                  ppszIpsecDefaultISAKMPPolicyReferences,
                  dwNumDefaultISAKMPPolicyReferences
                  );

    (VOID) RegPingPASvcForActivePolicy(
               hRegistryKey,
               pszIpsecRootContainer,
               pszLocationName
               );

error:

    if (ppszIpsecAllFilterNFAReferences) {
        FreeNFAReferences(
            ppszIpsecAllFilterNFAReferences,
            dwNumAllFilterNFAReferences
            );
    }

    if (ppszIpsecAllICMPFilterNFAReferences) {
        FreeNFAReferences(
            ppszIpsecAllICMPFilterNFAReferences,
            dwNumAllICMPFilterNFAReferences
            );
    }

    if (ppszIpsecPermitNegPolNFAReferences) {
        FreeNFAReferences(
            ppszIpsecPermitNegPolNFAReferences,
            dwNumPermitNegPolNFAReferences
            );
    }

    if (ppszIpsecSecIniNegPolNFAReferences) {
        FreeNFAReferences(
            ppszIpsecSecIniNegPolNFAReferences,
            dwNumSecIniNegPolNFAReferences
            );
    }

    if (ppszIpsecLockdownNegPolNFAReferences) {
        FreeNFAReferences(
            ppszIpsecLockdownNegPolNFAReferences,
            dwNumLockdownNegPolNFAReferences
            );
    }

    if (ppszIpsecResponderISAKMPPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecResponderISAKMPPolicyReferences,
            dwNumResponderISAKMPPolicyReferences
            );
    }

    if (ppszIpsecSecIniISAKMPPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecSecIniISAKMPPolicyReferences,
            dwNumSecIniISAKMPPolicyReferences
            );
    }

    if (ppszIpsecLockdownISAKMPPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecLockdownISAKMPPolicyReferences,
            dwNumLockdownISAKMPPolicyReferences
            );
    }

    if (ppszIpsecDefaultISAKMPPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecDefaultISAKMPPolicyReferences,
            dwNumDefaultISAKMPPolicyReferences
            );
    }

    return (dwError);
}


DWORD
RegRemoveDefaults(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName
    )
{
    DWORD dwError = 0;

    static const GUID GUID_RESPONDER_POLICY =
    { 0x72385236, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    static const GUID GUID_SECURE_INITIATOR_POLICY =
    { 0x72385230, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    static const GUID GUID_LOCKDOWN_POLICY =
    { 0x7238523c, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    dwError = RegDeleteDefaultPolicyData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszLocationName,
                  GUID_LOCKDOWN_POLICY
                  );
    
    dwError = RegDeleteDefaultPolicyData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszLocationName,
                  GUID_SECURE_INITIATOR_POLICY
                  );

    dwError = RegDeleteDefaultPolicyData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszLocationName,
                  GUID_RESPONDER_POLICY
                  );

    dwError = ERROR_SUCCESS;

    return (dwError);
}


DWORD
RegDeleteDefaultPolicyData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    GUID PolicyGUID
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;
    DWORD dwNumNFAObjects = 0;
    DWORD i = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;


    dwError = RegGetPolicyData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  PolicyGUID,
                  &pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegEnumNFAData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  PolicyGUID,
                  &ppIpsecNFAData,
                  &dwNumNFAObjects
                  );
    
    for (i = 0; i < dwNumNFAObjects; i++) {

        pIpsecNFAData = *(ppIpsecNFAData + i);

        dwError = RegDeleteNFAData(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      PolicyGUID,
                      pszLocationName,
                      pIpsecNFAData
                      );

        dwError = RegDeleteDynamicDefaultNegPolData(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      pszLocationName,
                      pIpsecNFAData->NegPolIdentifier
                      );

    }

    dwError = RegDeletePolicyData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:
    
    if (ppIpsecNFAData) {
        FreeMulIpsecNFAData(
            ppIpsecNFAData,
            dwNumNFAObjects
            );
    }

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(
            pIpsecPolicyData
            );
    }

    return(dwError);        
}


DWORD
RegDeleteDynamicDefaultNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    GUID NegPolGUID
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;


    dwError = RegGetNegPolData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  NegPolGUID,
                  &pIpsecNegPolData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!memcmp(
            &(pIpsecNegPolData->NegPolType),
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {

        dwError = RegDeleteNegPolData(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      NegPolGUID
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (pIpsecNegPolData) {
        FreeIpsecNegPolData(
            pIpsecNegPolData
            );
    }

    return(dwError);        
}


DWORD
RegDeleteDefaultFilterData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;


    *pppszIpsecNFAReferences = NULL;
    *pdwNumReferences = 0;

    dwError = RegRemoveOwnersReferenceInFilter(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  FilterIdentifier,
                  pppszIpsecNFAReferences,
                  pdwNumReferences
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegDeleteFilterData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  FilterIdentifier
                  );
error:

    return (dwError);
}


DWORD
RegDeleteDefaultNegPolData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;


    *pppszIpsecNFAReferences = NULL;
    *pdwNumReferences = 0;

    dwError = RegRemoveOwnersReferenceInNegPol(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  NegPolIdentifier,
                  pppszIpsecNFAReferences,
                  pdwNumReferences
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegDeleteNegPolData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  NegPolIdentifier
                  );
error:

    return (dwError);
}


DWORD
RegDeleteDefaultISAKMPData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;


    *pppszIpsecPolicyReferences = NULL;
    *pdwNumReferences = 0;

    dwError = RegRemoveOwnersReferenceInISAKMP(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  ISAKMPIdentifier,
                  pppszIpsecPolicyReferences,
                  pdwNumReferences
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegDeleteISAKMPData(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  ISAKMPIdentifier
                  );
error:

    return (dwError);
}


DWORD
RegRemoveOwnersReferenceInFilter(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    LPWSTR pszIpsecFilterReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecNFAReference = NULL;

    dwError = ConvertGuidToFilterString(
                  FilterIdentifier,
                  pszIpsecRootContainer,
                  &pszIpsecFilterReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwRootPathLen =  wcslen(pszIpsecRootContainer);
    pszRelativeName = pszIpsecFilterReference + dwRootPathLen + 1;

    dwError = RegGetNFAReferencesForFilter(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszRelativeName,
                  &ppszIpsecNFAReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecNFAReference = *(ppszIpsecNFAReferences + i);

        dwError = RegDeleteNFAReferenceInFilterObject(
                      hRegistryKey,
                      pszRelativeName,
                      pszIpsecNFAReference
                      );

    }

    *pppszIpsecNFAReferences = ppszIpsecNFAReferences;
    *pdwNumReferences = dwNumReferences;

cleanup:

    if (pszIpsecFilterReference) {
        FreePolStr(
            pszIpsecFilterReference
            );
    }

    return(dwError);

error:

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            dwNumReferences
            );
    }

    *pppszIpsecNFAReferences = NULL;
    *pdwNumReferences = 0;
    goto cleanup;
}


DWORD
RegRemoveOwnersReferenceInNegPol(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    LPWSTR pszIpsecNegPolReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecNFAReference = NULL;

    dwError = ConvertGuidToNegPolString(
                  NegPolIdentifier,
                  pszIpsecRootContainer,
                  &pszIpsecNegPolReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwRootPathLen =  wcslen(pszIpsecRootContainer);
    pszRelativeName = pszIpsecNegPolReference + dwRootPathLen + 1;

    dwError = RegGetNFAReferencesForNegPol(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszRelativeName,
                  &ppszIpsecNFAReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecNFAReference = *(ppszIpsecNFAReferences + i);

        dwError = RegDeleteNFAReferenceInNegPolObject(
                      hRegistryKey,
                      pszRelativeName,
                      pszIpsecNFAReference
                      );

    }

    *pppszIpsecNFAReferences = ppszIpsecNFAReferences;
    *pdwNumReferences = dwNumReferences;

cleanup:

    if (pszIpsecNegPolReference) {
        FreePolStr(
            pszIpsecNegPolReference
            );
    }

    return(dwError);

error:

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            dwNumReferences
            );
    }

    *pppszIpsecNFAReferences = NULL;
    *pdwNumReferences = 0;
    goto cleanup;
}


DWORD
RegRemoveOwnersReferenceInISAKMP(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    LPWSTR pszIpsecISAKMPReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    LPWSTR * ppszIpsecPolicyReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecPolicyReference = NULL;

    dwError = ConvertGuidToISAKMPString(
                  ISAKMPIdentifier,
                  pszIpsecRootContainer,
                  &pszIpsecISAKMPReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwRootPathLen =  wcslen(pszIpsecRootContainer);
    pszRelativeName = pszIpsecISAKMPReference + dwRootPathLen + 1;

    dwError = RegGetPolicyReferencesForISAKMP(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszRelativeName,
                  &ppszIpsecPolicyReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecPolicyReference = *(ppszIpsecPolicyReferences + i);

        dwError = RegRemovePolicyReferenceFromISAKMPObject(
                      hRegistryKey,
                      pszRelativeName,
                      pszIpsecPolicyReference
                      );

    }

    *pppszIpsecPolicyReferences = ppszIpsecPolicyReferences;
    *pdwNumReferences = dwNumReferences;

cleanup:

    if (pszIpsecISAKMPReference) {
        FreePolStr(
            pszIpsecISAKMPReference
            );
    }

    return(dwError);

error:

    if (ppszIpsecPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecPolicyReferences,
            dwNumReferences
            );
    }

    *pppszIpsecPolicyReferences = NULL;
    *pdwNumReferences = 0;
    goto cleanup;
}


DWORD
RegUpdateFilterOwnersReference(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier,
    LPWSTR * ppszIpsecNFAReferences,
    DWORD dwNumNFAReferences
    )
{
    DWORD dwError = 0;
    LPWSTR pszIpsecFilterReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    DWORD i = 0;
    LPWSTR pszIpsecNFAReference = NULL;


    dwError = ConvertGuidToFilterString(
                  FilterIdentifier,
                  pszIpsecRootContainer,
                  &pszIpsecFilterReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwRootPathLen =  wcslen(pszIpsecRootContainer);

    pszRelativeName = pszIpsecFilterReference + dwRootPathLen + 1;

    for (i = 0; i < dwNumNFAReferences; i++) {
          
        pszIpsecNFAReference = *(ppszIpsecNFAReferences + i);

        dwError = RegAddNFAReferenceToFilterObject(
                      hRegistryKey,
                      pszRelativeName,
                      pszIpsecNFAReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (pszIpsecFilterReference) {
        FreePolStr(
            pszIpsecFilterReference
            );
    }

    return(dwError);
}


DWORD
RegUpdateNegPolOwnersReference(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier,
    LPWSTR * ppszIpsecNFAReferences,
    DWORD dwNumNFAReferences
    )
{
    DWORD dwError = 0;
    LPWSTR pszIpsecNegPolReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    DWORD i = 0;
    LPWSTR pszIpsecNFAReference = NULL;


    dwError = ConvertGuidToNegPolString(
                  NegPolIdentifier,
                  pszIpsecRootContainer,
                  &pszIpsecNegPolReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwRootPathLen =  wcslen(pszIpsecRootContainer);

    pszRelativeName = pszIpsecNegPolReference + dwRootPathLen + 1;

    for (i = 0; i < dwNumNFAReferences; i++) {
          
        pszIpsecNFAReference = *(ppszIpsecNFAReferences + i);

        dwError = RegAddNFAReferenceToNegPolObject(
                      hRegistryKey,
                      pszRelativeName,
                      pszIpsecNFAReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (pszIpsecNegPolReference) {
        FreePolStr(
            pszIpsecNegPolReference
            );
    }

    return(dwError);
}


DWORD
RegUpdateISAKMPOwnersReference(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier,
    LPWSTR * ppszIpsecPolicyReferences,
    DWORD dwNumPolicyReferences
    )
{
    DWORD dwError = 0;
    LPWSTR pszIpsecISAKMPReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    DWORD i = 0;
    LPWSTR pszIpsecPolicyReference = NULL;


    dwError = ConvertGuidToISAKMPString(
                  ISAKMPIdentifier,
                  pszIpsecRootContainer,
                  &pszIpsecISAKMPReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwRootPathLen =  wcslen(pszIpsecRootContainer);

    pszRelativeName = pszIpsecISAKMPReference + dwRootPathLen + 1;

    for (i = 0; i < dwNumPolicyReferences; i++) {
          
        pszIpsecPolicyReference = *(ppszIpsecPolicyReferences + i);

        dwError = RegAddPolicyReferenceToISAKMPObject(
                      hRegistryKey,
                      pszRelativeName,
                      pszIpsecPolicyReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

error:

    if (pszIpsecISAKMPReference) {
        FreePolStr(
            pszIpsecISAKMPReference
            );
    }

    return(dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\rules-d.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       rules-d.c
//
//  Contents:   Rule management for directory.
//
//
//  History:    AbhisheV
//
//----------------------------------------------------------------------------


#include "precomp.h"

extern LPWSTR NFADNAttributes[];
extern LPWSTR PolicyDNAttributes[];

DWORD
DirEnumNFAData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA ** pppIpsecNFAData,
    PDWORD pdwNumNFAObjects
    )
{
    DWORD dwError = 0;
    LPWSTR pszPolicyString = NULL;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject = NULL;
    DWORD dwNumNFAObjects = 0;
    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;
    DWORD i = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;
    DWORD j = 0;


    dwError = GenerateSpecificPolicyQuery(
                  PolicyIdentifier,
                  &pszPolicyString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirEnumNFAObjects(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pszPolicyString,
                  &ppIpsecNFAObject,
                  &dwNumNFAObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumNFAObjects) {
        ppIpsecNFAData = (PIPSEC_NFA_DATA *)AllocPolMem(
                                sizeof(PIPSEC_NFA_DATA)*dwNumNFAObjects
                                );
        if (!ppIpsecNFAData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumNFAObjects; i++) {

        pIpsecNFAObject = *(ppIpsecNFAObject + i);

        dwError = DirUnmarshallNFAData(
                        pIpsecNFAObject,
                        &pIpsecNFAData
                        );
        if (!dwError) {
            *(ppIpsecNFAData + j) = pIpsecNFAData;
            j++;
        }
    }

    if (j == 0) {
        if (ppIpsecNFAData) {
            FreePolMem(ppIpsecNFAData);
            ppIpsecNFAData = NULL;
        }
    }

    *pppIpsecNFAData = ppIpsecNFAData;
    *pdwNumNFAObjects  = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecNFAObject) {
        FreeIpsecNFAObjects(
            ppIpsecNFAObject,
            dwNumNFAObjects
            );
    }

    if (pszPolicyString) {
        FreePolStr(pszPolicyString);
    }

    return(dwError);

error:

    if (ppIpsecNFAData) {
        FreeMulIpsecNFAData(
            ppIpsecNFAData,
            i
            );
    }

    *pppIpsecNFAData  = NULL;
    *pdwNumNFAObjects = 0;

    goto cleanup;
}


DWORD
DirEnumNFAObjects(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecPolicyName,
    PIPSEC_NFA_OBJECT ** pppIpsecNFAObjects,
    PDWORD pdwNumNFAObjects
    )
{
    DWORD dwError = 0;
    LPWSTR * ppszNFADNs = NULL;
    DWORD dwNumNFAObjects = 0;
    LPWSTR pszFilterString = NULL;
    LDAPMessage *res = NULL;
    DWORD dwCount = 0;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects = NULL;
    DWORD i = 0;
    LDAPMessage *e = NULL;
    PIPSEC_NFA_OBJECT pIpsecNFAObject =  NULL;
    DWORD dwNumNFAObjectsReturned = 0;
    LPWSTR pszFilterReference = NULL;
    LPWSTR pszNegPolReference = NULL;


    dwError = DirGetNFADNsForPolicy(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pszIpsecPolicyName,
                  &ppszNFADNs,
                  &dwNumNFAObjects
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = GenerateNFAQuery(
                  ppszNFADNs,
                  dwNumNFAObjects,
                  &pszFilterString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszFilterString,
                  NFADNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppIpsecNFAObjects  = (PIPSEC_NFA_OBJECT *)AllocPolMem(
                                              sizeof(PIPSEC_NFA_OBJECT)*dwCount
                                              );
    if (!ppIpsecNFAObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwCount; i++) {

        if (i == 0) {
            dwError = LdapFirstEntry(
                          hLdapBindHandle,
                          res,
                          &e
                          );
            BAIL_ON_WIN32_ERROR(dwError);
        }
        else {
            dwError = LdapNextEntry(
                          hLdapBindHandle,
                          e,
                          &e
                          );
            BAIL_ON_WIN32_ERROR(dwError);
        }

        dwError =UnMarshallNFAObject(
                     hLdapBindHandle,
                     e,
                     &pIpsecNFAObject,
                     &pszFilterReference,
                     &pszNegPolReference
                     );
        if (dwError == ERROR_SUCCESS) {

            *(ppIpsecNFAObjects + dwNumNFAObjectsReturned) = pIpsecNFAObject;
            dwNumNFAObjectsReturned++;

            if (pszFilterReference) {
                FreePolStr(pszFilterReference);
                pszFilterReference = NULL;
            }

            if (pszNegPolReference) {
                FreePolStr(pszNegPolReference);
                pszNegPolReference = NULL;
            }

        }

    }

    *pppIpsecNFAObjects = ppIpsecNFAObjects;
    *pdwNumNFAObjects = dwNumNFAObjectsReturned;

    dwError = ERROR_SUCCESS;

cleanup:

    if (res) {
        LdapMsgFree(res);
    }

    if (pszFilterString) {
        FreePolStr(pszFilterString);
    }

    if (ppszNFADNs) {
        FreeNFAReferences(
            ppszNFADNs,
            dwNumNFAObjects
            );
    }

    return(dwError);

error:

    if (ppIpsecNFAObjects) {
        FreeIpsecNFAObjects(
            ppIpsecNFAObjects,
            dwNumNFAObjectsReturned
            );
    }

    *pppIpsecNFAObjects = NULL;
    *pdwNumNFAObjects = 0;

    goto cleanup;
}


DWORD
DirGetNFADNsForPolicy(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecPolicyName,
    LPWSTR ** pppszNFADNs,
    PDWORD pdwNumNFAObjects
    )
{
    DWORD dwError = 0;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;
    LDAPMessage * e = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject =  NULL;
    LPWSTR * ppszNFADNs = NULL;
    LPWSTR * ppszIpsecNFANames = NULL;
    DWORD dwNumberOfRules = 0;
    DWORD i = 0;
    LPWSTR pszIpsecNFAName = NULL;
    LPWSTR pszNFADN = NULL;


    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszIpsecPolicyName,
                  PolicyDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallPolicyObject2(
                  hLdapBindHandle,
                  e,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ppszIpsecNFANames = pIpsecPolicyObject->ppszIpsecNFAReferences;
    dwNumberOfRules = pIpsecPolicyObject->NumberofRules;

    if (!dwNumberOfRules) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppszNFADNs = (LPWSTR *)AllocPolMem(
                               sizeof(LPWSTR)*dwNumberOfRules
                               );
    if (!ppszNFADNs) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwNumberOfRules; i++) {

        pszIpsecNFAName = *(ppszIpsecNFANames + i);

        pszNFADN = AllocPolStr(pszIpsecNFAName);

        if (!pszNFADN) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        *(ppszNFADNs + i) = pszNFADN;

    }

    *pppszNFADNs = ppszNFADNs;
    *pdwNumNFAObjects = dwNumberOfRules;

cleanup:

    if (res) {
        LdapMsgFree(res);
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    return(dwError);

error:

    if (ppszNFADNs) {
        FreeNFAReferences(
            ppszNFADNs,
            i
            );
    }

    *pppszNFADNs = NULL;
    *pdwNumNFAObjects = 0;

    goto cleanup;
}


DWORD
DirUnmarshallNFAData(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallNFAObject(
                  pIpsecNFAObject,
                  IPSEC_DIRECTORY_PROVIDER,
                  ppIpsecNFAData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
DirCreateNFAData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    LPWSTR pszIpsecPolicyReference = NULL;


    dwError = DirMarshallNFAObject(
                        pIpsecNFAData,
                        pszIpsecRootContainer,
                        &pIpsecNFAObject
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ConvertGuidToDirPolicyString(
                  PolicyIdentifier,
                  pszIpsecRootContainer,
                  &pszIpsecPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirCreateNFAObject(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    pIpsecNFAObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Write the policy object reference.
    //

    dwError = DirAddNFAReferenceToPolicyObject(
                  hLdapBindHandle,
                  pszIpsecPolicyReference,
                  pIpsecNFAObject->pszDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Write the NFA object reference.
    //

    dwError = DirAddPolicyReferenceToNFAObject(
                  hLdapBindHandle,
                  pIpsecNFAObject->pszDistinguishedName,
                  pszIpsecPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Write the filter object reference for the NFA
    // only if the NFA is not a default rule.
    //

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        dwError = DirAddNFAReferenceToFilterObject(
                      hLdapBindHandle,
                      pIpsecNFAObject->pszIpsecFilterReference,
                      pIpsecNFAObject->pszDistinguishedName
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Write the NFA object reference for the filter
    // only if the NFA is not a default rule.
    //

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        dwError = DirAddFilterReferenceToNFAObject(
                      hLdapBindHandle,
                      pIpsecNFAObject->pszDistinguishedName,
                      pIpsecNFAObject->pszIpsecFilterReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Write the negpol object reference for the NFA.
    //

    dwError = DirAddNFAReferenceToNegPolObject(
                  hLdapBindHandle,
                  pIpsecNFAObject->pszIpsecNegPolReference,
                  pIpsecNFAObject->pszDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Write the NFA object reference for the negpol.
    //

    dwError = DirAddNegPolReferenceToNFAObject(
                  hLdapBindHandle,
                  pIpsecNFAObject->pszDistinguishedName,
                  pIpsecNFAObject->pszIpsecNegPolReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(
            pIpsecNFAObject
            );
    }

    if (pszIpsecPolicyReference) {
        FreePolStr(pszIpsecPolicyReference);
    }

    return(dwError);
}


DWORD
DirMarshallNFAObject(
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;
    LPWSTR pszIpsecFilterReference = NULL;
    LPWSTR pszIpsecNegPolReference = NULL;
    GUID ZeroGuid;


    memset(&ZeroGuid, 0, sizeof(GUID));

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';
    pIpsecNFAObject = (PIPSEC_NFA_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_NFA_OBJECT)
                                                    );
    if (!pIpsecNFAObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecNFAData->NFAIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    //
    // Fill in the distinguishedName
    //

    wcscpy(szDistinguishedName,L"CN=ipsecNFA");
    wcscat(szDistinguishedName, szGuid);
    wcscat(szDistinguishedName, L",");
    SecStrCatW(szDistinguishedName, pszIpsecRootContainer, MAX_PATH);

    pIpsecNFAObject->pszDistinguishedName = AllocPolStr(
                                                szDistinguishedName
                                                );
    if (!pIpsecNFAObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Fill in the ipsecName
    //

    if (pIpsecNFAData->pszIpsecName &&
        *pIpsecNFAData->pszIpsecName) {

        pIpsecNFAObject->pszIpsecName = AllocPolStr(
                                            pIpsecNFAData->pszIpsecName
                                            );
        if (!pIpsecNFAObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNFAData->pszDescription &&
        *pIpsecNFAData->pszDescription) {

        pIpsecNFAObject->pszDescription = AllocPolStr(
                                            pIpsecNFAData->pszDescription
                                            );
        if (!pIpsecNFAObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //
    // Fill in the ipsecID
    //

    pIpsecNFAObject->pszIpsecID = AllocPolStr(
                                      szGuid
                                      );
    if (!pIpsecNFAObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Fill in the ipsecDataType
    //

    pIpsecNFAObject->dwIpsecDataType = 0x100;


    //
    // Marshall the pIpsecDataBuffer and the Length
    //

    dwError = MarshallNFABuffer(
                    pIpsecNFAData,
                    &pBuffer,
                    &dwBufferLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNFAObject->pIpsecData  = pBuffer;

    pIpsecNFAObject->dwIpsecDataLen = dwBufferLen;

    //
    // Marshall the Filter Reference.
    // There's no filter reference for a default rule.
    //

    if (memcmp(
            &pIpsecNFAData->FilterIdentifier,
            &ZeroGuid,
            sizeof(GUID))) {
        dwError = ConvertGuidToDirFilterString(
                      pIpsecNFAData->FilterIdentifier,
                      pszIpsecRootContainer,
                      &pszIpsecFilterReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecNFAObject->pszIpsecFilterReference = pszIpsecFilterReference;
    }
    else {
        pIpsecNFAObject->pszIpsecFilterReference = NULL;
    }

    //
    // Marshall the NegPol Reference
    //

    dwError = ConvertGuidToDirNegPolString(
                    pIpsecNFAData->NegPolIdentifier,
                    pszIpsecRootContainer,
                    &pszIpsecNegPolReference
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    pIpsecNFAObject->pszIpsecNegPolReference = pszIpsecNegPolReference;

    pIpsecNFAObject->dwWhenChanged = 0;

    *ppIpsecNFAObject = pIpsecNFAObject;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }

    return(dwError);

error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(
                pIpsecNFAObject
                );
    }

    *ppIpsecNFAObject = NULL;
    goto cleanup;
}


DWORD
ConvertGuidToDirFilterString(
    GUID FilterIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecFilterReference
    )
{
    DWORD dwError = 0;
    LPWSTR pszStringUuid = NULL;
    WCHAR szGuidString[MAX_PATH];
    WCHAR szFilterReference[MAX_PATH];
    LPWSTR pszIpsecFilterReference = NULL;


    dwError = UuidToString(
                  &FilterIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szGuidString[0] = L'\0';
    wcscpy(szGuidString, L"{");
    wcscat(szGuidString, pszStringUuid);
    wcscat(szGuidString, L"}");

    szFilterReference[0] = L'\0';
    wcscpy(szFilterReference,L"CN=ipsecFilter");
    wcscat(szFilterReference, szGuidString);
    wcscat(szFilterReference, L",");
    SecStrCatW(szFilterReference, pszIpsecRootContainer, MAX_PATH);

    pszIpsecFilterReference = AllocPolStr(
                                    szFilterReference
                                    );
    if (!pszIpsecFilterReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszIpsecFilterReference = pszIpsecFilterReference;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    *ppszIpsecFilterReference = NULL;

    goto cleanup;
}


DWORD
ConvertGuidToDirNegPolString(
    GUID NegPolIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecNegPolReference
    )
{
    DWORD dwError = 0;
    LPWSTR pszStringUuid = NULL;
    WCHAR szGuidString[MAX_PATH];
    WCHAR szNegPolReference[MAX_PATH];
    LPWSTR pszIpsecNegPolReference = NULL;


    dwError = UuidToString(
                  &NegPolIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szGuidString[0] = L'\0';
    wcscpy(szGuidString, L"{");
    wcscat(szGuidString, pszStringUuid);
    wcscat(szGuidString, L"}");

    szNegPolReference[0] = L'\0';
    wcscpy(szNegPolReference,L"CN=ipsecNegotiationPolicy");
    wcscat(szNegPolReference, szGuidString);
    wcscat(szNegPolReference, L",");
    SecStrCatW(szNegPolReference, pszIpsecRootContainer, MAX_PATH);

    pszIpsecNegPolReference = AllocPolStr(
                                    szNegPolReference
                                    );
    if (!pszIpsecNegPolReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszIpsecNegPolReference = pszIpsecNegPolReference;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    *ppszIpsecNegPolReference = NULL;

    goto cleanup;
}


DWORD
DirCreateNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;


    dwError = DirMarshallAddNFAObject(
                        hLdapBindHandle,
                        pszIpsecRootContainer,
                        pIpsecNFAObject,
                        &ppLDAPModW
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapAddS(
                    hLdapBindHandle,
                    pIpsecNFAObject->pszDistinguishedName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    //
    // Free the amods structures.
    //

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirMarshallAddNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    LDAPModW *** pppLDAPModW
    )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 6;
    DWORD dwError = 0;
    WCHAR Buffer[64];


    if (!pIpsecNFAObject->pszIpsecName ||
        !*pIpsecNFAObject->pszIpsecName) {
        dwNumAttributes--;
    }

    if (!pIpsecNFAObject->pszDescription ||
        !*pIpsecNFAObject->pszDescription) {
        dwNumAttributes--;
    }

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // 0. objectClass
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"objectClass",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    L"ipsecNFA",
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 1. ipsecName
    //

    if (pIpsecNFAObject->pszIpsecName &&
        *pIpsecNFAObject->pszIpsecName) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"ipsecName",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecNFAObject->pszIpsecName,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 2. ipsecID
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecID",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecNFAObject->pszIpsecID,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 3. ipsecDataType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecDataType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( pIpsecNFAObject->dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                    Buffer,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 4. ipsecData
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecData",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPBinaryValue(
                    pIpsecNFAObject->pIpsecData,
                    pIpsecNFAObject->dwIpsecDataLen,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;

    i++;

    //
    // 5. description
    //

    if (pIpsecNFAObject->pszDescription &&
        *pIpsecNFAObject->pszDescription) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"description",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecNFAObject->pszDescription,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    *pppLDAPModW = ppLDAPModW;

    return(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    *pppLDAPModW = NULL;

    return(dwError);
}


DWORD
DirSetNFAData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    LPWSTR pszOldIpsecFilterReference = NULL;
    LPWSTR pszOldIpsecNegPolReference = NULL;


    dwError = DirMarshallNFAObject(
                    pIpsecNFAData,
                    pszIpsecRootContainer,
                    &pIpsecNFAObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirGetNFAExistingFilterRef(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pIpsecNFAData,
                  &pszOldIpsecFilterReference
                  );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirGetNFAExistingNegPolRef(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pIpsecNFAData,
                  &pszOldIpsecNegPolReference
                  );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirSetNFAObject(
                    hLdapBindHandle,
                    pszIpsecRootContainer,
                    pIpsecNFAObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pszOldIpsecFilterReference) {
        dwError = DirDeleteNFAReferenceInFilterObject(
                      hLdapBindHandle,
                      pszOldIpsecFilterReference,
                      pIpsecNFAObject->pszDistinguishedName
                      );
        // BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        dwError = DirAddNFAReferenceToFilterObject(
                      hLdapBindHandle,
                      pIpsecNFAObject->pszIpsecFilterReference,
                      pIpsecNFAObject->pszDistinguishedName
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Update the NFA object reference for the filter.
    //

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        dwError = DirUpdateFilterReferenceInNFAObject(
                      hLdapBindHandle,
                      pIpsecNFAObject->pszDistinguishedName,
                      pszOldIpsecFilterReference,
                      pIpsecNFAObject->pszIpsecFilterReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    else {
        dwError = DirRemoveFilterReferenceInNFAObject(
                      hLdapBindHandle,
                      pIpsecNFAObject->pszDistinguishedName
                      );
        // BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pszOldIpsecNegPolReference) {
        dwError = DirDeleteNFAReferenceInNegPolObject(
                      hLdapBindHandle,
                      pszOldIpsecNegPolReference,
                      pIpsecNFAObject->pszDistinguishedName
                      );
        // BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = DirAddNFAReferenceToNegPolObject(
                  hLdapBindHandle,
                  pIpsecNFAObject->pszIpsecNegPolReference,
                  pIpsecNFAObject->pszDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Update the NFA object reference for the negpol.
    //

    dwError = DirUpdateNegPolReferenceInNFAObject(
                  hLdapBindHandle,
                  pIpsecNFAObject->pszDistinguishedName,
                  pszOldIpsecNegPolReference,
                  pIpsecNFAObject->pszIpsecNegPolReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DirBackPropIncChangesForNFAToPolicy(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pIpsecNFAObject->pszDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(pIpsecNFAObject);
    }

    if (pszOldIpsecFilterReference) {
        FreePolStr(pszOldIpsecFilterReference);
    }

    if (pszOldIpsecNegPolReference) {
        FreePolStr(pszOldIpsecNegPolReference);
    }

    return(dwError);
}


DWORD
DirSetNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    )
{
    DWORD dwError = 0;
    LDAPModW ** ppLDAPModW = NULL;

    dwError = DirMarshallSetNFAObject(
                        hLdapBindHandle,
                        pszIpsecRootContainer,
                        pIpsecNFAObject,
                        &ppLDAPModW
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapModifyS(
                    hLdapBindHandle,
                    pIpsecNFAObject->pszDistinguishedName,
                    ppLDAPModW
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    //
    // Free the amods structures.
    //

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }


    return(dwError);
}


DWORD
DirMarshallSetNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    LDAPModW *** pppLDAPModW
    )
{
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    DWORD dwNumAttributes = 5;
    DWORD dwError = 0;
    WCHAR Buffer[64];


    if (!pIpsecNFAObject->pszIpsecName ||
        !*pIpsecNFAObject->pszIpsecName) {
        dwNumAttributes--;
    }

    if (!pIpsecNFAObject->pszDescription ||
        !*pIpsecNFAObject->pszDescription) {
        dwNumAttributes--;
    }

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                    (dwNumAttributes+1) * sizeof(LDAPModW*)
                                    );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                    dwNumAttributes * sizeof(LDAPModW)
                                    );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // 1. ipsecName
    //

    if (pIpsecNFAObject->pszIpsecName &&
        *pIpsecNFAObject->pszIpsecName) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"ipsecName",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecNFAObject->pszIpsecName,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    //
    // 2. ipsecID
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecID",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPStringValue(
                    pIpsecNFAObject->pszIpsecID,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 3. ipsecDataType
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecDataType",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( pIpsecNFAObject->dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                    Buffer,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    i++;

    //
    // 4. ipsecData
    //

    ppLDAPModW[i] = pLDAPModW + i;
    dwError = AllocatePolString(
                    L"ipsecData",
                    &(pLDAPModW +i)->mod_type
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateLDAPBinaryValue(
                    pIpsecNFAObject->pIpsecData,
                    pIpsecNFAObject->dwIpsecDataLen,
                    (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW+i)->mod_op = LDAP_MOD_REPLACE | LDAP_MOD_BVALUES;

    i++;

    //
    // 5. description
    //

    if (pIpsecNFAObject->pszDescription &&
        *pIpsecNFAObject->pszDescription) {

        ppLDAPModW[i] = pLDAPModW + i;
        dwError = AllocatePolString(
                      L"description",
                      &(pLDAPModW +i)->mod_type
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = AllocateLDAPStringValue(
                      pIpsecNFAObject->pszDescription,
                      (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

        i++;

    }

    *pppLDAPModW = ppLDAPModW;

    return(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    *pppLDAPModW = NULL;

    return(dwError);
}


DWORD
DirDeleteNFAData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    LPWSTR pszIpsecPolicyReference = NULL;


    dwError = DirMarshallNFAObject(
                  pIpsecNFAData,
                  pszIpsecRootContainer,
                  &pIpsecNFAObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ConvertGuidToDirPolicyString(
                  PolicyIdentifier,
                  pszIpsecRootContainer,
                  &pszIpsecPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Remove the NFA reference from the policy object.
    //

    dwError = DirRemoveNFAReferenceFromPolicyObject(
                  hLdapBindHandle,
                  pszIpsecPolicyReference,
                  pIpsecNFAObject->pszDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Remove the NFA Reference from the negpol object.
    //

    dwError = DirDeleteNFAReferenceInNegPolObject(
                  hLdapBindHandle,
                  pIpsecNFAObject->pszIpsecNegPolReference,
                  pIpsecNFAObject->pszDistinguishedName
                  );
    // BAIL_ON_WIN32_ERROR(dwError);

    //
    // Remove the NFA Reference from the filter object.
    //

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        dwError = DirDeleteNFAReferenceInFilterObject(
                      hLdapBindHandle,
                      pIpsecNFAObject->pszIpsecFilterReference,
                      pIpsecNFAObject->pszDistinguishedName
                      );
        // BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = LdapDeleteS(
                  hLdapBindHandle,
                  pIpsecNFAObject->pszDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(pIpsecNFAObject);
    }

    if (pszIpsecPolicyReference) {
        FreePolStr(pszIpsecPolicyReference);
    }

    return(dwError);
}


DWORD
DirGetNFAExistingFilterRef(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR * ppszIpsecFilterName
    )
{
    DWORD dwError = 0;
    LPWSTR pszNFAString = NULL;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;
    LDAPMessage * e = NULL;
    PIPSEC_NFA_OBJECT pIpsecNFAObject =  NULL;
    LPWSTR pszIpsecFilterName = NULL;
    LPWSTR pszFilterReference = NULL;
    LPWSTR pszNegPolReference = NULL;


    dwError = GenerateSpecificNFAQuery(
                  pIpsecNFAData->NFAIdentifier,
                  &pszNFAString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszNFAString,
                  NFADNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError =UnMarshallNFAObject(
                 hLdapBindHandle,
                 e,
                 &pIpsecNFAObject,
                 &pszFilterReference,
                 &pszNegPolReference
                 );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pszFilterReference) {
        FreePolStr(pszFilterReference);
    }

    if (pszNegPolReference) {
        FreePolStr(pszNegPolReference);
    }

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        pszIpsecFilterName = AllocPolStr(
                                 pIpsecNFAObject->pszIpsecFilterReference
                                 );
        if (!pszIpsecFilterName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    *ppszIpsecFilterName = pszIpsecFilterName;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszNFAString) {
        FreePolMem(pszNFAString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(pIpsecNFAObject);
    }

    return(dwError);

error:

    *ppszIpsecFilterName = NULL;

    goto cleanup;
}


DWORD
GenerateSpecificNFAQuery(
    GUID NFAIdentifier,
    LPWSTR * ppszNFAString
    )
{
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szGuid[MAX_PATH];
    WCHAR szCommonName[MAX_PATH];
    LPWSTR pszStringUuid = NULL;
    DWORD dwLength = 0;
    LPWSTR pszNFAString = NULL;


    szGuid[0] = L'\0';
    szCommonName[0] = L'\0';

    dwError = UuidToString(
                  &NFAIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    wcscpy(szCommonName, L"cn=ipsecNFA");
    wcscat(szCommonName, szGuid);

    //
    // Compute Length of Buffer to be allocated
    //

    dwLength = wcslen(L"(&(objectclass=ipsecNFA)");
    dwLength += wcslen(L"(");
    dwLength += wcslen(szCommonName);
    dwLength += wcslen(L"))");

    pszNFAString = (LPWSTR) AllocPolMem((dwLength + 1)*sizeof(WCHAR));

    if (!pszNFAString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    wcscpy(pszNFAString, L"(&(objectclass=ipsecNFA)");
    wcscat(pszNFAString, L"(");
    wcscat(pszNFAString, szCommonName);
    wcscat(pszNFAString, L"))");

    *ppszNFAString = pszNFAString;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    if (pszNFAString) {
        FreePolMem(pszNFAString);
    }

    *ppszNFAString = NULL;

    goto cleanup;
}


DWORD
DirGetNFAExistingNegPolRef(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR * ppszIpsecNegPolName
    )
{
    DWORD dwError = 0;
    LPWSTR pszNFAString = NULL;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;
    LDAPMessage * e = NULL;
    PIPSEC_NFA_OBJECT pIpsecNFAObject =  NULL;
    LPWSTR pszIpsecNegPolName = NULL;
    LPWSTR pszFilterReference = NULL;
    LPWSTR pszNegPolReference = NULL;


    dwError = GenerateSpecificNFAQuery(
                  pIpsecNFAData->NFAIdentifier,
                  &pszNFAString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszNFAString,
                  NFADNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError =UnMarshallNFAObject(
                 hLdapBindHandle,
                 e,
                 &pIpsecNFAObject,
                 &pszFilterReference,
                 &pszNegPolReference
                 );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pszFilterReference) {
        FreePolStr(pszFilterReference);
    }

    if (pszNegPolReference) {
        FreePolStr(pszNegPolReference);
    }

    pszIpsecNegPolName = AllocPolStr(
                             pIpsecNFAObject->pszIpsecNegPolReference
                             );
    if (!pszIpsecNegPolName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszIpsecNegPolName = pszIpsecNegPolName;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszNFAString) {
        FreePolMem(pszNFAString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(pIpsecNFAObject);
    }

    return(dwError);

error:

    *ppszIpsecNegPolName = NULL;

    goto cleanup;
}


DWORD
DirGetNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NFAGUID,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject
    )
{
    DWORD dwError = 0;
    LPWSTR pszNFAString = NULL;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;
    LDAPMessage * e = NULL;
    PIPSEC_NFA_OBJECT pIpsecNFAObject =  NULL;
    LPWSTR pszFilterReference = NULL;
    LPWSTR pszNegPolReference = NULL;


    dwError = GenerateSpecificNFAQuery(
                  NFAGUID,
                  &pszNFAString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszNFAString,
                  NFADNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UnMarshallNFAObject(
                  hLdapBindHandle,
                  e,
                  &pIpsecNFAObject,
                  &pszFilterReference,
                  &pszNegPolReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pszFilterReference) {
        FreePolStr(pszFilterReference);
    }

    if (pszNegPolReference) {
        FreePolStr(pszNegPolReference);
    }

    *ppIpsecNFAObject = pIpsecNFAObject;

    dwError = ERROR_SUCCESS;

cleanup:

    if (pszNFAString) {
        FreePolMem(pszNFAString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    return(dwError);

error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(
            pIpsecNFAObject
            );
    }

    *ppIpsecNFAObject = NULL;

    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\reginit.c ===
#include "precomp.h"


const DWORD PS_INTERFACE_TYPE_NONE = 0;
const DWORD PS_INTERFACE_TYPE_DIALUP = -1;
const DWORD PS_INTERFACE_TYPE_LAN = -2;
const DWORD PS_INTERFACE_TYPE_ALL = -3;

DWORD
GenerateDefaultInformation(
    HANDLE hPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_DATA pAllFilter = NULL;
    PIPSEC_FILTER_DATA pAllICMPFilter = NULL;
    PIPSEC_NEGPOL_DATA pPermitNegPol = NULL;
    PIPSEC_NEGPOL_DATA pRequestSecurityNegPol = NULL;
    PIPSEC_NEGPOL_DATA pRequireSecurityNegPol = NULL;
    PIPSEC_ISAKMP_DATA pDefaultISAKMP = NULL;

    // {72385234-70FA-11d1-864C-14A300000000}
    static const GUID GUID_DEFAULT_ISAKMP=
    { 0x72385234, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


    dwError = CreateAllFilter(
                  hPolicyStore,
                  &pAllFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateAllICMPFilter(
                  hPolicyStore,
                  &pAllICMPFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreatePermitNegPol(
                  hPolicyStore,
                  &pPermitNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateRequestSecurityNegPol(
                  hPolicyStore,
                  &pRequestSecurityNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateRequireSecurityNegPol(
                  hPolicyStore,
                  &pRequireSecurityNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateClientPolicy(
                  hPolicyStore
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateRequestSecurityPolicy(
                  hPolicyStore,
                  pAllFilter,
                  pAllICMPFilter,
                  pPermitNegPol,
                  pRequestSecurityNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateRequireSecurityPolicy(
                  hPolicyStore,
                  pAllFilter,
                  pAllICMPFilter,
                  pPermitNegPol,
                  pRequireSecurityNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateISAKMP(
                  hPolicyStore,
                  GUID_DEFAULT_ISAKMP,
                  &pDefaultISAKMP
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pAllFilter) {
        FreeIpsecFilterData(pAllFilter);
    }

    if (pAllICMPFilter) {
        FreeIpsecFilterData(pAllICMPFilter);
    }

    if (pPermitNegPol) {
        FreeIpsecNegPolData(pPermitNegPol);
    }

    if (pRequestSecurityNegPol) {
        FreeIpsecNegPolData(pRequestSecurityNegPol);
    }

    if (pRequireSecurityNegPol) {
        FreeIpsecNegPolData(pRequireSecurityNegPol);
    }

    if (pDefaultISAKMP) {
        FreeIpsecISAKMPData(pDefaultISAKMP);
    }

    return(dwError);
}


DWORD
CreateAllFilter(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA * ppAllFilter
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_DATA pAllFilter = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppFilterSpecs = NULL;
    PIPSEC_FILTER_SPEC pFilterSpec = NULL;

    // {7238523a-70FA-11d1-864C-14A300000000}
    static const GUID GUID_ALL_FILTER=
    { 0x7238523a, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


    pAllFilter = (PIPSEC_FILTER_DATA) AllocPolMem(
                                      sizeof(IPSEC_FILTER_DATA)
                                      );
    if (!pAllFilter) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        &(pAllFilter->FilterIdentifier),
        &(GUID_ALL_FILTER),
        sizeof(GUID)
        );

    pAllFilter->dwWhenChanged = 0;

    dwError = MapAndAllocPolStr(&(pAllFilter->pszIpsecName),
                               POLSTORE_ALL_FILTER_NAME
                               );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MapAndAllocPolStr(&(pAllFilter->pszDescription),
                                POLSTORE_ALL_FILTER_DESCRIPTION
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwNumFilterSpecs = 1;
    ppFilterSpecs = (PIPSEC_FILTER_SPEC *) AllocPolMem(
                    sizeof(PIPSEC_FILTER_SPEC)*dwNumFilterSpecs
                    );
    if (!ppFilterSpecs) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    pAllFilter->dwNumFilterSpecs = dwNumFilterSpecs;
    pAllFilter->ppFilterSpecs = ppFilterSpecs;

    pFilterSpec = (PIPSEC_FILTER_SPEC) AllocPolMem(
                  sizeof(IPSEC_FILTER_SPEC)
                  );
    if (!pFilterSpec) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    *(ppFilterSpecs + 0) = pFilterSpec;

    pFilterSpec->pszSrcDNSName = NULL;
    pFilterSpec->pszDestDNSName = NULL;
    pFilterSpec->pszDescription = NULL;

    dwError = UuidCreate(
                  &pFilterSpec->FilterSpecGUID
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pFilterSpec->dwMirrorFlag = 1;

    pFilterSpec->Filter.SrcAddr = 0;
    pFilterSpec->Filter.SrcMask = -1;
    pFilterSpec->Filter.DestAddr = 0;
    pFilterSpec->Filter.DestMask = 0;
    pFilterSpec->Filter.TunnelAddr = 0;
    pFilterSpec->Filter.Protocol = 0;
    pFilterSpec->Filter.SrcPort = 0;
    pFilterSpec->Filter.DestPort = 0;
    pFilterSpec->Filter.TunnelFilter = 0;
    pFilterSpec->Filter.Flags = 0;

    dwError = IPSecCreateFilterData(
                  hPolicyStore,
                  pAllFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppAllFilter = pAllFilter;

    return (dwError);

error:

    if (pAllFilter) {
        FreeIpsecFilterData(pAllFilter);
    }

    *ppAllFilter = NULL;
    return (dwError);
}


DWORD
CreateAllICMPFilter(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA * ppAllICMPFilter
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_DATA pAllICMPFilter = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppFilterSpecs = NULL;
    PIPSEC_FILTER_SPEC pFilterSpec = NULL;

    // {72385235-70FA-11d1-864C-14A300000000}
    static const GUID GUID_ALL_ICMP_FILTER =
    { 0x72385235, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


    pAllICMPFilter = (PIPSEC_FILTER_DATA) AllocPolMem(
                                      sizeof(IPSEC_FILTER_DATA)
                                      );
    if (!pAllICMPFilter) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        &(pAllICMPFilter->FilterIdentifier),
        &(GUID_ALL_ICMP_FILTER),
        sizeof(GUID)
        );

    pAllICMPFilter->dwWhenChanged = 0;

    dwError = MapAndAllocPolStr(&(pAllICMPFilter->pszIpsecName),
                                POLSTORE_ALL_ICMP_FILTER_NAME
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MapAndAllocPolStr(&(pAllICMPFilter->pszDescription),
                                POLSTORE_ALL_ICMP_FILTER_DESCRIPTION
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwNumFilterSpecs = 1;
    ppFilterSpecs = (PIPSEC_FILTER_SPEC *) AllocPolMem(
                    sizeof(PIPSEC_FILTER_SPEC)*dwNumFilterSpecs
                    );
    if (!ppFilterSpecs) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    pAllICMPFilter->dwNumFilterSpecs = dwNumFilterSpecs;
    pAllICMPFilter->ppFilterSpecs = ppFilterSpecs;

    pFilterSpec = (PIPSEC_FILTER_SPEC) AllocPolMem(
                  sizeof(IPSEC_FILTER_SPEC)
                  );
    if (!pFilterSpec) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    *(ppFilterSpecs + 0) = pFilterSpec;

    pFilterSpec->pszSrcDNSName = NULL;
    pFilterSpec->pszDestDNSName = NULL;
    dwError = MapAndAllocPolStr(&(pFilterSpec->pszDescription),
                                POLSTORE_ICMPFILTER_SPEC_DESCRIPTION
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UuidCreate(
                  &pFilterSpec->FilterSpecGUID
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pFilterSpec->dwMirrorFlag = 1;

    pFilterSpec->Filter.SrcAddr = 0;
    pFilterSpec->Filter.SrcMask = -1;
    pFilterSpec->Filter.DestAddr = 0;
    pFilterSpec->Filter.DestMask = 0;
    pFilterSpec->Filter.TunnelAddr = 0;
    pFilterSpec->Filter.Protocol = 1;
    pFilterSpec->Filter.SrcPort = 0;
    pFilterSpec->Filter.DestPort = 0;
    pFilterSpec->Filter.TunnelFilter = 0;
    pFilterSpec->Filter.Flags = 0;

    dwError = IPSecCreateFilterData(
                  hPolicyStore,
                  pAllICMPFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppAllICMPFilter = pAllICMPFilter;

    return (dwError);

error:

    if (pAllICMPFilter) {
        FreeIpsecFilterData(pAllICMPFilter);
    }

    *ppAllICMPFilter = NULL;
    return (dwError);
}


DWORD
CreatePermitNegPol(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA * ppPermitNegPol
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pPermitNegPol = NULL;

    static const GUID GUID_PERMIT_NEGPOL =
    { 0x7238523b, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    pPermitNegPol = (PIPSEC_NEGPOL_DATA) AllocPolMem(
                                      sizeof(IPSEC_NEGPOL_DATA)
                                      );
    if (!pPermitNegPol) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        &(pPermitNegPol->NegPolIdentifier),
        &(GUID_PERMIT_NEGPOL),
        sizeof(GUID)
        );

    memcpy(
        &(pPermitNegPol->NegPolAction),
        &(GUID_NEGOTIATION_ACTION_NO_IPSEC),
        sizeof(GUID)
        );

    memcpy(
        &(pPermitNegPol->NegPolType),
        &(GUID_NEGOTIATION_TYPE_STANDARD),
        sizeof(GUID)
        );

    pPermitNegPol->dwSecurityMethodCount = 0;
    pPermitNegPol->pIpsecSecurityMethods = NULL;

    pPermitNegPol->dwWhenChanged = 0;

    dwError = MapAndAllocPolStr(&(pPermitNegPol->pszIpsecName),
                                POLSTORE_PERMIT_NEG_POL_NAME
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MapAndAllocPolStr(&(pPermitNegPol->pszDescription),
                                POLSTORE_PERMIT_NEG_POL_DESCRIPTION
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IPSecCreateNegPolData(
                  hPolicyStore,
                  pPermitNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppPermitNegPol = pPermitNegPol;

    return (dwError);

error:

    if (pPermitNegPol) {
        FreeIpsecNegPolData(pPermitNegPol);
    }

    *ppPermitNegPol = NULL;
    return (dwError);
}


DWORD
CreateRequestSecurityNegPol(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA * ppRequestSecurityNegPol
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pRequestSecurityNegPol = NULL;
    DWORD dwSecurityMethodCount = 0;
    PIPSEC_SECURITY_METHOD pIpsecSecurityMethods = NULL;
    PIPSEC_SECURITY_METHOD pMethod = NULL;

    // {72385233-70FA-11d1-864C-14A300000000}
    static const GUID GUID_SECURE_INITIATOR_NEGPOL =
    { 0x72385233, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


    pRequestSecurityNegPol = (PIPSEC_NEGPOL_DATA) AllocPolMem(
                                      sizeof(IPSEC_NEGPOL_DATA)
                                      );
    if (!pRequestSecurityNegPol) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        &(pRequestSecurityNegPol->NegPolIdentifier),
        &(GUID_SECURE_INITIATOR_NEGPOL),
        sizeof(GUID)
        );

    memcpy(
        &(pRequestSecurityNegPol->NegPolAction),
        &(GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU),
        sizeof(GUID)
        );

    memcpy(
        &(pRequestSecurityNegPol->NegPolType),
        &(GUID_NEGOTIATION_TYPE_STANDARD),
        sizeof(GUID)
        );

    dwSecurityMethodCount = 5;
    pIpsecSecurityMethods = (PIPSEC_SECURITY_METHOD) AllocPolMem(
                            sizeof(IPSEC_SECURITY_METHOD)*dwSecurityMethodCount
                            );
    if (!pIpsecSecurityMethods) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMethod = pIpsecSecurityMethods;

    pMethod->Lifetime.KeyExpirationTime = 900;
    pMethod->Lifetime.KeyExpirationBytes = 100000;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Encrypt;
    pMethod->Algos[0].algoIdentifier = IPSEC_ESP_3_DES;
    pMethod->Algos[0].secondaryAlgoIdentifier = IPSEC_AH_SHA;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 900;
    pMethod->Lifetime.KeyExpirationBytes = 100000;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Encrypt;
    pMethod->Algos[0].algoIdentifier = IPSEC_ESP_DES;
    pMethod->Algos[0].secondaryAlgoIdentifier = IPSEC_AH_SHA;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 300;
    pMethod->Lifetime.KeyExpirationBytes = 100000;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Auth;
    pMethod->Algos[0].algoIdentifier = IPSEC_AH_SHA;
    pMethod->Algos[0].secondaryAlgoIdentifier = 0;;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 300;
    pMethod->Lifetime.KeyExpirationBytes = 100000;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Auth;
    pMethod->Algos[0].algoIdentifier = IPSEC_AH_MD5;
    pMethod->Algos[0].secondaryAlgoIdentifier = 0;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 0;
    pMethod->Lifetime.KeyExpirationBytes = 0;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 0;

    pRequestSecurityNegPol->dwSecurityMethodCount = dwSecurityMethodCount;
    pRequestSecurityNegPol->pIpsecSecurityMethods = pIpsecSecurityMethods;

    pRequestSecurityNegPol->dwWhenChanged = 0;

    dwError = MapAndAllocPolStr(&(pRequestSecurityNegPol->pszIpsecName),
                                POLSTORE_REQUEST_SECURITY_NEG_POL_NAME
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MapAndAllocPolStr(&(pRequestSecurityNegPol->pszDescription),
                                POLSTORE_REQUEST_SECURITY_NEG_POL_DESCRIPTION
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IPSecCreateNegPolData(
                  hPolicyStore,
                  pRequestSecurityNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppRequestSecurityNegPol = pRequestSecurityNegPol;

    return (dwError);

error:

    if (pRequestSecurityNegPol) {
        FreeIpsecNegPolData(pRequestSecurityNegPol);
    }

    *ppRequestSecurityNegPol = NULL;
    return (dwError);
}


DWORD
CreateRequireSecurityNegPol(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA * ppRequireSecurityNegPol
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pRequireSecurityNegPol = NULL;
    DWORD dwSecurityMethodCount = 0;
    PIPSEC_SECURITY_METHOD pIpsecSecurityMethods = NULL;
    PIPSEC_SECURITY_METHOD pMethod = NULL;

    // {7238523f-70FA-11d1-864C-14A300000000}
    static const GUID GUID_LOCKDOWN_NEGPOL =
    { 0x7238523f, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


    pRequireSecurityNegPol = (PIPSEC_NEGPOL_DATA) AllocPolMem(
                                      sizeof(IPSEC_NEGPOL_DATA)
                                      );
    if (!pRequireSecurityNegPol) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        &(pRequireSecurityNegPol->NegPolIdentifier),
        &(GUID_LOCKDOWN_NEGPOL),
        sizeof(GUID)
        );

    memcpy(
        &(pRequireSecurityNegPol->NegPolAction),
        &(GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU),
        sizeof(GUID)
        );

    memcpy(
        &(pRequireSecurityNegPol->NegPolType),
        &(GUID_NEGOTIATION_TYPE_STANDARD),
        sizeof(GUID)
        );

    dwSecurityMethodCount = 4;
    pIpsecSecurityMethods = (PIPSEC_SECURITY_METHOD) AllocPolMem(
                            sizeof(IPSEC_SECURITY_METHOD)*dwSecurityMethodCount
                            );
    if (!pIpsecSecurityMethods) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMethod = pIpsecSecurityMethods;

    pMethod->Lifetime.KeyExpirationTime = 900;
    pMethod->Lifetime.KeyExpirationBytes = 100000;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Encrypt;
    pMethod->Algos[0].algoIdentifier = IPSEC_ESP_3_DES;
    pMethod->Algos[0].secondaryAlgoIdentifier = IPSEC_AH_SHA;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 900;
    pMethod->Lifetime.KeyExpirationBytes = 100000;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Encrypt;
    pMethod->Algos[0].algoIdentifier = IPSEC_ESP_3_DES;
    pMethod->Algos[0].secondaryAlgoIdentifier = IPSEC_AH_MD5;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 900;
    pMethod->Lifetime.KeyExpirationBytes = 100000;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Encrypt;
    pMethod->Algos[0].algoIdentifier = IPSEC_ESP_DES;
    pMethod->Algos[0].secondaryAlgoIdentifier = IPSEC_AH_SHA;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 900;
    pMethod->Lifetime.KeyExpirationBytes = 100000;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Encrypt;
    pMethod->Algos[0].algoIdentifier = IPSEC_ESP_DES;
    pMethod->Algos[0].secondaryAlgoIdentifier = IPSEC_AH_MD5;

    pRequireSecurityNegPol->dwSecurityMethodCount = dwSecurityMethodCount;
    pRequireSecurityNegPol->pIpsecSecurityMethods = pIpsecSecurityMethods;

    pRequireSecurityNegPol->dwWhenChanged = 0;

    dwError = MapAndAllocPolStr(&(pRequireSecurityNegPol->pszIpsecName),
                                POLSTORE_REQUIRE_SECURITY_NEG_POL_NAME
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MapAndAllocPolStr(&(pRequireSecurityNegPol->pszDescription),
                                POLSTORE_REQUIRE_SECURITY_NEG_POL_DESCRIPTION
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IPSecCreateNegPolData(
                  hPolicyStore,
                  pRequireSecurityNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppRequireSecurityNegPol = pRequireSecurityNegPol;

    return (dwError);

error:

    if (pRequireSecurityNegPol) {
        FreeIpsecNegPolData(pRequireSecurityNegPol);
    }

    *ppRequireSecurityNegPol = NULL;
    return (dwError);
}


DWORD
CreateClientPolicy(
    HANDLE hPolicyStore
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_DATA pClientISAKMP = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    PIPSEC_NEGPOL_DATA pDefaultNegPol = NULL;
    GUID NFAIdentifier;
    GUID FilterIdentifier;
    LPWSTR pszNFAName = NULL;
    LPWSTR pszNFADescription = NULL;

    // {72385237-70FA-11d1-864C-14A300000000}
    static const GUID GUID_RESPONDER_ISAKMP =
    { 0x72385237, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    // {72385236-70FA-11d1-864C-14A300000000}
    static const GUID GUID_RESPONDER_POLICY =
    { 0x72385236, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };


    dwError = CreateISAKMP(
                  hPolicyStore,
                  GUID_RESPONDER_ISAKMP,
                  &pClientISAKMP
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyData = (PIPSEC_POLICY_DATA) AllocPolMem(
                       sizeof(IPSEC_POLICY_DATA)
                       );
    if (!pIpsecPolicyData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        &(pIpsecPolicyData->PolicyIdentifier),
        &GUID_RESPONDER_POLICY,
        sizeof(GUID)
        );

    pIpsecPolicyData->dwPollingInterval = 10800;

    pIpsecPolicyData->pIpsecISAKMPData = NULL;
    pIpsecPolicyData->ppIpsecNFAData = NULL;
    pIpsecPolicyData->dwNumNFACount = 0;

    pIpsecPolicyData->dwWhenChanged = 0;

    dwError = MapAndAllocPolStr(&(pIpsecPolicyData->pszIpsecName),
                                POLSTORE_CLIENT_POLICY_NAME
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MapAndAllocPolStr(&(pIpsecPolicyData->pszDescription),
                                POLSTORE_CLIENT_POLICY_DESCRIPTION
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pIpsecPolicyData->ISAKMPIdentifier),
        &(pClientISAKMP->ISAKMPIdentifier),
        sizeof(GUID)
        );

    dwError = IPSecCreatePolicyData(
                  hPolicyStore,
                  pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateDefaultNegPol(
                  hPolicyStore,
                  &pDefaultNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UuidCreate(
                  &NFAIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memset(&FilterIdentifier, 0, sizeof(GUID));

    dwError = CreateNFA(
                  hPolicyStore,
                  NFAIdentifier,
                  GUID_RESPONDER_POLICY,
                  FilterIdentifier,
                  pDefaultNegPol->NegPolIdentifier,
                  pszNFAName,
                  pszNFADescription
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    if (pClientISAKMP) {
        FreeIpsecISAKMPData(pClientISAKMP);
    }

    if (pDefaultNegPol) {
        FreeIpsecNegPolData(pDefaultNegPol);
    }

    return (dwError);
}


DWORD
CreateRequestSecurityPolicy(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA pAllFilter,
    PIPSEC_FILTER_DATA pAllICMPFilter,
    PIPSEC_NEGPOL_DATA pPermitNegPol,
    PIPSEC_NEGPOL_DATA pRequestSecurityNegPol
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_DATA pRequestSecurityISAKMP = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    PIPSEC_NEGPOL_DATA pDefaultNegPol = NULL;
    GUID NFAIdentifier;
    GUID FilterIdentifier;
    LPWSTR pszNFAName = NULL;
    LPWSTR pszNFADescription = NULL;

    // {72385231-70FA-11d1-864C-14A300000000}
    static const GUID GUID_SECURE_INITIATOR_ISAKMP =
    { 0x72385231, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    // {72385230-70FA-11d1-864C-14A300000000}
    static const GUID GUID_SECURE_INITIATOR_POLICY =
    { 0x72385230, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    dwError = CreateISAKMP(
                  hPolicyStore,
                  GUID_SECURE_INITIATOR_ISAKMP,
                  &pRequestSecurityISAKMP
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyData = (PIPSEC_POLICY_DATA) AllocPolMem(
                       sizeof(IPSEC_POLICY_DATA)
                       );
    if (!pIpsecPolicyData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        &(pIpsecPolicyData->PolicyIdentifier),
        &GUID_SECURE_INITIATOR_POLICY,
        sizeof(GUID)
        );

    pIpsecPolicyData->dwPollingInterval = 10800;

    pIpsecPolicyData->pIpsecISAKMPData = NULL;
    pIpsecPolicyData->ppIpsecNFAData = NULL;
    pIpsecPolicyData->dwNumNFACount = 0;

    pIpsecPolicyData->dwWhenChanged = 0;

    dwError = MapAndAllocPolStr(&(pIpsecPolicyData->pszIpsecName),
                                POLSTORE_SECURE_INITIATOR_POLICY_NAME
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MapAndAllocPolStr(&(pIpsecPolicyData->pszDescription),
                                POLSTORE_SECURE_INITIATOR_POLICY_DESCRIPTION
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pIpsecPolicyData->ISAKMPIdentifier),
        &(pRequestSecurityISAKMP->ISAKMPIdentifier),
        sizeof(GUID)
        );

    dwError = IPSecCreatePolicyData(
                  hPolicyStore,
                  pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateDefaultNegPol(
                  hPolicyStore,
                  &pDefaultNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UuidCreate(
                  &NFAIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memset(&FilterIdentifier, 0, sizeof(GUID));

    dwError = CreateNFA(
                  hPolicyStore,
                  NFAIdentifier,
                  GUID_SECURE_INITIATOR_POLICY,
                  FilterIdentifier,
                  pDefaultNegPol->NegPolIdentifier,
                  pszNFAName,
                  pszNFADescription
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UuidCreate(
                  &NFAIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Create the ICMP Rule.
    //

    dwError = MapIdAndCreateNFA(
                  hPolicyStore,
                  NFAIdentifier,
                  GUID_SECURE_INITIATOR_POLICY,
                  pAllICMPFilter->FilterIdentifier,
                  pPermitNegPol->NegPolIdentifier,
                  POLSTORE_ICMP_NFA_NAME,
                  POLSTORE_ICMP_NFA_DESCRIPTION
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UuidCreate(
                  &NFAIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Create the Secure Initiator Rule.
    //

    dwError = MapIdAndCreateNFA(
                  hPolicyStore,
                  NFAIdentifier,
                  GUID_SECURE_INITIATOR_POLICY,
                  pAllFilter->FilterIdentifier,
                  pRequestSecurityNegPol->NegPolIdentifier,
                  POLSTORE_SECURE_INITIATOR_NFA_NAME,
                  POLSTORE_SECURE_INITIATOR_NFA_DESCRIPTION
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    if (pRequestSecurityISAKMP) {
        FreeIpsecISAKMPData(pRequestSecurityISAKMP);
    }

    if (pDefaultNegPol) {
        FreeIpsecNegPolData(pDefaultNegPol);
    }

    return (dwError);
}


DWORD
CreateRequireSecurityPolicy(
    HANDLE hPolicyStore,
    PIPSEC_FILTER_DATA pAllFilter,
    PIPSEC_FILTER_DATA pAllICMPFilter,
    PIPSEC_NEGPOL_DATA pPermitNegPol,
    PIPSEC_NEGPOL_DATA pRequireSecurityNegPol
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_DATA pRequireSecurityISAKMP = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    PIPSEC_NEGPOL_DATA pDefaultNegPol = NULL;
    GUID NFAIdentifier;
    GUID FilterIdentifier;
    LPWSTR pszNFAName = NULL;
    LPWSTR pszNFADescription = NULL;

    // {7238523d-70FA-11d1-864C-14A300000000}
    static const GUID GUID_LOCKDOWN_ISAKMP =
    { 0x7238523d, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    // {7238523c-70FA-11d1-864C-14A300000000}
    static const GUID GUID_LOCKDOWN_POLICY =
    { 0x7238523c, 0x70fa, 0x11d1, { 0x86, 0x4c, 0x14, 0xa3, 0x0, 0x0, 0x0, 0x0 } };

    dwError = CreateISAKMP(
                  hPolicyStore,
                  GUID_LOCKDOWN_ISAKMP,
                  &pRequireSecurityISAKMP
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecPolicyData = (PIPSEC_POLICY_DATA) AllocPolMem(
                       sizeof(IPSEC_POLICY_DATA)
                       );
    if (!pIpsecPolicyData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        &(pIpsecPolicyData->PolicyIdentifier),
        &GUID_LOCKDOWN_POLICY,
        sizeof(GUID)
        );

    pIpsecPolicyData->dwPollingInterval = 10800;

    pIpsecPolicyData->pIpsecISAKMPData = NULL;
    pIpsecPolicyData->ppIpsecNFAData = NULL;
    pIpsecPolicyData->dwNumNFACount = 0;

    pIpsecPolicyData->dwWhenChanged = 0;

    dwError = MapAndAllocPolStr(&(pIpsecPolicyData->pszIpsecName),
                                POLSTORE_LOCKDOWN_POLICY_NAME
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MapAndAllocPolStr(&(pIpsecPolicyData->pszDescription),
                                POLSTORE_LOCKDOWN_POLICY_DESCRIPTION
                                );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pIpsecPolicyData->ISAKMPIdentifier),
        &(pRequireSecurityISAKMP->ISAKMPIdentifier),
        sizeof(GUID)
        );

    dwError = IPSecCreatePolicyData(
                  hPolicyStore,
                  pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateDefaultNegPol(
                  hPolicyStore,
                  &pDefaultNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UuidCreate(
                  &NFAIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memset(&FilterIdentifier, 0, sizeof(GUID));

    dwError = CreateNFA(
                  hPolicyStore,
                  NFAIdentifier,
                  GUID_LOCKDOWN_POLICY,
                  FilterIdentifier,
                  pDefaultNegPol->NegPolIdentifier,
                  pszNFAName,
                  pszNFADescription
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UuidCreate(
                  &NFAIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Create the ICMP Rule.
    //

    dwError = MapIdAndCreateNFA(
                  hPolicyStore,
                  NFAIdentifier,
                  GUID_LOCKDOWN_POLICY,
                  pAllICMPFilter->FilterIdentifier,
                  pPermitNegPol->NegPolIdentifier,
                  POLSTORE_ICMP_NFA_NAME,
                  POLSTORE_ICMP_NFA_DESCRIPTION
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UuidCreate(
                  &NFAIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Create the Secure Initiator Rule.
    //

    dwError = MapIdAndCreateNFA(
                  hPolicyStore,
                  NFAIdentifier,
                  GUID_LOCKDOWN_POLICY,
                  pAllFilter->FilterIdentifier,
                  pRequireSecurityNegPol->NegPolIdentifier,
                  POLSTORE_LOCKDOWN_NFA_NAME,
                  POLSTORE_LOCKDOWN_NFA_DESCRIPTION
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    if (pRequireSecurityISAKMP) {
        FreeIpsecISAKMPData(pRequireSecurityISAKMP);
    }

    if (pDefaultNegPol) {
        FreeIpsecNegPolData(pDefaultNegPol);
    }

    return (dwError);
}


DWORD
CreateISAKMP(
    HANDLE hPolicyStore,
    GUID ISAKMPIdentifier,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;
    DWORD dwNumISAKMPSecurityMethods = 0;
    PCRYPTO_BUNDLE pSecurityMethods = NULL;
    PCRYPTO_BUNDLE pBundle = NULL;


    pIpsecISAKMPData = (PIPSEC_ISAKMP_DATA) AllocPolMem(
                       sizeof(IPSEC_ISAKMP_DATA)
                       );
    if (!pIpsecISAKMPData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memcpy(
        &(pIpsecISAKMPData->ISAKMPIdentifier),
        &(ISAKMPIdentifier),
        sizeof(GUID)
        );

    memset(
        &(pIpsecISAKMPData->ISAKMPPolicy),
        0,
        sizeof(ISAKMP_POLICY)
        );

    dwNumISAKMPSecurityMethods = 4;

    pSecurityMethods = (PCRYPTO_BUNDLE) AllocPolMem(
                       sizeof(CRYPTO_BUNDLE)*dwNumISAKMPSecurityMethods
                       );
    if (!pSecurityMethods) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pBundle = pSecurityMethods;

    pBundle->Lifetime.Seconds = 480*60;
    pBundle->EncryptionAlgorithm.AlgorithmIdentifier = IPSEC_ESP_3_DES;
    pBundle->HashAlgorithm.AlgorithmIdentifier = IPSEC_AH_SHA;
    pBundle->OakleyGroup = 2;
    pBundle++;

    pBundle->Lifetime.Seconds = 480*60;
    pBundle->EncryptionAlgorithm.AlgorithmIdentifier = IPSEC_ESP_3_DES;
    pBundle->HashAlgorithm.AlgorithmIdentifier = IPSEC_AH_MD5;
    pBundle->OakleyGroup = 2;
    pBundle++;

    pBundle->Lifetime.Seconds = 480*60;
    pBundle->EncryptionAlgorithm.AlgorithmIdentifier = IPSEC_ESP_DES;
    pBundle->HashAlgorithm.AlgorithmIdentifier = IPSEC_AH_SHA;
    pBundle->OakleyGroup = 1;
    pBundle++;

    pBundle->Lifetime.Seconds = 480*60;
    pBundle->EncryptionAlgorithm.AlgorithmIdentifier = IPSEC_ESP_DES;
    pBundle->HashAlgorithm.AlgorithmIdentifier = IPSEC_AH_MD5;
    pBundle->OakleyGroup = 1;

    pIpsecISAKMPData->dwNumISAKMPSecurityMethods = dwNumISAKMPSecurityMethods;
    pIpsecISAKMPData->pSecurityMethods = pSecurityMethods;

    pIpsecISAKMPData->dwWhenChanged = 0;

    dwError = IPSecCreateISAKMPData(
                  hPolicyStore,
                  pIpsecISAKMPData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecISAKMPData = pIpsecISAKMPData;
    return (dwError);

error:

    if (pIpsecISAKMPData) {
        FreeIpsecISAKMPData(pIpsecISAKMPData);
    }

    *ppIpsecISAKMPData = NULL;
    return (dwError);
}


DWORD
CreateDefaultNegPol(
    HANDLE hPolicyStore,
    PIPSEC_NEGPOL_DATA * ppDefaultNegPol
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pDefaultNegPol = NULL;
    DWORD dwSecurityMethodCount = 0;
    PIPSEC_SECURITY_METHOD pIpsecSecurityMethods = NULL;
    PIPSEC_SECURITY_METHOD pMethod = NULL;


    pDefaultNegPol = (PIPSEC_NEGPOL_DATA) AllocPolMem(
                                      sizeof(IPSEC_NEGPOL_DATA)
                                      );
    if (!pDefaultNegPol) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidCreate(
                  &(pDefaultNegPol->NegPolIdentifier)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pDefaultNegPol->NegPolAction),
        &(GUID_NEGOTIATION_ACTION_NORMAL_IPSEC),
        sizeof(GUID)
        );

    memcpy(
        &(pDefaultNegPol->NegPolType),
        &(GUID_NEGOTIATION_TYPE_DEFAULT),
        sizeof(GUID)
        );

    dwSecurityMethodCount = 6;
    pIpsecSecurityMethods = (PIPSEC_SECURITY_METHOD) AllocPolMem(
                            sizeof(IPSEC_SECURITY_METHOD)*dwSecurityMethodCount
                            );
    if (!pIpsecSecurityMethods) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMethod = pIpsecSecurityMethods;

    pMethod->Lifetime.KeyExpirationTime = 0;
    pMethod->Lifetime.KeyExpirationBytes = 0;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Encrypt;
    pMethod->Algos[0].algoIdentifier = IPSEC_ESP_3_DES;
    pMethod->Algos[0].secondaryAlgoIdentifier = IPSEC_AH_SHA;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 0;
    pMethod->Lifetime.KeyExpirationBytes = 0;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Encrypt;
    pMethod->Algos[0].algoIdentifier = IPSEC_ESP_3_DES;
    pMethod->Algos[0].secondaryAlgoIdentifier = IPSEC_AH_MD5;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 0;
    pMethod->Lifetime.KeyExpirationBytes = 0;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Encrypt;
    pMethod->Algos[0].algoIdentifier = IPSEC_ESP_DES;
    pMethod->Algos[0].secondaryAlgoIdentifier = IPSEC_AH_SHA;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 0;
    pMethod->Lifetime.KeyExpirationBytes = 0;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Encrypt;
    pMethod->Algos[0].algoIdentifier = IPSEC_ESP_DES;
    pMethod->Algos[0].secondaryAlgoIdentifier = IPSEC_AH_MD5;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 0;
    pMethod->Lifetime.KeyExpirationBytes = 0;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Auth;
    pMethod->Algos[0].algoIdentifier = IPSEC_AH_SHA;
    pMethod->Algos[0].secondaryAlgoIdentifier = 0;
    pMethod ++;

    pMethod->Lifetime.KeyExpirationTime = 0;
    pMethod->Lifetime.KeyExpirationBytes = 0;
    pMethod->Flags = 0;
    pMethod->PfsQMRequired = FALSE;
    pMethod->Count = 1;
    pMethod->Algos[0].operation = Auth;
    pMethod->Algos[0].algoIdentifier = IPSEC_AH_MD5;
    pMethod->Algos[0].secondaryAlgoIdentifier = 0;

    pDefaultNegPol->dwSecurityMethodCount = dwSecurityMethodCount;
    pDefaultNegPol->pIpsecSecurityMethods = pIpsecSecurityMethods;

    pDefaultNegPol->dwWhenChanged = 0;

    pDefaultNegPol->pszIpsecName = NULL;

    pDefaultNegPol->pszDescription = NULL;

    dwError = IPSecCreateNegPolData(
                  hPolicyStore,
                  pDefaultNegPol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppDefaultNegPol = pDefaultNegPol;

    return (dwError);

error:

    if (pDefaultNegPol) {
        FreeIpsecNegPolData(pDefaultNegPol);
    }

    *ppDefaultNegPol = NULL;
    return (dwError);
}


DWORD
CreateNFA(
    HANDLE hPolicyStore,
    GUID NFAIdentifier,
    GUID PolicyIdentifier,
    GUID FilterIdentifier,
    GUID NegPolIdentifier,
    LPWSTR pszNFAName,
    LPWSTR pszNFADescription
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;
    DWORD dwAuthMethodCount = 0;
    PIPSEC_AUTH_METHOD * ppAuthMethods = NULL;
    PIPSEC_AUTH_METHOD pMethod = NULL;


    pIpsecNFAData = (PIPSEC_NFA_DATA) AllocPolMem(
                    sizeof(IPSEC_NFA_DATA)
                    );
    if (!pIpsecNFAData) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pszNFAName) {
        pIpsecNFAData->pszIpsecName = AllocPolStr(pszNFAName);
        if (!pIpsecNFAData->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    memcpy(
        &(pIpsecNFAData->NFAIdentifier),
        &(NFAIdentifier),
        sizeof(GUID)
        );

    dwAuthMethodCount = 1;
    ppAuthMethods = (PIPSEC_AUTH_METHOD *) AllocPolMem(
                    sizeof(PIPSEC_AUTH_METHOD)*dwAuthMethodCount
                    );
    if (!ppAuthMethods) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    pIpsecNFAData->dwAuthMethodCount = dwAuthMethodCount;
    pIpsecNFAData->ppAuthMethods = ppAuthMethods;

    pMethod = (PIPSEC_AUTH_METHOD) AllocPolMem(
              sizeof(IPSEC_AUTH_METHOD)
              );
    if (!pMethod) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMethod->dwAuthType = OAK_SSPI;
    pMethod->dwAuthLen = 0;
    pMethod->pszAuthMethod = NULL;
    pMethod->dwAltAuthLen = 0;
    pMethod->pAltAuthMethod = NULL;

    *(ppAuthMethods + 0) = pMethod;

    pIpsecNFAData->dwInterfaceType = PS_INTERFACE_TYPE_ALL;
    pIpsecNFAData->pszInterfaceName = NULL;

    pIpsecNFAData->dwTunnelIpAddr = 0;
    pIpsecNFAData->dwTunnelFlags = 0;

    pIpsecNFAData->dwActiveFlag = 1;

    pIpsecNFAData->pszEndPointName = NULL;

    pIpsecNFAData->pIpsecFilterData = NULL;
    pIpsecNFAData->pIpsecNegPolData = NULL;

    pIpsecNFAData->dwWhenChanged = 0;

    memcpy(
        &(pIpsecNFAData->NegPolIdentifier),
        &(NegPolIdentifier),
        sizeof(GUID)
        );
    memcpy(
        &(pIpsecNFAData->FilterIdentifier),
        &(FilterIdentifier),
        sizeof(GUID)
        );

    if (pszNFADescription) {
        pIpsecNFAData->pszDescription = AllocPolStr(pszNFADescription);
        if (!pIpsecNFAData->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    dwError = IPSecCreateNFAData(
                  hPolicyStore,
                  PolicyIdentifier,
                  pIpsecNFAData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecNFAData) {
        FreeIpsecNFAData(pIpsecNFAData);
    }

    return (dwError);
}


DWORD
MapIdAndCreateNFA(
    HANDLE hPolicyStore,
    GUID NFAIdentifier,
    GUID PolicyIdentifier,
    GUID FilterIdentifier,
    GUID NegPolIdentifier,
    DWORD dwNFANameID,
    DWORD dwNFADescriptionID
    )
{
    LPWSTR pszNFAName = NULL, pszNFADescription = NULL;
    DWORD dwError = 0;

    dwError = MapAndAllocPolStr(&pszNFAName, dwNFANameID);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = MapAndAllocPolStr(&pszNFADescription, dwNFADescriptionID);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError =  CreateNFA(hPolicyStore,
                        NFAIdentifier,
                        PolicyIdentifier,
                        FilterIdentifier,
                        NegPolIdentifier,
                        pszNFAName,
                        pszNFADescription
                        );
error:
    LocalFree(pszNFADescription);
    LocalFree(pszNFAName);

    return dwError;
}


DWORD
MapAndAllocPolStr(
    LPWSTR * plpStr,
    DWORD dwStrID
    )
{
    LPWSTR lpStr;
    DWORD dwResult;

    dwResult = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE
                            | FORMAT_MESSAGE_IGNORE_INSERTS,
                            GetModuleHandleW(SZAPPNAME),
                            dwStrID, LANG_NEUTRAL,
                            (LPWSTR) plpStr, 0, NULL);

    if (dwResult == 0) {
       *plpStr = NULL;
       return GetLastError();
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\refer-r.h ===
//
// Policy Object References
//

DWORD
RegAddNFAReferenceToPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecNFADistinguishedName
    );

DWORD
RegRemoveNFAReferenceFromPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecNFAName
    );

//
// NFA Object References
//

DWORD
RegAddPolicyReferenceToNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecPolicyName
    );


DWORD
RegAddNegPolReferenceToNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecNegPolName
    );

DWORD
RegUpdateNegPolReferenceInNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszOldIpsecNegPolName,
    LPWSTR pszNewIpsecNegPolName
    );


DWORD
RegAddFilterReferenceToNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszIpsecFilterName
    );

DWORD
RegUpdateFilterReferenceInNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName,
    LPWSTR pszOldIpsecFilterName,
    LPWSTR pszNewIpsecFilterName
    );


//
// Filter Object References
//


DWORD
RegAddNFAReferenceToFilterObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecFilterName,
    LPWSTR pszIpsecNFAName
    );

DWORD
RegDeleteNFAReferenceInFilterObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecFilterName,
    LPWSTR pszIpsecNFAName
    );

//
// NegPol Object References
//


DWORD
RegAddNFAReferenceToNegPolObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNegPolName,
    LPWSTR pszIpsecNFAName
    );

DWORD
RegDeleteNFAReferenceInNegPolObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNegPolName,
    LPWSTR pszIpsecNFAName
    );

DWORD
AddValueToMultiSz(
    LPBYTE pValueData,
    DWORD dwSize,
    LPWSTR pszValuetoAdd,
    LPBYTE * ppNewValueData,
    DWORD * pdwNewSize
    );

DWORD
DeleteValueFromMultiSz(
    LPBYTE pValueData,
    DWORD dwSize,
    LPWSTR pszValuetoDel,
    LPBYTE * ppNewValueData,
    DWORD * pdwNewSize
    );

DWORD
RegDelFilterRefValueOfNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecNFAName
    );

DWORD
RegAddPolicyReferenceToISAKMPObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecISAKMPName,
    LPWSTR pszIpsecPolicyDistinguishedName
    );

DWORD
RegRemovePolicyReferenceFromISAKMPObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecISAKMPName,
    LPWSTR pszIpsecPolicyName
    );

DWORD
RegAddISAKMPReferenceToPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszIpsecISAKMPName
    );

DWORD
RegUpdateISAKMPReferenceInPolicyObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecPolicyName,
    LPWSTR pszOldIpsecISAKMPName,
    LPWSTR pszNewIpsecISAKMPName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\rules-d.h ===
DWORD
DirEnumNFAData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA ** pppIpsecNFAData,
    PDWORD pdwNumNFAObjects
    );

DWORD
DirEnumNFAObjects(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecPolicyName,
    PIPSEC_NFA_OBJECT ** pppIpsecNFAObjects,
    PDWORD pdwNumNFAObjects
    );

DWORD
DirGetNFADNsForPolicy(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecPolicyName,
    LPWSTR ** pppszNFADNs,
    PDWORD pdwNumNFAObjects
    );

DWORD
DirUnmarshallNFAData(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    );

DWORD
DirCreateNFAData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
DirMarshallNFAObject(
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject
    );

DWORD
ConvertGuidToDirFilterString(
    GUID FilterIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecFilterReference
    );

DWORD
ConvertGuidToDirNegPolString(
    GUID NegPolIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecNegPolReference
    );

DWORD
DirCreateNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    );

DWORD
DirMarshallAddNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    LDAPModW *** pppLDAPModW
    );

DWORD
DirSetNFAData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
DirSetNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    );

DWORD
DirMarshallSetNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    LDAPModW *** pppLDAPModW
    );

DWORD
DirDeleteNFAData(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
DirGetNFAExistingFilterRef(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR * ppszIpsecFilterName
    );

DWORD
GenerateSpecificNFAQuery(
    GUID NFAIdentifier,
    LPWSTR * ppszNFAString
    );

DWORD
DirGetNFAExistingNegPolRef(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR * ppszIpsecNegPolName
    );

DWORD
DirGetNFAObject(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NFAGUID,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\rules-f.c ===
#include "precomp.h"


DWORD
ExportNFADataToFile(
    HANDLE hSrcPolicyStore,
    PIPSEC_POLICY_STORE pDesPolicyStore,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData,
    DWORD dwNumPolicyObjects
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD j = 0;
    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;
    DWORD dwNumNFAObjects = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;


    for (i = 0; i < dwNumPolicyObjects; i++) {

        pIpsecPolicyData = *(ppIpsecPolicyData + i);

        ppIpsecNFAData = NULL;
        dwNumNFAObjects = 0;

        dwError = IPSecEnumNFAData(
                      hSrcPolicyStore,
                      pIpsecPolicyData->PolicyIdentifier,
                      &ppIpsecNFAData,
                      &dwNumNFAObjects
                      );
        if (dwError) {
            continue;
        }

        for (j = 0; j < dwNumNFAObjects; j++) {

            pIpsecNFAData = *(ppIpsecNFAData + j);

            dwError = RegCreateNFAData(
                          pDesPolicyStore->hRegistryKey,
                          pDesPolicyStore->pszIpsecRootContainer,
                          pIpsecPolicyData->PolicyIdentifier,
                          pDesPolicyStore->pszLocationName,
                          pIpsecNFAData
                          );
            if (dwError) {
                continue;
            }

        }

        if (ppIpsecNFAData) {
            FreeMulIpsecNFAData(
                ppIpsecNFAData,
                dwNumNFAObjects
                );
        }

    }

    dwError = ERROR_SUCCESS;

    return (dwError);
}


DWORD
ImportNFADataFromFile(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData,
    DWORD dwNumPolicyObjects
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD j = 0;
    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;
    DWORD dwNumNFAObjects = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;


    for (i = 0; i < dwNumPolicyObjects; i++) {

        pIpsecPolicyData = *(ppIpsecPolicyData + i);

        ppIpsecNFAData = NULL;
        dwNumNFAObjects = 0;

        dwError = RegEnumNFAData(
                      pSrcPolicyStore->hRegistryKey,
                      pSrcPolicyStore->pszIpsecRootContainer,
                      pIpsecPolicyData->PolicyIdentifier,
                      &ppIpsecNFAData,
                      &dwNumNFAObjects
                      );
        if (dwError) {
            continue;
        }

        for (j = 0; j < dwNumNFAObjects; j++) {

            pIpsecNFAData = *(ppIpsecNFAData + j);

            dwError = IPSecCreateNFAData(
                          hDesPolicyStore,
                          pIpsecPolicyData->PolicyIdentifier,
                          pIpsecNFAData
                          );
            if (dwError == ERROR_OBJECT_ALREADY_EXISTS) {
                dwError = IPSecSetNFAData(
                              hDesPolicyStore,
                              pIpsecPolicyData->PolicyIdentifier,
                              pIpsecNFAData
                              );
            }
            if (dwError) {
                continue;
            }

        }

        if (ppIpsecNFAData) {
            FreeMulIpsecNFAData(
                ppIpsecNFAData,
                dwNumNFAObjects
                );
        }

    }

    dwError = ERROR_SUCCESS;

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\rules-f.h ===
DWORD
ExportNFADataToFile(
    HANDLE hSrcPolicyStore,
    PIPSEC_POLICY_STORE pDesPolicyStore,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData,
    DWORD dwNumPolicyObjects
    );

DWORD
ImportNFADataFromFile(
    PIPSEC_POLICY_STORE pSrcPolicyStore,
    HANDLE hDesPolicyStore,
    PIPSEC_POLICY_DATA * ppIpsecPolicyData,
    DWORD dwNumPolicyObjects
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\rules-r.h ===
DWORD
RegCreateNFAData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    LPWSTR pszLocationName,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
RegSetNFAData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    LPWSTR pszLocationName,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
RegDeleteNFAData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    LPWSTR pszLocationName,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
RegEnumNFAData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA ** pppIpsecNFAData,
    PDWORD pdwNumNFAObjects
    );

DWORD
RegEnumNFAObjects(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecPolicyName,
    PIPSEC_NFA_OBJECT ** pppIpsecNFAObjects,
    PDWORD pdwNumNFAObjects
    );

DWORD
RegCreateNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    );

DWORD
RegSetNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    );

DWORD
RegUnmarshallNFAData(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    );

DWORD
RegMarshallNFAObject(
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject
    );

DWORD
MarshallNFABuffer(
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPBYTE * ppBuffer,
    DWORD * pdwBufferLen
    );

DWORD
MarshallAuthMethods(
    PIPSEC_AUTH_METHOD pIpsecAuthMethod,
    LPBYTE * ppMem,
    DWORD * pdwSize,
    DWORD dwVersion
    );

DWORD
ConvertGuidToNegPolString(
    GUID NegPolIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecNegPolReference
    );

DWORD
ConvertGuidToFilterString(
    GUID FilterIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecFilterReference
    );

DWORD
RegGetNFAExistingFilterRef(
    HKEY hRegistryKey,
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR * ppszFilterName
    );

DWORD
RegGetNFAExistingNegPolRef(
    HKEY hRegistryKey,
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR * ppszNegPolName
    );

DWORD
ConvertGuidToPolicyString(
    GUID PolicyIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecPolicyReference
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\rules-r.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       rules-r.c
//
//  Contents:   Rule management for registry.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//
//----------------------------------------------------------------------------

#include "precomp.h"

extern LPWSTR NFADNAttributes[];


#define AUTH_VERSION_ONE    1
#define AUTH_VERSION_TWO    2


DWORD
RegCreateNFAData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    LPWSTR pszLocationName,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    WCHAR szAbsNFAReference[MAX_PATH];
    LPWSTR pszAbsPolicyReference = NULL;
    LPWSTR pszRelPolicyReference = NULL;
    LPWSTR pszRelFilterReference = NULL;
    LPWSTR pszRelNegPolReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszIpsecPolicyRef = NULL;
    BOOL bIsActive = FALSE;


    dwRootPathLen =  wcslen(pszIpsecRootContainer);

    dwError = RegMarshallNFAObject(
                    pIpsecNFAData,
                    pszIpsecRootContainer,
                    &pIpsecNFAObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Create the NFA object in the store.
    //

    dwError = RegCreateNFAObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    pIpsecNFAObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ConvertGuidToPolicyString(
                  PolicyIdentifier,
                  pszIpsecRootContainer,
                  &pszAbsPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    pszRelPolicyReference = pszAbsPolicyReference
                            + dwRootPathLen + 1;

    szAbsNFAReference[0] = L'\0';
    wcscpy(szAbsNFAReference, pszIpsecRootContainer);
    wcscat(szAbsNFAReference, L"\\");
    wcscat(szAbsNFAReference, pIpsecNFAObject->pszDistinguishedName);

    //
    // Write the policy object reference.
    //

    dwError = RegAddNFAReferenceToPolicyObject(
                  hRegistryKey,
                  pszRelPolicyReference,
                  szAbsNFAReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    //
    // Write the NFA object reference.
    //

    dwError = RegAddPolicyReferenceToNFAObject(
                  hRegistryKey,
                  pIpsecNFAObject->pszDistinguishedName,
                  pszAbsPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Write the filter object reference for the NFA
    // only if the NFA is not a default rule.
    //


    if (pIpsecNFAObject->pszIpsecFilterReference) {
        pszRelFilterReference = pIpsecNFAObject->pszIpsecFilterReference
                                + dwRootPathLen + 1;
        dwError = RegAddNFAReferenceToFilterObject(
                      hRegistryKey,
                      pszRelFilterReference,
                      szAbsNFAReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Write the NFA object reference for the filter
    // only if the NFA is not a default rule.
    //

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        dwError = RegAddFilterReferenceToNFAObject(
                      hRegistryKey,
                      pIpsecNFAObject->pszDistinguishedName,
                      pIpsecNFAObject->pszIpsecFilterReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Write the negpol object reference for the NFA.
    //
    pszRelNegPolReference = pIpsecNFAObject->pszIpsecNegPolReference
                            + dwRootPathLen + 1;
    dwError = RegAddNFAReferenceToNegPolObject(
                  hRegistryKey,
                  pszRelNegPolReference,
                  szAbsNFAReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Write the NFA object reference for the negpol.
    //

    dwError = RegAddNegPolReferenceToNFAObject(
                  hRegistryKey,
                  pIpsecNFAObject->pszDistinguishedName,
                  pIpsecNFAObject->pszIpsecNegPolReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IsRegPolicyCurrentlyActive(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  PolicyIdentifier,
                  &bIsActive
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (bIsActive) {
        dwError = PingPolicyAgentSvc(pszLocationName);
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(pIpsecNFAObject);
    }

    if (pszAbsPolicyReference) {
        FreePolStr(pszAbsPolicyReference);
    }

    return(dwError);
}


DWORD
RegSetNFAData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    LPWSTR pszLocationName,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    WCHAR szAbsNFAReference[MAX_PATH];
    LPWSTR pszAbsOldFilterRef = NULL;
    LPWSTR pszAbsOldNegPolRef = NULL;
    LPWSTR pszRelOldFilterRef = NULL;
    LPWSTR pszRelOldNegPolRef = NULL;
    LPWSTR pszRelFilterReference = NULL;
    LPWSTR pszRelNegPolReference = NULL;
    DWORD dwRootPathLen = 0;


    dwRootPathLen =  wcslen(pszIpsecRootContainer);

    dwError = RegGetNFAExistingFilterRef(
                   hRegistryKey,
                   pIpsecNFAData,
                   &pszAbsOldFilterRef
                   );
    //
    // Filter Reference can be null for a default rule.                    
    // BAIL_ON_WIN32_ERROR(dwError);
    //

    if (pszAbsOldFilterRef && *pszAbsOldFilterRef) {
        pszRelOldFilterRef = pszAbsOldFilterRef + dwRootPathLen + 1;
    }

    dwError = RegGetNFAExistingNegPolRef(
                   hRegistryKey,
                   pIpsecNFAData,
                   &pszAbsOldNegPolRef
                   );                    
    // BAIL_ON_WIN32_ERROR(dwError);
    if (pszAbsOldNegPolRef && *pszAbsOldNegPolRef) {
        pszRelOldNegPolRef = pszAbsOldNegPolRef + dwRootPathLen + 1;
    }

    //
    // Marshall to update the NFA object in the store
    //

    dwError = RegMarshallNFAObject(
                    pIpsecNFAData,
                    pszIpsecRootContainer,
                    &pIpsecNFAObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);


    //
    // Update the NFA object
    //

    dwError = RegSetNFAObject(
                    hRegistryKey,
                    pszIpsecRootContainer,
                    pIpsecNFAObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    szAbsNFAReference[0] = L'\0';
    wcscpy(szAbsNFAReference, pszIpsecRootContainer);
    wcscat(szAbsNFAReference, L"\\");
    wcscat(szAbsNFAReference, pIpsecNFAObject->pszDistinguishedName);

    if (pszRelOldFilterRef && *pszRelOldFilterRef) {
        dwError = RegDeleteNFAReferenceInFilterObject(
                      hRegistryKey,
                      pszRelOldFilterRef,
                      szAbsNFAReference
                      );
        // BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Write the new filter object reference for the NFA.
    //

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        pszRelFilterReference = pIpsecNFAObject->pszIpsecFilterReference
                                + dwRootPathLen + 1;
        dwError = RegAddNFAReferenceToFilterObject(
                      hRegistryKey,
                      pszRelFilterReference,
                      szAbsNFAReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }  

    //
    // Update the NFA object reference for the filter.
    //

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        dwError = RegUpdateFilterReferenceInNFAObject(
                      hRegistryKey,
                      pIpsecNFAObject->pszDistinguishedName,
                      pszAbsOldFilterRef,
                      pIpsecNFAObject->pszIpsecFilterReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    else {
        dwError = RegDelFilterRefValueOfNFAObject(
                      hRegistryKey,
                      pIpsecNFAObject->pszDistinguishedName
                      );
        // BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Write the new negpol object reference for the NFA.
    //

    pszRelNegPolReference = pIpsecNFAObject->pszIpsecNegPolReference
                            + dwRootPathLen + 1;

    if (pszRelOldNegPolRef && *pszRelOldNegPolRef) {
        dwError = RegDeleteNFAReferenceInNegPolObject(
                      hRegistryKey,
                      pszRelOldNegPolRef,
                      szAbsNFAReference
                      );
        // BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegAddNFAReferenceToNegPolObject(
                  hRegistryKey,
                  pszRelNegPolReference,
                  szAbsNFAReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Update the NFA object reference for the negpol.
    //

    dwError = RegUpdateNegPolReferenceInNFAObject(
                  hRegistryKey,
                  pIpsecNFAObject->pszDistinguishedName,
                  pszAbsOldNegPolRef,
                  pIpsecNFAObject->pszIpsecNegPolReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegBackPropIncChangesForNFAToPolicy(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszLocationName,
                  pIpsecNFAObject->pszDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(pIpsecNFAObject);
    }

    if (pszAbsOldFilterRef) {
        FreePolStr(pszAbsOldFilterRef);
    }

    if (pszAbsOldNegPolRef) {
        FreePolStr(pszAbsOldNegPolRef);
    }

    return(dwError);
}


DWORD
RegDeleteNFAData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    LPWSTR pszLocationName,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    LPWSTR pszAbsPolicyReference = NULL;
    LPWSTR pszRelPolicyReference = NULL;
    WCHAR szAbsNFAReference[MAX_PATH];
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelNegPolReference = NULL;
    LPWSTR pszRelFilterReference = NULL;
    BOOL bIsActive = FALSE;


    dwRootPathLen = wcslen(pszIpsecRootContainer);

    dwError = ConvertGuidToPolicyString(
                  PolicyIdentifier,
                  pszIpsecRootContainer,
                  &pszAbsPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    pszRelPolicyReference = pszAbsPolicyReference
                            + dwRootPathLen + 1;

    dwError = RegMarshallNFAObject(
                    pIpsecNFAData,
                    pszIpsecRootContainer,
                    &pIpsecNFAObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    szAbsNFAReference[0] = L'\0';
    wcscpy(szAbsNFAReference, pszIpsecRootContainer);
    wcscat(szAbsNFAReference, L"\\");
    wcscat(szAbsNFAReference, pIpsecNFAObject->pszDistinguishedName);

    //
    // Remove the NFA reference from the policy object.
    //

    dwError = RegRemoveNFAReferenceFromPolicyObject(
                  hRegistryKey,
                  pszRelPolicyReference,
                  szAbsNFAReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pszRelNegPolReference = pIpsecNFAObject->pszIpsecNegPolReference
                            + dwRootPathLen + 1;
    dwError = RegDeleteNFAReferenceInNegPolObject(
                  hRegistryKey,
                  pszRelNegPolReference,
                  szAbsNFAReference
                  );
    // BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecNFAObject->pszIpsecFilterReference) {
        pszRelFilterReference = pIpsecNFAObject->pszIpsecFilterReference
                                + dwRootPathLen + 1;
        dwError = RegDeleteNFAReferenceInFilterObject(
                      hRegistryKey,
                      pszRelFilterReference,
                      szAbsNFAReference
                      );
        // BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegDeleteKeyW(
                  hRegistryKey,
                  pIpsecNFAObject->pszDistinguishedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IsRegPolicyCurrentlyActive(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  PolicyIdentifier,
                  &bIsActive
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (bIsActive) {
        dwError = PingPolicyAgentSvc(pszLocationName);
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(pIpsecNFAObject);
    }

    if (pszAbsPolicyReference) {
        FreePolStr(pszAbsPolicyReference);
    }

    return(dwError);
}


DWORD
RegEnumNFAData(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA ** pppIpsecNFAData,
    PDWORD pdwNumNFAObjects
    )
{

    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject = NULL;
    DWORD dwNumNFAObjects = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;
    LPWSTR pszAbsPolicyReference = NULL;
    LPWSTR pszRelPolicyReference = NULL;
    DWORD dwRootPathLen = 0;
    DWORD j = 0;


    dwRootPathLen = wcslen(pszIpsecRootContainer);

    dwError = ConvertGuidToPolicyString(
                  PolicyIdentifier,
                  pszIpsecRootContainer,
                  &pszAbsPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    pszRelPolicyReference = pszAbsPolicyReference
                            + dwRootPathLen + 1;

    dwError = RegEnumNFAObjects(
                        hRegistryKey,
                        pszIpsecRootContainer,
                        pszRelPolicyReference,
                        &ppIpsecNFAObject,
                        &dwNumNFAObjects
                        );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumNFAObjects) {
        ppIpsecNFAData = (PIPSEC_NFA_DATA *)AllocPolMem(
                                sizeof(PIPSEC_NFA_DATA)*dwNumNFAObjects
                                );
        if (!ppIpsecNFAData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    for (i = 0; i < dwNumNFAObjects; i++) {

        pIpsecNFAObject = *(ppIpsecNFAObject + i);

        dwError = RegUnmarshallNFAData(
                        pIpsecNFAObject,
                        &pIpsecNFAData
                        );
        if (!dwError) {
            *(ppIpsecNFAData + j) = pIpsecNFAData;
            j++;
        }
    }

    if (j == 0) {
        if (ppIpsecNFAData) {
            FreePolMem(ppIpsecNFAData);
            ppIpsecNFAData = NULL;
        }
    }

    *pppIpsecNFAData = ppIpsecNFAData;
    *pdwNumNFAObjects  = j;

    dwError = ERROR_SUCCESS;

cleanup:

    if (ppIpsecNFAObject) {
        FreeIpsecNFAObjects(
            ppIpsecNFAObject,
            dwNumNFAObjects
            );
    }

    if (pszAbsPolicyReference) {
        FreePolStr(pszAbsPolicyReference);
    }

    return(dwError);

error:

    if (ppIpsecNFAData) {
        FreeMulIpsecNFAData(
            ppIpsecNFAData,
            i
            );
    }

    *pppIpsecNFAData  = NULL;
    *pdwNumNFAObjects = 0;

    goto cleanup;
}


DWORD
RegEnumNFAObjects(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecRelPolicyName,
    PIPSEC_NFA_OBJECT ** pppIpsecNFAObjects,
    PDWORD pdwNumNFAObjects
    )
{
    PIPSEC_NFA_OBJECT pIpsecNFAObject =  NULL;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects = NULL;
    DWORD dwNumNFAObjects = 0;
    DWORD dwError = 0;
    DWORD dwSize = 0;
    HKEY hRegKey = 0;
    DWORD i = 0;
    DWORD dwCount = 0;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszIpsecNFAName = NULL;
    LPWSTR pszTemp = NULL;
    LPWSTR pszString = NULL;
    LPWSTR pszIpsecNFAReference = NULL;
    LPWSTR pszFilterReference = NULL;
    LPWSTR pszNegPolReference = NULL;


    *pppIpsecNFAObjects = NULL;
    *pdwNumNFAObjects = 0;

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecRelPolicyName,
                    0,
                    KEY_ALL_ACCESS,
                    &hRegKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecNFAReference",
                    REG_MULTI_SZ,
                    (LPBYTE *)&pszIpsecNFAReference,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pszTemp = pszIpsecNFAReference;
    while (*pszTemp != L'\0') {

        pszTemp += wcslen(pszTemp) + 1;
        dwCount++;
    }

    if (!dwCount) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                sizeof(LPWSTR)*dwCount
                                );
    if (!ppszIpsecNFANames) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pszTemp = pszIpsecNFAReference;
    for (i = 0; i < dwCount; i++) {

        pszString = AllocPolStr(pszTemp);
        if (!pszString) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        *(ppszIpsecNFANames + i) = pszString;

        pszTemp += wcslen(pszTemp) + 1; //for the null terminator;

    }

    ppIpsecNFAObjects = (PIPSEC_NFA_OBJECT *)AllocPolMem(
                                    sizeof(PIPSEC_NFA_OBJECT)*dwCount
                                    );
    if (!ppIpsecNFAObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    for (i = 0; i < dwCount; i++) {

        dwError = UnMarshallRegistryNFAObject(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      *(ppszIpsecNFANames + i),
                      &pIpsecNFAObject,
                      &pszFilterReference,
                      &pszNegPolReference
                      );

        if (dwError == ERROR_SUCCESS) {

            *(ppIpsecNFAObjects + dwNumNFAObjects) = pIpsecNFAObject;

            dwNumNFAObjects++;

            if (pszFilterReference) {
                FreePolStr(pszFilterReference);
            }

            if (pszNegPolReference) {
                FreePolStr(pszNegPolReference);
            }

        }

    }

    *pppIpsecNFAObjects = ppIpsecNFAObjects;
    *pdwNumNFAObjects = dwNumNFAObjects;

    dwError = ERROR_SUCCESS;

cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pszIpsecNFAReference) {
        FreePolStr(pszIpsecNFAReference);
    }

    if (ppszIpsecNFANames) {
        FreeNFAReferences(
            ppszIpsecNFANames,
            dwCount
            );
    }

    return(dwError);

error:

    if (ppIpsecNFAObjects) {
        FreeIpsecNFAObjects(
            ppIpsecNFAObjects,
            dwNumNFAObjects
            );
    }

    *pppIpsecNFAObjects = NULL;
    *pdwNumNFAObjects = 0;

    goto cleanup;
}


DWORD
RegCreateNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    )
{
    DWORD dwError = 0;

    dwError = PersistNFAObject(
                    hRegistryKey,
                    pIpsecNFAObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegSetNFAObject(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT pIpsecNFAObject
    )
{
    DWORD dwError = 0;

    dwError = PersistNFAObject(
                    hRegistryKey,
                    pIpsecNFAObject
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegUnmarshallNFAData(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallNFAObject(
                    pIpsecNFAObject,
                    IPSEC_REGISTRY_PROVIDER,
                    ppIpsecNFAData
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return(dwError);
}


DWORD
RegMarshallNFAObject(
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR pszIpsecRootContainer,
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject
    )
{
    DWORD dwError = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    WCHAR szGuid[MAX_PATH];
    WCHAR szDistinguishedName[MAX_PATH];
    LPBYTE pBuffer = NULL;
    DWORD dwBufferLen = 0;
    LPWSTR pszStringUuid = NULL;
    LPWSTR pszIpsecFilterReference = NULL;
    LPWSTR pszIpsecNegPolReference = NULL;
    GUID ZeroGuid;
    time_t PresentTime;

    memset(&ZeroGuid, 0, sizeof(GUID));

    szGuid[0] = L'\0';
    szDistinguishedName[0] = L'\0';
    pIpsecNFAObject = (PIPSEC_NFA_OBJECT)AllocPolMem(
                                                    sizeof(IPSEC_NFA_OBJECT)
                                                    );
    if (!pIpsecNFAObject) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = UuidToString(
                    &pIpsecNFAData->NFAIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szGuid, L"{");
    wcscat(szGuid, pszStringUuid);
    wcscat(szGuid, L"}");

    //
    // Fill in the distinguishedName
    //

    wcscpy(szDistinguishedName,L"ipsecNFA");
    wcscat(szDistinguishedName, szGuid);
    pIpsecNFAObject->pszDistinguishedName = AllocPolStr(
                                                szDistinguishedName
                                                );
    if (!pIpsecNFAObject->pszDistinguishedName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }


    //
    // Fill in the ipsecName
    //

    if (pIpsecNFAData->pszIpsecName &&
        *pIpsecNFAData->pszIpsecName) {

        pIpsecNFAObject->pszIpsecName = AllocPolStr(
                                            pIpsecNFAData->pszIpsecName
                                            );
        if (!pIpsecNFAObject->pszIpsecName) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pIpsecNFAData->pszDescription &&
        *pIpsecNFAData->pszDescription) {

        pIpsecNFAObject->pszDescription = AllocPolStr(
                                            pIpsecNFAData->pszDescription
                                            );
        if (!pIpsecNFAObject->pszDescription) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    //
    // Fill in the ipsecID
    //

    pIpsecNFAObject->pszIpsecID = AllocPolStr(
                                      szGuid
                                      );
    if (!pIpsecNFAObject->pszIpsecID) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Fill in the ipsecDataType
    //

    pIpsecNFAObject->dwIpsecDataType = 0x100;


    //
    // Marshall the pIpsecDataBuffer and the Length
    //

    dwError = MarshallNFABuffer(
                    pIpsecNFAData,
                    &pBuffer,
                    &dwBufferLen
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNFAObject->pIpsecData  = pBuffer;

    pIpsecNFAObject->dwIpsecDataLen = dwBufferLen;

    //
    // Marshall the Filter Reference.
    // There's no filter reference for a default rule.
    //

    if (memcmp(
            &pIpsecNFAData->FilterIdentifier,
            &ZeroGuid,
            sizeof(GUID))) {
        dwError = ConvertGuidToFilterString(
                      pIpsecNFAData->FilterIdentifier,
                      pszIpsecRootContainer,
                      &pszIpsecFilterReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        pIpsecNFAObject->pszIpsecFilterReference = pszIpsecFilterReference;
    }
    else {
        pIpsecNFAObject->pszIpsecFilterReference = NULL;
    }

    //
    // Marshall the NegPol Reference
    //

    dwError = ConvertGuidToNegPolString(
                    pIpsecNFAData->NegPolIdentifier,
                    pszIpsecRootContainer,
                    &pszIpsecNegPolReference
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    pIpsecNFAObject->pszIpsecNegPolReference = pszIpsecNegPolReference;

    time(&PresentTime);

    pIpsecNFAObject->dwWhenChanged = (DWORD) PresentTime;

    *ppIpsecNFAObject = pIpsecNFAObject;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(
            &pszStringUuid
            );
    }

    return(dwError);

error:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(
                pIpsecNFAObject
                );
    }

    *ppIpsecNFAObject = NULL;
    goto cleanup;
}


DWORD
MarshallNFABuffer(
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPBYTE * ppBuffer,
    DWORD * pdwBufferLen
    )
{
    LPBYTE pBuffer = NULL;
    LPBYTE pCurrentPos = NULL;
    DWORD dwTotalSize = 0;
    DWORD dwError = 0;
    LPBYTE pAuthMem = NULL;
    DWORD dwAuthSize = 0;
    DWORD dwInterfaceType = 0;
    DWORD dwInterfaceNameLen = 0;
    LPWSTR pszInterfaceName = NULL;
    DWORD dwTunnelIpAddr = 0;
    DWORD dwTunnelFlags = 0;
    DWORD dwActiveFlag = 0;
    LPWSTR pszEndPointName = NULL;
    DWORD dwEndPointNameLen = 0;
    PIPSEC_AUTH_METHOD pIpsecAuthMethod = NULL;
    DWORD dwNumAuthMethods = 0;
    DWORD i = 0;
    PSPEC_BUFFER  pSpecBuffer = NULL;
    PSPEC_BUFFER  pSpecBufferV2 = NULL;
    // {11BBAC00-498D-11d1-8639-00A0248D3021}
    static const GUID GUID_IPSEC_NFA_BLOB =
    { 0x11bbac00, 0x498d, 0x11d1, { 0x86, 0x39, 0x0, 0xa0, 0x24, 0x8d, 0x30, 0x21 } };
    DWORD dwEffectiveSize = 0;
    DWORD dwTotalV2AuthSize=0;
    DWORD dwTotalV3AuthSize=0;

    dwTotalSize += sizeof(GUID);

    dwTotalSize += sizeof(DWORD);

    dwTotalSize += sizeof(DWORD);

    dwNumAuthMethods = pIpsecNFAData->dwAuthMethodCount;

    if (!dwNumAuthMethods) {
         dwError = ERROR_INVALID_PARAMETER;
         BAIL_ON_WIN32_ERROR(dwError);
    }

    pSpecBuffer = AllocPolMem(
                    sizeof(SPEC_BUFFER)*dwNumAuthMethods
                    );
    if (!pSpecBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pSpecBufferV2 = AllocPolMem(
                      sizeof(SPEC_BUFFER)*dwNumAuthMethods
                      );
    if (!pSpecBufferV2) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwNumAuthMethods;i++){

        pIpsecAuthMethod = *(pIpsecNFAData->ppAuthMethods + i);
        dwError = MarshallAuthMethods(
                        pIpsecAuthMethod,
                        &pAuthMem,
                        &dwAuthSize,
                        AUTH_VERSION_ONE
                        );
        BAIL_ON_WIN32_ERROR(dwError);
        dwTotalSize += dwAuthSize;

        (pSpecBuffer + i)->dwSize = dwAuthSize;
        (pSpecBuffer + i)->pMem = pAuthMem;

    }

    dwInterfaceType = pIpsecNFAData->dwInterfaceType;
    dwTotalSize += sizeof(DWORD);

    pszInterfaceName = pIpsecNFAData->pszInterfaceName;
    if (pszInterfaceName) {
        dwInterfaceNameLen = (wcslen(pszInterfaceName) + 1)*sizeof(WCHAR);
    }
    else {
        dwInterfaceNameLen = sizeof(WCHAR);
    }

    dwTotalSize += sizeof(DWORD);
    dwTotalSize += dwInterfaceNameLen;

    dwTunnelIpAddr = pIpsecNFAData->dwTunnelIpAddr;
    dwTotalSize += sizeof(DWORD);

    dwTunnelFlags = pIpsecNFAData->dwTunnelFlags;
    dwTotalSize += sizeof(DWORD);

    dwActiveFlag = pIpsecNFAData->dwActiveFlag;
    dwTotalSize += sizeof(DWORD);

    pszEndPointName = pIpsecNFAData->pszEndPointName;
    if (pszEndPointName) {
        dwEndPointNameLen = (wcslen(pszEndPointName) + 1)*sizeof(WCHAR);
    }
    else {
        dwEndPointNameLen = sizeof(WCHAR);
    }

    dwTotalSize += sizeof(DWORD);
    dwTotalSize += dwEndPointNameLen;

    //
    // Marshall version 2 auth data.
    //

    dwTotalSize += sizeof(GUID);
    dwTotalV2AuthSize += sizeof(GUID);

    dwTotalSize += sizeof(DWORD);
    dwTotalV2AuthSize += sizeof(DWORD);

    for (i = 0; i < dwNumAuthMethods; i++) {

        pIpsecAuthMethod = *(pIpsecNFAData->ppAuthMethods + i);
        dwError = MarshallAuthMethods(
                        pIpsecAuthMethod,
                        &pAuthMem,
                        &dwAuthSize,
                        AUTH_VERSION_TWO
                        );
        BAIL_ON_WIN32_ERROR(dwError);
        dwTotalSize += dwAuthSize;
        dwTotalV2AuthSize += dwAuthSize;

        (pSpecBufferV2 + i)->dwSize = dwAuthSize;
        (pSpecBufferV2 + i)->pMem = pAuthMem;

    }

    //
    // Marshall version 3 auth flags
    // 
    dwTotalSize += sizeof(GUID);
    dwTotalV3AuthSize += sizeof(GUID);

    dwTotalSize += sizeof(DWORD);
    dwTotalV3AuthSize += sizeof(DWORD);

    dwTotalSize += dwNumAuthMethods * sizeof(DWORD);
    dwTotalV3AuthSize += dwNumAuthMethods * sizeof(DWORD);
    
    dwTotalSize++;

    pBuffer = AllocPolMem(dwTotalSize);
    if (!pBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pCurrentPos = pBuffer;

    memcpy(pCurrentPos, &GUID_IPSEC_NFA_BLOB, sizeof(GUID));
    pCurrentPos += sizeof(GUID);

    dwEffectiveSize = dwTotalSize - sizeof(GUID) - sizeof(DWORD) - 1 -
                      dwTotalV2AuthSize - dwTotalV3AuthSize;

    memcpy(pCurrentPos, (LPBYTE)&dwEffectiveSize, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    memcpy(pCurrentPos, (LPBYTE)&dwNumAuthMethods, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    for (i = 0; i < dwNumAuthMethods; i++) {

        pAuthMem = (pSpecBuffer + i)->pMem;
        dwAuthSize = (pSpecBuffer + i)->dwSize;

        memcpy(pCurrentPos, pAuthMem, dwAuthSize);
        pCurrentPos += dwAuthSize;

    }

    memcpy(pCurrentPos, (LPBYTE)&dwInterfaceType, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    memcpy(pCurrentPos, (LPBYTE)&dwInterfaceNameLen, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    if (pszInterfaceName) {
        memcpy(pCurrentPos, pszInterfaceName, dwInterfaceNameLen);
    }
    pCurrentPos += dwInterfaceNameLen;

    memcpy(pCurrentPos, (LPBYTE)&dwTunnelIpAddr, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    memcpy(pCurrentPos, (LPBYTE)&dwTunnelFlags, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    memcpy(pCurrentPos, (LPBYTE)&dwActiveFlag, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    memcpy(pCurrentPos, (LPBYTE)&dwEndPointNameLen, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    if (pszEndPointName) {
        memcpy(pCurrentPos, pszEndPointName, dwEndPointNameLen);
    }
    pCurrentPos += dwEndPointNameLen;

    //
    // Copy version 2 auth data.
    //

    memset(pCurrentPos, 1, sizeof(GUID));
    pCurrentPos += sizeof(GUID);

    memcpy(pCurrentPos, (LPBYTE)&dwNumAuthMethods, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    for (i = 0; i < dwNumAuthMethods; i++) {

        pAuthMem = (pSpecBufferV2 + i)->pMem;
        dwAuthSize = (pSpecBufferV2 + i)->dwSize;

        memcpy(pCurrentPos, pAuthMem, dwAuthSize);
        pCurrentPos += dwAuthSize;

    }

    //
    // Create version 3 auth data
    //
    memset(pCurrentPos, 1, sizeof(GUID));
    (pCurrentPos[sizeof(GUID)-1])++;
    pCurrentPos += sizeof(GUID);

    memcpy(pCurrentPos, (LPBYTE)&dwNumAuthMethods, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    
    for (i = 0; i < dwNumAuthMethods; i++) {
        pIpsecAuthMethod = *(pIpsecNFAData->ppAuthMethods + i);
        memcpy(pCurrentPos,&pIpsecAuthMethod->dwAuthFlags,sizeof(DWORD));
        pCurrentPos += sizeof(DWORD);
    }
    
    *ppBuffer = pBuffer;
    *pdwBufferLen = dwTotalSize;

cleanup:

    if (pSpecBuffer) {
        FreeSpecBuffer(
            pSpecBuffer,
            dwNumAuthMethods
            );
    }

    if (pSpecBufferV2) {
        FreeSpecBuffer(
            pSpecBufferV2,
            dwNumAuthMethods
            );
    }

    return (dwError);

error:

    *ppBuffer = NULL;
    *pdwBufferLen = 0;
    goto cleanup;
}


DWORD
MarshallAuthMethods(
    PIPSEC_AUTH_METHOD pIpsecAuthMethod,
    LPBYTE * ppMem,
    DWORD * pdwSize,
    DWORD dwVersion
    )
{
    DWORD dwSize = 0;
    LPBYTE pMem = NULL;
    LPBYTE pCurrentPos = NULL;
    DWORD dwError = 0;
    LPWSTR pszAuthMethod = NULL;
    DWORD dwAuthType = 0;
    DWORD dwAuthLen = 0;
    PBYTE pAltAuthMethod = NULL;


    dwAuthType = pIpsecAuthMethod->dwAuthType;

    //
    // Length in number of characters excluding the null character for
    // auth version 1.
    //

    if (dwVersion == AUTH_VERSION_ONE) {
        dwAuthLen =  pIpsecAuthMethod->dwAuthLen;
        dwAuthLen = (dwAuthLen + 1)*2;
        pszAuthMethod = pIpsecAuthMethod->pszAuthMethod;
    }
    else {
        dwAuthLen =  pIpsecAuthMethod->dwAltAuthLen;
        pAltAuthMethod = pIpsecAuthMethod->pAltAuthMethod;
    }

    dwSize += sizeof(DWORD);

    dwSize +=  sizeof(DWORD);

    dwSize += dwAuthLen;

    pMem = AllocPolMem(dwSize);
    if (!pMem) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pCurrentPos = pMem;

    memcpy(pCurrentPos, &dwAuthType, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);
    memcpy(pCurrentPos, &dwAuthLen, sizeof(DWORD));
    pCurrentPos += sizeof(DWORD);

    if (dwVersion == AUTH_VERSION_ONE) {
        if (pszAuthMethod) {
            memcpy(pCurrentPos, pszAuthMethod, dwAuthLen);
        }
    }
    else {
        if (pAltAuthMethod) {
            memcpy(pCurrentPos, pAltAuthMethod, dwAuthLen);
        }
    }

    *ppMem = pMem;
    *pdwSize = dwSize;

    return(dwError);

error:

    *ppMem = NULL;
    *pdwSize = 0;

    return(dwError);
}


DWORD
ConvertGuidToNegPolString(
    GUID NegPolIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecNegPolReference
    )
{
    DWORD dwError = 0;
    WCHAR szNegPolReference[MAX_PATH];
    LPWSTR pszIpsecNegPolReference = NULL;
    WCHAR szGuidString[MAX_PATH];
    LPWSTR pszStringUuid = NULL;


    dwError = UuidToString(
                  &NegPolIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szGuidString[0] = L'\0';
    wcscpy(szGuidString, L"{");
    wcscat(szGuidString, pszStringUuid);
    wcscat(szGuidString, L"}");

    szNegPolReference[0] = L'\0';
    SecStrCpyW(szNegPolReference, pszIpsecRootContainer, MAX_PATH);
    wcscat(szNegPolReference, L"\\");
    wcscat(szNegPolReference, L"ipsecNegotiationPolicy");
    wcscat(szNegPolReference, szGuidString);

    pszIpsecNegPolReference = AllocPolStr(
                                    szNegPolReference
                                    );
    if (!pszIpsecNegPolReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszIpsecNegPolReference = pszIpsecNegPolReference;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    *ppszIpsecNegPolReference = NULL;

    goto cleanup;
}


DWORD
ConvertGuidToFilterString(
    GUID FilterIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecFilterReference
    )
{
    DWORD dwError = 0;
    WCHAR szFilterReference[MAX_PATH];
    LPWSTR pszIpsecFilterReference = NULL;
    WCHAR szGuidString[MAX_PATH];
    LPWSTR pszStringUuid = NULL;


    dwError = UuidToString(
                  &FilterIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szGuidString[0] = L'\0';
    wcscpy(szGuidString, L"{");
    wcscat(szGuidString, pszStringUuid);
    wcscat(szGuidString, L"}");

    szFilterReference[0] = L'\0';
    SecStrCpyW(szFilterReference, pszIpsecRootContainer, MAX_PATH);
    wcscat(szFilterReference, L"\\");
    wcscat(szFilterReference, L"ipsecFilter");
    wcscat(szFilterReference, szGuidString);

    pszIpsecFilterReference = AllocPolStr(
                                    szFilterReference
                                    );
    if (!pszIpsecFilterReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszIpsecFilterReference = pszIpsecFilterReference;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    *ppszIpsecFilterReference = NULL;

    goto cleanup;
}


DWORD
RegGetNFAExistingFilterRef(
    HKEY hRegistryKey,
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR * ppszFilterName
    )
{
    DWORD dwError = 0;
    LPWSTR pszStringUuid = NULL;
    WCHAR szRelativeName[MAX_PATH];
    HKEY hRegKey = NULL;
    DWORD dwSize = 0;


    szRelativeName[0] = L'\0';
    dwError = UuidToString(
                    &pIpsecNFAData->NFAIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szRelativeName, L"ipsecNFA");
    wcscat(szRelativeName, L"{");
    wcscat(szRelativeName, pszStringUuid);
    wcscat(szRelativeName, L"}");

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    szRelativeName,
                    0,
                    KEY_ALL_ACCESS,
                    &hRegKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecFilterReference",
                    REG_SZ,
                    (LPBYTE *)ppszFilterName,
                    &dwSize
                    );
    // BAIL_ON_WIN32_ERROR(dwError);

    dwError = 0;

error:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return (dwError);
}


DWORD
RegGetNFAExistingNegPolRef(
    HKEY hRegistryKey,
    PIPSEC_NFA_DATA pIpsecNFAData,
    LPWSTR * ppszNegPolName
    )
{
    DWORD dwError = 0;
    LPWSTR pszStringUuid = NULL;
    WCHAR szRelativeName[MAX_PATH];
    HKEY hRegKey = NULL;
    DWORD dwSize = 0;


    szRelativeName[0] = L'\0';
    dwError = UuidToString(
                    &pIpsecNFAData->NFAIdentifier,
                    &pszStringUuid
                    );
    BAIL_ON_WIN32_ERROR(dwError);
    wcscpy(szRelativeName, L"ipsecNFA");
    wcscat(szRelativeName, L"{");
    wcscat(szRelativeName, pszStringUuid);
    wcscat(szRelativeName, L"}");

    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    szRelativeName,
                    0,
                    KEY_ALL_ACCESS,
                    &hRegKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecNegotiationPolicyReference",
                    REG_SZ,
                    (LPBYTE *)ppszNegPolName,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return (dwError);
}


DWORD
ConvertGuidToPolicyString(
    GUID PolicyIdentifier,
    LPWSTR pszIpsecRootContainer,
    LPWSTR * ppszIpsecPolicyReference
    )
{
    DWORD dwError = 0;
    WCHAR szPolicyReference[MAX_PATH];
    LPWSTR pszIpsecPolicyReference = NULL;
    WCHAR szGuidString[MAX_PATH];
    LPWSTR pszStringUuid = NULL;


    dwError = UuidToString(
                  &PolicyIdentifier,
                  &pszStringUuid
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    szGuidString[0] = L'\0';
    wcscpy(szGuidString, L"{");
    wcscat(szGuidString, pszStringUuid);
    wcscat(szGuidString, L"}");

    szPolicyReference[0] = L'\0';
    SecStrCpyW(szPolicyReference, pszIpsecRootContainer, MAX_PATH);
    wcscat(szPolicyReference, L"\\");
    wcscat(szPolicyReference, L"ipsecPolicy");
    wcscat(szPolicyReference, szGuidString);

    pszIpsecPolicyReference = AllocPolStr(
                                    szPolicyReference
                                    );
    if (!pszIpsecPolicyReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszIpsecPolicyReference = pszIpsecPolicyReference;

cleanup:

    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }

    return(dwError);

error:

    *ppszIpsecPolicyReference = NULL;

    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\rules-w.h ===
DWORD
WMIEnumNFADataEx(
    IWbemServices *pWbemServices,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA ** pppIpsecNFAData,
    PDWORD pdwNumNFAObjects
    );

DWORD
WMIEnumNFAObjectsEx(
    IWbemServices *pWbemServices,
    LPWSTR pszIpsecRelPolicyName,
    PIPSEC_NFA_OBJECT ** pppIpsecNFAObjects,
    PDWORD pdwNumNFAObjects
    );

DWORD
WMIUnmarshallNFAData(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    );

DWORD
ConvertGuidToPolicyStringEx(
    GUID PolicyIdentifier,
    LPWSTR * ppszIpsecPolicyReference
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\update-d.h ===
DWORD
DirBackPropIncChangesForISAKMPToPolicy(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier
    );

DWORD
DirBackPropIncChangesForFilterToNFA(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier
    );

DWORD
DirBackPropIncChangesForNegPolToNFA(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier
    );

DWORD
DirBackPropIncChangesForNFAToPolicy(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszNFADistinguishedName
    );

DWORD
DirGetPolicyReferencesForISAKMP(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    );

DWORD
DirUpdatePolicy(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecPolicyReference,
    DWORD dwDataType
    );

DWORD
DirGetPolicyReferencesForNFA(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszNFADistinguishedName,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    );

DWORD
DirGetNFAReferencesForFilter(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    );

DWORD
DirUpdateNFA(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecNFAReference,
    DWORD dwDataType
    );

DWORD
DirGetNFAReferencesForNegPol(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    );

DWORD
CopyReferences(
    LPWSTR * ppszIpsecReferences,
    DWORD dwNumReferences,
    LPWSTR ** pppszNewIpsecReferences,
    PDWORD pdwNumNewReferences
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\rules-w.c ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000.
//
//  File:       rules-w.c
//
//  Contents:   Rule management for WMI.
//
//
//  History:    KrishnaG.
//              AbhisheV.
//              t-hhsu
//
//----------------------------------------------------------------------------

#include "precomp.h"

//extern LPWSTR NFADNAttributes[];


DWORD
WMIEnumNFADataEx(
    IWbemServices *pWbemServices,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA ** pppIpsecNFAData,
    PDWORD pdwNumNFAObjects
    )
{

    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObject = NULL;
    DWORD dwNumNFAObjects = 0;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    PIPSEC_NFA_DATA * ppIpsecNFAData = NULL;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;
    LPWSTR pszAbsPolicyReference = NULL;
    LPWSTR pszRelPolicyReference = NULL;
    DWORD dwRootPathLen = 0; ////wcslen(pszIpsecRootContainer);
    DWORD j = 0;


    
    dwError = ConvertGuidToPolicyStringEx(
                  PolicyIdentifier,
                  &pszAbsPolicyReference
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    pszRelPolicyReference = pszAbsPolicyReference;
    
    dwError = WMIEnumNFAObjectsEx(
        pWbemServices,
        pszRelPolicyReference, ////'ipsecNFARef{xxx}'
        &ppIpsecNFAObject,
        &dwNumNFAObjects
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    if (dwNumNFAObjects) {
        ppIpsecNFAData = (PIPSEC_NFA_DATA *)AllocPolMem(
            sizeof(PIPSEC_NFA_DATA)*dwNumNFAObjects
            );
        if (!ppIpsecNFAData) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    
    for (i = 0; i < dwNumNFAObjects; i++) {
        pIpsecNFAObject = *(ppIpsecNFAObject + i);
        dwError = WMIUnmarshallNFAData(
            pIpsecNFAObject,
            &pIpsecNFAData
            );
        if (!dwError) {
            *(ppIpsecNFAData + j) = pIpsecNFAData;
            j++;
        }
    }
    
    if (j == 0) {
        if (ppIpsecNFAData) {
            FreePolMem(ppIpsecNFAData);
            ppIpsecNFAData = NULL;
        }
    }
    
    *pppIpsecNFAData = ppIpsecNFAData;
    *pdwNumNFAObjects  = j;
    
    dwError = ERROR_SUCCESS;
    
 cleanup:
    
    if (ppIpsecNFAObject) {
        FreeIpsecNFAObjects(
            ppIpsecNFAObject,
            dwNumNFAObjects
            );
    }
    
    if (pszAbsPolicyReference) {
        FreePolStr(pszAbsPolicyReference);
    }

    return(dwError);
    
 error:
    
    if (ppIpsecNFAData) {
        FreeMulIpsecNFAData(
            ppIpsecNFAData,
            i
            );
    }
    
    *pppIpsecNFAData  = NULL;
    *pdwNumNFAObjects = 0;
    
    goto cleanup;
}


DWORD
WMIEnumNFAObjectsEx(
    IWbemServices *pWbemServices,
    LPWSTR pszIpsecRelPolicyName,
    PIPSEC_NFA_OBJECT ** pppIpsecNFAObjects,
    PDWORD pdwNumNFAObjects
    )
{
    PIPSEC_NFA_OBJECT pIpsecNFAObject =  NULL;
    PIPSEC_NFA_OBJECT * ppIpsecNFAObjects = NULL;
    DWORD dwNumNFAObjects = 0;
    DWORD dwError = 0;
    HRESULT hr = S_OK;
    DWORD dwSize = 0;
    HKEY hRegKey = 0;
    DWORD i = 0;
    DWORD dwCount = 0;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszIpsecNFAName = NULL;
    LPWSTR pszTemp = NULL;
    LPWSTR pszString = NULL;
    LPWSTR pszIpsecNFAReference = NULL;
    LPWSTR pszFilterReference = NULL;
    LPWSTR pszNegPolReference = NULL;

    ///wbem
    IWbemClassObject *pObj = NULL;
    LPWSTR objPathA = L"RSOP_IPSECPolicySetting.id=";
    LPWSTR objPath = NULL;
    BSTR bstrObjPath = NULL;



    *pppIpsecNFAObjects = NULL;
    *pdwNumNFAObjects = 0;

    if(!pszIpsecRelPolicyName || !*pszIpsecRelPolicyName) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    objPath = (LPWSTR)AllocPolMem(
        sizeof(WCHAR)*(wcslen(objPathA)+wcslen(pszIpsecRelPolicyName)+3)
        );
    if(!objPath) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    wcscpy(objPath, objPathA);
    wcscat(objPath, L"\"");
    wcscat(objPath, pszIpsecRelPolicyName);
    wcscat(objPath, L"\"");
    
    bstrObjPath = SysAllocString(objPath);
    if(!bstrObjPath) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    hr = IWbemServices_GetObject(
        pWbemServices,
        bstrObjPath,
        WBEM_FLAG_RETURN_WBEM_COMPLETE,
        0,
        &pObj,
        0
        );
    SysFreeString(bstrObjPath);

    BAIL_ON_WMI_ERROR_WITH_WIN32(hr, dwError);

    dwError = WMIstoreQueryValue(
        pObj,
        L"ipsecNFAReference",
        VT_ARRAY|VT_BSTR,
        (LPBYTE *)&pszIpsecNFAReference,
        &dwSize
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    pszTemp = pszIpsecNFAReference;
    while (*pszTemp != L'\0') {
        pszTemp += wcslen(pszTemp) + 1;
        dwCount++;
    }
    
    if (!dwCount) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
        sizeof(LPWSTR)*dwCount
        );
    if (!ppszIpsecNFANames) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pszTemp = pszIpsecNFAReference;
    for (i = 0; i < dwCount; i++) {
        pszString = AllocPolStr(pszTemp);
        if (!pszString) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        *(ppszIpsecNFANames + i) = pszString;
        pszTemp += wcslen(pszTemp) + 1; //for the null terminator;
    }
    
    //ppszIpsecNFANames => now an array of strings w/ nfa refs
    
    ppIpsecNFAObjects = (PIPSEC_NFA_OBJECT *)AllocPolMem(
        sizeof(PIPSEC_NFA_OBJECT)*dwCount
        );
    if (!ppIpsecNFAObjects) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    for (i = 0; i < dwCount; i++) {
        dwError = UnMarshallWMINFAObject(
            pWbemServices,
            *(ppszIpsecNFANames + i),
            &pIpsecNFAObject,
            &pszFilterReference,
            &pszNegPolReference
            );
        if (dwError == ERROR_SUCCESS) {
            *(ppIpsecNFAObjects + dwNumNFAObjects) = pIpsecNFAObject;
            dwNumNFAObjects++;
            if (pszFilterReference) {
                FreePolStr(pszFilterReference);
            }
            if (pszNegPolReference) {
                FreePolStr(pszNegPolReference);
            }
        }
    }
    
    *pppIpsecNFAObjects = ppIpsecNFAObjects;
    *pdwNumNFAObjects = dwNumNFAObjects;
    
    dwError = ERROR_SUCCESS;
    
 cleanup:

    //free
    if(pObj)
        IWbemClassObject_Release(pObj);

    if (pszIpsecNFAReference) {
        FreePolStr(pszIpsecNFAReference);
    }
    
    if (ppszIpsecNFANames) {
        FreeNFAReferences(
            ppszIpsecNFANames,
            dwCount
            );
    }

    if(objPath) {
        FreePolStr(objPath);
    }

    return(dwError);
    
 error:
    
    if (ppIpsecNFAObjects) {
        FreeIpsecNFAObjects(
            ppIpsecNFAObjects,
            dwNumNFAObjects
            );
    }
    
    *pppIpsecNFAObjects = NULL;
    *pdwNumNFAObjects = 0;
    
    goto cleanup;
}


DWORD
WMIUnmarshallNFAData(
    PIPSEC_NFA_OBJECT pIpsecNFAObject,
    PIPSEC_NFA_DATA * ppIpsecNFAData
    )
{
    DWORD dwError = 0;

    dwError = UnmarshallNFAObject(
        pIpsecNFAObject,
        IPSEC_WMI_PROVIDER,
        ppIpsecNFAData
        );
    BAIL_ON_WIN32_ERROR(dwError);
    if (*ppIpsecNFAData) {
        (*ppIpsecNFAData)->dwFlags |= POLSTORE_READONLY;
    }

error:
    return(dwError);
}


DWORD
ConvertGuidToPolicyStringEx(
    GUID PolicyIdentifier,
    LPWSTR * ppszIpsecPolicyReference
    )
{
    DWORD dwError = 0;
    WCHAR szPolicyReference[MAX_PATH];
    LPWSTR pszIpsecPolicyReference = NULL;
    WCHAR szGuidString[MAX_PATH];
    LPWSTR pszStringUuid = NULL;


    
    dwError = UuidToString(
        &PolicyIdentifier,
        &pszStringUuid
        );
    BAIL_ON_WIN32_ERROR(dwError);
    
    szGuidString[0] = L'\0';
    wcscpy(szGuidString, L"{");
    wcscat(szGuidString, pszStringUuid);
    wcscat(szGuidString, L"}");
    
    szPolicyReference[0] = L'\0';
    wcscpy(szPolicyReference, L"ipsecPolicy");
    wcscat(szPolicyReference, szGuidString);
    
    pszIpsecPolicyReference = AllocPolStr(
        szPolicyReference
        );
    if (!pszIpsecPolicyReference) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    *ppszIpsecPolicyReference = pszIpsecPolicyReference;
    
 cleanup:
    
    if (pszStringUuid) {
        RpcStringFree(&pszStringUuid);
    }
    
    return(dwError);
    
 error:
    
    *ppszIpsecPolicyReference = NULL;
    
    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\update-r.h ===
DWORD
RegBackPropIncChangesForISAKMPToPolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    );

DWORD
RegBackPropIncChangesForFilterToNFA(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    );
    
DWORD
RegBackPropIncChangesForNegPolToNFA(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    );

DWORD
RegBackPropIncChangesForNFAToPolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    LPWSTR pszNFADistinguishedName
    );

DWORD
RegGetPolicyReferencesForISAKMP(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszISAKMPDistinguishedName,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    );

DWORD
RegUpdatePolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecPolicyReference
    );

DWORD
RegGetGuidFromPolicyReference(
    LPWSTR pszIpsecPolicyReference,
    GUID * pPolicyIdentifier
    );

DWORD
RegGetPolicyReferencesForNFA(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszNFADistinguishedName,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    );

DWORD
RegGetNFAReferencesForFilter(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszFilterDistinguishedName,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    );

DWORD
RegUpdateNFA(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecNFAReference
    );

DWORD
RegGetNFAReferencesForNegPol(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszNegPolDistinguishedName,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\update-d.c ===
#include "precomp.h"


DWORD
DirBackPropIncChangesForISAKMPToPolicy(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier
    )
{
    DWORD dwError = 0;
    LPWSTR * ppszIpsecPolicyReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecPolicyReference = NULL;


    dwError = DirGetPolicyReferencesForISAKMP(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  ISAKMPIdentifier,
                  &ppszIpsecPolicyReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecPolicyReference = *(ppszIpsecPolicyReferences + i);

        dwError = DirUpdatePolicy(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pszIpsecPolicyReference,
                      0x200
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = DirUpdatePolicy(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pszIpsecPolicyReference,
                      0x100
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    dwError = ERROR_SUCCESS;

error:

    if (ppszIpsecPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecPolicyReferences,
            dwNumReferences
            );
    }

    return (dwError);
}


DWORD
DirBackPropIncChangesForFilterToNFA(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier
    )
{
    DWORD dwError = 0;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecNFAReference = NULL;


    dwError = DirGetNFAReferencesForFilter(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  FilterIdentifier,
                  &ppszIpsecNFAReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecNFAReference = *(ppszIpsecNFAReferences + i);

        dwError = DirUpdateNFA(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pszIpsecNFAReference,
                      0x200
                      );
        if (dwError) {
            continue;
        }

        dwError = DirUpdateNFA(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pszIpsecNFAReference,
                      0x100
                      );
        if (dwError) {
            continue;
        }

        dwError = DirBackPropIncChangesForNFAToPolicy(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pszIpsecNFAReference
                      );
        if (dwError) {
            continue;
        }

    }

    dwError = ERROR_SUCCESS;

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            dwNumReferences
            );
    }

    return (dwError);
}

    
DWORD
DirBackPropIncChangesForNegPolToNFA(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier
    )
{
    DWORD dwError = 0;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecNFAReference = NULL;


    dwError = DirGetNFAReferencesForNegPol(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  NegPolIdentifier,
                  &ppszIpsecNFAReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecNFAReference = *(ppszIpsecNFAReferences + i);

        dwError = DirUpdateNFA(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pszIpsecNFAReference,
                      0x200
                      );
        if (dwError) {
            continue;
        }

        dwError = DirUpdateNFA(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pszIpsecNFAReference,
                      0x100
                      );
        if (dwError) {
            continue;
        }

        dwError = DirBackPropIncChangesForNFAToPolicy(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pszIpsecNFAReference
                      );
        if (dwError) {
            continue;
        }

    }

    dwError = ERROR_SUCCESS;

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            dwNumReferences
            );
    }

    return (dwError);
}


DWORD
DirBackPropIncChangesForNFAToPolicy(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszNFADistinguishedName
    )
{
    DWORD dwError = 0;
    LPWSTR * ppszIpsecPolicyReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecPolicyReference = NULL;


    dwError = DirGetPolicyReferencesForNFA(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  pszNFADistinguishedName,
                  &ppszIpsecPolicyReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecPolicyReference = *(ppszIpsecPolicyReferences + i);

        dwError = DirUpdatePolicy(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pszIpsecPolicyReference,
                      0x200
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = DirUpdatePolicy(
                      hLdapBindHandle,
                      pszIpsecRootContainer,
                      pszIpsecPolicyReference,
                      0x100
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    dwError = ERROR_SUCCESS;

error:

    if (ppszIpsecPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecPolicyReferences,
            dwNumReferences
            );
    }

    return (dwError);
}


DWORD
DirGetPolicyReferencesForISAKMP(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID ISAKMPIdentifier,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject = NULL;
    LPWSTR * ppszIpsecPolicyReferences = NULL;
    DWORD dwNumReferences = 0;


    dwError = DirGetISAKMPObject(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  ISAKMPIdentifier,
                  &pIpsecISAKMPObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyReferences(
                  pIpsecISAKMPObject->ppszIpsecNFAReferences,
                  pIpsecISAKMPObject->dwNFACount,
                  &ppszIpsecPolicyReferences,
                  &dwNumReferences
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *pppszIpsecPolicyReferences = ppszIpsecPolicyReferences;
    *pdwNumReferences = dwNumReferences;

cleanup:

    if (pIpsecISAKMPObject) {
        FreeIpsecISAKMPObject(pIpsecISAKMPObject);
    }

    return (dwError);

error:

    *pppszIpsecPolicyReferences = NULL;
    *pdwNumReferences = 0;

    goto cleanup;
}


DWORD
DirUpdatePolicy(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecPolicyReference,
    DWORD dwDataType
    )
{
    DWORD dwError = 0;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    WCHAR Buffer[64];
    DWORD dwIpsecDataType = dwDataType;


    Buffer[0] = L'\0';

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                   (dwNumAttributes+1) * sizeof(LDAPModW*)
                                   );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                 dwNumAttributes * sizeof(LDAPModW)
                                 );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                  L"ipsecDataType",
                  &(pLDAPModW +i)->mod_type
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                  Buffer,
                  (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    dwError = LdapModifyS(
                  hLdapBindHandle,
                  pszIpsecPolicyReference,
                  ppLDAPModW
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirGetPolicyReferencesForNFA(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszNFADistinguishedName,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    LPWSTR pszIpsecID = NULL;
    GUID NFAIdentifier;
    PIPSEC_NFA_OBJECT pIpsecNFAObject = NULL;
    LPWSTR * ppszIpsecPolicyReferences = NULL;
    DWORD dwNumReferences = 0;


    pszIpsecID = wcschr(pszNFADistinguishedName, L'{');

    if (!pszIpsecID) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    wGUIDFromString(
        pszIpsecID,
        &NFAIdentifier
        );

    dwError = DirGetNFAObject(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  NFAIdentifier,
                  &pIpsecNFAObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyReferences(
                  &(pIpsecNFAObject->pszIpsecOwnersReference),
                  1,
                  &ppszIpsecPolicyReferences,
                  &dwNumReferences
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *pppszIpsecPolicyReferences = ppszIpsecPolicyReferences;
    *pdwNumReferences = dwNumReferences;

cleanup:

    if (pIpsecNFAObject) {
        FreeIpsecNFAObject(pIpsecNFAObject);
    }

    return (dwError);

error:

    *pppszIpsecPolicyReferences = NULL;
    *pdwNumReferences = 0;

    goto cleanup;
}


DWORD
DirGetNFAReferencesForFilter(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID FilterIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_OBJECT pIpsecFilterObject = NULL;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;


    dwError = DirGetFilterObject(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  FilterIdentifier,
                  &pIpsecFilterObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyReferences(
                  pIpsecFilterObject->ppszIpsecNFAReferences,
                  pIpsecFilterObject->dwNFACount,
                  &ppszIpsecNFAReferences,
                  &dwNumReferences
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *pppszIpsecNFAReferences = ppszIpsecNFAReferences;
    *pdwNumReferences = dwNumReferences;

cleanup:

    if (pIpsecFilterObject) {
        FreeIpsecFilterObject(pIpsecFilterObject);
    }

    return (dwError);

error:

    *pppszIpsecNFAReferences = NULL;
    *pdwNumReferences = 0;

    goto cleanup;
}


DWORD
DirUpdateNFA(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecNFAReference,
    DWORD dwDataType
    )
{
    DWORD dwError = 0;
    DWORD dwNumAttributes = 1;
    DWORD i = 0;
    LDAPModW ** ppLDAPModW = NULL;
    LDAPModW * pLDAPModW = NULL;
    WCHAR Buffer[64];
    DWORD dwIpsecDataType = dwDataType;


    Buffer[0] = L'\0';

    ppLDAPModW = (LDAPModW **) AllocPolMem(
                                   (dwNumAttributes+1) * sizeof(LDAPModW*)
                                   );
    if (!ppLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pLDAPModW = (LDAPModW *) AllocPolMem(
                                 dwNumAttributes * sizeof(LDAPModW)
                                 );
    if (!pLDAPModW) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppLDAPModW[i] = pLDAPModW + i;

    dwError = AllocatePolString(
                  L"ipsecDataType",
                  &(pLDAPModW +i)->mod_type
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    _itow( dwIpsecDataType, Buffer, 10 );

    dwError = AllocateLDAPStringValue(
                  Buffer,
                  (PLDAPOBJECT *)&(pLDAPModW +i)->mod_values
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (pLDAPModW + i)->mod_op |= LDAP_MOD_REPLACE;

    dwError = LdapModifyS(
                  hLdapBindHandle,
                  pszIpsecNFAReference,
                  ppLDAPModW
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (ppLDAPModW) {
        FreeLDAPModWs(
            ppLDAPModW
            );
    }

    return(dwError);
}


DWORD
DirGetNFAReferencesForNegPol(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID NegPolIdentifier,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject = NULL;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;


    dwError = DirGetNegPolObject(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  NegPolIdentifier,
                  &pIpsecNegPolObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyReferences(
                  pIpsecNegPolObject->ppszIpsecNFAReferences,
                  pIpsecNegPolObject->dwNFACount,
                  &ppszIpsecNFAReferences,
                  &dwNumReferences
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *pppszIpsecNFAReferences = ppszIpsecNFAReferences;
    *pdwNumReferences = dwNumReferences;

cleanup:

    if (pIpsecNegPolObject) {
        FreeIpsecNegPolObject(pIpsecNegPolObject);
    }

    return (dwError);

error:

    *pppszIpsecNFAReferences = NULL;
    *pdwNumReferences = 0;

    goto cleanup;
}


DWORD
CopyReferences(
    LPWSTR * ppszIpsecReferences,
    DWORD dwNumReferences,
    LPWSTR ** pppszNewIpsecReferences,
    PDWORD pdwNumNewReferences
    )
{
    DWORD dwError = 0;
    LPWSTR * ppszNewIpsecReferences = NULL;
    DWORD i = 0;
    LPWSTR pszTemp = NULL;
    LPWSTR pszString = NULL;


    if (!dwNumReferences || !ppszIpsecReferences) {
        *pppszNewIpsecReferences = NULL;
        *pdwNumNewReferences = 0;
        return (dwError);
    }

    ppszNewIpsecReferences = (LPWSTR *) AllocPolMem(
                             sizeof(LPWSTR) * dwNumReferences
                             );
    if (!ppszNewIpsecReferences) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwNumReferences; i++) {

        pszTemp = *(ppszIpsecReferences + i);

        pszString = AllocPolStr(pszTemp);

        if (!pszString) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        *(ppszNewIpsecReferences + i) = pszString;

    }

    *pppszNewIpsecReferences = ppszNewIpsecReferences;
    *pdwNumNewReferences = dwNumReferences;

    return (dwError);

error:

    if (ppszNewIpsecReferences) {
        FreeNFAReferences(
            ppszNewIpsecReferences,
            i
            );
    }

    *pppszNewIpsecReferences = NULL;
    *pdwNumNewReferences = 0;

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\safestr.c ===
/*

Copyright (c) 2002, Microsoft Corporation.  All rights reserved.


Module Name:

    safestr.c

Abstract:

    Safe, secure string handling routines.

Authors and History:
    23 Jan 2002 : RaymondS added:
                  SecStrCpyW, SecStrCatW
    
Environment:

    User Level: Win32

--*/

#include "precomp.h"

wchar_t * SecStrCpyW(
    wchar_t * strDest,          // Destination
    const wchar_t * strSource,  // Source
    SIZE_T destSize             // Total size of Destination in characters.
    )
{
    strDest[destSize-1] = L'\0';    
    return wcsncpy(strDest, strSource, destSize-1);
}


wchar_t * SecStrCatW(
    wchar_t * strDest,          // Destination
    const wchar_t * strSource,  // Source
    SIZE_T destSize             // Total size of Destination in characters.
    )
{
    SSIZE_T spaceLeft = 0;

    spaceLeft = destSize - wcslen(strDest);
    if (spaceLeft > 0) {
        strDest[destSize-1] = L'\0';    
        return wcsncat(strDest, strSource, spaceLeft-1);
    }
    else {
        return NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\update-r.c ===
#include "precomp.h"


DWORD
RegBackPropIncChangesForISAKMPToPolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_ISAKMP_OBJECT pIpsecISAKMPObject
    )
{
    DWORD dwError = 0;
    LPWSTR * ppszIpsecPolicyReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecPolicyReference = NULL;
    GUID PolicyIdentifier;
    BOOL bIsActive = FALSE;


    dwError = RegGetPolicyReferencesForISAKMP(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pIpsecISAKMPObject->pszDistinguishedName,
                  &ppszIpsecPolicyReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecPolicyReference = *(ppszIpsecPolicyReferences + i);

        dwError = RegUpdatePolicy(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      pszIpsecPolicyReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = RegGetGuidFromPolicyReference(
                      pszIpsecPolicyReference,
                      &PolicyIdentifier
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = IsRegPolicyCurrentlyActive(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      PolicyIdentifier,
                      &bIsActive
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        if (bIsActive) {
            dwError = PingPolicyAgentSvc(pszLocationName);
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }

    dwError = ERROR_SUCCESS;

error:

    if (ppszIpsecPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecPolicyReferences,
            dwNumReferences
            );
    }

    return (dwError);
}


DWORD
RegBackPropIncChangesForFilterToNFA(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_FILTER_OBJECT pIpsecFilterObject
    )
{
    DWORD dwError = 0;
    DWORD dwRootPathLen = 0;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecNFAReference = NULL;
    LPWSTR pszRelativeName = NULL;


    dwRootPathLen =  wcslen(pszIpsecRootContainer);

    dwError = RegGetNFAReferencesForFilter(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pIpsecFilterObject->pszDistinguishedName,
                  &ppszIpsecNFAReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecNFAReference = *(ppszIpsecNFAReferences + i);

        dwError = RegUpdateNFA(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      pszIpsecNFAReference
                      );
        if (dwError) {
            continue;
        }

    }

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecNFAReference = *(ppszIpsecNFAReferences + i);

        pszRelativeName = pszIpsecNFAReference + dwRootPathLen + 1;

        dwError = RegBackPropIncChangesForNFAToPolicy(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      pszLocationName,
                      pszRelativeName
                      );
        if (dwError) {
            continue;
        }

    }

    dwError = ERROR_SUCCESS;

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            dwNumReferences
            );
    }

    return (dwError);
}

    
DWORD
RegBackPropIncChangesForNegPolToNFA(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    PIPSEC_NEGPOL_OBJECT pIpsecNegPolObject
    )
{
    DWORD dwError = 0;
    DWORD dwRootPathLen = 0;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecNFAReference = NULL;
    LPWSTR pszRelativeName = NULL;


    dwRootPathLen =  wcslen(pszIpsecRootContainer);

    dwError = RegGetNFAReferencesForNegPol(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pIpsecNegPolObject->pszDistinguishedName,
                  &ppszIpsecNFAReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecNFAReference = *(ppszIpsecNFAReferences + i);

        dwError = RegUpdateNFA(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      pszIpsecNFAReference
                      );
        if (dwError) {
            continue;
        }

    }

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecNFAReference = *(ppszIpsecNFAReferences + i);

        pszRelativeName = pszIpsecNFAReference + dwRootPathLen + 1;

        dwError = RegBackPropIncChangesForNFAToPolicy(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      pszLocationName,
                      pszRelativeName
                      );
        if (dwError) {
            continue;
        }

    }

    dwError = ERROR_SUCCESS;

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            dwNumReferences
            );
    }

    return (dwError);
}


DWORD
RegBackPropIncChangesForNFAToPolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszLocationName,
    LPWSTR pszNFADistinguishedName
    )
{
    DWORD dwError = 0;
    LPWSTR * ppszIpsecPolicyReferences = NULL;
    DWORD dwNumReferences = 0;
    DWORD i = 0;
    LPWSTR pszIpsecPolicyReference = NULL;
    GUID PolicyIdentifier;
    BOOL bIsActive = FALSE;


    dwError = RegGetPolicyReferencesForNFA(
                  hRegistryKey,
                  pszIpsecRootContainer,
                  pszNFADistinguishedName,
                  &ppszIpsecPolicyReferences,
                  &dwNumReferences
                  );

    for (i = 0; i < dwNumReferences; i++) {

        pszIpsecPolicyReference = *(ppszIpsecPolicyReferences + i);

        dwError = RegUpdatePolicy(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      pszIpsecPolicyReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = RegGetGuidFromPolicyReference(
                      pszIpsecPolicyReference,
                      &PolicyIdentifier
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = IsRegPolicyCurrentlyActive(
                      hRegistryKey,
                      pszIpsecRootContainer,
                      PolicyIdentifier,
                      &bIsActive
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        if (bIsActive) {
            dwError = PingPolicyAgentSvc(pszLocationName);
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }

    dwError = ERROR_SUCCESS;

error:

    if (ppszIpsecPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecPolicyReferences,
            dwNumReferences
            );
    }

    return (dwError);
}


DWORD
RegGetPolicyReferencesForISAKMP(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszISAKMPDistinguishedName,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    LPWSTR pszIpsecPolicyReference = NULL;
    DWORD dwSize = 0;
    LPWSTR pszTemp = NULL;
    DWORD dwCount = 0;
    LPWSTR * ppszIpsecPolicyReferences = NULL;
    DWORD i = 0;
    LPWSTR pszString = NULL;


    dwError = RegOpenKeyExW(
                  hRegistryKey,
                  pszISAKMPDistinguishedName,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"ipsecOwnersReference",
                  REG_MULTI_SZ,
                  (LPBYTE *)&pszIpsecPolicyReference,
                  &dwSize
                  );

    if (!dwError) {

        pszTemp = pszIpsecPolicyReference;

        while (*pszTemp != L'\0') {
            pszTemp += wcslen(pszTemp) + 1;
            dwCount++;
        }

        ppszIpsecPolicyReferences = (LPWSTR *) AllocPolMem(
                                   sizeof(LPWSTR)*dwCount
                                   );
        if (!ppszIpsecPolicyReferences) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pszTemp = pszIpsecPolicyReference;

        for (i = 0; i < dwCount; i++) {

            pszString = AllocPolStr(pszTemp);
            if (!pszString) {
                dwError = ERROR_OUTOFMEMORY;
                BAIL_ON_WIN32_ERROR(dwError);
            }

            *(ppszIpsecPolicyReferences + i) = pszString;

            pszTemp += wcslen(pszTemp) + 1;

        }

    }

    dwError = ERROR_SUCCESS;

    *pppszIpsecPolicyReferences = ppszIpsecPolicyReferences;
    *pdwNumReferences = dwCount;

cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pszIpsecPolicyReference) {
        FreePolStr(pszIpsecPolicyReference);
    }

    return (dwError);

error:

    *pppszIpsecPolicyReferences = NULL;
    *pdwNumReferences = 0;

    if (ppszIpsecPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecPolicyReferences,
            i
            );
    }

    goto cleanup;
}


DWORD
RegUpdatePolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecPolicyReference
    )
{
    DWORD dwError = 0;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    time_t PresentTime;
    DWORD dwWhenChanged = 0;


    dwRootPathLen = wcslen(pszIpsecRootContainer);
    pszRelativeName = pszIpsecPolicyReference + dwRootPathLen + 1;

    dwError = RegOpenKeyExW(
                  hRegistryKey,
                  pszRelativeName,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"whenChanged",
                  NULL,
                  &dwType,
                  (LPBYTE)&dwWhenChanged,
                  &dwSize
                  );
    if (dwError) {
        time(&PresentTime);
        dwWhenChanged = (DWORD) PresentTime;
    }
    else {
        dwWhenChanged++;
    }

    dwError = RegSetValueExW(
                  hRegKey,
                  L"whenChanged",
                  0,
                  REG_DWORD,
                  (LPBYTE)&dwWhenChanged,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return (dwError);
}


DWORD
RegGetGuidFromPolicyReference(
    LPWSTR pszIpsecPolicyReference,
    GUID * pPolicyIdentifier
    )
{
    DWORD dwError = 0;
    LPWSTR pszGuid = NULL;


    memset(pPolicyIdentifier, 0, sizeof(GUID));

    if (pszIpsecPolicyReference) {

        pszGuid = wcschr(pszIpsecPolicyReference, L'{');
        if (!pszGuid) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        wGUIDFromString(pszGuid, pPolicyIdentifier);

    }

error:

    return(dwError);
}


DWORD
RegGetPolicyReferencesForNFA(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszNFADistinguishedName,
    LPWSTR ** pppszIpsecPolicyReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    LPWSTR pszIpsecPolicyReference = NULL;
    DWORD dwSize = 0;
    LPWSTR pszTemp = NULL;
    DWORD dwCount = 0;
    LPWSTR * ppszIpsecPolicyReferences = NULL;
    DWORD i = 0;
    LPWSTR pszString = NULL;


    dwError = RegOpenKeyExW(
                  hRegistryKey,
                  pszNFADistinguishedName,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"ipsecOwnersReference",
                  REG_MULTI_SZ,
                  (LPBYTE *)&pszIpsecPolicyReference,
                  &dwSize
                  );

    if (!dwError) {

        pszTemp = pszIpsecPolicyReference;

        while (*pszTemp != L'\0') {
            pszTemp += wcslen(pszTemp) + 1;
            dwCount++;
        }

        ppszIpsecPolicyReferences = (LPWSTR *) AllocPolMem(
                                   sizeof(LPWSTR)*dwCount
                                   );
        if (!ppszIpsecPolicyReferences) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pszTemp = pszIpsecPolicyReference;

        for (i = 0; i < dwCount; i++) {

            pszString = AllocPolStr(pszTemp);
            if (!pszString) {
                dwError = ERROR_OUTOFMEMORY;
                BAIL_ON_WIN32_ERROR(dwError);
            }

            *(ppszIpsecPolicyReferences + i) = pszString;

            pszTemp += wcslen(pszTemp) + 1;

        }

    }

    dwError = ERROR_SUCCESS;

    *pppszIpsecPolicyReferences = ppszIpsecPolicyReferences;
    *pdwNumReferences = dwCount;

cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pszIpsecPolicyReference) {
        FreePolStr(pszIpsecPolicyReference);
    }

    return (dwError);

error:

    *pppszIpsecPolicyReferences = NULL;
    *pdwNumReferences = 0;

    if (ppszIpsecPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecPolicyReferences,
            i
            );
    }

    goto cleanup;
}


DWORD
RegGetNFAReferencesForFilter(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszFilterDistinguishedName,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    LPWSTR pszIpsecNFAReference = NULL;
    DWORD dwSize = 0;
    LPWSTR pszTemp = NULL;
    DWORD dwCount = 0;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD i = 0;
    LPWSTR pszString = NULL;


    dwError = RegOpenKeyExW(
                  hRegistryKey,
                  pszFilterDistinguishedName,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"ipsecOwnersReference",
                  REG_MULTI_SZ,
                  (LPBYTE *)&pszIpsecNFAReference,
                  &dwSize
                  );

    if (!dwError) {

        pszTemp = pszIpsecNFAReference;

        while (*pszTemp != L'\0') {
            pszTemp += wcslen(pszTemp) + 1;
            dwCount++;
        }

        ppszIpsecNFAReferences = (LPWSTR *) AllocPolMem(
                                   sizeof(LPWSTR)*dwCount
                                   );
        if (!ppszIpsecNFAReferences) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pszTemp = pszIpsecNFAReference;

        for (i = 0; i < dwCount; i++) {

            pszString = AllocPolStr(pszTemp);
            if (!pszString) {
                dwError = ERROR_OUTOFMEMORY;
                BAIL_ON_WIN32_ERROR(dwError);
            }

            *(ppszIpsecNFAReferences + i) = pszString;

            pszTemp += wcslen(pszTemp) + 1;

        }

    }

    dwError = ERROR_SUCCESS;

    *pppszIpsecNFAReferences = ppszIpsecNFAReferences;
    *pdwNumReferences = dwCount;

cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pszIpsecNFAReference) {
        FreePolStr(pszIpsecNFAReference);
    }

    return (dwError);

error:

    *pppszIpsecNFAReferences = NULL;
    *pdwNumReferences = 0;

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            i
            );
    }

    goto cleanup;
}


DWORD
RegUpdateNFA(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecNFAReference
    )
{
    DWORD dwError = 0;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    HKEY hRegKey = NULL;
    DWORD dwType = 0;
    DWORD dwSize = 0;
    time_t PresentTime;
    DWORD dwWhenChanged = 0;


    dwRootPathLen = wcslen(pszIpsecRootContainer);
    pszRelativeName = pszIpsecNFAReference + dwRootPathLen + 1;

    dwError = RegOpenKeyExW(
                  hRegistryKey,
                  pszRelativeName,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwType = REG_DWORD;
    dwSize = sizeof(DWORD);
    dwError = RegQueryValueExW(
                  hRegKey,
                  L"whenChanged",
                  NULL,
                  &dwType,
                  (LPBYTE)&dwWhenChanged,
                  &dwSize
                  );
    if (dwError) {
        time(&PresentTime);
        dwWhenChanged = (DWORD) PresentTime;
    }
    else {
        dwWhenChanged++;
    }

    dwError = RegSetValueExW(
                  hRegKey,
                  L"whenChanged",
                  0,
                  REG_DWORD,
                  (LPBYTE)&dwWhenChanged,
                  sizeof(DWORD)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return (dwError);
}


DWORD
RegGetNFAReferencesForNegPol(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszNegPolDistinguishedName,
    LPWSTR ** pppszIpsecNFAReferences,
    PDWORD pdwNumReferences
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    LPWSTR pszIpsecNFAReference = NULL;
    DWORD dwSize = 0;
    LPWSTR pszTemp = NULL;
    DWORD dwCount = 0;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD i = 0;
    LPWSTR pszString = NULL;


    dwError = RegOpenKeyExW(
                  hRegistryKey,
                  pszNegPolDistinguishedName,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"ipsecOwnersReference",
                  REG_MULTI_SZ,
                  (LPBYTE *)&pszIpsecNFAReference,
                  &dwSize
                  );

    if (!dwError) {

        pszTemp = pszIpsecNFAReference;

        while (*pszTemp != L'\0') {
            pszTemp += wcslen(pszTemp) + 1;
            dwCount++;
        }

        ppszIpsecNFAReferences = (LPWSTR *) AllocPolMem(
                                   sizeof(LPWSTR)*dwCount
                                   );
        if (!ppszIpsecNFAReferences) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        pszTemp = pszIpsecNFAReference;

        for (i = 0; i < dwCount; i++) {

            pszString = AllocPolStr(pszTemp);
            if (!pszString) {
                dwError = ERROR_OUTOFMEMORY;
                BAIL_ON_WIN32_ERROR(dwError);
            }

            *(ppszIpsecNFAReferences + i) = pszString;

            pszTemp += wcslen(pszTemp) + 1;

        }

    }

    dwError = ERROR_SUCCESS;

    *pppszIpsecNFAReferences = ppszIpsecNFAReferences;
    *pdwNumReferences = dwCount;

cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pszIpsecNFAReference) {
        FreePolStr(pszIpsecNFAReference);
    }

    return (dwError);

error:

    *pppszIpsecNFAReferences = NULL;
    *pdwNumReferences = 0;

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            i
            );
    }

    goto cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\validate.h ===
DWORD
ValidateISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    );


DWORD
ValidateNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    );


BOOL
IsClearOnly(
    GUID gNegPolAction
    );


BOOL
IsBlocking(
    GUID gNegPolAction
    );


DWORD
ValidateISAKMPDataDeletion(
    HANDLE hPolicyStore,
    GUID ISAKMPIdentifier
    );


DWORD
ValidateNegPolDataDeletion(
    HANDLE hPolicyStore,
    GUID NegPolIdentifier
    );


DWORD
ValidateFilterDataDeletion(
    HANDLE hPolicyStore,
    GUID FilterIdentifier
    );


DWORD
ValidatePolicyDataDeletion(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );


DWORD
ValidatePolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );


DWORD
ValidateNFAData(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    );


DWORD
VerifyPolicyDataExistence(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier
    );


DWORD
RegGetNFAReferencesForPolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecRelPolicyName,
    LPWSTR ** pppszIpsecNFANames,
    PDWORD pdwNumNFANames
    );


DWORD
RegVerifyPolicyDataExistence(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyGUID
    );


DWORD
DirVerifyPolicyDataExistence(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyGUID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\client\bind.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    bind.c

Abstract:

    Contains the RPC bind and un-bind routines.

Author:

    abhisheV    21-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


handle_t
TRANSPORTFILTER_HANDLE_bind(
    TRANSPORTFILTER_HANDLE hFilter,
    STRING_HANDLE lpStr
    )
{
    RPC_STATUS RpcStatus = 0;
    LPWSTR     pszStrBinding = NULL;
    handle_t   hBinding = NULL;

    if (!lpStr || !*lpStr) {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncalrpc",
                        0, 
                        L"ipsec",
                        gpszStrBindingOptions,
                        &pszStrBinding
                        );
    }
    else {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncacn_np",
                        lpStr,
                        L"\\pipe\\ipsec",
                        gpszStrBindingOptions,
                        &pszStrBinding
                        );
    }

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    RpcStatus = RpcBindingFromStringBindingW(
                    pszStrBinding,
                    &hBinding
                    );

    RpcStringFreeW(&pszStrBinding);

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    return (hBinding);
}


VOID
TRANSPORTFILTER_HANDLE_unbind(
    TRANSPORTFILTER_HANDLE hFilter,
    handle_t hBinding
    )
{
    RPC_STATUS RpcStatus = 0;

    RpcStatus = RpcBindingFree(&hBinding);

    ASSERT(RpcStatus == RPC_S_OK);

    return;
}


handle_t
STRING_HANDLE_bind(
    STRING_HANDLE lpStr
    )
{
    RPC_STATUS RpcStatus = 0;
    LPWSTR     pszStringBinding = NULL;
    handle_t   hBinding = NULL;
    LPWSTR pszServerPrincipalName = NULL;


    if (!lpStr || !*lpStr) {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncalrpc",
                        0,
                        NULL,             // Null for dynamic endpoint
                        gpszStrBindingOptions,
                        &pszStringBinding
                        );
    }
    else {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncacn_np",
                        lpStr,
                        NULL,           // Null for dynamic endpoint
                        gpszStrBindingOptions,
                        &pszStringBinding
                        );
    }

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    RpcStatus = RpcBindingFromStringBindingW(
                    pszStringBinding,
                    &hBinding
                    );

    RpcStringFreeW(&pszStringBinding);

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    RpcStatus = RpcEpResolveBinding(
                   hBinding,
                   winipsec_ClientIfHandle
                   );
    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    RpcStatus = RpcBindingSetOption(
                    hBinding,
                    RPC_C_OPT_UNIQUE_BINDING,
                    (ULONG_PTR) 1
                    );

    if (RpcStatus != RPC_S_OK) {
        STRING_HANDLE_unbind(lpStr, hBinding);
        return NULL;
    }

    RpcStatus = RpcMgmtInqServerPrincName(
                    hBinding,
                    RPC_C_AUTHN_GSS_NEGOTIATE,
                    &pszServerPrincipalName
                    );

    if (RpcStatus != RPC_S_OK) {
        STRING_HANDLE_unbind(lpStr, hBinding);
        RpcRaiseException(RpcStatus);
    }

    if (!lpStr || !*lpStr) {
        RpcStatus = RpcBindingSetAuthInfoW(
                        hBinding,
                        pszServerPrincipalName,
                        RPC_C_PROTECT_LEVEL_PKT_PRIVACY,
                        RPC_C_AUTHN_WINNT,
                        NULL,
                        RPC_C_AUTHZ_NONE
                        );
    }
    else {
        RpcStatus = RpcBindingSetAuthInfoW(
                        hBinding,
                        pszServerPrincipalName,
                        RPC_C_PROTECT_LEVEL_PKT_PRIVACY,
                        RPC_C_AUTHN_GSS_NEGOTIATE,
                        NULL,
                        RPC_C_AUTHZ_NONE
                        );
    }

    if (pszServerPrincipalName) {
        RpcStringFree(&pszServerPrincipalName);
    }

    if (RpcStatus != RPC_S_OK) {
        STRING_HANDLE_unbind(lpStr, hBinding);
        return NULL;
    }

    ASSERT(RpcStatus == RPC_S_OK);

    return (hBinding);
}


VOID
STRING_HANDLE_unbind(
    STRING_HANDLE lpStr,
    handle_t      hBinding
    )
{
    RPC_STATUS RpcStatus = 0;

    RpcStatus = RpcBindingFree(&hBinding);

    ASSERT(RpcStatus == RPC_S_OK);

    return;
}


handle_t
MMFILTER_HANDLE_bind(
    MMFILTER_HANDLE hFilter,
    STRING_HANDLE lpStr
    )
{
    RPC_STATUS RpcStatus = 0;
    LPWSTR     pszStrBinding = NULL;
    handle_t   hBinding = NULL;

    if (!lpStr || !*lpStr) {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncalrpc",
                        0, 
                        L"ipsec",
                        gpszStrBindingOptions,
                        &pszStrBinding
                        );
    }
    else {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncacn_np",
                        lpStr,
                        L"\\pipe\\ipsec",
                        gpszStrBindingOptions,
                        &pszStrBinding
                        );
    }

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    RpcStatus = RpcBindingFromStringBindingW(
                    pszStrBinding,
                    &hBinding
                    );

    RpcStringFreeW(&pszStrBinding);

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    return (hBinding);
}


VOID
MMFILTER_HANDLE_unbind(
    MMFILTER_HANDLE hFilter,
    handle_t hBinding
    )
{
    RPC_STATUS RpcStatus = 0;

    RpcStatus = RpcBindingFree(&hBinding);

    ASSERT(RpcStatus == RPC_S_OK);

    return;
}


handle_t
IKENEGOTIATION_HANDLE_bind(
    IKENEGOTIATION_HANDLE hIKENegotiation,
    STRING_HANDLE lpStr
    )
{
    RPC_STATUS RpcStatus = 0;
    LPWSTR     pszStrBinding = NULL;
    handle_t   hBinding = NULL;

    if (!lpStr || !*lpStr) {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncalrpc",
                        0, 
                        L"ipsec",
                        gpszStrBindingOptions,
                        &pszStrBinding
                        );
    }
    else {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncacn_np",
                        lpStr,
                        L"\\pipe\\ipsec",
                        gpszStrBindingOptions,
                        &pszStrBinding
                        );
    }

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    RpcStatus = RpcBindingFromStringBindingW(
                    pszStrBinding,
                    &hBinding
                    );

    RpcStringFreeW(&pszStrBinding);

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    return (hBinding);
}


VOID
IKENEGOTIATION_HANDLE_unbind(
    IKENEGOTIATION_HANDLE hIKENegotiation,
    handle_t hBinding
    )
{
    RPC_STATUS RpcStatus = 0;

    RpcStatus = RpcBindingFree(&hBinding);

    ASSERT(RpcStatus == RPC_S_OK);

    return;
}


handle_t
IKENOTIFY_HANDLE_bind(
    IKENOTIFY_HANDLE hIKENegotiation,
    STRING_HANDLE lpStr
    )
{
    RPC_STATUS RpcStatus = 0;
    LPWSTR     pszStrBinding = NULL;
    handle_t   hBinding = NULL;

    if (!lpStr || !*lpStr) {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncalrpc",
                        0, 
                        L"ipsec",
                        gpszStrBindingOptions,
                        &pszStrBinding
                        );
    }
    else {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncacn_np",
                        lpStr,
                        L"\\pipe\\ipsec",
                        gpszStrBindingOptions,
                        &pszStrBinding
                        );
    }

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    RpcStatus = RpcBindingFromStringBindingW(
                    pszStrBinding,
                    &hBinding
                    );

    RpcStringFreeW(&pszStrBinding);

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    return (hBinding);
}


VOID
IKENOTIFY_HANDLE_unbind(
    IKENOTIFY_HANDLE hIKENegotiation,
    handle_t hBinding
    )
{
    RPC_STATUS RpcStatus = 0;

    RpcStatus = RpcBindingFree(&hBinding);

    ASSERT(RpcStatus == RPC_S_OK);

    return;
}


handle_t
TUNNELFILTER_HANDLE_bind(
    TUNNELFILTER_HANDLE hFilter,
    STRING_HANDLE lpStr
    )
{
    RPC_STATUS RpcStatus = 0;
    LPWSTR     pszStrBinding = NULL;
    handle_t   hBinding = NULL;

    if (!lpStr || !*lpStr) {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncalrpc",
                        0, 
                        L"ipsec",
                        gpszStrBindingOptions,
                        &pszStrBinding
                        );
    }
    else {
        RpcStatus = RpcStringBindingComposeW(
                        0,
                        L"ncacn_np",
                        lpStr,
                        L"\\pipe\\ipsec",
                        gpszStrBindingOptions,
                        &pszStrBinding
                        );
    }

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    RpcStatus = RpcBindingFromStringBindingW(
                    pszStrBinding,
                    &hBinding
                    );

    RpcStringFreeW(&pszStrBinding);

    if (RpcStatus != RPC_S_OK) {
        return NULL;
    }

    return (hBinding);
}


VOID
TUNNELFILTER_HANDLE_unbind(
    TUNNELFILTER_HANDLE hFilter,
    handle_t hBinding
    )
{
    RPC_STATUS RpcStatus = 0;

    RpcStatus = RpcBindingFree(&hBinding);

    ASSERT(RpcStatus == RPC_S_OK);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\client\client.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    client.c

Abstract:

    Holds general client code.

Author:

    abhisheV    21-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


DWORD
TranslateExceptionCode(
    DWORD dwExceptionCode
    )
{
    return (dwExceptionCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\polstore\validate.c ===
#include "precomp.h"

extern LPWSTR PolicyDNAttributes[];

DWORD
ValidateISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData
    )
{
    DWORD dwError = 0;


    if (!pIpsecISAKMPData) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pIpsecISAKMPData->pSecurityMethods) ||
        !(pIpsecISAKMPData->dwNumISAKMPSecurityMethods)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    return (dwError);
}


DWORD
ValidateNegPolData(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData
    )
{
    DWORD dwError = 0;


    if (!pIpsecNegPolData) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!IsClearOnly(pIpsecNegPolData->NegPolAction) &&
        !IsBlocking(pIpsecNegPolData->NegPolAction)) {

        if (!(pIpsecNegPolData->pIpsecSecurityMethods) ||
            !(pIpsecNegPolData->dwSecurityMethodCount)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }

error:

    return (dwError);
}


BOOL
IsClearOnly(
    GUID gNegPolAction
    )
{
    if (!memcmp(
            &gNegPolAction,
            &(GUID_NEGOTIATION_ACTION_NO_IPSEC),
            sizeof(GUID))) {
        return (TRUE);
    }
    else {
        return (FALSE);
    }
}


BOOL
IsBlocking(
    GUID gNegPolAction
    )
{
    if (!memcmp(
            &gNegPolAction,
            &(GUID_NEGOTIATION_ACTION_BLOCK),
            sizeof(GUID))) {
        return (TRUE);
    }
    else {
        return (FALSE);
    }
}


DWORD
ValidateISAKMPDataDeletion(
    HANDLE hPolicyStore,
    GUID ISAKMPIdentifier
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    LPWSTR pszIpsecISAKMPReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    LPWSTR * ppszIpsecPolicyReferences = NULL;
    DWORD dwNumReferences = 0;


    pPolicyStore = (PIPSEC_POLICY_STORE) hPolicyStore;

    switch (pPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:

        dwError = ConvertGuidToISAKMPString(
                      ISAKMPIdentifier,
                      pPolicyStore->pszIpsecRootContainer,
                      &pszIpsecISAKMPReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwRootPathLen =  wcslen(pPolicyStore->pszIpsecRootContainer);
        pszRelativeName = pszIpsecISAKMPReference + dwRootPathLen + 1;

        dwError = RegGetPolicyReferencesForISAKMP(
                      pPolicyStore->hRegistryKey,
                      pPolicyStore->pszIpsecRootContainer,
                      pszRelativeName,
                      &ppszIpsecPolicyReferences,
                      &dwNumReferences
                      );
        break;

    case IPSEC_DIRECTORY_PROVIDER:

        dwError = DirGetPolicyReferencesForISAKMP(
                      pPolicyStore->hLdapBindHandle,
                      pPolicyStore->pszIpsecRootContainer,
                      ISAKMPIdentifier,
                      &ppszIpsecPolicyReferences,
                      &dwNumReferences
                      );
        break;

    default:

        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
        break;

    }

    if (!dwNumReferences) {
        dwError = ERROR_SUCCESS;
    }
    else {
        dwError = ERROR_INVALID_DATA;
    }

error:

    if (pszIpsecISAKMPReference) {
        FreePolStr(pszIpsecISAKMPReference);
    }

    if (ppszIpsecPolicyReferences) {
        FreeNFAReferences(
            ppszIpsecPolicyReferences,
            dwNumReferences
            );
    }

    return (dwError);
}


DWORD
ValidateNegPolDataDeletion(
    HANDLE hPolicyStore,
    GUID NegPolIdentifier
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    LPWSTR pszIpsecNegPolReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;


    pPolicyStore = (PIPSEC_POLICY_STORE) hPolicyStore;

    switch (pPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:

        dwError = ConvertGuidToNegPolString(
                      NegPolIdentifier,
                      pPolicyStore->pszIpsecRootContainer,
                      &pszIpsecNegPolReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwRootPathLen =  wcslen(pPolicyStore->pszIpsecRootContainer);
        pszRelativeName = pszIpsecNegPolReference + dwRootPathLen + 1;

        dwError = RegGetNFAReferencesForNegPol(
                      pPolicyStore->hRegistryKey,
                      pPolicyStore->pszIpsecRootContainer,
                      pszRelativeName,
                      &ppszIpsecNFAReferences,
                      &dwNumReferences
                      );
        break;

    case IPSEC_DIRECTORY_PROVIDER:

        dwError = DirGetNFAReferencesForNegPol(
                      pPolicyStore->hLdapBindHandle,
                      pPolicyStore->pszIpsecRootContainer,
                      NegPolIdentifier,
                      &ppszIpsecNFAReferences,
                      &dwNumReferences
                      );
        break;

    default:

        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
        break;

    }

    if (!dwNumReferences) {
        dwError = ERROR_SUCCESS;
    }
    else {
        dwError = ERROR_INVALID_DATA;
    }

error:

    if (pszIpsecNegPolReference) {
        FreePolStr(pszIpsecNegPolReference);
    }

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            dwNumReferences
            );
    }

    return (dwError);
}


DWORD
ValidateFilterDataDeletion(
    HANDLE hPolicyStore,
    GUID FilterIdentifier
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    LPWSTR pszIpsecFilterReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;


    pPolicyStore = (PIPSEC_POLICY_STORE) hPolicyStore;

    switch (pPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:

        dwError = ConvertGuidToFilterString(
                      FilterIdentifier,
                      pPolicyStore->pszIpsecRootContainer,
                      &pszIpsecFilterReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwRootPathLen =  wcslen(pPolicyStore->pszIpsecRootContainer);
        pszRelativeName = pszIpsecFilterReference + dwRootPathLen + 1;

        dwError = RegGetNFAReferencesForFilter(
                      pPolicyStore->hRegistryKey,
                      pPolicyStore->pszIpsecRootContainer,
                      pszRelativeName,
                      &ppszIpsecNFAReferences,
                      &dwNumReferences
                      );
        break;

    case IPSEC_DIRECTORY_PROVIDER:

        dwError = DirGetNFAReferencesForFilter(
                      pPolicyStore->hLdapBindHandle,
                      pPolicyStore->pszIpsecRootContainer,
                      FilterIdentifier,
                      &ppszIpsecNFAReferences,
                      &dwNumReferences
                      );
        break;

    default:

        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
        break;

    }

    if (!dwNumReferences) {
        dwError = ERROR_SUCCESS;
    }
    else {
        dwError = ERROR_INVALID_DATA;
    }

error:

    if (pszIpsecFilterReference) {
        FreePolStr(pszIpsecFilterReference);
    }

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            dwNumReferences
            );
    }

    return (dwError);
}


DWORD
ValidatePolicyDataDeletion(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;
    LPWSTR pszIpsecPolicyReference = NULL;
    DWORD dwRootPathLen = 0;
    LPWSTR pszRelativeName = NULL;
    LPWSTR * ppszIpsecNFAReferences = NULL;
    DWORD dwNumReferences = 0;


    pPolicyStore = (PIPSEC_POLICY_STORE) hPolicyStore;

    switch (pPolicyStore->dwProvider) {

    case IPSEC_REGISTRY_PROVIDER:

        dwError = ConvertGuidToPolicyString(
                      pIpsecPolicyData->PolicyIdentifier,
                      pPolicyStore->pszIpsecRootContainer,
                      &pszIpsecPolicyReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwRootPathLen =  wcslen(pPolicyStore->pszIpsecRootContainer);
        pszRelativeName = pszIpsecPolicyReference + dwRootPathLen + 1;

        dwError = RegGetNFAReferencesForPolicy(
                      pPolicyStore->hRegistryKey,
                      pPolicyStore->pszIpsecRootContainer,
                      pszRelativeName,
                      &ppszIpsecNFAReferences,
                      &dwNumReferences
                      );
        break;

    case IPSEC_DIRECTORY_PROVIDER:

        dwError = GenerateSpecificPolicyQuery(
                      pIpsecPolicyData->PolicyIdentifier,
                      &pszIpsecPolicyReference
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        dwError = DirGetNFADNsForPolicy(
                      pPolicyStore->hLdapBindHandle,
                      pPolicyStore->pszIpsecRootContainer,
                      pszIpsecPolicyReference,
                      &ppszIpsecNFAReferences,
                      &dwNumReferences
                      );
        break;

    default:

        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
        break;

    }

    if (!dwNumReferences) {
        dwError = ERROR_SUCCESS;
    }
    else {
        dwError = ERROR_INVALID_DATA;
    }

error:

    if (pszIpsecPolicyReference) {
        FreePolStr(pszIpsecPolicyReference);
    }

    if (ppszIpsecNFAReferences) {
        FreeNFAReferences(
            ppszIpsecNFAReferences,
            dwNumReferences
            );
    }

    return (dwError);
}


DWORD
ValidatePolicyData(
    HANDLE hPolicyStore,
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;


    dwError = IPSecGetISAKMPData(
                  hPolicyStore,
                  pIpsecPolicyData->ISAKMPIdentifier,
                  &pIpsecISAKMPData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecISAKMPData) {
        FreeIpsecISAKMPData(
            pIpsecISAKMPData
            );
    }

    return (dwError);
}


DWORD
ValidateNFAData(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    GUID gZeroGUID;


    memset(&gZeroGUID, 0, sizeof(GUID));

    if (memcmp(
            &gZeroGUID,
            &pIpsecNFAData->FilterIdentifier,
            sizeof(GUID))) {
        dwError = IPSecGetFilterData(
                      hPolicyStore,
                      pIpsecNFAData->FilterIdentifier, 
                      &pIpsecFilterData
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = IPSecGetNegPolData(
                  hPolicyStore,
                  pIpsecNFAData->NegPolIdentifier, 
                  &pIpsecNegPolData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPolicyDataExistence(
                  hPolicyStore,
                  PolicyIdentifier
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pIpsecFilterData) {
        FreeIpsecFilterData(
            pIpsecFilterData
            );
    }

    if (pIpsecNegPolData) {
        FreeIpsecNegPolData(
            pIpsecNegPolData
            );
    }

    return (dwError);
}


DWORD
VerifyPolicyDataExistence(
    HANDLE hPolicyStore,
    GUID PolicyIdentifier
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_STORE pPolicyStore = NULL;


    pPolicyStore = (PIPSEC_POLICY_STORE) hPolicyStore;

    switch (pPolicyStore->dwProvider) {

        case IPSEC_REGISTRY_PROVIDER:
            dwError = RegVerifyPolicyDataExistence(
                          pPolicyStore->hRegistryKey,
                          pPolicyStore->pszIpsecRootContainer,
                          PolicyIdentifier
                          );
            break;

        case IPSEC_DIRECTORY_PROVIDER:
            dwError = DirVerifyPolicyDataExistence(
                          pPolicyStore->hLdapBindHandle,
                          pPolicyStore->pszIpsecRootContainer,
                          PolicyIdentifier
                          );
            break;

        default:
            dwError = ERROR_INVALID_PARAMETER;
            break;

    }

    return (dwError);
}


DWORD
RegGetNFAReferencesForPolicy(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    LPWSTR pszIpsecRelPolicyName,
    LPWSTR ** pppszIpsecNFANames,
    PDWORD pdwNumNFANames
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = 0;
    LPWSTR pszIpsecNFAReference = NULL;
    DWORD dwSize = 0;
    LPWSTR pszTemp = NULL;
    DWORD dwCount = 0;
    LPWSTR * ppszIpsecNFANames = NULL;
    LPWSTR pszString = NULL;
    DWORD i = 0;


    dwError = RegOpenKeyExW(
                    hRegistryKey,
                    pszIpsecRelPolicyName,
                    0,
                    KEY_ALL_ACCESS,
                    &hRegKey
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                    hRegKey,
                    L"ipsecNFAReference",
                    REG_MULTI_SZ,
                    (LPBYTE *)&pszIpsecNFAReference,
                    &dwSize
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pszTemp = pszIpsecNFAReference;
    while (*pszTemp != L'\0') {

        pszTemp += wcslen(pszTemp) + 1;
        dwCount++;

    }

    if (!dwCount) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ppszIpsecNFANames =  (LPWSTR *)AllocPolMem(
                                sizeof(LPWSTR)*dwCount
                                );
    if (!ppszIpsecNFANames) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pszTemp = pszIpsecNFAReference;
    for (i = 0; i < dwCount; i++) {

        pszString = AllocPolStr(pszTemp);
        if (!pszString) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        *(ppszIpsecNFANames + i) = pszString;

        pszTemp += wcslen(pszTemp) + 1; //for the null terminator;

    }

    *pppszIpsecNFANames = ppszIpsecNFANames;
    *pdwNumNFANames = dwCount;

    dwError = ERROR_SUCCESS;

cleanup:

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    if (pszIpsecNFAReference) {
        FreePolStr(pszIpsecNFAReference);
    }

    return(dwError);

error:

    if (ppszIpsecNFANames) {
        FreeNFAReferences(
            ppszIpsecNFANames,
            dwCount
            );
    }

    *pppszIpsecNFANames = NULL;
    *pdwNumNFANames = 0;

    goto cleanup;
}


DWORD
RegVerifyPolicyDataExistence(
    HKEY hRegistryKey,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyGUID
    )
{
    DWORD dwError = 0;
    WCHAR szIpsecPolicyName[MAX_PATH];
    LPWSTR pszPolicyName = NULL;
    HKEY hRegKey = NULL;


    szIpsecPolicyName[0] = L'\0';
    wcscpy(szIpsecPolicyName, L"ipsecPolicy");

    dwError = UuidToString(&PolicyGUID, &pszPolicyName);
    BAIL_ON_WIN32_ERROR(dwError);

    wcscat(szIpsecPolicyName, L"{");
    wcscat(szIpsecPolicyName, pszPolicyName);
    wcscat(szIpsecPolicyName, L"}");

    dwError = RegOpenKeyExW(
                  hRegistryKey,
                  szIpsecPolicyName,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pszPolicyName) {
        RpcStringFree(&pszPolicyName);
    }

    if (hRegKey) {
        RegCloseKey(hRegKey);
    }

    return (dwError);
}


DWORD
DirVerifyPolicyDataExistence(
    HLDAP hLdapBindHandle,
    LPWSTR pszIpsecRootContainer,
    GUID PolicyGUID
    )
{
    DWORD dwError = 0;
    LPWSTR pszPolicyString = NULL;
    LDAPMessage * res = NULL;
    DWORD dwCount = 0;


    dwError = GenerateSpecificPolicyQuery(
                  PolicyGUID,
                  &pszPolicyString
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecRootContainer,
                  LDAP_SCOPE_ONELEVEL,
                  pszPolicyString,
                  PolicyDNAttributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwCount = LdapCountEntries(
                  hLdapBindHandle,
                  res
                  );
    if (!dwCount) {
        dwError = ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (pszPolicyString) {
        FreePolStr(pszPolicyString);
    }

    if (res) {
        LdapMsgFree(res);
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\client\globals.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    globals.c

Abstract:

    Holds global variable declarations.

Author:

    abhisheV    21-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


HANDLE ghInstance = NULL;

/*
Security=[Impersonation | Identification | Anonymous] [Dynamic | Static] [True | False]
         (where True | False corresponds to EffectiveOnly)
*/

LPWSTR gpszStrBindingOptions = L"Security=Impersonation Dynamic False";


const ULONG guFatalExceptions[] =
    {
    STATUS_ACCESS_VIOLATION,
    STATUS_POSSIBLE_DEADLOCK,
    STATUS_INSTRUCTION_MISALIGNMENT,
    STATUS_DATATYPE_MISALIGNMENT,
    STATUS_PRIVILEGED_INSTRUCTION,
    STATUS_ILLEGAL_INSTRUCTION,
    STATUS_BREAKPOINT,
    STATUS_STACK_OVERFLOW
    };


const int FATAL_EXCEPTIONS_ARRAY_SIZE =
    sizeof(guFatalExceptions) / sizeof(guFatalExceptions[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\client\init.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    init.c

Abstract:

    Holds initialization code for winipsec.dll.

Author:

    abhisheV    21-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


// This entry point is called on DLL initialization.
// The module handle is needed to load the resources.


BOOL
InitializeDll(
    IN PVOID    hmod,
    IN DWORD    dwReason,
    IN PCONTEXT pctx      OPTIONAL
    )
{
    DBG_UNREFERENCED_PARAMETER(pctx);

    switch (dwReason) {

    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls((HMODULE) hmod);
        ghInstance = hmod;

        break;

    case DLL_PROCESS_DETACH:

        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\client\client.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    client.h

Abstract:

    Holds client.c header information.

Author:

    abhisheV    21-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif


DWORD
TranslateExceptionCode(
    DWORD dwExceptionCode
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\client\externs.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    externs.h

Abstract:

    Holds externs for global variables.

Author:

    abhisheV    21-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


extern HANDLE ghInstance;

extern LPWSTR gpszStrBindingOptions;

extern const ULONG guFatalExceptions[];

extern const int FATAL_EXCEPTIONS_ARRAY_SIZE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\client\midluser.c ===
/*++

Copyright (c) 1991 Microsoft Corporation


Module Name:

    midluser.c

Abstract:

    This file contains common functions and utilities that the API
    DLLs can use in making remote calls.  This includes the
    MIDL_USER_ALLOCATE functions.

Author:

    danl    02/06/1991

Environment:

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


PVOID
MIDL_user_allocate(
    IN size_t NumBytes
    )
/*++

Routine Description:

    Allocates storage for RPC transactions. The RPC stubs will either call
    MIDL_user_allocate when it needs to un-marshall data into a buffer
    that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - the number of bytes to allocate.

Return Value:

    None.

--*/
{
    return (LocalAlloc(0,NumBytes));
}


VOID
MIDL_user_free(
    IN void * MemPointer
    )
/*++

Routine Description:

    Frees storage used in RPC transactions. The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - pointer to the memory block that is to be released.

Return Value:

    None.

--*/

{
    LocalFree(MemPointer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\client\spd_c_stub.c ===
#include "spd_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\client\utils.h ===
DWORD
SPDDestroyClientContextHandle(
    DWORD dwStatus,
    HANDLE hFilter
    );

int
RPC_ENTRY
I_RpcExceptionFilter(
    unsigned long uExceptionCode
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\client\precomp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    precomp.h

Abstract:

    Precompiled header for winipsec.dll.

Author:

    abhisheV    21-September-1999

Environment:

    User Level: Win32

Revision History:


--*/

#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntddrdr.h>

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <string.h>
#include <rpc.h>
#include <windows.h>
#include <winddiui.h>
#include <wininet.h>
#include "shlobj.h"
#include <tchar.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <dsrole.h>
#include <dsgetdc.h>
#include <wininet.h>
#include <activeds.h>
#include <ntdsapi.h>

#ifdef __cplusplus
}
#endif

#include <lmcons.h>
#include <lmapibuf.h>
#include "winsock2.h"
#include "winsock.h"

#include "spd_c.h"
#include "winipsec.h"
#include "externs.h"
#include "utils.h"
#include "client.h"
#include "ipsecshr.h"
#include "winperf.h"
#include "perfipsec.h"


#define BAIL_ON_WIN32_ERROR(dwError) \
    if (dwError) {                   \
        goto error;                  \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\client\utils.c ===
#include "precomp.h"

DWORD
SPDDestroyClientContextHandle(
    DWORD dwStatus,
    HANDLE hFilter
    )
{
    DWORD dwError = 0;


    switch (dwStatus) {

    case RPC_S_SERVER_UNAVAILABLE:
    case RPC_S_CALL_FAILED:
    case RPC_S_CALL_FAILED_DNE:
    case RPC_S_UNKNOWN_IF:

        RpcTryExcept {

            RpcSsDestroyClientContext(&hFilter);

        } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

            dwError = TranslateExceptionCode(RpcExceptionCode());
            BAIL_ON_WIN32_ERROR(dwError);

        } RpcEndExcept

        break;

    default:

        dwError = dwStatus;
        break;

    }

error:

    return (dwError);
}


int
RPC_ENTRY
I_RpcExceptionFilter(
    unsigned long uExceptionCode
    )
{
    int i = 0;


    for (i = 0; i < FATAL_EXCEPTIONS_ARRAY_SIZE; i ++) {

        if (uExceptionCode == guFatalExceptions[i]) {
            return EXCEPTION_CONTINUE_SEARCH;
        }

    }

    return EXCEPTION_EXECUTE_HANDLER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\idl\import.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    import.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "import.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    krishnaG    21-September-1999

Environment:

    User Level: Win32

Revision History:

    abhisheV    29-September-1999

--*/


#ifdef MIDL_PASS
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>

#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define LPDEVMODEW DWORD
#define PSECURITY_DESCRIPTOR DWORD
#define BOOL DWORD
#endif

#include <winipsec.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\idl\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#
# The following is where you put the name of your .idl file without
# the .idl extension:
#

!INCLUDE $(NTMAKEENV)\makefile.plt

CLIENT_ACF = spdcli.acf
SERVER_ACF = spdsrv.acf

IDL_NAME  = spd
IMPORT    = import

UNICODE=1

INCS  = -I. -I$(SDK_INC_PATH)  -I$(CRT_INC_PATH) -I$(OAK_INC_PATH) -I$(PROJECT_ROOT)\inc -I$(NET_INC_PATH)

CPP = -cpp_cmd "$(MIDL_CPP)" -DNO_STRICT $(MIDL_FLAGS)


CLIENT_TARGETS =   $(O)\$(IDL_NAME)_c.c  \
                   $(O)\$(IDL_NAME)_c.h


SERVER_TARGETS =   $(O)\$(IDL_NAME)_s.c  \
                   $(O)\$(IDL_NAME)_s.h


#
# Define Products and Dependencies
#

all:    $(CLIENT_TARGETS) $(SERVER_TARGETS) 
!IF "$(BUILDMSG)" != ""
    @ech ; $(BUILDMSG) ;
!ENDIF

clean: delete_source all

delete_source:
    erase $(CLIENT_TARGETS) $(SERVER_TARGETS)

#
# MIDL COMPILE
#

MIDL_OPTIMIZATION_NT5=-Oicf -no_format_opt -robust -error all -out .\$(O)

$(CLIENT_TARGETS) : $(IDL_NAME).idl $(CLIENT_ACF) 
    midl $(MIDL_OPTIMIZATION_NT5) -acf $(CLIENT_ACF) -server none -oldnames -ms_ext -c_ext $(CPP) $(INCS) $(IDL_NAME).idl -header $(IDL_NAME)_c.h

$(SERVER_TARGETS) : $(IDL_NAME).idl $(SERVER_ACF) 
    midl $(MIDL_OPTIMIZATION_NT5) -acf $(SERVER_ACF) -client none -oldnames -ms_ext -c_ext $(CPP) $(INCS) $(IDL_NAME).idl -header $(IDL_NAME)_s.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\ipsecprf\dataipsec.c ===
/*++ 

Copyright (c) 2002  Microsoft Corporation

Module Name:

    dataipsec.c

Abstract:

    a file containing the constant data structures used by the Performance
    Monitor data for the IPSec Extensible Objects.

    This file contains a set of constant data structures which are
    currently defined for the IPSec Extensible Objects.  

Created:

    Avnish Kumar Chhabra    07/03/2002

Revision History

--*/

//
//  Include Files
//

#include <windows.h>
#include <winperf.h>
#include "ipsecnm.h"
#include "dataipsec.h"
#include "perfipsec.h"



//
//  Constant structure initializations
//  defined in dataipsec.h
//


//
//  The _PERF_DATA_BLOCK structure is followed by NumObjectTypes of
//  data sections, one for each type of object measured.  Each object
//  type section begins with a _PERF_OBJECT_TYPE structure.
//


//
//  IPSec driver Perf Object and counters
//

IPSEC_DRIVER_DATA_DEFINITION gIPSecDriverDataDefinition = 
{
    {
    	// TotalByteLength.  
	    sizeof(IPSEC_DRIVER_DATA_DEFINITION) + ALIGN8(SIZEOF_IPSEC_TOTAL_DRIVER_DATA),

    	// DefinitionLength
	    sizeof(IPSEC_DRIVER_DATA_DEFINITION),

	    // HeaderLength
    	sizeof(PERF_OBJECT_TYPE),

	    // ObjectNameTitleIndex
    	IPSECOBJ ,

	    // ObjectNameTitle
    	0,

	    // ObjectHelpTitleIndex
	    IPSECOBJ ,

	    // ObjectHelpTitle
    	0,

	    // DetailLevel
	    PERF_DETAIL_NOVICE,

	    // NumCounters
	    (sizeof(IPSEC_DRIVER_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/ sizeof(PERF_COUNTER_DEFINITION),

	    // DefaultCounter. 
	    0,

	    // NumInstances.  
    	PERF_NO_INSTANCES,

	    // CodePage
    	0,

	    //PerfTime
	    {0,1},

	    //PerfFreq
	    {0,5}
    },

    CREATE_COUNTER( ACTIVESA,               -1,PERF_DETAIL_NOVICE,PERF_COUNTER_RAWCOUNT,sizeof(DWORD)) ,
    CREATE_COUNTER( OFFLOADEDSA,            -1,PERF_DETAIL_NOVICE,PERF_COUNTER_RAWCOUNT,sizeof(DWORD)) ,
    CREATE_COUNTER( PENDINGKEYOPS,           0,PERF_DETAIL_NOVICE,PERF_COUNTER_RAWCOUNT,sizeof(DWORD)) ,
    CREATE_COUNTER( REKEYNUM,               -2,PERF_DETAIL_NOVICE,PERF_COUNTER_RAWCOUNT,sizeof(DWORD)) ,
    CREATE_COUNTER( BADSPIPKTS,             -2,PERF_DETAIL_NOVICE,PERF_COUNTER_RAWCOUNT,sizeof(DWORD)) ,
    CREATE_COUNTER( PKTSNOTDECRYPTED,       -2,PERF_DETAIL_NOVICE,PERF_COUNTER_RAWCOUNT,sizeof(DWORD)) ,
    CREATE_COUNTER( PKTSNOTAUTHENTICATED,-2,PERF_DETAIL_NOVICE,PERF_COUNTER_RAWCOUNT,sizeof(DWORD)) ,
    CREATE_COUNTER( PKTSFAILEDREPLAY,       -2,PERF_DETAIL_NOVICE,PERF_COUNTER_RAWCOUNT,sizeof(DWORD)) ,
    CREATE_COUNTER( TPTBYTESSENT,           -6,PERF_DETAIL_NOVICE,PERF_COUNTER_LARGE_RAWCOUNT,sizeof(ULARGE_INTEGER)) ,
    CREATE_COUNTER( TPTBYTESRECV,           -6,PERF_DETAIL_NOVICE,PERF_COUNTER_LARGE_RAWCOUNT,sizeof(ULARGE_INTEGER)) ,
    CREATE_COUNTER( TUNBYTESSENT,           -6,PERF_DETAIL_NOVICE,PERF_COUNTER_LARGE_RAWCOUNT,sizeof(ULARGE_INTEGER)) ,
    CREATE_COUNTER( TUNBYTESRECV,           -6,PERF_DETAIL_NOVICE,PERF_COUNTER_LARGE_RAWCOUNT,sizeof(ULARGE_INTEGER)) ,
    CREATE_COUNTER( OFFLOADBYTESSENT,       -6,PERF_DETAIL_NOVICE,PERF_COUNTER_LARGE_RAWCOUNT,sizeof(ULARGE_INTEGER)) ,
    CREATE_COUNTER( OFFLOADBYTESRECV,       -6,PERF_DETAIL_NOVICE,PERF_COUNTER_LARGE_RAWCOUNT,sizeof(ULARGE_INTEGER)) 
};

//
// IKE Keying module Perf Object and counters
//


	
IKE_DATA_DEFINITION gIKEDataDefinition = 
{
    {
    	// TotalByteLength.  
	    sizeof(IKE_DATA_DEFINITION) + ALIGN8(SIZEOF_IPSEC_TOTAL_IKE_DATA),

    	// DefinitionLength
	    sizeof(IKE_DATA_DEFINITION),

    	// HeaderLength
    	sizeof(PERF_OBJECT_TYPE),

	    // ObjectNameTitleIndex
    	IKEOBJ ,

    	// ObjectNameTitle
    	0,

	    // ObjectHelpTitleIndex
	    IKEOBJ ,

    	// ObjectHelpTitle
    	0,

	    // DetailLevel
	    PERF_DETAIL_NOVICE,

    	// NumCounters
	    (sizeof(IKE_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/ sizeof(PERF_COUNTER_DEFINITION),

    	// DefaultCounter. 
	    0,

    	// NumInstances.  
    	PERF_NO_INSTANCES,

	    // CodePage
    	0,

    	//PerfTime
	    {0,1},

    	//PerfFreq
	    {0,5}
    },
    CREATE_COUNTER( ACQUIREHEAPSIZE,     0,PERF_DETAIL_NOVICE,PERF_COUNTER_RAWCOUNT,sizeof(DWORD)) ,
    CREATE_COUNTER( RECEIVEHEAPSIZE,     0,PERF_DETAIL_NOVICE,PERF_COUNTER_RAWCOUNT,sizeof(DWORD)) ,
    CREATE_COUNTER( NEGFAILURE,         -2,PERF_DETAIL_NOVICE,PERF_COUNTER_RAWCOUNT,sizeof(DWORD)) ,
    CREATE_COUNTER( AUTHFAILURE,        -2,PERF_DETAIL_NOVICE,PERF_COUNTER_RAWCOUNT,sizeof(DWORD)) ,
    CREATE_COUNTER( ISADBSIZE,          -1,PERF_DETAIL_NOVICE,PERF_COUNTER_RAWCOUNT,sizeof(DWORD)) ,
    CREATE_COUNTER( CONNLSIZE,          -1,PERF_DETAIL_NOVICE,PERF_COUNTER_RAWCOUNT,sizeof(DWORD)) ,
    CREATE_COUNTER( MMSA,               -2,PERF_DETAIL_NOVICE,PERF_COUNTER_RAWCOUNT,sizeof(DWORD)) ,
    CREATE_COUNTER( QMSA,               -3,PERF_DETAIL_NOVICE,PERF_COUNTER_RAWCOUNT,sizeof(DWORD)) ,
    CREATE_COUNTER( SOFTSA,             -3,PERF_DETAIL_NOVICE,PERF_COUNTER_RAWCOUNT,sizeof(DWORD))    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\client\winipsec.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    winipsec.c

Abstract:

    Contains IPSec WINAPI calls specific code.

Author:

    abhisheV    21-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


DWORD
SPDApiBufferAllocate(
    DWORD dwByteCount,
    LPVOID * ppBuffer
    )
{
    DWORD dwError = 0;

    if (ppBuffer == NULL) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppBuffer = NULL;
    *ppBuffer = MIDL_user_allocate(dwByteCount);

    if (*ppBuffer == NULL) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    else {
        memset((LPBYTE) *ppBuffer, 0, dwByteCount);
    }

error:

    return (dwError);
}


VOID
SPDApiBufferFree(
    LPVOID pBuffer
    )
{
    if (pBuffer) {
        MIDL_user_free(pBuffer);
    }
}


DWORD
AddTransportFilter(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PTRANSPORT_FILTER pTransportFilter,
    LPVOID pvReserved,
    PHANDLE phFilter
    )
{
    DWORD dwError = 0;
    TRANSPORT_FILTER_CONTAINER FilterContainer;
    PTRANSPORT_FILTER_CONTAINER pFilterContainer = &FilterContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!phFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (pTransportFilter && (pTransportFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        return (ERROR_INVALID_LEVEL);
    }

    dwError = ValidateTransportFilter(
                  pTransportFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pFilterContainer->dwNumFilters = 1;
    pFilterContainer->pTransportFilters = pTransportFilter;

    RpcTryExcept {

        dwError = RpcAddTransportFilter(
                      pServerName,
                      dwVersion,
                      dwFlags,
                      pFilterContainer,
                      phFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
DeleteTransportFilter(
    HANDLE hFilter
    )
{
    DWORD dwError = 0;


    if (!hFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcDeleteTransportFilter(
                      &hFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    if (dwError) {
        dwError = SPDDestroyClientContextHandle(
                      dwError,
                      hFilter
                      );
    }

    return (dwError);
}


DWORD
EnumTransportFilters(
    LPWSTR pServerName,
    DWORD dwVersion,
    PTRANSPORT_FILTER pTransportTemplateFilter,
    DWORD dwLevel,
    GUID gGenericFilterID,
    DWORD dwPreferredNumEntries,
    PTRANSPORT_FILTER * ppTransportFilters,
    LPDWORD pdwNumFilters,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    TRANSPORT_FILTER_CONTAINER FilterContainer;
    PTRANSPORT_FILTER_CONTAINER pFilterContainer = &FilterContainer;
    TRANSPORT_FILTER_CONTAINER TemplateFilterContainer;
    PTRANSPORT_FILTER_CONTAINER pTemplateFilterContainer = &TemplateFilterContainer;


    memset(pFilterContainer, 0, sizeof(TRANSPORT_FILTER_CONTAINER));


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (pTransportTemplateFilter) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!ppTransportFilters || !pdwNumFilters || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    switch (dwLevel) {

    case ENUM_GENERIC_FILTERS:
    case ENUM_SELECT_SPECIFIC_FILTERS:
    case ENUM_SPECIFIC_FILTERS:
        break;

    default:
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    pTemplateFilterContainer->dwNumFilters = 0;
    pTemplateFilterContainer->pTransportFilters = NULL;

    RpcTryExcept {

        dwError = RpcEnumTransportFilters(
                      pServerName,
                      dwVersion,
                      pTemplateFilterContainer,
                      dwLevel,
                      gGenericFilterID,
                      dwPreferredNumEntries,
                      &pFilterContainer,
                      pdwResumeHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppTransportFilters = pFilterContainer->pTransportFilters;
    *pdwNumFilters = pFilterContainer->dwNumFilters;

    return (dwError);

error:

    *ppTransportFilters = NULL;
    *pdwNumFilters = 0;

    return (dwError);
}


DWORD
SetTransportFilter(
    HANDLE hFilter,
    DWORD dwVersion,
    PTRANSPORT_FILTER pTransportFilter,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    TRANSPORT_FILTER_CONTAINER FilterContainer;
    PTRANSPORT_FILTER_CONTAINER pFilterContainer = &FilterContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!hFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (pTransportFilter && (pTransportFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        return (ERROR_INVALID_LEVEL);
    }

    dwError = ValidateTransportFilter(
                  pTransportFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pFilterContainer->dwNumFilters = 1;
    pFilterContainer->pTransportFilters = pTransportFilter;

    RpcTryExcept {

        dwError = RpcSetTransportFilter(
                      hFilter,
                      dwVersion,
                      pFilterContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
GetTransportFilter(
    HANDLE hFilter,
    DWORD dwVersion,
    PTRANSPORT_FILTER * ppTransportFilter,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    TRANSPORT_FILTER_CONTAINER FilterContainer;
    PTRANSPORT_FILTER_CONTAINER pFilterContainer = &FilterContainer;


    memset(pFilterContainer, 0, sizeof(TRANSPORT_FILTER_CONTAINER));

    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!hFilter || !ppTransportFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcGetTransportFilter(
                      hFilter,
                      dwVersion,
                      &pFilterContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept


    *ppTransportFilter = pFilterContainer->pTransportFilters;
    return (dwError);

error:

    *ppTransportFilter = NULL;
    return (dwError);
}


DWORD
AddQMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PIPSEC_QM_POLICY pQMPolicy,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    IPSEC_QM_POLICY_CONTAINER QMPolicyContainer;
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer = &QMPolicyContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    dwError = ValidateQMPolicy(
                  pQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pQMPolicyContainer->dwNumPolicies = 1;
    pQMPolicyContainer->pPolicies = pQMPolicy;

    RpcTryExcept {

        dwError = RpcAddQMPolicy(
                      pServerName,
                      dwVersion,
                      dwFlags,
                      pQMPolicyContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
DeleteQMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pszPolicyName || !*pszPolicyName) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    RpcTryExcept {

        dwError = RpcDeleteQMPolicy(
                      pServerName,
                      dwVersion,
                      pszPolicyName
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
EnumQMPolicies(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_QM_POLICY pQMTemplatePolicy,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PIPSEC_QM_POLICY * ppQMPolicies,
    LPDWORD pdwNumPolicies,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    IPSEC_QM_POLICY_CONTAINER QMPolicyContainer;
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer = &QMPolicyContainer;
    IPSEC_QM_POLICY_CONTAINER QMTempPolicyContainer;
    PIPSEC_QM_POLICY_CONTAINER pQMTempPolicyContainer = &QMTempPolicyContainer;


    memset(pQMPolicyContainer, 0, sizeof(IPSEC_QM_POLICY_CONTAINER));

    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (pQMTemplatePolicy) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!ppQMPolicies || !pdwNumPolicies || !pdwResumeHandle) {
        //
        // Do not bail to error from here.
        //
        return (ERROR_INVALID_PARAMETER);
    }

    pQMTempPolicyContainer->dwNumPolicies = 0;
    pQMTempPolicyContainer->pPolicies = NULL;

    RpcTryExcept {

        dwError = RpcEnumQMPolicies(
                      pServerName,
                      dwVersion,
                      pQMTempPolicyContainer,
                      dwFlags,
                      dwPreferredNumEntries,
                      &pQMPolicyContainer,
                      pdwResumeHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppQMPolicies = pQMPolicyContainer->pPolicies;
    *pdwNumPolicies = pQMPolicyContainer->dwNumPolicies;

    return (dwError);

error:

    *ppQMPolicies = NULL;
    *pdwNumPolicies = 0;

    return (dwError);
}


DWORD
SetQMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    PIPSEC_QM_POLICY pQMPolicy,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    IPSEC_QM_POLICY_CONTAINER QMPolicyContainer;
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer = &QMPolicyContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pszPolicyName || !*pszPolicyName) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateQMPolicy(
                  pQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pQMPolicyContainer->dwNumPolicies = 1;
    pQMPolicyContainer->pPolicies = pQMPolicy;

    RpcTryExcept {

        dwError = RpcSetQMPolicy(
                      pServerName,
                      dwVersion,
                      pszPolicyName,
                      pQMPolicyContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
GetQMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    DWORD dwFlags,
    PIPSEC_QM_POLICY * ppQMPolicy,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    IPSEC_QM_POLICY_CONTAINER  QMPolicyContainer;
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer = &QMPolicyContainer;


    memset(pQMPolicyContainer, 0, sizeof(IPSEC_QM_POLICY_CONTAINER));

    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pszPolicyName || !*pszPolicyName || !ppQMPolicy) {
        //
        // Do not bail to error from here.
        //
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcGetQMPolicy(
                      pServerName,
                      dwVersion,
                      pszPolicyName,
                      dwFlags,
                      &pQMPolicyContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept


    *ppQMPolicy = pQMPolicyContainer->pPolicies;
    return (dwError);

error:

    *ppQMPolicy = NULL;
    return (dwError);
}


DWORD
AddMMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PIPSEC_MM_POLICY pMMPolicy,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    IPSEC_MM_POLICY_CONTAINER MMPolicyContainer;
    PIPSEC_MM_POLICY_CONTAINER pMMPolicyContainer = &MMPolicyContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    dwError = ValidateMMPolicy(
                  pMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMPolicyContainer->dwNumPolicies = 1;
    pMMPolicyContainer->pPolicies = pMMPolicy;

    RpcTryExcept {

        dwError = RpcAddMMPolicy(
                      pServerName,
                      dwVersion,
                      dwFlags,
                      pMMPolicyContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
DeleteMMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pszPolicyName || !*pszPolicyName) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    RpcTryExcept {

        dwError = RpcDeleteMMPolicy(
                      pServerName,
                      dwVersion,
                      pszPolicyName
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
EnumMMPolicies(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_MM_POLICY pMMTemplatePolicy,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PIPSEC_MM_POLICY * ppMMPolicies,
    LPDWORD pdwNumPolicies,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    IPSEC_MM_POLICY_CONTAINER MMPolicyContainer;
    PIPSEC_MM_POLICY_CONTAINER pMMPolicyContainer = &MMPolicyContainer;
    IPSEC_MM_POLICY_CONTAINER MMTempPolicyContainer;
    PIPSEC_MM_POLICY_CONTAINER pMMTempPolicyContainer = &MMTempPolicyContainer;


    memset(pMMPolicyContainer, 0, sizeof(IPSEC_MM_POLICY_CONTAINER));

    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (pMMTemplatePolicy) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!ppMMPolicies || !pdwNumPolicies || !pdwResumeHandle) {
        //
        // Do not bail to error from here.
        //
        return (ERROR_INVALID_PARAMETER);
    }

    pMMTempPolicyContainer->dwNumPolicies = 0;
    pMMTempPolicyContainer->pPolicies = NULL;

    RpcTryExcept {

        dwError = RpcEnumMMPolicies(
                      pServerName,
                      dwVersion,
                      pMMTempPolicyContainer,
                      dwFlags,
                      dwPreferredNumEntries,
                      &pMMPolicyContainer,
                      pdwResumeHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppMMPolicies = pMMPolicyContainer->pPolicies;
    *pdwNumPolicies = pMMPolicyContainer->dwNumPolicies;

    return (dwError);

error:

    *ppMMPolicies = NULL;
    *pdwNumPolicies = 0;

    return (dwError);
}


DWORD
SetMMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    PIPSEC_MM_POLICY pMMPolicy,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    IPSEC_MM_POLICY_CONTAINER MMPolicyContainer;
    PIPSEC_MM_POLICY_CONTAINER pMMPolicyContainer = &MMPolicyContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pszPolicyName || !*pszPolicyName) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateMMPolicy(
                  pMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMPolicyContainer->dwNumPolicies = 1;
    pMMPolicyContainer->pPolicies = pMMPolicy;

    RpcTryExcept {

        dwError = RpcSetMMPolicy(
                      pServerName,
                      dwVersion,
                      pszPolicyName,
                      pMMPolicyContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
GetMMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    PIPSEC_MM_POLICY * ppMMPolicy,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    IPSEC_MM_POLICY_CONTAINER  MMPolicyContainer;
    PIPSEC_MM_POLICY_CONTAINER pMMPolicyContainer = &MMPolicyContainer;


    memset(pMMPolicyContainer, 0, sizeof(IPSEC_MM_POLICY_CONTAINER));

    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pszPolicyName || !*pszPolicyName || !ppMMPolicy) {
        //
        // Do not bail to error from here.
        //
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcGetMMPolicy(
                      pServerName,
                      dwVersion,
                      pszPolicyName,
                      &pMMPolicyContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept


    *ppMMPolicy = pMMPolicyContainer->pPolicies;
    return (dwError);

error:

    *ppMMPolicy = NULL;
    return (dwError);
}


DWORD
AddMMFilter(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PMM_FILTER pMMFilter,
    LPVOID pvReserved,
    PHANDLE phMMFilter
    )
{
    DWORD dwError = 0;
    MM_FILTER_CONTAINER MMFilterContainer;
    PMM_FILTER_CONTAINER pMMFilterContainer = &MMFilterContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!phMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (pMMFilter && (pMMFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        return (ERROR_INVALID_LEVEL);
    }

    dwError = ValidateMMFilter(
                  pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilterContainer->dwNumFilters = 1;
    pMMFilterContainer->pMMFilters = pMMFilter;

    RpcTryExcept {

        dwError = RpcAddMMFilter(
                      pServerName,
                      dwVersion,
                      dwFlags,
                      pMMFilterContainer,
                      phMMFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
DeleteMMFilter(
    HANDLE hMMFilter
    )
{
    DWORD dwError = 0;


    if (!hMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcDeleteMMFilter(
                      &hMMFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    if (dwError) {
        dwError = SPDDestroyClientContextHandle(
                      dwError,
                      hMMFilter
                      );
    }

    return (dwError);
}


DWORD
EnumMMFilters(
    LPWSTR pServerName,
    DWORD dwVersion,
    PMM_FILTER pMMTemplateFilter,
    DWORD dwLevel,
    GUID gGenericFilterID,
    DWORD dwPreferredNumEntries,
    PMM_FILTER * ppMMFilters,
    LPDWORD pdwNumMMFilters,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    MM_FILTER_CONTAINER MMFilterContainer;
    PMM_FILTER_CONTAINER pMMFilterContainer = &MMFilterContainer;
    MM_FILTER_CONTAINER TemplateFilterContainer;
    PMM_FILTER_CONTAINER pTemplateFilterContainer = &TemplateFilterContainer;


    memset(pMMFilterContainer, 0, sizeof(MM_FILTER_CONTAINER));

    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (pMMTemplateFilter) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!ppMMFilters || !pdwNumMMFilters || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    switch (dwLevel) {

    case ENUM_GENERIC_FILTERS:
    case ENUM_SELECT_SPECIFIC_FILTERS:
    case ENUM_SPECIFIC_FILTERS:
        break;

    default:
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    pTemplateFilterContainer->dwNumFilters = 0;
    pTemplateFilterContainer->pMMFilters = NULL;

    RpcTryExcept {

        dwError = RpcEnumMMFilters(
                      pServerName,
                      dwVersion,
                      pTemplateFilterContainer,
                      dwLevel,
                      gGenericFilterID,
                      dwPreferredNumEntries,
                      &pMMFilterContainer,
                      pdwResumeHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppMMFilters = pMMFilterContainer->pMMFilters;
    *pdwNumMMFilters = pMMFilterContainer->dwNumFilters;

    return (dwError);

error:

    *ppMMFilters = NULL;
    *pdwNumMMFilters = 0;

    return (dwError);
}


DWORD
SetMMFilter(
    HANDLE hMMFilter,
    DWORD dwVersion,
    PMM_FILTER pMMFilter,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    MM_FILTER_CONTAINER MMFilterContainer;
    PMM_FILTER_CONTAINER pMMFilterContainer = &MMFilterContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!hMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (pMMFilter && (pMMFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        return (ERROR_INVALID_LEVEL);
    }

    dwError = ValidateMMFilter(
                  pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilterContainer->dwNumFilters = 1;
    pMMFilterContainer->pMMFilters = pMMFilter;

    RpcTryExcept {

        dwError = RpcSetMMFilter(
                      hMMFilter,
                      dwVersion,
                      pMMFilterContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
GetMMFilter(
    HANDLE hMMFilter,
    DWORD dwVersion,
    PMM_FILTER * ppMMFilter,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    MM_FILTER_CONTAINER MMFilterContainer;
    PMM_FILTER_CONTAINER pMMFilterContainer = &MMFilterContainer;


    memset(pMMFilterContainer, 0, sizeof(MM_FILTER_CONTAINER));

    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!hMMFilter || !ppMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcGetMMFilter(
                      hMMFilter,
                      dwVersion,
                      &pMMFilterContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept


    *ppMMFilter = pMMFilterContainer->pMMFilters;
    return (dwError);

error:

    *ppMMFilter = NULL;
    return (dwError);
}


DWORD
MatchMMFilter(
    LPWSTR pServerName,
    DWORD dwVersion,
    PMM_FILTER pMMFilter,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PMM_FILTER * ppMatchedMMFilters,
    PIPSEC_MM_POLICY * ppMatchedMMPolicies,
    PMM_AUTH_METHODS * ppMatchedMMAuthMethods,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    MM_FILTER_CONTAINER InMMFilterContainer;
    PMM_FILTER_CONTAINER pInMMFilterContainer = &InMMFilterContainer;
    MM_FILTER_CONTAINER OutMMFilterContainer;
    PMM_FILTER_CONTAINER pOutMMFilterContainer = &OutMMFilterContainer;
    IPSEC_MM_POLICY_CONTAINER MMPolicyContainer;
    PIPSEC_MM_POLICY_CONTAINER pMMPolicyContainer = &MMPolicyContainer;
    MM_AUTH_METHODS_CONTAINER MMAuthContainer;
    PMM_AUTH_METHODS_CONTAINER pMMAuthContainer = &MMAuthContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pMMFilter || !ppMatchedMMFilters || !ppMatchedMMPolicies ||
        !ppMatchedMMAuthMethods || !pdwNumMatches || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (pMMFilter && (pMMFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        return (ERROR_INVALID_LEVEL);
    }

    dwError = ValidateMMFilterTemplate(
                  pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pInMMFilterContainer->dwNumFilters = 1;
    pInMMFilterContainer->pMMFilters = pMMFilter;

    memset(pOutMMFilterContainer, 0, sizeof(MM_FILTER_CONTAINER));
    memset(pMMPolicyContainer, 0, sizeof(IPSEC_MM_POLICY_CONTAINER));
    memset(pMMAuthContainer, 0, sizeof(MM_AUTH_METHODS_CONTAINER));

    RpcTryExcept {

        dwError = RpcMatchMMFilter(
                      pServerName,
                      dwVersion,
                      pInMMFilterContainer,
                      dwFlags,
                      dwPreferredNumEntries,
                      &pOutMMFilterContainer,
                      &pMMPolicyContainer,
                      &pMMAuthContainer,
                      pdwResumeHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppMatchedMMFilters = pOutMMFilterContainer->pMMFilters;
    *ppMatchedMMPolicies = pMMPolicyContainer->pPolicies;
    *ppMatchedMMAuthMethods = pMMAuthContainer->pMMAuthMethods;
    *pdwNumMatches = pOutMMFilterContainer->dwNumFilters;

    return (dwError);

error:

    *ppMatchedMMFilters = NULL;
    *ppMatchedMMPolicies = NULL;
    *ppMatchedMMAuthMethods = NULL;
    *pdwNumMatches = 0;

    return (dwError);
}


DWORD
MatchTransportFilter(
    LPWSTR pServerName,
    DWORD dwVersion,
    PTRANSPORT_FILTER pTxFilter,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PTRANSPORT_FILTER * ppMatchedTxFilters,
    PIPSEC_QM_POLICY * ppMatchedQMPolicies,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    TRANSPORT_FILTER_CONTAINER InTxFilterContainer;
    PTRANSPORT_FILTER_CONTAINER pInTxFilterContainer = &InTxFilterContainer;
    TRANSPORT_FILTER_CONTAINER OutTxFilterContainer;
    PTRANSPORT_FILTER_CONTAINER pOutTxFilterContainer = &OutTxFilterContainer;
    IPSEC_QM_POLICY_CONTAINER QMPolicyContainer;
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer = &QMPolicyContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pTxFilter || !ppMatchedTxFilters || !ppMatchedQMPolicies ||
        !pdwNumMatches || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (pTxFilter && (pTxFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        return (ERROR_INVALID_LEVEL);
    }

    dwError = ValidateTxFilterTemplate(
                  pTxFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pInTxFilterContainer->dwNumFilters = 1;
    pInTxFilterContainer->pTransportFilters = pTxFilter;

    memset(pOutTxFilterContainer, 0, sizeof(TRANSPORT_FILTER_CONTAINER));
    memset(pQMPolicyContainer, 0, sizeof(IPSEC_QM_POLICY_CONTAINER));

    RpcTryExcept {

        dwError = RpcMatchTransportFilter(
                      pServerName,
                      dwVersion,
                      pInTxFilterContainer,
                      dwFlags,
                      dwPreferredNumEntries,
                      &pOutTxFilterContainer,
                      &pQMPolicyContainer,
                      pdwResumeHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppMatchedTxFilters = pOutTxFilterContainer->pTransportFilters;
    *ppMatchedQMPolicies = pQMPolicyContainer->pPolicies;
    *pdwNumMatches = pOutTxFilterContainer->dwNumFilters;

    return (dwError);

error:

    *ppMatchedTxFilters = NULL;
    *ppMatchedQMPolicies = NULL;
    *pdwNumMatches = 0;

    return (dwError);
}


DWORD
GetQMPolicyByID(
    LPWSTR pServerName,
    DWORD dwVersion,
    GUID gQMPolicyID,
    DWORD dwFlags,
    PIPSEC_QM_POLICY * ppQMPolicy,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    IPSEC_QM_POLICY_CONTAINER  QMPolicyContainer;
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer = &QMPolicyContainer;


    memset(pQMPolicyContainer, 0, sizeof(IPSEC_QM_POLICY_CONTAINER));

    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!ppQMPolicy) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcGetQMPolicyByID(
                      pServerName,
                      dwVersion,
                      gQMPolicyID,
                      dwFlags,
                      &pQMPolicyContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept


    *ppQMPolicy = pQMPolicyContainer->pPolicies;
    return (dwError);

error:

    *ppQMPolicy = NULL;
    return (dwError);
}


DWORD
GetMMPolicyByID(
    LPWSTR pServerName,
    DWORD dwVersion,
    GUID gMMPolicyID,
    PIPSEC_MM_POLICY * ppMMPolicy,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    IPSEC_MM_POLICY_CONTAINER  MMPolicyContainer;
    PIPSEC_MM_POLICY_CONTAINER pMMPolicyContainer = &MMPolicyContainer;


    memset(pMMPolicyContainer, 0, sizeof(IPSEC_MM_POLICY_CONTAINER));

    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!ppMMPolicy) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcGetMMPolicyByID(
                      pServerName,
                      dwVersion,
                      gMMPolicyID,
                      &pMMPolicyContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept


    *ppMMPolicy = pMMPolicyContainer->pPolicies;
    return (dwError);

error:

    *ppMMPolicy = NULL;
    return (dwError);
}


DWORD
AddMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PMM_AUTH_METHODS pMMAuthMethods,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    MM_AUTH_METHODS_CONTAINER MMAuthContainer;
    PMM_AUTH_METHODS_CONTAINER pMMAuthContainer = &MMAuthContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    dwError = ValidateMMAuthMethods(
                  pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMAuthContainer->dwNumAuthMethods = 1;
    pMMAuthContainer->pMMAuthMethods = pMMAuthMethods;

    RpcTryExcept {

        dwError = RpcAddMMAuthMethods(
                      pServerName,
                      dwVersion,
                      dwFlags,
                      pMMAuthContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
DeleteMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwVersion,
    GUID gMMAuthID,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    RpcTryExcept {

        dwError = RpcDeleteMMAuthMethods(
                      pServerName,
                      dwVersion,
                      gMMAuthID
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
EnumMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwVersion,
    PMM_AUTH_METHODS pMMTemplateAuthMethods,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PMM_AUTH_METHODS * ppMMAuthMethods,
    LPDWORD pdwNumAuthMethods,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    MM_AUTH_METHODS_CONTAINER MMAuthContainer;
    PMM_AUTH_METHODS_CONTAINER pMMAuthContainer = &MMAuthContainer;
    MM_AUTH_METHODS_CONTAINER MMTempAuthContainer;
    PMM_AUTH_METHODS_CONTAINER pMMTempAuthContainer = &MMTempAuthContainer;


    memset(pMMAuthContainer, 0, sizeof(MM_AUTH_METHODS_CONTAINER));

    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (pMMTemplateAuthMethods) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!ppMMAuthMethods || !pdwNumAuthMethods || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    pMMTempAuthContainer->dwNumAuthMethods = 0;
    pMMTempAuthContainer->pMMAuthMethods = NULL;

    RpcTryExcept {

        dwError = RpcEnumMMAuthMethods(
                      pServerName,
                      dwVersion,
                      pMMTempAuthContainer,
                      dwFlags,
                      dwPreferredNumEntries,
                      &pMMAuthContainer,
                      pdwResumeHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppMMAuthMethods = pMMAuthContainer->pMMAuthMethods;
    *pdwNumAuthMethods = pMMAuthContainer->dwNumAuthMethods;

    return (dwError);

error:

    *ppMMAuthMethods = NULL;
    *pdwNumAuthMethods = 0;

    return (dwError);
}


DWORD
SetMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwVersion,
    GUID gMMAuthID,
    PMM_AUTH_METHODS pMMAuthMethods,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    MM_AUTH_METHODS_CONTAINER MMAuthContainer;
    PMM_AUTH_METHODS_CONTAINER pMMAuthContainer = &MMAuthContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    dwError = ValidateMMAuthMethods(
                  pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMAuthContainer->dwNumAuthMethods = 1;
    pMMAuthContainer->pMMAuthMethods = pMMAuthMethods;

    RpcTryExcept {

        dwError = RpcSetMMAuthMethods(
                      pServerName,
                      dwVersion,
                      gMMAuthID,
                      pMMAuthContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
GetMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwVersion,
    GUID gMMAuthID,
    PMM_AUTH_METHODS * ppMMAuthMethods,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    MM_AUTH_METHODS_CONTAINER  MMAuthContainer;
    PMM_AUTH_METHODS_CONTAINER pMMAuthContainer = &MMAuthContainer;


    memset(pMMAuthContainer, 0, sizeof(MM_AUTH_METHODS_CONTAINER));

    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!ppMMAuthMethods) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcGetMMAuthMethods(
                      pServerName,
                      dwVersion,
                      gMMAuthID,
                      &pMMAuthContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept


    *ppMMAuthMethods = pMMAuthContainer->pMMAuthMethods;
    return (dwError);

error:

    *ppMMAuthMethods = NULL;
    return (dwError);
}


DWORD
InitiateIKENegotiation(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_QM_FILTER pQMFilter,
    DWORD dwClientProcessId,
    HANDLE hClientEvent,
    DWORD dwFlags,
    IPSEC_UDP_ENCAP_CONTEXT UdpEncapContext,
    LPVOID pvReserved,
    PHANDLE phNegotiation
    )
{
    DWORD dwError = 0;
    QM_FILTER_CONTAINER FilterContainer;
    PQM_FILTER_CONTAINER pFilterContainer = &FilterContainer;
    ULONG uhClientEvent = 0;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    pFilterContainer->dwNumFilters = 1;
    pFilterContainer->pQMFilters = pQMFilter;
    uhClientEvent = HandleToUlong(hClientEvent);

    if (phNegotiation) {
        *phNegotiation = NULL;
    }

    if (pQMFilter && (pQMFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        return (ERROR_INVALID_LEVEL);
    }

    dwError=ValidateInitiateIKENegotiation(
        pServerName,
        pFilterContainer,
        dwClientProcessId,
        uhClientEvent,
        dwFlags,
        UdpEncapContext,
        phNegotiation
        );        
    BAIL_ON_WIN32_ERROR(dwError);    

    RpcTryExcept {

        dwError = RpcInitiateIKENegotiation(
                      pServerName,
                      dwVersion,
                      pFilterContainer,
                      dwClientProcessId,
                      uhClientEvent,
                      dwFlags,
                      UdpEncapContext,
                      phNegotiation
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
QueryIKENegotiationStatus(
    HANDLE hNegotiation,
    DWORD dwVersion,
    PSA_NEGOTIATION_STATUS_INFO pNegotiationStatus,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    dwError = ValidateQueryIKENegotiationStatus(
                  hNegotiation,
                  pNegotiationStatus
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    RpcTryExcept {

        dwError = RpcQueryIKENegotiationStatus(
                      hNegotiation,
                      dwVersion,
                      pNegotiationStatus
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
CloseIKENegotiationHandle(
    HANDLE hNegotiation
    )
{
    DWORD dwError = 0;


    dwError = ValidateCloseIKENegotiationHandle(hNegotiation);
    BAIL_ON_WIN32_ERROR(dwError);

    RpcTryExcept {

        dwError = RpcCloseIKENegotiationHandle(
                      &hNegotiation
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
EnumMMSAs(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_MM_SA pMMTemplate,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PIPSEC_MM_SA * ppMMSAs,
    LPDWORD pdwNumEntries,
    LPDWORD pdwTotalMMsAvailable,
    LPDWORD pdwEnumHandle,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    MM_SA_CONTAINER MMSAContainer, MMSAContainerTemplate;
    PMM_SA_CONTAINER pContainer = &MMSAContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (pMMTemplate && (pMMTemplate->IpVersion != IPSEC_PROTOCOL_V4)) {
        return (ERROR_INVALID_LEVEL);
    }

    MMSAContainerTemplate.dwNumMMSAs = 1;
    MMSAContainerTemplate.pMMSAs = pMMTemplate;

    memset(&MMSAContainer, 0, sizeof(MM_SA_CONTAINER));

    if (ppMMSAs == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = ValidateEnumMMSAs(
                  pServerName,
                  &MMSAContainerTemplate,
                  &pContainer,
                  pdwNumEntries,
                  pdwTotalMMsAvailable,
                  pdwEnumHandle,
                  dwFlags
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    RpcTryExcept {

        dwError = RpcEnumMMSAs(
                      pServerName,
                      dwVersion,
                      &MMSAContainerTemplate,
                      dwFlags,
                      dwPreferredNumEntries,
                      &pContainer,
                      pdwNumEntries,
                      pdwTotalMMsAvailable,
                      pdwEnumHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppMMSAs = pContainer->pMMSAs;

    return (dwError);

error:

    *ppMMSAs = NULL;

    return (dwError);
}


DWORD
DeleteMMSAs(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_MM_SA pMMTemplate,
    DWORD dwFlags,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    MM_SA_CONTAINER MMSAContainerTemplate;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (pMMTemplate && (pMMTemplate->IpVersion != IPSEC_PROTOCOL_V4)) {
        return (ERROR_INVALID_LEVEL);
    }

    MMSAContainerTemplate.dwNumMMSAs = 1;
    MMSAContainerTemplate.pMMSAs = pMMTemplate;

    dwError = ValidateDeleteMMSAs(
                  pServerName,
                  &MMSAContainerTemplate,
                  dwFlags
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    RpcTryExcept {

        dwError = RpcDeleteMMSAs(
                      pServerName,
                      dwVersion,
                      &MMSAContainerTemplate,
                      dwFlags
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
DeleteQMSAs(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_QM_SA pIpsecQMSA,
    DWORD dwFlags,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    QM_SA_CONTAINER QMSATempContainer;
    PQM_SA_CONTAINER pQMSATempContainer = &QMSATempContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (pIpsecQMSA && (pIpsecQMSA->IpsecQMFilter.IpVersion != IPSEC_PROTOCOL_V4)) {
        return (ERROR_INVALID_LEVEL);
    }

    memset(pQMSATempContainer, 0, sizeof(QM_SA_CONTAINER));

    if (!pIpsecQMSA) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pQMSATempContainer->dwNumQMSAs = 1;
    pQMSATempContainer->pQMSAs = pIpsecQMSA;

    dwError = ValidateQMFilterAddresses(
                  &pQMSATempContainer->pQMSAs->IpsecQMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    RpcTryExcept {

        dwError = RpcDeleteQMSAs(
                      pServerName,
                      dwVersion,
                      pQMSATempContainer,
                      dwFlags
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
QueryIKEStatistics(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIKE_STATISTICS pIKEStatistics,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    dwError = ValidateQueryIKEStatistics(
                  pServerName,
                  pIKEStatistics
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    RpcTryExcept {

        dwError = RpcQueryIKEStatistics(
                      pServerName,
                      dwVersion,
                      pIKEStatistics
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
RegisterIKENotifyClient(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwClientProcessId,
    HANDLE hClientEvent,
    IPSEC_QM_SA QMTemplate,
    DWORD dwFlags,
    LPVOID pvReserved,
    PHANDLE phNotifyHandle
    )
{
    DWORD dwError = 0;
    ULONG uhClientEvent = 0;
    QM_SA_CONTAINER QMSAContainer;
    PQM_SA_CONTAINER pQMSAContainer = &QMSAContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (QMTemplate.IpsecQMFilter.IpVersion != IPSEC_PROTOCOL_V4) {
        return (ERROR_INVALID_LEVEL);
    }

    QMSAContainer.dwNumQMSAs = 1;
    QMSAContainer.pQMSAs = &QMTemplate;

    uhClientEvent = HandleToUlong(hClientEvent);

    dwError = ValidateRegisterIKENotifyClient(
                  pServerName,
                  dwClientProcessId,
                  uhClientEvent,
                  pQMSAContainer,
                  phNotifyHandle,
                  dwFlags
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    RpcTryExcept {

        dwError = RpcRegisterIKENotifyClient(
                      pServerName,
                      dwVersion,
                      dwClientProcessId,
                      uhClientEvent,
                      pQMSAContainer,
                      dwFlags,
                      phNotifyHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
QueryIKENotifyData(
    HANDLE hNotifyHandle,
    DWORD dwVersion,
    DWORD dwFlags,
    PIPSEC_QM_SA * ppQMSAs,
    PDWORD pdwNumEntries,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    QM_SA_CONTAINER QMSAContainer;
    PQM_SA_CONTAINER pContainer = &QMSAContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    memset(&QMSAContainer, 0, sizeof(QM_SA_CONTAINER));

    if ((ppQMSAs == NULL) || (pdwNumEntries == NULL)) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = ValidateQueryNotifyData(
                  hNotifyHandle,
                  pdwNumEntries,
                  &pContainer,
                  dwFlags
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    RpcTryExcept {

        dwError = RpcQueryIKENotifyData(
                      hNotifyHandle,
                      dwVersion,
                      dwFlags,
                      &pContainer,
                      pdwNumEntries
                      );

        if (dwError && dwError != ERROR_MORE_DATA) {
            goto error;
        }

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppQMSAs = pContainer->pQMSAs;
    *pdwNumEntries = pContainer->dwNumQMSAs;

    return (dwError);

error:

    *ppQMSAs = NULL;
    *pdwNumEntries = 0;

    return (dwError);
}


DWORD
CloseIKENotifyHandle(
    HANDLE hNotifyHandle
    )
{
    DWORD dwError = 0;


    dwError = ValidateCloseNotifyHandle(hNotifyHandle);
    BAIL_ON_WIN32_ERROR(dwError);

    RpcTryExcept {

        dwError = RpcCloseIKENotifyHandle(
                      &hNotifyHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
QueryIPSecStatistics(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_STATISTICS * ppIpsecStatistics,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    IPSEC_STATISTICS_CONTAINER IpsecStatsContainer;
    PIPSEC_STATISTICS_CONTAINER pIpsecStatsContainer = &IpsecStatsContainer;


    memset(pIpsecStatsContainer, 0, sizeof(IPSEC_STATISTICS_CONTAINER));

    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!ppIpsecStatistics) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcQueryIPSecStatistics(
                      pServerName,
                      dwVersion,
                      &pIpsecStatsContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept


    *ppIpsecStatistics = pIpsecStatsContainer->pIpsecStatistics;
    return (dwError);

error:

    return (dwError);
}


DWORD
EnumQMSAs(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_QM_SA pQMSATemplate,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PIPSEC_QM_SA * ppQMSAs,
    LPDWORD pdwNumQMSAs,
    LPDWORD pdwNumTotalQMSAs,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    QM_SA_CONTAINER QMSATempContainer;
    PQM_SA_CONTAINER pQMSATempContainer = &QMSATempContainer;
    QM_SA_CONTAINER QMSAContainer;
    PQM_SA_CONTAINER pQMSAContainer = &QMSAContainer;


    memset(pQMSAContainer, 0, sizeof(QM_SA_CONTAINER));

    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (pQMSATemplate) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!ppQMSAs || !pdwNumQMSAs ||
        !pdwNumTotalQMSAs || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    pQMSATempContainer->dwNumQMSAs = 0;
    pQMSATempContainer->pQMSAs = NULL;

    RpcTryExcept {

        dwError = RpcEnumQMSAs(
                      pServerName,
                      dwVersion,
                      pQMSATempContainer,
                      dwFlags,
                      dwPreferredNumEntries,
                      &pQMSAContainer,
                      pdwNumTotalQMSAs,
                      pdwResumeHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppQMSAs = pQMSAContainer->pQMSAs;
    *pdwNumQMSAs = pQMSAContainer->dwNumQMSAs;

    return (dwError);

error:

    return (dwError);
}


DWORD
AddTunnelFilter(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PTUNNEL_FILTER pTunnelFilter,
    LPVOID pvReserved,
    PHANDLE phFilter
    )
{
    DWORD dwError = 0;
    TUNNEL_FILTER_CONTAINER FilterContainer;
    PTUNNEL_FILTER_CONTAINER pFilterContainer = &FilterContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!phFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (pTunnelFilter && (pTunnelFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        return (ERROR_INVALID_LEVEL);
    }

    dwError = ValidateTunnelFilter(
                  pTunnelFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pFilterContainer->dwNumFilters = 1;
    pFilterContainer->pTunnelFilters = pTunnelFilter;

    RpcTryExcept {

        dwError = RpcAddTunnelFilter(
                      pServerName,
                      dwVersion,
                      dwFlags,
                      pFilterContainer,
                      phFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
DeleteTunnelFilter(
    HANDLE hFilter
    )
{
    DWORD dwError = 0;


    if (!hFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcDeleteTunnelFilter(
                      &hFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    if (dwError) {
        dwError = SPDDestroyClientContextHandle(
                      dwError,
                      hFilter
                      );
    }

    return (dwError);
}


DWORD
EnumTunnelFilters(
    LPWSTR pServerName,
    DWORD dwVersion,
    PTUNNEL_FILTER pTunnelTemplateFilter,
    DWORD dwLevel,
    GUID gGenericFilterID,
    DWORD dwPreferredNumEntries,
    PTUNNEL_FILTER * ppTunnelFilters,
    LPDWORD pdwNumFilters,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    TUNNEL_FILTER_CONTAINER FilterContainer;
    PTUNNEL_FILTER_CONTAINER pFilterContainer = &FilterContainer;
    TUNNEL_FILTER_CONTAINER TemplateFilterContainer;
    PTUNNEL_FILTER_CONTAINER pTemplateFilterContainer = &TemplateFilterContainer;


    memset(pFilterContainer, 0, sizeof(TUNNEL_FILTER_CONTAINER));

    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (pTunnelTemplateFilter) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!ppTunnelFilters || !pdwNumFilters || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    switch (dwLevel) {

    case ENUM_GENERIC_FILTERS:
    case ENUM_SELECT_SPECIFIC_FILTERS:
    case ENUM_SPECIFIC_FILTERS:
        break;

    default:
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    pTemplateFilterContainer->dwNumFilters = 0;
    pTemplateFilterContainer->pTunnelFilters = NULL;

    RpcTryExcept {

        dwError = RpcEnumTunnelFilters(
                      pServerName,
                      dwVersion,
                      pTemplateFilterContainer,
                      dwLevel,
                      gGenericFilterID,
                      dwPreferredNumEntries,
                      &pFilterContainer,
                      pdwResumeHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppTunnelFilters = pFilterContainer->pTunnelFilters;
    *pdwNumFilters = pFilterContainer->dwNumFilters;

    return (dwError);

error:

    *ppTunnelFilters = NULL;
    *pdwNumFilters = 0;

    return (dwError);
}


DWORD
SetTunnelFilter(
    HANDLE hFilter,
    DWORD dwVersion,
    PTUNNEL_FILTER pTunnelFilter,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    TUNNEL_FILTER_CONTAINER FilterContainer;
    PTUNNEL_FILTER_CONTAINER pFilterContainer = &FilterContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!hFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (pTunnelFilter && (pTunnelFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        return (ERROR_INVALID_LEVEL);
    }

    dwError = ValidateTunnelFilter(
                  pTunnelFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pFilterContainer->dwNumFilters = 1;
    pFilterContainer->pTunnelFilters = pTunnelFilter;

    RpcTryExcept {

        dwError = RpcSetTunnelFilter(
                      hFilter,
                      dwVersion,
                      pFilterContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
GetTunnelFilter(
    HANDLE hFilter,
    DWORD dwVersion,
    PTUNNEL_FILTER * ppTunnelFilter,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    TUNNEL_FILTER_CONTAINER FilterContainer;
    PTUNNEL_FILTER_CONTAINER pFilterContainer = &FilterContainer;


    memset(pFilterContainer, 0, sizeof(TUNNEL_FILTER_CONTAINER));

    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!hFilter || !ppTunnelFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcGetTunnelFilter(
                      hFilter,
                      dwVersion,
                      &pFilterContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept


    *ppTunnelFilter = pFilterContainer->pTunnelFilters;
    return (dwError);

error:

    *ppTunnelFilter = NULL;
    return (dwError);
}


DWORD
MatchTunnelFilter(
    LPWSTR pServerName,
    DWORD dwVersion,
    PTUNNEL_FILTER pTnFilter,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PTUNNEL_FILTER * ppMatchedTnFilters,
    PIPSEC_QM_POLICY * ppMatchedQMPolicies,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    TUNNEL_FILTER_CONTAINER InTnFilterContainer;
    PTUNNEL_FILTER_CONTAINER pInTnFilterContainer = &InTnFilterContainer;
    TUNNEL_FILTER_CONTAINER OutTnFilterContainer;
    PTUNNEL_FILTER_CONTAINER pOutTnFilterContainer = &OutTnFilterContainer;
    IPSEC_QM_POLICY_CONTAINER QMPolicyContainer;
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer = &QMPolicyContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pTnFilter || !ppMatchedTnFilters || !ppMatchedQMPolicies ||
        !pdwNumMatches || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (pTnFilter && (pTnFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        return (ERROR_INVALID_LEVEL);
    }

    dwError = ValidateTnFilterTemplate(
                  pTnFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pInTnFilterContainer->dwNumFilters = 1;
    pInTnFilterContainer->pTunnelFilters = pTnFilter;

    memset(pOutTnFilterContainer, 0, sizeof(TUNNEL_FILTER_CONTAINER));
    memset(pQMPolicyContainer, 0, sizeof(IPSEC_QM_POLICY_CONTAINER));

    RpcTryExcept {

        dwError = RpcMatchTunnelFilter(
                      pServerName,
                      dwVersion,
                      pInTnFilterContainer,
                      dwFlags,
                      dwPreferredNumEntries,
                      &pOutTnFilterContainer,
                      &pQMPolicyContainer,
                      pdwResumeHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppMatchedTnFilters = pOutTnFilterContainer->pTunnelFilters;
    *ppMatchedQMPolicies = pQMPolicyContainer->pPolicies;
    *pdwNumMatches = pOutTnFilterContainer->dwNumFilters;

    return (dwError);

error:

    *ppMatchedTnFilters = NULL;
    *ppMatchedQMPolicies = NULL;
    *pdwNumMatches = 0;

    return (dwError);
}


DWORD
OpenMMFilterHandle(
    LPWSTR pServerName,
    DWORD dwVersion,
    PMM_FILTER pMMFilter,
    LPVOID pvReserved,
    PHANDLE phMMFilter
    )
{
    DWORD dwError = 0;
    MM_FILTER_CONTAINER MMFilterContainer;
    PMM_FILTER_CONTAINER pMMFilterContainer = &MMFilterContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!phMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (pMMFilter && (pMMFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        return (ERROR_INVALID_LEVEL);
    }

    dwError = ValidateMMFilter(
                  pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilterContainer->dwNumFilters = 1;
    pMMFilterContainer->pMMFilters = pMMFilter;

    RpcTryExcept {

        dwError = RpcOpenMMFilterHandle(
                      pServerName,
                      dwVersion,
                      pMMFilterContainer,
                      phMMFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
CloseMMFilterHandle(
    HANDLE hMMFilter
    )
{
    DWORD dwError = 0;


    if (!hMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcCloseMMFilterHandle(
                      &hMMFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    if (dwError) {
        dwError = SPDDestroyClientContextHandle(
                      dwError,
                      hMMFilter
                      );
    }

    return (dwError);
}


DWORD
OpenTransportFilterHandle(
    LPWSTR pServerName,
    DWORD dwVersion,
    PTRANSPORT_FILTER pTransportFilter,
    LPVOID pvReserved,
    PHANDLE phTxFilter
    )
{
    DWORD dwError = 0;
    TRANSPORT_FILTER_CONTAINER FilterContainer;
    PTRANSPORT_FILTER_CONTAINER pFilterContainer = &FilterContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!phTxFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (pTransportFilter && (pTransportFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        return (ERROR_INVALID_LEVEL);
    }

    dwError = ValidateTransportFilter(
                  pTransportFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pFilterContainer->dwNumFilters = 1;
    pFilterContainer->pTransportFilters = pTransportFilter;

    RpcTryExcept {

        dwError = RpcOpenTransportFilterHandle(
                      pServerName,
                      dwVersion,
                      pFilterContainer,
                      phTxFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
CloseTransportFilterHandle(
    HANDLE hTxFilter
    )
{
    DWORD dwError = 0;


    if (!hTxFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcCloseTransportFilterHandle(
                      &hTxFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    if (dwError) {
        dwError = SPDDestroyClientContextHandle(
                      dwError,
                      hTxFilter
                      );
    }

    return (dwError);
}


DWORD
OpenTunnelFilterHandle(
    LPWSTR pServerName,
    DWORD dwVersion,
    PTUNNEL_FILTER pTunnelFilter,
    LPVOID pvReserved,
    PHANDLE phTnFilter
    )
{
    DWORD dwError = 0;
    TUNNEL_FILTER_CONTAINER FilterContainer;
    PTUNNEL_FILTER_CONTAINER pFilterContainer = &FilterContainer;


    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!phTnFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (pTunnelFilter && (pTunnelFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        return (ERROR_INVALID_LEVEL);
    }

    dwError = ValidateTunnelFilter(
                  pTunnelFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pFilterContainer->dwNumFilters = 1;
    pFilterContainer->pTunnelFilters = pTunnelFilter;

    RpcTryExcept {

        dwError = RpcOpenTunnelFilterHandle(
                      pServerName,
                      dwVersion,
                      pFilterContainer,
                      phTnFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
CloseTunnelFilterHandle(
    HANDLE hTnFilter
    )
{
    DWORD dwError = 0;


    if (!hTnFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcCloseTunnelFilterHandle(
                      &hTnFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    if (dwError) {
        dwError = SPDDestroyClientContextHandle(
                      dwError,
                      hTnFilter
                      );
    }

    return (dwError);
}


DWORD
EnumIPSecInterfaces(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_INTERFACE_INFO pIpsecIfTemplate,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PIPSEC_INTERFACE_INFO * ppIpsecInterfaces,
    LPDWORD pdwNumInterfaces,
    LPDWORD pdwNumTotalInterfaces,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    IPSEC_INTERFACE_CONTAINER IpsecIfTempContainer;
    PIPSEC_INTERFACE_CONTAINER pIpsecIfTempContainer = &IpsecIfTempContainer;
    IPSEC_INTERFACE_CONTAINER IpsecIfContainer;
    PIPSEC_INTERFACE_CONTAINER pIpsecIfContainer = &IpsecIfContainer;


    memset(pIpsecIfContainer, 0, sizeof(IPSEC_INTERFACE_CONTAINER));

    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (pIpsecIfTemplate) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!ppIpsecInterfaces || !pdwNumInterfaces ||
        !pdwNumTotalInterfaces || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    pIpsecIfTempContainer->dwNumInterfaces = 0;
    pIpsecIfTempContainer->pIpsecInterfaces = NULL;

    RpcTryExcept {

        dwError = RpcEnumIpsecInterfaces(
                      pServerName,
                      dwVersion,
                      pIpsecIfTempContainer,
                      dwFlags,
                      dwPreferredNumEntries,
                      &pIpsecIfContainer,
                      pdwNumTotalInterfaces,
                      pdwResumeHandle
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *ppIpsecInterfaces = pIpsecIfContainer->pIpsecInterfaces;
    *pdwNumInterfaces = pIpsecIfContainer->dwNumInterfaces;

    return (dwError);

error:

    *ppIpsecInterfaces = NULL;
    *pdwNumInterfaces = 0;
    *pdwNumTotalInterfaces = 0;

    return (dwError);
}


DWORD
AddSAs(
    LPWSTR pServerName,
    DWORD dwVersion,
    IPSEC_SA_DIRECTION SADirection,
    PIPSEC_QM_OFFER pQMOffer,
    PIPSEC_QM_FILTER pQMFilter,
    HANDLE * phLarvalContext,
    DWORD dwInboundKeyMatLen,
    BYTE * pInboundKeyMat,
    DWORD dwOutboundKeyMatLen,
    BYTE * pOutboundKeyMat,
    BYTE * pContextInfo,
    UDP_ENCAP_INFO EncapInfo,
    LPVOID pvReserved,
    DWORD dwFlags
    )

{
    DWORD dwError = 0;
    QM_FILTER_CONTAINER FilterContainer;
    PQM_FILTER_CONTAINER pFilterContainer = &FilterContainer;
    IPSEC_QM_POLICY_CONTAINER QMPolicyContainer;
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer = &QMPolicyContainer;
    IPSEC_QM_POLICY QMPolicy;
    ULONG uhLarvalContext = 0;


    memset(&QMPolicy, 0, sizeof(IPSEC_QM_POLICY));

    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (phLarvalContext == NULL) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pQMFilter && (pQMFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        return (ERROR_INVALID_LEVEL);
    }

    uhLarvalContext = HandleToUlong(*phLarvalContext);

    pFilterContainer->dwNumFilters = 1;
    pFilterContainer->pQMFilters = pQMFilter;

    pQMPolicyContainer->dwNumPolicies = 1;
    QMPolicy.pOffers = pQMOffer;
    QMPolicy.dwOfferCount = 1;
    pQMPolicyContainer->pPolicies = &QMPolicy;

    dwError=ValidateIPSecAddSA(
        pServerName,
        SADirection,
        pQMPolicyContainer,
        pFilterContainer,
        &uhLarvalContext,
        dwInboundKeyMatLen,
        pInboundKeyMat,
        dwOutboundKeyMatLen,
        pOutboundKeyMat,
        pContextInfo,
        EncapInfo,
        dwFlags);
    BAIL_ON_WIN32_ERROR(dwError);

    RpcTryExcept {

        dwError = RpcAddSAs(
            pServerName,
            dwVersion,
            SADirection,
            pQMPolicyContainer,
            pFilterContainer,
            &uhLarvalContext,
            dwInboundKeyMatLen,
            pInboundKeyMat,
            dwOutboundKeyMatLen,
            pOutboundKeyMat,
            pContextInfo,
            EncapInfo,
            dwFlags);
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

    *phLarvalContext = LongToHandle(uhLarvalContext);


error:

    return (dwError);
}


DWORD
WINAPI
SetConfigurationVariables(
    LPWSTR pServerName,
    IKE_CONFIG IKEConfig
    )
{

    DWORD dwError = 0;

    dwError=ValidateSetConfigurationVariables(
        pServerName,
        IKEConfig
        );
    BAIL_ON_WIN32_ERROR(dwError);

    RpcTryExcept {

        dwError = RpcSetConfigurationVariables(
                      pServerName,
                      IKEConfig
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        
    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}

DWORD
WINAPI
GetConfigurationVariables(
    LPWSTR pServerName,
    PIKE_CONFIG pIKEConfig
    )
{
    DWORD dwError = 0;

    dwError=ValidateGetConfigurationVariables(
        pServerName,
        pIKEConfig
        );
    BAIL_ON_WIN32_ERROR(dwError);


    RpcTryExcept {

        dwError = RpcGetConfigurationVariables(
                      pServerName,
                      pIKEConfig
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        
    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept

error:

    return (dwError);
}


DWORD
WINAPI
QuerySpdPolicyState(
    LPWSTR pServerName,
    DWORD dwVersion,
    PSPD_POLICY_STATE * ppSpdPolicyState,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    SPD_POLICY_STATE_CONTAINER SpdPolicyStateContainer;
    PSPD_POLICY_STATE_CONTAINER pSpdPolicyStateContainer = &SpdPolicyStateContainer;
    
    memset(pSpdPolicyStateContainer, 0, sizeof(SPD_POLICY_STATE_CONTAINER));

    if (dwVersion) {
        return (ERROR_NOT_SUPPORTED);
    }

    if (!ppSpdPolicyState) {
        return (ERROR_INVALID_PARAMETER);
    }

    RpcTryExcept {

        dwError = RpcQuerySpdPolicyState(
                      pServerName,
                      dwVersion,
                      &pSpdPolicyStateContainer
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcExcept(I_RpcExceptionFilter(RpcExceptionCode())) {

        dwError = TranslateExceptionCode(RpcExceptionCode());
        BAIL_ON_WIN32_ERROR(dwError);

    } RpcEndExcept


    *ppSpdPolicyState = pSpdPolicyStateContainer->pSpdPolicyStates;
    return (dwError);

error:
    *ppSpdPolicyState = NULL;
    
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\ipsecprf\ipsecnm.h ===
/*++
copyright (c) 2002 Microsoft Corporation

Module Name:

 ipsecprfnm.h

Abstract:

 This file defines the IPSec symbols used in ipsecprf.ini file for
 loading the counters to registry.


Created:

   Avnish Kumar Chhabra      July 3, 2002

Revision History:

--*/



#define IPSECOBJ 0

#define ACTIVESA 2

#define OFFLOADEDSA 4

#define PENDINGKEYOPS 6

#define KEYADDITIONS 8

#define KEYDELETIONS 10

#define REKEYNUM 12

#define ACTIVETUNNEL 14

#define BADSPIPKTS 16

#define PKTSNOTDECRYPTED 18

#define PKTSNOTAUTHENTICATED 20

#define PKTSFAILEDREPLAY 22

#define CONFBYTESSENT 24

#define CONFBYTESRECV 26

#define AUTHBYTESSENT 28

#define AUTHBYTESRECV 30

#define TPTBYTESSENT 32

#define TPTBYTESRECV 34

#define TUNBYTESSENT 36

#define TUNBYTESRECV 38

#define OFFLOADBYTESSENT 40

#define OFFLOADBYTESRECV 42

#define IKEOBJ	44

#define ACTIVEACQUIRE	46

#define ACTIVERECEIVE	48

#define ACQUIREFAILURE	50

#define RECEIVEFAILURE	52

#define SENDFAILURE		54

#define ACQUIREHEAPSIZE	56

#define RECEIVEHEAPSIZE 	58

#define NEGFAILURE	60

#define AUTHFAILURE	62

#define INVCOOKIE	64

#define TOTACQUIRE	66

#define TOTGETSPI	68

#define IKEKEYSADD	70

#define IKEKEYSUPDT	72

#define GETSPIFAIL	74

#define KEYADDFAIL	76

#define KEYUPDTFAIL	78

#define ISADBSIZE	80

#define CONNLSIZE	82

#define MMSA	84

#define QMSA	86

#define SOFTSA	88

#define INVPKTSRCV	90
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\ipsecprf\dataipsec.h ===
/*++
copyright (c) 2002 Microsoft Corporation

Module Name:

	dataipsec.h

Abstract:

        Header file for IPSec Extensible Object Data Definitions
Author: 

        Avnish Kumar Chhabra 07/03/2002

Revision History:

--*/


#ifndef _DATAIPSEC_H_
#define _DATAIPSEC_H_

#include  <winperf.h>
#include  <winipsec.h>


#define IPSEC_NUM_PERF_OBJECT_TYPES 1


//
// IPSec Counter definitions
//

//
// Following is used in counter definitions to describe relative
// position of each counter in the returned data for IPSec Driver
//

#define NUM_ACTIVESA_OFFSET                     (FIELD_OFFSET(IPSEC_DRIVER_PM_STATS,ActiveSA))
#define NUM_OFFLOADEDSA_OFFSET                  (FIELD_OFFSET(IPSEC_DRIVER_PM_STATS,OffloadedSA))
#define NUM_PENDINGKEYOPS_OFFSET                (FIELD_OFFSET(IPSEC_DRIVER_PM_STATS,PendingKeyOps))
#define NUM_REKEYNUM_OFFSET                     (FIELD_OFFSET(IPSEC_DRIVER_PM_STATS,Rekey))
#define NUM_BADSPIPKTS_OFFSET                   (FIELD_OFFSET(IPSEC_DRIVER_PM_STATS,BadSPIPackets))
#define NUM_PKTSNOTDECRYPTED_OFFSET             (FIELD_OFFSET(IPSEC_DRIVER_PM_STATS,PacketsNotDecrypted))
#define NUM_PKTSNOTAUTHENTICATED_OFFSET         (FIELD_OFFSET(IPSEC_DRIVER_PM_STATS,PacketsNotAuthenticated))
#define NUM_PKTSFAILEDREPLAY_OFFSET             (FIELD_OFFSET(IPSEC_DRIVER_PM_STATS,PacketsWithReplayDetection))
#define NUM_TPTBYTESSENT_OFFSET                 (FIELD_OFFSET(IPSEC_DRIVER_PM_STATS,TptBytesSent))
#define NUM_TPTBYTESRECV_OFFSET                 (FIELD_OFFSET(IPSEC_DRIVER_PM_STATS,TptBytesRecv))
#define NUM_TUNBYTESSENT_OFFSET                 (FIELD_OFFSET(IPSEC_DRIVER_PM_STATS,TunBytesSent)) 
#define NUM_TUNBYTESRECV_OFFSET                 (FIELD_OFFSET(IPSEC_DRIVER_PM_STATS,TunBytesRecv))
#define NUM_OFFLOADBYTESSENT_OFFSET             (FIELD_OFFSET(IPSEC_DRIVER_PM_STATS,OffloadedBytesSent))
#define NUM_OFFLOADBYTESRECV_OFFSET             (FIELD_OFFSET(IPSEC_DRIVER_PM_STATS,OffloadedBytesRecv))
#define SIZEOF_IPSEC_TOTAL_DRIVER_DATA          (sizeof(IPSEC_DRIVER_PM_STATS))
#define NUM_OF_IPSEC_DRIVER_COUNTERS            14 // Update this if a new IPSec Driver Counter is added



//
// IKE Counter definitions
//

//
// Following is used in counter definitions to describe relative
// position of each counter in the returned data for IKE keying module
//

#define NUM_ACQUIREHEAPSIZE_OFFSET         (FIELD_OFFSET(IKE_PM_STATS,AcquireHeapSize))
#define NUM_RECEIVEHEAPSIZE_OFFSET         (FIELD_OFFSET(IKE_PM_STATS,ReceiveHeapSize))
#define NUM_NEGFAILURE_OFFSET	           (FIELD_OFFSET(IKE_PM_STATS,NegFailure))
#define NUM_AUTHFAILURE_OFFSET             (FIELD_OFFSET(IKE_PM_STATS,AuthFailure))
#define NUM_ISADBSIZE_OFFSET               (FIELD_OFFSET(IKE_PM_STATS,ISADBSize))
#define NUM_CONNLSIZE_OFFSET               (FIELD_OFFSET(IKE_PM_STATS,ConnLSize))
#define NUM_MMSA_OFFSET                    (FIELD_OFFSET(IKE_PM_STATS,MmSA))
#define NUM_QMSA_OFFSET                    (FIELD_OFFSET(IKE_PM_STATS,QmSA))
#define NUM_SOFTSA_OFFSET                  (FIELD_OFFSET(IKE_PM_STATS,SoftSA))
#define SIZEOF_IPSEC_TOTAL_IKE_DATA        ( sizeof(IKE_PM_STATS))
#define NUM_OF_IKE_COUNTERS                9 //Update this if a new IKE counter is added


typedef struct _IPSEC_DRIVER_DATA_DEFINITION 
{
    PERF_OBJECT_TYPE		 IPSecObjectType;
    PERF_COUNTER_DEFINITION	 ActiveSA;
    PERF_COUNTER_DEFINITION	 OffloadedSA;
    PERF_COUNTER_DEFINITION	 PendingKeyOps;
    PERF_COUNTER_DEFINITION	 Rekey;
    PERF_COUNTER_DEFINITION      NumBadSPIPackets;
    PERF_COUNTER_DEFINITION      NumPacketsNotDecrypted;
    PERF_COUNTER_DEFINITION      NumPacketsNotAuthenticated;
    PERF_COUNTER_DEFINITION      NumPacketsWithReplayDetection;
    PERF_COUNTER_DEFINITION	 TptBytesSent;
    PERF_COUNTER_DEFINITION	 TptBytesRecv;
    PERF_COUNTER_DEFINITION      TunBytesSent;
    PERF_COUNTER_DEFINITION      TunBytesRecv;
    PERF_COUNTER_DEFINITION      OffloadedBytesSent;
    PERF_COUNTER_DEFINITION      OffloadedbytesRecv;
} IPSEC_DRIVER_DATA_DEFINITION, *PIPSEC_DRIVER_DATA_DEFINITION;


typedef struct _IPSEC_DRIVER_PM_STATS
{
    PERF_COUNTER_BLOCK	 CounterBlock;
    DWORD                ActiveSA;
    DWORD                OffloadedSA;
    DWORD                PendingKeyOps;
    DWORD                Rekey;
    DWORD                BadSPIPackets;
    DWORD                PacketsNotDecrypted;
    DWORD                PacketsNotAuthenticated;
    DWORD                PacketsWithReplayDetection;
    ULARGE_INTEGER       TptBytesSent;
    ULARGE_INTEGER       TptBytesRecv;
    ULARGE_INTEGER       TunBytesSent;
    ULARGE_INTEGER       TunBytesRecv;
    ULARGE_INTEGER       OffloadedBytesSent;
    ULARGE_INTEGER       OffloadedBytesRecv;
} IPSEC_DRIVER_PM_STATS, * PIPSEC_DRIVER_PM_STATS;




typedef struct _IKE_DATA_DEFINITION 
{
	PERF_OBJECT_TYPE 	        IKEObjectType;
	PERF_COUNTER_DEFINITION		AcquireHeapSize;
	PERF_COUNTER_DEFINITION		ReceiveHeapSize;
	PERF_COUNTER_DEFINITION		NegFailure;
	PERF_COUNTER_DEFINITION		AuthFailure;
	PERF_COUNTER_DEFINITION		ISADBSize;
	PERF_COUNTER_DEFINITION		ConnLSize;
	PERF_COUNTER_DEFINITION		MmSA;
	PERF_COUNTER_DEFINITION		QmSA;
	PERF_COUNTER_DEFINITION		SoftSA;	
}	IKE_DATA_DEFINITION , *PIKE_DATA_DEFINITION ;

typedef struct _IKE_PM_STATS
{
        PERF_COUNTER_BLOCK        CounterBlock;
	DWORD		          AcquireHeapSize;
	DWORD		          ReceiveHeapSize;
	DWORD		          NegFailure;
	DWORD		          AuthFailure;
	DWORD		          ISADBSize;
	DWORD		          ConnLSize;
	DWORD		          MmSA;
	DWORD		          QmSA;
	DWORD		          SoftSA;	
} IKE_PM_STATS, * PIKE_PM_STATS;

//
// Macro used to create the Perf object counter definitions
//


#define CREATE_COUNTER(counter,scale,detail,type,size)	\
{														\
	sizeof(PERF_COUNTER_DEFINITION),					\
	counter ,											\
	0,													\
	counter ,											\
	0,													\
	scale,												\
	detail,												\
	type,												\
	size,												\
	NUM_##counter##_OFFSET							    \
}


extern IPSEC_DRIVER_DATA_DEFINITION  gIPSecDriverDataDefinition;
extern IKE_DATA_DEFINITION           gIKEDataDefinition;


#endif //_DATAIPSEC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\ipsecprf\makefile.inc ===
ver.rc: rasctrs.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\ipsecprf\perfipsec.h ===
#ifndef _PERFIPSEC_H_
#define _PERFIPSEC_H_

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];      
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)

#define ALIGN8(_x)   (((_x) + 7) & ~7)

#define IPSEC_PERF_REG_KEY       "SYSTEM\\CurrentControlSet\\Services\\IPSec\\Performance"
#define IPSEC_PERF_FIRST_COUNTER "First Counter"
#define IPSEC_PERF_FIRST_HELP    "First Help"
#define IPSEC_POLAGENT_NAME	 "PolicyAgent"

//
//  Function Prototypes
//
//      these are used to insure that the data collection functions
//      accessed by Perflib will have the correct calling format.
//

PM_OPEN_PROC            OpenIPSecPerformanceData;
PM_COLLECT_PROC         CollectIPSecPerformanceData;
PM_CLOSE_PROC           CloseIPSecPerformanceData;



DWORD
DwInitializeIPSecCounters(
VOID
);


DWORD
GetDriverData( 
	PVOID *lppData 
);

DWORD 
GetIKEData(
	PVOID *lppData 
);

ULONG 
GetSpaceNeeded( 
	BOOL IsIPSecDriverObject, 
	BOOL IsIKEObject 
);


DWORD
GetQueryType (
    IN LPWSTR lpValue
);

BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
);

BOOL
FIPSecStarted(
	VOID
);


BOOL 
UpdateDataDefFromRegistry( 
	VOID 
);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\address.h ===
DWORD
VerifyAddresses(
    PADDR pAddr,
    BOOL bAcceptMe,
    BOOL bIsDesAddr
    );

BOOL
EqualAddresses(
    IN ADDR_V4 OldAddr,
    IN ADDR_V4 NewAddr
    );

VOID
CopyAddresses(
    IN  ADDR_V4    InAddr,
    OUT PADDR_V4   pOutAddr
    );

BOOL
AddressesConflict(
    ADDR    SrcAddr,
    ADDR    DesAddr
    );

VOID
FreeAddresses(
    ADDR    Addr
    );

DWORD
VerifySubNetAddress(
    ULONG uSubNetAddr,
    ULONG uSubNetMask,
    BOOL bIsDesAddr
    );

BOOL
bIsValidIPMask(
    ULONG uMask
    );

BOOL
bIsValidIPAddress(
    ULONG uIpAddr,
    BOOL bAcceptMe,
    BOOL bIsDesAddr
    );

BOOL
bIsValidSubnet(
    ULONG uIpAddr,
    ULONG uMask,
    BOOL bIsDesAddr
    );

BOOL
MatchAddresses(
    ADDR_V4 AddrToMatch,
    ADDR AddrTemplate
    );

DWORD
ApplyMulticastFilterValidation(
    ADDR Addr,
    BOOL bCreateMirror
    );

BOOL
EqualExtIntAddresses(
    IN ADDR_V4 OldAddr,
    IN ADDR NewAddr
    );

VOID
CopyExtToIntAddresses(
    IN  ADDR       InAddr,
    OUT PADDR_V4   pOutAddr
    );

DWORD
CopyIntToExtAddresses(
    IN  ADDR_V4    InAddr,
    OUT PADDR      pOutAddr
    );

DWORD
ValidateAddr(
    PADDR pAddr
    );

DWORD
ValidateDeleteQMSAs(
    PIPSEC_QM_FILTER pIpsecQMFilter
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\address.c ===
#include"precomp.h"


DWORD
VerifyAddresses(
    PADDR pAddr,
    BOOL bAcceptMe,
    BOOL bIsDesAddr
    )
{
    DWORD   dwError = 0;
    BOOL    bIsValid = FALSE;

    switch (pAddr->AddrType) {

    case IP_ADDR_UNIQUE:
        bIsValid = bIsValidIPAddress(
                       ntohl(pAddr->uIpAddr),
                       bAcceptMe,
                       bIsDesAddr
                       );
        if (!bIsValid) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        if (pAddr->pgInterfaceID) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;

    case IP_ADDR_SUBNET:
        dwError = VerifySubNetAddress(
                      ntohl(pAddr->uIpAddr),
                      ntohl(pAddr->uSubNetMask),
                      bIsDesAddr
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        if (pAddr->pgInterfaceID) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;

    case IP_ADDR_INTERFACE:
        if (pAddr->uIpAddr) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        if (!(pAddr->pgInterfaceID)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;
    default:
        if (!IsSpecialServ(pAddr->AddrType)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;
    }

error:

    return (dwError);
}


BOOL
EqualAddresses(
    IN ADDR_V4 OldAddr,
    IN ADDR_V4 NewAddr
    )
{
    BOOL bMatches = FALSE;

    if (OldAddr.AddrType == NewAddr.AddrType) {
        switch(OldAddr.AddrType) {
        case IP_ADDR_UNIQUE:
            if (OldAddr.uIpAddr == NewAddr.uIpAddr) {
                bMatches = TRUE;
            }
            break;
        case IP_ADDR_SUBNET:
            if ((OldAddr.uIpAddr == NewAddr.uIpAddr) && 
                (OldAddr.uSubNetMask == NewAddr.uSubNetMask)) {
                bMatches = TRUE;
            }
            break;
        case IP_ADDR_INTERFACE:
            if (!memcmp(
                     &OldAddr.gInterfaceID,
                     &NewAddr.gInterfaceID,
                     sizeof(GUID)) &&
                (OldAddr.uIpAddr == NewAddr.uIpAddr)) {
                bMatches = TRUE;
            }
            break;
        }
    }

    return (bMatches);
}


VOID
CopyAddresses(
    IN  ADDR_V4    InAddr,
    OUT PADDR_V4   pOutAddr
    )
{
    pOutAddr->AddrType = InAddr.AddrType;
    switch (InAddr.AddrType) {
    case IP_ADDR_UNIQUE:
        pOutAddr->uIpAddr = InAddr.uIpAddr;
        pOutAddr->uSubNetMask = IP_ADDRESS_MASK_NONE;
        memset(&pOutAddr->gInterfaceID, 0, sizeof(GUID));
        break;
    case IP_ADDR_SUBNET:
        pOutAddr->uIpAddr = InAddr.uIpAddr;
        pOutAddr->uSubNetMask = InAddr.uSubNetMask;
        memset(&pOutAddr->gInterfaceID, 0, sizeof(GUID));
        break;
    case IP_ADDR_INTERFACE:
        pOutAddr->uIpAddr = InAddr.uIpAddr;
        pOutAddr->uSubNetMask = IP_ADDRESS_MASK_NONE;
        memcpy(
            &pOutAddr->gInterfaceID,
            &InAddr.gInterfaceID,
            sizeof(GUID)
            );
        break;
    default:
        if (IsSpecialServ(InAddr.AddrType)) {
            pOutAddr->uIpAddr = InAddr.uIpAddr;
            pOutAddr->uSubNetMask = IP_ADDRESS_MASK_NONE;
            memset(&pOutAddr->gInterfaceID, 0, sizeof(GUID));
        }    
        break;
    }
}


BOOL
AddressesConflict(
    ADDR    SrcAddr,
    ADDR    DesAddr
    )
{
    if ((SrcAddr.AddrType == IP_ADDR_UNIQUE) &&
        (DesAddr.AddrType == IP_ADDR_UNIQUE)) {

        if (SrcAddr.uIpAddr == DesAddr.uIpAddr) {
            return (TRUE);
        }

    }

    if ((SrcAddr.AddrType == IP_ADDR_INTERFACE) &&
        (DesAddr.AddrType == IP_ADDR_INTERFACE)) {
        return (TRUE);
    }

   if (IsSpecialServ(SrcAddr.AddrType) &&
       (SrcAddr.AddrType == DesAddr.AddrType)) {
        return (TRUE);
   }

    return (FALSE);
}


VOID
FreeAddresses(
    ADDR    Addr
    )
{
    switch (Addr.AddrType) {

    case (IP_ADDR_UNIQUE):
    case (IP_ADDR_SUBNET):
    case (IP_ADDR_INTERFACE):
        break;

    }
}


DWORD
VerifySubNetAddress(
    ULONG uSubNetAddr,
    ULONG uSubNetMask,
    BOOL bIsDesAddr
    )
{
    DWORD dwError = 0;
    BOOL  bIsValid = FALSE;

    if (uSubNetAddr == SUBNET_ADDRESS_ANY) {
        if (uSubNetMask != SUBNET_MASK_ANY) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    else {
        bIsValid = bIsValidSubnet(
                       uSubNetAddr,
                       uSubNetMask,
                       bIsDesAddr
                       );
        if (!bIsValid) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

error:

    return (dwError);
}


BOOL
bIsValidIPMask(
    ULONG uMask
    )
{
    BOOL    bValidMask = FALSE;
    ULONG   uTestMask = 0;

    //
    // Mask must be contiguous bits.
    //

    for (uTestMask = 0xFFFFFFFF; uTestMask; uTestMask <<= 1) {

        if (uTestMask == uMask) {
            bValidMask = TRUE;
            break;
        }

    }

    return (bValidMask);
}


BOOL
bIsValidIPAddress(
    ULONG uIpAddr,
    BOOL bAcceptMe,
    BOOL bIsDesAddr
    )
{
    ULONG uHostMask = IN_CLASSA_HOST;   // Default host mask.


    //
    // Accept the address if its "me".
    //

    if (bAcceptMe) {
        if (uIpAddr == IP_ADDRESS_ME) {
            return TRUE;
        }
    }

    //
    // Reject if its a multicast address and is not the 
    // destination address.
    //

    if (IN_CLASSD(uIpAddr)) {
        if (bIsDesAddr) {
            return TRUE;
        }
        else {
            return FALSE;
        }
    }

    //
    // Reject if its a Class E address.
    //

    if (IN_CLASSE(uIpAddr)) {
        return FALSE;
    }

    //
    // Reject if the first octet is zero.
    //

    if (!(IN_CLASSA_NET & uIpAddr)) {
        return FALSE;
    }

    return TRUE;
}


BOOL
bIsValidSubnet(
    ULONG uIpAddr,
    ULONG uMask,
    BOOL bIsDesAddr
    )
{
    ULONG uHostMask = 0;


    //
    // Reject if its a multicast address and is not the 
    // destination address.
    //

    if (IN_CLASSD(uIpAddr)) {
        if (!bIsDesAddr) {
            return FALSE;
        }
    }

    //
    // Reject if its a Class E address.
    //

    if (IN_CLASSE(uIpAddr)) {
        return FALSE;
    }

    //
    // Reject if the first octet is zero.
    //

    if (!(IN_CLASSA_NET & uIpAddr)) {
        return FALSE;
    }

    //
    // If the mask is invalid then return.
    //

    if (!bIsValidIPMask(uMask)) {
        return FALSE;
    }

    //
    // Use the provided subnet mask to generate the host mask.
    //

    uHostMask = 0xFFFFFFFF ^ uMask;

    //
    // Accept address only when the host portion is zero, network
    // portion is non-zero and first octet is non-zero.
    //

    if (!(uHostMask & uIpAddr) &&
        (uMask & uIpAddr) && 
        (IN_CLASSA_NET & uIpAddr)) {
        return TRUE;
    }

    return FALSE;
}


BOOL
MatchAddresses(
    ADDR_V4 AddrToMatch,
    ADDR AddrTemplate
    )
{

    switch (AddrTemplate.AddrType) {

    case IP_ADDR_UNIQUE:
        if ((AddrToMatch.uIpAddr & AddrToMatch.uSubNetMask) !=
            (AddrTemplate.uIpAddr & AddrToMatch.uSubNetMask)) {
            return (FALSE);
        }
        break;

    case IP_ADDR_SUBNET:
        if ((AddrToMatch.uIpAddr & AddrToMatch.uSubNetMask) !=
            ((AddrTemplate.uIpAddr & AddrTemplate.uSubNetMask)
            & AddrToMatch.uSubNetMask)) {
            return (FALSE);
        }
        break;

    case IP_ADDR_INTERFACE:
        if (memcmp(
                &AddrToMatch.gInterfaceID,
                AddrTemplate.pgInterfaceID,
                sizeof(GUID))) {
            return (FALSE);
        }
        break;
    default:
        if (IsSpecialServ(AddrTemplate.AddrType) 
            && IsSpecialServ(AddrToMatch.AddrType)) {
            return (AddrTemplate.AddrType == AddrToMatch.AddrType);
        }
        break;
    }

    return (TRUE);
}


DWORD
ApplyMulticastFilterValidation(
    ADDR Addr,
    BOOL bCreateMirror
    )
{
    DWORD dwError = 0;


    if (((Addr.AddrType == IP_ADDR_UNIQUE) ||
        (Addr.AddrType == IP_ADDR_SUBNET)) &&
        (IN_CLASSD(ntohl(Addr.uIpAddr))) &&
        bCreateMirror) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    return (dwError);
}


BOOL
EqualExtIntAddresses(
    IN ADDR_V4 OldAddr,
    IN ADDR NewAddr
    )
{
    BOOL bMatches = FALSE;

    if (OldAddr.AddrType == NewAddr.AddrType) {
        switch(OldAddr.AddrType) {
        case IP_ADDR_UNIQUE:
            if (OldAddr.uIpAddr == NewAddr.uIpAddr) {
                bMatches = TRUE;
            }
            break;
        case IP_ADDR_SUBNET:
            if ((OldAddr.uIpAddr == NewAddr.uIpAddr) && 
                (OldAddr.uSubNetMask == NewAddr.uSubNetMask)) {
                bMatches = TRUE;
            }
            break;
        case IP_ADDR_INTERFACE:
            if (!memcmp(
                     &OldAddr.gInterfaceID,
                     NewAddr.pgInterfaceID,
                     sizeof(GUID)) &&
                (OldAddr.uIpAddr == NewAddr.uIpAddr)) {
                bMatches = TRUE;
            }
            break;
        default:
            if (IsSpecialServ(OldAddr.AddrType)) {
               bMatches = TRUE;
            }
            break;
        }
    }

    return (bMatches);
}


VOID
CopyExtToIntAddresses(
    IN  ADDR       InAddr,
    OUT PADDR_V4   pOutAddr
    )
{
    pOutAddr->AddrType = InAddr.AddrType;
    switch (InAddr.AddrType) {
    case IP_ADDR_UNIQUE:
        pOutAddr->uIpAddr = InAddr.uIpAddr;
        pOutAddr->uSubNetMask = IP_ADDRESS_MASK_NONE;
        memset(&pOutAddr->gInterfaceID, 0, sizeof(GUID));
        break;
    case IP_ADDR_SUBNET:
        pOutAddr->uIpAddr = InAddr.uIpAddr;
        pOutAddr->uSubNetMask = InAddr.uSubNetMask;
        memset(&pOutAddr->gInterfaceID, 0, sizeof(GUID));
        break;
    case IP_ADDR_INTERFACE:
        pOutAddr->uIpAddr = InAddr.uIpAddr;
        pOutAddr->uSubNetMask = IP_ADDRESS_MASK_NONE;
        memcpy(
            &pOutAddr->gInterfaceID,
            InAddr.pgInterfaceID,
            sizeof(GUID)
            );
        break;
    default:
        if (IsSpecialServ(InAddr.AddrType)) {
            pOutAddr->uIpAddr = InAddr.uIpAddr;
            pOutAddr->uSubNetMask = IP_ADDRESS_MASK_NONE;
            memset(&pOutAddr->gInterfaceID, 0, sizeof(GUID));
        }
        break;
    }
}


DWORD
CopyIntToExtAddresses(
    IN  ADDR_V4    InAddr,
    OUT PADDR      pOutAddr
    )
{
    DWORD dwError = 0;


    pOutAddr->AddrType = InAddr.AddrType;
    switch (InAddr.AddrType) {
    case IP_ADDR_UNIQUE:
        pOutAddr->uIpAddr = InAddr.uIpAddr;
        pOutAddr->uSubNetMask = IP_ADDRESS_MASK_NONE;
        pOutAddr->pgInterfaceID = NULL;
        break;
    case IP_ADDR_SUBNET:
        pOutAddr->uIpAddr = InAddr.uIpAddr;
        pOutAddr->uSubNetMask = InAddr.uSubNetMask;
        pOutAddr->pgInterfaceID = NULL;
        break;
    case IP_ADDR_INTERFACE:
        pOutAddr->uIpAddr = InAddr.uIpAddr;
        pOutAddr->uSubNetMask = IP_ADDRESS_MASK_NONE;
        dwError = SPDApiBufferAllocate(
                    sizeof(GUID),
                    &(pOutAddr->pgInterfaceID)
                    );
        BAIL_ON_WIN32_ERROR(dwError);
        memcpy(
            pOutAddr->pgInterfaceID,
            &InAddr.gInterfaceID,
            sizeof(GUID)
            );
        break;
     default:
        if (IsSpecialServ(InAddr.AddrType)) {
            pOutAddr->uIpAddr = InAddr.uIpAddr;
            pOutAddr->uSubNetMask = IP_ADDRESS_MASK_NONE;
            pOutAddr->pgInterfaceID = NULL;
        }
        break;
     
    }

error:

    return (dwError);
}

DWORD
ValidateAddr(
    PADDR pAddr
    )
{
    DWORD dwError = 0;

__try {
    if (pAddr->AddrType == IP_ADDR_INTERFACE) {
        if (!(pAddr->pgInterfaceID)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    else {
        if (pAddr->pgInterfaceID) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
} __except(EXCEPTION_EXECUTE_HANDLER) {
    dwError = ERROR_INVALID_PARAMETER;
}
    
error:

    return (dwError);
}


DWORD
ValidateQMFilterAddresses(
    PIPSEC_QM_FILTER pIpsecQMFilter
    )
{
    DWORD dwError = 0;


    dwError = ValidateAddr(&(pIpsecQMFilter->SrcAddr));
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateAddr(&(pIpsecQMFilter->DesAddr));
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateAddr(&(pIpsecQMFilter->MyTunnelEndpt));
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateAddr(&(pIpsecQMFilter->PeerTunnelEndpt));
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\audit.h ===
DWORD
PerformAudit(
    DWORD dwCategoryId,
    DWORD dwAuditId,
    PSID pSid,
    DWORD dwParamCnt,
    LPWSTR * ppszArgArray,
    BOOL bSuccess,
    BOOL bDoAudit
    );

VOID
AuditEvent(
    DWORD dwCategoryId,
    DWORD dwAuditId,
    DWORD dwStrId,
    LPWSTR * ppszArguments,
    BOOL bSuccess,
    BOOL bDoAudit
    );

VOID
AuditOneArgErrorEvent(
    DWORD dwCategoryId,
    DWORD dwAuditId,
    DWORD dwStrId,
    DWORD dwErrorCode,
    BOOL bSuccess,
    BOOL bDoAudit
    );

VOID
AuditIPSecPolicyEvent(
    DWORD dwCategoryId,
    DWORD dwAuditId,
    DWORD dwStrId,
    LPWSTR pszPolicyName,
    BOOL bSuccess,
    BOOL bDoAudit
    );

VOID
AuditIPSecPolicyErrorEvent(
    DWORD dwCategoryId,
    DWORD dwAuditId,
    DWORD dwStrId,
    LPWSTR pszPolicyName,
    DWORD dwErrorCode,
    BOOL bSuccess,
    BOOL bDoAudit
    );

#define UKNOWN_POLICY_NAME L"???"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\ipsecprf\perfipsec.c ===
/*++ 

Copyright (c) 2002  Microsoft Corporation

Module Name:

    perfipsec.c

Abstract:

    This file implements the Extensible Objects for  the IPsec object type

Created:

    Avnish Kumar Chhabra      09 July 2002

Revision History

--*/

//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntddser.h>

#include <windows.h>
#include <string.h>
#include <wcstr.h>
#include <winperf.h>

#include <malloc.h>
#include <ntprfctr.h>

#include <winipsec.h>
#include "perfipsec.h"
#include "dataipsec.h"
#include "ipsecnm.h"

//
// Determines whether counter name and help indices have been correctly initialized
// 1) This is set to TRUE after one successful call to UpdateDataDefFromRegistry.
// 2) While this is TRUE ; DwInitializeIPSecCounters need not be called.
//
BOOL    g_bInitOK = FALSE;        // true = DLL initialized OK
//
// The number of threads that have called open but not called close as yet
// 1) Needed to initialize the critical section g_csPerf when the first client calls open
// 2) Needed to delete the critical section once all clients have called close
//
DWORD   g_dwOpenCount = 0;        // count of "Open" threads
//
// Critical section used to serialize access t o UpDateDataDefFromRegistry
// This prevents multiple concurrent threads from entering this function
// and adding the base offset to counter indices multiple times .
//
CRITICAL_SECTION g_csPerf;
//
// Contant strings used to identify the nature of the collect request.
//
WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";






//***
//
// Routine Description:
//
//      This routine will initialize the entry points into winipsec.dll 
//       which will be used to communicate statistics with SPD
// Arguments:
//
//      Pointer to object ID of each device to be opened 
//
//
// Return Value:
//
//      None.
//
//***

DWORD 
OpenIPSecPerformanceData(
        LPWSTR lpDeviceNames 
    )
{

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //

    // First call into this function 
    if (!g_dwOpenCount){
        InitializeCriticalSection(&g_csPerf);
    }
    g_dwOpenCount++;
    
    //
    //  Do we need to initialize the counter name and help indicess
    //
    if (!g_bInitOK){
        DwInitializeIPSecCounters();
    }
    return ERROR_SUCCESS;
}

DWORD
DwInitializeIPSecCounters(
    VOID
)
{
    LONG status = ERROR_SUCCESS;
    // Serialize access to index update routine
    EnterCriticalSection(&g_csPerf);
    if (g_bInitOK){
        goto EXIT;
    }

    //
    // Update the IPsec Driver and IKE counter's name and help indices
    //
    if (UpdateDataDefFromRegistry()){
        status = ERROR_SUCCESS; // for successful exit
        g_bInitOK = TRUE; // No need to reinitialize indices after this
    }
    else{
        status = ERROR_REGISTRY_IO_FAILED;
    }
    
    EXIT:
        
    LeaveCriticalSection(&g_csPerf);
    return status;
}



//************
//
//  Function:   UpdateDataDefFromRegistry
//
//  Synopsis:   Gets counter and help index base values from registry as follows :
//              1) Open key to registry entry
//              2) Read First Counter and First Help values
//              3) Update static data strucutures gIPSecDriverDataDefnition by adding base to
//                 offset value in structure.
//
//  Arguments:  None
//
//  Returns:    TRUE if succeeds, FALSE otherwise
//
//*************
BOOL UpdateDataDefFromRegistry(
    VOID
)
{

    HKEY hKeyDriverPerf;
    DWORD status;
    DWORD type;
    DWORD size; 
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;
    PERF_COUNTER_DEFINITION *pctr;
    DWORD i;
    BOOL fRetValue = TRUE, fKeyOpened=FALSE;

    status = RegOpenKeyEx (
        HKEY_LOCAL_MACHINE,
        IPSEC_PERF_REG_KEY,
        0L,
        KEY_READ,
        &hKeyDriverPerf);


    if (status != ERROR_SUCCESS) {
     //
     // this is fatal, if we can't get the base values of the
     // counter or help names, then the names won't be available
     // to the requesting application so there's not much
     // point in continuing.
     //
     fRetValue= FALSE;
     goto EXIT;
    }

    fKeyOpened=TRUE;

    size = sizeof (DWORD);
    status = RegQueryValueEx(
            hKeyDriverPerf,
            IPSEC_PERF_FIRST_COUNTER,
            0L,
            &type,
            (LPBYTE)&dwFirstCounter,
            &size);

    if (status != ERROR_SUCCESS) {
        //
        // this is fatal, if we can't get the base values of the
        // counter or help names, then the names won't be available
        // to the requesting application  so there's not much
        // point in continuing.
        //
        fRetValue = FALSE;
        goto EXIT;
    }

    size = sizeof (DWORD);
    status = RegQueryValueEx(
            hKeyDriverPerf,
            IPSEC_PERF_FIRST_HELP,
            0L,
            &type,
            (LPBYTE)&dwFirstHelp,
            &size);

    if (status != ERROR_SUCCESS) {
        //
        // this is fatal, if we can't get the base values of the
        // counter or help names, then the names won't be available
        // to the requesting application  so there's not much
        // point in continuing.
        //
        fRetValue = FALSE;
        goto EXIT;
    }

    //
    // We can not fail now 
    //

    fRetValue = TRUE;

    //
    // Initialize counter object indices
    //
    gIPSecDriverDataDefinition.IPSecObjectType.ObjectNameTitleIndex += dwFirstCounter;
    gIPSecDriverDataDefinition.IPSecObjectType.ObjectHelpTitleIndex += dwFirstHelp;

    //    
    // Initialize all IPSec Driver counter's indices
    //
    pctr = &gIPSecDriverDataDefinition.ActiveSA;
    for( i=0; i<NUM_OF_IPSEC_DRIVER_COUNTERS; i++ ){
        pctr->CounterNameTitleIndex += dwFirstCounter;
        pctr->CounterHelpTitleIndex += dwFirstHelp;
        pctr ++;
    }


    gIKEDataDefinition.IKEObjectType.ObjectNameTitleIndex += dwFirstCounter;
    gIKEDataDefinition.IKEObjectType.ObjectHelpTitleIndex += dwFirstHelp;

    //    
    // Initialize all IKE counter's indices
    //
    pctr = &gIKEDataDefinition.AcquireHeapSize;
    for( i=0; i<NUM_OF_IKE_COUNTERS; i++ ){
        pctr->CounterNameTitleIndex += dwFirstCounter;
        pctr->CounterHelpTitleIndex += dwFirstHelp;
        pctr ++;
    }


    EXIT:

    if (fKeyOpened){
    //
    // close key to registry
    //
    RegCloseKey (hKeyDriverPerf); 
    }

    return fRetValue;
}

//***
//
// Routine Description:
//
//      This routine will return the data for the IPSec counters.
//
// Arguments:
//
//    IN OUT    LPWSTR  lpValueName
//              pointer to a wide character string passed by registry.
//
//    IN OUT	LPVOID   *lppData
//    IN:	    pointer to the address of the buffer to receive the completed
//              PerfDataBlock and subordinate structures. This routine will
//              append its data to the buffer starting at the point referenced
//              by *lppData.
//    OUT:	    points to the first byte after the data structure added by this
//              routine. This routine updated the value at lppdata after appending
//              its data.
//
//    IN OUT	LPDWORD  lpcbTotalBytes
//    IN:       the address of the DWORD that tells the size in bytes of the
//              buffer referenced by the lppData argument
//    OUT:      the number of bytes added by this routine is written to the
//              DWORD pointed to by this argument
//
//    IN OUT    LPDWORD  NumObjectTypes
//    IN:       the address of the DWORD to receive the number of objects added
//              by this routine
//    OUT:      the number of objects added by this routine is written to the
//              DWORD pointed to by this argument
//
// Return Value:
//
//    ERROR_MORE_DATA if buffer passed is too small to hold data
//    any error conditions encountered are reported to the event log if
//    event logging is enabled.
//
//    ERROR_SUCCESS   if success or any other error. Errors, however are
//    also reported to the event log.
//
//***

DWORD CollectIPSecPerformanceData(
    IN      LPWSTR  lpValueName,
    IN OUT  LPVOID  *lppData,
    IN OUT  LPDWORD lpcbTotalBytes,
    IN OUT  LPDWORD lpNumObjectTypes 
)
{
    DWORD dwQueryType;
    BOOL IsIPSecDriverObject = FALSE ,IsIKEObject = FALSE;
    ULONG SpaceNeeded =0;
    DWORD status;

    //
    // Initialize the counter indices if neccessary
    //
    if (!g_bInitOK){
        DwInitializeIPSecCounters();
    }

    //
    // Make sure that
    // (a) Counter indices have been initialized
    // (b) IPsec service is presently running
    //
    
    if ((!g_bInitOK) || (!FIPSecStarted())){
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; 
    }

    dwQueryType = GetQueryType (lpValueName);

    //
    // see if this is a foreign (i.e. non-NT) computer data request
    //

    if (dwQueryType == QUERY_FOREIGN){
        
        //
        // this routine does not service requests for data from
        // Non-NT computers
        //
        
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }
    else if (dwQueryType == QUERY_ITEMS){
        IsIPSecDriverObject = IsNumberInUnicodeList (gIPSecDriverDataDefinition.IPSecObjectType.ObjectNameTitleIndex,
        lpValueName);

        IsIKEObject = IsNumberInUnicodeList (gIKEDataDefinition.IKEObjectType.ObjectNameTitleIndex,
        lpValueName);

        if ( !IsIPSecDriverObject && !IsIKEObject )
        {
            //
            // request received for data object not provided by this routine
            //
            
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }
    else if( dwQueryType == QUERY_GLOBAL )
    {
        IsIPSecDriverObject = IsIKEObject = TRUE;
    }


    //
    // Now check to see if we have enough space to hold all the data
    //

    SpaceNeeded = GetSpaceNeeded(IsIPSecDriverObject, IsIKEObject);

    if ( *lpcbTotalBytes < SpaceNeeded )
    {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    *lpcbTotalBytes = (DWORD) 0;
    *lpNumObjectTypes = (DWORD) 0;


    //
    // Then we fill in the data for object ipsec driver, if needed.
    //

    if( IsIPSecDriverObject )
    {
        PIPSEC_DRIVER_DATA_DEFINITION pIPSecDriverDataDefinition;
        PVOID   pData;

        pIPSecDriverDataDefinition = (PIPSEC_DRIVER_DATA_DEFINITION) *lppData;

        //
        // Copy the (constant, initialized) Object Type and counter definitions
        // to the caller's data buffer
        //

        memcpy( pIPSecDriverDataDefinition,
        &gIPSecDriverDataDefinition,
        sizeof(IPSEC_DRIVER_DATA_DEFINITION));

        //
        // Now copy the counter block.
        //
        
        pData = (PBYTE) pIPSecDriverDataDefinition + ALIGN8(sizeof(IPSEC_DRIVER_DATA_DEFINITION));

        status = GetDriverData( &pData );
        if (ERROR_SUCCESS == status){
            
            //
            // Set *lppData to the next available byte.
            //
            
            *lppData = pData;
            (*lpNumObjectTypes)++;
        }
    }

    if (IsIKEObject)
    {
        PIKE_DATA_DEFINITION pIKEDataDefinition;
        PVOID pData;

        pIKEDataDefinition = (PIKE_DATA_DEFINITION)*lppData;

        //
        // Copy the (Constant,initialized) Object Type and counter definitions
        // to the callers Datan Buffer
        //
        
        memcpy(pIKEDataDefinition,
        &gIKEDataDefinition,
        sizeof(IKE_DATA_DEFINITION));
        
        //
        // Now copy the counter block
        //
        
        pData = (PBYTE)pIKEDataDefinition +  ALIGN8(sizeof(IKE_DATA_DEFINITION));

        status = GetIKEData(&pData);
        if (ERROR_SUCCESS == status){
            
            //
            // Set *lppData to the next available byte
            //
            
            *lppData = pData;
            (*lpNumObjectTypes)++;
        }
    }

    if (ERROR_SUCCESS == status){
        *lpcbTotalBytes = SpaceNeeded;
    }

    return ERROR_SUCCESS;
}


//***
//
// Routine Description:
//
//      This routine closes the open handles to IPSec device performance
//      counters.
//
// Arguments:
//
//      None.
//
// Return Value:
//
//      ERROR_SUCCESS
//
//***

DWORD 
CloseIPSecPerformanceData(
    VOID
)
{
    if (!(--g_dwOpenCount))
    {
        //
        // when this is the last thread...
        //
        
        EnterCriticalSection(&g_csPerf);
        DeleteCriticalSection(&g_csPerf);
    }
    return ERROR_SUCCESS;
}

//***
//
// Routine Description:
//
//      This routine closes fetched IKE statistics from SPD and puts it into Perfmon's buffers
//
// Arguments:
//
//      IN OUT  PVOID * lppData
//      IN :    Contains the pointer to the location where the counter stats can be placed
//      OUT:    Contains the pointer to the first byte after the counter stats
// Return Value:
//
//      ERROR_SUCCESS
//
//***



DWORD 
GetIKEData(
    IN OUT PVOID *lppData 
)
{
    IKE_PM_STATS UNALIGNED * pIKEPMStats;
    DWORD status;
    IKE_STATISTICS IKEStats;


    pIKEPMStats = (IKE_PM_STATS UNALIGNED *)*lppData;
    pIKEPMStats->CounterBlock.ByteLength = ALIGN8(SIZEOF_IPSEC_TOTAL_IKE_DATA);
    status = QueryIKEStatistics(NULL, 0,&IKEStats, NULL );

    if ( status != ERROR_SUCCESS) {
        return status;
    }

    //
    // Go to end of PerfCounterBlock to get array of counters
    //

    pIKEPMStats->AcquireHeapSize = IKEStats.dwAcquireHeapSize;
    pIKEPMStats->ReceiveHeapSize = IKEStats.dwReceiveHeapSize;
    pIKEPMStats->NegFailure = IKEStats.dwNegotiationFailures;
    pIKEPMStats->AuthFailure = IKEStats.dwAuthenticationFailures;
    pIKEPMStats->ISADBSize = IKEStats.dwIsadbListSize;
    pIKEPMStats->ConnLSize = IKEStats.dwConnListSize;
    pIKEPMStats->MmSA = IKEStats.dwOakleyMainModes;
    pIKEPMStats->QmSA = IKEStats.dwOakleyQuickModes;
    pIKEPMStats->SoftSA = IKEStats.dwSoftAssociations;

    //
    // Update *lppData to the next available byte.
    //

    *lppData = (PVOID) ((PBYTE) pIKEPMStats + pIKEPMStats->CounterBlock.ByteLength);
    return ERROR_SUCCESS;
}

//***
//
// Routine Description:
//
//      This routine closes fetched IPSec driver statistics from SPD and puts it into Perfmon's 
//      buffers
//
// Arguments:
//
//      IN OUT  PVOID * lppData
//      IN :    Contains the pointer to the location where the counter stats can be placed
//      OUT:    Contains the pointer to the first byte after the counter stats
// Return Value:
//
//      ERROR_SUCCESS
//
//***

DWORD 
GetDriverData( 
    PVOID *lppData 
)
{
    IPSEC_DRIVER_PM_STATS UNALIGNED * pIPSecPMStats;
    DWORD status = ERROR_SUCCESS;
    PIPSEC_STATISTICS  pIPSecStats;
    IPSEC_STATISTICS IPSecStats;
    
    pIPSecPMStats = (IPSEC_DRIVER_PM_STATS UNALIGNED *) *lppData;
    pIPSecPMStats->CounterBlock.ByteLength = ALIGN8(SIZEOF_IPSEC_TOTAL_DRIVER_DATA);

    status = QueryIPSecStatistics(NULL,0,&pIPSecStats,NULL);
    
    if (status != ERROR_SUCCESS) {
      return status;
    }

    IPSecStats = *pIPSecStats;
    SPDApiBufferFree(pIPSecStats);

    //
    // Go to end of PerfCounterBlock to get of array of counters
    //


   pIPSecPMStats->ActiveSA= IPSecStats.dwNumActiveAssociations;
   pIPSecPMStats->OffloadedSA= IPSecStats.dwNumOffloadedSAs;
   pIPSecPMStats->PendingKeyOps= IPSecStats.dwNumPendingKeyOps;
   pIPSecPMStats->Rekey= IPSecStats.dwNumReKeys;
   pIPSecPMStats->BadSPIPackets= IPSecStats.dwNumBadSPIPackets;
   pIPSecPMStats->PacketsNotDecrypted= IPSecStats.dwNumPacketsNotDecrypted;
   pIPSecPMStats->PacketsNotAuthenticated= IPSecStats.dwNumPacketsNotAuthenticated;
   pIPSecPMStats->PacketsWithReplayDetection= IPSecStats.dwNumPacketsWithReplayDetection;
   pIPSecPMStats->TptBytesSent= IPSecStats.uTransportBytesSent;
   pIPSecPMStats->TptBytesRecv= IPSecStats.uTransportBytesReceived;
   pIPSecPMStats->TunBytesSent= IPSecStats.uBytesSentInTunnels;
   pIPSecPMStats->TunBytesRecv= IPSecStats.uBytesReceivedInTunnels;
   pIPSecPMStats->OffloadedBytesSent= IPSecStats.uOffloadedBytesSent;
   pIPSecPMStats->OffloadedBytesRecv= IPSecStats.uOffloadedBytesReceived;

  
    //
    // Update *lppData to the next available byte.
    //


    *lppData = (PVOID) ((PBYTE) pIPSecPMStats + pIPSecPMStats->CounterBlock.ByteLength);
    return ERROR_SUCCESS;
}


//***
//
// Routine Description:
//
//      This routine will return the number of Bytes needed for all the
//      objects requested.
//
// Arguments:
//
//      None.
//
// Return Value:
//
//      The number of bytes needed to store stats of requested objects
//
//***

ULONG 
GetSpaceNeeded( 
    BOOL IsIPSecDriverObject, 
    BOOL IsIKEObject 
)
{
    ULONG       Space = 0;
    
    if( IsIPSecDriverObject )
    {
        Space += gIPSecDriverDataDefinition.IPSecObjectType.TotalByteLength;
    }
    
    if( IsIKEObject )
    {
        Space += gIKEDataDefinition.IKEObjectType.TotalByteLength;
    }
    return Space;
}

DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to CollectIPSecPerformanceData for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;

    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request

    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request

    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string

    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly,
    // then it must be an item list

    return QUERY_ITEMS;

}


BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:

    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    BOOL    bReturnValue;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;

    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;

            case DELIMITER:
                // a delimter is either the delimiter character or the
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList

BOOL
FIPSecStarted(VOID)
{
    SC_HANDLE schandle = NULL;
    SC_HANDLE svchandle = NULL;
    BOOL fRet = FALSE;
    
    //
    // Check to see if ipsec service is started.
    // fail if it isn't.
    //
    schandle = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

    if(NULL != schandle)
    {
        svchandle = OpenService(schandle,
                                IPSEC_POLAGENT_NAME,
                                SERVICE_QUERY_STATUS);

        if(NULL != svchandle)
        {
            SERVICE_STATUS status;
            
            if(     (QueryServiceStatus(svchandle, &status))
                &&  (status.dwCurrentState == SERVICE_RUNNING))
            {
                fRet = TRUE;
            }

            CloseServiceHandle(svchandle);
        }

        CloseServiceHandle(schandle);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\audit.c ===
#include "precomp.h"


#define MAX_AUDIT_BUFFER    4096

#define MAX_MSG_BUFFER      2048

WCHAR gszAuditBuffer[MAX_AUDIT_BUFFER];

WCHAR * gpszAuditBuffer = gszAuditBuffer;

WCHAR gszAuditMsgBuffer[MAX_MSG_BUFFER];

WCHAR * gpszAuditMsgBuffer = gszAuditMsgBuffer;

wchar_t * SecStrCpyW(
    wchar_t * strDest,          // Destination
    const wchar_t * strSource,  // Source
    SIZE_T destSize             // Total size of Destination in characters.
    )
{
    strDest[destSize-1] = L'\0';    
    return wcsncpy(strDest, strSource, destSize-1);
}


wchar_t * SecStrCatW(
    wchar_t * strDest,          // Destination
    const wchar_t * strSource,  // Source
    SIZE_T destSize             // Total size of Destination in characters.
    )
{
    SSIZE_T spaceLeft = 0;

    spaceLeft = destSize - wcslen(strDest);
    if (spaceLeft > 0) {
        strDest[destSize-1] = L'\0';    
        return wcsncat(strDest, strSource, spaceLeft-1);
    }
    else {
        return NULL;
    }
}


DWORD
PerformAudit(
    DWORD dwCategoryId,
    DWORD dwAuditId,
    PSID pSid,
    DWORD dwParamCnt,
    LPWSTR * ppszArgArray,
    BOOL bSuccess,
    BOOL bDoAudit
    )
{
    SE_ADT_PARAMETER_ARRAY * pParArray = NULL;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    DWORD dwStrSize = 0;
    DWORD i = 0;
    DWORD dwAllocSize = 0;
    BYTE * pbyteCurAddr = NULL;
    DWORD dwSidLength = RtlLengthSid(pSid);
    UNICODE_STRING * pusStrArray = NULL;
    WCHAR * pszModuleName = L"IPSec Server";


    //
    // dwCategoryId should be equal to SE_CATEGID_POLICY_CHANGE.
    //

    dwCategoryId = SE_CATEGID_POLICY_CHANGE;

    for (i = 0; i < dwParamCnt; i++) {
        dwStrSize += (wcslen(ppszArgArray[i]) + 1) * sizeof(WCHAR);
    }

    dwStrSize += (wcslen(pszModuleName) + 1) * sizeof(WCHAR);

    dwAllocSize = sizeof(SE_ADT_PARAMETER_ARRAY) +
                  dwParamCnt * sizeof(UNICODE_STRING) + dwStrSize;
    dwAllocSize += PtrAlignSize(dwSidLength);

    if (dwAllocSize > MAX_AUDIT_BUFFER) {
        return (ERROR_BUFFER_OVERFLOW);
    }

    pParArray = (SE_ADT_PARAMETER_ARRAY *) gpszAuditBuffer;

    pParArray->CategoryId = dwCategoryId;
    pParArray->AuditId = dwAuditId;
    pParArray->ParameterCount = dwParamCnt + 2;
    pParArray->Length = dwAllocSize;
    pParArray->Flags = 0;

    if (bSuccess) {
        pParArray->Type = EVENTLOG_AUDIT_SUCCESS;
    }
    else {
        pParArray->Type = EVENTLOG_AUDIT_FAILURE;
    }

    pbyteCurAddr = (BYTE *) (pParArray + 1);

    pParArray->Parameters[0].Type = SeAdtParmTypeSid;
    pParArray->Parameters[0].Length = dwSidLength;
    pParArray->Parameters[0].Data[0] = 0;
    pParArray->Parameters[0].Data[1] = 0;
    pParArray->Parameters[0].Address = pSid;

    memcpy((BYTE *) pbyteCurAddr, (BYTE *) pSid, dwSidLength);

    pbyteCurAddr = (BYTE *) pbyteCurAddr + PtrAlignSize(dwSidLength);

    pusStrArray = (UNICODE_STRING *) pbyteCurAddr;

    pusStrArray[0].Length = wcslen(pszModuleName) * sizeof(WCHAR);
    pusStrArray[0].MaximumLength = pusStrArray[0].Length + sizeof(WCHAR);
    pusStrArray[0].Buffer = (LPWSTR) pszModuleName;

    pParArray->Parameters[1].Type = SeAdtParmTypeString;
    pParArray->Parameters[1].Length = sizeof(UNICODE_STRING) +
                                      pusStrArray[0].MaximumLength;
    pParArray->Parameters[1].Data[0] = 0;
    pParArray->Parameters[1].Data[1] = 0;
    pParArray->Parameters[1].Address = (PVOID) &pusStrArray[0];

    for (i = 0; i < dwParamCnt; i++) {

        pusStrArray[i+1].Length = wcslen(ppszArgArray[i]) * sizeof(WCHAR);
        pusStrArray[i+1].MaximumLength = pusStrArray[i+1].Length + sizeof(WCHAR);
        pusStrArray[i+1].Buffer = (LPWSTR) ppszArgArray[i];

        pParArray->Parameters[i+2].Type = SeAdtParmTypeString;
        pParArray->Parameters[i+2].Length = sizeof(UNICODE_STRING) +
                                            pusStrArray[i+1].MaximumLength;
        pParArray->Parameters[i+2].Data[0] = 0;
        pParArray->Parameters[i+2].Data[1] = 0;
        pParArray->Parameters[i+2].Address = (PVOID) &pusStrArray[i+1];

    }

    if (bDoAudit) {
        ntStatus = LsaIWriteAuditEvent(pParArray, 0);
    }

    return (ERROR_SUCCESS);
}


VOID
AuditEvent(
    DWORD dwCategoryId,
    DWORD dwAuditId,
    DWORD dwStrId,
    LPWSTR * ppszArguments,
    BOOL bSuccess,
    BOOL bDoAudit
    )
{
    DWORD dwError = 0;
    LPWSTR pszArgArray[3];
    DWORD dwParamCnt = 0;


    EnterCriticalSection(&gcSPDAuditSection);

    dwError = FormatMessage(
                  FORMAT_MESSAGE_FROM_HMODULE |
                  FORMAT_MESSAGE_ARGUMENT_ARRAY,
                  ghIpsecServerModule,
                  dwStrId,
                  LANG_NEUTRAL,
                  gpszAuditMsgBuffer,
                  MAX_MSG_BUFFER,
                  (va_list *) ppszArguments
                  );
    if (dwError == 0) {
        wsprintf(
            gpszAuditMsgBuffer,
            L"IPSec Services encountered an error while auditing event ID 0x%x",
            dwStrId
            );
    }

    gpszAuditMsgBuffer[MAX_MSG_BUFFER - 1] = 0;

    if (dwError != 0) {

       switch (dwAuditId) {

       case SE_AUDITID_IPSEC_POLICY_CHANGED:
           dwParamCnt = 1;
           pszArgArray[0] = (LPWSTR) gpszAuditMsgBuffer;
           break;

       default:
           LeaveCriticalSection(&gcSPDAuditSection);
           return;

       }

       (VOID) PerformAudit(
                  dwCategoryId,
                  dwAuditId,
                  gpIpsecServerSid,
                  dwParamCnt,
                  (LPWSTR *) pszArgArray,
                  bSuccess,
                  bDoAudit
                  );

    }

    LeaveCriticalSection(&gcSPDAuditSection);
    return;
}


VOID
AuditOneArgErrorEvent(
    DWORD dwCategoryId,
    DWORD dwAuditId,
    DWORD dwStrId,
    DWORD dwErrorCode,
    BOOL bSuccess,
    BOOL bDoAudit
    )
{
    DWORD dwError = 0;
    LPVOID lpvMsgBuf = NULL;
    WCHAR szAuditLocalMsgBuffer[MAX_PATH];
    WCHAR * pszAuditLocalMsgBuffer = szAuditLocalMsgBuffer;


    szAuditLocalMsgBuffer[0] = L'\0';

    dwError = FormatMessage(
                  FORMAT_MESSAGE_ALLOCATE_BUFFER |
                  FORMAT_MESSAGE_FROM_SYSTEM |
                  FORMAT_MESSAGE_IGNORE_INSERTS,
                  NULL,
                  dwErrorCode,
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                  (LPWSTR) &lpvMsgBuf,
                  0,
                  NULL
                  );
    if (!dwError) {
        wsprintf(
            pszAuditLocalMsgBuffer,
            L"0x%x",
            dwErrorCode
            );
        AuditEvent(
            dwCategoryId,
            dwAuditId,
            dwStrId,
            (LPWSTR *) &pszAuditLocalMsgBuffer,
            bSuccess,
            bDoAudit
            );
        return;
    }

    AuditEvent(
        dwCategoryId,
        dwAuditId,
        dwStrId,
        (LPWSTR *) &lpvMsgBuf,
        bSuccess,
        bDoAudit
        );

    if (lpvMsgBuf) {
        LocalFree(lpvMsgBuf);
    }

    return;
}


VOID
AuditIPSecPolicyEvent(
    DWORD dwCategoryId,
    DWORD dwAuditId,
    DWORD dwStrId,
    LPWSTR pszPolicyName,
    BOOL bSuccess,
    BOOL bDoAudit
    )
{
    WCHAR szAuditLocalMsgBuffer[MAX_PATH];
    WCHAR * pszAuditLocalMsgBuffer = szAuditLocalMsgBuffer;


    szAuditLocalMsgBuffer[0] = L'\0';
    if (pszPolicyName) {
        SecStrCpyW(pszAuditLocalMsgBuffer, pszPolicyName, MAX_PATH);
    } else {
        SecStrCpyW(pszAuditLocalMsgBuffer, UKNOWN_POLICY_NAME, MAX_PATH);
    }        

    AuditEvent(
        dwCategoryId,
        dwAuditId,
        dwStrId,
        (LPWSTR *) &pszAuditLocalMsgBuffer,
        bSuccess,
        bDoAudit
        );

    return;
}


VOID
AuditIPSecPolicyErrorEvent(
    DWORD dwCategoryId,
    DWORD dwAuditId,
    DWORD dwStrId,
    LPWSTR pszPolicyName,
    DWORD dwErrorCode,
    BOOL bSuccess,
    BOOL bDoAudit
    )
{
    DWORD dwError = 0;
    WCHAR szAuditPolicyMsgBuffer[MAX_PATH];
    WCHAR * pszAuditPolicyMsgBuffer = szAuditPolicyMsgBuffer;
    WCHAR szAuditErrorMsgBuffer[MAX_PATH];
    WCHAR * pszAuditErrorMsgBuffer = szAuditErrorMsgBuffer;
    LPWSTR pszArgArray[2];
    LPWSTR * ppszArgArray = pszArgArray;
    LPVOID lpvMsgBuf = NULL;


    szAuditPolicyMsgBuffer[0] = L'\0';
    szAuditErrorMsgBuffer[0] = L'\0';

    if (pszPolicyName) {
        SecStrCpyW(pszAuditPolicyMsgBuffer, pszPolicyName, MAX_PATH);
    } else {
        SecStrCpyW(pszAuditPolicyMsgBuffer, UKNOWN_POLICY_NAME, MAX_PATH);
    }        

    dwError = FormatMessage(
                  FORMAT_MESSAGE_ALLOCATE_BUFFER |
                  FORMAT_MESSAGE_FROM_SYSTEM |
                  FORMAT_MESSAGE_IGNORE_INSERTS,
                  NULL,
                  dwErrorCode,
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                  (LPWSTR) &lpvMsgBuf,
                  0,
                  NULL
                  );
    if (!dwError) {
        wsprintf(
            pszAuditErrorMsgBuffer,
            L"0x%x",
            dwErrorCode
            );
        pszArgArray[0] = pszAuditPolicyMsgBuffer;
        pszArgArray[1] = pszAuditErrorMsgBuffer;
        AuditEvent(
            dwCategoryId,
            dwAuditId,
            dwStrId,
            (LPWSTR *) ppszArgArray,
            bSuccess,
            bDoAudit
            );
        return;
    }

    pszArgArray[0] = pszAuditPolicyMsgBuffer;
    pszArgArray[1] = (LPWSTR) lpvMsgBuf;
    AuditEvent(
        dwCategoryId,
        dwAuditId,
        dwStrId,
        (LPWSTR *) ppszArgArray,
        bSuccess,
        bDoAudit
        );

    if (lpvMsgBuf) {
        LocalFree(lpvMsgBuf);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\driver.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    driver.c

Abstract:

    This module contains all of the code to drive the
    management of specific filters in the IPSec driver.

Author:

    abhisheV    05-November-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"

#ifdef TRACE_ON
#include "driver.tmh"
#endif

DWORD
SPDStartIPSecDriver(
    )
/*++

Routine Description:

    Starts the IPSec Driver service.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    SC_HANDLE ServiceDatabase = NULL;
    SC_HANDLE ServiceHandle   = NULL;
    BOOL bStatus = FALSE;
    DWORD dwError = 0;
    SERVICE_STATUS IpsecStatus;


    memset(&IpsecStatus, 0, sizeof(SERVICE_STATUS));


    ServiceDatabase = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_ALL_ACCESS
                          );
    if (ServiceDatabase == NULL) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }


    ServiceHandle = OpenService(
                        ServiceDatabase,
                        IPSEC_SERVICE_NAME,
                        SERVICE_START | SERVICE_QUERY_STATUS
                        );
    if (ServiceHandle == NULL) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }


    bStatus = QueryServiceStatus(
                  ServiceHandle,
                  &IpsecStatus
                  );
    if (bStatus == FALSE) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (IpsecStatus.dwCurrentState == SERVICE_STOPPED) {

        bStatus = StartService(
                      ServiceHandle,
                      0,
                      NULL
                      );
        if (bStatus == FALSE) {
            dwError = GetLastError();
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }


error:

    if (ServiceDatabase != NULL) {
        CloseServiceHandle(ServiceDatabase);
    }

    if (ServiceHandle != NULL) {
        CloseServiceHandle(ServiceHandle);
    }

    return (dwError);
}


DWORD
SPDStopIPSecDriver(
    )
/*++

Routine Description:

    Stops the IPSec Driver service.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    SC_HANDLE ServiceDatabase = NULL;
    SC_HANDLE ServiceHandle   = NULL;
    BOOL bStatus = FALSE;
    DWORD dwError = 0;
    SERVICE_STATUS IpsecStatus;


    memset(&IpsecStatus, 0, sizeof(SERVICE_STATUS));


    ServiceDatabase = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_ALL_ACCESS
                          );
    if (ServiceDatabase == NULL) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }


    ServiceHandle = OpenService(
                        ServiceDatabase,
                        IPSEC_SERVICE_NAME,
                        SERVICE_STOP | SERVICE_QUERY_STATUS
                        );
    if (ServiceHandle == NULL) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }


    bStatus = QueryServiceStatus(
                  ServiceHandle,
                  &IpsecStatus
                  );
    if (bStatus == FALSE) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }


    if (IpsecStatus.dwCurrentState == SERVICE_RUNNING) {

        bStatus = ControlService(
                      ServiceHandle,
                      SERVICE_CONTROL_STOP,
                      &IpsecStatus
                      );
        if (bStatus == FALSE) {
            dwError = GetLastError();
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }


error:

    if (ServiceDatabase != NULL) {
        CloseServiceHandle(ServiceDatabase);
    }

    if (ServiceHandle != NULL) {
        CloseServiceHandle(ServiceHandle);
    }

    return (dwError);
}


DWORD
SPDOpenIPSecDriver(
    PHANDLE phIPSecDriver
    )
/*++

Routine Description:

    Opens a handle to the IPSec Driver.

Arguments:

    phIPSecDriver - pointer to a handle to the IPSec Driver.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    HANDLE hIPSecDriver = NULL;


    hIPSecDriver = CreateFile(
                       DEVICE_NAME,                  // File name.
                       GENERIC_READ | GENERIC_WRITE, // Access mode.
                       0,                            // Share mode.
                       NULL,                         // Security attributes.
                       OPEN_EXISTING,                // How to create.
                       0,                            // File attributes.
                       NULL                          // Handle to file.
                       );
    if (hIPSecDriver == INVALID_HANDLE_VALUE) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *phIPSecDriver = hIPSecDriver;
    
    return (dwError);

error:

    *phIPSecDriver = INVALID_HANDLE_VALUE;

    TRACE(TRC_ERROR, ("Failed to open driver: %!winerr!", dwError));
    return (dwError);
}


VOID
SPDCloseIPSecDriver(
    HANDLE hIPSecDriver
    )
/*++

Routine Description:

    Closes the handle to the IPSec Driver.

Arguments:

    hIPSecDriver - handle to the IPSec Driver to close.

Return Value:

    None.

--*/
{
    if (hIPSecDriver) {
        CloseHandle(hIPSecDriver);
    }
}


DWORD
InsertTransportFiltersIntoIPSec(
    PINITXSFILTER pSpecificFilters
    )
/*++

Routine Description:

    Insert a list of specific filters into the
    IPSec Driver.

Arguments:

    pSpecificFilters - list of filters to insert.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    HANDLE hIPSecDriver = NULL;
    LPBYTE pInBuffer = NULL;
    DWORD dwInBufferSize = 0;

    BOOL bStatus = FALSE;

    LPBYTE pOutBuffer = NULL;
    DWORD dwOutBufferSize = 0;
    DWORD dwBytesReturned = 0;

    DWORD dwNumFilters = 0;
    PIPSEC_FILTER_INFO pInternalFilters = NULL;
    LPBYTE pTemp = NULL;
    DWORD i = 0;


    if (!pSpecificFilters) {
        return (dwError);
    }

    dwError = SPDOpenIPSecDriver(
                  &hIPSecDriver
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = WrapTransportFilters(
                  pSpecificFilters,
                  &pInternalFilters,
                  &dwNumFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    dwInBufferSize = sizeof(DWORD) +
                     sizeof(IPSEC_FILTER_INFO)*dwNumFilters;

    dwError = AllocateSPDMemory(
                   dwInBufferSize,
                   &pInBuffer
                   );
    BAIL_ON_WIN32_ERROR(dwError);


    pTemp = pInBuffer;
    memcpy(pTemp, &dwNumFilters, sizeof(DWORD));
    pTemp += sizeof(DWORD);

    for (i = 0 ; i < dwNumFilters; i++) {

        memcpy(pTemp, &(pInternalFilters[i]), sizeof(IPSEC_FILTER_INFO));
        pTemp += sizeof(IPSEC_FILTER_INFO);

    }

    bStatus =  DeviceIoControl(
                   hIPSecDriver,
                   IOCTL_IPSEC_ADD_FILTER,
                   pInBuffer,
                   dwInBufferSize,
                   pOutBuffer,
                   dwOutBufferSize,
                   &dwBytesReturned,
                   NULL
                   );
    if (bStatus == FALSE) {
        dwError = GetLastError();

        TRACE(TRC_ERROR, (L"Failed IOCTL to add transport filters to driver: %!winerr!", dwError));    
        BAIL_ON_WIN32_ERROR(dwError);
    }


error:

    if (hIPSecDriver != INVALID_HANDLE_VALUE) {
        SPDCloseIPSecDriver(hIPSecDriver);
    }

    if (pInternalFilters) {
        FreeSPDMemory(pInternalFilters);
    }

    if (pInBuffer) {
        FreeSPDMemory(pInBuffer);
    }

    if (pOutBuffer) {
        LocalFree(pOutBuffer);
    }

#ifdef TRACE_ON
    if (dwError) {
        TRACE(TRC_ERROR, (L"Failed to add transport filters to driver: %!winerr!", dwError));    
    }
#endif

    return (dwError);
}


DWORD
DeleteTransportFiltersFromIPSec(
    PINITXSFILTER pSpecificFilters
    )
/*++

Routine Description:

    Delete a list of filters from the IPSec Driver.

Arguments:

    pSpecificFilters - list of filters to delete.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

 --*/
{
    DWORD dwError = 0;
    HANDLE hIPSecDriver = NULL;
    LPBYTE pInBuffer = NULL;
    DWORD dwInBufferSize = 0;

    BOOL bStatus = FALSE;

    LPBYTE pOutBuffer = NULL;
    DWORD dwOutBufferSize = 0;
    DWORD dwBytesReturned = 0;

    DWORD dwNumFilters = 0;
    PIPSEC_FILTER_INFO pInternalFilters = NULL;
    LPBYTE pTemp = NULL;
    DWORD i = 0;
    BOOL bMachineShutdown =  FALSE;

    bMachineShutdown = gdwShutdownFlags & SPD_SHUTDOWN_MACHINE;

    if (!pSpecificFilters) {
        return (dwError);
    }

    dwError = SPDOpenIPSecDriver(
                  &hIPSecDriver
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = WrapTransportFilters(
                  pSpecificFilters,
                  &pInternalFilters,
                  &dwNumFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    dwInBufferSize = sizeof(DWORD) +
                     sizeof(IPSEC_FILTER_INFO)*dwNumFilters;

    dwError = AllocateSPDMemory(
                   dwInBufferSize,
                   &pInBuffer
                   );
    BAIL_ON_WIN32_ERROR(dwError);


    pTemp = pInBuffer;
    memcpy(pTemp, &dwNumFilters, sizeof(DWORD));
    pTemp += sizeof(DWORD);

    for (i = 0 ; i < dwNumFilters; i++) {

        memcpy(pTemp, &(pInternalFilters[i]), sizeof(IPSEC_FILTER_INFO));
        pTemp += sizeof(IPSEC_FILTER_INFO);

    }

    if (bMachineShutdown) {
        bStatus = TRUE;    
    } else {    
        bStatus =  DeviceIoControl(
                       hIPSecDriver,
                       IOCTL_IPSEC_DELETE_FILTER,
                       pInBuffer,
                       dwInBufferSize,
                       pOutBuffer,
                       dwOutBufferSize,
                       &dwBytesReturned,
                       NULL
                       );
    }    

    if (bStatus == FALSE) {
        dwError = GetLastError();
        TRACE(TRC_ERROR, (L"Failed IOCTL to delete transport filters from driver: %!winerr!", dwError));            
        BAIL_ON_WIN32_ERROR(dwError);
    }


error:

    if (hIPSecDriver != INVALID_HANDLE_VALUE) {
        SPDCloseIPSecDriver(hIPSecDriver);
    }

    if (pInternalFilters) {
        FreeSPDMemory(pInternalFilters);
    }

    if (pInBuffer) {
        FreeSPDMemory(pInBuffer);
    }

    if (pOutBuffer) {
        LocalFree(pOutBuffer);
    }

#ifdef TRACE_ON
    if (dwError) {
        TRACE(TRC_ERROR, (L"Failed to delete transport filters from driver: %!winerr!", dwError));        
    }
#endif    

    return (dwError);
}


DWORD
WrapTransportFilters(
    PINITXSFILTER pSpecificFilters,
    PIPSEC_FILTER_INFO * ppInternalFilters,
    PDWORD pdwNumFilters
    )
/*++

Routine Description:

    Transforms a list of specific transport filters to
    an equivalent list of filters acceptable to the
    IPSec Driver.

Arguments:

    pSpecificFilters - list of filters to convert.

    ppInternalFilters - list of transformed filters.

    pdwNumFilters - count of the filters in the transformed
                    list.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITXSFILTER pTempFilter = NULL;
    PIPSEC_FILTER_INFO pInternalFilters = NULL;
    DWORD dwNumFilters = 0;
    DWORD i = 0;


    //
    // At this point, there's atleast one filter in the
    // specific filter list.
    //

    pTempFilter = pSpecificFilters;

    while(pTempFilter) {
        pTempFilter = pTempFilter->pNext;
        dwNumFilters++;
    }


    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_FILTER_INFO)*dwNumFilters,
                  &pInternalFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    pTempFilter = pSpecificFilters;

    while(pTempFilter) {

        FormIPSecTransportFilter(
            pTempFilter,
            &(pInternalFilters[i])
            );

        pTempFilter = pTempFilter->pNext;
        i++;

    }

    *ppInternalFilters = pInternalFilters;
    *pdwNumFilters = dwNumFilters;
    return (dwError);

error:

    *ppInternalFilters = NULL;
    *pdwNumFilters = 0;

    TRACE(
        TRC_ERROR,
        (L"Failed to convert set of SPD transport filters to driver filters: %!winerr!",
        dwError)
        );
    
    return (dwError);
}


VOID
FormIPSecTransportFilter(
    PINITXSFILTER pSpecificFilter,
    PIPSEC_FILTER_INFO pIpsecFilter
    )
/*++

Routine Description:

    Transforms a specific transport filter to an
    equivalent filter acceptable to the IPSec Driver.

Arguments:

    pSpecificFilter - filter to convert.

    pIpsecFilter - transformed filter.

Return Value:

    NONE.

--*/
{
    memcpy(
        &(pIpsecFilter->FilterId),
        &(pSpecificFilter->gParentID),
        sizeof(GUID)
        );

    memcpy(
        &(pIpsecFilter->PolicyId),
        &(pSpecificFilter->gPolicyID),
        sizeof(GUID)
        );

    pIpsecFilter->Index = pSpecificFilter->dwWeight;

    pIpsecFilter->AssociatedFilter.SrcAddr = pSpecificFilter->SrcAddr.uIpAddr;
    pIpsecFilter->AssociatedFilter.SrcMask = pSpecificFilter->SrcAddr.uSubNetMask;

    pIpsecFilter->AssociatedFilter.DestAddr = pSpecificFilter->DesAddr.uIpAddr;
    pIpsecFilter->AssociatedFilter.DestMask = pSpecificFilter->DesAddr.uSubNetMask;

    pIpsecFilter->AssociatedFilter.Protocol = pSpecificFilter->Protocol.dwProtocol;
    pIpsecFilter->AssociatedFilter.SrcPort = pSpecificFilter->SrcPort.wPort;
    pIpsecFilter->AssociatedFilter.DestPort = pSpecificFilter->DesPort.wPort;

    pIpsecFilter->AssociatedFilter.TunnelFilter = FALSE;
    pIpsecFilter->AssociatedFilter.TunnelAddr = 0;

    pIpsecFilter->AssociatedFilter.Flags = 0;

    if (pSpecificFilter->dwDirection == FILTER_DIRECTION_INBOUND) {
        pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_INBOUND;
        switch (pSpecificFilter->InboundFilterAction) {

        case PASS_THRU:
            pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_PASS_THRU;
            break;

        case BLOCKING:
            pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_DROP;
            break;

        default:
            break;
        }
    }
    else {
        pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_OUTBOUND;
        switch (pSpecificFilter->OutboundFilterAction) {

        case PASS_THRU:
            pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_PASS_THRU;
            break;

        case BLOCKING:
            pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_DROP;
            break;

        default:
            break;
        }
    }
}


DWORD
QueryIPSecStatistics(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_STATISTICS * ppIpsecStatistics,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    PIPSEC_STATISTICS pIpsecStatistics = NULL;


    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = QueryDriverForIpsecStats(
                  &pIpsecStatistics
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecStatistics = pIpsecStatistics;

cleanup:

    return (dwError);

error:

    *ppIpsecStatistics = NULL;

    goto cleanup;
}


DWORD
QueryDriverForIpsecStats(
    PIPSEC_QUERY_STATS * ppQueryStats
    )
{
    DWORD dwError = 0;
    PIPSEC_QUERY_STATS pQueryStats = NULL;
    HANDLE hIPSecDriver = NULL;
    LPBYTE pInBuffer = NULL;
    DWORD dwInBufferSize = 0;
    BOOL bStatus = FALSE;
    LPBYTE pOutBuffer = NULL;
    DWORD dwOutBufferSize = 0;
    DWORD dwBytesReturned = 0;


    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_QUERY_STATS),
                  &pQueryStats
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDOpenIPSecDriver(
                  &hIPSecDriver
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pInBuffer =  (LPBYTE) pQueryStats;
    dwInBufferSize = sizeof(IPSEC_QUERY_STATS);

    pOutBuffer = (LPBYTE) pQueryStats;
    dwOutBufferSize = sizeof(IPSEC_QUERY_STATS);

    dwBytesReturned = dwOutBufferSize;

    bStatus = DeviceIoControl(
                  hIPSecDriver,
                  IOCTL_IPSEC_QUERY_STATS,
                  pInBuffer,
                  dwInBufferSize,
                  pOutBuffer,
                  dwOutBufferSize,
                  &dwBytesReturned,
                  NULL
                  );
    if (bStatus == FALSE) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppQueryStats = pQueryStats;

cleanup:

    if (hIPSecDriver != INVALID_HANDLE_VALUE) {
        SPDCloseIPSecDriver(hIPSecDriver);
    }

    return (dwError);

error:

    if (pQueryStats) {
        SPDApiBufferFree(pQueryStats);
    }

    *ppQueryStats = NULL;

    TRACE(TRC_ERROR, (L"Failed to query IPSec driver for statistics: %!winerr!", dwError));    
    goto cleanup;
}


DWORD
EnumQMSAs(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_QM_SA pQMSATemplate,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PIPSEC_QM_SA * ppQMSAs,
    LPDWORD pdwNumQMSAs,
    LPDWORD pdwNumTotalQMSAs,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    DWORD dwResumeHandle = 0;
    DWORD dwNumToEnum = 0;
    DWORD dwNumTotalQMSAs = 0;
    PIPSEC_ENUM_SAS pIpsecEnumSAs = NULL;
    PIPSEC_SA_INFO pInfo = NULL;
    DWORD i = 0;
    DWORD dwNumQMSAs = 0;
    PIPSEC_QM_SA pQMSAs = NULL;
    PIPSEC_SA_INFO pTemp = NULL;
    PIPSEC_QM_SA pTempQMSA = NULL;


    dwResumeHandle = *pdwResumeHandle;

    if (!dwPreferredNumEntries || (dwPreferredNumEntries > MAX_QMSA_ENUM_COUNT)) {
        dwNumToEnum = MAX_QMSA_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IpsecEnumSAs(
                  &dwNumTotalQMSAs,
                  &pIpsecEnumSAs
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwNumTotalQMSAs <= dwResumeHandle) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pInfo = pIpsecEnumSAs->pInfo;

    for (i = 0; i < dwResumeHandle; i++) {
        pInfo++;
    }

    dwNumQMSAs = dwNumTotalQMSAs - dwResumeHandle;

    if (dwNumQMSAs > dwNumToEnum) {
        dwNumQMSAs = dwNumToEnum;
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_QM_SA)*dwNumQMSAs,
                  &pQMSAs
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pInfo;
    pTempQMSA = pQMSAs;

    for (i = 0; i < dwNumQMSAs; i++) {

        dwError = CopyQMSA(
                      pTemp,
                      pTempQMSA
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        pTemp++;
        pTempQMSA++;

    }

    *ppQMSAs = pQMSAs;
    *pdwResumeHandle = dwResumeHandle + dwNumQMSAs;
    *pdwNumQMSAs = dwNumQMSAs;
    *pdwNumTotalQMSAs = dwNumTotalQMSAs;

cleanup:

    if (pIpsecEnumSAs) {
        FreeSPDMem(pIpsecEnumSAs);
    }

    return (dwError);

error:

    if (pQMSAs) {
        FreeQMSAs(
            i,
            pQMSAs
            );
    }

    *ppQMSAs = NULL;
    *pdwResumeHandle = dwResumeHandle;
    *pdwNumQMSAs = 0;
    *pdwNumTotalQMSAs = 0;

    goto cleanup;
}


DWORD
IpsecEnumSAs(
    PDWORD pdwNumberOfSAs,
    PIPSEC_ENUM_SAS * ppIpsecEnumSAs
    )
{
    DWORD dwError = 0;
    DWORD dwNumberOfSAs = 0;
    PIPSEC_ENUM_SAS pIpsecEnumSAs = NULL;
    HANDLE hIPSecDriver = NULL;
    BOOL bStatus = FALSE;
    PIPSEC_ENUM_SAS pOutBuffer = NULL;
    DWORD dwOutBufferSize = 0;
    DWORD dwBytesReturned = 0;


    dwError = SPDOpenIPSecDriver(
                  &hIPSecDriver
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // The first call passes in a return buffer of size IPSEC_ENUM_SAS.
    // The idea here is to determine the number of SAs and then pass
    // a second buffer with the correct size.
    //

    dwOutBufferSize = sizeof(IPSEC_ENUM_SAS);

    pOutBuffer = (PIPSEC_ENUM_SAS) AllocSPDMem(
                                       sizeof(IPSEC_ENUM_SAS)
                                       );
    if (!pOutBuffer) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    memset(pOutBuffer, 0, dwOutBufferSize);
    dwBytesReturned = dwOutBufferSize;

    bStatus =  DeviceIoControl(
                   hIPSecDriver,
                   IOCTL_IPSEC_ENUM_SAS,
                   NULL,
                   0,
                   (PVOID) pOutBuffer,
                   dwOutBufferSize,
                   &dwBytesReturned,
                   NULL
                   );

    //
    // The error code here should be either ERROR_BUFFER_OVERFLOW
    // or ERROR_MORE_DATA or ERROR_SUCCESS.
    //

    if (!bStatus) {
        dwError = GetLastError();
    }
    else {
        dwError = ERROR_SUCCESS;
    }

    while (dwError == ERROR_BUFFER_OVERFLOW || dwError == ERROR_MORE_DATA) {

        //
        // Determine the number of SAs that the driver currently has.
        //

        pIpsecEnumSAs = (PIPSEC_ENUM_SAS) pOutBuffer;
        dwNumberOfSAs = pIpsecEnumSAs->NumEntriesPresent;

        if (dwNumberOfSAs == 0) {
            dwError = ERROR_NO_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        if (pOutBuffer) {
            FreeSPDMem(pOutBuffer);
            pOutBuffer = NULL;
        }

        dwOutBufferSize = sizeof(IPSEC_ENUM_SAS)
                                + (dwNumberOfSAs -1)*sizeof(IPSEC_SA_INFO);

        pOutBuffer = (PIPSEC_ENUM_SAS) AllocSPDMem(
                                           dwOutBufferSize
                                           );
        if (!pOutBuffer) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        memset(pOutBuffer, 0, dwOutBufferSize);
        dwBytesReturned = dwOutBufferSize;

        bStatus =  DeviceIoControl(
                       hIPSecDriver,
                       IOCTL_IPSEC_ENUM_SAS,
                       NULL,
                       0,
                       (PVOID) pOutBuffer,
                       dwOutBufferSize,
                       &dwBytesReturned,
                       NULL
                       );

        if (!bStatus) {
            dwError = GetLastError();
            TRACE(TRC_ERROR, (L"Failed IOCTL to enumerate Quickmode SAs from driver: %!winerr!", dwError));
        }
        else {
            dwError = ERROR_SUCCESS;
        }

    }

    pIpsecEnumSAs = (PIPSEC_ENUM_SAS) pOutBuffer;
    dwNumberOfSAs = pIpsecEnumSAs->NumEntries;

    if (dwNumberOfSAs == 0) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *pdwNumberOfSAs = dwNumberOfSAs;
    *ppIpsecEnumSAs = pIpsecEnumSAs;

cleanup:

    if (hIPSecDriver != INVALID_HANDLE_VALUE) {
        SPDCloseIPSecDriver(hIPSecDriver);
    }

    return (dwError);

error:

    *pdwNumberOfSAs = 0;
    *ppIpsecEnumSAs = NULL;

    if (pOutBuffer) {
        FreeSPDMem(pOutBuffer);
    }

    TRACE(TRC_ERROR, (L"Failed to enumerate Quickmode SAs from driver: %!winerr!", dwError));
    goto cleanup;
}


DWORD
CopyQMSA(
    PIPSEC_SA_INFO pInfo,
    PIPSEC_QM_SA pQMSA
    )
{
    DWORD dwError = 0;


    memcpy(
        &(pQMSA->gQMPolicyID),
        &(pInfo->PolicyId),
        sizeof(GUID)
        );

    memcpy(
        &(pQMSA->gQMFilterID),
        &(pInfo->FilterId),
        sizeof(GUID)
        );

    CopyQMSAOffer(
        pInfo,
        &(pQMSA->SelectedQMOffer)
        );

    CopyQMSAFilter(
        pInfo->InboundTunnelAddr,
        &(pInfo->AssociatedFilter),
        &(pQMSA->IpsecQMFilter)
        );

    CopyQMSAMMSpi(
        pInfo->CookiePair,
        &(pQMSA->MMSpi)
        );

    
    memcpy(&pQMSA->EncapInfo,
           &pInfo->EncapInfo,
           sizeof(UDP_ENCAP_INFO));

    return (dwError);
}


VOID
CopyQMSAOffer(
    PIPSEC_SA_INFO pInfo,
    PIPSEC_QM_OFFER pOffer
    )
{
    DWORD i = 0;
    DWORD j = 0;
    DWORD k = 0;


    pOffer->Lifetime.uKeyExpirationTime =
    pInfo->Lifetime.KeyExpirationTime;

    pOffer->Lifetime.uKeyExpirationKBytes =
    pInfo->Lifetime.KeyExpirationBytes;

    pOffer->dwFlags = 0;

    pOffer->dwPFSGroup = pInfo->dwQMPFSGroup;

    if ((pOffer->dwPFSGroup != PFS_GROUP_1) &&
        (pOffer->dwPFSGroup != PFS_GROUP_2) &&
        (pOffer->dwPFSGroup != PFS_GROUP_2048) &&
        (pOffer->dwPFSGroup != PFS_GROUP_MM)) {
         pOffer->dwPFSGroup = PFS_GROUP_NONE;
         pOffer->bPFSRequired = FALSE;
    }
    else {
         pOffer->bPFSRequired = TRUE;
    }

    i = 0;

    for (j = 0; (j < pInfo->NumOps) && (i < QM_MAX_ALGOS) ; j++) {

        switch (pInfo->Operation[j]) {

        case Auth:

            switch (pInfo->AlgoInfo[j].IntegrityAlgo.algoIdentifier) {

            case IPSEC_AH_MD5:
                pOffer->Algos[i].uAlgoIdentifier = AUTH_ALGO_MD5;
                break;

            case IPSEC_AH_SHA:
                pOffer->Algos[i].uAlgoIdentifier = AUTH_ALGO_SHA1;
                break;

            default:
                pOffer->Algos[i].uAlgoIdentifier = AUTH_ALGO_NONE;
                break;

            }

            pOffer->Algos[i].uSecAlgoIdentifier = HMAC_AUTH_ALGO_NONE;

            pOffer->Algos[i].Operation = AUTHENTICATION;

            pOffer->Algos[i].uAlgoKeyLen =
            pInfo->AlgoInfo[j].IntegrityAlgo.algoKeylen;

            pOffer->Algos[i].uAlgoRounds =
            pInfo->AlgoInfo[j].IntegrityAlgo.algoRounds;

            pOffer->Algos[i].uSecAlgoKeyLen = 0;

            pOffer->Algos[i].uSecAlgoRounds = 0;

            pOffer->Algos[i].MySpi = pInfo->InboundSPI[j];
            pOffer->Algos[i].PeerSpi = pInfo->OutboundSPI[j];

            i++;
            break;

        case Encrypt:

            switch (pInfo->AlgoInfo[j].ConfAlgo.algoIdentifier) {

            case IPSEC_ESP_DES:
                pOffer->Algos[i].uAlgoIdentifier = CONF_ALGO_DES;
                break;

            case IPSEC_ESP_DES_40:
                pOffer->Algos[i].uAlgoIdentifier = CONF_ALGO_DES;
                break;

            case IPSEC_ESP_3_DES:
                pOffer->Algos[i].uAlgoIdentifier = CONF_ALGO_3_DES;
                break;

            default:
                pOffer->Algos[i].uAlgoIdentifier = CONF_ALGO_NONE;
                break;

            }

            switch (pInfo->AlgoInfo[j].IntegrityAlgo.algoIdentifier) {

            case IPSEC_AH_MD5:
                pOffer->Algos[i].uSecAlgoIdentifier = HMAC_AUTH_ALGO_MD5;
                break;

            case IPSEC_AH_SHA:
                pOffer->Algos[i].uSecAlgoIdentifier = HMAC_AUTH_ALGO_SHA1;
                break;

            default:
                pOffer->Algos[i].uSecAlgoIdentifier = HMAC_AUTH_ALGO_NONE;
                break;

            }

            pOffer->Algos[i].Operation = ENCRYPTION;

            pOffer->Algos[i].uAlgoKeyLen =
            pInfo->AlgoInfo[j].ConfAlgo.algoKeylen;

            pOffer->Algos[i].uAlgoRounds =
            pInfo->AlgoInfo[j].ConfAlgo.algoRounds;

            pOffer->Algos[i].uSecAlgoKeyLen =
            pInfo->AlgoInfo[j].IntegrityAlgo.algoKeylen;

            pOffer->Algos[i].uSecAlgoRounds =
            pInfo->AlgoInfo[j].IntegrityAlgo.algoRounds;

            pOffer->Algos[i].MySpi = pInfo->InboundSPI[j];
            pOffer->Algos[i].PeerSpi = pInfo->OutboundSPI[j];

            i++;
            break;

        case None:

            pOffer->Algos[i].Operation = NONE;
            pOffer->Algos[i].uAlgoIdentifier = CONF_ALGO_NONE;
            pOffer->Algos[i].uSecAlgoIdentifier = HMAC_AUTH_ALGO_NONE;
            pOffer->Algos[i].uAlgoKeyLen = 0;
            pOffer->Algos[i].uAlgoRounds = 0;
            pOffer->Algos[i].uSecAlgoKeyLen = 0;
            pOffer->Algos[i].uSecAlgoRounds = 0;
            pOffer->Algos[i].MySpi = pInfo->InboundSPI[j];
            pOffer->Algos[i].PeerSpi = pInfo->OutboundSPI[j];

            i++;
            break;

        case Compress:
        default:
            break;

        }

    }

    for (k = i; k < QM_MAX_ALGOS; k++) {
         memset(&(pOffer->Algos[k]), 0, sizeof(IPSEC_QM_ALGO));
    }

    pOffer->dwNumAlgos = i;

    pOffer->dwReserved = 0;

    return;
}


VOID
CopyQMSAFilter(
    IPAddr MyTunnelEndpt,
    PIPSEC_FILTER pIpsecFilter,
    PIPSEC_QM_FILTER pIpsecQMFilter
    )
{
    pIpsecQMFilter->IpVersion = IPSEC_PROTOCOL_V4;

    if (pIpsecFilter->TunnelFilter) {
        pIpsecQMFilter->QMFilterType = QM_TUNNEL_FILTER;
    }
    else {
        pIpsecQMFilter->QMFilterType = QM_TRANSPORT_FILTER;
    }

    PASetAddress(
        pIpsecFilter->SrcMask,
        pIpsecFilter->SrcAddr,
        &(pIpsecQMFilter->SrcAddr)
        );

    PASetAddress(
        pIpsecFilter->DestMask,
        pIpsecFilter->DestAddr,
        &(pIpsecQMFilter->DesAddr)
        );

    pIpsecQMFilter->Protocol.ProtocolType = PROTOCOL_UNIQUE;
    pIpsecQMFilter->Protocol.dwProtocol = pIpsecFilter->Protocol;

    pIpsecQMFilter->SrcPort.PortType = PORT_UNIQUE;
    pIpsecQMFilter->SrcPort.wPort = ntohs(pIpsecFilter->SrcPort);

    pIpsecQMFilter->DesPort.PortType = PORT_UNIQUE;
    pIpsecQMFilter->DesPort.wPort = ntohs(pIpsecFilter->DestPort);

    if (pIpsecFilter->TunnelFilter) {
        PASetTunnelAddress(
            MyTunnelEndpt,
            &(pIpsecQMFilter->MyTunnelEndpt)
            );
        PASetTunnelAddress(
            pIpsecFilter->TunnelAddr,
            &(pIpsecQMFilter->PeerTunnelEndpt)
            );
    }
    else {
        PASetAddress(
            SUBNET_MASK_ANY,
            SUBNET_ADDRESS_ANY,
            &(pIpsecQMFilter->MyTunnelEndpt)
            );
        PASetAddress(
            SUBNET_MASK_ANY,
            SUBNET_ADDRESS_ANY,
            &(pIpsecQMFilter->PeerTunnelEndpt)
            );
    }

    pIpsecQMFilter->dwFlags = 0;

    if ((pIpsecFilter->Flags) & FILTER_FLAGS_INBOUND) {
        pIpsecQMFilter->dwFlags |= FILTER_DIRECTION_INBOUND;
    }
    else {
        pIpsecQMFilter->dwFlags |= FILTER_DIRECTION_OUTBOUND;
    }

    if ((pIpsecFilter->Flags) & FILTER_FLAGS_PASS_THRU) {
        pIpsecQMFilter->dwFlags |= FILTER_NATURE_PASS_THRU;
    }
    else if ((pIpsecFilter->Flags) & FILTER_FLAGS_DROP) {
        pIpsecQMFilter->dwFlags |= FILTER_NATURE_BLOCKING;
    }
    else {
        pIpsecQMFilter->dwFlags |= 0;
    }

    return;
}


VOID
CopyQMSAMMSpi(
    IKE_COOKIE_PAIR CookiePair,
    PIKE_COOKIE_PAIR pMMSpi
    )
{
    pMMSpi->Initiator = CookiePair.Initiator;

    pMMSpi->Responder = CookiePair.Responder;

    return;
}


VOID
FreeQMSAs(
    DWORD dwCnt,
    PIPSEC_QM_SA pQMSAs
    )
{
    if (pQMSAs) {
        SPDApiBufferFree(pQMSAs);
    }
}


DWORD
InsertTunnelFiltersIntoIPSec(
    PINITNSFILTER pSpecificFilters
    )
/*++

Routine Description:

    Insert a list of specific filters into the
    IPSec Driver.

Arguments:

    pSpecificFilters - list of filters to insert.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    HANDLE hIPSecDriver = NULL;
    LPBYTE pInBuffer = NULL;
    DWORD dwInBufferSize = 0;

    BOOL bStatus = FALSE;

    LPBYTE pOutBuffer = NULL;
    DWORD dwOutBufferSize = 0;
    DWORD dwBytesReturned = 0;

    DWORD dwNumFilters = 0;
    PIPSEC_FILTER_INFO pInternalFilters = NULL;
    LPBYTE pTemp = NULL;
    DWORD i = 0;


    if (!pSpecificFilters) {
        return (dwError);
    }

    dwError = SPDOpenIPSecDriver(
                  &hIPSecDriver
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = WrapTunnelFilters(
                  pSpecificFilters,
                  &pInternalFilters,
                  &dwNumFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    dwInBufferSize = sizeof(DWORD) +
                     sizeof(IPSEC_FILTER_INFO)*dwNumFilters;

    dwError = AllocateSPDMemory(
                   dwInBufferSize,
                   &pInBuffer
                   );
    BAIL_ON_WIN32_ERROR(dwError);


    pTemp = pInBuffer;
    memcpy(pTemp, &dwNumFilters, sizeof(DWORD));
    pTemp += sizeof(DWORD);

    for (i = 0 ; i < dwNumFilters; i++) {

        memcpy(pTemp, &(pInternalFilters[i]), sizeof(IPSEC_FILTER_INFO));
        pTemp += sizeof(IPSEC_FILTER_INFO);

    }


    bStatus =  DeviceIoControl(
                   hIPSecDriver,
                   IOCTL_IPSEC_ADD_FILTER,
                   pInBuffer,
                   dwInBufferSize,
                   pOutBuffer,
                   dwOutBufferSize,
                   &dwBytesReturned,
                   NULL
                   );
    if (bStatus == FALSE) {
        dwError = GetLastError();
        TRACE(TRC_ERROR, (L"Failed IOCTL to add tunnel filters to driver: %!winerr!", dwError));    
        BAIL_ON_WIN32_ERROR(dwError);
    }


error:

    if (hIPSecDriver != INVALID_HANDLE_VALUE) {
        SPDCloseIPSecDriver(hIPSecDriver);
    }

    if (pInternalFilters) {
        FreeSPDMemory(pInternalFilters);
    }

    if (pInBuffer) {
        FreeSPDMemory(pInBuffer);
    }

    if (pOutBuffer) {
        LocalFree(pOutBuffer);
    }

#ifdef TRACE_ON
    if (dwError) {
        TRACE(TRC_ERROR, (L"Failed to add tunnel filters to driver: %!winerr!", dwError));    
    }
#endif
    
    return (dwError);
}


DWORD
DeleteTunnelFiltersFromIPSec(
    PINITNSFILTER pSpecificFilters
    )
/*++

Routine Description:

    Delete a list of filters from the IPSec Driver.

Arguments:

    pSpecificFilters - list of filters to delete.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

 --*/
{
    DWORD dwError = 0;
    HANDLE hIPSecDriver = NULL;
    LPBYTE pInBuffer = NULL;
    DWORD dwInBufferSize = 0;

    BOOL bStatus = FALSE;

    LPBYTE pOutBuffer = NULL;
    DWORD dwOutBufferSize = 0;
    DWORD dwBytesReturned = 0;

    DWORD dwNumFilters = 0;
    PIPSEC_FILTER_INFO pInternalFilters = NULL;
    LPBYTE pTemp = NULL;
    DWORD i = 0;
    BOOL bMachineShutdown =  FALSE;

    bMachineShutdown = gdwShutdownFlags & SPD_SHUTDOWN_MACHINE;


    if (!pSpecificFilters) {
        return (dwError);
    }

    dwError = SPDOpenIPSecDriver(
                  &hIPSecDriver
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = WrapTunnelFilters(
                  pSpecificFilters,
                  &pInternalFilters,
                  &dwNumFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    dwInBufferSize = sizeof(DWORD) +
                     sizeof(IPSEC_FILTER_INFO)*dwNumFilters;

    dwError = AllocateSPDMemory(
                   dwInBufferSize,
                   &pInBuffer
                   );
    BAIL_ON_WIN32_ERROR(dwError);


    pTemp = pInBuffer;
    memcpy(pTemp, &dwNumFilters, sizeof(DWORD));
    pTemp += sizeof(DWORD);

    for (i = 0 ; i < dwNumFilters; i++) {

        memcpy(pTemp, &(pInternalFilters[i]), sizeof(IPSEC_FILTER_INFO));
        pTemp += sizeof(IPSEC_FILTER_INFO);

    }

    if (bMachineShutdown) {
        bStatus = TRUE;    
    } else {
        bStatus =  DeviceIoControl(
                       hIPSecDriver,
                       IOCTL_IPSEC_DELETE_FILTER,
                       pInBuffer,
                       dwInBufferSize,
                       pOutBuffer,
                       dwOutBufferSize,
                       &dwBytesReturned,
                       NULL
                       );
    }    
                       

    if (bStatus == FALSE) {
        dwError = GetLastError();
        TRACE(TRC_ERROR, (L"Failed IOCTL to delete tunnel filters from driver: %!winerr!", dwError));     
        BAIL_ON_WIN32_ERROR(dwError);
    }


error:

    if (hIPSecDriver != INVALID_HANDLE_VALUE) {
        SPDCloseIPSecDriver(hIPSecDriver);
    }

    if (pInternalFilters) {
        FreeSPDMemory(pInternalFilters);
    }

    if (pInBuffer) {
        FreeSPDMemory(pInBuffer);
    }

    if (pOutBuffer) {
        LocalFree(pOutBuffer);
    }

#ifdef TRACE_ON
    if (dwError) {
        TRACE(TRC_ERROR, (L"Failed to delete tunnel filters from driver: %!winerr!", dwError));        
    }
#endif    
    
    return (dwError);
}


DWORD
WrapTunnelFilters(
    PINITNSFILTER pSpecificFilters,
    PIPSEC_FILTER_INFO * ppInternalFilters,
    PDWORD pdwNumFilters
    )
/*++

Routine Description:

    Transforms a list of specific tunnel filters to
    an equivalent list of filters acceptable to the
    IPSec Driver.

Arguments:

    pSpecificFilters - list of filters to convert.

    ppInternalFilters - list of transformed filters.

    pdwNumFilters - count of the filters in the transformed
                    list.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITNSFILTER pTempFilter = NULL;
    PIPSEC_FILTER_INFO pInternalFilters = NULL;
    DWORD dwNumFilters = 0;
    DWORD i = 0;


    //
    // At this point, there's atleast one filter in the
    // specific filter list.
    //

    pTempFilter = pSpecificFilters;

    while(pTempFilter) {
        pTempFilter = pTempFilter->pNext;
        dwNumFilters++;
    }


    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_FILTER_INFO)*dwNumFilters,
                  &pInternalFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    pTempFilter = pSpecificFilters;

    while(pTempFilter) {

        FormIPSecTunnelFilter(
            pTempFilter,
            &(pInternalFilters[i])
            );

        pTempFilter = pTempFilter->pNext;
        i++;

    }

    *ppInternalFilters = pInternalFilters;
    *pdwNumFilters = dwNumFilters;
    return (dwError);

error:

    *ppInternalFilters = NULL;
    *pdwNumFilters = 0;

    TRACE(
        TRC_ERROR,
        (L"Failed to convert set of SPD tunnel filters to driver filters: %!winerr!",
        dwError)
        );
    
    return (dwError);
}


VOID
FormIPSecTunnelFilter(
    PINITNSFILTER pSpecificFilter,
    PIPSEC_FILTER_INFO pIpsecFilter
    )
/*++

Routine Description:

    Transforms a specific tunnel filter to an
    equivalent filter acceptable to the IPSec Driver.

Arguments:

    pSpecificFilter - filter to convert.

    pIpsecFilter - transformed filter.

Return Value:

    NONE.

--*/
{
    memcpy(
        &(pIpsecFilter->FilterId),
        &(pSpecificFilter->gParentID),
        sizeof(GUID)
        );

    memcpy(
        &(pIpsecFilter->PolicyId),
        &(pSpecificFilter->gPolicyID),
        sizeof(GUID)
        );

    pIpsecFilter->Index = pSpecificFilter->dwWeight;

    pIpsecFilter->AssociatedFilter.SrcAddr = pSpecificFilter->SrcAddr.uIpAddr;
    pIpsecFilter->AssociatedFilter.SrcMask = pSpecificFilter->SrcAddr.uSubNetMask;

    pIpsecFilter->AssociatedFilter.DestAddr = pSpecificFilter->DesAddr.uIpAddr;
    pIpsecFilter->AssociatedFilter.DestMask = pSpecificFilter->DesAddr.uSubNetMask;

    pIpsecFilter->AssociatedFilter.Protocol = pSpecificFilter->Protocol.dwProtocol;
    pIpsecFilter->AssociatedFilter.SrcPort = pSpecificFilter->SrcPort.wPort;
    pIpsecFilter->AssociatedFilter.DestPort = pSpecificFilter->DesPort.wPort;

    pIpsecFilter->AssociatedFilter.TunnelFilter = TRUE;
    pIpsecFilter->AssociatedFilter.TunnelAddr = pSpecificFilter->DesTunnelAddr.uIpAddr;

    pIpsecFilter->AssociatedFilter.Flags = 0;

    if (pSpecificFilter->dwDirection == FILTER_DIRECTION_INBOUND) {
        pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_INBOUND;
        switch (pSpecificFilter->InboundFilterAction) {

        case PASS_THRU:
            pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_PASS_THRU;
            break;

        case BLOCKING:
            pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_DROP;
            break;

        default:
            break;
        }
    }
    else {
        pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_OUTBOUND;
        switch (pSpecificFilter->OutboundFilterAction) {

        case PASS_THRU:
            pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_PASS_THRU;
            break;

        case BLOCKING:
            pIpsecFilter->AssociatedFilter.Flags |= FILTER_FLAGS_DROP;
            break;

        default:
            break;
        }
    }
}


DWORD
SPDSetIPSecDriverOpMode(
    DWORD dwOpMode
    )
{
    DWORD dwError = 0;
    HANDLE hIPSecDriver = NULL;
    PIPSEC_SET_OPERATION_MODE pIpsecSetOpMode = NULL;
    LPBYTE pInBuffer = NULL;
    DWORD dwInBufferSize = 0;
    LPBYTE pOutBuffer = NULL;
    DWORD dwOutBufferSize = 0;
    DWORD dwBytesReturned = 0;
    BOOL bStatus = FALSE;


    dwError = SPDOpenIPSecDriver(
                  &hIPSecDriver
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_SET_OPERATION_MODE),
                  &pIpsecSetOpMode
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecSetOpMode->OperationMode = (OPERATION_MODE) dwOpMode;

    pInBuffer =  (LPBYTE) pIpsecSetOpMode;
    dwInBufferSize = sizeof(IPSEC_SET_OPERATION_MODE);

    pOutBuffer = (LPBYTE) pIpsecSetOpMode;
    dwOutBufferSize = sizeof(IPSEC_SET_OPERATION_MODE);

    dwBytesReturned = dwOutBufferSize;

    bStatus = DeviceIoControl(
                  hIPSecDriver,
                  IOCTL_IPSEC_SET_OPERATION_MODE,
                  pInBuffer,
                  dwInBufferSize,
                  pOutBuffer,
                  dwOutBufferSize,
                  &dwBytesReturned,
                  NULL
                  );
    if (bStatus == FALSE) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (hIPSecDriver != INVALID_HANDLE_VALUE) {
        SPDCloseIPSecDriver(hIPSecDriver);
    }

    if (pIpsecSetOpMode) {
        FreeSPDMemory(pIpsecSetOpMode);
    }

#ifdef TRACE_ON
    if (dwError) {
        TRACE(TRC_ERROR, (L"Failed to set driver operation mode to %d: %!winerr!", dwOpMode, dwError));
    }
#endif    

    return (dwError);
}


DWORD
DeleteQMSAs(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_QM_SA pIpsecQMSA,
    DWORD dwFlags,
    LPVOID pvReserved
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HANDLE hIPSecDriver = NULL;
    IPSEC_DELETE_SA IpsecDeleteSA;
    LPBYTE pInBuffer = NULL;
    DWORD dwInBufferSize = 0;
    LPBYTE pOutBuffer = NULL;
    DWORD dwOutBufferSize = 0;
    DWORD dwBytesReturned = 0;
    BOOL bStatus = FALSE;


    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);


    dwError = SPDOpenIPSecDriver(
                  &hIPSecDriver
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    
    memcpy(
        &IpsecDeleteSA.SATemplate,
        pIpsecQMSA,
        sizeof(IPSEC_QM_SA)
        );

    pInBuffer = (LPBYTE) &IpsecDeleteSA;
    dwInBufferSize = sizeof(IPSEC_DELETE_SA);

    pOutBuffer = (LPBYTE) &IpsecDeleteSA;
    dwOutBufferSize = sizeof(IPSEC_DELETE_SA);

    dwBytesReturned = dwOutBufferSize;

    bStatus = DeviceIoControl(
                  hIPSecDriver,
                  IOCTL_IPSEC_DELETE_SA,
                  pInBuffer,
                  dwInBufferSize,
                  pOutBuffer,
                  dwOutBufferSize,
                  &dwBytesReturned,
                  NULL
                  );
    if (bStatus == FALSE) {
        dwError = GetLastError();
        TRACE(TRC_ERROR, (L"Failed IOCTL to delete Quickmode SAs from driver: %!winerr!", dwError));        
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (hIPSecDriver != INVALID_HANDLE_VALUE) {
        SPDCloseIPSecDriver(hIPSecDriver);
    }

    TRACE(TRC_ERROR, (L"Failed to delete Quickmode SAs from driver: %!winerr!", dwError));        
    return (dwError);
}


DWORD
SPDRegisterIPSecDriverProtocols(
    DWORD dwRegisterMode
    )
{
    DWORD dwError = 0;
    HANDLE hIPSecDriver = NULL;
    PIPSEC_REGISTER_PROTOCOL pIpsecRegisterProtocol = NULL;
    LPBYTE pInBuffer = NULL;
    DWORD dwInBufferSize = 0;
    LPBYTE pOutBuffer = NULL;
    DWORD dwOutBufferSize = 0;
    DWORD dwBytesReturned = 0;
    BOOL bStatus = FALSE;


    dwError = SPDOpenIPSecDriver(
                  &hIPSecDriver
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_REGISTER_PROTOCOL),
                  &pIpsecRegisterProtocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecRegisterProtocol->RegisterProtocol = (REGISTER_IPSEC_PROTOCOL) dwRegisterMode;

    pInBuffer =  (LPBYTE) pIpsecRegisterProtocol;
    dwInBufferSize = sizeof(IPSEC_REGISTER_PROTOCOL);

    pOutBuffer = (LPBYTE) pIpsecRegisterProtocol;
    dwOutBufferSize = sizeof(IPSEC_REGISTER_PROTOCOL);

    dwBytesReturned = dwOutBufferSize;

    bStatus = DeviceIoControl(
                  hIPSecDriver,
                  IOCTL_IPSEC_REGISTER_PROTOCOL,
                  pInBuffer,
                  dwInBufferSize,
                  pOutBuffer,
                  dwOutBufferSize,
                  &dwBytesReturned,
                  NULL
                  );
    if (bStatus == FALSE) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:

    if (hIPSecDriver != INVALID_HANDLE_VALUE) {
        SPDCloseIPSecDriver(hIPSecDriver);
    }

    if (pIpsecRegisterProtocol) {
        FreeSPDMemory(pIpsecRegisterProtocol);
    }

#ifdef TRACE_ON
    if (dwError) {
        TRACE(TRC_ERROR, (L"Failed to register IPSec driver protocols: %!winerr!", dwError));        
    }
#endif    

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\driver.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    driver.h

Abstract:

    This module contains all of the code prototypes to
    drive the management of specific filters in the 
    IPSec driver.

Author:

    abhisheV    05-November-1999

Environment

    User Level: Win32

Revision History:


--*/


#define DEVICE_NAME         L"\\\\.\\IpsecDev"
#define IPSEC_SERVICE_NAME  L"IPSEC"


#if defined(__cplusplus)
extern "C" {
#endif


DWORD
SPDStartIPSecDriver(
    );


DWORD
SPDStopIPSecDriver(
    );


DWORD
SPDOpenIPSecDriver(
    PHANDLE phIPSecDriver
    );


VOID
SPDCloseIPSecDriver(
    HANDLE hIPSecDriver
    );


DWORD
InsertTransportFiltersIntoIPSec(
    PINITXSFILTER pSpecificFilters
    );


DWORD
DeleteTransportFiltersFromIPSec(
    PINITXSFILTER pSpecificFilters
    );


DWORD
WrapTransportFilters(
    PINITXSFILTER pSpecificFilters,
    PIPSEC_FILTER_INFO * ppInternalFilters,
    PDWORD pdwNumFilters
    );


VOID
FormIPSecTransportFilter(
    PINITXSFILTER pSpecificFilter,
    PIPSEC_FILTER_INFO pIpsecFilter
    );


DWORD
QueryDriverForIpsecStats(
    PIPSEC_QUERY_STATS * ppQueryStats
    );


DWORD
IpsecEnumSAs(
    PDWORD pdwNumberOfSAs,
    PIPSEC_ENUM_SAS * ppIpsecEnumSAs
    );


DWORD
CopyQMSA(
    PIPSEC_SA_INFO pInfo,
    PIPSEC_QM_SA pQMSA
    );


VOID
CopyQMSAOffer(
    PIPSEC_SA_INFO pInfo,
    PIPSEC_QM_OFFER pOffer
    );


VOID
CopyQMSAFilter(
    IPAddr MyTunnelEndpt,
    PIPSEC_FILTER pIpsecFilter,
    PIPSEC_QM_FILTER pIpsecQMFilter
    );


VOID
CopyQMSAMMSpi(
    IKE_COOKIE_PAIR CookiePair,
    PIKE_COOKIE_PAIR pMMSpi
    );


VOID
FreeQMSAs(
    DWORD dwCnt,
    PIPSEC_QM_SA pQMSAs
    );


DWORD
InsertTunnelFiltersIntoIPSec(
    PINITNSFILTER pSpecificFilters
    );


DWORD
DeleteTunnelFiltersFromIPSec(
    PINITNSFILTER pSpecificFilters
    );


DWORD
WrapTunnelFilters(
    PINITNSFILTER pSpecificFilters,
    PIPSEC_FILTER_INFO * ppInternalFilters,
    PDWORD pdwNumFilters
    );


VOID
FormIPSecTunnelFilter(
    PINITNSFILTER pSpecificFilter,
    PIPSEC_FILTER_INFO pIpsecFilter
    );


DWORD
SPDSetIPSecDriverOpMode(
    DWORD dwOpMode
    );


DWORD
SPDRegisterIPSecDriverProtocols(
    DWORD dwRegisterMode
    );


#if defined(__cplusplus)
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\init.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    init.h

Abstract:

    This module contains all of the code prototypes
    to initialize the variables for the IPSecSPD Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#define IPSEC_NEW_DS_POLICY_EVENT L"IPSEC_POLICY_CHANGE_EVENT"

#ifdef __cplusplus
extern "C" {
#endif

DWORD
InitSPDGlobals(
    );

DWORD
InitSPDThruRegistry(
    );

DWORD InitAuditing(
        );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\externs.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    externs.h

Abstract:

    Holds externs for global variables.

Author:

    abhisheV    30-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif


extern  BOOL                        gbSPDRPCServerUp;

extern  HANDLE                      ghServiceStopEvent;

extern  CRITICAL_SECTION            gcServerListenSection;

extern  DWORD                       gdwServersListening;

extern  BOOL                        gbServerListenSection;

extern PIPSEC_INTERFACE             gpInterfaceList;

extern BOOL                         gbwsaStarted;

extern SOCKET                       gIfChangeEventSocket;

extern HANDLE                       ghIfChangeEvent;

extern HANDLE                       ghOverlapEvent;

extern WSAOVERLAPPED                gwsaOverlapped;

extern WSADATA                      gwsaData;

extern PSPECIAL_ADDR                gpSpecialAddrsList;

//
// Globals for transport-mode filters - txfilter.c
//

extern PINITXFILTER gpIniTxFilter;

extern PINITXSFILTER gpIniTxSFilter;

extern PTX_FILTER_HANDLE gpTxFilterHandle;

extern CRITICAL_SECTION             gcSPDSection;

extern BOOL                         gbSPDSection;

//
// Globals for quick mode policies - qm-policy.c
//

extern PINIQMPOLICY gpIniQMPolicy;

extern PINIQMPOLICY gpIniDefaultQMPolicy;

//
// Globals for main mode policies - mm-policy.c
//

extern PINIMMPOLICY gpIniMMPolicy;

extern PINIMMPOLICY gpIniDefaultMMPolicy;

//
// Globals for main mode filters - mmfilter.c
//

extern PINIMMFILTER gpIniMMFilter;

extern PINIMMSFILTER gpIniMMSFilter;

extern PMM_FILTER_HANDLE gpMMFilterHandle;

//
// Globals for main mode auth methods - mmauth.c
//

extern PINIMMAUTHMETHODS gpIniMMAuthMethods;

extern PINIMMAUTHMETHODS gpIniDefaultMMAuthMethods;


//
// Policy Agent Store specific globals.
//

extern IPSEC_POLICY_STATE gIpsecPolicyState;

extern PIPSEC_POLICY_STATE gpIpsecPolicyState;

extern DWORD gCurrentPollingInterval;

extern DWORD gDefaultPollingInterval;

extern DWORD gdwRetryCount;

extern LPWSTR gpszIpsecDSPolicyKey;

extern LPWSTR gpszIpsecLocalPolicyKey;

extern LPWSTR gpszIpsecPersistentPolicyKey;

extern LPWSTR gpszIpsecCachePolicyKey;

extern LPWSTR gpszDefaultISAKMPPolicyDN;

extern LPWSTR gpszLocPolicyAgent;

extern HANDLE ghNewDSPolicyEvent;

extern HANDLE ghNewLocalPolicyEvent;

extern HANDLE ghForcedPolicyReloadEvent;

extern HANDLE ghPolicyChangeNotifyEvent;

extern HANDLE ghGpupdateRefreshEvent;

extern BOOL gbLoadedISAKMPDefaults;


//
// PA Store to SPD intergration specific globals.
//

extern PMMPOLICYSTATE gpMMPolicyState;

extern PMMAUTHSTATE gpMMAuthState;

extern PMMFILTERSTATE gpMMFilterState;

extern DWORD gdwMMPolicyCounter;

extern DWORD gdwMMFilterCounter;

extern PQMPOLICYSTATE gpQMPolicyState;

extern DWORD gdwQMPolicyCounter;

extern PTXFILTERSTATE gpTxFilterState;

extern DWORD gdwTxFilterCounter;


//
// Globals for tunnel-mode filters - tnfilter.c
//

extern PINITNFILTER gpIniTnFilter;

extern PINITNSFILTER gpIniTnSFilter;

extern PTN_FILTER_HANDLE gpTnFilterHandle;


extern PTNFILTERSTATE gpTnFilterState;

extern DWORD gdwTnFilterCounter;


extern BOOL gbIsIKEUp;


extern PSECURITY_DESCRIPTOR gpSPDSD;

extern BOOL gbIKENotify;

extern HANDLE ghIPSecDriver;

extern SID gIpsecServerSid;

extern PSID gpIpsecServerSid;

extern CRITICAL_SECTION gcSPDAuditSection;

extern BOOL gbSPDAuditSection;

extern BOOL gbAuditingInitialized;

extern HMODULE ghIpsecServerModule;

extern BOOL gbIsIoctlPended;

extern BOOL gbBackwardSoftSA;

extern DWORD gdwShutdownFlags;

extern BOOL gbPersistentPolicyApplied;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\ikerpc.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    ikerpc.c

Abstract:

    This module contains all of the code to service the
    RPC calls made to the SPD that are serviced in IKE.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


VOID
IKENEGOTIATION_HANDLE_rundown(
    IKENEGOTIATION_HANDLE hIKENegotiation
    )
{
    if (!gbIsIKEUp) {
        return;
    }

    if (hIKENegotiation) {
        (VOID) IKECloseIKENegotiationHandle(
                   hIKENegotiation
                   );
    }
}


VOID
IKENOTIFY_HANDLE_rundown(
    IKENOTIFY_HANDLE hIKENotifyHandle
    )
{
    if (!gbIsIKEUp) {
        return;
    }

    if (hIKENotifyHandle) {
        (VOID) IKECloseIKENotifyHandle(
                   hIKENotifyHandle
                   );
    }
}


DWORD
RpcInitiateIKENegotiation(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    PQM_FILTER_CONTAINER pQMFilterContainer,
    DWORD dwClientProcessId,
    ULONG uhClientEvent,
    DWORD dwFlags,
    IPSEC_UDP_ENCAP_CONTEXT UdpEncapContext,
    IKENEGOTIATION_HANDLE * phIKENegotiation
    )
{
    DWORD dwError = 0;
    HANDLE hClientEvent = NULL;
    PIPSEC_QM_FILTER pQMFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateInitiateIKENegotiation(pServerName,
                                             pQMFilterContainer,
                                             dwClientProcessId,
                                             uhClientEvent,
                                             dwFlags,
                                             UdpEncapContext,
                                             phIKENegotiation);
    BAIL_ON_WIN32_ERROR(dwError);    

    hClientEvent = LongToHandle(uhClientEvent);

    pQMFilter = pQMFilterContainer->pQMFilters;

    if (pQMFilter && (pQMFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = IKEInitiateIKENegotiation(
                  pQMFilter,
                  dwClientProcessId,
                  hClientEvent,
                  dwFlags,
                  UdpEncapContext,
                  phIKENegotiation
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcQueryIKENegotiationStatus(
    IKENEGOTIATION_HANDLE hIKENegotiation,
    DWORD dwVersion,
    SA_NEGOTIATION_STATUS_INFO * pNegotiationStatus
    )
{
    DWORD dwError = 0;
    DWORD dwFlags = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateQueryIKENegotiationStatus(
                  hIKENegotiation,
                  pNegotiationStatus
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IKEQueryIKENegotiationStatus(
                  hIKENegotiation,
                  pNegotiationStatus,
                  dwFlags
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcCloseIKENegotiationHandle(
    IKENEGOTIATION_HANDLE * phIKENegotiation
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateCloseIKENegotiationHandle(phIKENegotiation);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IKECloseIKENegotiationHandle(
                  *phIKENegotiation
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *phIKENegotiation = NULL;

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcEnumMMSAs(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    PMM_SA_CONTAINER pMMTemplate,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PMM_SA_CONTAINER * ppMMSAContainer,
    LPDWORD pdwNumEntries,
    LPDWORD pdwTotalMMsAvailable,
    LPDWORD pdwEnumHandle
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_SA pMMSAs = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateEnumMMSAs(
                  pServerName,
                  pMMTemplate,
                  ppMMSAContainer,
                  pdwNumEntries,
                  pdwTotalMMsAvailable,
                  pdwEnumHandle,
                  dwFlags
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pMMTemplate->pMMSAs && (pMMTemplate->pMMSAs->IpVersion != IPSEC_PROTOCOL_V4)) {
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError= IKEEnumMMs(
                 pMMTemplate->pMMSAs,
                 &pMMSAs,
                 pdwNumEntries,
                 pdwTotalMMsAvailable,
                 pdwEnumHandle,
                 dwFlags
                 );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppMMSAContainer)->pMMSAs = pMMSAs;
    (*ppMMSAContainer)->dwNumMMSAs = *pdwNumEntries;

error:

    if (dwError != ERROR_SUCCESS) {
        if (ppMMSAContainer && *ppMMSAContainer) {
            (*ppMMSAContainer)->pMMSAs = NULL;
            (*ppMMSAContainer)->dwNumMMSAs = 0;
        }
    }

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcDeleteMMSAs(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    PMM_SA_CONTAINER pMMTemplate,
    DWORD dwFlags
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateDeleteMMSAs(
                  pServerName,
                  pMMTemplate,
                  dwFlags
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pMMTemplate->pMMSAs && (pMMTemplate->pMMSAs->IpVersion != IPSEC_PROTOCOL_V4)) {
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError= IKEDeleteAssociation(
                 pMMTemplate->pMMSAs,
                 dwFlags
                 );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcQueryIKEStatistics(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    IKE_STATISTICS * pIKEStatistics
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateQueryIKEStatistics(
                  pServerName,
                  pIKEStatistics
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IKEQueryStatistics(pIKEStatistics);
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcRegisterIKENotifyClient(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    DWORD dwClientProcessId,
    ULONG uhClientEvent,
    PQM_SA_CONTAINER pQMSATemplateContainer,
    DWORD dwFlags,
    IKENOTIFY_HANDLE * phNotifyHandle
    )
{
    DWORD dwError = 0;
    HANDLE hClientEvent = LongToHandle(uhClientEvent);
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateRegisterIKENotifyClient(
                  pServerName,
                  dwClientProcessId,
                  uhClientEvent,
                  pQMSATemplateContainer,
                  phNotifyHandle,
                  dwFlags
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pQMSATemplateContainer->pQMSAs &&
        (pQMSATemplateContainer->pQMSAs->IpsecQMFilter.IpVersion != IPSEC_PROTOCOL_V4)) {
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = IKERegisterNotifyClient(
                  dwClientProcessId,
                  hClientEvent,
                  *pQMSATemplateContainer->pQMSAs,
                  phNotifyHandle
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcQueryIKENotifyData(
    IKENOTIFY_HANDLE uhNotifyHandle,
    DWORD dwVersion,
    DWORD dwFlags,
    PQM_SA_CONTAINER * ppQMSAContainer,
    PDWORD pdwNumEntries
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_SA pQMSAs = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateQueryNotifyData(
                  uhNotifyHandle,
                  pdwNumEntries,
                  ppQMSAContainer,
                  dwFlags
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IKEQuerySpiChange(
                  uhNotifyHandle,
                  pdwNumEntries,
                  &pQMSAs
                  );

    if ((dwError == ERROR_SUCCESS) ||
        (dwError == ERROR_MORE_DATA)) {

        (*ppQMSAContainer)->pQMSAs = pQMSAs;
        (*ppQMSAContainer)->dwNumQMSAs = *pdwNumEntries;
        SPDRevertToSelf(bImpersonating);
        return (dwError);

    }

error:

    if (ppQMSAContainer && *ppQMSAContainer) {
        (*ppQMSAContainer)->pQMSAs = NULL;
        (*ppQMSAContainer)->dwNumQMSAs = 0;
    }

    if (pdwNumEntries) {
        *pdwNumEntries = 0;
    }

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcCloseIKENotifyHandle(
    IKENOTIFY_HANDLE * phHandle
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateCloseNotifyHandle(phHandle);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IKECloseIKENotifyHandle(*phHandle);
    BAIL_ON_WIN32_ERROR(dwError);

    *phHandle = NULL;

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcAddSAs(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    IPSEC_SA_DIRECTION SADirection,
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer,
    PQM_FILTER_CONTAINER pQMFilterContainer,
    ULONG * puhLarvalContext,
    DWORD dwInboundKeyMatLen,
    BYTE * pInboundKeyMat,
    DWORD dwOutboundKeyMatLen,
    BYTE *pOutboundKeyMat,
    BYTE *pContextInfo,
    UDP_ENCAP_INFO EncapInfo,
    DWORD dwFlags)

{
    DWORD dwError = 0;
    HANDLE hLarvalContext = NULL;
    PIPSEC_QM_FILTER pQMFilter = NULL;
    PIPSEC_QM_OFFER pQMOffer = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError=ValidateIPSecAddSA(pServerName,
                               SADirection,
                               pQMPolicyContainer,
                               pQMFilterContainer,
                               puhLarvalContext,
                               dwInboundKeyMatLen,
                               pInboundKeyMat,
                               dwOutboundKeyMatLen,
                               pOutboundKeyMat,
                               pContextInfo,
                               EncapInfo,
                               dwFlags);

    BAIL_ON_WIN32_ERROR(dwError);

    hLarvalContext = LongToHandle(*puhLarvalContext);

    pQMFilter = pQMFilterContainer->pQMFilters;
    pQMOffer = pQMPolicyContainer->pPolicies->pOffers;

    if (pQMFilter && (pQMFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError=IKEAddSAs(
        SADirection,
        pQMOffer,
        pQMFilter,
        &hLarvalContext,
        dwInboundKeyMatLen,
        pInboundKeyMat,
        dwOutboundKeyMatLen,
        pOutboundKeyMat,
        pContextInfo,
        EncapInfo,
        dwFlags);
    
    BAIL_ON_WIN32_ERROR(dwError);

    *puhLarvalContext = HandleToLong(hLarvalContext);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}

DWORD
RpcGetConfigurationVariables(
    STRING_HANDLE pServerName, 
    IKE_CONFIG *pIKEConfig
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;

    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError=ValidateGetConfigurationVariables(pServerName,
                                              pIKEConfig);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IKEGetConfigurationVariables(pIKEConfig);
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return dwError;
}

DWORD
RpcSetConfigurationVariables(
    STRING_HANDLE pServerName, 
    IKE_CONFIG IKEConfig
    )

{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;

    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    LEAVE_SPD_SECTION();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError=ValidateSetConfigurationVariables(pServerName,
                                              IKEConfig);
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = IKESetConfigurationVariables(IKEConfig);
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return dwError;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\globals.c ===
/*++


Copyright (c) 1999 Microsoft Corporation


Module Name:

    globals.c

Abstract:

    Holds global variable declarations.

Author:

    abhisheV    30-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


BOOL                        gbSPDRPCServerUp;

HANDLE                      ghServiceStopEvent;

CRITICAL_SECTION            gcServerListenSection;

DWORD                       gdwServersListening;

BOOL                        gbServerListenSection;

PIPSEC_INTERFACE            gpInterfaceList;


BOOL                        gbwsaStarted;

SOCKET                      gIfChangeEventSocket;

HANDLE                      ghIfChangeEvent;

HANDLE                      ghOverlapEvent;

WSAOVERLAPPED               gwsaOverlapped;

WSADATA                     gwsaData;

PSPECIAL_ADDR               gpSpecialAddrsList;

//
// Globals for transport-mode filters - txfilter.c
//

PINITXFILTER gpIniTxFilter;

PINITXSFILTER gpIniTxSFilter;

PTX_FILTER_HANDLE gpTxFilterHandle;

CRITICAL_SECTION            gcSPDSection;

BOOL                        gbSPDSection;

//
// Globals for quick mode policies - qm-policy.c
//

PINIQMPOLICY gpIniQMPolicy;

PINIQMPOLICY gpIniDefaultQMPolicy;

//
// Globals for main mode policies - mm-policy.c
//

PINIMMPOLICY gpIniMMPolicy;

PINIMMPOLICY gpIniDefaultMMPolicy;

//
// Globals for main mode filters - mmfilter.c
//

PINIMMFILTER gpIniMMFilter;

PINIMMSFILTER gpIniMMSFilter;

PMM_FILTER_HANDLE gpMMFilterHandle;

//
// Globals for main mode auth methods - mmauth.c
//

PINIMMAUTHMETHODS gpIniMMAuthMethods;

PINIMMAUTHMETHODS gpIniDefaultMMAuthMethods;


//
// Policy Agent Store specific globals.
//

IPSEC_POLICY_STATE gIpsecPolicyState;

PIPSEC_POLICY_STATE gpIpsecPolicyState;

DWORD gCurrentPollingInterval;

DWORD gDefaultPollingInterval;

DWORD gdwRetryCount;

LPWSTR gpszIpsecDSPolicyKey;

LPWSTR gpszIpsecLocalPolicyKey;

LPWSTR gpszIpsecPersistentPolicyKey;

LPWSTR gpszIpsecCachePolicyKey;

LPWSTR gpszDefaultISAKMPPolicyDN;

LPWSTR gpszLocPolicyAgent;

HANDLE ghNewDSPolicyEvent;

HANDLE ghNewLocalPolicyEvent;

HANDLE ghForcedPolicyReloadEvent;

HANDLE ghPolicyChangeNotifyEvent;

HANDLE ghGpupdateRefreshEvent;

BOOL gbLoadedISAKMPDefaults;


//
// PA Store to SPD intergration specific globals.
//

PMMPOLICYSTATE gpMMPolicyState;

PMMAUTHSTATE gpMMAuthState;

PMMFILTERSTATE gpMMFilterState;

DWORD gdwMMPolicyCounter;

DWORD gdwMMFilterCounter;

PQMPOLICYSTATE gpQMPolicyState;

DWORD gdwQMPolicyCounter;

PTXFILTERSTATE gpTxFilterState;

DWORD gdwTxFilterCounter;


//
// Globals for tunnel-mode filters - tnfilter.c
//

PINITNFILTER gpIniTnFilter;

PINITNSFILTER gpIniTnSFilter;

PTN_FILTER_HANDLE gpTnFilterHandle;


PTNFILTERSTATE gpTnFilterState;

DWORD gdwTnFilterCounter;

BOOL gbIsIKEUp;

PSECURITY_DESCRIPTOR gpSPDSD;

BOOL gbIKENotify;

HANDLE ghIPSecDriver = INVALID_HANDLE_VALUE;

SID gIpsecServerSid = { SID_REVISION,
                        1,
                        SECURITY_NT_AUTHORITY,
                        SECURITY_NETWORK_SERVICE_RID
                      };

PSID gpIpsecServerSid = &gIpsecServerSid;

CRITICAL_SECTION gcSPDAuditSection;

BOOL gbSPDAuditSection;

BOOL gbAuditingInitialized;

HMODULE ghIpsecServerModule;

BOOL gbIsIoctlPended;

BOOL gbBackwardSoftSA;

DWORD gdwShutdownFlags;

BOOL gbPersistentPolicyApplied;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\init.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    init.h

Abstract:

    This module contains all of the code to
    initialize the variables for the IPSecSPD Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"
#ifdef TRACE_ON
#include "init.tmh"
#endif


#define SZAPPNAME   L"ipsecsvc.dll"

DWORD
InitSPDThruRegistry(
    )
{
    DWORD dwError = 0;
    HKEY hKey = NULL;
    DWORD dwtype = REG_DWORD;
    DWORD dwsize = sizeof(DWORD);
    DWORD dwBackwardSoftSA = 0;

    dwError = RegOpenKey(
                  HKEY_LOCAL_MACHINE,
                  gpszLocPolicyAgent,
                  &hKey
                  );
    if (dwError) {
        dwBackwardSoftSA = 0;
        dwError = ERROR_SUCCESS;
        BAIL_ON_WIN32_SUCCESS(dwError);
    }

    dwError = RegQueryValueEx(
                  hKey,
                  L"OldFallBackToClear",
                  0,
                  &dwtype,
                  (unsigned char *) &dwBackwardSoftSA,
                  &dwsize
                  );
    if (dwError) {
        dwBackwardSoftSA = 0;
        dwError = ERROR_SUCCESS;
        BAIL_ON_WIN32_SUCCESS(dwError);
    }
    
success:
    gbBackwardSoftSA = dwBackwardSoftSA ? TRUE : FALSE;
    
    if (hKey) {
        RegCloseKey(hKey);
    }

    return (dwError);
}


DWORD InitAuditing(
        )
{
    DWORD dwError = 0;

    InitializeCriticalSection(&gcSPDAuditSection);
    gbSPDAuditSection = TRUE;

    ghIpsecServerModule = GetModuleHandle(SZAPPNAME);

    if (!ghIpsecServerModule) {
        dwError = ERROR_INVALID_HANDLE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    gbAuditingInitialized = TRUE;
    return dwError;
error:
    TRACE(TRC_ERROR, (L"Failed to initialize auditing %!winerr!", dwError));
    return dwError;
}

DWORD
InitSPDGlobals(
    )
{
    DWORD dwError = 0;
    SECURITY_ATTRIBUTES SecurityAttributes;


    dwError = InitializeSPDSecurity(&gpSPDSD);
    BAIL_ON_WIN32_ERROR(dwError);

    memset(&SecurityAttributes, 0, sizeof(SECURITY_ATTRIBUTES));

    SecurityAttributes.nLength = sizeof(SecurityAttributes);
    SecurityAttributes.lpSecurityDescriptor = NULL;
    SecurityAttributes.bInheritHandle = TRUE;

    ghNewDSPolicyEvent = CreateEvent(
                             &SecurityAttributes,
                             TRUE,
                             FALSE,
                             IPSEC_NEW_DS_POLICY_EVENT
                             );
    if (!ghNewDSPolicyEvent) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ghNewLocalPolicyEvent = CreateEvent(
                                &SecurityAttributes,
                                TRUE,
                                FALSE,
                                NULL
                                );
    if (!ghNewLocalPolicyEvent) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ghForcedPolicyReloadEvent = CreateEvent(
                                    &SecurityAttributes,
                                    TRUE,
                                    FALSE,
                                    NULL
                                    );
    if (!ghForcedPolicyReloadEvent) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // IPSEC_POLICY_CHANGE_NOTIFY is defined in ipsec.h.
    // 

    ghPolicyChangeNotifyEvent = CreateEvent(
                                    NULL,
                                    TRUE,
                                    FALSE,
                                    IPSEC_POLICY_CHANGE_NOTIFY
                                    );
    if (!ghPolicyChangeNotifyEvent) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ghServiceStopEvent = CreateEvent(
                             &SecurityAttributes,
                             TRUE,
                             FALSE,
                             NULL
                             );
    if (!ghServiceStopEvent) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ghGpupdateRefreshEvent = CreateEvent(
                                 &SecurityAttributes,
                                 TRUE,
                                 FALSE,
                                 IPSEC_GP_REFRESH_EVENT
                                 );
    if (!ghGpupdateRefreshEvent) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }
                                

    InitializeCriticalSection(&gcServerListenSection);

    gbServerListenSection = TRUE;

    gdwServersListening = 0;

    InitializeCriticalSection(&gcSPDSection);

    gbSPDSection = TRUE;

    dwError = InitializeInterfaceChangeEvent();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ResetInterfaceChangeEvent();
    BAIL_ON_WIN32_ERROR(dwError);

    InitializePolicyStateBlock(
        gpIpsecPolicyState
        );
    return (dwError);
error:

    TRACE(TRC_ERROR, (L"Failed to initialize SPD globals %!winerr!", dwError));
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\iphlpwrp.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    iphlpwrp.c

Abstract:

    This module contains all of the code to wrap
    the ip public help apis for getting the list of
    active interfaces on a machine.

Author:

    krishnaG

Environment

    User Level: Win32

Revision History:

    abhisheV    30-September-1999

--*/


#include "precomp.h"


DWORD
PaPNPGetIfTable(
    OUT PMIB_IFTABLE * ppMibIfTable
    )
{
    DWORD               dwStatus = 0;
    PMIB_IFTABLE        pIfTable = NULL;
    PMIB_IFTABLE        pMibIfTable = NULL;
    PIP_INTERFACE_INFO  pInterfaceInfo = NULL;
    DWORD               i = 0;
    DWORD               j = 0;
    DWORD               dwNameLen = 0;

    dwStatus =  AllocateAndGetIfTableFromStack(
                    &pIfTable,
                    TRUE,
                    GetProcessHeap(),
                    0,
                    TRUE
                    );
    BAIL_ON_WIN32_ERROR(dwStatus);

    pMibIfTable = (PMIB_IFTABLE) LocalAlloc(
                                     LPTR,
                                     sizeof(DWORD)+
                                     sizeof(MIB_IFROW) *
                                     pIfTable->dwNumEntries
                                     );

    if (!pMibIfTable) {
        dwStatus = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwStatus);
    }

    for (i = 0; i < pIfTable->dwNumEntries; i++) {
        memcpy(&(pMibIfTable->table[i]), &(pIfTable->table[i]), sizeof(MIB_IFROW));
    }
    pMibIfTable->dwNumEntries = pIfTable->dwNumEntries;

    //  Get the corresponding Interface Information structure here.

    dwStatus =  PaPNPGetInterfaceInformation(
                    &pInterfaceInfo
                    );
    BAIL_ON_WIN32_ERROR(dwStatus);

    if (!pInterfaceInfo) {
        dwStatus = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwStatus);
    }

    for (j = 0; j < pMibIfTable->dwNumEntries; j++) {
        for (i = 0; i < (DWORD) pInterfaceInfo->NumAdapters; i++) {
            if (pInterfaceInfo->Adapter[i].Index == pMibIfTable->table[j].dwIndex) {
                dwNameLen = wcslen((LPTSTR) &pInterfaceInfo->Adapter[i].Name);
                wcsncpy(
                    (LPTSTR)&(pMibIfTable->table[j].wszName),
                    (LPTSTR)&(pInterfaceInfo->Adapter[i].Name),
                    dwNameLen
                    );
            }
        }
    }

    *ppMibIfTable = pMibIfTable;

cleanup:

    if (pIfTable) {
        HeapFree(GetProcessHeap(), 0, pIfTable);
    }

    if (pInterfaceInfo) {
        LocalFree(pInterfaceInfo);
    }

    return (dwStatus);

error:

    if (pMibIfTable) {
        LocalFree(pMibIfTable);
    }

    *ppMibIfTable = NULL;

    goto cleanup;
}


DWORD
PaPNPGetInterfaceInformation(
    OUT PIP_INTERFACE_INFO * ppInterfaceInfo
    )
{

    LPBYTE  pBuffer = NULL;
    DWORD   dwBufferSize = 2048;
    DWORD   dwStatus = 0;

    pBuffer = (LPBYTE) LocalAlloc(
                           LPTR,
                           dwBufferSize
                           );

    if (!pBuffer) {
        return (ERROR_OUTOFMEMORY);
    }

    dwStatus = GetInterfaceInfo(
                   (PIP_INTERFACE_INFO) pBuffer,
                   &dwBufferSize
                   );

    if (dwStatus == ERROR_INSUFFICIENT_BUFFER) {

        if (pBuffer) {
            LocalFree(pBuffer);
            pBuffer = NULL;
        }

        pBuffer = (LPBYTE) LocalAlloc(
                               LPTR,
                               dwBufferSize
                               );

        if (!pBuffer) {
            return (ERROR_OUTOFMEMORY);
        }

        dwStatus = GetInterfaceInfo(
                       (PIP_INTERFACE_INFO) pBuffer,
                       &dwBufferSize
                       );

        if (dwStatus) {
            goto error;
        }

    } 
    else if (dwStatus) {
        goto error;
    }

    *ppInterfaceInfo = (PIP_INTERFACE_INFO) pBuffer;

    return (dwStatus);

error:

    if (pBuffer) {
        LocalFree(pBuffer);
    }

    return (dwStatus);
}


VOID
PrintMibIfTable(
    IN PMIB_IFTABLE pMibIfTable
    )
{
    DWORD       dwNumEntries = 0;
    DWORD       i = 0;
    PMIB_IFROW  pMibIfRow = NULL;
    PMIB_IFROW  pCurrentMibIfRow = NULL;

    dwNumEntries = pMibIfTable->dwNumEntries;
    pMibIfRow = &(pMibIfTable->table[0]);

    for (i = 0; i < dwNumEntries; i++) {

        pCurrentMibIfRow = pMibIfRow + i;

        wprintf(L"Name = %s\n", pCurrentMibIfRow->wszName);
        wprintf(L"dwIndex = %d\n", pCurrentMibIfRow->dwIndex);
        printf("Description = %s\n", (pCurrentMibIfRow->bDescr));

    }

    wprintf(L"\n\n");
}



VOID
PrintInterfaceInfo(
    IN PIP_INTERFACE_INFO pInterfaceInfo
    )
{
    DWORD                   dwNumAdapters = 0;
    DWORD                   i = 0;
    PIP_ADAPTER_INDEX_MAP   pAdapterIndexMap = NULL;
    PIP_ADAPTER_INDEX_MAP   pCurrentAdapter = NULL;

    dwNumAdapters =  pInterfaceInfo->NumAdapters;
    pAdapterIndexMap = &(pInterfaceInfo->Adapter[0]);

    for (i = 0; i < dwNumAdapters; i++) {

        pCurrentAdapter = pAdapterIndexMap + i;
        wprintf(
            L"Adapter %d Index %d Name %s\n",
            i,
            pCurrentAdapter->Index,
            pCurrentAdapter->Name
            );

    }
}


VOID
PrintMibAddrTable(
    IN PMIB_IPADDRTABLE pMibAddrTable
    )
{
    DWORD           dwNumEntries = 0;
    DWORD           i = 0;
    PMIB_IPADDRROW  pMibAddrRow = NULL;
    PMIB_IPADDRROW  pCurrentMibAddrRow = NULL;

    dwNumEntries = pMibAddrTable->dwNumEntries;
    pMibAddrRow = &(pMibAddrTable->table[0]);

    for (i = 0; i < dwNumEntries; i++) {

        pCurrentMibAddrRow = pMibAddrRow + i;

        wprintf(L"Address = %d\n", pCurrentMibAddrRow->dwAddr);
        wprintf(L"dwIndex = %d\n", pCurrentMibAddrRow->dwIndex);
        wprintf(L"dwMask = %d\n",  pCurrentMibAddrRow->dwMask);

    }
    wprintf(L"\n\n");
}


DWORD
PaPNPGetIpAddrTable(
    OUT PMIB_IPADDRTABLE * ppMibIpAddrTable
    )
{
    PMIB_IPADDRTABLE    pMibIpAddrTable = NULL;
    DWORD               dwBufferSize = 2048;
    DWORD               dwStatus = 0;
    DWORD               dwNameLen = 0;

    pMibIpAddrTable = (PMIB_IPADDRTABLE) LocalAlloc(
                                             LPTR,
                                             dwBufferSize
                                             );
    if (!pMibIpAddrTable) {
        return (ERROR_OUTOFMEMORY);
    }

    dwStatus = GetIpAddrTable(
                   (PMIB_IPADDRTABLE) pMibIpAddrTable,
                   &dwBufferSize,
                   TRUE
                   );

    if (dwStatus == ERROR_INSUFFICIENT_BUFFER) {

        if (pMibIpAddrTable) {
            LocalFree(pMibIpAddrTable);
            pMibIpAddrTable = NULL;
        }

        pMibIpAddrTable = (PMIB_IPADDRTABLE) LocalAlloc(
                                                 LPTR,
                                                 dwBufferSize
                                                 );
        if (!pMibIpAddrTable) {
            return (ERROR_OUTOFMEMORY);
        }

        dwStatus = GetIpAddrTable(
                       (PMIB_IPADDRTABLE) pMibIpAddrTable,
                       &dwBufferSize,
                       TRUE
                       );
        if (dwStatus) {
            goto error;
        }

    }
    else if (dwStatus) {
        goto error;
    }

    *ppMibIpAddrTable = pMibIpAddrTable;

    return (dwStatus);

error:

    *ppMibIpAddrTable = NULL;

    if (pMibIpAddrTable) {
        LocalFree(pMibIpAddrTable);
    }

    return (dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\interface.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    interface.c

Abstract:

    This module contains all of the code to drive
    the interface list management of IPSecSPD Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"
#ifdef TRACE_ON
#include "interface.tmh"
#endif

DWORD
CreateInterfaceList(
    OUT PIPSEC_INTERFACE * ppIfListToCreate
    )
{
    DWORD            dwError = 0;
    PIPSEC_INTERFACE pIfList = NULL;


    dwError = GetInterfaceListFromStack(
                  &pIfList
                  );

    ENTER_SPD_SECTION();

    *ppIfListToCreate = pIfList;

    LEAVE_SPD_SECTION();

    return (dwError);
}


VOID
DestroyInterfaceList(
    IN PIPSEC_INTERFACE pIfListToDelete
    )
{
    PIPSEC_INTERFACE pIf = NULL;
    PIPSEC_INTERFACE pTempIf = NULL;

    pIf = pIfListToDelete;

    while (pIf) {
        pTempIf = pIf;
        pIf = pIf->pNext;
        FreeIpsecInterface(pTempIf);
    }
}


DWORD
OnInterfaceChangeEvent(
    )
{
    DWORD            dwError = 0;
    PIPSEC_INTERFACE pIfList = NULL;
    PIPSEC_INTERFACE pObseleteIfList = NULL;
    PIPSEC_INTERFACE pNewIfList = NULL;
    PIPSEC_INTERFACE pExistingIfList = NULL;
    PSPECIAL_ADDR    pLatestSpecialAddrsList;
    DWORD dwMMError = 0;
    DWORD dwTxError = 0;
    DWORD dwTnError = 0;


    dwError = ResetInterfaceChangeEvent();

    (VOID) GetInterfaceListFromStack(
               &pIfList
               );

    (VOID) GetSpecialAddrsList(
               &pLatestSpecialAddrsList
               );

    ENTER_SPD_SECTION();

    (VOID) FreeSpecialAddrList(
               &gpSpecialAddrsList
               );
               
    gpSpecialAddrsList = pLatestSpecialAddrsList;

    pExistingIfList = gpInterfaceList;

    // Interface List from Stack can be NULL.

    FormObseleteAndNewIfLists(
        pIfList,
        &pExistingIfList,
        &pObseleteIfList,
        &pNewIfList
        );

    if (pNewIfList) {
        AddToInterfaceList(
            pNewIfList,
            &pExistingIfList
            );
    }

    if (pObseleteIfList) {
        DestroyInterfaceList(
            pObseleteIfList
            );
    }

    gpInterfaceList = pExistingIfList;

    (VOID) ApplyIfChangeToIniMMFilters(
               &dwMMError,
               pExistingIfList,
               gpSpecialAddrsList
               );

    (VOID) ApplyIfChangeToIniTxFilters(
               &dwTxError,
               pExistingIfList,
               gpSpecialAddrsList
               );

    (VOID) ApplyIfChangeToIniTnFilters(
               &dwTnError,
               pExistingIfList,
               gpSpecialAddrsList
               );

    LEAVE_SPD_SECTION();

    if (dwMMError || dwTxError || dwTnError) {
        AuditEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            IPSECSVC_FAILED_PNP_FILTER_PROCESSING,
            NULL,
            FALSE,
            TRUE
            );
    }

    return (dwError);
}


DWORD
OnSpecialAddrsChange(
    )
{
    DWORD            dwError = 0;
    DWORD dwMMError = 0;
    DWORD dwTxError = 0;
    DWORD dwTnError = 0;
    PSPECIAL_ADDR    pOldSpecialAddrsList = NULL;
    PSPECIAL_ADDR pLatestSpecialAddrsList = NULL;
    BOOL bListSame = FALSE;
    
    dwError = GetSpecialAddrsList(
                  &pLatestSpecialAddrsList
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    bListSame = IsSpecialListSame(
                    pLatestSpecialAddrsList,
                    gpSpecialAddrsList
                    );
    if (bListSame) {
        (VOID) FreeSpecialAddrList(
                   &pLatestSpecialAddrsList
                   );

        LEAVE_SPD_SECTION();
        return ERROR_SUCCESS;
    }

    pOldSpecialAddrsList = gpSpecialAddrsList;
    gpSpecialAddrsList = pLatestSpecialAddrsList;
    
    (VOID) FreeSpecialAddrList(
              &pOldSpecialAddrsList
              );
    
    (VOID) ApplyIfChangeToIniMMFilters(
               &dwMMError,
               gpInterfaceList,
               gpSpecialAddrsList
               );

    (VOID) ApplyIfChangeToIniTxFilters(
               &dwTxError,
               gpInterfaceList,
               gpSpecialAddrsList
               );

    (VOID) ApplyIfChangeToIniTnFilters(
               &dwTnError,
               gpInterfaceList,
               gpSpecialAddrsList
               );

    LEAVE_SPD_SECTION();

    if (dwMMError || dwTxError || dwTnError) {
        AuditEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            IPSECSVC_FAILED_PNP_FILTER_PROCESSING,
            NULL,
            FALSE,
            TRUE
            );
    }

error:
    return (dwError);
}

VOID
FormObseleteAndNewIfLists(
    IN     PIPSEC_INTERFACE   pIfList,
    IN OUT PIPSEC_INTERFACE * ppExistingIfList,
    OUT    PIPSEC_INTERFACE * ppObseleteIfList,
    OUT    PIPSEC_INTERFACE * ppNewIfList
    )
{
    PIPSEC_INTERFACE pObseleteIfList = NULL;
    PIPSEC_INTERFACE pNewIfList = NULL;
    PIPSEC_INTERFACE pIf = NULL;
    PIPSEC_INTERFACE pNewIf = NULL;
    PIPSEC_INTERFACE pTempIf = NULL;
    BOOL             bInterfaceExists = FALSE;
    PIPSEC_INTERFACE pExistingIf = NULL;
    PIPSEC_INTERFACE pExistingIfList = NULL;

    pExistingIfList = *ppExistingIfList;

    MarkInterfaceListSuspect(
        pExistingIfList
        );

    pIf = pIfList;

    while (pIf) {

        bInterfaceExists = InterfaceExistsInList(
                               pIf,
                               pExistingIfList,
                               &pExistingIf
                               );

        if (bInterfaceExists) {

            // Interface already exists in the list.
            // Delete the interface.

            pTempIf = pIf;
            pIf = pIf->pNext;
            FreeIpsecInterface(pTempIf);

            // The corresponding entry in the original interface list
            // is not a suspect any more.

            pExistingIf->bIsASuspect = FALSE;

        }
        else {

            // This is a new interface.
            // Add it to the list of new interfaces.

            pNewIf =  pIf;
            pIf = pIf->pNext;

            pTempIf = pNewIfList;
            pNewIfList = pNewIf;
            pNewIfList->pNext = pTempIf;

        }

    }

    DeleteObseleteInterfaces(
        &pExistingIfList,
        &pObseleteIfList
        );

    *ppExistingIfList = pExistingIfList;
    *ppObseleteIfList = pObseleteIfList;
    *ppNewIfList = pNewIfList;
}


VOID
AddToInterfaceList(
    IN  PIPSEC_INTERFACE   pIfListToAppend,
    OUT PIPSEC_INTERFACE * ppOriginalIfList
    )
{
    PIPSEC_INTERFACE pIf = NULL;
    PIPSEC_INTERFACE pIfToAppend = NULL;
    PIPSEC_INTERFACE pTempIf = NULL;

    pIf = pIfListToAppend;

    while (pIf) {

        pIfToAppend = pIf;
        pIf = pIf->pNext;
        
        pTempIf = *ppOriginalIfList;
        *ppOriginalIfList = pIfToAppend;
        (*ppOriginalIfList)->pNext = pTempIf;

    }
}


VOID
MarkInterfaceListSuspect(
    IN  PIPSEC_INTERFACE pExistingIfList
    )
{
    PIPSEC_INTERFACE pIf = NULL;

    pIf = pExistingIfList;

    while (pIf) {
        pIf->bIsASuspect = TRUE;
        pIf = pIf->pNext;
    }
}


VOID
DeleteObseleteInterfaces(
    IN  OUT PIPSEC_INTERFACE * ppExistingIfList,
    OUT     PIPSEC_INTERFACE * ppObseleteIfList
    )
{
    PIPSEC_INTERFACE pCurIf = NULL;
    PIPSEC_INTERFACE pPreIf = NULL;
    PIPSEC_INTERFACE pStartIf = NULL;
    PIPSEC_INTERFACE pObseleteIfList = NULL;
    PIPSEC_INTERFACE pObseleteIf = NULL;
    PIPSEC_INTERFACE pTempIf = NULL;

    pCurIf = *ppExistingIfList;
    pStartIf = pCurIf;

    while (pCurIf) {

        if (pCurIf->bIsASuspect) {

            pObseleteIf = pCurIf;
            pCurIf = pCurIf->pNext;

            if (pPreIf) {
                pPreIf->pNext = pCurIf;
            }
            else {
                pStartIf = pCurIf;
            }

            pTempIf = pObseleteIfList;
            pObseleteIfList = pObseleteIf;
            pObseleteIfList->pNext = pTempIf;

        }
        else {

            pPreIf = pCurIf;
            pCurIf = pCurIf->pNext;

        }

    }

    *ppObseleteIfList = pObseleteIfList;
    *ppExistingIfList = pStartIf;
}


BOOL
InterfaceExistsInList(
    IN  PIPSEC_INTERFACE   pTestIf,
    IN  PIPSEC_INTERFACE   pExistingIfList,
    OUT PIPSEC_INTERFACE * ppExistingIf
    )
{
    PIPSEC_INTERFACE pIf = NULL;
    PIPSEC_INTERFACE pExistingIf = NULL;
    BOOL             bIfExists = FALSE;

    pIf = pExistingIfList;

    while (pIf) {

        if ((pIf->dwIndex == pTestIf->dwIndex) &&
            (pIf->IpAddress == pTestIf->IpAddress)) {

            bIfExists = TRUE;
            pExistingIf = pIf;

            break;

        }

        pIf = pIf->pNext;

    }

    *ppExistingIf = pExistingIf;
    return (bIfExists);
}


DWORD
GetInterfaceListFromStack(
    OUT PIPSEC_INTERFACE *ppIfList
    )
{
    DWORD            dwError = 0;
    PMIB_IPADDRTABLE pMibIpAddrTable = NULL;
    PMIB_IFTABLE     pMibIfTable = NULL;
    PIPSEC_INTERFACE pIfList = NULL;

    dwError = PaPNPGetIpAddrTable(
                  &pMibIpAddrTable
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = PaPNPGetIfTable(
                  &pMibIfTable
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = GenerateInterfaces(
                  pMibIpAddrTable,
                  pMibIfTable,
                  &pIfList
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    
    *ppIfList = pIfList;

cleanup:

    if (pMibIfTable) {
        LocalFree(pMibIfTable);
    }

    if (pMibIpAddrTable) {
        LocalFree(pMibIpAddrTable);
    }

    return (dwError);

error:

    AuditEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        IPSECSVC_INTERFACE_LIST_INCOMPLETE,
        NULL,
        FALSE,
        TRUE
        );
    *ppIfList = NULL;

    TRACE(TRC_ERROR, (L"Failed to get interface list from stack: %!winerr!", dwError));        
    goto cleanup;
}


DWORD
GenerateInterfaces(
    IN  PMIB_IPADDRTABLE   pMibIpAddrTable,
    IN  PMIB_IFTABLE       pMibIfTable,
    OUT PIPSEC_INTERFACE * ppIfList
    )
{
    DWORD            dwError = 0;
    DWORD            dwInterfaceType = 0;
    ULONG            IpAddress = 0;
    DWORD            dwIndex = 0;
    DWORD            dwNumEntries = 0;
    DWORD            dwCnt = 0;
    PMIB_IFROW       pMibIfRow = NULL;
    PIPSEC_INTERFACE pNewIf = NULL;
    PIPSEC_INTERFACE pTempIf = NULL;
    PIPSEC_INTERFACE pIfList = NULL;
    DWORD            dwNewIfsCnt = 0;

    dwNumEntries = pMibIpAddrTable->dwNumEntries;

    for (dwCnt = 0; dwCnt < dwNumEntries; dwCnt++) {

        dwIndex = pMibIpAddrTable->table[dwCnt].dwIndex;

        pMibIfRow = GetMibIfRow(
                        pMibIfTable,
                        dwIndex
                        );
        if (!pMibIfRow) {
            continue;
        }

        IpAddress = pMibIpAddrTable->table[dwCnt].dwAddr;
        dwInterfaceType = pMibIfRow->dwType;

        dwError = CreateNewInterface(
                      dwInterfaceType,
                      IpAddress,
                      dwIndex,
                      pMibIfRow,
                      &pNewIf
                      );
        if (dwError) {
            continue;
        }

        pTempIf = pIfList;
        pIfList = pNewIf;
        pIfList->pNext = pTempIf;
        dwNewIfsCnt++;

    }

    if (dwNewIfsCnt) {
        *ppIfList = pIfList;
        dwError = ERROR_SUCCESS;
    }
    else {
        *ppIfList = NULL;
        dwError = ERROR_INVALID_DATA;
    }

    return (dwError);
}


BOOL 
IsInSpecialAddrList(
    PSPECIAL_ADDR pSpecialAddrList,
    PSPECIAL_ADDR pInSpecialAddr
    )
{
    PSPECIAL_ADDR pSpecialAddr;
    
    for (pSpecialAddr = pSpecialAddrList;
         pSpecialAddr;
         pSpecialAddr = pSpecialAddr->pNext) {
        if (pSpecialAddr->AddrType == pInSpecialAddr->AddrType
            && pSpecialAddr->uIpAddr == pInSpecialAddr->uIpAddr
            && pSpecialAddr->InterfaceType 
               == pInSpecialAddr->InterfaceType) {

            return TRUE;
        }
    }

    return FALSE;
}

BOOL
IsSpecialListSame(
    PSPECIAL_ADDR pSpecialAddrList1,
    PSPECIAL_ADDR pSpecialAddrList2
    )
{
    PSPECIAL_ADDR pSpecialAddr;
    
    for (pSpecialAddr = pSpecialAddrList1;
         pSpecialAddr;
         pSpecialAddr = pSpecialAddr->pNext) {
         if (!IsInSpecialAddrList(
                pSpecialAddrList2,
                pSpecialAddr
                )) {

              return FALSE;
         }
   }
         
    for (pSpecialAddr = pSpecialAddrList2;
         pSpecialAddr;
         pSpecialAddr = pSpecialAddr->pNext) {
         if (!IsInSpecialAddrList(
                 pSpecialAddrList1,
                 pSpecialAddr
                 )) {

              return FALSE;
         }
    }
         
    return TRUE;
}

DWORD 
NoDupAddSpecialAddr(
    PSPECIAL_ADDR *ppSpecialAddrList,
    ADDR_TYPE AddrType,
    IP_ADDRESS_STRING IpAddr,    
    DWORD dwInterfaceType
    )
{
    PSPECIAL_ADDR pSpecialAddr;
    BOOL       Found = FALSE;
    BOOL       bDupInterface = FALSE;
    PSPECIAL_ADDR pSpecialAddrList;
    DWORD dwError = ERROR_SUCCESS;
    IF_TYPE      IfType = 0;
    ULONG uIpAddr;

    uIpAddr = inet_addr(
                 IpAddr.String
              );
        
    if (uIpAddr == INADDR_NONE || !uIpAddr) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
     }

    if (IsDialUp(dwInterfaceType)) {
        IfType = INTERFACE_TYPE_DIALUP;
    }    
    else if (IsLAN(dwInterfaceType)) {
        IfType = INTERFACE_TYPE_LAN;
    }
    
    //
    // Search if an exact entry already exists or if a similar entry
    // with different InterfaceType exists
    // 
    for (pSpecialAddr = *ppSpecialAddrList;
         pSpecialAddr;
         pSpecialAddr = pSpecialAddr->pNext) {
        if (pSpecialAddr->AddrType == AddrType
            && pSpecialAddr->uIpAddr == uIpAddr) {
            if (pSpecialAddr->InterfaceType == IfType) {
                Found = TRUE;

                break;
             }
             else {
                 bDupInterface = TRUE;  
             }
        }
    }

    //
    // Add new address to list head if it doesn't exist
    //
    if (!Found) {
        dwError = AllocateSPDMemory(
                      sizeof(SPECIAL_ADDR),
                      &pSpecialAddr);
        BAIL_ON_WIN32_ERROR(dwError);
        pSpecialAddr->AddrType         = AddrType;
        pSpecialAddr->uIpAddr          = uIpAddr;
        pSpecialAddr->InterfaceType    = IfType;
        pSpecialAddr->bDupInterface    = bDupInterface;
        pSpecialAddr->pNext = *ppSpecialAddrList;
        *ppSpecialAddrList = pSpecialAddr;
    }
        
error:
    return dwError;
}
    
DWORD 
FreeSpecialAddrList(
    PSPECIAL_ADDR *ppSpecialAddrList
    )
{
    PSPECIAL_ADDR pSpecialAddr;
    PSPECIAL_ADDR pTemp;

    for (pSpecialAddr = *ppSpecialAddrList;
         pSpecialAddr;
         pSpecialAddr = pTemp) {
       pTemp = pSpecialAddr->pNext;
       FreeSPDMemory(pSpecialAddr);
   }

   *ppSpecialAddrList = NULL;
   
   return ERROR_SUCCESS;
}
    

DWORD 
AllocAndGetAdaptersInfo(
    PIP_ADAPTER_INFO *ppAdapterInfo,
    ULONG *pulOutBufLen
    )
{
    DWORD            dwError      = ERROR_SUCCESS;
    PIP_ADAPTER_INFO pAdapterInfo = NULL;
    ULONG            ulOutBufLen  = 0;

    dwError = GetAdaptersInfo(
                  pAdapterInfo,
                  &ulOutBufLen
                  );

    if (dwError == ERROR_BUFFER_OVERFLOW) {
        dwError = AllocateSPDMemory(
                      ulOutBufLen,
                      &pAdapterInfo
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        
        dwError = GetAdaptersInfo(
                      pAdapterInfo,
                      &ulOutBufLen
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }
    else {
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppAdapterInfo =  pAdapterInfo;
    *pulOutBufLen  =  ulOutBufLen;

    return dwError;
error:
    if (pAdapterInfo) {
        FreeSPDMemory(pAdapterInfo);
    }
    *ppAdapterInfo = NULL;
    *pulOutBufLen  =0;
    return dwError;
}

DWORD 
AllocAndGetPerAdapterInfo(
    ULONG IfIndex,
    PIP_PER_ADAPTER_INFO *ppPerAdapterInfo,
    ULONG *pulOutBufLen
    )
{
    DWORD                dwError         = ERROR_SUCCESS;
    PIP_PER_ADAPTER_INFO pPerAdapterInfo = NULL;
    ULONG                ulOutBufLen     = 0;

    dwError = GetPerAdapterInfo(
                  IfIndex,
                  pPerAdapterInfo,
                  &ulOutBufLen
                  );
    if (dwError == ERROR_BUFFER_OVERFLOW) {
        dwError = AllocateSPDMemory(
                      ulOutBufLen,
                      &pPerAdapterInfo
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        
        dwError = GetPerAdapterInfo(
                      IfIndex,
                      pPerAdapterInfo,
                      &ulOutBufLen
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }    
    else {
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppPerAdapterInfo =  pPerAdapterInfo;
    *pulOutBufLen  =  ulOutBufLen;

    return dwError;
error:
    if (pPerAdapterInfo) {
        FreeSPDMemory(pPerAdapterInfo);
    }
    *ppPerAdapterInfo = NULL;
    *pulOutBufLen  =0;
    return dwError;

}


DWORD
GetSpecialAddrsList(
    OUT PSPECIAL_ADDR *ppSpecialAddrsList
    )
{
    PSPECIAL_ADDR    pAddrs              = NULL;
    DWORD            dwAddrCnt           = 0;
    PIP_ADAPTER_INFO pAdapterInfo        = NULL;
    PIP_ADAPTER_INFO pAdapterInfoEnum    = NULL;
    PIP_PER_ADAPTER_INFO pPerAdapterInfo = NULL;
    ULONG            ulOutBufLen         = 0;
    PIP_ADDR_STRING  pIPAddrStr          = NULL;
    PSPECIAL_ADDR    pSpecialAddrsList   = NULL;

    DWORD            dwError             = ERROR_SUCCESS;
    DWORD i;

    dwError = AllocAndGetAdaptersInfo(
                  &pAdapterInfo,
                  &ulOutBufLen
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    
    //
    // Fill in special addresses
    //
 
    pAdapterInfoEnum = pAdapterInfo;
    while (pAdapterInfoEnum) {
        if (pAdapterInfoEnum->DhcpEnabled) {
            (VOID) NoDupAddSpecialAddr(
                       &pSpecialAddrsList,
                       IP_ADDR_DHCP_SERVER,
                       pAdapterInfoEnum->DhcpServer.IpAddress,
                       pAdapterInfoEnum->Type
                       );
        }
        
        (VOID) NoDupAddSpecialAddr(
                       &pSpecialAddrsList,
                       IP_ADDR_DEFAULT_GATEWAY,
                       pAdapterInfoEnum->GatewayList.IpAddress,
                       pAdapterInfoEnum->Type
                       );

        if (pAdapterInfoEnum->HaveWins) {
           (VOID) NoDupAddSpecialAddr(
                       &pSpecialAddrsList,
                       IP_ADDR_WINS_SERVER,
                       pAdapterInfoEnum->PrimaryWinsServer.IpAddress,
                       pAdapterInfoEnum->Type
                       );
           // Get Secondary WINS
            pIPAddrStr = &pAdapterInfoEnum->SecondaryWinsServer;
            while (pIPAddrStr) {
               (VOID) NoDupAddSpecialAddr(
                       &pSpecialAddrsList,
                       IP_ADDR_WINS_SERVER,
                       pIPAddrStr->IpAddress,
                       pAdapterInfoEnum->Type
                       );

                pIPAddrStr = pIPAddrStr->Next;
            }
           
        }

        //
        // Get DNS servers
        //
        dwError = AllocAndGetPerAdapterInfo(
                      pAdapterInfoEnum->Index,
                      &pPerAdapterInfo,
                      &ulOutBufLen
                      );
        
        if (dwError == ERROR_SUCCESS) {
            pIPAddrStr = &pPerAdapterInfo->DnsServerList;
            while (pIPAddrStr) {
               (VOID) NoDupAddSpecialAddr(
                       &pSpecialAddrsList,
                       IP_ADDR_DNS_SERVER,
                       pIPAddrStr->IpAddress,
                       pAdapterInfoEnum->Type
                       );

                pIPAddrStr = pIPAddrStr->Next;
            }
            
            FreeSPDMemory(
                pPerAdapterInfo
                );
            pPerAdapterInfo = NULL;    
        }
        
        pAdapterInfoEnum = pAdapterInfoEnum->Next;
    }

    FreeSPDMemory(
        pAdapterInfo
        );
    *ppSpecialAddrsList = pSpecialAddrsList;

    return dwError;    

error:
    FreeSPDMemory(
        pAdapterInfo
        );
    *ppSpecialAddrsList = NULL;

    TRACE(TRC_WARNING, (L"Failed to create list of special servers: %!winerr!", dwError));
    return dwError;    
}

PMIB_IFROW
GetMibIfRow(
    IN  PMIB_IFTABLE pMibIfTable,
    IN  DWORD        dwIndex
    )
{
    DWORD      i = 0;
    PMIB_IFROW pMibIfRow = NULL;

    for (i = 0; i < pMibIfTable->dwNumEntries; i++) {

        if (pMibIfTable->table[i].dwIndex == dwIndex) {
            pMibIfRow = &(pMibIfTable->table[i]);
            break;
        }

    }

    return (pMibIfRow);
}


DWORD
CreateNewInterface(
    IN  DWORD              dwInterfaceType,
    IN  ULONG              IpAddress,
    IN  DWORD              dwIndex,
    IN  PMIB_IFROW         pMibIfRow,
    OUT PIPSEC_INTERFACE * ppNewInterface
    )
{
    DWORD            dwError =  0;
    PIPSEC_INTERFACE pNewInterface = NULL;
    LPWSTR pszString = NULL;
    LPWSTR pszTemp = NULL;
    WCHAR szDeviceName[MAXLEN_IFDESCR*sizeof(WCHAR)];
    GUID gInterfaceID;

    
    szDeviceName[0] = L'\0';

    if (IpAddress == INADDR_ANY) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    else {
        if (dwInterfaceType == MIB_IF_TYPE_LOOPBACK) {
            dwError = ERROR_INVALID_DATA;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    pszString = AllocSPDStr(pMibIfRow->wszName);
    if (!pszString) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (wcslen(pszString) <= wcslen(L"\\DEVICE\\TCPIP_")) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pszTemp = pszString + wcslen(L"\\DEVICE\\TCPIP_");

    wGUIDFromString(pszTemp, &gInterfaceID);

    pNewInterface = (PIPSEC_INTERFACE) AllocSPDMem(
                                           sizeof(IPSEC_INTERFACE)
                                           );
    if (!pNewInterface) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pNewInterface->dwInterfaceType = dwInterfaceType;
    pNewInterface->IpAddress = IpAddress;
    pNewInterface->dwIndex = dwIndex;
    pNewInterface->bIsASuspect = FALSE;

    memcpy(
        &pNewInterface->gInterfaceID,
        &gInterfaceID,
        sizeof(GUID)
        );

    pNewInterface->pszInterfaceName = NULL;

    mbstowcs(
        szDeviceName,
        pMibIfRow->bDescr,
        MAXLEN_IFDESCR
        );
        
    pNewInterface->pszDeviceName = AllocSPDStr(
                                       szDeviceName
                                       );
    if (!pNewInterface->pszDeviceName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pNewInterface->pNext = NULL;

    *ppNewInterface = pNewInterface;

cleanup:

    if (pszString) {
        FreeSPDStr(pszString);
    }

    return(dwError);

error:

    *ppNewInterface = NULL;

    if (pNewInterface) {
        FreeIpsecInterface(pNewInterface);
    }

    goto cleanup;
}


BOOL
MatchInterfaceType(
    IN DWORD    dwIfListEntryIfType,
    IN IF_TYPE  FilterIfType
    )
{
    BOOL bMatchesType = FALSE;

    if (FilterIfType == INTERFACE_TYPE_ALL) {
        bMatchesType = TRUE;
    }
    else if (FilterIfType == INTERFACE_TYPE_LAN) {
        bMatchesType = IsLAN(dwIfListEntryIfType);
    }
    else if (FilterIfType == INTERFACE_TYPE_DIALUP) {
        bMatchesType = IsDialUp(dwIfListEntryIfType);
    }

    return (bMatchesType);
}

BOOL
IsLAN(
    IN DWORD dwInterfaceType
    )
{
    BOOL bIsLAN = FALSE;

    if ((dwInterfaceType == MIB_IF_TYPE_ETHERNET) ||
        (dwInterfaceType == MIB_IF_TYPE_FDDI) ||
        (dwInterfaceType == MIB_IF_TYPE_TOKENRING)) {
        bIsLAN = TRUE;
    }

    return (bIsLAN);
}


BOOL
IsDialUp(
    IN DWORD dwInterfaceType
    )
{
    BOOL bIsDialUp = FALSE;

    if ((dwInterfaceType == MIB_IF_TYPE_PPP) ||
        (dwInterfaceType == MIB_IF_TYPE_SLIP)) {
        bIsDialUp = TRUE;
    }

    return (bIsDialUp);
}


DWORD
InitializeInterfaceChangeEvent(
    )
{
    DWORD   dwError = 0;
    WORD    wsaVersion = MAKEWORD(2,0);

    memset(&gwsaOverlapped, 0, sizeof(WSAOVERLAPPED));

    // Start up WinSock.

    dwError = WSAStartup(
                  wsaVersion,
                  &gwsaData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    gbwsaStarted = TRUE;

    if ((LOBYTE(gwsaData.wVersion) != LOBYTE(wsaVersion)) ||
        (HIBYTE(gwsaData.wVersion) != HIBYTE(wsaVersion))) {
        dwError = WSAVERNOTSUPPORTED; 
        BAIL_ON_WIN32_ERROR(dwError);
    }

    // Set up the Socket.

    gIfChangeEventSocket = WSASocket(
                               AF_INET,
                               SOCK_DGRAM,
                               0,
                               NULL,
                               0,
                               WSA_FLAG_OVERLAPPED
                               );
    if (gIfChangeEventSocket == INVALID_SOCKET) {
        dwError = WSAGetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ghIfChangeEvent = WSACreateEvent();
    if (ghIfChangeEvent == WSA_INVALID_EVENT) {
        dwError = WSAGetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ghOverlapEvent = WSACreateEvent();
    if (ghOverlapEvent == WSA_INVALID_EVENT) {
        dwError = WSAGetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }
    gwsaOverlapped.hEvent = ghOverlapEvent;
    return (dwError);
error:
    TRACE(TRC_ERROR, (L"Failed to initialize interface change event: %!winerr!", dwError));
    return (dwError);
}


DWORD
ResetInterfaceChangeEvent(
    )
{
    DWORD dwError = 0;
    LONG  lNetworkEvents = FD_ADDRESS_LIST_CHANGE;
    DWORD dwOutSize = 0;

    ResetEvent(ghIfChangeEvent);
    gbIsIoctlPended = FALSE;

    dwError = WSAIoctl(
                  gIfChangeEventSocket,
                  SIO_ADDRESS_LIST_CHANGE,
                  NULL,
                  0,
                  NULL,
                  0,
                  &dwOutSize,
                  &gwsaOverlapped,
                  NULL
                  );

    if (dwError == SOCKET_ERROR) {
        dwError = WSAGetLastError();
        if (dwError != ERROR_IO_PENDING) {
            TRACE(TRC_ERROR, (L"Failed to register for interface change event: %!winerr!", dwError));
            return (dwError);
        }
        else {
            gbIsIoctlPended = TRUE;
        }
    }

    dwError = WSAEventSelect(
                  gIfChangeEventSocket,
                  ghIfChangeEvent,
                  lNetworkEvents
                  );
#ifdef TRACE_ON
    if (dwError) {
        TRACE(TRC_ERROR, (L"Failed to associate socket with interface change event: %!winerr!", dwError));
    }
#endif    
    return (dwError);
}


VOID
DestroyInterfaceChangeEvent(
    )
{
    DWORD dwStatus = 0;
    BOOL bDoneWaiting = FALSE;


    if (gIfChangeEventSocket) {
        closesocket(gIfChangeEventSocket);        
        if (gbIsIoctlPended) {
            while (!bDoneWaiting) {
                dwStatus = WaitForSingleObject(
                               ghOverlapEvent,
                               1000
                               );
                switch (dwStatus) {
                case WAIT_OBJECT_0:
                    bDoneWaiting = TRUE;
                    break;
                case WAIT_TIMEOUT:
                    ASSERT(FALSE);
                    break;
                default:
                    bDoneWaiting = TRUE;
                    ASSERT(FALSE);
                    break;
                }
            }
        }
    }

    if (ghIfChangeEvent) {
        CloseHandle(ghIfChangeEvent);
    }

    if (ghOverlapEvent) {
        CloseHandle(ghOverlapEvent);
    }

    if (gbwsaStarted) {
        WSACleanup();
    }
}


HANDLE
GetInterfaceChangeEvent(
    )
{
    return ghOverlapEvent;
}


BOOL
IsMyAddress(
    IN ULONG            IpAddrToCheck,
    IN ULONG            IpAddrMask,
    IN PIPSEC_INTERFACE pExistingIfList
    )
{
    BOOL bIsMyAddress = FALSE;
    PIPSEC_INTERFACE pIf = NULL;

    pIf = pExistingIfList;

    while (pIf) {

        if ((pIf->IpAddress & IpAddrMask) ==
            (IpAddrToCheck & IpAddrMask)) {

            bIsMyAddress = TRUE;
            break;

        }

        pIf = pIf->pNext;

    }

    return (bIsMyAddress);
}


VOID
PrintInterfaceList(
    IN PIPSEC_INTERFACE pInterfaceList
    )
{
    WCHAR            PrintData[256];
    PIPSEC_INTERFACE pInterface = NULL;
    DWORD            i = 0;

    pInterface = pInterfaceList;

    while (pInterface) {
        
        wsprintf(PrintData, L"Interface Entry no. %d\n", i+1);
        OutputDebugString((LPCTSTR) PrintData);

        wsprintf(PrintData, L"\tInterface Type:  %d\n", pInterface->dwInterfaceType);
        OutputDebugString((LPCTSTR) PrintData);

        wsprintf(PrintData, L"\tIP Address:  %d\n", pInterface->IpAddress);
        OutputDebugString((LPCTSTR) PrintData);

        wsprintf(PrintData, L"\tIndex:  %d\n", pInterface->dwIndex);
        OutputDebugString((LPCTSTR) PrintData);

        wsprintf(PrintData, L"\tIs a suspect:  %d\n", pInterface->bIsASuspect);
        OutputDebugString((LPCTSTR) PrintData);

        i++;
        pInterface = pInterface->pNext;

    }
}


DWORD
GetMatchingInterfaces(
    IF_TYPE             FilterInterfaceType,
    PIPSEC_INTERFACE    pExistingIfList,
    MATCHING_ADDR    ** ppMatchingAddresses,
    DWORD             * pdwAddrCnt
    )
{
    DWORD               dwError = 0;
    MATCHING_ADDR     * pMatchingAddresses = NULL;
    PIPSEC_INTERFACE    pTempIf = NULL;
    BOOL                bMatches = FALSE;
    DWORD               dwCnt = 0;
    DWORD               i = 0;

    pTempIf = pExistingIfList;
    while (pTempIf) {

        bMatches = MatchInterfaceType(
                       pTempIf->dwInterfaceType,
                       FilterInterfaceType
                       );
        if (bMatches) {
            dwCnt++;
        }
        pTempIf = pTempIf->pNext;

    }        

    if (!dwCnt) {
        dwError = ERROR_SUCCESS;
        BAIL_ON_WIN32_SUCCESS(dwError);
    }

    dwError = AllocateSPDMemory(
                  sizeof(MATCHING_ADDR) * dwCnt,
                  (LPVOID *) &pMatchingAddresses
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTempIf = pExistingIfList;
    while (pTempIf) {

        bMatches = MatchInterfaceType(
                       pTempIf->dwInterfaceType,
                       FilterInterfaceType
                       );
        if (bMatches) {
            pMatchingAddresses[i].uIpAddr = pTempIf->IpAddress;
            memcpy(
                &pMatchingAddresses[i].gInterfaceID,
                &pTempIf->gInterfaceID,
                sizeof(GUID)
                );
            i++;
        }
        pTempIf = pTempIf->pNext;

    }

    *ppMatchingAddresses = pMatchingAddresses;
    *pdwAddrCnt = i;
    return (dwError);

success:
error:

    *ppMatchingAddresses = NULL;
    *pdwAddrCnt = 0;
    return (dwError);
}


BOOL
InterfaceAddrIsLocal(
    ULONG            uIpAddr,
    ULONG            uIpAddrMask,
    MATCHING_ADDR  * pLocalAddresses,
    DWORD            dwAddrCnt
    )
{
    BOOL    bIsLocal = FALSE;
    DWORD   i = 0;


    for (i = 0; i < dwAddrCnt; i++) {

        if ((pLocalAddresses[i].uIpAddr & uIpAddrMask) ==
            (uIpAddr & uIpAddrMask)) {

            bIsLocal = TRUE;
            break;

        }

    }

    return (bIsLocal);
}


VOID
FreeIpsecInterface(
    PIPSEC_INTERFACE pIpsecInterface
    )
{
    if (pIpsecInterface) {

        if (pIpsecInterface->pszInterfaceName) {
            FreeSPDStr(pIpsecInterface->pszInterfaceName);
        }

        if (pIpsecInterface->pszDeviceName) {
            FreeSPDStr(pIpsecInterface->pszDeviceName);
        }

        FreeSPDMem(pIpsecInterface);

    }
}


DWORD
EnumIPSecInterfaces(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_INTERFACE_INFO pIpsecIfTemplate,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PIPSEC_INTERFACE_INFO * ppIpsecInterfaces,
    LPDWORD pdwNumInterfaces,
    LPDWORD pdwNumTotalInterfaces,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    DWORD dwResumeHandle = 0;
    DWORD dwNumToEnum = 0;
    PIPSEC_INTERFACE pIpsecIf = NULL;
    DWORD dwNumTotalInterfaces = 0;
    DWORD i = 0;
    PIPSEC_INTERFACE pTempIf = NULL;
    DWORD dwNumInterfaces = 0;
    PIPSEC_INTERFACE_INFO pIpsecInterfaces = NULL;
    PIPSEC_INTERFACE_INFO pTempInterface = NULL;


    dwResumeHandle = *pdwResumeHandle;

    if (!dwPreferredNumEntries || (dwPreferredNumEntries > MAX_INTERFACE_ENUM_COUNT)) {
        dwNumToEnum = MAX_INTERFACE_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIpsecIf = gpInterfaceList;

    for (i = 0; (i < dwResumeHandle) && (pIpsecIf != NULL); i++) {
        dwNumTotalInterfaces++;
        pIpsecIf = pIpsecIf->pNext;
    }

    if (!pIpsecIf) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    pTempIf = pIpsecIf;

    while (pTempIf && (dwNumInterfaces < dwNumToEnum)) {
        dwNumTotalInterfaces++;
        dwNumInterfaces++;
        pTempIf = pTempIf->pNext;
    }

    while (pTempIf) {
        dwNumTotalInterfaces++;
        pTempIf = pTempIf->pNext;
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_INTERFACE_INFO)*dwNumInterfaces,
                  &pIpsecInterfaces
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pTempIf = pIpsecIf;
    pTempInterface = pIpsecInterfaces;

    for (i = 0; i < dwNumInterfaces; i++) {

        dwError = CopyIpsecInterface(
                      pTempIf,
                      pTempInterface
                      );
        BAIL_ON_LOCK_ERROR(dwError);

        pTempIf = pTempIf->pNext;
        pTempInterface++;

    }

    *ppIpsecInterfaces = pIpsecInterfaces;
    *pdwNumInterfaces = dwNumInterfaces;
    *pdwNumTotalInterfaces = dwNumTotalInterfaces;
    *pdwResumeHandle = dwResumeHandle + dwNumInterfaces;

    LEAVE_SPD_SECTION();

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    if (pIpsecInterfaces) {
        FreeIpsecInterfaceInfos(
            i,
            pIpsecInterfaces
            );
    }

    *ppIpsecInterfaces = NULL;
    *pdwNumInterfaces = 0;
    *pdwNumTotalInterfaces = 0;
    *pdwResumeHandle = dwResumeHandle;

    return (dwError);
}


DWORD
CopyIpsecInterface(
    PIPSEC_INTERFACE pIpsecIf,
    PIPSEC_INTERFACE_INFO pIpsecInterface
    )
{
    DWORD dwError = 0;


    memcpy(
        &(pIpsecInterface->gInterfaceID),
        &(pIpsecIf->gInterfaceID),
        sizeof(GUID)
        );

    pIpsecInterface->dwIndex = pIpsecIf->dwIndex;

    if (!(pIpsecIf->pszInterfaceName)) {
        (VOID) GetInterfaceName(
                   pIpsecIf->gInterfaceID,
                   &pIpsecIf->pszInterfaceName
                   );
    }

    if (pIpsecIf->pszInterfaceName) {

        dwError =  SPDApiBufferAllocate(
                       wcslen(pIpsecIf->pszInterfaceName)*sizeof(WCHAR)
                       + sizeof(WCHAR),
                       &(pIpsecInterface->pszInterfaceName)
                       );
        BAIL_ON_WIN32_ERROR(dwError);

        wcscpy(pIpsecInterface->pszInterfaceName, pIpsecIf->pszInterfaceName);

    }

    dwError =  SPDApiBufferAllocate(
                   wcslen(pIpsecIf->pszDeviceName)*sizeof(WCHAR)
                   + sizeof(WCHAR),
                   &(pIpsecInterface->pszDeviceName)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(pIpsecInterface->pszDeviceName, pIpsecIf->pszDeviceName);

    pIpsecInterface->dwInterfaceType = pIpsecIf->dwInterfaceType;

    pIpsecInterface->IpVersion = IPSEC_PROTOCOL_V4;
    pIpsecInterface->uIpAddr = pIpsecIf->IpAddress;

    return (dwError);

error:

    if (pIpsecInterface->pszInterfaceName) {
        SPDApiBufferFree(pIpsecInterface->pszInterfaceName);
    }

    return (dwError);
}


VOID
FreeIpsecInterfaceInfos(
    DWORD dwNumInterfaces,
    PIPSEC_INTERFACE_INFO pIpsecInterfaces
    )
{
    PIPSEC_INTERFACE_INFO pTempInterface = NULL;
    DWORD i = 0;


    if (!pIpsecInterfaces) {
        return;
    }

    pTempInterface = pIpsecInterfaces;

    for (i = 0; i < dwNumInterfaces; i++) {

        if (pTempInterface->pszInterfaceName) {
            SPDApiBufferFree(pTempInterface->pszInterfaceName);
        }

        if (pTempInterface->pszDeviceName) {
            SPDApiBufferFree(pTempInterface->pszDeviceName);
        }

        pTempInterface++;

    }

    SPDApiBufferFree(pIpsecInterfaces);
}


DWORD
GetInterfaceName(
    GUID gInterfaceID,
    LPWSTR * ppszInterfaceName
    )
{
    DWORD dwError = 0;
    DWORD dwSize = 0;
    WCHAR szInterfaceName[512];


    *ppszInterfaceName = NULL;
    szInterfaceName[0] = L'\0';

    dwSize = sizeof(szInterfaceName)/sizeof(WCHAR);

    dwError = NhGetInterfaceNameFromGuid(
                  &gInterfaceID,
                  szInterfaceName,
                  &dwSize,
                  FALSE,
                  FALSE
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppszInterfaceName = AllocSPDStr(
                            szInterfaceName
                            );

error:

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\memory.h ===
#ifndef _MEMORY_H_INCLUDED_
#define _MEMORY_H_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

LPVOID
AllocSPDMem(
    DWORD cb
);

BOOL
FreeSPDMem(
   LPVOID pMem
);

LPVOID
ReallocSPDMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
);

LPWSTR
AllocSPDStr(
    LPWSTR pStr
);

BOOL
FreeSPDStr(
   LPWSTR pStr
);


BOOL
ReallocSPDStr(
   LPWSTR *ppStr,
   LPWSTR pStr
);

DWORD
AllocateSPDMemory(
    DWORD cb,
    LPVOID * ppMem
    );

void
FreeSPDMemory(
    LPVOID pMem
    );

DWORD
AllocateSPDString(
    LPWSTR pszString,
    LPWSTR * ppszNewString
    );

void
FreeSPDString(
    LPWSTR pszString
    );


#if DBG

extern LIST_ENTRY SPDMemList ;

extern CRITICAL_SECTION SPDMemCritSect ;

VOID InitSPDMem(
    VOID
    ) ;

VOID AssertSPDMemLeaks(
    VOID
    ) ;


VOID
DumpMemoryTracker();


#else

#define InitSPDMem()
#define AssertSPDMemLeaks()

#define DumpMemoryTracker()



#endif


#ifdef __cplusplus
}
#endif

/*
inline void * _CRTAPI1
operator new(size_t size)
{
    return AllocSPDMem(size);
}

inline void  _CRTAPI1
operator delete(void * pv)
{
    FreeSPDMem(pv);
}*/


#endif // _MEMORY_H_INCLUDED_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\interface.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    interface.h

Abstract:

    This module contains all of the code prototypes to
    drive the interface list management of IPSecSPD Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif


DWORD
CreateInterfaceList(
    OUT PIPSEC_INTERFACE * ppIfListToCreate
    );


VOID
DestroyInterfaceList(
    IN PIPSEC_INTERFACE pIfListToDelete
    );


DWORD
OnInterfaceChangeEvent(
    );


VOID
FormObseleteAndNewIfLists(
    IN     PIPSEC_INTERFACE   pIfList,
    IN OUT PIPSEC_INTERFACE * ppExistingIfList,
    OUT    PIPSEC_INTERFACE * ppObseleteIfList,
    OUT    PIPSEC_INTERFACE * ppNewIfList
    );


VOID
AddToInterfaceList(
    IN  PIPSEC_INTERFACE   pIfListToAppend,
    OUT PIPSEC_INTERFACE * ppOriginalIfList
    );


VOID
MarkInterfaceListSuspect(
    IN  PIPSEC_INTERFACE pExistingIfList
    );


VOID
DeleteObseleteInterfaces(
    IN  OUT PIPSEC_INTERFACE * ppExistingIfList,
    OUT     PIPSEC_INTERFACE * ppObseleteIfList
    );


BOOL
InterfaceExistsInList(
    IN  PIPSEC_INTERFACE   pTestIf,
    IN  PIPSEC_INTERFACE   pExistingIfList,
    OUT PIPSEC_INTERFACE * ppExistingIf
    );

DWORD
GetSpecialAddrsList(
    OUT PSPECIAL_ADDR * ppSpecialAddrsList
    );
    
DWORD
GetInterfaceListFromStack(
    OUT PIPSEC_INTERFACE * ppIfList
    );


DWORD
GenerateInterfaces(
    IN  PMIB_IPADDRTABLE   pMibIpAddrTable,
    IN  PMIB_IFTABLE       pMibIfTable,
    OUT PIPSEC_INTERFACE * ppIfList
    );


PMIB_IFROW
GetMibIfRow(
    IN  PMIB_IFTABLE pMibIfTable,
    IN  DWORD        dwIndex
    );


DWORD
CreateNewInterface(
    IN  DWORD              dwInterfaceType,
    IN  ULONG              IpAddress,
    IN  DWORD              dwIndex,
    IN  PMIB_IFROW         pMibIfRow,
    OUT PIPSEC_INTERFACE * ppNewInterface
    );


BOOL
MatchInterfaceType(
    IN DWORD    dwIfListEntryIfType,
    IN IF_TYPE  dwFilterIfType
    );


BOOL
IsLAN(
    IN DWORD dwInterfaceType
    );


BOOL
IsDialUp(
    IN DWORD dwInterfaceType
    );


DWORD
InitializeInterfaceChangeEvent(
    );


DWORD
ResetInterfaceChangeEvent(
    );


VOID
DestroyInterfaceChangeEvent(
    );


HANDLE
GetInterfaceChangeEvent(
    );


BOOL
IsMyAddress(
    IN ULONG            IpAddrToCheck,
    IN ULONG            IpAddrMask,
    IN PIPSEC_INTERFACE pExistingIfList
    );


VOID
PrintInterfaceList(
    IN PIPSEC_INTERFACE pInterfaceList
    );


DWORD
GetMatchingInterfaces(
    IF_TYPE             FilterInterfaceType,
    PIPSEC_INTERFACE    pExistingIfList,
    MATCHING_ADDR    ** ppMatchingAddresses,
    DWORD             * pdwAddrCnt
    );


BOOL
InterfaceAddrIsLocal(
    ULONG            uIpAddr,
    ULONG            uIpAddrMask,
    MATCHING_ADDR  * pLocalAddresses,
    DWORD            dwAddrCnt
    );


VOID
FreeIpsecInterface(
    PIPSEC_INTERFACE pIpsecInterface
    );


DWORD
CopyIpsecInterface(
    PIPSEC_INTERFACE pIpsecIf,
    PIPSEC_INTERFACE_INFO pIpsecInterface
    );


VOID
FreeIpsecInterfaceInfos(
    DWORD dwNumInterfaces,
    PIPSEC_INTERFACE_INFO pIpsecInterfaces
    );


DWORD
GetInterfaceName(
    GUID gInterfaceID,
    LPWSTR * ppszInterfaceName
    );

DWORD
FreeSpecialAddrList(
    PSPECIAL_ADDR * ppSpecialAddrList
    );
    
DWORD
NoDupAddSpecialAddr(
    PSPECIAL_ADDR * ppSpecialAddrList,
    ADDR_TYPE AddrType,
    IP_ADDRESS_STRING IpAddr,    
    DWORD dwInterfaceType
    );
    
BOOL
IsInSpecialAddrList(
    PSPECIAL_ADDR pSpecialAddrList,
    PSPECIAL_ADDR pInSpecialAddr
    );
    
DWORD
OnSpecialAddrsChange(
    );
    
BOOL
IsSpecialListSame(
    PSPECIAL_ADDR pSpecialAddrList1,
    PSPECIAL_ADDR pSpecialAddrList2
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\midluser.c ===
/*++

Copyright (c) 1991 Microsoft Corporation


Module Name:

    midluser.c

Abstract:

    This file contains common functions and utilities that the API
    DLLs can use in making remote calls.  This includes the
    MIDL_USER_ALLOCATE functions.

Author:

    danl    02/06/1991

Environment:

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


PVOID
MIDL_user_allocate(
    IN size_t NumBytes
    )
/*++

Routine Description:

    Allocates storage for RPC transactions. The RPC stubs will either call
    MIDL_user_allocate when it needs to un-marshall data into a buffer
    that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - the number of bytes to allocate.

Return Value:

    None.

--*/
{
    return (LocalAlloc(0,NumBytes));
}


VOID
MIDL_user_free(
    IN void * MemPointer
    )
/*++

Routine Description:

    Frees storage used in RPC transactions. The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - pointer to the memory block that is to be released.

Return Value:

    None.

--*/

{
    LocalFree(MemPointer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\iphlpwrp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    iphlpwrp.h

Abstract:

    This module contains all of the code prototypes to
    wrap the ip public help apis for getting the list of
    active interfaces on a machine.

Author:

    krishnaG

Environment

    User Level: Win32

Revision History:

    abhisheV    30-September-1999

--*/


#ifdef __cplusplus
extern "C" {
#endif


DWORD
PaPNPGetIfTable(
    OUT PMIB_IFTABLE * ppMibIfTable
    );


DWORD
PaPNPGetInterfaceInformation(
    OUT PIP_INTERFACE_INFO * ppInterfaceInfo
    );


VOID
PrintMibIfTable(
    IN PMIB_IFTABLE pMibIfTable
    );


VOID
PrintInterfaceInfo(
    IN PIP_INTERFACE_INFO pInterfaceInfo
    );


VOID
PrintMibAddrTable(
    IN PMIB_IPADDRTABLE pMibAddrTable
    );


DWORD
PaPNPGetIpAddrTable(
    OUT PMIB_IPADDRTABLE * ppMibIpAddrTable
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\ipsecspd.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    ipsecspd.c

Abstract:

    This module contains all of the code to drive
    the IPSecSPD Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"

#ifdef TRACE_ON
#include "ipsecspd.tmh"
#endif

SERVICE_STATUS           IPSecSPDStatus;
SERVICE_STATUS_HANDLE    IPSecSPDStatusHandle = NULL;


#define IPSECSPD_SERVICE        L"PolicyAgent"


void WINAPI
SPDServiceMain(
    IN DWORD    dwArgc,
    IN LPTSTR * lpszArgv
    )
{
    DWORD dwError = 0;
    DWORD dwTempError = 0;

    WPP_INIT_TRACING(SPD_WPP_APPNAME);

    // Sleep(30000);
    
    InitMiscGlobals();

    dwError = InitAuditing();
    BAIL_ON_WIN32_ERROR(dwError);

    InitSPDThruRegistry();
    
    //
    // Open the IPSec Driver first, so that if we bail on error later,
    // we can still set driver in block mode.
    //
    
    dwError = SPDOpenIPSecDriver(
                  &ghIPSecDriver
                  );
    if (dwError) {
        AuditOneArgErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            IPSECSVC_DRIVER_INIT_FAILURE,
            dwError,
            FALSE,
            TRUE
            );
    }
    BAIL_ON_WIN32_ERROR(dwError);


    // Initialize all the status fields so that the subsequent calls
    // to SetServiceStatus need to only update fields that changed.

    IPSecSPDStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    IPSecSPDStatus.dwCurrentState = SERVICE_START_PENDING;
    IPSecSPDStatus.dwControlsAccepted = 0;
    IPSecSPDStatus.dwCheckPoint = 1;
    IPSecSPDStatus.dwWaitHint = 5000;
    IPSecSPDStatus.dwWin32ExitCode = NO_ERROR;
    IPSecSPDStatus.dwServiceSpecificExitCode = 0;

    // Initialize the workstation to receive service requests
    // by registering the service control handler.

    IPSecSPDStatusHandle = RegisterServiceCtrlHandlerExW(
                                IPSECSPD_SERVICE,
                                IPSecSPDControlHandler,
								NULL
                                );
    if (IPSecSPDStatusHandle == (SERVICE_STATUS_HANDLE) NULL) {
        dwError = ERROR_INVALID_HANDLE;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    (void) IPSecSPDUpdateStatus();

    dwError = InitSPDGlobals();
    BAIL_ON_WIN32_ERROR(dwError);

    IPSecSPDStatus.dwCurrentState = SERVICE_RUNNING;
    IPSecSPDStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                        SERVICE_ACCEPT_SHUTDOWN |
								        SERVICE_ACCEPT_POWEREVENT;
    IPSecSPDStatus.dwCheckPoint = 0;
    IPSecSPDStatus.dwWaitHint = 0;
    IPSecSPDStatus.dwWin32ExitCode = NO_ERROR;
    IPSecSPDStatus.dwServiceSpecificExitCode = 0;

    (void) IPSecSPDUpdateStatus();


    //
    // Get the current list of active interfaces on the machine.
    //
    (VOID) CreateInterfaceList(
               &gpInterfaceList
               );

    //
    // Get a list of DNS, DHCP, etc servers.
    //
    (VOID) GetSpecialAddrsList(
               &gpSpecialAddrsList
               );
               
    gpIpsecPolicyState->PersIncarnationNumber = 0;
    dwError = LoadPersistedIPSecInformation();
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDSetIPSecDriverOpMode(
                  (DWORD) IPSEC_SECURE_MODE
                  );
    if (dwError) {
        AuditOneArgErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            IPSECSVC_DRIVER_INIT_FAILURE,
            dwError,
            FALSE,
            TRUE
            );
    }
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDRegisterIPSecDriverProtocols(
                  (DWORD) IPSEC_REGISTER_PROTOCOLS
                  );
    if (dwError) {
        AuditOneArgErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            IPSECSVC_DRIVER_INIT_FAILURE,
            dwError,
            FALSE,
            TRUE
            );
    }
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Start IKE Service.
    //
    dwError = IKEInit();
    if (dwError) {
        AuditOneArgErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            IPSECSVC_IKE_INIT_FAILURE,
            dwError,
            FALSE,
            TRUE
            );
        TRACE(TRC_ERROR, (L"Failed to initialize IKE: %!winerr!", dwError));
    }
    BAIL_ON_WIN32_ERROR(dwError);
    gbIsIKEUp = TRUE;
    gbIKENotify = TRUE;

    //
    // Start the RPC Server.
    //
    dwError = SPDStartRPCServer(
                  );
    if (dwError) {
        AuditOneArgErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            IPSECSVC_RPC_INIT_FAILURE,
            dwError,
            FALSE,
            TRUE
            );
        TRACE(TRC_ERROR, (L"Failed to start RPC server: %!winerr!", dwError));
    }
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ServiceWait();

error:
#ifdef TRACE_ON
    if (dwError) {
        TRACE(TRC_ERROR, (L"Failed to start IPSec PolicyAgent: %!winerr!", dwError));        
    }
#endif    

    if (dwError && ghIPSecDriver != INVALID_HANDLE_VALUE)  {
        dwTempError = SPDSetIPSecDriverOpMode(
                         (DWORD) IPSEC_BLOCK_MODE
                      );
        if (gbAuditingInitialized) {
            AuditOneArgErrorEvent(
                SE_CATEGID_POLICY_CHANGE,
                SE_AUDITID_IPSEC_POLICY_CHANGED,
                IPSECSVC_SET_DRIVER_BLOCK,
                dwError,
                FALSE,
                TRUE
                );
        }
    }        

    IPSecSPDShutdown(dwError);

    return;
}


DWORD
IPSecSPDUpdateStatus(
    )
{
    DWORD dwError = 0;

    if (!SetServiceStatus(IPSecSPDStatusHandle, &IPSecSPDStatus)) {
        dwError = GetLastError();
    }

    return (dwError);
}


DWORD
IPSecSPDControlHandler(
					  IN DWORD dwOpCode,
					  IN DWORD dwEventType,
					  IN LPVOID lpEventData,
					  IN LPVOID lpContext
    )
{
     DWORD dwErr = ERROR_SUCCESS;

    switch (dwOpCode)
    {

    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:

        if (dwOpCode == SERVICE_CONTROL_SHUTDOWN) {
            gdwShutdownFlags = SPD_SHUTDOWN_MACHINE;
        } else {
            gdwShutdownFlags = SPD_SHUTDOWN_SERVICE;
        }

        if (IPSecSPDStatus.dwCurrentState != SERVICE_STOP_PENDING) {

            IPSecSPDStatus.dwCurrentState = SERVICE_STOP_PENDING;
            IPSecSPDStatus.dwCheckPoint = 1;
            IPSecSPDStatus.dwWaitHint = 60000;

            (void) IPSecSPDUpdateStatus();

            SetEvent(ghServiceStopEvent);

            return dwErr;
        }

        break;
    case SERVICE_CONTROL_NEW_LOCAL_POLICY:

        SetEvent(ghNewLocalPolicyEvent);

        break;

    case SERVICE_CONTROL_FORCED_POLICY_RELOAD:

        SetEvent(ghForcedPolicyReloadEvent);

        break;

    case SERVICE_CONTROL_INTERROGATE:

        break;

	case SERVICE_CONTROL_POWEREVENT:

		switch ( dwEventType ) {
		  
		case PBT_APMRESUMEAUTOMATIC:
		case PBT_APMRESUMECRITICAL:
		case PBT_APMRESUMESUSPEND:
 			// Notify IKE of power event, ignore error
			if (gbIKENotify) {
				IKENotifyPolicyChange(NULL,POLICY_GUID_POWEREVENT_RESUME);
			}
			break;
		default:
		   break;
		}
	}

    (void) IPSecSPDUpdateStatus();

    return (dwErr);
}


VOID
IPSecSPDShutdown(
    IN DWORD dwErrorCode
    )
{
    BOOL bMachineShutdown =  FALSE;

    TRACE(TRC_INFORMATION, (L"PolicyAgent shutting down."));
    
    bMachineShutdown = gdwShutdownFlags & SPD_SHUTDOWN_MACHINE;
    
    gbIKENotify = FALSE;
    (VOID) DeleteAllPolicyInformation();

    ClearPolicyStateBlock(
        gpIpsecPolicyState
        );

    if (gbLoadedISAKMPDefaults) {
        UnLoadDefaultISAKMPInformation(gpszDefaultISAKMPPolicyDN);
    }

    ClearPAStoreGlobals();

    //
    // Service stop still pending.
    // Increment checkpoint counter and update 
    // the status with the Service Control Manager.
    //

    (IPSecSPDStatus.dwCheckPoint)++;

    (void) IPSecSPDUpdateStatus();

    if (gbSPDRPCServerUp) {
        gbSPDRPCServerUp = FALSE;
        SPDStopRPCServer();
    }

    if (gbIsIKEUp) {
        gbIsIKEUp = FALSE;
        if (bMachineShutdown) {
            IKEShutdown(SPD_SHUTDOWN_MACHINE);
        } else {
            IKEShutdown(SPD_SHUTDOWN_SERVICE);
        }
    }

    if (gpIniMMPolicy) {
        FreeIniMMPolicyList(gpIniMMPolicy);
        gpIniMMPolicy = NULL;
    }

    if (gpIniMMAuthMethods) {
        FreeIniMMAuthMethodsList(gpIniMMAuthMethods);
        gpIniMMAuthMethods = NULL;
    }

    if (gpIniQMPolicy) {
        FreeIniQMPolicyList(gpIniQMPolicy);
        gpIniQMPolicy = NULL;
    }

    if (gpIniMMSFilter) {
        FreeIniMMSFilterList(gpIniMMSFilter);
        gpIniMMSFilter = NULL;
    }

    if (gpMMFilterHandle) {
        FreeMMFilterHandleList(gpMMFilterHandle);
        gpMMFilterHandle = NULL;
    }

    if (gpIniMMFilter) {
        FreeIniMMFilterList(gpIniMMFilter);
        gpIniMMFilter = NULL;
    }

    if (gpIniTxSFilter) {
        // Following call will check gShutdownFlags and 
        // not delete ipsec filters if shutting down machine
        (VOID) DeleteTransportFiltersFromIPSec(gpIniTxSFilter);

        FreeIniTxSFilterList(gpIniTxSFilter);
        gpIniTxSFilter = NULL;
    }

    if (gpTxFilterHandle) {
        FreeTxFilterHandleList(gpTxFilterHandle);
        gpTxFilterHandle = NULL;
    }

    if (gpIniTxFilter) {
        FreeIniTxFilterList(gpIniTxFilter);
        gpIniTxFilter = NULL;
    }

    if (gpIniTnSFilter) {
        // Following call will check gShutdownFlags and 
        // not delete ipsec filters if shutting down machine
        (VOID) DeleteTunnelFiltersFromIPSec(gpIniTnSFilter);

        FreeIniTnSFilterList(gpIniTnSFilter);
        gpIniTnSFilter = NULL;
    }

    if (gpTnFilterHandle) {
        FreeTnFilterHandleList(gpTnFilterHandle);
        gpTnFilterHandle = NULL;
    }

    if (gpIniTnFilter) {
        FreeIniTnFilterList(gpIniTnFilter);
        gpIniTnFilter = NULL;
    }

    if (!bMachineShutdown) {
        (VOID) SPDRegisterIPSecDriverProtocols(
                   (DWORD) IPSEC_DEREGISTER_PROTOCOLS
                   );
    }               

    if (ghIPSecDriver != INVALID_HANDLE_VALUE) {
        SPDCloseIPSecDriver(ghIPSecDriver);
        ghIPSecDriver = INVALID_HANDLE_VALUE;
    }

    if (gpInterfaceList) {
        DestroyInterfaceList(
            gpInterfaceList
            );
        gpInterfaceList = NULL;
    }

    if (gpSpecialAddrsList) {
        FreeSpecialAddrList(
            &gpSpecialAddrsList
            );
        gpSpecialAddrsList = NULL;
    }
    
    ClearSPDGlobals();

    IPSecSPDStatus.dwCurrentState = SERVICE_STOPPED;
    IPSecSPDStatus.dwControlsAccepted = 0;
    IPSecSPDStatus.dwCheckPoint = 0;
    IPSecSPDStatus.dwWaitHint = 0;
    IPSecSPDStatus.dwWin32ExitCode = dwErrorCode;
    IPSecSPDStatus.dwServiceSpecificExitCode = 0;

    (void) IPSecSPDUpdateStatus();

    WPP_CLEANUP();
    return;
}


VOID
ClearSPDGlobals(
    )
{
    DestroyInterfaceChangeEvent();

    if (gbSPDSection) {
        DeleteCriticalSection(&gcSPDSection);
    }

    if (gbServerListenSection == TRUE) {
        DeleteCriticalSection(&gcServerListenSection);
    }

    if (ghServiceStopEvent) {
        CloseHandle(ghServiceStopEvent);
        ghServiceStopEvent = NULL;
    }

    if (ghNewDSPolicyEvent) {
        CloseHandle(ghNewDSPolicyEvent);
        ghNewDSPolicyEvent = NULL;
    }

    if (ghNewLocalPolicyEvent) {
        CloseHandle(ghNewLocalPolicyEvent);
        ghNewLocalPolicyEvent = NULL;
    }

    if (ghForcedPolicyReloadEvent) {
        CloseHandle(ghForcedPolicyReloadEvent);
        ghForcedPolicyReloadEvent = NULL;
    }

    if (ghPolicyChangeNotifyEvent) {
        CloseHandle(ghPolicyChangeNotifyEvent);
        ghPolicyChangeNotifyEvent = NULL;
    }

    if (ghGpupdateRefreshEvent) {
        CloseHandle(ghGpupdateRefreshEvent);
        ghGpupdateRefreshEvent = NULL;
    }
    
    if (gbSPDAuditSection) {
        DeleteCriticalSection(&gcSPDAuditSection);
    }
    gbAuditingInitialized = FALSE;

    if (gpSPDSD) {
        LocalFree(gpSPDSD);
        gpSPDSD = NULL;
    }
}


VOID
ClearPAStoreGlobals(
    )
{
    if (gpMMFilterState) {
        PAFreeMMFilterStateList(gpMMFilterState);
        gpMMFilterState = NULL;
    }

    if (gpMMPolicyState) {
        PAFreeMMPolicyStateList(gpMMPolicyState);
        gpMMPolicyState = NULL;
    }

    if (gpMMAuthState) {
        PAFreeMMAuthStateList(gpMMAuthState);
        gpMMAuthState = NULL;
    }

    if (gpTxFilterState) {
        PAFreeTxFilterStateList(gpTxFilterState);
        gpTxFilterState = NULL;
    }

    if (gpTnFilterState) {
        PAFreeTnFilterStateList(gpTnFilterState);
        gpTnFilterState = NULL;
    }

    if (gpQMPolicyState) {
        PAFreeQMPolicyStateList(gpQMPolicyState);
        gpQMPolicyState = NULL;
    }
}


VOID
InitMiscGlobals(
    )
{
    //
    // Init globals that aren't cleared on service stop to make sure
    // everything's in a known state on start.  This allows us to
    // stop/restart without having our DLL unloaded/reloaded first.
    //

    gbSPDRPCServerUp          = FALSE;
    ghServiceStopEvent        = NULL;
    gdwServersListening       = 0;
    gbServerListenSection     = FALSE;

    gpInterfaceList           = NULL;
    gpSpecialAddrsList        = NULL;
    gbwsaStarted              = FALSE;
    gIfChangeEventSocket      = INVALID_SOCKET;
    ghIfChangeEvent           = NULL;
    ghOverlapEvent            = NULL;

    gpIniTxFilter             = NULL;
    gpIniTxSFilter            = NULL;
    gpTxFilterHandle          = NULL;

    gbSPDSection              = FALSE;

    gpIniQMPolicy             = NULL;
    gpIniDefaultQMPolicy      = NULL;

    gpIniMMPolicy             = NULL;
    gpIniDefaultMMPolicy      = NULL;

    gpIniMMFilter             = NULL;
    gpIniMMSFilter            = NULL;
    gpMMFilterHandle          = NULL;

    gpIniMMAuthMethods        = NULL;
    gpIniDefaultMMAuthMethods = NULL;

    gpIpsecPolicyState        = &gIpsecPolicyState;
    gCurrentPollingInterval   = 0;
    gDefaultPollingInterval   = 166*60; // (seconds).
    gdwRetryCount             = 0;
    gpszIpsecDSPolicyKey      = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\GPTIPSECPolicy";
    gpszIpsecLocalPolicyKey   = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Local";
    gpszIpsecPersistentPolicyKey = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Persistent";
    gpszIpsecCachePolicyKey   = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Cache";
    gpszDefaultISAKMPPolicyDN = L"SOFTWARE\\Policies\\Microsoft\\Windows\\IPSec\\Policy\\Local\\ipsecISAKMPPolicy{72385234-70FA-11D1-864C-14A300000000}";
    gpszLocPolicyAgent        = L"SYSTEM\\CurrentControlSet\\Services\\PolicyAgent";
    ghNewDSPolicyEvent        = NULL;
    ghNewLocalPolicyEvent     = NULL;
    ghForcedPolicyReloadEvent = NULL;
    ghPolicyChangeNotifyEvent = NULL;
    ghGpupdateRefreshEvent    = NULL;
    gbLoadedISAKMPDefaults    = FALSE;

    gpMMPolicyState           = NULL;
    gpMMAuthState             = NULL;
    gpMMFilterState           = NULL;
    gdwMMPolicyCounter        = 0;
    gdwMMFilterCounter        = 0;
    gpQMPolicyState           = NULL;
    gdwQMPolicyCounter        = 0;
    gpTxFilterState           = NULL;
    gdwTxFilterCounter        = 0;

    gpIniTnFilter             = NULL;
    gpIniTnSFilter            = NULL;
    gpTnFilterHandle          = NULL;
    gpTnFilterState           = NULL;
    gdwTnFilterCounter        = 0;

    gbIsIKEUp                 = FALSE;
    gpSPDSD                   = NULL;
    gbIKENotify               = FALSE;
    ghIPSecDriver             = INVALID_HANDLE_VALUE;

    gbSPDAuditSection         = FALSE;
    ghIpsecServerModule       = NULL;
    gbAuditingInitialized     = FALSE;
    gbIsIoctlPended           = FALSE;

    gbBackwardSoftSA          = FALSE;

    gdwShutdownFlags          = 0;

    gbPersistentPolicyApplied = FALSE;
    return;
}

DWORD
QuerySpdPolicyState(
    LPWSTR pServerName,
    DWORD dwVersion,
    PSPD_POLICY_STATE * ppSpdPolicyState,
    LPVOID pvReserved
    )
{
    DWORD dwError = 0;
    PSPD_POLICY_STATE pSpdPolicyState = NULL;

    dwError = SPDApiBufferAllocate(
                  sizeof(SPD_POLICY_STATE),
                  &pSpdPolicyState
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();
    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pSpdPolicyState->PolicyLoadState = gpIpsecPolicyState->CurrentState;
    
    switch (gpIpsecPolicyState->CurrentState) {
        case SPD_STATE_DS_APPLY_SUCCESS:
            pSpdPolicyState->dwWhenChanged = gpIpsecPolicyState->DSIncarnationNumber;
        break;
        case SPD_STATE_LOCAL_APPLY_SUCCESS:
        case SPD_STATE_CACHE_APPLY_SUCCESS:        
            pSpdPolicyState->dwWhenChanged = gpIpsecPolicyState->RegIncarnationNumber;
        break;
        case SPD_STATE_PERSISTENT_APPLY_SUCCESS:                    
            pSpdPolicyState->dwWhenChanged = gpIpsecPolicyState->PersIncarnationNumber;
        break;
        default:
            pSpdPolicyState->dwWhenChanged = 0;
        break;
    }
    LEAVE_SPD_SECTION();

    *ppSpdPolicyState = pSpdPolicyState;
    return (dwError);

lock:

    LEAVE_SPD_SECTION();
   
error:
    if (pSpdPolicyState) {
        SPDApiBufferFree(pSpdPolicyState);
    }

    *ppSpdPolicyState = NULL;
    return (dwError);
}


DWORD
SetSpdStateOnError(
    DWORD dwPolicySource,
    SPD_ACTION SpdAction,
    DWORD ActionError,
    SPD_STATE * pSpdState
    )
{
    SPD_STATE SpdPolicyState = 0;
    DWORD dwError = ERROR_SUCCESS;

    if (!pSpdState) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    // Collapse triplet into one flag:
    // Long-winded, but by doing it like this we simplify readability 
    // of other parts of code.
    
    if (!ActionError) {
        if (SpdAction == SPD_POLICY_APPLY) {
            switch(dwPolicySource) {
                case IPSEC_SOURCE_PERSISTENT:
                    SpdPolicyState = SPD_STATE_PERSISTENT_APPLY_SUCCESS;
                break;
                case IPSEC_SOURCE_LOCAL:
                    SpdPolicyState = SPD_STATE_LOCAL_APPLY_SUCCESS;
                break;                
                case IPSEC_SOURCE_DOMAIN:
                    SpdPolicyState = SPD_STATE_DS_APPLY_SUCCESS;
                break;                
                case IPSEC_SOURCE_CACHE:
                    SpdPolicyState = SPD_STATE_CACHE_APPLY_SUCCESS;
                break;                
            }
         } else if (SpdAction == SPD_POLICY_LOAD) {
            switch(dwPolicySource) {
                case IPSEC_SOURCE_PERSISTENT:
                    SpdPolicyState = SPD_STATE_PERSISTENT_LOAD_SUCCESS;
                break;
                case IPSEC_SOURCE_LOCAL:
                    SpdPolicyState = SPD_STATE_LOCAL_LOAD_SUCCESS;
                break;                
                case IPSEC_SOURCE_DOMAIN:
                    SpdPolicyState = SPD_STATE_DS_LOAD_SUCCESS;
                break;                
                case IPSEC_SOURCE_CACHE:
                    SpdPolicyState = SPD_STATE_CACHE_LOAD_SUCCESS;
                break;                
            }
        }
     } else {
        if (SpdAction == SPD_POLICY_APPLY) {
            switch(dwPolicySource) {
                case IPSEC_SOURCE_PERSISTENT:
                    SpdPolicyState = SPD_STATE_PERSISTENT_APPLY_FAIL;
                break;
                case IPSEC_SOURCE_LOCAL:
                    SpdPolicyState = SPD_STATE_LOCAL_APPLY_FAIL;
                break;                
                case IPSEC_SOURCE_DOMAIN:
                    SpdPolicyState = SPD_STATE_DS_APPLY_FAIL;
                break;                
                case IPSEC_SOURCE_CACHE:
                    SpdPolicyState = SPD_STATE_CACHE_APPLY_FAIL;
                break;                
            }
         } else if (SpdAction == SPD_POLICY_LOAD) {
            switch(dwPolicySource) {
                case IPSEC_SOURCE_PERSISTENT:
                    SpdPolicyState = SPD_STATE_PERSISTENT_LOAD_FAIL;
                break;
                case IPSEC_SOURCE_LOCAL:
                    SpdPolicyState = SPD_STATE_LOCAL_LOAD_FAIL;
                break;                
                case IPSEC_SOURCE_DOMAIN:
                    SpdPolicyState = SPD_STATE_DS_LOAD_FAIL;
                break;                
                case IPSEC_SOURCE_CACHE:
                    SpdPolicyState = SPD_STATE_CACHE_LOAD_FAIL;
                break;                
            }
        }
     
     }

    (*pSpdState) = SpdPolicyState;
    
error:
    return ERROR_SUCCESS;
}

BOOL
InAcceptableState(
    SPD_STATE SpdState
    )
{
    BOOL AcceptableState =  FALSE;
    
    switch (SpdState) {
        case SPD_STATE_LOCAL_APPLY_SUCCESS:
        case SPD_STATE_DS_APPLY_SUCCESS:
        case SPD_STATE_PERSISTENT_APPLY_SUCCESS:
        case SPD_STATE_INITIAL:
            AcceptableState = TRUE;
        break;    
    }
    
    return AcceptableState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\ipsecspd.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    ipsecspd.h

Abstract:

    This module contains all of the code prototypes
    to drive the IPSecSPD Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif


#define SERVICE_CONTROL_NEW_LOCAL_POLICY 129

#define SERVICE_CONTROL_FORCED_POLICY_RELOAD 130


VOID WINAPI
IPSecSPDServiceMain(
    IN DWORD    dwArgc,
    IN LPTSTR * lpszArgv
    );


DWORD
IPSecSPDUpdateStatus(
    );


DWORD
IPSecSPDControlHandler(
    IN DWORD    dwOpCode,
	IN DWORD dwEventType,
	IN LPVOID lpEventData,
	IN LPVOID lpContext
	 );


VOID
IPSecSPDShutdown(
    IN DWORD    dwErrorCode
    );


VOID
ClearSPDGlobals(
    );


VOID
ClearPAStoreGlobals(
    );

VOID
InitMiscGlobals(
    );

DWORD
SetSpdStateOnError(
    DWORD dwPolicySource,
    SPD_ACTION SpdAction,
    DWORD ActionError,
    SPD_STATE * pSpdState
    );

BOOL
InAcceptableState(
    SPD_STATE SpdState
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\loopmgr.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    loopmgr.c

Abstract:

    This module contains all of the code to drive the
    Loop Manager of IPSecSPD Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"
#ifdef TRACE_ON
#include "loopmgr.tmh"
#endif


enum {
    SERVICE_STOP_EVENT = 0,
    INTERFACE_CHANGE_EVENT,
    NEW_LOCAL_POLICY_EVENT,
    NEW_DS_POLICY_EVENT,
    FORCED_POLICY_RELOAD_EVENT,
    GPUPDATE_REFRESH_EVENT,
    WAIT_EVENT_COUNT,
};


DWORD
ServiceWait(
    )
{

    // ASSERT:  All the following are true at this point:
    //          . Persistent policy has not been defined or if persistent policy has been
    //            defined, then it has been applied successfully.
    //          . IKE is up.
    //          . Driver is up.
    // If persistent policy application failed, IKE init failed, or driver op failed,
    // then service would have shutdown with driver in block mode if possible.
    
    DWORD dwError = 0;
    HANDLE hWaitForEvents[WAIT_EVENT_COUNT];
    BOOL bDoneWaiting = FALSE;
    DWORD dwWaitMilliseconds = 0;
    DWORD dwStatus = 0;
    time_t LastTimeOutTime = 0;
    
    AuditEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        IPSECSVC_SUCCESSFUL_START,
        NULL,
        TRUE,
        TRUE
        );

    hWaitForEvents[SERVICE_STOP_EVENT] = ghServiceStopEvent;
    hWaitForEvents[INTERFACE_CHANGE_EVENT] = GetInterfaceChangeEvent();
    hWaitForEvents[NEW_LOCAL_POLICY_EVENT] = ghNewLocalPolicyEvent;
    hWaitForEvents[NEW_DS_POLICY_EVENT] = ghNewDSPolicyEvent;
    hWaitForEvents[FORCED_POLICY_RELOAD_EVENT] = ghForcedPolicyReloadEvent;
    hWaitForEvents[GPUPDATE_REFRESH_EVENT] = ghGpupdateRefreshEvent;

    //
    // First load the default main mode policy.
    //

    (VOID) LoadDefaultISAKMPInformation(
               gpszDefaultISAKMPPolicyDN
               );

    //
    // Call the Polling Manager for the first time.
    //

    (VOID) StartStatePollingManager(
               gpIpsecPolicyState
               );


    NotifyIpsecPolicyChange();


    ComputeRelativePollingTime(
        LastTimeOutTime,
        TRUE,
        gdwRetryCount,
        &dwWaitMilliseconds
        );


    time(&LastTimeOutTime);

    TRACE(TRC_INFORMATION, (L"Completed startup routines. Entering service wait loop."));
        
    while (!bDoneWaiting) {

        dwStatus = WaitForMultipleObjects(
                       WAIT_EVENT_COUNT,
                       hWaitForEvents,
                       FALSE,
                       dwWaitMilliseconds
                       );

        PADeleteInUsePolicies();

        switch (dwStatus) {

        case SERVICE_STOP_EVENT:
            TRACE(TRC_INFORMATION, (L"Service stop event signaled"));

            dwError = ERROR_SUCCESS;
            bDoneWaiting = TRUE;
            break;

        case INTERFACE_CHANGE_EVENT:
            TRACE(TRC_INFORMATION, (L"Interface changed event signaled"));
            
            (VOID) OnInterfaceChangeEvent(
                       );
            (VOID) IKEInterfaceChange();
            break;

        case NEW_LOCAL_POLICY_EVENT:
            TRACE(TRC_INFORMATION, (L"New local policy event signaled"));
            ResetEvent(ghNewLocalPolicyEvent);
            if ((gpIpsecPolicyState->CurrentState != SPD_STATE_DS_APPLY_SUCCESS) &&
                (gpIpsecPolicyState->CurrentState != SPD_STATE_CACHE_APPLY_SUCCESS)) {
                (VOID) ProcessLocalPolicyPollState(
                           gpIpsecPolicyState
                           );
                NotifyIpsecPolicyChange();
            }
            break;

        case NEW_DS_POLICY_EVENT:
            TRACE(TRC_INFORMATION, (L"New DS policy event signaled"));
            
            ResetEvent(ghNewDSPolicyEvent);
            (VOID) OnPolicyChanged(
                       gpIpsecPolicyState
                       );
            NotifyIpsecPolicyChange();
            break;

        case GPUPDATE_REFRESH_EVENT:
            TRACE(TRC_INFORMATION, (L"Group policy refresh event signaled"));            
            ResetEvent(ghGpupdateRefreshEvent);
            dwError = ProcessDirectoryPolicyPollState(
                gpIpsecPolicyState
                );
            break;
        case FORCED_POLICY_RELOAD_EVENT:
            TRACE(TRC_INFORMATION, (L"Forced policy reload event signaled"));            
            ResetEvent(ghForcedPolicyReloadEvent);
            (VOID) OnPolicyChanged(
                       gpIpsecPolicyState
                       );
            NotifyIpsecPolicyChange();
            AuditEvent(
                SE_CATEGID_POLICY_CHANGE,
                SE_AUDITID_IPSEC_POLICY_CHANGED,
                PASTORE_FORCED_POLICY_RELOAD,
                NULL,
                TRUE,
                TRUE
                );
            break;

        case WAIT_TIMEOUT:
            TRACE(TRC_INFORMATION, (L"Polling event signaled"));            
            time(&LastTimeOutTime);
            (VOID) OnPolicyPoll(
                       gpIpsecPolicyState
                       );
                       
            (VOID) OnSpecialAddrsChange();
            break;

        case WAIT_FAILED:

            dwError = GetLastError();
            TRACE(TRC_ERROR, (L"Failed service wait WaitForMultipleObjects %!winerr!: ", dwError));            
            bDoneWaiting = TRUE;
            break;

        default:

            dwError = ERROR_INVALID_EVENT_COUNT;
            bDoneWaiting = TRUE;
            break;

        }

        ComputeRelativePollingTime(
            LastTimeOutTime,
            FALSE,
            gdwRetryCount,
            &dwWaitMilliseconds
            );

        if (InAcceptableState(gpIpsecPolicyState->CurrentState)) {
            // Polling is not going to retry anymore since we've reached an
            // acceptable state.  So reset gdwRetryCount for NEXT time
            // in case we reach an unacceptable state.
            
            gdwRetryCount = 0;
            TRACE(
                TRC_INFORMATION,
                ("Policy Agent now in state %d",
                (DWORD) gpIpsecPolicyState->CurrentState)
                );
                
        }
#ifdef TRACE_ON
            else {
                TRACE(
                    TRC_INFORMATION,
                    ("Policy Agent in error state %d, retry count is %d ",
                    (DWORD) gpIpsecPolicyState->CurrentState,
                    gdwRetryCount)
                    );
            }
#endif
        
    }

    if (!dwError) {
        AuditEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            IPSECSVC_SUCCESSFUL_SHUTDOWN,
            NULL,
            TRUE,
            TRUE
            );
    }
    else {
        AuditOneArgErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            IPSECSVC_ERROR_SHUTDOWN,
            dwError,
            FALSE,
            TRUE
            );

         TRACE(TRC_ERROR, (L"Failed and exiting service wait %!winerr!: ", dwError));                    
    }

    return (dwError);
}


VOID
ComputeRelativePollingTime(
    IN time_t LastTimeOutTime,
    IN BOOL bInitialLoad,
    IN DWORD dwRetryCount,
    IN PDWORD pWaitMilliseconds
    )
{
    DWORD WaitMilliseconds = 0;
    DWORD DSReconnectMilliseconds = 0;
    time_t NextTimeOutTime = 0;
    time_t PresentTime = 0;
    long WaitSeconds = gDefaultPollingInterval;
    DWORD64 NewPollingIntervalSeconds = 0;

    if (!InAcceptableState(gpIpsecPolicyState->CurrentState)) {
        // Exponentially back-off polling interval until
        // we hit default polling interval.
        // Polling interval increases as (dwRetryCount+1)^2

        NewPollingIntervalSeconds = (dwRetryCount+1) * (dwRetryCount+1) * 60;
        if (NewPollingIntervalSeconds < gDefaultPollingInterval) {
            gCurrentPollingInterval = (DWORD) NewPollingIntervalSeconds;
        } else {
            gCurrentPollingInterval = gDefaultPollingInterval;
        }
    }
        

    WaitMilliseconds = gCurrentPollingInterval * 1000;

    if (!WaitMilliseconds) {
        WaitMilliseconds = INFINITE;
    }

    if (!bInitialLoad && WaitMilliseconds != INFINITE) {

        //
        // LastTimeOutTime is the snapshot time value in the past when
        // we timed out waiting for multiple events.
        // Ideally, the time for the next time out, NextTimeOutTime, is
        // the time value in future which is sum of the last time when
        // we timed out + the current waiting time value.
        //

        NextTimeOutTime = LastTimeOutTime + (WaitMilliseconds/1000);

        //
        // However, the last time we may not have timed out waiting
        // for multiple events but rather came out because one of the
        // events other than WAIT_TIMEOUT happened.
        // However, on that event we may not have done a policy
        // poll to figure out whether there was a policy change or
        // not. If we again wait for WaitMilliseconds, then we are
        // un-knowingly making our net time for policy poll greater
        // than the alloted time interval value = WaitMilliseconds.
        // So, we need to adjust the WaitMilliseconds to such a value
        // that no matter what happens, we always do a policy poll
        // atmost every WaitMilliseconds time interval value.
        // The current time is PresentTime.
        //

        time(&PresentTime);

        WaitSeconds = (long) (NextTimeOutTime - PresentTime);

        if (WaitSeconds < 0) {
            WaitMilliseconds = 0;
        }
        else {
            WaitMilliseconds = WaitSeconds * 1000;
        }

    }

    *pWaitMilliseconds = WaitMilliseconds;
}


VOID
NotifyIpsecPolicyChange(
    )
{
    PulseEvent(ghPolicyChangeNotifyEvent);

    SendPschedIoctl();

    ResetEvent(ghPolicyChangeNotifyEvent);

    return;
}


VOID
SendPschedIoctl(
    )
{
    HANDLE hPschedDriverHandle = NULL;
    ULONG uBytesReturned = 0;
    BOOL bIOStatus = FALSE;


    #define DriverName TEXT("\\\\.\\PSCHED")

    #define IOCTL_PSCHED_ZAW_EVENT CTL_CODE( \
                                       FILE_DEVICE_NETWORK, \
                                       20, \
                                       METHOD_BUFFERED, \
                                       FILE_ANY_ACCESS \
                                       )

    hPschedDriverHandle = CreateFile(
                              DriverName,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                              NULL
                              );

    if (hPschedDriverHandle != INVALID_HANDLE_VALUE) {

        bIOStatus = DeviceIoControl(
                        hPschedDriverHandle,
                        IOCTL_PSCHED_ZAW_EVENT,
                        NULL,
                        0,
                        NULL,
                        0,
                        &uBytesReturned,
                        NULL
                        );

        CloseHandle(hPschedDriverHandle);

    }
}


VOID
PADeleteInUsePolicies(
    )
{
    DWORD dwError = 0;

    TRACE(TRC_INFORMATION, (L"Deleting policy components no longer in use"));
    
    dwError = PADeleteInUseMMPolicies();

    dwError = PADeleteInUseMMAuthMethods();

    dwError = PADeleteInUseQMPolicies();

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\loopmgr.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    loopmgr.h

Abstract:

    This module contains all of the code prototypes to drive the
    Loop Manager of IPSecSPD Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif


DWORD
ServiceWait(
    );

VOID
ComputeRelativePollingTime(
    IN time_t LastTimeOutTime,
    IN BOOL bInitialLoad,
    IN DWORD dwRetryCount,
    IN PDWORD pWaitMilliseconds
    );

VOID
NotifyIpsecPolicyChange(
    );


VOID
SendPschedIoctl(
    );


VOID
PADeleteInUsePolicies(
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\mm-policy.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    mm-policy.c

Abstract:


Author:


Environment: User Mode


Revision History:


--*/


#include "precomp.h"
#ifdef TRACE_ON
#include "mm-policy.tmh"
#endif


DWORD
AddMMPolicyInternal(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    DWORD dwSource,
    PIPSEC_MM_POLICY pMMPolicy,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function adds a main mode policy to the SPD.

Arguments:

    pServerName - Server on which the main mode policy is to be added.

    pMMPolicy - Main mode policy to be added.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMPOLICY pIniMMPolicy = NULL;

    //
    // Validate the main mode policy.
    //

    dwError = ValidateMMPolicy(
                  pMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMPolicy = FindMMPolicy(
                       gpIniMMPolicy,
                       pMMPolicy->pszPolicyName
                       );
    if (pIniMMPolicy) {
        dwError = ERROR_IPSEC_MM_POLICY_EXISTS;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    pIniMMPolicy = FindMMPolicyByGuid(
                       gpIniMMPolicy,
                       pMMPolicy->gPolicyID
                       );
    if (pIniMMPolicy) {
        dwError = ERROR_IPSEC_MM_POLICY_EXISTS;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = CreateIniMMPolicy(
                  pMMPolicy,
                  &pIniMMPolicy
                  );
    if (dwError != WARNING_IPSEC_MM_POLICY_PRUNED) {
        BAIL_ON_LOCK_ERROR(dwError);
    }

    pIniMMPolicy->dwSource = dwSource;

    pIniMMPolicy->pNext = gpIniMMPolicy;
    gpIniMMPolicy = pIniMMPolicy;

    if ((pIniMMPolicy->dwFlags) & IPSEC_MM_POLICY_DEFAULT_POLICY) {
        gpIniDefaultMMPolicy = pIniMMPolicy;
        TRACE(
            TRC_INFORMATION,
            (L"Set default MM policy to \"%ls\" (%!guid!)",
            pMMPolicy->pszPolicyName,
            &pMMPolicy->gPolicyID)
            );
    }
 
    LEAVE_SPD_SECTION();

    TRACE(
        TRC_INFORMATION,
        (L"Added MM policy \"%ls\"(%!guid!)",
        pMMPolicy->pszPolicyName,
        &pMMPolicy->gPolicyID)
        );

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:
#ifdef TRACE_ON    
    if (pMMPolicy) {
        TRACE(
            TRC_ERROR,
            (L"Failed to add MM policy \"%ls\"(%!guid!): %!winerr!",
            pMMPolicy->pszPolicyName,
            &pMMPolicy->gPolicyID,
            dwError)
            );
    } else {
        TRACE(
            TRC_ERROR,
            (L"Failed to add MM policy. Policy details unavailable since pMMPolicy is null: %!winerr!",
            dwError)
            );
    }
#endif
    return (dwError);
}

DWORD
AddMMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PIPSEC_MM_POLICY pMMPolicy,
    LPVOID pvReserved
    )
{
    return AddMMPolicyInternal(
                pServerName, 
                dwVersion, 
                dwFlags,
                IPSEC_SOURCE_WINIPSEC,
                pMMPolicy,
                pvReserved);
}

DWORD
ValidateMMPolicy(
    PIPSEC_MM_POLICY pMMPolicy
    )
{
    DWORD dwError = 0;


    if (!pMMPolicy) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMPolicy->pszPolicyName) || !(*(pMMPolicy->pszPolicyName))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateMMOffers(
                  pMMPolicy->dwOfferCount,
                  pMMPolicy->pOffers
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:
#ifdef TRACE_ON
    if (dwError) {
        TRACE(TRC_ERROR, ("Failed MM policy validation: %!winerr!", dwError));
    }
#endif
    
    return (dwError);
}

DWORD
ValidateMMOffers(
    DWORD dwOfferCount,
    PIPSEC_MM_OFFER pOffers
    )
{
    DWORD dwError = 0;

    if (!dwOfferCount || !pOffers || dwOfferCount > IPSEC_MAX_MM_OFFERS) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:
#ifdef TRACE_ON
    if (dwError) {
        TRACE(TRC_ERROR, ("Failed MM offers validation: %!winerr!", dwError));
    }
#endif
    

    return (dwError);
}

DWORD
ValidateMMOffer(
    PIPSEC_MM_OFFER pOffer
    )
{
    DWORD dwError = 0;
    
    if ((pOffer->dwDHGroup != DH_GROUP_1) &&
        (pOffer->dwDHGroup != DH_GROUP_2) && 
        (pOffer->dwDHGroup != DH_GROUP_2048)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    if (pOffer->EncryptionAlgorithm.uAlgoIdentifier >= CONF_ALGO_MAX ||
        pOffer->EncryptionAlgorithm.uAlgoIdentifier == CONF_ALGO_NONE) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    if (pOffer->HashingAlgorithm.uAlgoIdentifier >= AUTH_ALGO_MAX || 
        pOffer->HashingAlgorithm.uAlgoIdentifier == AUTH_ALGO_NONE) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:
#ifdef TRACE_ON
    if (dwError) {
        TRACE(TRC_ERROR, ("Failed a MM offer validation: %!winerr!", dwError));
    }
#endif

    return (dwError);
}

DWORD
CreateIniMMPolicy(
    PIPSEC_MM_POLICY pMMPolicy,
    PINIMMPOLICY * ppIniMMPolicy
    )
{
    DWORD dwError = 0;
    PINIMMPOLICY pIniMMPolicy = NULL;


    dwError = AllocateSPDMemory(
                  sizeof(INIMMPOLICY),
                  &pIniMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pIniMMPolicy->gPolicyID),
        &(pMMPolicy->gPolicyID),
        sizeof(GUID)
        );

    dwError =  AllocateSPDString(
                   pMMPolicy->pszPolicyName,
                   &(pIniMMPolicy->pszPolicyName)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    pIniMMPolicy->cRef = 0;
    pIniMMPolicy->dwSource = 0;

    pIniMMPolicy->dwFlags = pMMPolicy->dwFlags;
    pIniMMPolicy->uSoftExpirationTime = pMMPolicy->uSoftExpirationTime;
    pIniMMPolicy->pNext = NULL;

    dwError = CreateIniMMOffers(
                  pMMPolicy->dwOfferCount,
                  pMMPolicy->pOffers,
                  &(pIniMMPolicy->dwOfferCount),
                  &(pIniMMPolicy->pOffers)
                  );
    if (dwError != WARNING_IPSEC_MM_POLICY_PRUNED) {
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppIniMMPolicy = pIniMMPolicy;
    return (dwError);

error:
    TRACE(TRC_ERROR, ("Failed to create MM Policy link node: %!winerr!", dwError));

    if (pIniMMPolicy) {
        FreeIniMMPolicy(
            pIniMMPolicy
            );
    }

    *ppIniMMPolicy = NULL;
    return (dwError);
}


DWORD
CreateIniMMOffers(
    DWORD dwInOfferCount,
    PIPSEC_MM_OFFER pInOffers,
    PDWORD pdwOfferCount,
    PIPSEC_MM_OFFER * ppOffers
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_OFFER pOffers = NULL;
    PIPSEC_MM_OFFER pTemp = NULL;
    PIPSEC_MM_OFFER pInTempOffer = NULL;
    DWORD i = 0;
    DWORD dwOfferCount = 0;
    DWORD dwCurIndex = 0;

    for (i = 0; i < dwInOfferCount; i++) {
        dwError = ValidateMMOffer(&pInOffers[i]);
        if (dwError == ERROR_SUCCESS) {
            dwOfferCount++;
        } 
    }

    if (dwOfferCount == 0) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_MM_OFFER) * dwOfferCount,
                  &(pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    for (i = 0; i < dwInOfferCount; i++) {

        pTemp = &pOffers[dwCurIndex];
        pInTempOffer = &pInOffers[i];

        dwError = ValidateMMOffer(pInTempOffer);
        if (dwError) {
            continue;
        }

        memcpy(
            &(pTemp->Lifetime),
            &(pInTempOffer->Lifetime),
            sizeof(KEY_LIFETIME)
            );
        if (!(pTemp->Lifetime.uKeyExpirationTime)) {
            pTemp->Lifetime.uKeyExpirationTime = DEFAULT_MM_KEY_EXPIRATION_TIME;
        }

        pTemp->dwFlags = pInTempOffer->dwFlags;
        pTemp->dwQuickModeLimit = pInTempOffer->dwQuickModeLimit;
        pTemp->dwDHGroup = pInTempOffer->dwDHGroup;

        memcpy(
            &(pTemp->EncryptionAlgorithm),
            &(pInTempOffer->EncryptionAlgorithm),
            sizeof(IPSEC_MM_ALGO)
            );
        memcpy(
            &(pTemp->HashingAlgorithm),
            &(pInTempOffer->HashingAlgorithm),
            sizeof(IPSEC_MM_ALGO)
            );

        dwCurIndex++;

    }

    *pdwOfferCount = dwOfferCount;
    *ppOffers = pOffers;

    if (dwOfferCount != dwInOfferCount) {
        TRACE(TRC_WARNING, ("Pruned MM offers node."));        
        return WARNING_IPSEC_MM_POLICY_PRUNED;
    }
    return (ERROR_SUCCESS);

error:
    TRACE(TRC_ERROR, ("Failed to create MM offers node: %!winerr!", dwError));

    if (pOffers) {
        FreeIniMMOffers(
            i,
            pOffers
            );
    }

    *pdwOfferCount = 0;
    *ppOffers = NULL;
    return (dwError);
}
    

VOID
FreeIniMMPolicy(
    PINIMMPOLICY pIniMMPolicy
    )
{
    if (pIniMMPolicy) {

        if (pIniMMPolicy->pszPolicyName) {
            FreeSPDString(pIniMMPolicy->pszPolicyName);
        }

        FreeIniMMOffers(
            pIniMMPolicy->dwOfferCount,
            pIniMMPolicy->pOffers
            );

        FreeSPDMemory(pIniMMPolicy);

    }
}


VOID
FreeIniMMOffers(
    DWORD dwOfferCount,
    PIPSEC_MM_OFFER pOffers
    )
{
    if (pOffers) {
        FreeSPDMemory(pOffers);
    }
}


PINIMMPOLICY
FindMMPolicy(
    PINIMMPOLICY pIniMMPolicyList,
    LPWSTR pszPolicyName
    )
{
    DWORD dwError = 0;
    PINIMMPOLICY pTemp = NULL;


    pTemp = pIniMMPolicyList;

    while (pTemp) {

        if (!_wcsicmp(pTemp->pszPolicyName, pszPolicyName)) {
            return (pTemp);
        }
        pTemp = pTemp->pNext;

    }

    return (NULL);
}


DWORD
DeleteMMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function deletes a main mode policy from the SPD.

Arguments:

    pServerName - Server on which the main mode policy is to be deleted.

    pszPolicyName - Main mode policy to be deleted.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMPOLICY pIniMMPolicy = NULL;
    GUID gPolicyID;


    if (!pszPolicyName || !*pszPolicyName) {
        return (ERROR_INVALID_PARAMETER);
    }

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMPolicy = FindMMPolicy(
                       gpIniMMPolicy,
                       pszPolicyName
                       );
    if (!pIniMMPolicy) {
        dwError = ERROR_IPSEC_MM_POLICY_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniMMPolicy->cRef) {
        dwError = ERROR_IPSEC_MM_POLICY_IN_USE;
        memcpy(&gPolicyID, &pIniMMPolicy->gPolicyID, sizeof(GUID));
        BAIL_ON_LOCK_ERROR(dwError);
    }

    memcpy(&gPolicyID, &pIniMMPolicy->gPolicyID, sizeof(GUID));

    dwError = DeleteIniMMPolicy(
                  pIniMMPolicy
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    LEAVE_SPD_SECTION();

    if (gbIKENotify) {
        (VOID) IKENotifyPolicyChange(
                   &(gPolicyID),
                   POLICY_GUID_MM
                   );
    }

    TRACE(
        TRC_INFORMATION,
        ("Deleted MM Policy \"%ls\"(%!guid!)",
        pszPolicyName,
        &gPolicyID)
        );
    
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

#ifdef TRACE_ON    
    if (pIniMMPolicy) {
        TRACE(
            TRC_ERROR,
            (L"Failed to delete MM policy \"%ls\"(%!guid!): %!winerr!",
            pIniMMPolicy->pszPolicyName,
            &pIniMMPolicy->gPolicyID,
            dwError)
            );
    } else {
        TRACE(
            TRC_ERROR,
            (L"Failed to delete MM policy \"%ls\": %!winerr!",
            pszPolicyName,
            dwError)
            );
    }
#endif

    return (dwError);
}


DWORD
EnumMMPolicies(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_MM_POLICY pMMTemplatePolicy,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PIPSEC_MM_POLICY * ppMMPolicies,
    LPDWORD pdwNumPolicies,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function enumerates main mode policies from the SPD.

Arguments:

    pServerName - Server on which the main mode policies are to
                  be enumerated.

    ppMMPolicies - Enumerated main mode policies returned to the 
                   caller.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    pdwNumPolicies - Number of main mode policies actually enumerated.

    pdwResumeHandle - Handle to the location in the main mode policy
                      list from which to resume enumeration.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwResumeHandle = 0;
    DWORD dwNumToEnum = 0;
    PINIMMPOLICY pIniMMPolicy = NULL;
    DWORD i = 0;
    PINIMMPOLICY pTemp = NULL;
    DWORD dwNumPolicies = 0;
    PIPSEC_MM_POLICY pMMPolicies = NULL;
    PIPSEC_MM_POLICY pMMPolicy = NULL;


    dwResumeHandle = *pdwResumeHandle;

    if (!dwPreferredNumEntries || (dwPreferredNumEntries > MAX_MMPOLICY_ENUM_COUNT)) {
        dwNumToEnum = MAX_MMPOLICY_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMPolicy = gpIniMMPolicy;

    for (i = 0; (i < dwResumeHandle) && (pIniMMPolicy != NULL); i++) {
        pIniMMPolicy = pIniMMPolicy->pNext;
    }

    if (!pIniMMPolicy) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    pTemp = pIniMMPolicy;

    while (pTemp && (dwNumPolicies < dwNumToEnum)) {
        dwNumPolicies++;
        pTemp = pTemp->pNext;
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_MM_POLICY)*dwNumPolicies,
                  &pMMPolicies
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pTemp = pIniMMPolicy;
    pMMPolicy = pMMPolicies;

    for (i = 0; i < dwNumPolicies; i++) {

        dwError = CopyMMPolicy(
                      pTemp,
                      pMMPolicy
                      );
        BAIL_ON_LOCK_ERROR(dwError);

        pTemp = pTemp->pNext;
        pMMPolicy++;

    }

    *ppMMPolicies = pMMPolicies;
    *pdwResumeHandle = dwResumeHandle + dwNumPolicies;
    *pdwNumPolicies = dwNumPolicies;

    LEAVE_SPD_SECTION();

    TRACE(TRC_INFORMATION, (L"Enumerated policies."));
    
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    if (pMMPolicies) {
        FreeMMPolicies(
            i,
            pMMPolicies
            );
    }

    *ppMMPolicies = NULL;
    *pdwResumeHandle = dwResumeHandle;
    *pdwNumPolicies = 0;

    TRACE(TRC_ERROR, ("Failed to enumerate policies: %!winerr!", dwError));    
    
    return (dwError);
}


DWORD
SetMMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    PIPSEC_MM_POLICY pMMPolicy,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function updates a main mode policy in the SPD.

Arguments:

    pServerName - Server on which the main mode policy is to be
                  updated.

    pszPolicyName - Name of the main mode policy to be updated.

    pMMPolicy - New main mode policy which will replace the 
                existing policy.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMPOLICY pIniMMPolicy = NULL;
    DWORD dwStatus = 0;

    if (!pszPolicyName || !*pszPolicyName) {
        return (ERROR_INVALID_PARAMETER);
    }
    
    //
    // Validate main mode policy.
    //

    dwError = ValidateMMPolicy(
                  pMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMPolicy = FindMMPolicy(
                       gpIniMMPolicy,
                       pszPolicyName
                       );
    if (!pIniMMPolicy) {
        dwError = ERROR_IPSEC_MM_POLICY_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (memcmp(
            &(pIniMMPolicy->gPolicyID),
            &(pMMPolicy->gPolicyID),
            sizeof(GUID))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = SetIniMMPolicy(
                  pIniMMPolicy,
                  pMMPolicy
                  );
    if (dwError != WARNING_IPSEC_MM_POLICY_PRUNED) {
        BAIL_ON_LOCK_ERROR(dwError);
    } else {
        dwStatus = dwError;
    }

    LEAVE_SPD_SECTION();

    (VOID) IKENotifyPolicyChange(
               &(pMMPolicy->gPolicyID),
               POLICY_GUID_MM
               );

    TRACE(
        TRC_INFORMATION,
        (L"Changed MM Policy \"%ls\" (%!guid!)",
        pMMPolicy->pszPolicyName,
        &pMMPolicy->gPolicyID)
        );
    return (dwStatus);

lock:

    LEAVE_SPD_SECTION();

error:
#ifdef TRACE_ON    
    if (pIniMMPolicy) {
        TRACE(
            TRC_ERROR,
            (L"Failed to change MM policy \"%ls\"(%!guid!): %!winerr!",
            pIniMMPolicy->pszPolicyName,
            &pIniMMPolicy->gPolicyID,
            dwError)
            );
    } else {
        TRACE(
            TRC_ERROR,
            (L"Failed to change MM policy \"%ls\": %!winerr!",
            pszPolicyName,
            dwError)
            );
    }
#endif
    

    return (dwError);
}


DWORD
GetMMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    PIPSEC_MM_POLICY * ppMMPolicy,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function gets a main mode policy from the SPD.

Arguments:

    pServerName - Server from which to get the main mode policy.

    pszPolicyName - Name of the main mode policy to get.

    ppMMPolicy - Main mode policy found returned to the caller.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMPOLICY pIniMMPolicy = NULL;
    PIPSEC_MM_POLICY pMMPolicy = NULL;


    if (!pszPolicyName || !*pszPolicyName) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMPolicy = FindMMPolicy(
                       gpIniMMPolicy,
                       pszPolicyName
                       );
    if (!pIniMMPolicy) {
        dwError = ERROR_IPSEC_MM_POLICY_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = GetIniMMPolicy(
                  pIniMMPolicy,
                  &pMMPolicy
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    *ppMMPolicy = pMMPolicy;

    LEAVE_SPD_SECTION();
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    *ppMMPolicy = NULL;
    return (dwError);
}


DWORD
SetIniMMPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PIPSEC_MM_POLICY pMMPolicy
    )
{
    DWORD dwError = 0;
    DWORD dwOfferCount = 0;
    PIPSEC_MM_OFFER pOffers = NULL;

    dwError = CreateIniMMOffers(
                  pMMPolicy->dwOfferCount,
                  pMMPolicy->pOffers,
                  &dwOfferCount,
                  &pOffers
                  );
    if (dwError != WARNING_IPSEC_MM_POLICY_PRUNED) {
        BAIL_ON_WIN32_ERROR(dwError);
    }

    FreeIniMMOffers(
        pIniMMPolicy->dwOfferCount,
        pIniMMPolicy->pOffers
        );
    
    if ((pIniMMPolicy->dwFlags) & IPSEC_MM_POLICY_DEFAULT_POLICY) {
        gpIniDefaultMMPolicy = NULL;
        TRACE(
            TRC_INFORMATION,
            (L"Cleared default MM policy \"%ls\" (%!guid!)",
            pIniMMPolicy->pszPolicyName,
            &pIniMMPolicy->gPolicyID)
            );
    }

    pIniMMPolicy->dwFlags = pMMPolicy->dwFlags;
    pIniMMPolicy->uSoftExpirationTime = pMMPolicy->uSoftExpirationTime;
    pIniMMPolicy->dwOfferCount = dwOfferCount;
    pIniMMPolicy->pOffers = pOffers;

    if ((pIniMMPolicy->dwFlags) & IPSEC_MM_POLICY_DEFAULT_POLICY) {
        gpIniDefaultMMPolicy = pIniMMPolicy;
        TRACE(
            TRC_INFORMATION,
            (L"Set default MM policy to \"%ls\" (%!guid!)",
            pIniMMPolicy->pszPolicyName,
            &pIniMMPolicy->gPolicyID)
            );
        
    }

error:

    return (dwError);
}


DWORD
GetIniMMPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PIPSEC_MM_POLICY * ppMMPolicy
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_POLICY pMMPolicy = NULL;


    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_MM_POLICY),
                  &pMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyMMPolicy(
                  pIniMMPolicy,
                  pMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppMMPolicy = pMMPolicy;
    return (dwError);

error:

    if (pMMPolicy) {
        SPDApiBufferFree(pMMPolicy);
    }

    *ppMMPolicy = NULL;
    return (dwError);
}


DWORD
CopyMMPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PIPSEC_MM_POLICY pMMPolicy
    )
{
    DWORD dwError = 0;


    memcpy(
        &(pMMPolicy->gPolicyID),
        &(pIniMMPolicy->gPolicyID),
        sizeof(GUID)
        );

    dwError =  SPDApiBufferAllocate(
                   wcslen(pIniMMPolicy->pszPolicyName)*sizeof(WCHAR)
                   + sizeof(WCHAR),
                   &(pMMPolicy->pszPolicyName)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(pMMPolicy->pszPolicyName, pIniMMPolicy->pszPolicyName);
 
    pMMPolicy->dwFlags = pIniMMPolicy->dwFlags;
    pMMPolicy->uSoftExpirationTime = pIniMMPolicy->uSoftExpirationTime;

    dwError = CreateMMOffers(
                  pIniMMPolicy->dwOfferCount,
                  pIniMMPolicy->pOffers,
                  &(pMMPolicy->dwOfferCount),
                  &(pMMPolicy->pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    return (dwError);

error:

    if (pMMPolicy->pszPolicyName) {
        SPDApiBufferFree(pMMPolicy->pszPolicyName);
    }

    return (dwError);
}


DWORD
CreateMMOffers(
    DWORD dwInOfferCount,
    PIPSEC_MM_OFFER pInOffers,
    PDWORD pdwOfferCount,
    PIPSEC_MM_OFFER * ppOffers
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_OFFER pOffers = NULL;
    PIPSEC_MM_OFFER pTemp = NULL;
    PIPSEC_MM_OFFER pInTempOffer = NULL;
    DWORD i = 0;


    //
    // Offer count and the offers themselves have already been validated.
    // 

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_MM_OFFER) * dwInOfferCount,
                  &(pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pOffers;
    pInTempOffer = pInOffers;

    for (i = 0; i < dwInOfferCount; i++) {

        memcpy(
            &(pTemp->Lifetime),
            &(pInTempOffer->Lifetime),
            sizeof(KEY_LIFETIME)
            );

        pTemp->dwFlags = pInTempOffer->dwFlags;
        pTemp->dwQuickModeLimit = pInTempOffer->dwQuickModeLimit;
        pTemp->dwDHGroup = pInTempOffer->dwDHGroup;

        memcpy(
            &(pTemp->EncryptionAlgorithm),
            &(pInTempOffer->EncryptionAlgorithm),
            sizeof(IPSEC_MM_ALGO)
            );
        memcpy(
            &(pTemp->HashingAlgorithm),
            &(pInTempOffer->HashingAlgorithm),
            sizeof(IPSEC_MM_ALGO)
            );

        pInTempOffer++;
        pTemp++;

    }

    *pdwOfferCount = dwInOfferCount;
    *ppOffers = pOffers;
    return (dwError);

error:
    TRACE(TRC_ERROR, ("Failed to create MM offers"));    
    
    if (pOffers) {
        FreeMMOffers(
            i,
            pOffers
            );
    }

    *pdwOfferCount = 0;
    *ppOffers = NULL;
    return (dwError);
}


DWORD
DeleteIniMMPolicy(
    PINIMMPOLICY pIniMMPolicy
    )
{
    DWORD dwError = 0;
    PINIMMPOLICY * ppTemp = NULL;


    ppTemp = &gpIniMMPolicy;

    while (*ppTemp) {

        if (*ppTemp == pIniMMPolicy) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);

    }

    if (*ppTemp) {
        *ppTemp = pIniMMPolicy->pNext;
    }

    if ((pIniMMPolicy->dwFlags) & IPSEC_MM_POLICY_DEFAULT_POLICY) {
        gpIniDefaultMMPolicy = NULL;
        TRACE(
            TRC_INFORMATION,
            (L"Cleared default MM policy \"%ls\" (%!guid!)",
            pIniMMPolicy->pszPolicyName,
            &pIniMMPolicy->gPolicyID)
            );
    }

    FreeIniMMPolicy(pIniMMPolicy);

    return (dwError);
}


VOID
FreeMMOffers(
    DWORD dwOfferCount,
    PIPSEC_MM_OFFER pOffers
    )
{
    if (pOffers) {
        SPDApiBufferFree(pOffers);
    }
}


VOID
FreeIniMMPolicyList(
    PINIMMPOLICY pIniMMPolicyList
    )
{
    PINIMMPOLICY pTemp = NULL;
    PINIMMPOLICY pIniMMPolicy = NULL;


    pTemp = pIniMMPolicyList;

    while (pTemp) {

         pIniMMPolicy = pTemp;
         pTemp = pTemp->pNext;

         FreeIniMMPolicy(pIniMMPolicy);

    }
}


PINIMMPOLICY
FindMMPolicyByGuid(
    PINIMMPOLICY pIniMMPolicyList,
    GUID gPolicyID
    )
{
    DWORD dwError = 0;
    PINIMMPOLICY pTemp = NULL;


    pTemp = pIniMMPolicyList;

    while (pTemp) {

        if (!memcmp(&(pTemp->gPolicyID), &gPolicyID, sizeof(GUID))) {
            return (pTemp);
        }
        pTemp = pTemp->pNext;

    }

    return (NULL);
}


VOID
FreeMMPolicies(
    DWORD dwNumMMPolicies,
    PIPSEC_MM_POLICY pMMPolicies
    )
{
    DWORD i = 0;

    if (pMMPolicies) {

        for (i = 0; i < dwNumMMPolicies; i++) {

            if (pMMPolicies[i].pszPolicyName) {
                SPDApiBufferFree(pMMPolicies[i].pszPolicyName);
            }

            FreeMMOffers(
                pMMPolicies[i].dwOfferCount,
                pMMPolicies[i].pOffers
                );

        }

        SPDApiBufferFree(pMMPolicies);

    }

}


DWORD
GetMMPolicyByID(
    LPWSTR pServerName,
    DWORD dwVersion,
    GUID gMMPolicyID,
    PIPSEC_MM_POLICY * ppMMPolicy,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function gets a main mode policy from the SPD.

Arguments:

    pServerName - Server from which to get the main mode policy.

    gMMPolicyID - Guid of the main mode policy to get.

    ppMMPolicy - Main mode policy found returned to the caller.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMPOLICY pIniMMPolicy = NULL;
    PIPSEC_MM_POLICY pMMPolicy = NULL;


    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMPolicy = FindMMPolicyByGuid(
                       gpIniMMPolicy,
                       gMMPolicyID
                       );
    if (!pIniMMPolicy) {
        dwError = ERROR_IPSEC_MM_POLICY_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = GetIniMMPolicy(
                  pIniMMPolicy,
                  &pMMPolicy
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    *ppMMPolicy = pMMPolicy;

    LEAVE_SPD_SECTION();
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    *ppMMPolicy = NULL;
    return (dwError);
}


DWORD
LocateMMPolicy(
    PMM_FILTER pMMFilter,
    PINIMMPOLICY * ppIniMMPolicy
    )
{
    DWORD dwError = 0;
    PINIMMPOLICY pIniMMPolicy = NULL;


    if ((pMMFilter->dwFlags) & IPSEC_MM_POLICY_DEFAULT_POLICY) {

        if (!gpIniDefaultMMPolicy) {
            dwError = ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        pIniMMPolicy = gpIniDefaultMMPolicy;

    }
    else {

        pIniMMPolicy = FindMMPolicyByGuid(
                           gpIniMMPolicy,
                           pMMFilter->gPolicyID
                           );
        if (!pIniMMPolicy) {
            dwError = ERROR_IPSEC_MM_POLICY_NOT_FOUND;
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }

    *ppIniMMPolicy = pIniMMPolicy;
    return (dwError);

error:

    *ppIniMMPolicy = NULL;
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\mm-policy.h ===
typedef struct _iniMMpolicy {
    GUID gPolicyID;
    LPWSTR pszPolicyName;
    DWORD  cRef;
    DWORD  dwSource;
    DWORD dwFlags;
    ULONG uSoftExpirationTime;
    DWORD dwOfferCount;
    PIPSEC_MM_OFFER pOffers;
    struct _iniMMpolicy * pNext;
} INIMMPOLICY, * PINIMMPOLICY;

DWORD
AddMMPolicyInternal(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    DWORD dwSource,
    PIPSEC_MM_POLICY pMMPolicy,
    LPVOID pvReserved
    );
    
DWORD
CreateIniMMPolicy(
    PIPSEC_MM_POLICY pMMPolicy,
    PINIMMPOLICY * ppIniMMPolicy
    );

DWORD
ValidateMMPolicy(
    PIPSEC_MM_POLICY pMMPolicy
    );

DWORD
ValidateMMOffers(
    DWORD dwOfferCount,
    PIPSEC_MM_OFFER pOffers
    );

DWORD
ValidateMMOffer(
    PIPSEC_MM_OFFER pOffer
    );

PINIMMPOLICY
FindMMPolicy(
    PINIMMPOLICY pIniMMPolicyList,
    LPWSTR pszPolicyName
    );

VOID
FreeIniMMPolicy(
    PINIMMPOLICY pIniMMPolicy
    );

VOID
FreeIniMMOffers(
    DWORD dwOfferCount,
    PIPSEC_MM_OFFER pOffers
    );

DWORD
CreateIniMMOffers(
    DWORD dwInOfferCount,
    PIPSEC_MM_OFFER pInOffers,
    PDWORD pdwOfferCount,
    PIPSEC_MM_OFFER * ppOffers
    );

DWORD
SetIniMMPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PIPSEC_MM_POLICY pMMPolicy
    );

DWORD
GetIniMMPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PIPSEC_MM_POLICY * ppMMPolicy
    );

DWORD
CopyMMPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PIPSEC_MM_POLICY pMMPolicy
    );

DWORD
CreateMMOffers(
    DWORD dwInOfferCount,
    PIPSEC_MM_OFFER pInOffers,
    PDWORD pdwOfferCount,
    PIPSEC_MM_OFFER * ppOffers
    );

DWORD
DeleteIniMMPolicy(
    PINIMMPOLICY pIniMMPolicy
    );

VOID
FreeMMOffers(
    DWORD dwOfferCount,
    PIPSEC_MM_OFFER pOffers
    );

VOID
FreeIniMMPolicyList(
    PINIMMPOLICY pIniMMPolicyList
    );

PINIMMPOLICY
FindMMPolicyByGuid(
    PINIMMPOLICY pIniMMPolicyList,
    GUID gPolicyID
    );

VOID
FreeMMPolicies(
    DWORD dwNumMMPolicies,
    PIPSEC_MM_POLICY pMMPolicies
    );

DWORD
LocateMMPolicy(
    PMM_FILTER pMMFilter,
    PINIMMPOLICY * ppIniMMPolicy
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\memory.c ===
/*++


Copyright (c) 1990  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    This module provides all the memory management functions for all spooler
    components

Author:

    Krishna Ganugapati (KrishnaG) 03-Feb-1994

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>
//#include "oledsdbg.h"

#define SPDAssert(x)    NULL

#define WORD_ALIGN_DOWN(addr) ((LPBYTE)((DWORD)addr &= ~1))

#define DWORD_ALIGN_UP(size) ((size+3)&~3)


#if DBG


DWORD dwMemoryLog = 0;

#define MAXDEPTH 10

typedef struct _SPDMEMTAG {
    DWORD Tag ;
    DWORD Size ;
    PVOID pvBackTrace[MAXDEPTH+1];
    LPSTR pszSymbol[MAXDEPTH+1];
    DWORD uDepth;
    LIST_ENTRY List ;
} SPDMEMTAG, *PSPDMEMTAG ;

LIST_ENTRY       SPDMemList ;
DWORD            SPDMemCount ;
CRITICAL_SECTION SPDMemCritSect ;

/*++

Routine Description:

    This function initializes the SPD mem tracking code. Must be call
    during DLL load an ONLY during DLL load.

Arguments:

    None

Return Value:

    None.

--*/
VOID InitSPDMem(
    VOID
)
{
    InitializeCriticalSection(&SPDMemCritSect) ;
    InitializeListHead(&SPDMemList) ;
    SPDMemCount = 0 ;
}

/*++

Routine Description:

    This function asserts that the mem list is empty on exit.

Arguments:

    None

Return Value:

    None.

--*/
VOID AssertSPDMemLeaks(
    VOID
)
{
    SPDAssert(IsListEmpty(&SPDMemList)) ;
}

#endif

LPVOID
AllocSPDMem(
    DWORD cb
)
/*++

Routine Description:

    This function will allocate local memory. It will possibly allocate extra
    memory and fill this with debugging information for the debugging version.

Arguments:

    cb - The amount of memory to allocate

Return Value:

    NON-NULL - A pointer to the allocated memory

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
    LPVOID pMem = NULL;

    pMem = LocalAlloc(LPTR, cb);

    if (pMem) {
        memset((LPBYTE) pMem, 0, cb);
    }
    return (pMem);
}

BOOL
FreeSPDMem(
   LPVOID pMem
)
{
    return(LocalFree(pMem) == NULL);
}

LPVOID
ReallocSPDMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
)
{
    LPVOID pNewMem;

    pNewMem=AllocSPDMem(cbNew);

    if (pOldMem && pNewMem) {
        memcpy(pNewMem, pOldMem, min(cbNew, cbOld));
        FreeSPDMem(pOldMem);
    }

    return pNewMem;
}

LPWSTR
AllocSPDStr(
    LPWSTR pStr
)
/*++

Routine Description:

    This function will allocate enough local memory to store the specified
    string, and copy that string to the allocated memory

Arguments:

    pStr - Pointer to the string that needs to be allocated and stored

Return Value:

    NON-NULL - A pointer to the allocated memory containing the string

    FALSE/NULL - The operation failed. Extended error status is available
    using GetLastError.

--*/
{
   LPWSTR pMem;

   if (!pStr)
      return 0;

   if (pMem = (LPWSTR)AllocSPDMem( wcslen(pStr)*sizeof(WCHAR) + sizeof(WCHAR) ))
      wcscpy(pMem, pStr);

   return pMem;
}

BOOL
FreeSPDStr(
   LPWSTR pStr
)
{
   return pStr ? FreeSPDMem(pStr)
               : FALSE;
}

BOOL
ReallocSPDStr(
   LPWSTR *ppStr,
   LPWSTR pStr
)
{
   FreeSPDStr(*ppStr);
   *ppStr=AllocSPDStr(pStr);

   return TRUE;
}

DWORD
AllocateSPDMemory(
    DWORD cb,
    LPVOID * ppMem
    )
{
    DWORD dwError = 0;

    LPBYTE pMem = NULL;

    pMem = AllocSPDMem(cb);

    if (!pMem) {
        dwError = GetLastError();
    }

    *ppMem = pMem;

    return(dwError);
}

void
FreeSPDMemory(
    LPVOID pMem
    )
{
    if (pMem) {
        FreeSPDMem(pMem);
    }

    return;
}


DWORD
AllocateSPDString(
    LPWSTR pszString,
    LPWSTR * ppszNewString
    )
{
    LPWSTR pszNewString = NULL;
    DWORD dwError = 0;

    pszNewString = AllocSPDStr(pszString);

    if (!pszNewString) {
        dwError = GetLastError();
    }

    *ppszNewString = pszNewString;

    return(dwError);
}

void
FreeSPDString(
    LPWSTR pszString
    )
{
    if (pszString) {
        FreeSPDStr(pszString);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\mmspecific.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    mmspecific.c

Abstract:

    This module contains all of the code to drive the
    mm specific filter list management of IPSecSPD Service.

Author:

    abhisheV    08-December-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


DWORD
ApplyMMTransform(
    PINIMMFILTER pFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PSPECIAL_ADDR pSpecialAddrsList,
    PINIMMSFILTER * ppSpecificFilters
    )
/*++

Routine Description:

    This function expands a generic mm filter into its
    corresponding specific filters.

Arguments:

    pFilter - Generic filter to expand.

    pMatchingAddresses - List of local ip addresses whose interface
                         type matches that of the filter.

    dwAddrCnt - Number of local ip addresses in the list.

    ppSpecificFilters - List of specific filters expanded for the
                        given generic filter.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMSFILTER pSpecificFilters = NULL;
    PINIMMSFILTER pOutboundSpecificFilters = NULL;
    PINIMMSFILTER pInboundSpecificFilters = NULL;

    PADDR_V4 pOutSrcAddrList = NULL;
    DWORD dwOutSrcAddrCnt = 0;
    PADDR_V4 pInSrcAddrList = NULL;
    DWORD dwInSrcAddrCnt = 0;

    PADDR_V4 pOutDesAddrList = NULL;
    DWORD dwOutDesAddrCnt = 0;
    PADDR_V4 pInDesAddrList = NULL;
    DWORD dwInDesAddrCnt = 0;


    // 
    // Form the outbound and inbound source and destination
    // address lists.
    // 

    dwError = FormMMOutboundInboundAddresses(
                  pFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  pSpecialAddrsList,
                  &pOutSrcAddrList,
                  &dwOutSrcAddrCnt,
                  &pInSrcAddrList,
                  &dwInSrcAddrCnt,
                  &pOutDesAddrList,
                  &dwOutDesAddrCnt,
                  &pInDesAddrList,
                  &dwInDesAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    //
    // Form outbound specific filters.
    //

    dwError = FormSpecificMMFilters(
                  pFilter,
                  pOutSrcAddrList,
                  dwOutSrcAddrCnt,
                  pOutDesAddrList,
                  dwOutDesAddrCnt,
                  FILTER_DIRECTION_OUTBOUND,
                  &pOutboundSpecificFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    //
    // Form inbound specific filters.
    //

    dwError = FormSpecificMMFilters(
                  pFilter,
                  pInSrcAddrList,
                  dwInSrcAddrCnt,
                  pInDesAddrList,
                  dwInDesAddrCnt,
                  FILTER_DIRECTION_INBOUND,
                  &pInboundSpecificFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    pSpecificFilters = pOutboundSpecificFilters;

    AddToSpecificMMList(
        &pSpecificFilters,
        pInboundSpecificFilters
        );


    *ppSpecificFilters = pSpecificFilters;

cleanup:

    if (pOutSrcAddrList) {
        FreeSPDMemory(pOutSrcAddrList);
    }

    if (pInSrcAddrList) {
        FreeSPDMemory(pInSrcAddrList);
    }

    if (pOutDesAddrList) {
        FreeSPDMemory(pOutDesAddrList);
    }

    if (pInDesAddrList) {
        FreeSPDMemory(pInDesAddrList);
    }

    return (dwError);

error:

    if (pOutboundSpecificFilters) {
        FreeIniMMSFilterList(pOutboundSpecificFilters);
    }

    if (pInboundSpecificFilters) {
        FreeIniMMSFilterList(pInboundSpecificFilters);
    }


    *ppSpecificFilters = NULL;
    goto cleanup;
}


DWORD
FormMMOutboundInboundAddresses(
    PINIMMFILTER pFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PSPECIAL_ADDR pSpecialAddrsList,
    PADDR_V4 * ppOutSrcAddrList,
    PDWORD pdwOutSrcAddrCnt,
    PADDR_V4 * ppInSrcAddrList,
    PDWORD pdwInSrcAddrCnt,
    PADDR_V4 * ppOutDesAddrList,
    PDWORD pdwOutDesAddrCnt,
    PADDR_V4 * ppInDesAddrList,
    PDWORD pdwInDesAddrCnt
    )
/*++

Routine Description:

    This function forms the outbound and inbound source and
    destination address sets for a generic filter.

Arguments:

    pFilter - Generic filter under consideration.

    pMatchingAddresses - List of local ip addresses whose interface
                         type matches that of the filter.

    dwAddrCnt - Number of local ip addresses in the list.

    ppOutSrcAddrList - List of outbound source addresses.

    pdwOutSrcAddrCnt - Number of addresses in the outbound
                       source address list.

    ppInSrcAddrList - List of inbound source addresses.

    pdwInSrcAddrCnt - Number of addresses in the inbound
                      source address list.

    ppOutDesAddrList - List of outbound destination addresses.

    pdwOutDesAddrCnt - Number of addresses in the outbound
                       destination address list.

    ppInDesAddrList - List of inbound destination addresses.

    pdwInDesAddrCnt - Number of addresses in the inbound
                      destination address list.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;

    PADDR_V4 pSrcAddrList = NULL;
    DWORD dwSrcAddrCnt = 0;
    PADDR_V4 pDesAddrList = NULL;
    DWORD dwDesAddrCnt = 0;

    PADDR_V4 pOutSrcAddrList = NULL;
    DWORD dwOutSrcAddrCnt = 0;
    PADDR_V4 pInSrcAddrList = NULL;
    DWORD dwInSrcAddrCnt = 0;

    PADDR_V4 pOutDesAddrList = NULL;
    DWORD dwOutDesAddrCnt = 0;
    PADDR_V4 pInDesAddrList = NULL;
    DWORD dwInDesAddrCnt = 0;


    //
    // Replace wild card information to generate the new source
    // address list.
    //

    dwError = FormAddressList(
                  pFilter->SrcAddr,
                  pMatchingAddresses,
                  dwAddrCnt,
                  pSpecialAddrsList,
                  pFilter->InterfaceType,
                  &pSrcAddrList,
                  &dwSrcAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Replace wild card information to generate the new destination
    // address list.
    //

    dwError = FormAddressList(
                  pFilter->DesAddr,
                  pMatchingAddresses,
                  dwAddrCnt,
                  pSpecialAddrsList,
                  pFilter->InterfaceType,
                  &pDesAddrList,
                  &dwDesAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Separate the source address list into outbound and inbound 
    // source address sets based on the local machine's ip addresses.
    //

    dwError = SeparateAddrList(
                  pFilter->SrcAddr.AddrType,
                  pSrcAddrList,
                  dwSrcAddrCnt,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pOutSrcAddrList,
                  &dwOutSrcAddrCnt,
                  &pInSrcAddrList,
                  &dwInSrcAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Separate the destination address list into outbound and inbound
    // destination address sets based on the local machine's ip 
    // addresses.
    //

    dwError = SeparateAddrList(
                  pFilter->DesAddr.AddrType,
                  pDesAddrList,
                  dwDesAddrCnt,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pInDesAddrList,
                  &dwInDesAddrCnt,
                  &pOutDesAddrList,
                  &dwOutDesAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppOutSrcAddrList = pOutSrcAddrList;
    *pdwOutSrcAddrCnt = dwOutSrcAddrCnt;
    *ppInSrcAddrList = pInSrcAddrList;
    *pdwInSrcAddrCnt = dwInSrcAddrCnt;

    *ppOutDesAddrList = pOutDesAddrList;
    *pdwOutDesAddrCnt = dwOutDesAddrCnt;
    *ppInDesAddrList = pInDesAddrList;
    *pdwInDesAddrCnt = dwInDesAddrCnt;

cleanup:

    if (pSrcAddrList) {
        FreeSPDMemory(pSrcAddrList);
    }

    if (pDesAddrList) {
        FreeSPDMemory(pDesAddrList);
    }

    return (dwError);

error:

    if (pOutSrcAddrList) {
        FreeSPDMemory(pOutSrcAddrList);
    }

    if (pInSrcAddrList) {
        FreeSPDMemory(pInSrcAddrList);
    }

    if (pOutDesAddrList) {
        FreeSPDMemory(pOutDesAddrList);
    }

    if (pInDesAddrList) {
        FreeSPDMemory(pInDesAddrList);
    }

    *ppOutSrcAddrList = NULL;
    *pdwOutSrcAddrCnt = 0;
    *ppInSrcAddrList = NULL;
    *pdwInSrcAddrCnt = 0;

    *ppOutDesAddrList = NULL;
    *pdwOutDesAddrCnt = 0;
    *ppInDesAddrList = NULL;
    *pdwInDesAddrCnt = 0;

    goto cleanup;
}


DWORD
FormSpecificMMFilters(
    PINIMMFILTER pFilter,
    PADDR_V4 pSrcAddrList,
    DWORD dwSrcAddrCnt,
    PADDR_V4 pDesAddrList,
    DWORD dwDesAddrCnt,
    DWORD dwDirection,
    PINIMMSFILTER * ppSpecificFilters
    )
/*++

Routine Description:

    This function forms the specific main mode filters
    for the given generic filter and the source and 
    destination address sets.

Arguments:

    pFilter - Generic filter for which specific filters
              are to be created.

    pSrcAddrList - List of source addresses.

    dwSrcAddrCnt - Number of addresses in the source
                   address list.

    pDesAddrList - List of destination addresses.

    dwDesAddrCnt - Number of addresses in the destination
                   address list.

    ppSpecificFilters - Specific filters created for the given
                        generic filter and the given addresses.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMSFILTER pSpecificFilters = NULL;
    DWORD i = 0, j = 0;
    PINIMMSFILTER pSpecificFilter = NULL;



    for (i = 0; i < dwSrcAddrCnt; i++) {

        for (j = 0; j < dwDesAddrCnt; j++) {

            dwError = CreateSpecificMMFilter(
                          pFilter,
                          pSrcAddrList[i],
                          pDesAddrList[j],
                          &pSpecificFilter
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            //
            // Set the direction of the filter.
            //

            pSpecificFilter->dwDirection = dwDirection;

            AssignMMFilterWeight(pSpecificFilter);

            AddToSpecificMMList(
                &pSpecificFilters,
                pSpecificFilter
                );

        }

    }

    *ppSpecificFilters = pSpecificFilters;
    return (dwError);

error:

    if (pSpecificFilters) {
        FreeIniMMSFilterList(pSpecificFilters);
    }

    *ppSpecificFilters = NULL;
    return (dwError);
}


DWORD
CreateSpecificMMFilter(
    PINIMMFILTER pGenericFilter,
    ADDR_V4 SrcAddr,
    ADDR_V4 DesAddr,
    PINIMMSFILTER * ppSpecificFilter
    )
{
    DWORD dwError = 0; 
    PINIMMSFILTER pSpecificFilter = NULL;


    dwError = AllocateSPDMemory(
                    sizeof(INIMMSFILTER),
                    &pSpecificFilter
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pSpecificFilter->cRef = 0;

    pSpecificFilter->IpVersion = pGenericFilter->IpVersion;

    CopyGuid(pGenericFilter->gFilterID, &(pSpecificFilter->gParentID));

    dwError = AllocateSPDString(
                  pGenericFilter->pszFilterName,
                  &(pSpecificFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pSpecificFilter->InterfaceType = pGenericFilter->InterfaceType;

    pSpecificFilter->dwFlags = pGenericFilter->dwFlags;

    CopyAddresses(SrcAddr, &(pSpecificFilter->SrcAddr));

    CopyAddresses(DesAddr, &(pSpecificFilter->DesAddr));

    //
    // Direction must be set in the calling routine.
    //

    pSpecificFilter->dwDirection = 0;

    //
    // Weight must be set in the calling routine.
    //

    pSpecificFilter->dwWeight = 0;

    CopyGuid(pGenericFilter->gMMAuthID, &(pSpecificFilter->gMMAuthID));

    CopyGuid(pGenericFilter->gPolicyID, &(pSpecificFilter->gPolicyID));

    pSpecificFilter->pIniMMAuthMethods = NULL;

    pSpecificFilter->pIniMMPolicy = NULL;

    pSpecificFilter->pNext = NULL;

    *ppSpecificFilter = pSpecificFilter;
    return (dwError);

error:

    if (pSpecificFilter) {
        FreeIniMMSFilter(pSpecificFilter);
    }

    *ppSpecificFilter = NULL;
    return (dwError);
}


VOID
AssignMMFilterWeight(
    PINIMMSFILTER pSpecificFilter
    )
/*++

Routine Description:

    Computes and assigns the weight to a specific mm filter.

    The mm filter weight consists of the following:

    31         16       12           8        0
    +-----------+--------+-----------+--------+
    |AddrMaskWgt|           Reserved          |
    +-----------+--------+-----------+--------+

Arguments:

    pSpecificFilter - Specific mm filter to which the weight 
                      is to be assigned.

Return Value:

    None.

--*/
{
    DWORD dwWeight = 0;
    ULONG SrcMask = 0;
    ULONG DesMask = 0;
    DWORD dwSrcMaskWeight = 0;
    DWORD dwDesMaskWeight = 0;
    DWORD dwMaskWeight = 0;
    DWORD i = 0;


    //
    // Weight Rule:
    // A field with a more specific value gets a higher weight than
    // the same field with a lesser specific value.
    //

    //
    // IP addresses get the weight values based on their mask values.
    // In the address case, the weight is computed as a sum of the 
    // bit positions starting from the position that contains the 
    // first least significant non-zero bit to the most significant
    // bit position of the mask. 
    // All unique ip addresses have a mask of 0xFFFFFFFF and thus get
    // the same weight, which is 1 + 2 + .... + 32.
    // A subnet address has a mask with atleast the least significant
    // bit zero and thus gets weight in the range (2 + .. + 32) to 0.
    //
  
    DesMask = ntohl(pSpecificFilter->DesAddr.uSubNetMask);

    for (i = 0; i < sizeof(ULONG) * 8; i++) {

         //
         // If the bit position contains a non-zero bit, add the bit
         // position to the sum.
         //

         if ((DesMask & 0x1) == 0x1) {
             dwMaskWeight += (i+1);
             dwDesMaskWeight += (i+1);
         }

         //
         // Move to the next bit position.
         //

         DesMask = DesMask >> 1;

    }


    SrcMask = ntohl(pSpecificFilter->SrcAddr.uSubNetMask);

    for (i = 0; i < sizeof(ULONG) * 8; i++) {

         //
         // If the bit position contains a non-zero bit, add the bit
         // position to the sum.
         //

         if ((SrcMask & 0x1) == 0x1) {
             dwMaskWeight += (i+1);
             dwSrcMaskWeight += (i+1);
         }

         //
         // Move to the next bit position.
         //

         SrcMask = SrcMask >> 1;

    }

    if (dwDesMaskWeight >= dwSrcMaskWeight) {
        dwWeight |= WEIGHT_ADDRESS_TIE_BREAKER;
    }

    //
    // Move the mask weight to the set of bits in the overall weight
    // that it occupies.
    //

    dwMaskWeight = dwMaskWeight << 16;

    dwWeight += dwMaskWeight;

    pSpecificFilter->dwWeight = dwWeight;
}


VOID
AddToSpecificMMList(
    PINIMMSFILTER * ppSpecificMMFilterList,
    PINIMMSFILTER pSpecificMMFilters
    )
{
    PINIMMSFILTER pListOne = NULL;
    PINIMMSFILTER pListTwo = NULL;
    PINIMMSFILTER pListMerge = NULL;
    PINIMMSFILTER pLast = NULL;

    if (!(*ppSpecificMMFilterList) && !pSpecificMMFilters) {
        return;
    }

    if (!(*ppSpecificMMFilterList)) {
        *ppSpecificMMFilterList = pSpecificMMFilters;
        return;
    }

    if (!pSpecificMMFilters) {
        return;
    }

    pListOne = *ppSpecificMMFilterList;
    pListTwo = pSpecificMMFilters;

    while (pListOne && pListTwo) {

        if ((pListOne->dwWeight) > (pListTwo->dwWeight)) {

            if (!pListMerge) {
                pListMerge = pListOne;
                pLast = pListOne;
                pListOne = pListOne->pNext;
            }
            else {
                pLast->pNext = pListOne;
                pListOne = pListOne->pNext;
                pLast = pLast->pNext;
            }

        }
        else {

            if (!pListMerge) {
                pListMerge = pListTwo;
                pLast = pListTwo;
                pListTwo = pListTwo->pNext;
            }
            else {
                pLast->pNext = pListTwo;
                pListTwo = pListTwo->pNext;
                pLast = pLast->pNext;
            }

        }

    }
    
    if (pListMerge) {
        if (pListOne) {
            pLast->pNext = pListOne;
        }
        else {
            pLast->pNext = pListTwo;
        }
    }

    *ppSpecificMMFilterList = pListMerge;
    return;
}


VOID
FreeIniMMSFilterList(
    PINIMMSFILTER pIniMMSFilterList
    )
{
    PINIMMSFILTER pFilter = NULL;
    PINIMMSFILTER pTempFilter = NULL;

    pFilter = pIniMMSFilterList;

    while (pFilter) {
        pTempFilter = pFilter;
        pFilter = pFilter->pNext;
        FreeIniMMSFilter(pTempFilter);
    }
}


VOID
FreeIniMMSFilter(
    PINIMMSFILTER pIniMMSFilter
    )
{
    if (pIniMMSFilter) {
        if (pIniMMSFilter->pszFilterName) {
            FreeSPDString(pIniMMSFilter->pszFilterName);
        }

        //
        // Must not ever free pIniMMSFilter->pIniMMPolicy.
        //

        FreeSPDMemory(pIniMMSFilter);
    }
}


VOID
LinkMMSpecificFiltersToPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PINIMMSFILTER pIniMMSFilters
    )
{
    PINIMMSFILTER pTemp = NULL;

    pTemp = pIniMMSFilters;

    while (pTemp) {
        pTemp->pIniMMPolicy = pIniMMPolicy;
        pTemp = pTemp->pNext;
    }

    return;
}


VOID
LinkMMSpecificFiltersToAuth(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMSFILTER pIniMMSFilters
    )
{
    PINIMMSFILTER pTemp = NULL;

    pTemp = pIniMMSFilters;

    while (pTemp) {
        pTemp->pIniMMAuthMethods = pIniMMAuthMethods;
        pTemp = pTemp->pNext;
    }

    return;
}


VOID
RemoveIniMMSFilter(
    PINIMMSFILTER pIniMMSFilter
    )
{
    PINIMMSFILTER * ppTemp = NULL;

    ppTemp = &gpIniMMSFilter;

    while (*ppTemp) {

        if (*ppTemp == pIniMMSFilter) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);
    }

    if (*ppTemp) {
        *ppTemp = pIniMMSFilter->pNext;
    }

    return;
}


DWORD
EnumSpecificMMFilters(
    PINIMMSFILTER pIniMMSFilterList,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PMM_FILTER * ppMMFilters,
    PDWORD pdwNumMMFilters
    )
/*++

Routine Description:

    This function creates enumerated specific filters.

Arguments:

    pIniMMSFilterList - List of specific filters to enumerate.

    dwResumeHandle - Location in the specific filter list from which
                     to resume enumeration.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    ppMMFilters - Enumerated filters returned to the caller.

    pdwNumMMFilters - Number of filters actually enumerated.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwNumToEnum = 0;
    PINIMMSFILTER pIniMMSFilter = NULL;
    DWORD i = 0;
    PINIMMSFILTER pTemp = NULL;
    DWORD dwNumMMFilters = 0;
    PMM_FILTER pMMFilters = 0;
    PMM_FILTER pMMFilter = 0;


    if (!dwPreferredNumEntries || 
        (dwPreferredNumEntries > MAX_MMFILTER_ENUM_COUNT)) {
        dwNumToEnum = MAX_MMFILTER_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    pIniMMSFilter = pIniMMSFilterList;

    for (i = 0; (i < dwResumeHandle) && (pIniMMSFilter != NULL); i++) {
        pIniMMSFilter = pIniMMSFilter->pNext;
    }

    if (!pIniMMSFilter) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTemp = pIniMMSFilter;

    while (pTemp && (dwNumMMFilters < dwNumToEnum)) {
        dwNumMMFilters++;
        pTemp = pTemp->pNext;
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(MM_FILTER)*dwNumMMFilters,
                  &pMMFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pIniMMSFilter;
    pMMFilter = pMMFilters;

    for (i = 0; i < dwNumMMFilters; i++) {

        dwError = CopyMMSFilter(
                      pTemp,
                      pMMFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        pTemp = pTemp->pNext;
        pMMFilter++;

    }

    *ppMMFilters = pMMFilters;
    *pdwNumMMFilters = dwNumMMFilters;
    return (dwError);

error:

    if (pMMFilters) {
        FreeMMFilters(
            i,
            pMMFilters
            );
    }

    *ppMMFilters = NULL;
    *pdwNumMMFilters = 0;

    return (dwError);
}


DWORD
CopyMMSFilter(
    PINIMMSFILTER pIniMMSFilter,
    PMM_FILTER pMMFilter
    )
/*++

Routine Description:

    This function copies an internal filter into an external filter
    container.

Arguments:

    pIniMMSFilter - Internal filter to copy.

    pMMFilter - External filter container in which to copy.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;


    pMMFilter->IpVersion = pIniMMSFilter->IpVersion;

    CopyGuid(pIniMMSFilter->gParentID, &(pMMFilter->gFilterID));

    dwError = CopyName(
                  pIniMMSFilter->pszFilterName,
                  &(pMMFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilter->InterfaceType = pIniMMSFilter->InterfaceType;

    pMMFilter->bCreateMirror = FALSE;

    pMMFilter->dwFlags = pIniMMSFilter->dwFlags;

    dwError = CopyIntToExtAddresses(pIniMMSFilter->SrcAddr, &(pMMFilter->SrcAddr));
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyIntToExtAddresses(pIniMMSFilter->DesAddr, &(pMMFilter->DesAddr));
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilter->dwDirection = pIniMMSFilter->dwDirection;

    pMMFilter->dwWeight = pIniMMSFilter->dwWeight;

    CopyGuid(pIniMMSFilter->gMMAuthID, &(pMMFilter->gMMAuthID));

    CopyGuid(pIniMMSFilter->gPolicyID, &(pMMFilter->gPolicyID));

    return (dwError);

error:

    if (pMMFilter->pszFilterName) {
        SPDApiBufferFree(pMMFilter->pszFilterName);
        pMMFilter->pszFilterName = NULL;
    }

    if (pMMFilter->SrcAddr.pgInterfaceID) {
        SPDApiBufferFree(pMMFilter->SrcAddr.pgInterfaceID);
        pMMFilter->SrcAddr.pgInterfaceID = NULL;
    }

    if (pMMFilter->DesAddr.pgInterfaceID) {
        SPDApiBufferFree(pMMFilter->DesAddr.pgInterfaceID);
        pMMFilter->DesAddr.pgInterfaceID = NULL;
    }

    return (dwError);
}


DWORD
EnumSelectSpecificMMFilters(
    PINIMMFILTER pIniMMFilter,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PMM_FILTER * ppMMFilters,
    PDWORD pdwNumMMFilters
    )
/*++

Routine Description:

    This function creates enumerated specific filters for
    the given generic filter.

Arguments:

    pIniMMFilter - Generic filter for which specific filters
                   are to be enumerated.

    dwResumeHandle - Location in the specific filter list for the
                     given generic filter from which to resume
                     enumeration.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    ppMMFilters - Enumerated filters returned to the caller.

    pdwNumMMFilters - Number of filters actually enumerated.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwNumToEnum = 0;
    DWORD dwNumMMSFilters = 0; 
    PINIMMSFILTER * ppIniMMSFilters = NULL;
    DWORD i = 0;
    DWORD dwNumMMFilters = 0;
    PMM_FILTER pMMFilters = 0;
    PMM_FILTER pMMFilter = 0;


    if (!dwPreferredNumEntries || 
        (dwPreferredNumEntries > MAX_MMFILTER_ENUM_COUNT)) {
        dwNumToEnum = MAX_MMFILTER_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    dwNumMMSFilters = pIniMMFilter->dwNumMMSFilters;
    ppIniMMSFilters = pIniMMFilter->ppIniMMSFilters;

    if (!dwNumMMSFilters || (dwNumMMSFilters <= dwResumeHandle)) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwNumMMFilters = min((dwNumMMSFilters-dwResumeHandle),
                         dwNumToEnum);
 
    dwError = SPDApiBufferAllocate(
                  sizeof(MM_FILTER)*dwNumMMFilters,
                  &pMMFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilter = pMMFilters;

    for (i = 0; i < dwNumMMFilters; i++) {

        dwError = CopyMMSFilter(
                      *(ppIniMMSFilters + (dwResumeHandle + i)),
                      pMMFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        pMMFilter++;

    }

    *ppMMFilters = pMMFilters;
    *pdwNumMMFilters = dwNumMMFilters;
    return (dwError);

error:

    if (pMMFilters) {
        FreeMMFilters(
            i,
            pMMFilters
            );
    }

    *ppMMFilters = NULL;
    *pdwNumMMFilters = 0;

    return (dwError);
}


DWORD
IntMatchMMFilter(
    LPWSTR pServerName,
    DWORD dwVersion,
    PMM_FILTER pMMFilter,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PMM_FILTER * ppMatchedMMFilters,
    PIPSEC_MM_POLICY * ppMatchedMMPolicies,
    PINT_MM_AUTH_METHODS * ppMatchedMMAuthMethods,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function finds the matching mm filters for the given mm
    filter template. The matched filters can not be more specific
    than the given filter template.

Arguments:

    pServerName - Server on which a filter template is to be matched.

    pMMFilter - Filter template to match.

    dwFlags - Flags.

    ppMatchedMMFilters - Matched main mode filters returned to the
                         caller.

    ppMatchedMMPolicies - Main mode policies corresponding to the 
                          matched main mode filters returned to the
                          caller.

    ppMatchedMMAuthMethods - Main mode auth methods corresponding to the
                             matched main mode filters returned to the
                             caller.

    dwPreferredNumEntries - Preferred number of matched entries.

    pdwNumMatches - Number of filters actually matched.

    pdwResumeHandle - Handle to the location in the matched filter 
                      list from which to resume enumeration.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwResumeHandle = 0;
    DWORD dwNumToMatch = 0;
    PINIMMSFILTER pIniMMSFilter = NULL;
    DWORD i = 0;
    BOOL bMatches = FALSE;
    PINIMMSFILTER pTemp = NULL;
    DWORD dwNumMatches = 0;
    PINIMMSFILTER pLastMatchedFilter = NULL;
    PMM_FILTER pMatchedMMFilters = NULL;
    PIPSEC_MM_POLICY pMatchedMMPolicies = NULL;
    PINT_MM_AUTH_METHODS pMatchedMMAuthMethods = NULL;
    DWORD dwNumFilters = 0;
    DWORD dwNumPolicies = 0;
    DWORD dwNumAuthMethods = 0;
    PMM_FILTER pMatchedMMFilter = NULL;
    PIPSEC_MM_POLICY pMatchedMMPolicy = NULL;
    PINT_MM_AUTH_METHODS pTempMMAuthMethods = NULL;


    dwError = ValidateMMFilterTemplate(
                  pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwResumeHandle = *pdwResumeHandle;

    if (!dwPreferredNumEntries) {
        dwNumToMatch = 1;
    }
    else if (dwPreferredNumEntries > MAX_MMFILTER_ENUM_COUNT) {
        dwNumToMatch = MAX_MMFILTER_ENUM_COUNT;
    }
    else {
        dwNumToMatch = dwPreferredNumEntries;
    }

    ENTER_SPD_SECTION();

    dwError = ValidateMMSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMSFilter = gpIniMMSFilter;

    while ((i < dwResumeHandle) && (pIniMMSFilter != NULL)) {
        bMatches = MatchIniMMSFilter(
                       pIniMMSFilter,
                       pMMFilter
                       );
        if (bMatches) {
            i++;
        }
        pIniMMSFilter = pIniMMSFilter->pNext;
    }

    if (!pIniMMSFilter) {
        if (!(dwFlags & RETURN_DEFAULTS_ON_NO_MATCH)) {
            dwError = ERROR_NO_DATA;
            BAIL_ON_LOCK_ERROR(dwError);
        }
        else {
            dwError = CopyMMMatchDefaults(
                          &pMatchedMMFilters,
                          &pMatchedMMAuthMethods,
                          &pMatchedMMPolicies,
                          &dwNumMatches
                          );
            BAIL_ON_LOCK_ERROR(dwError);
            BAIL_ON_LOCK_SUCCESS(dwError);
        }
    }

    pTemp = pIniMMSFilter;

    while (pTemp && (dwNumMatches < dwNumToMatch)) {
        bMatches = MatchIniMMSFilter(
                       pTemp,
                       pMMFilter
                       );
        if (bMatches) {
            pLastMatchedFilter = pTemp;
            dwNumMatches++;
        }
        pTemp = pTemp->pNext;
    }

    if (!dwNumMatches) {
        if (!(dwFlags & RETURN_DEFAULTS_ON_NO_MATCH)) {
            dwError = ERROR_NO_DATA;
            BAIL_ON_LOCK_ERROR(dwError);
        }
        else {
            dwError = CopyMMMatchDefaults(
                          &pMatchedMMFilters,
                          &pMatchedMMAuthMethods,
                          &pMatchedMMPolicies,
                          &dwNumMatches
                          );
            BAIL_ON_LOCK_ERROR(dwError);
            BAIL_ON_LOCK_SUCCESS(dwError);
        }
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(MM_FILTER)*dwNumMatches,
                  &pMatchedMMFilters
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_MM_POLICY)*dwNumMatches,
                  &pMatchedMMPolicies
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = SPDApiBufferAllocate(
                  sizeof(INT_MM_AUTH_METHODS)*dwNumMatches,
                  &pMatchedMMAuthMethods
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    if (dwNumMatches == 1) {

        dwError = CopyMMSFilter(
                      pLastMatchedFilter,
                      pMatchedMMFilters
                      );
        BAIL_ON_LOCK_ERROR(dwError);
        dwNumFilters++;

        if (pLastMatchedFilter->pIniMMPolicy) {
            dwError = CopyMMPolicy(
                          pLastMatchedFilter->pIniMMPolicy,
                          pMatchedMMPolicies
                          );
            BAIL_ON_LOCK_ERROR(dwError);
        }
        else {
            memset(pMatchedMMPolicies, 0, sizeof(IPSEC_MM_POLICY));
        }
        dwNumPolicies++;

        if (pLastMatchedFilter->pIniMMAuthMethods) {
            dwError = CopyMMAuthMethods(
                          pLastMatchedFilter->pIniMMAuthMethods,
                          pMatchedMMAuthMethods
                          );
            BAIL_ON_LOCK_ERROR(dwError);
        }
        else {
            memset(pMatchedMMAuthMethods, 0, sizeof(INT_MM_AUTH_METHODS));
        }
        dwNumAuthMethods++;

    }
    else {

        pTemp = pIniMMSFilter;
        pMatchedMMFilter = pMatchedMMFilters;
        pMatchedMMPolicy = pMatchedMMPolicies;
        pTempMMAuthMethods = pMatchedMMAuthMethods;
        i = 0;

        while (i < dwNumMatches) {

            bMatches = MatchIniMMSFilter(
                           pTemp,
                           pMMFilter
                           );
            if (bMatches) {

                dwError = CopyMMSFilter(
                              pTemp,
                              pMatchedMMFilter
                              );
                BAIL_ON_LOCK_ERROR(dwError);
                pMatchedMMFilter++;
                dwNumFilters++;

                if (pTemp->pIniMMPolicy) {
                    dwError = CopyMMPolicy(
                                  pTemp->pIniMMPolicy,
                                  pMatchedMMPolicy
                                  );
                    BAIL_ON_LOCK_ERROR(dwError);
                }
                else {
                    memset(pMatchedMMPolicy, 0, sizeof(IPSEC_MM_POLICY));
                }
                pMatchedMMPolicy++;
                dwNumPolicies++;

                if (pTemp->pIniMMAuthMethods) {
                    dwError = CopyMMAuthMethods(
                                  pTemp->pIniMMAuthMethods,
                                  pTempMMAuthMethods
                                  );
                    BAIL_ON_LOCK_ERROR(dwError);
                }
                else {
                    memset(pTempMMAuthMethods, 0, sizeof(INT_MM_AUTH_METHODS));
                }
                pTempMMAuthMethods++;
                dwNumAuthMethods++;

                i++;

            }

            pTemp = pTemp->pNext;

        }

    }

lock_success:

    LEAVE_SPD_SECTION();

    *ppMatchedMMFilters = pMatchedMMFilters;
    *ppMatchedMMPolicies = pMatchedMMPolicies;
    *ppMatchedMMAuthMethods = pMatchedMMAuthMethods;
    *pdwNumMatches = dwNumMatches;
    *pdwResumeHandle = dwResumeHandle + dwNumMatches;

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    if (pMatchedMMFilters) {
        FreeMMFilters(
            dwNumFilters,
            pMatchedMMFilters
            );
    }

    if (pMatchedMMPolicies) {
        FreeMMPolicies(
            dwNumPolicies,
            pMatchedMMPolicies
            );
    }

    if (pMatchedMMAuthMethods) {
        FreeMMAuthMethods(
            dwNumAuthMethods,
            pMatchedMMAuthMethods
            );
    }

    *ppMatchedMMFilters = NULL;
    *ppMatchedMMPolicies = NULL;
    *ppMatchedMMAuthMethods = NULL;
    *pdwNumMatches = 0;
    *pdwResumeHandle = dwResumeHandle;

    return (dwError);
}


DWORD
ValidateMMFilterTemplate(
    PMM_FILTER pMMFilter
    )
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pMMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(&(pMMFilter->SrcAddr), TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(&(pMMFilter->DesAddr), TRUE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = AddressesConflict(
                     pMMFilter->SrcAddr,
                     pMMFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pMMFilter->dwDirection) {
        if ((pMMFilter->dwDirection != FILTER_DIRECTION_INBOUND) &&
            (pMMFilter->dwDirection != FILTER_DIRECTION_OUTBOUND)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

error:

    return (dwError);
}


BOOL
MatchIniMMSFilter(
    PINIMMSFILTER pIniMMSFilter,
    PMM_FILTER pMMFilter
    )
{
    BOOL bMatches = FALSE;

    if (pMMFilter->dwDirection) {
        if (pMMFilter->dwDirection != pIniMMSFilter->dwDirection) {
            return (FALSE);
        }
    }

    bMatches = MatchAddresses(
                   pIniMMSFilter->SrcAddr,
                   pMMFilter->SrcAddr
                   );
    if (!bMatches) {
        return (FALSE);
    }

    bMatches = MatchAddresses(
                   pIniMMSFilter->DesAddr,
                   pMMFilter->DesAddr
                   );
    if (!bMatches) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
CopyMMMatchDefaults(
    PMM_FILTER * ppMMFilters,
    PINT_MM_AUTH_METHODS * ppMMAuthMethods,
    PIPSEC_MM_POLICY * ppMMPolicies,
    PDWORD pdwNumMatches
    )
{
    DWORD dwError = 0;
    PMM_FILTER pMMFilters = NULL;
    PINT_MM_AUTH_METHODS pMMAuthMethods = NULL;
    PIPSEC_MM_POLICY pMMPolicies = NULL;
    DWORD dwNumFilters = 0;
    DWORD dwNumAuthMethods = 0;
    DWORD dwNumPolicies = 0;


    if (!gpIniDefaultMMPolicy) {
        dwError = ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!gpIniDefaultMMAuthMethods) {
        dwError = ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(MM_FILTER),
                  &pMMFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_MM_POLICY),
                  &pMMPolicies
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDApiBufferAllocate(
                  sizeof(INT_MM_AUTH_METHODS),
                  &pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyDefaultMMFilter(
                  pMMFilters,
                  gpIniDefaultMMAuthMethods,
                  gpIniDefaultMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    dwNumFilters++;

    dwError = CopyMMPolicy(
                  gpIniDefaultMMPolicy,
                  pMMPolicies
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    pMMPolicies->dwFlags |= IPSEC_MM_POLICY_ON_NO_MATCH;
    dwNumPolicies++;

    dwError = CopyMMAuthMethods(
                  gpIniDefaultMMAuthMethods,
                  pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    pMMAuthMethods->dwFlags |= IPSEC_MM_AUTH_ON_NO_MATCH;
    dwNumAuthMethods++;

    *ppMMFilters = pMMFilters;
    *ppMMPolicies = pMMPolicies;
    *ppMMAuthMethods = pMMAuthMethods;
    *pdwNumMatches = 1;

    return (dwError);

error:

    if (pMMFilters) {
        FreeMMFilters(
            dwNumFilters,
            pMMFilters
            );
    }

    if (pMMPolicies) {
        FreeMMPolicies(
            dwNumPolicies,
            pMMPolicies
            );
    }

    if (pMMAuthMethods) {
        FreeMMAuthMethods(
            dwNumAuthMethods,
            pMMAuthMethods
            );
    }

    *ppMMFilters = NULL;
    *ppMMPolicies = NULL;
    *ppMMAuthMethods = NULL;
    *pdwNumMatches = 0;

    return (dwError);
}


DWORD
CopyDefaultMMFilter(
    PMM_FILTER pMMFilter,
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMPOLICY pIniMMPolicy
    )
{
    DWORD dwError = 0;
    RPC_STATUS RpcStatus = RPC_S_OK;

    pMMFilter->IpVersion = IPSEC_PROTOCOL_V4;

    RpcStatus = UuidCreate(&(pMMFilter->gFilterID));
    if (!(RpcStatus == RPC_S_OK ||  RpcStatus == RPC_S_UUID_LOCAL_ONLY)) {
        dwError = RPC_S_CALL_FAILED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = CopyName(
                  L"0",
                  &(pMMFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilter->InterfaceType = INTERFACE_TYPE_ALL;

    pMMFilter->bCreateMirror = TRUE;

    pMMFilter->dwFlags = 0;

    pMMFilter->dwFlags |= IPSEC_MM_POLICY_DEFAULT_POLICY;
    pMMFilter->dwFlags |= IPSEC_MM_AUTH_DEFAULT_AUTH;

    pMMFilter->SrcAddr.AddrType = IP_ADDR_SUBNET;
    pMMFilter->SrcAddr.uIpAddr = SUBNET_ADDRESS_ANY;
    pMMFilter->SrcAddr.uSubNetMask = SUBNET_MASK_ANY;
    pMMFilter->SrcAddr.pgInterfaceID = NULL;

    pMMFilter->DesAddr.AddrType = IP_ADDR_SUBNET;
    pMMFilter->DesAddr.uIpAddr = SUBNET_ADDRESS_ANY;
    pMMFilter->DesAddr.uSubNetMask = SUBNET_MASK_ANY;
    pMMFilter->DesAddr.pgInterfaceID = NULL;

    pMMFilter->dwDirection = 0;

    pMMFilter->dwWeight = 0;

    CopyGuid(pIniMMAuthMethods->gMMAuthID, &(pMMFilter->gMMAuthID));

    CopyGuid(pIniMMPolicy->gPolicyID, &(pMMFilter->gPolicyID));

error:

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\mmauth.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    mmauth.c

Abstract:


Author:

    abhishev    06-January-2000

Environment: User Mode


Revision History:


--*/


#include "precomp.h"
#ifdef TRACE_ON
#include "mmauth.tmh"
#endif


DWORD
WINAPI
IntAddMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    DWORD dwSource,
    PINT_MM_AUTH_METHODS pMMAuthMethods,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function adds main mode auths to the SPD.

Arguments:

    pServerName - Server on which the main mode auths are to be added.

    pMMAuthMethods - Main mode auths to be added.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMAUTHMETHODS pIniMMAuthMethods = NULL;

    //
    // Validate the main mode auth methods.
    //

    dwError = IntValidateMMAuthMethods(
                  pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMAuthMethods = FindMMAuthMethods(
                            gpIniMMAuthMethods,
                            pMMAuthMethods->gMMAuthID
                            );
    if (pIniMMAuthMethods) {
        dwError = ERROR_IPSEC_MM_AUTH_EXISTS;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = CreateIniMMAuthMethods(
                  pMMAuthMethods,
                  &pIniMMAuthMethods
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMAuthMethods->dwSource = dwSource;

    pIniMMAuthMethods->pNext = gpIniMMAuthMethods;
    gpIniMMAuthMethods = pIniMMAuthMethods;

    if ((pIniMMAuthMethods->dwFlags) & IPSEC_MM_AUTH_DEFAULT_AUTH) {
        gpIniDefaultMMAuthMethods = pIniMMAuthMethods;
        TRACE(
            TRC_INFORMATION,
            (L"Set default MM auth methods to %!guid!",
            &pIniMMAuthMethods->gMMAuthID)
            );
    }

    LEAVE_SPD_SECTION();

    TRACE(
        TRC_INFORMATION,
        (L"Added MM auth methods %!guid!",
        &pIniMMAuthMethods->gMMAuthID)
        );
    
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:
#ifdef TRACE_ON    
    if (pMMAuthMethods) {
        TRACE(
            TRC_ERROR,
            (L"Failed to add MM auth methods %!guid!: %!winerr!",
            &pMMAuthMethods->gMMAuthID,
            dwError)
            );
    } else {
        TRACE(
            TRC_ERROR,
            (L"Failed to add MM auth methods.  Details unvailable since pMMAuthMethods is null: %!winerr!",
            dwError)
            );
    }
#endif


    return (dwError);
}

DWORD
IntValidateMMAuthMethods(
    PINT_MM_AUTH_METHODS pMMAuthMethods
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PINT_IPSEC_MM_AUTH_INFO pTemp = NULL;
    DWORD dwNumAuthInfos = 0;
    PINT_IPSEC_MM_AUTH_INFO pAuthenticationInfo = NULL;
    BOOL bSSPI = FALSE;
    BOOL bPresharedKey = FALSE;


    if (!pMMAuthMethods) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwNumAuthInfos = pMMAuthMethods->dwNumAuthInfos;
    pAuthenticationInfo = pMMAuthMethods->pAuthenticationInfo;

    if (!dwNumAuthInfos || !pAuthenticationInfo) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Need to catch the exception when the number of auth infos
    // specified is more than the actual number of auth infos.
    //


    pTemp = pAuthenticationInfo;

    for (i = 0; i < dwNumAuthInfos; i++) {

        if ((pTemp->AuthMethod != IKE_PRESHARED_KEY) &&
            (pTemp->AuthMethod != IKE_RSA_SIGNATURE) &&
            (pTemp->AuthMethod != IKE_SSPI)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        if (pTemp->AuthMethod != IKE_SSPI) {
            if (!(pTemp->dwAuthInfoSize) || !(pTemp->pAuthInfo)) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
            }
        }

        if (pTemp->AuthMethod == IKE_SSPI) {
            if (bSSPI) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
            }
            bSSPI = TRUE;
        }

        if (pTemp->AuthMethod == IKE_PRESHARED_KEY) {
            if (bPresharedKey) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
            }
            bPresharedKey = TRUE;
        }

        pTemp++;

    }

error:
#ifdef TRACE_ON
    if (dwError) {
        if (pMMAuthMethods) {
            TRACE(
                TRC_ERROR,
                (L"Failed MM Auth method validation %!guid!: %!winerr!",
                &pMMAuthMethods->gMMAuthID,
                dwError)
                );
        } else {
            TRACE(
                TRC_ERROR,
                (L"Failed MM Auth method validation.  No details available since pMMAuthMethods is null : %!winerr!",
                dwError)
                );
        }
    }
#endif

    return (dwError);
}


PINIMMAUTHMETHODS
FindMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    GUID gMMAuthID
    )
{
    DWORD dwError = 0;
    PINIMMAUTHMETHODS pTemp = NULL;


    pTemp = pIniMMAuthMethods;

    while (pTemp) {

        if (!memcmp(&(pTemp->gMMAuthID), &gMMAuthID, sizeof(GUID))) {
            return (pTemp);
        }
        pTemp = pTemp->pNext;

    }

    return (NULL);
}


DWORD
CreateIniMMAuthMethods(
    PINT_MM_AUTH_METHODS pMMAuthMethods,
    PINIMMAUTHMETHODS * ppIniMMAuthMethods
    )
{
    DWORD dwError = 0;
    PINIMMAUTHMETHODS pIniMMAuthMethods = NULL;


    dwError = AllocateSPDMemory(
                  sizeof(INIMMAUTHMETHODS),
                  &pIniMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pIniMMAuthMethods->gMMAuthID),
        &(pMMAuthMethods->gMMAuthID),
        sizeof(GUID)
        );

    pIniMMAuthMethods->dwFlags = pMMAuthMethods->dwFlags;
    pIniMMAuthMethods->cRef = 0;
    pIniMMAuthMethods->dwSource = 0;
    pIniMMAuthMethods->pNext = NULL;

    dwError = CreateIniMMAuthInfos(
                  pMMAuthMethods->dwNumAuthInfos,
                  pMMAuthMethods->pAuthenticationInfo,
                  &(pIniMMAuthMethods->dwNumAuthInfos),
                  &(pIniMMAuthMethods->pAuthenticationInfo)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIniMMAuthMethods = pIniMMAuthMethods;
    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        ("Failed to create MM auth method node %!guid!: %!winerr!",
        &pMMAuthMethods->gMMAuthID,
        dwError)
        );    
    
    if (pIniMMAuthMethods) {
        FreeIniMMAuthMethods(
            pIniMMAuthMethods
            );
    }

    *ppIniMMAuthMethods = NULL;
    return (dwError);
}


DWORD
CreateIniMMAuthInfos(
    DWORD dwInNumAuthInfos,
    PINT_IPSEC_MM_AUTH_INFO pInAuthenticationInfo,
    PDWORD pdwNumAuthInfos,
    PINT_IPSEC_MM_AUTH_INFO * ppAuthenticationInfo
    )
{
    DWORD dwError = 0;
    PINT_IPSEC_MM_AUTH_INFO pAuthenticationInfo = NULL;
    PINT_IPSEC_MM_AUTH_INFO pTemp = NULL;
    PINT_IPSEC_MM_AUTH_INFO pInTemp = NULL;
    DWORD i = 0;


    //
    // Number of auth infos and the auth infos themselves 
    // have already been validated.
    // 

    dwError = AllocateSPDMemory(
                  sizeof(INT_IPSEC_MM_AUTH_INFO) * dwInNumAuthInfos,
                  &(pAuthenticationInfo)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pAuthenticationInfo;
    pInTemp = pInAuthenticationInfo;

    for (i = 0; i < dwInNumAuthInfos; i++) {

        pTemp->AuthMethod = pInTemp->AuthMethod;
        pTemp->dwAuthFlags = pInTemp->dwAuthFlags;

        if (pInTemp->AuthMethod == IKE_SSPI) {

            pTemp->dwAuthInfoSize = 0;
            pTemp->pAuthInfo = NULL;

        }
        else {

            if (!(pInTemp->dwAuthInfoSize) || !(pInTemp->pAuthInfo)) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
            }

            dwError = AllocateSPDMemory(
                          pInTemp->dwAuthInfoSize,
                          &(pTemp->pAuthInfo)
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            pTemp->dwAuthInfoSize = pInTemp->dwAuthInfoSize;

            //
            // Need to catch the exception when the size of auth info
            // specified is more than the actual size. This can
            // not be checked earlier in the validation routine.
            //
            //

            memcpy(
                pTemp->pAuthInfo,
                pInTemp->pAuthInfo,
                pInTemp->dwAuthInfoSize
                );

        }

        pInTemp++;
        pTemp++;

    }

    *pdwNumAuthInfos = dwInNumAuthInfos;
    *ppAuthenticationInfo = pAuthenticationInfo;
    return (dwError);

error:
    TRACE(TRC_ERROR, ("Failed to create MM auth infos node: %!winerr!", dwError));    
    
    if (pAuthenticationInfo) {
        FreeIniMMAuthInfos(
            i,
            pAuthenticationInfo
            );
    }

    *pdwNumAuthInfos = 0;
    *ppAuthenticationInfo = NULL;
    return (dwError);
}


VOID
FreeIniMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods
    )
{
    if (pIniMMAuthMethods) {

        FreeIniMMAuthInfos(
            pIniMMAuthMethods->dwNumAuthInfos,
            pIniMMAuthMethods->pAuthenticationInfo
            );

        FreeSPDMemory(pIniMMAuthMethods);

    }
}


VOID
FreeIniMMAuthInfos(
    DWORD dwNumAuthInfos,
    PINT_IPSEC_MM_AUTH_INFO pAuthenticationInfo
    )
{
    DWORD i = 0;
    PINT_IPSEC_MM_AUTH_INFO pTemp = NULL;


    if (pAuthenticationInfo) {

        pTemp = pAuthenticationInfo;

        for (i = 0; i < dwNumAuthInfos; i++) {
            if (pTemp->pAuthInfo) {
                FreeSPDMemory(pTemp->pAuthInfo);
            }
            pTemp++;
        }

        FreeSPDMemory(pAuthenticationInfo);

    }
}


DWORD
WINAPI
DeleteMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwVersion,
    GUID gMMAuthID,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function deletes main mode auth methods from the SPD.

Arguments:

    pServerName - Server on which the main mode auth methods
                  are to be deleted.

    gMMAuthID - Main mode methods to be deleted.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMAUTHMETHODS pIniMMAuthMethods = NULL;


    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMAuthMethods = FindMMAuthMethods(
                            gpIniMMAuthMethods,
                            gMMAuthID
                            );
    if (!pIniMMAuthMethods) {
        dwError = ERROR_IPSEC_MM_AUTH_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniMMAuthMethods->cRef) {
        dwError = ERROR_IPSEC_MM_AUTH_IN_USE;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = DeleteIniMMAuthMethods(
                  pIniMMAuthMethods
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    LEAVE_SPD_SECTION();

    if (gbIKENotify) {
        (VOID) IKENotifyPolicyChange(
                   &(gMMAuthID),
                   POLICY_GUID_AUTH
                   );
    }

    TRACE(
        TRC_INFORMATION,
        (L"Deleted MM auth methods %!guid!",
        &gMMAuthID)
        );
    
    return (dwError);

lock:
    TRACE(
        TRC_ERROR,
        (L"Failed to delete MM auth methods %!guid!: %!winerr!",
        &gMMAuthID,
        dwError)
        );

    LEAVE_SPD_SECTION();

    return (dwError);
}


DWORD
DeleteIniMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods
    )
{
    DWORD dwError = 0;
    PINIMMAUTHMETHODS * ppTemp = NULL;


    ppTemp = &gpIniMMAuthMethods;

    while (*ppTemp) {

        if (*ppTemp == pIniMMAuthMethods) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);

    }

    if (*ppTemp) {
        *ppTemp = pIniMMAuthMethods->pNext;
    }

    if ((pIniMMAuthMethods->dwFlags) & IPSEC_MM_AUTH_DEFAULT_AUTH) {
        gpIniDefaultMMAuthMethods = NULL;
        TRACE(
            TRC_INFORMATION,
            (L"Cleared default MM auth methods")
            );
    }

    FreeIniMMAuthMethods(pIniMMAuthMethods);

    return (dwError);
}


DWORD
WINAPI
IntEnumMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwVersion,
    PINT_MM_AUTH_METHODS pMMTemplateAuthMethods,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PINT_MM_AUTH_METHODS * ppMMAuthMethods,
    LPDWORD pdwNumAuthMethods,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function enumerates main mode auth methods from the SPD.

Arguments:

    pServerName - Server on which the main mode auth methods are to
                  be enumerated.

    ppMMAuthMethods - Enumerated main mode auth methods returned to
                      the caller.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    pdwNumAuthMethods - Number of main mode auth methods actually
                        enumerated.

    pdwResumeHandle - Handle to the location in the main mode auth
                      methods list from which to resume enumeration.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwResumeHandle = 0;
    DWORD dwNumToEnum = 0;
    PINIMMAUTHMETHODS pIniMMAuthMethods = NULL;
    DWORD i = 0;
    PINIMMAUTHMETHODS pTemp = NULL;
    DWORD dwNumAuthMethods = 0;
    PINT_MM_AUTH_METHODS pMMAuthMethods = NULL;
    PINT_MM_AUTH_METHODS pTempMMAuthMethods = NULL;


    dwResumeHandle = *pdwResumeHandle;

    if (!dwPreferredNumEntries || (dwPreferredNumEntries > MAX_MMAUTH_ENUM_COUNT)) {
        dwNumToEnum = MAX_MMAUTH_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMAuthMethods = gpIniMMAuthMethods;

    for (i = 0; (i < dwResumeHandle) && (pIniMMAuthMethods != NULL); i++) {
        pIniMMAuthMethods = pIniMMAuthMethods->pNext;
    }

    if (!pIniMMAuthMethods) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    pTemp = pIniMMAuthMethods;

    while (pTemp && (dwNumAuthMethods < dwNumToEnum)) {
        dwNumAuthMethods++;
        pTemp = pTemp->pNext;
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(INT_MM_AUTH_METHODS)*dwNumAuthMethods,
                  &pMMAuthMethods
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pTemp = pIniMMAuthMethods;
    pTempMMAuthMethods = pMMAuthMethods;

    for (i = 0; i < dwNumAuthMethods; i++) {

        dwError = CopyMMAuthMethods(
                      pTemp,
                      pTempMMAuthMethods
                      );
        BAIL_ON_LOCK_ERROR(dwError);

        pTemp = pTemp->pNext;
        pTempMMAuthMethods++;

    }

    *ppMMAuthMethods = pMMAuthMethods;
    *pdwResumeHandle = dwResumeHandle + dwNumAuthMethods;
    *pdwNumAuthMethods = dwNumAuthMethods;

    LEAVE_SPD_SECTION();

    TRACE(TRC_INFORMATION, (L"Enumerated MM auth methods"));    
    return (dwError);

lock:
    TRACE(TRC_ERROR, (L"Failed to enumerate MM auth methods: %!winerr!", dwError));

    LEAVE_SPD_SECTION();

    if (pMMAuthMethods) {
        FreeMMAuthMethods(
            i,
            pMMAuthMethods
            );
    }

    *ppMMAuthMethods = NULL;
    *pdwResumeHandle = dwResumeHandle;
    *pdwNumAuthMethods = 0;

    return (dwError);
}


DWORD
WINAPI
IntSetMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwVersion,
    GUID gMMAuthID,
    PINT_MM_AUTH_METHODS pMMAuthMethods,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function updates main mode auth methods in the SPD.

Arguments:

    pServerName - Server on which the main mode auth methods are to
                  be updated.

    gMMAuthID - Guid of the main mode auth methods to be updated.

    pMMAuthMethods - New main mode auth methods which will replace
                     the existing methods.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMAUTHMETHODS pIniMMAuthMethods = NULL;

    
    //
    // Validate main mode auth methods.
    //

    dwError = IntValidateMMAuthMethods(
                  pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMAuthMethods = FindMMAuthMethods(
                            gpIniMMAuthMethods,
                            gMMAuthID
                            );
    if (!pIniMMAuthMethods) {
        dwError = ERROR_IPSEC_MM_AUTH_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (memcmp(
            &(pIniMMAuthMethods->gMMAuthID),
            &(pMMAuthMethods->gMMAuthID),
            sizeof(GUID))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = SetIniMMAuthMethods(
                  pIniMMAuthMethods,
                  pMMAuthMethods
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    LEAVE_SPD_SECTION();

    (VOID) IKENotifyPolicyChange(
               &(pMMAuthMethods->gMMAuthID),
               POLICY_GUID_AUTH
               );

    TRACE(
        TRC_INFORMATION,
        (L"Changed MM auth methods %!guid!",
        &pMMAuthMethods->gMMAuthID)
        );
    
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:
    TRACE(
        TRC_ERROR,
        (L"Failed to change MM auth method %!guid!: %!winerr!",
        &gMMAuthID,
        dwError)
        );

    return (dwError);
}


DWORD
SetIniMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINT_MM_AUTH_METHODS pMMAuthMethods
    )
{
    DWORD dwError = 0;
    DWORD dwNumAuthInfos = 0;
    PINT_IPSEC_MM_AUTH_INFO pAuthenticationInfo = NULL;


    dwError = CreateIniMMAuthInfos(
                  pMMAuthMethods->dwNumAuthInfos,
                  pMMAuthMethods->pAuthenticationInfo,
                  &dwNumAuthInfos,
                  &pAuthenticationInfo
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    FreeIniMMAuthInfos(
        pIniMMAuthMethods->dwNumAuthInfos,
        pIniMMAuthMethods->pAuthenticationInfo
        );
    
    if ((pIniMMAuthMethods->dwFlags) & IPSEC_MM_AUTH_DEFAULT_AUTH) {
        gpIniDefaultMMAuthMethods = NULL;
        TRACE(TRC_INFORMATION, (L"Cleared default MM auth methods"));
    }

    pIniMMAuthMethods->dwFlags = pMMAuthMethods->dwFlags;
    pIniMMAuthMethods->dwNumAuthInfos = dwNumAuthInfos;
    pIniMMAuthMethods->pAuthenticationInfo = pAuthenticationInfo;

    if ((pIniMMAuthMethods->dwFlags) & IPSEC_MM_AUTH_DEFAULT_AUTH) {
        gpIniDefaultMMAuthMethods = pIniMMAuthMethods;
        TRACE(
            TRC_INFORMATION,
            (L"Set default MM auth methods to %!guid!",
            &pIniMMAuthMethods->gMMAuthID)
            );
    }

error:

    return (dwError);
}


DWORD
WINAPI
IntGetMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwVersion,
    GUID gMMAuthID,
    PINT_MM_AUTH_METHODS * ppMMAuthMethods,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function gets main mode auth methods from the SPD.

Arguments:

    pServerName - Server from which to get the main mode auth methods.

    gMMAuthID - Guid of the main mode auth methods to get.

    ppMMAuthMethods - Main mode auth methods found returned to the
                      caller.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMAUTHMETHODS pIniMMAuthMethods = NULL;
    PINT_MM_AUTH_METHODS pMMAuthMethods = NULL;


    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMAuthMethods = FindMMAuthMethods(
                            gpIniMMAuthMethods,
                            gMMAuthID
                            );
    if (!pIniMMAuthMethods) {
        dwError = ERROR_IPSEC_MM_AUTH_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = GetIniMMAuthMethods(
                  pIniMMAuthMethods,
                  &pMMAuthMethods
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    *ppMMAuthMethods = pMMAuthMethods;

    LEAVE_SPD_SECTION();
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    *ppMMAuthMethods = NULL;
    return (dwError);
}


DWORD
GetIniMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINT_MM_AUTH_METHODS * ppMMAuthMethods
    )
{
    DWORD dwError = 0;
    PINT_MM_AUTH_METHODS pMMAuthMethods = NULL;


    dwError = SPDApiBufferAllocate(
                  sizeof(INT_MM_AUTH_METHODS),
                  &pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyMMAuthMethods(
                  pIniMMAuthMethods,
                  pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppMMAuthMethods = pMMAuthMethods;
    return (dwError);

error:

    if (pMMAuthMethods) {
        SPDApiBufferFree(pMMAuthMethods);
    }

    *ppMMAuthMethods = NULL;
    return (dwError);
}


DWORD
CopyMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINT_MM_AUTH_METHODS pMMAuthMethods
    )
{
    DWORD dwError = 0;

    memcpy(
        &(pMMAuthMethods->gMMAuthID),
        &(pIniMMAuthMethods->gMMAuthID),
        sizeof(GUID)
        );

    pMMAuthMethods->dwFlags = pIniMMAuthMethods->dwFlags;

    dwError = CreateMMAuthInfos(
                  pIniMMAuthMethods->dwNumAuthInfos,
                  pIniMMAuthMethods->pAuthenticationInfo,
                  &(pMMAuthMethods->dwNumAuthInfos),
                  &(pMMAuthMethods->pAuthenticationInfo)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}


DWORD
CreateMMAuthInfos(
    DWORD dwInNumAuthInfos,
    PINT_IPSEC_MM_AUTH_INFO pInAuthenticationInfo,
    PDWORD pdwNumAuthInfos,
    PINT_IPSEC_MM_AUTH_INFO * ppAuthenticationInfo
    )
{
    DWORD dwError = 0;
    PINT_IPSEC_MM_AUTH_INFO pAuthenticationInfo = NULL;
    PINT_IPSEC_MM_AUTH_INFO pTemp = NULL;
    PINT_IPSEC_MM_AUTH_INFO pInTemp = NULL;
    DWORD i = 0;


    //
    // Number of auth infos and the auth infos themselves 
    // have already been validated.
    // 

    dwError = SPDApiBufferAllocate(
                  sizeof(INT_IPSEC_MM_AUTH_INFO) * dwInNumAuthInfos,
                  &(pAuthenticationInfo)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pAuthenticationInfo;
    pInTemp = pInAuthenticationInfo;

    for (i = 0; i < dwInNumAuthInfos; i++) {

        pTemp->AuthMethod = pInTemp->AuthMethod;
        pTemp->dwAuthFlags = pInTemp->dwAuthFlags;

        //
        // Auth info size and the auth info have already 
        // been validated.
        // 

        if (pInTemp->AuthMethod == IKE_SSPI) {

            pTemp->dwAuthInfoSize = 0;
            pTemp->pAuthInfo = NULL;

        }
        else {

            dwError = SPDApiBufferAllocate(
                          pInTemp->dwAuthInfoSize,
                          &(pTemp->pAuthInfo)
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            pTemp->dwAuthInfoSize = pInTemp->dwAuthInfoSize;

            //
            // Need to catch the exception when the size of auth info
            // specified is more than the actual size. This can
            // not be checked earlier in the validation routine.
            //
            //

            memcpy(
                pTemp->pAuthInfo,
                pInTemp->pAuthInfo,
                pInTemp->dwAuthInfoSize
                );

        }

        pInTemp++;
        pTemp++;

    }

    *pdwNumAuthInfos = dwInNumAuthInfos;
    *ppAuthenticationInfo = pAuthenticationInfo;
    return (dwError);

error:

    if (pAuthenticationInfo) {
        FreeMMAuthInfos(
            i,
            pAuthenticationInfo
            );
    }

    *pdwNumAuthInfos = 0;
    *ppAuthenticationInfo = NULL;
    return (dwError);
}


VOID
FreeMMAuthInfos(
    DWORD dwNumAuthInfos,
    PINT_IPSEC_MM_AUTH_INFO pAuthenticationInfo
    )
{
    DWORD i = 0;
    PINT_IPSEC_MM_AUTH_INFO pTemp = NULL;


    if (pAuthenticationInfo) {

        pTemp = pAuthenticationInfo;

        for (i = 0; i < dwNumAuthInfos; i++) {
            if (pTemp->pAuthInfo) {
                SPDApiBufferFree(pTemp->pAuthInfo);
            }
            pTemp++;
        }

        SPDApiBufferFree(pAuthenticationInfo);

    }
}


VOID
FreeIniMMAuthMethodsList(
    PINIMMAUTHMETHODS pIniMMAuthMethodsList
    )
{
    PINIMMAUTHMETHODS pTemp = NULL;
    PINIMMAUTHMETHODS pIniMMAuthMethods = NULL;


    pTemp = pIniMMAuthMethodsList;

    while (pTemp) {

         pIniMMAuthMethods = pTemp;
         pTemp = pTemp->pNext;

         FreeIniMMAuthMethods(pIniMMAuthMethods);

    }
}


VOID
FreeMMAuthMethods(
    DWORD dwNumAuthMethods,
    PINT_MM_AUTH_METHODS pMMAuthMethods
    )
{
    DWORD i = 0;

    if (pMMAuthMethods) {

        for (i = 0; i < dwNumAuthMethods; i++) {

            FreeMMAuthInfos(
                pMMAuthMethods[i].dwNumAuthInfos,
                pMMAuthMethods[i].pAuthenticationInfo
                );

        }

        SPDApiBufferFree(pMMAuthMethods);

    }
}


DWORD
LocateMMAuthMethods(
    PMM_FILTER pMMFilter,
    PINIMMAUTHMETHODS * ppIniMMAuthMethods
    )
{
    DWORD dwError = 0;
    PINIMMAUTHMETHODS pIniMMAuthMethods = NULL;


    if ((pMMFilter->dwFlags) & IPSEC_MM_AUTH_DEFAULT_AUTH) {

        if (!gpIniDefaultMMAuthMethods) {
            dwError = ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        pIniMMAuthMethods = gpIniDefaultMMAuthMethods;

    }
    else {

        pIniMMAuthMethods = FindMMAuthMethods(
                                gpIniMMAuthMethods,
                                pMMFilter->gMMAuthID
                                );
        if (!pIniMMAuthMethods) {
            dwError = ERROR_IPSEC_MM_AUTH_NOT_FOUND;
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }

    *ppIniMMAuthMethods = pIniMMAuthMethods;
    return (dwError);

error:

    *ppIniMMAuthMethods = NULL;
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\mmauth.h ===
typedef struct _iniMMauthmethods {
    GUID gMMAuthID;
    DWORD dwFlags;
    DWORD cRef;
    DWORD dwSource;
    DWORD dwNumAuthInfos;
    PINT_IPSEC_MM_AUTH_INFO pAuthenticationInfo;
    struct _iniMMauthmethods * pNext;
} INIMMAUTHMETHODS, * PINIMMAUTHMETHODS;


DWORD
IntValidateMMAuthMethods(
    PINT_MM_AUTH_METHODS pMMAuthMethods
    );

PINIMMAUTHMETHODS
FindMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    GUID gMMAuthID
    );

DWORD
CreateIniMMAuthMethods(
    PINT_MM_AUTH_METHODS pMMAuthMethods,
    PINIMMAUTHMETHODS * ppIniMMAuthMethods
    );

DWORD
CreateIniMMAuthInfos(
    DWORD dwInNumAuthInfos,
    PINT_IPSEC_MM_AUTH_INFO pInAuthenticationInfo,
    PDWORD pdwNumAuthInfos,
    PINT_IPSEC_MM_AUTH_INFO * ppAuthenticationInfo
    );

VOID
FreeIniMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods
    );

VOID
FreeIniMMAuthInfos(
    DWORD dwNumAuthInfos,
    PINT_IPSEC_MM_AUTH_INFO pAuthenticationInfo
    );

DWORD
DeleteIniMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods
    );

DWORD
SetIniMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINT_MM_AUTH_METHODS pMMAuthMethods
    );

DWORD
GetIniMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINT_MM_AUTH_METHODS * ppMMAuthMethods
    );

DWORD
CopyMMAuthMethods(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINT_MM_AUTH_METHODS pMMAuthMethods
    );

DWORD
CreateMMAuthInfos(
    DWORD dwInNumAuthInfos,
    PINT_IPSEC_MM_AUTH_INFO pInAuthenticationInfo,
    PDWORD pdwNumAuthInfos,
    PINT_IPSEC_MM_AUTH_INFO * ppAuthenticationInfo
    );


VOID
FreeMMAuthInfos(
    DWORD dwNumAuthInfos,
    PINT_IPSEC_MM_AUTH_INFO pAuthenticationInfo
    );

VOID
FreeIniMMAuthMethodsList(
    PINIMMAUTHMETHODS pIniMMAuthMethodsList
    );

VOID
FreeMMAuthMethods(
    DWORD dwNumAuthMethods,
    PINT_MM_AUTH_METHODS pMMAuthMethods
    );

DWORD
LocateMMAuthMethods(
    PMM_FILTER pMMFilter,
    PINIMMAUTHMETHODS * ppIniMMAuthMethods
    );

DWORD
IntAddMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    DWORD dwSource,
    PINT_MM_AUTH_METHODS pMMAuthMethods,
    LPVOID pvReserved
    );

DWORD
IntEnumMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwVersion,
    PINT_MM_AUTH_METHODS pMMTemplateAuthMethods,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PINT_MM_AUTH_METHODS * ppMMAuthMethods,
    LPDWORD pdwNumAuthMethods,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    );

DWORD
IntSetMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwVersion,
    GUID gMMAuthID,
    PINT_MM_AUTH_METHODS pMMAuthMethods,
    LPVOID pvReserved
    );
    
DWORD
IntGetMMAuthMethods(
    LPWSTR pServerName,
    DWORD dwVersion,
    GUID gMMAuthID,
    PINT_MM_AUTH_METHODS * ppMMAuthMethods,
    LPVOID pvReserved
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\mmfilter.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    mmfilter.h

Abstract:

    This module contains all of the code prototypes to
    drive the main mode filter list management of
    IPSecSPD Service.

Author:


Environment: User Mode


Revision History:


--*/


typedef struct _inimmfilter {
    IP_PROTOCOL_VERSION IpVersion;
    GUID gFilterID;
    LPWSTR pszFilterName;
    IF_TYPE InterfaceType;
    BOOL bCreateMirror;
    DWORD dwFlags;
    ADDR_V4 SrcAddr;
    ADDR_V4 DesAddr;
    DWORD cRef;
    DWORD dwSource;
    BOOL bPendingDeletion;
    GUID gMMAuthID;
    GUID gPolicyID;
    PINIMMAUTHMETHODS pIniMMAuthMethods;
    PINIMMPOLICY pIniMMPolicy;
    DWORD dwNumMMSFilters;
    struct _inimmsfilter ** ppIniMMSFilters;
    struct _inimmfilter * pNext;
} INIMMFILTER, * PINIMMFILTER;


typedef struct _inimmsfilter {
    IP_PROTOCOL_VERSION IpVersion;
    GUID gParentID;
    LPWSTR pszFilterName;
    IF_TYPE InterfaceType;
    DWORD dwFlags;
    ADDR_V4 SrcAddr;
    ADDR_V4 DesAddr;
    DWORD cRef;
    DWORD dwDirection;
    DWORD dwWeight;
    GUID gMMAuthID;
    GUID gPolicyID;
    PINIMMAUTHMETHODS pIniMMAuthMethods;
    PINIMMPOLICY pIniMMPolicy;
    struct _inimmsfilter * pNext;
} INIMMSFILTER, * PINIMMSFILTER;


typedef struct _mm_filter_handle {
    IP_PROTOCOL_VERSION IpVersion;
    PINIMMFILTER pIniMMFilter;
    GUID gFilterID;
    struct _mm_filter_handle * pNext;
} MM_FILTER_HANDLE, * PMM_FILTER_HANDLE;

DWORD
AddMMFilterInternal(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    DWORD dwSource,
    PMM_FILTER pMMFilter,
    LPVOID pvReserved,
    PHANDLE phMMFilter
    );

DWORD
ValidateMMFilter(
    PMM_FILTER pMMFilter
    );

PINIMMFILTER
FindMMFilterByGuid(
    PMM_FILTER_HANDLE pMMFilterHandleList,
    PINIMMFILTER pIniMMFilterList,
    GUID gFilterID
    );
  
PINIMMFILTER
IsConflictMMFilter(
    PINIMMFILTER pGenericMMList,
    PMM_FILTER pMMFilter
    );

DWORD
RefMMFilterHandle(
    PINIMMFILTER pIniMMFilter,
    GUID gFilterID,
    PMM_FILTER_HANDLE * ppMMFilterHandle
    );

BOOL
EqualMMFilterPKeys(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    );

DWORD
CreateIniMMFilter(
    PMM_FILTER pMMFilter,
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMPOLICY pIniMMPolicy,
    PINIMMFILTER * ppIniMMFilter
    );

DWORD
CreateIniMMSFilters(
    PINIMMFILTER pIniMMFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PSPECIAL_ADDR pSpecialAddrsList,
    PINIMMSFILTER * ppIniMMSFilters
    );

DWORD
CreateIniMirroredMMFilter(
    PINIMMFILTER pFilter,
    PINIMMFILTER * ppMirroredFilter
    );

BOOL
EqualIniMMFilterPKeys(
    PINIMMFILTER pIniMMFilter,
    PINIMMFILTER pFilter
    );

DWORD
CreateMMFilterHandle(
    PINIMMFILTER pIniMMFilter,
    GUID gFilterID,
    PMM_FILTER_HANDLE * ppMMFilterHandle
    );

DWORD
CreateSpecificMMFilterLinks(
    PINIMMFILTER pIniMMFilter,
    PINIMMSFILTER pIniMMSFilters
    );

VOID
LinkMMFilterToPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PINIMMFILTER pIniMMFilter
    );

VOID
LinkMMFilterToAuth(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMFILTER pIniMMFilter
    );

VOID
FreeIniMMFilterList(
    PINIMMFILTER pIniMMFilterList
    );

VOID
FreeIniMMFilter(
    PINIMMFILTER pIniMMFilter
    );

DWORD
DeleteIniMMFilter(
    PINIMMFILTER   pIniMMFilter
    );

VOID
DelinkMMFilterFromPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PINIMMFILTER pIniMMFilter
    );

VOID
DelinkMMFilterFromAuth(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMFILTER pIniMMFilter
    );

VOID
DeleteIniMMSFilters(
    PINIMMFILTER pIniMMFilter
    );

VOID
RemoveIniMMFilter(
    PINIMMFILTER pIniMMFilter
    );

VOID
RemoveMMFilterHandle(
    PMM_FILTER_HANDLE pMMFilterHandle
    );

VOID
FreeMMFilterHandleList(
    PMM_FILTER_HANDLE pMMFilterHandleList
    );

VOID
FreeMMFilterHandle(
    PMM_FILTER_HANDLE pMMFilterHandle
    );

DWORD
EnumGenericMMFilters(
    PINIMMFILTER pIniMMFilterList,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PMM_FILTER * ppMMFilters,
    PDWORD pdwNumMMFilters
    );

DWORD
CopyMMFilter(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    );

VOID
FreeMMFilters(
    DWORD dwNumMMFilters,
    PMM_FILTER pMMFilters
    );

DWORD
SetIniMMFilter(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    );

BOOL
EqualMMFilterNonPKeys(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    );

DWORD
CreateMMSFilterLinks(
    PINIMMSFILTER pIniMMSFilters,
    PDWORD pdwNumMMSFilters,
    PINIMMSFILTER ** pppIniMMSFilters
    );

VOID
RemoveMMSFilters(
    PINIMMFILTER pIniMMFilter,
    PINIMMSFILTER * ppIniCurMMSFilters 
    );

VOID
UpdateMMSFilterLinks(
    PINIMMFILTER pIniMMFilter,
    DWORD dwNumMMSFilters,
    PINIMMSFILTER * ppIniMMSFilters
    );

VOID
UpdateMMFilterNonPKeys(
    PINIMMFILTER pIniMMFilter,
    LPWSTR pszFilterName,
    PMM_FILTER pMMFilter,
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMPOLICY pIniMMPolicy
    );

DWORD
GetIniMMFilter(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER * ppMMFilter
    );

DWORD
ApplyIfChangeToIniMMFilters(
    PDWORD pdwMMError,
    PIPSEC_INTERFACE pLatestIfList,
    PSPECIAL_ADDR    pLatestSpecialAddrsList    
    );

DWORD
UpdateIniMMFilterThruIfChange(
    PINIMMFILTER pIniMMFilter,
    PIPSEC_INTERFACE pLatestIfList,
    PSPECIAL_ADDR pLatestSpecialAddrsList
    );

DWORD
FormIniMMSFilters(
    PINIMMFILTER pIniMMFilter,
    PIPSEC_INTERFACE pIfList,
    PSPECIAL_ADDR    pLatestSpecialAddrsList,    
    PINIMMSFILTER * ppIniMMSFilters
    );

VOID
ProcessIniMMSFilters(
    PINIMMSFILTER * ppLatestIniMMSFilters,
    PINIMMSFILTER * ppCurIniMMSFilters,
    PINIMMSFILTER * ppNewIniMMSFilters,
    PINIMMSFILTER * ppOldIniMMSFilters
    );

BOOL
EqualIniMMSFilterIfPKeys(
    PINIMMSFILTER pExsIniMMSFilter,
    PINIMMSFILTER pNewIniMMSFilter
    );

DWORD
AllocateMMSFilterLinks(
    PINIMMSFILTER pIniMMSFilters,
    PDWORD pdwNumMMSFilters,
    PINIMMSFILTER ** pppIniMMSFilters
    );

VOID
SetMMSFilterLinks(
    PINIMMSFILTER pCurIniMMSFilters,
    PINIMMSFILTER pNewIniMMSFilters,
    DWORD dwNumMMSFilters,
    PINIMMSFILTER * ppIniMMSFilters
    );

PINIMMFILTER
FindExactMMFilter(
    PINIMMFILTER pGenericMMList,
    PMM_FILTER pMMFilter
    );

BOOL
IsConflictMirroredMMFilterPKeys(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    );

BOOL
IsConflictMMFilterPKeys(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\mmfilter.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    mmfilter.c

Abstract:

    This module contains all of the code to drive
    the main mode filter list management of IPSecSPD
    Service.

Author:


Environment: User Mode


Revision History:


--*/


#include "precomp.h"
#ifdef TRACE_ON
#include "mmfilter.tmh"
#endif


DWORD
AddMMFilterInternal(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    DWORD dwSource,
    PMM_FILTER pMMFilter,
    LPVOID pvReserved,
    PHANDLE phMMFilter
    )
/*++

Routine Description:

    This function adds a generic MM filter to the SPD.

Arguments:

    pServerName - Server on which the MM filter is to be added.

    pMMFilter - MM Filter to be added.

    phMMFilter -  Handle to the filter returned to the caller.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMFILTER pIniExistsMMFilter = NULL;
    PINIMMFILTER pIniMMFilter = NULL;
    PINIMMAUTHMETHODS pIniMMAuthMethods = NULL;
    PINIMMPOLICY pIniMMPolicy = NULL;
    PINIMMSFILTER pIniMMSFilters = NULL;
    PMM_FILTER_HANDLE pMMFilterHandle = NULL;
    MATCHING_ADDR * pMatchingAddresses = NULL;
    DWORD dwAddrCnt = 0;
    BOOL bOpenIfExists = FALSE;

    bOpenIfExists = (BOOL) (dwFlags & OPEN_IF_EXISTS);

    if (!phMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Validate the external MM filter.
    //

    dwError = ValidateMMFilter(
                  pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateMMSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniExistsMMFilter = IsConflictMMFilter(
                             gpIniMMFilter,
                             pMMFilter
                             );
    if (pIniExistsMMFilter)
    {
        if (bOpenIfExists) 
        {
            dwError = RefMMFilterHandle(
                          pIniExistsMMFilter,
                          pMMFilter->gFilterID,
                          &pMMFilterHandle
                          );
            BAIL_ON_LOCK_ERROR(dwError);
            dwError = ERROR_IPSEC_MM_FILTER_EXISTS;
            BAIL_LOCK_SUCCESS;
        } 
        else 
        {
            dwError = ERROR_IPSEC_MM_FILTER_EXISTS;        
            BAIL_ON_LOCK_ERROR(dwError);
        }            
    }

    pIniExistsMMFilter = FindMMFilterByGuid(
                             gpMMFilterHandle,
                             gpIniMMFilter,
                             pMMFilter->gFilterID
                             );
    if (pIniExistsMMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = LocateMMAuthMethods(
                  pMMFilter,
                  &pIniMMAuthMethods
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = LocateMMPolicy(
                  pMMFilter,
                  &pIniMMPolicy
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = CreateIniMMFilter(
                  pMMFilter,
                  pIniMMAuthMethods,
                  pIniMMPolicy,
                  &pIniMMFilter
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMFilter->dwSource = dwSource;

    dwError = GetMatchingInterfaces(
                  pIniMMFilter->InterfaceType,
                  gpInterfaceList,
                  &pMatchingAddresses,
                  &dwAddrCnt
                  );
    BAIL_ON_LOCK_ERROR(dwError);
               
    dwError = CreateIniMMSFilters(
                  pIniMMFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  gpSpecialAddrsList,
                  &pIniMMSFilters
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = CreateMMFilterHandle(
                  pIniMMFilter,
                  pMMFilter->gFilterID,
                  &pMMFilterHandle
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = CreateSpecificMMFilterLinks(
                  pIniMMFilter,
                  pIniMMSFilters
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    if (pIniMMAuthMethods) {
        LinkMMFilterToAuth(
            pIniMMAuthMethods,
            pIniMMFilter
            );
        LinkMMSpecificFiltersToAuth(
            pIniMMAuthMethods,
            pIniMMSFilters
            );
    }

    if (pIniMMPolicy) {
        LinkMMFilterToPolicy(
            pIniMMPolicy,
            pIniMMFilter
            );
        LinkMMSpecificFiltersToPolicy(
            pIniMMPolicy,
            pIniMMSFilters
            );
    }

    AddToSpecificMMList(
        &gpIniMMSFilter,
        pIniMMSFilters
        );

    pIniMMFilter->cRef = 1;
    pIniMMFilter->pNext = gpIniMMFilter;
    gpIniMMFilter = pIniMMFilter;

    pMMFilterHandle->pNext = gpMMFilterHandle;
    gpMMFilterHandle = pMMFilterHandle;

lock_success:
    *phMMFilter = (HANDLE) pMMFilterHandle;
    
    LEAVE_SPD_SECTION();

    TRACE(
        TRC_INFORMATION,
        (L"Added MM filter %ls (%!guid!)",
        pMMFilter->pszFilterName,
        &pMMFilter->gFilterID)
        );
    
cleanup:

    if (pMatchingAddresses) {
        FreeSPDMemory(pMatchingAddresses);
    }

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:
#ifdef TRACE_ON
    if (dwError != ERROR_IPSEC_MM_FILTER_EXISTS) {
        if (pMMFilter) {
            TRACE(
                TRC_ERROR,
                (L"Failed to add MM filter \"%ls\"(%!guid!): %!winerr!",
                pMMFilter->pszFilterName,
                &pMMFilter->gPolicyID,
                dwError)
                );
        } else {
            TRACE(
                TRC_ERROR,
                (L"Failed to add MM filter.  Details unvailable since pMMFilter is null: %!winerr!",
                dwError)
                );
        }
    } else {
        if (pMMFilter) {
            TRACE(
                TRC_WARNING,
                (L"Failed to add MM filter \"%ls\" (%!guid!) since it already exists.",
                pMMFilter->pszFilterName,
                &pMMFilter->gPolicyID)
                );
        }
    }
#endif

    if (pIniMMFilter) {
        FreeIniMMFilter(pIniMMFilter);
    }

    if (pIniMMSFilters) {
        FreeIniMMSFilterList(pIniMMSFilters);
    }

    if (pMMFilterHandle) {
        FreeMMFilterHandle(pMMFilterHandle);
    }

    *phMMFilter = NULL;
    goto cleanup;
}

DWORD
AddMMFilter(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PMM_FILTER pMMFilter,
    LPVOID pvReserved,
    PHANDLE phMMFilter
    )
{
    return 
        AddMMFilterInternal(
            pServerName,
            dwVersion,
            dwFlags,
            IPSEC_SOURCE_WINIPSEC,
            pMMFilter,
            pvReserved,
            phMMFilter);
}


DWORD
ValidateMMFilter(
    PMM_FILTER pMMFilter
    )
/*++

Routine Description:

    This function validates an external generic MM filter.

Arguments:

    pMMFilter - Filter to validate.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pMMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(&(pMMFilter->SrcAddr), TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(&(pMMFilter->DesAddr), TRUE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = AddressesConflict(
                     pMMFilter->SrcAddr,
                     pMMFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMFilter->pszFilterName) || !(*(pMMFilter->pszFilterName))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pMMFilter->InterfaceType >= INTERFACE_TYPE_MAX) { 
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pMMFilter->dwFlags &&
        !(pMMFilter->dwFlags & IPSEC_MM_POLICY_DEFAULT_POLICY) &&
        !(pMMFilter->dwFlags & IPSEC_MM_AUTH_DEFAULT_AUTH)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ApplyMulticastFilterValidation(
                  pMMFilter->DesAddr,
                  pMMFilter->bCreateMirror
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:
#ifdef TRACE_ON
    if (dwError) {
        if (pMMFilter) {
            TRACE(
                TRC_ERROR,
                (L"Failed MM filter validation \"%ls\"(%!guid!): %!winerr!",
                pMMFilter->pszFilterName,
                &pMMFilter->gPolicyID,
                dwError)
                );
        } else {
            TRACE(
                TRC_ERROR,
                (L"Failed to MM filter validation.  Details unvailable since pMMFilter is null: %!winerr!",
                dwError)
                );
        }
    }
#endif
    return (dwError);
}


PINIMMFILTER
FindMMFilterByGuid(
    PMM_FILTER_HANDLE pMMFilterHandleList,
    PINIMMFILTER pIniMMFilterList,
    GUID gFilterID
    )
{
    BOOL bEqual = FALSE;
    PMM_FILTER_HANDLE pMMFilterHandle = NULL;
    PINIMMFILTER pIniMMFilter = NULL;


    pMMFilterHandle = pMMFilterHandleList;

    while (pMMFilterHandle) {

        bEqual = AreGuidsEqual(
                     pMMFilterHandle->gFilterID,
                     gFilterID
                     );
        if (bEqual) {
            return (pMMFilterHandle->pIniMMFilter);
        }
        pMMFilterHandle = pMMFilterHandle->pNext;

    }

    //
    // It could happen that the client closed its handle, so walking through
    // the handle list is not enough. Walk through the filter list as well.
    // Walking through the handle list is necessary and must be done before
    // walking through the filter list.
    //

    pIniMMFilter = pIniMMFilterList;

    while (pIniMMFilter) {

        bEqual = AreGuidsEqual(
                     pIniMMFilter->gFilterID,
                     gFilterID
                     );
        if (bEqual) {
            return (pIniMMFilter);
        }
        pIniMMFilter = pIniMMFilter->pNext;

    }

    return (NULL);
}


PINIMMFILTER
IsConflictMMFilter(
    PINIMMFILTER pGenericMMList,
    PMM_FILTER pMMFilter
    )
/*++

Routine Description:

    This function looks for a filter in the filter list.

Arguments:

    pGenericMMList - Filter list in which to search.

    pMMFilter - Filter to search for in the filter list.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    PINIMMFILTER pIniMMFilter = NULL;
    BOOL bEqual = FALSE;

    pIniMMFilter = pGenericMMList;

    while (pIniMMFilter) {

        bEqual = IsConflictMMFilterPKeys(
                     pIniMMFilter,
                     pMMFilter
                     );
        if (bEqual) {
            return (pIniMMFilter);
        }

        bEqual = IsConflictMirroredMMFilterPKeys(
                     pIniMMFilter,
                     pMMFilter
                     );
        if (bEqual) {
            return (pIniMMFilter);
        }

        pIniMMFilter = pIniMMFilter->pNext;

    }

    return (NULL);
}


BOOL
EqualMMFilterPKeys(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    )
/*++

Routine Description:

    This function compares an internal and an external main mode
    filter for equality.

Arguments:

    pIniMMFilter - Filter to compare.

    pMMFilter - Filter to compare.

Return Value:

    TRUE - Filters are equal.

    FALSE - Filters are different.

--*/
{
    BOOL  bCmp = FALSE;


    bCmp = EqualExtIntAddresses(pIniMMFilter->SrcAddr, pMMFilter->SrcAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualExtIntAddresses(pIniMMFilter->DesAddr, pMMFilter->DesAddr);
    if (!bCmp) {
        return (FALSE);
    }

    if (pIniMMFilter->InterfaceType != pMMFilter->InterfaceType) {
        return (FALSE);
    }

    if (pIniMMFilter->bCreateMirror != pMMFilter->bCreateMirror) {
        return (FALSE);
    }

    return (TRUE);
}

BOOL
IsConflictMMFilterPKeys(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    )
/*++

Routine Description:

    This function compares an internal and an external main mode
    and determines if they'd conflict.

Arguments:

    pIniMMFilter - Filter to compare.

    pMMFilter - Filter to compare.

Return Value:

    TRUE - Filters are equal.

    FALSE - Filters are different.

--*/
{
    BOOL  bCmp = FALSE;


    bCmp = EqualExtIntAddresses(pIniMMFilter->SrcAddr, pMMFilter->SrcAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualExtIntAddresses(pIniMMFilter->DesAddr, pMMFilter->DesAddr);
    if (!bCmp) {
        return (FALSE);
    }

    if ((pIniMMFilter->InterfaceType != INTERFACE_TYPE_ALL) &&
        (pMMFilter->InterfaceType != INTERFACE_TYPE_ALL) &&
        (pIniMMFilter->InterfaceType != pMMFilter->InterfaceType)) {
        return (FALSE);
    }

    // Not checking mirror value, since it's not relevant.
    // A <-> B (mirrored) conflicts with itself and A -> B.
    // B->A conflicts, but will be checked by IsConflictMirroredMMFilterPKeys.
    
    return (TRUE);
}


DWORD
CreateIniMMFilter(
    PMM_FILTER pMMFilter,
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMPOLICY pIniMMPolicy,
    PINIMMFILTER * ppIniMMFilter
    )
/*++

Routine Description:

    This function creates an internal generic MM filter from
    the external filter.

Arguments:

    pMMFilter - External generic MM filter.

    pIniMMAuthMethods - MM Auth Methods corresponding to the filter.

    pIniMMPolicy - MM Policy corresponding to the filter.

    ppIniMMFilter - Internal generic MM filter created from
                    the external filter.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMFILTER pIniMMFilter = NULL;


    dwError = AllocateSPDMemory(
                    sizeof(INIMMFILTER),
                    &pIniMMFilter
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIniMMFilter->cRef = 0;

    pIniMMFilter->dwSource = 0;

    pIniMMFilter->bPendingDeletion = FALSE;

    pIniMMFilter->IpVersion = pMMFilter->IpVersion;

    CopyGuid(pMMFilter->gFilterID, &(pIniMMFilter->gFilterID));

    dwError = AllocateSPDString(
                  pMMFilter->pszFilterName,
                  &(pIniMMFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pIniMMFilter->InterfaceType = pMMFilter->InterfaceType;

    pIniMMFilter->bCreateMirror = pMMFilter->bCreateMirror;

    pIniMMFilter->dwFlags = pMMFilter->dwFlags;

    CopyExtToIntAddresses(pMMFilter->SrcAddr, &(pIniMMFilter->SrcAddr));

    CopyExtToIntAddresses(pMMFilter->DesAddr, &(pIniMMFilter->DesAddr));

    if (pIniMMAuthMethods) {
        CopyGuid(pIniMMAuthMethods->gMMAuthID, &(pIniMMFilter->gMMAuthID));
    }
    else {
        CopyGuid(pMMFilter->gMMAuthID, &(pIniMMFilter->gMMAuthID));
    }

    if (pIniMMPolicy) {
        CopyGuid(pIniMMPolicy->gPolicyID, &(pIniMMFilter->gPolicyID));
    }
    else {
        CopyGuid(pMMFilter->gPolicyID, &(pIniMMFilter->gPolicyID));
    }

    pIniMMFilter->pIniMMAuthMethods = NULL;

    pIniMMFilter->pIniMMPolicy = NULL;

    pIniMMFilter->dwNumMMSFilters = 0;

    pIniMMFilter->ppIniMMSFilters = NULL;

    pIniMMFilter->pNext = NULL;

    *ppIniMMFilter = pIniMMFilter;
    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        (L"Failed to create generic MM filter node \"%ls\" (%!guid!): %!winerr!",
        pMMFilter->pszFilterName,
        &pMMFilter->gPolicyID,
        dwError)
        );

    if (pIniMMFilter) {
        FreeIniMMFilter(pIniMMFilter);
    }

    *ppIniMMFilter = NULL;
    return (dwError);
}


DWORD
CreateIniMMSFilters(
    PINIMMFILTER pIniMMFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PSPECIAL_ADDR pSpecialAddrsList,
    PINIMMSFILTER * ppIniMMSFilters
    )
/*++

Routine Description:

    This function expands a generic filter into a set of specific
    filters.

Arguments:

    pIniMMFilter - Generic filter to expand.

    pMatchingAddresses - List of local ip addresses whose interface
                         type matches that of the filter.

    dwAddrCnt - Count of local ip addresses in the list.

    ppIniMMSFilters - Expanded specific filters.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMSFILTER pSpecificFilters = NULL;
    PINIMMFILTER pMirroredFilter = NULL;
    PINIMMSFILTER pMirroredSpecificFilters = NULL;
    BOOL bEqual = FALSE;


    if (!dwAddrCnt) {
        dwError = ERROR_SUCCESS;
        BAIL_ON_WIN32_SUCCESS(dwError);
    }

    dwError = ApplyMMTransform(
                  pIniMMFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  pSpecialAddrsList,
                  &pSpecificFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIniMMFilter->bCreateMirror) {

        dwError = CreateIniMirroredMMFilter(
                      pIniMMFilter,
                      &pMirroredFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        bEqual = EqualIniMMFilterPKeys(
                     pIniMMFilter,
                     pMirroredFilter
                     );
        if (!bEqual) {

            dwError = ApplyMMTransform(
                          pMirroredFilter,
                          pMatchingAddresses,
                          dwAddrCnt,
                          pSpecialAddrsList,
                          &pMirroredSpecificFilters
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            AddToSpecificMMList(
                &pSpecificFilters,
                pMirroredSpecificFilters
                );

        }

    }

    *ppIniMMSFilters = pSpecificFilters;

    TRACE(
        TRC_INFORMATION,
        (L"Successfully generated specific MM filters from \"%ls\" (%!guid!)",
        pIniMMFilter->pszFilterName,
        &pIniMMFilter->gFilterID)
        );
cleanup:

    if (pMirroredFilter) {
        FreeIniMMFilter(pMirroredFilter);
    }

    return (dwError);

success:
error:
#ifdef TRACE_ON
    if (dwError) {
        TRACE(
            TRC_ERROR,
            ("Failed to generate specific MM filters from \"%ls\" (%!guid!): %!winerr!",
            pIniMMFilter->pszFilterName,
            &pIniMMFilter->gFilterID,
            dwError)
            );
    }    
#endif

    if (pSpecificFilters) {
        FreeIniMMSFilterList(pSpecificFilters);
    }

    *ppIniMMSFilters = NULL;
    goto cleanup;
}


DWORD
CreateIniMirroredMMFilter(
    PINIMMFILTER pFilter,
    PINIMMFILTER * ppMirroredFilter
    )
/*++

Routine Description:

    This function creates a mirrored filter for the given filter.

Arguments:

    pFilter - Filter for which to create the mirror.

    ppMirroredFilter - Mirrored filter created for the given filter.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIMMFILTER pMirroredFilter = NULL;


    dwError = AllocateSPDMemory(
                  sizeof(INIMMFILTER),
                  &pMirroredFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMirroredFilter->cRef = pFilter->cRef;

    pMirroredFilter->dwSource = pFilter->dwSource;

    pMirroredFilter->bPendingDeletion = pFilter->bPendingDeletion;

    pMirroredFilter->IpVersion = pFilter->IpVersion;

    CopyGuid(pFilter->gFilterID, &(pMirroredFilter->gFilterID));

    dwError = AllocateSPDString(
                  pFilter->pszFilterName,
                  &(pMirroredFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMirroredFilter->InterfaceType = pFilter->InterfaceType;

    pMirroredFilter->bCreateMirror = pFilter->bCreateMirror;

    pMirroredFilter->dwFlags = pFilter->dwFlags;

    CopyAddresses(pFilter->DesAddr, &(pMirroredFilter->SrcAddr));

    CopyAddresses(pFilter->SrcAddr, &(pMirroredFilter->DesAddr));

    CopyGuid(pFilter->gMMAuthID, &(pMirroredFilter->gMMAuthID));

    CopyGuid(pFilter->gPolicyID, &(pMirroredFilter->gPolicyID));

    pMirroredFilter->pIniMMAuthMethods = NULL;

    pMirroredFilter->pIniMMPolicy = NULL;

    pMirroredFilter->dwNumMMSFilters = 0;

    pMirroredFilter->ppIniMMSFilters = NULL;

    pMirroredFilter->pNext = NULL;

    *ppMirroredFilter = pMirroredFilter;
    return (dwError);

error:

    if (pMirroredFilter) {
        FreeIniMMFilter(pMirroredFilter);
    }

    *ppMirroredFilter = NULL;
    return (dwError);
}


BOOL
EqualIniMMFilterPKeys(
    PINIMMFILTER pIniMMFilter,
    PINIMMFILTER pFilter
    )
{
    BOOL  bCmp = FALSE;


    bCmp = EqualAddresses(pIniMMFilter->SrcAddr, pFilter->SrcAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pIniMMFilter->DesAddr, pFilter->DesAddr);
    if (!bCmp) {
        return (FALSE);
    }

    if (pIniMMFilter->InterfaceType != pFilter->InterfaceType) {
        return (FALSE);
    }

    if (pIniMMFilter->bCreateMirror != pFilter->bCreateMirror) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
CreateMMFilterHandle(
    PINIMMFILTER pIniMMFilter,
    GUID gFilterID,
    PMM_FILTER_HANDLE * ppMMFilterHandle
    )
{
    DWORD dwError = 0;
    PMM_FILTER_HANDLE pMMFilterHandle = NULL;


    dwError = AllocateSPDMemory(
                    sizeof(MM_FILTER_HANDLE),
                    &pMMFilterHandle
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilterHandle->IpVersion = pIniMMFilter->IpVersion;
    pMMFilterHandle->pIniMMFilter= pIniMMFilter;
    CopyGuid(gFilterID, &(pMMFilterHandle->gFilterID));
    pMMFilterHandle->pNext = NULL;

    *ppMMFilterHandle = pMMFilterHandle;
    return (dwError);

error:

    *ppMMFilterHandle = NULL;
    return (dwError);
}


DWORD
CreateSpecificMMFilterLinks(
    PINIMMFILTER pIniMMFilter,
    PINIMMSFILTER pIniMMSFilters
    )
{
    DWORD dwError = 0;
    PINIMMSFILTER pTemp = NULL;
    DWORD dwCnt = 0;
    PINIMMSFILTER * ppIniMMSFilters = NULL;
    DWORD i = 0;


    pTemp = pIniMMSFilters;

    while (pTemp) {
        dwCnt++;
        pTemp = pTemp->pNext;
    }

    if (!dwCnt) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pIniMMFilter->ppIniMMSFilters = (PINIMMSFILTER *)
                                    AllocSPDMem(
                                        sizeof(PINIMMSFILTER)*dwCnt
                                        );
    if (!(pIniMMFilter->ppIniMMSFilters)) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);    
    }

    pTemp = pIniMMSFilters;
    ppIniMMSFilters = pIniMMFilter->ppIniMMSFilters;

    for (i = 0; i < dwCnt; i++) {
        *(ppIniMMSFilters + i) = pTemp; 
        pTemp = pTemp->pNext;
    }
    pIniMMFilter->dwNumMMSFilters = dwCnt;

error:

    return (dwError);
}


VOID
LinkMMFilterToPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PINIMMFILTER pIniMMFilter
    )
{
    pIniMMPolicy->cRef++;
    pIniMMFilter->pIniMMPolicy = pIniMMPolicy;
    return;
}


VOID
LinkMMFilterToAuth(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMFILTER pIniMMFilter
    )
{
    pIniMMAuthMethods->cRef++;
    pIniMMFilter->pIniMMAuthMethods = pIniMMAuthMethods;
    return;
}


VOID
FreeIniMMFilterList(
    PINIMMFILTER pIniMMFilterList
    )
{
    PINIMMFILTER pFilter = NULL;
    PINIMMFILTER pTempFilter = NULL;

    pFilter = pIniMMFilterList;

    while (pFilter) {
        pTempFilter = pFilter;
        pFilter = pFilter->pNext;
        FreeIniMMFilter(pTempFilter);
    }
}


VOID
FreeIniMMFilter(
    PINIMMFILTER pIniMMFilter
    )
{
    if (pIniMMFilter) {
        if (pIniMMFilter->pszFilterName) {
            FreeSPDString(pIniMMFilter->pszFilterName);
        }

        //
        // Must not ever free pIniMMFilter->pIniMMPolicy.
        //

        //
        // Must not ever free memory pointed by each of
        // the pointers in pIniMMFilter->ppIniMMSFilters.
        //

        if (pIniMMFilter->ppIniMMSFilters) {
            FreeSPDMemory(pIniMMFilter->ppIniMMSFilters);
        }

        FreeSPDMemory(pIniMMFilter);
    }
}


DWORD
DeleteMMFilter(
    HANDLE hMMFilter
    )
/*++

Routine Description:

    This function deletes a generic MM filter from the SPD.

Arguments:

    hMMFilter -  Handle to the filter to be deleted.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PMM_FILTER_HANDLE pFilterHandle = NULL;
    PINIMMFILTER pIniMMFilter = NULL;
    GUID gFilterID;


    if (!hMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    pFilterHandle = (PMM_FILTER_HANDLE) hMMFilter;

    ENTER_SPD_SECTION();

    dwError = ValidateMMSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMFilter = pFilterHandle->pIniMMFilter;

    if (!pIniMMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniMMFilter->cRef > 1) {

        pIniMMFilter->cRef--;
        pIniMMFilter->bPendingDeletion = TRUE;

        RemoveMMFilterHandle(
            pFilterHandle
            );

        FreeMMFilterHandle(
            pFilterHandle
            );

        dwError = ERROR_SUCCESS;
        LEAVE_SPD_SECTION();
        return (dwError);

    }

    memcpy(&gFilterID, &pIniMMFilter->gFilterID, sizeof(GUID));

    dwError = DeleteIniMMFilter(
                  pIniMMFilter
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    //
    // Delete the filter handle from the list of MM handles.
    //

    RemoveMMFilterHandle(
        pFilterHandle
        );

    FreeMMFilterHandle(
        pFilterHandle
        );

    LEAVE_SPD_SECTION();

    if (gbIKENotify) {
        (VOID) IKENotifyPolicyChange(
                   &(gFilterID),
                   POLICY_GUID_MM_FILTER
                   );
    }

    TRACE(TRC_INFORMATION, (L"Deleted MM filter %!guid!", &gFilterID));
    return (dwError);

lock:
#ifdef TRACE_ON
    if (pIniMMFilter) {
        // ASSERT: if pIniMMFilter then gFilterID is valid.
        TRACE(
            TRC_ERROR,
            ("Failed to delete MM filter %!guid!: %!winerr!",
            &gFilterID,
            dwError)
            );
    } else {
        TRACE(
            TRC_ERROR,
            ("Failed to delete MM filter.  Details unavailable since pIniMMFilter is null: %!winerr!",
            dwError)
            );
    }
#endif

    LEAVE_SPD_SECTION();

    return (dwError);
}


DWORD
DeleteIniMMFilter(
    PINIMMFILTER pIniMMFilter
    )
/*++

Routine Description:

    This function physically deletes a mm filter and all the
    specific mm filters expanded out of it.

Arguments:

    pIniMMFilter - Generic filter to be deleted.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    if (pIniMMFilter->pIniMMAuthMethods) {
        DelinkMMFilterFromAuth(
            pIniMMFilter->pIniMMAuthMethods,
            pIniMMFilter
            );
    }

    if (pIniMMFilter->pIniMMPolicy) {
        DelinkMMFilterFromPolicy(
            pIniMMFilter->pIniMMPolicy,
            pIniMMFilter
            );
    }

    DeleteIniMMSFilters(
        pIniMMFilter
        );

    RemoveIniMMFilter(
        pIniMMFilter
        );

    FreeIniMMFilter(pIniMMFilter);

    return (ERROR_SUCCESS);
}


VOID
DelinkMMFilterFromPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PINIMMFILTER pIniMMFilter
    )
{
    pIniMMPolicy->cRef--;
    pIniMMFilter->pIniMMPolicy = NULL;
    return;
}


VOID
DelinkMMFilterFromAuth(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMFILTER pIniMMFilter
    )
{
    pIniMMAuthMethods->cRef--;
    pIniMMFilter->pIniMMAuthMethods = NULL;
    return;
}


VOID
DeleteIniMMSFilters(
    PINIMMFILTER pIniMMFilter
    )
{
    PINIMMSFILTER * ppIniMMSFilters = NULL;
    DWORD dwNumMMSFilters = 0;
    DWORD i = 0;
    PINIMMSFILTER pIniMMSFilter = NULL;
    PINIMMSFILTER pIniRemoveMMSFilter = NULL;
    PINIMMSFILTER pTemp = NULL;


    ppIniMMSFilters = pIniMMFilter->ppIniMMSFilters;
    dwNumMMSFilters = pIniMMFilter->dwNumMMSFilters;

    for (i = 0; i < dwNumMMSFilters; i++) {

       //
       // Remove each entry from the MM Specific Filter List.
       //

        pIniMMSFilter =  *(ppIniMMSFilters + i);
        RemoveIniMMSFilter(pIniMMSFilter);

        //
        // Add each entry removed to a removed list.
        //

        pIniMMSFilter->pNext = NULL;
        AddToSpecificMMList(
            &pIniRemoveMMSFilter,
            pIniMMSFilter
            );

    }

    //
    // Physically delete the removed list.
    //

    while (pIniRemoveMMSFilter) {
        pTemp = pIniRemoveMMSFilter;
        pIniRemoveMMSFilter = pIniRemoveMMSFilter->pNext;
        FreeIniMMSFilter(pTemp);
    }

    return;
}


VOID
RemoveIniMMFilter(
    PINIMMFILTER pIniMMFilter
    )
{
    PINIMMFILTER * ppTemp = NULL;

    ppTemp = &gpIniMMFilter;

    while (*ppTemp) {

        if (*ppTemp == pIniMMFilter) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);
    }

    if (*ppTemp) {
        *ppTemp = pIniMMFilter->pNext;
    }

    return;
}


VOID
RemoveMMFilterHandle(
    PMM_FILTER_HANDLE pMMFilterHandle
    )
{
    PMM_FILTER_HANDLE * ppTemp = NULL;

    ppTemp = &gpMMFilterHandle;

    while (*ppTemp) {

        if (*ppTemp == pMMFilterHandle) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);
    }

    if (*ppTemp) {
        *ppTemp = pMMFilterHandle->pNext;
    }

    return;
}


VOID
FreeMMFilterHandleList(
    PMM_FILTER_HANDLE pMMFilterHandleList
    )
{
    PMM_FILTER_HANDLE pMMFilterHandle = NULL;
    PMM_FILTER_HANDLE pTemp = NULL;

    pMMFilterHandle = pMMFilterHandleList;

    while (pMMFilterHandle) {
        pTemp = pMMFilterHandle;
        pMMFilterHandle = pMMFilterHandle->pNext;
        FreeMMFilterHandle(pTemp);
    }
}


VOID
FreeMMFilterHandle(
    PMM_FILTER_HANDLE pMMFilterHandle
    )
{
    if (pMMFilterHandle) {
        FreeSPDMemory(pMMFilterHandle);
    }
    return;
}


DWORD
EnumMMFilters(
    LPWSTR pServerName,
    DWORD dwVersion,
    PMM_FILTER pMMTemplateFilter,
    DWORD dwLevel,
    GUID gGenericFilterID,  
    DWORD dwPreferredNumEntries,
    PMM_FILTER * ppMMFilters,
    LPDWORD pdwNumMMFilters,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function enumerates main mode filters from the SPD.

Arguments:

    pServerName - Server on which the filters are to be enumerated.

    dwLevel - Level to identify the type of enumeration desired:
              (i) enumerate generic mm filters or
              (ii) enumerate specific mm filters or
              (iii) enumerate specific mm filters for a generic mm
                    filter.

    gGenericFilterID - Filter id of the generic mm filter in the 
                       case when the specific mm filters for a
                       generic filter are to be enumerated.
 
    ppMMFilters - Enumerated Filters returned to the caller.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    pdwNumMMFilters - Number of filters actually enumerated.

    pdwResumeHandle - Handle to the location in the filter list from
                      which to resume enumeration.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PMM_FILTER pMMFilters = 0;
    DWORD dwNumMMFilters = 0;
    PINIMMFILTER pIniMMFilter = NULL;


    if (!ppMMFilters || !pdwNumMMFilters || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    ENTER_SPD_SECTION();

    dwError = ValidateMMSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    switch (dwLevel) {

    case ENUM_GENERIC_FILTERS:

        dwError = EnumGenericMMFilters(
                      gpIniMMFilter,
                      *pdwResumeHandle,
                      dwPreferredNumEntries,
                      &pMMFilters,
                      &dwNumMMFilters
                      );
        BAIL_ON_LOCK_ERROR(dwError);
        break;

    case ENUM_SELECT_SPECIFIC_FILTERS:

        pIniMMFilter = FindMMFilterByGuid(
                           gpMMFilterHandle,
                           gpIniMMFilter,
                           gGenericFilterID
                           );
        if (!pIniMMFilter) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_LOCK_ERROR(dwError);
        }
        dwError = EnumSelectSpecificMMFilters(
                      pIniMMFilter,
                      *pdwResumeHandle,
                      dwPreferredNumEntries,
                      &pMMFilters,
                      &dwNumMMFilters
                      );
        BAIL_ON_LOCK_ERROR(dwError);
        break;

    case ENUM_SPECIFIC_FILTERS:

        dwError = EnumSpecificMMFilters(
                      gpIniMMSFilter,
                      *pdwResumeHandle,
                      dwPreferredNumEntries,
                      &pMMFilters,
                      &dwNumMMFilters
                      );
        BAIL_ON_LOCK_ERROR(dwError);
        break;

    default:

        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_LOCK_ERROR(dwError);
        break;

    }

    *ppMMFilters = pMMFilters;
    *pdwNumMMFilters = dwNumMMFilters;
    *pdwResumeHandle = *pdwResumeHandle + dwNumMMFilters;

    LEAVE_SPD_SECTION();

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    *ppMMFilters = NULL;
    *pdwNumMMFilters = 0;
    *pdwResumeHandle = *pdwResumeHandle;

    return (dwError);
}


DWORD
EnumGenericMMFilters(
    PINIMMFILTER pIniMMFilterList,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PMM_FILTER * ppMMFilters,
    PDWORD pdwNumMMFilters
    )
/*++

Routine Description:

    This function creates enumerated generic filters.

Arguments:

    pIniMMFilterList - List of generic filters to enumerate.

    dwResumeHandle - Location in the generic filter list from which
                     to resume enumeration.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    ppMMFilters - Enumerated filters returned to the caller.

    pdwNumMMFilters - Number of filters actually enumerated.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwNumToEnum = 0;
    PINIMMFILTER pIniMMFilter = NULL;
    DWORD i = 0;
    PINIMMFILTER pTemp = NULL;
    DWORD dwNumMMFilters = 0;
    PMM_FILTER pMMFilters = 0;
    PMM_FILTER pMMFilter = 0;


    if (!dwPreferredNumEntries || 
        (dwPreferredNumEntries > MAX_MMFILTER_ENUM_COUNT)) {
        dwNumToEnum = MAX_MMFILTER_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    pIniMMFilter = pIniMMFilterList;

    for (i = 0; (i < dwResumeHandle) && (pIniMMFilter != NULL); i++) {
        pIniMMFilter = pIniMMFilter->pNext;
    }

    if (!pIniMMFilter) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTemp = pIniMMFilter;

    while (pTemp && (dwNumMMFilters < dwNumToEnum)) {
        dwNumMMFilters++;
        pTemp = pTemp->pNext;
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(MM_FILTER)*dwNumMMFilters,
                  &pMMFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pIniMMFilter;
    pMMFilter = pMMFilters;

    for (i = 0; i < dwNumMMFilters; i++) {

        dwError = CopyMMFilter(
                      pTemp,
                      pMMFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        pTemp = pTemp->pNext;
        pMMFilter++;

    }

    *ppMMFilters = pMMFilters;
    *pdwNumMMFilters = dwNumMMFilters;
    return (dwError);

error:

    if (pMMFilters) {
        FreeMMFilters(
            i,
            pMMFilters
            );
    }

    *ppMMFilters = NULL;
    *pdwNumMMFilters = 0;

    return (dwError);
}


DWORD
CopyMMFilter(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    )
/*++

Routine Description:

    This function copies an internal filter into an external filter
    container.

Arguments:

    pIniMMFilter - Internal filter to copy.

    pMMFilter - External filter container in which to copy.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;


    pMMFilter->IpVersion = pIniMMFilter->IpVersion;

    CopyGuid(pIniMMFilter->gFilterID, &(pMMFilter->gFilterID));

    dwError = CopyName(
                  pIniMMFilter->pszFilterName,
                  &(pMMFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilter->InterfaceType = pIniMMFilter->InterfaceType;

    pMMFilter->bCreateMirror = pIniMMFilter->bCreateMirror;

    pMMFilter->dwFlags = pIniMMFilter->dwFlags;

    dwError = CopyIntToExtAddresses(pIniMMFilter->SrcAddr, &(pMMFilter->SrcAddr));
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyIntToExtAddresses(pIniMMFilter->DesAddr, &(pMMFilter->DesAddr));
    BAIL_ON_WIN32_ERROR(dwError);

    pMMFilter->dwDirection = 0;

    pMMFilter->dwWeight = 0;

    CopyGuid(pIniMMFilter->gMMAuthID, &(pMMFilter->gMMAuthID));

    CopyGuid(pIniMMFilter->gPolicyID, &(pMMFilter->gPolicyID));

    return (dwError);

error:

    if (pMMFilter->pszFilterName) {
        SPDApiBufferFree(pMMFilter->pszFilterName);
        pMMFilter->pszFilterName = NULL;
    }

    if (pMMFilter->SrcAddr.pgInterfaceID) {
        SPDApiBufferFree(pMMFilter->SrcAddr.pgInterfaceID);
        pMMFilter->SrcAddr.pgInterfaceID = NULL;
    }

    if (pMMFilter->DesAddr.pgInterfaceID) {
        SPDApiBufferFree(pMMFilter->DesAddr.pgInterfaceID);
        pMMFilter->DesAddr.pgInterfaceID = NULL;
    }

    return (dwError);
}


VOID
FreeMMFilters(
    DWORD dwNumMMFilters,
    PMM_FILTER pMMFilters
    )
{
    DWORD i = 0;

    if (pMMFilters) {

        for (i = 0; i < dwNumMMFilters; i++) {

            if (pMMFilters[i].pszFilterName) {
                SPDApiBufferFree(pMMFilters[i].pszFilterName);
            }

            if (pMMFilters[i].SrcAddr.pgInterfaceID) {
                SPDApiBufferFree(pMMFilters[i].SrcAddr.pgInterfaceID);
            }

            if (pMMFilters[i].DesAddr.pgInterfaceID) {
                SPDApiBufferFree(pMMFilters[i].DesAddr.pgInterfaceID);
            }

        }

        SPDApiBufferFree(pMMFilters);

    }

}


DWORD
SetMMFilter(
    HANDLE hMMFilter,
    DWORD dwVersion,
    PMM_FILTER pMMFilter,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function sets (updates) a mm filter in the SPD.

Arguments:

    hMMFilter - Handle to the filter to be replaced.

    pMMFilter - Filter that will replace the existing filter.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PMM_FILTER_HANDLE pFilterHandle = NULL;
    PINIMMFILTER pIniMMFilter = NULL;
    BOOL bEqualPKeys = FALSE;
    GUID gFilterID;


    if (!hMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = ValidateMMFilter(
                  pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateMMSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pFilterHandle = (PMM_FILTER_HANDLE) hMMFilter;

    pIniMMFilter = pFilterHandle->pIniMMFilter;

    if (!pIniMMFilter) {
        dwError = ERROR_IPSEC_MM_FILTER_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniMMFilter->bPendingDeletion) {
        dwError = ERROR_IPSEC_MM_FILTER_PENDING_DELETION;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    bEqualPKeys = EqualMMFilterPKeys(
                      pIniMMFilter,
                      pMMFilter
                      );
    if (!bEqualPKeys) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    memcpy(&gFilterID, &pIniMMFilter->gFilterID, sizeof(GUID));

    dwError = SetIniMMFilter(
                  pIniMMFilter,
                  pMMFilter
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    LEAVE_SPD_SECTION();

    if (gbIKENotify) {
        (VOID) IKENotifyPolicyChange(
                   &(gFilterID),
                   POLICY_GUID_MM_FILTER
                   );
    }

    TRACE(
        TRC_INFORMATION,
        (L"Changed MM filter %!guid!. New guid is %!guid!",
        &gFilterID,
        &pMMFilter->gFilterID)
        );
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:
    TRACE(
        TRC_ERROR,
        ("Failed to change filter to \"%ls\" (%!guid!): %!winerr!",
        pMMFilter->pszFilterName,
        &pMMFilter->gFilterID,
        dwError)
        );    
    return (dwError);
}


DWORD
SetIniMMFilter(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    )
{
    DWORD dwError = 0;
    BOOL bEqualNonPKeys = FALSE;
    PINIMMAUTHMETHODS pIniNewMMAuthMethods = NULL;
    PINIMMPOLICY pIniNewMMPolicy = NULL;
    PINIMMFILTER pIniNewMMFilter = NULL;
    MATCHING_ADDR * pMatchingAddresses = NULL;
    DWORD dwAddrCnt = 0;
    PINIMMSFILTER pIniNewMMSFilters = NULL;
    DWORD dwNumMMSFilters = 0;
    PINIMMSFILTER * ppIniMMSFilters = NULL;
    LPWSTR pszFilterName = NULL;
    PINIMMSFILTER pIniCurMMSFilters = NULL;


    bEqualNonPKeys = EqualMMFilterNonPKeys(
                         pIniMMFilter,
                         pMMFilter
                         );
    if (bEqualNonPKeys) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    dwError = LocateMMAuthMethods(
                  pMMFilter,
                  &pIniNewMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LocateMMPolicy(
                  pMMFilter,
                  &pIniNewMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateIniMMFilter(
                  pMMFilter,
                  pIniNewMMAuthMethods,
                  pIniNewMMPolicy,
                  &pIniNewMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = GetMatchingInterfaces(
                  pIniNewMMFilter->InterfaceType,
                  gpInterfaceList,
                  &pMatchingAddresses,
                  &dwAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateIniMMSFilters(
                  pIniNewMMFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  gpSpecialAddrsList,
                  &pIniNewMMSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateMMSFilterLinks(
                  pIniNewMMSFilters,
                  &dwNumMMSFilters,
                  &ppIniMMSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateSPDString(
                  pMMFilter->pszFilterName,
                  &pszFilterName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    RemoveMMSFilters(
        pIniMMFilter,
        &pIniCurMMSFilters
        );

    UpdateMMSFilterLinks(
        pIniMMFilter,
        dwNumMMSFilters,
        ppIniMMSFilters
        );

    if (pIniMMFilter->pIniMMAuthMethods) {
        DelinkMMFilterFromAuth(
            pIniMMFilter->pIniMMAuthMethods,
            pIniMMFilter
            );
    }

    if (pIniMMFilter->pIniMMPolicy) {
        DelinkMMFilterFromPolicy(
            pIniMMFilter->pIniMMPolicy,
            pIniMMFilter
            );
    }

    if (pIniNewMMAuthMethods) {
        LinkMMFilterToAuth(
            pIniNewMMAuthMethods,
            pIniMMFilter
            );
        LinkMMSpecificFiltersToAuth(
            pIniNewMMAuthMethods,
            pIniNewMMSFilters
            );
    }

    if (pIniNewMMPolicy) {
        LinkMMFilterToPolicy(
            pIniNewMMPolicy,
            pIniMMFilter
            );
        LinkMMSpecificFiltersToPolicy(
            pIniNewMMPolicy,
            pIniNewMMSFilters
            );
    }

    UpdateMMFilterNonPKeys(
        pIniMMFilter,
        pszFilterName,
        pMMFilter,
        pIniNewMMAuthMethods,
        pIniNewMMPolicy
        );

    AddToSpecificMMList(
        &gpIniMMSFilter,
        pIniNewMMSFilters
        );

    if (pIniCurMMSFilters) {
        FreeIniMMSFilterList(pIniCurMMSFilters);
    }

cleanup:

    if (pIniNewMMFilter) {
        FreeIniMMFilter(pIniNewMMFilter);
    }

    if (pMatchingAddresses) {
        FreeSPDMemory(pMatchingAddresses);
    }

    return (dwError);

error:

    if (pIniNewMMSFilters) {
        FreeIniMMSFilterList(pIniNewMMSFilters);
    }

    if (ppIniMMSFilters) {
        FreeSPDMemory(ppIniMMSFilters);
    }

    if (pszFilterName) {
        FreeSPDString(pszFilterName);
    }

    goto cleanup;
}


BOOL
EqualMMFilterNonPKeys(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    )
{

    if ((pIniMMFilter->dwFlags) != (pMMFilter->dwFlags)) {
        return (FALSE);
    }

    if (memcmp(
            &(pIniMMFilter->gMMAuthID),
            &(pMMFilter->gMMAuthID),
            sizeof(GUID))) {
        return (FALSE);
    }

    if (memcmp(
            &(pIniMMFilter->gPolicyID),
            &(pMMFilter->gPolicyID),
            sizeof(GUID))) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
CreateMMSFilterLinks(
    PINIMMSFILTER pIniMMSFilters,
    PDWORD pdwNumMMSFilters,
    PINIMMSFILTER ** pppIniMMSFilters
    )
{
    DWORD dwError = 0;
    PINIMMSFILTER pTemp = NULL;
    DWORD dwNumMMSFilters = 0;
    PINIMMSFILTER * ppIniMMSFilters = NULL;
    DWORD i = 0;


    pTemp = pIniMMSFilters;
    while (pTemp) {
        dwNumMMSFilters++;
        pTemp = pTemp->pNext;
    }

    if (dwNumMMSFilters) {
        ppIniMMSFilters = (PINIMMSFILTER *)
                          AllocSPDMem(
                              sizeof(PINIMMSFILTER)*
                              dwNumMMSFilters
                              );
        if (!ppIniMMSFilters) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);    
        }
    }

    pTemp = pIniMMSFilters;
    for (i = 0; i < dwNumMMSFilters; i++) {
        *(ppIniMMSFilters + i) = pTemp;
        pTemp = pTemp->pNext;
    }

    *pdwNumMMSFilters = dwNumMMSFilters;
    *pppIniMMSFilters = ppIniMMSFilters;
    return (dwError);

error:

    *pdwNumMMSFilters = 0;
    *pppIniMMSFilters = NULL;
    return (dwError);
}


VOID
RemoveMMSFilters(
    PINIMMFILTER pIniMMFilter,
    PINIMMSFILTER * ppIniCurMMSFilters 
    )
{
    PINIMMSFILTER * ppIniMMSFilters = NULL;
    DWORD dwNumMMSFilters = 0;
    DWORD i = 0;
    PINIMMSFILTER pIniMMSFilter = NULL;
    PINIMMSFILTER pIniCurMMSFilters = NULL;


    ppIniMMSFilters = pIniMMFilter->ppIniMMSFilters;
    dwNumMMSFilters = pIniMMFilter->dwNumMMSFilters;

    for (i = 0; i < dwNumMMSFilters; i++) {

        //
        // Remove each entry from the MM Specific Filter List.
        //

        pIniMMSFilter =  *(ppIniMMSFilters + i);
        RemoveIniMMSFilter(pIniMMSFilter);

        //
        // Add each entry removed to a removed list.
        //

        pIniMMSFilter->pNext = NULL;
        AddToSpecificMMList(
            &pIniCurMMSFilters,
            pIniMMSFilter
            );

    }

    *ppIniCurMMSFilters = pIniCurMMSFilters;
}


VOID
UpdateMMSFilterLinks(
    PINIMMFILTER pIniMMFilter,
    DWORD dwNumMMSFilters,
    PINIMMSFILTER * ppIniMMSFilters
    )
{
    if (pIniMMFilter->ppIniMMSFilters) {
        FreeSPDMemory(pIniMMFilter->ppIniMMSFilters);
    }

    pIniMMFilter->ppIniMMSFilters = ppIniMMSFilters;
    pIniMMFilter->dwNumMMSFilters = dwNumMMSFilters;
}


VOID
UpdateMMFilterNonPKeys(
    PINIMMFILTER pIniMMFilter,
    LPWSTR pszFilterName,
    PMM_FILTER pMMFilter,
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMPOLICY pIniMMPolicy
    )
{
    if (pIniMMFilter->pszFilterName) {
        FreeSPDString(pIniMMFilter->pszFilterName);
    }
    pIniMMFilter->pszFilterName = pszFilterName;

    pIniMMFilter->dwFlags = pMMFilter->dwFlags;

    if (pIniMMAuthMethods) {
        CopyGuid(pIniMMAuthMethods->gMMAuthID, &(pIniMMFilter->gMMAuthID));
    }
    else {
        CopyGuid(pMMFilter->gMMAuthID, &(pIniMMFilter->gMMAuthID));
    }

    if (pIniMMPolicy) {
        CopyGuid(pIniMMPolicy->gPolicyID, &(pIniMMFilter->gPolicyID));
    }
    else {
        CopyGuid(pMMFilter->gPolicyID, &(pIniMMFilter->gPolicyID));
    }
}


DWORD
GetMMFilter(
    HANDLE hMMFilter,
    DWORD dwVersion,
    PMM_FILTER * ppMMFilter,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function retrieves a mm filter from the SPD.

Arguments:

    hMMFilter - Handle to the filter to be retrieved.

    ppMMFilter -  Filter returned to the caller.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PMM_FILTER_HANDLE pFilterHandle = NULL;
    PINIMMFILTER pIniMMFilter = NULL;
    PMM_FILTER pMMFilter = NULL;


    if (!hMMFilter || !ppMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    ENTER_SPD_SECTION();

    dwError = ValidateMMSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pFilterHandle = (PMM_FILTER_HANDLE) hMMFilter;

    pIniMMFilter = pFilterHandle->pIniMMFilter;

    if (!pIniMMFilter) {
        dwError = ERROR_IPSEC_MM_FILTER_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = GetIniMMFilter(
                  pIniMMFilter,
                  &pMMFilter
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    LEAVE_SPD_SECTION();

    *ppMMFilter = pMMFilter;
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    *ppMMFilter = NULL;
    return (dwError);
}


DWORD
GetIniMMFilter(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER * ppMMFilter
    )
{
    DWORD dwError = 0;
    PMM_FILTER pMMFilter = NULL;


    dwError = SPDApiBufferAllocate(
                  sizeof(MM_FILTER),
                  &pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyMMFilter(
                  pIniMMFilter,
                  pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppMMFilter = pMMFilter;
    return (dwError);

error:

    if (pMMFilter) {
        SPDApiBufferFree(pMMFilter);
    }

    *ppMMFilter = NULL;
    return (dwError);
}


DWORD
ApplyIfChangeToIniMMFilters(
    PDWORD pdwMMError,
    PIPSEC_INTERFACE pLatestIfList,
    PSPECIAL_ADDR    pLatestSpecialAddrsList
    )
{
    DWORD dwError = 0;
    PINIMMFILTER pIniMMFilter = NULL;


    pIniMMFilter = gpIniMMFilter;

    while (pIniMMFilter) {

        dwError = UpdateIniMMFilterThruIfChange(
                      pIniMMFilter,
                      pLatestIfList,
                      pLatestSpecialAddrsList
                      );
        if (dwError) {
            *pdwMMError = dwError;
        }

        pIniMMFilter = pIniMMFilter->pNext;

    }

    dwError = ERROR_SUCCESS;
    return (dwError);
}


DWORD
UpdateIniMMFilterThruIfChange(
    PINIMMFILTER pIniMMFilter,
    PIPSEC_INTERFACE pLatestIfList,
    PSPECIAL_ADDR pLatestSpecialAddrsList
    )
{
    DWORD dwError = 0;
    PINIMMSFILTER pLatestIniMMSFilters = NULL;
    DWORD dwNumMMSFilters = 0;
    PINIMMSFILTER * ppIniMMSFilters = NULL;
    PINIMMSFILTER pCurIniMMSFilters = NULL;
    PINIMMSFILTER pNewIniMMSFilters = NULL;
    PINIMMSFILTER pOldIniMMSFilters = NULL;
 

    dwError = FormIniMMSFilters(
                  pIniMMFilter,
                  pLatestIfList,
                  pLatestSpecialAddrsList,
                  &pLatestIniMMSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateMMSFilterLinks(
                  pLatestIniMMSFilters,
                  &dwNumMMSFilters,
                  &ppIniMMSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    RemoveMMSFilters(
        pIniMMFilter,
        &pCurIniMMSFilters
        );

    ProcessIniMMSFilters(
        &pLatestIniMMSFilters,
        &pCurIniMMSFilters,
        &pNewIniMMSFilters,
        &pOldIniMMSFilters
        );

    if (pIniMMFilter->pIniMMAuthMethods) {
        LinkMMSpecificFiltersToAuth(
            pIniMMFilter->pIniMMAuthMethods,
            pCurIniMMSFilters
            );
        LinkMMSpecificFiltersToAuth(
            pIniMMFilter->pIniMMAuthMethods,
            pNewIniMMSFilters
            );
    }

    if (pIniMMFilter->pIniMMPolicy) {
        LinkMMSpecificFiltersToPolicy(
            pIniMMFilter->pIniMMPolicy,
            pCurIniMMSFilters
            );
        LinkMMSpecificFiltersToPolicy(
            pIniMMFilter->pIniMMPolicy,
            pNewIniMMSFilters
            );
    }

    SetMMSFilterLinks(
        pCurIniMMSFilters,
        pNewIniMMSFilters,
        dwNumMMSFilters,
        ppIniMMSFilters
        );

    UpdateMMSFilterLinks(
        pIniMMFilter,
        dwNumMMSFilters,
        ppIniMMSFilters
        );

    AddToSpecificMMList(
        &gpIniMMSFilter,
        pCurIniMMSFilters
        );

    AddToSpecificMMList(
        &gpIniMMSFilter,
        pNewIniMMSFilters
        );

    if (pOldIniMMSFilters) {
        FreeIniMMSFilterList(pOldIniMMSFilters);
    }

    TRACE(
        TRC_INFORMATION,
        (L"Succesfully updated MM filter \"%ls\" (%!guid!) after interface change",
        pIniMMFilter->pszFilterName,
        &pIniMMFilter->gFilterID)
        );

    return (dwError);

error:
    TRACE(
        TRC_INFORMATION,
        (L"Failed to update MM filter \"%ls\" (%!guid!) after interface change: %!winerr!",
        pIniMMFilter->pszFilterName,
        &pIniMMFilter->gFilterID,
        dwError)
        );
    
    if (pLatestIniMMSFilters) {
        FreeIniMMSFilterList(pLatestIniMMSFilters);
    }

    return (dwError);
}


DWORD
FormIniMMSFilters(
    PINIMMFILTER pIniMMFilter,
    PIPSEC_INTERFACE pIfList,
    PSPECIAL_ADDR pLatestSpecialAddrsList,        
    PINIMMSFILTER * ppIniMMSFilters
    )
{
    DWORD dwError = 0;
    MATCHING_ADDR * pMatchingAddresses = NULL;
    DWORD dwAddrCnt = 0;
    PINIMMSFILTER pIniMMSFilters = NULL;


    dwError = GetMatchingInterfaces(
                  pIniMMFilter->InterfaceType,
                  pIfList,
                  &pMatchingAddresses,
                  &dwAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateIniMMSFilters(
                  pIniMMFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  pLatestSpecialAddrsList,
                  &pIniMMSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIniMMSFilters = pIniMMSFilters;

cleanup:

    if (pMatchingAddresses) {
        FreeSPDMemory(pMatchingAddresses);
    }

    return (dwError);

error:

    *ppIniMMSFilters = NULL;

    goto cleanup;
}


VOID
ProcessIniMMSFilters(
    PINIMMSFILTER * ppLatestIniMMSFilters,
    PINIMMSFILTER * ppCurIniMMSFilters,
    PINIMMSFILTER * ppNewIniMMSFilters,
    PINIMMSFILTER * ppOldIniMMSFilters
    )
{
    PINIMMSFILTER pLatestIniMMSFilters = NULL;
    PINIMMSFILTER pCurIniMMSFilters = NULL;
    PINIMMSFILTER pTempCur = NULL;
    BOOL bEqual = FALSE;
    PINIMMSFILTER pTempLatest = NULL;
    PINIMMSFILTER pTemp = NULL;
    PINIMMSFILTER pNewIniMMSFilters = NULL;
    PINIMMSFILTER pOldIniMMSFilters = NULL;
    PINIMMSFILTER pTempPreToCur = NULL;
    PINIMMSFILTER pTempPreToLatest = NULL;


    pCurIniMMSFilters = *ppCurIniMMSFilters;
    pTempCur = *ppCurIniMMSFilters;

    while (pTempCur) {

        bEqual = FALSE;
        pTempLatest = *ppLatestIniMMSFilters;

        while (pTempLatest) {

            bEqual = EqualIniMMSFilterIfPKeys(
                         pTempLatest,
                         pTempCur
                         );
            if (bEqual) {
                break;
            }

            pTempLatest = pTempLatest->pNext;

        }

        if (bEqual) {
            pTempPreToCur  = pTempCur;
            pTempCur = pTempCur->pNext;
        }
        else {
            pTemp = pTempCur;
            pTempCur = pTempCur->pNext;
            if (pTempPreToCur) {
                pTempPreToCur->pNext = pTempCur;
            }
            else {
                pCurIniMMSFilters = pTempCur;
            }
            pTemp->pNext = NULL;
            AddToSpecificMMList(
                &pOldIniMMSFilters,
                pTemp
                );
        }

    }

    pLatestIniMMSFilters = *ppLatestIniMMSFilters;
    pTempLatest = *ppLatestIniMMSFilters;

    while (pTempLatest) {

        bEqual = FALSE;
        pTempCur = pCurIniMMSFilters;

        while (pTempCur) {

            bEqual = EqualIniMMSFilterIfPKeys(
                         pTempCur,
                         pTempLatest
                         );
            if (bEqual) {
                break;
            }

            pTempCur = pTempCur->pNext;

        }

        if (bEqual) {
            pTemp = pTempLatest;
            pTempLatest = pTempLatest->pNext;
            if (pTempPreToLatest) {
                pTempPreToLatest->pNext = pTempLatest;
            }
            else {
                pLatestIniMMSFilters = pTempLatest;
            }
            FreeIniMMSFilter(pTemp);
        }
        else {
            pTemp = pTempLatest;
            pTempLatest = pTempLatest->pNext;
            if (pTempPreToLatest) {
                pTempPreToLatest->pNext = pTempLatest;
            }
            else {
                pLatestIniMMSFilters = pTempLatest;
            }
            pTemp->pNext = NULL;
            AddToSpecificMMList(
                &pNewIniMMSFilters,
                pTemp
                );
        }

    }

    *ppLatestIniMMSFilters = pLatestIniMMSFilters;
    *ppCurIniMMSFilters = pCurIniMMSFilters;
    *ppNewIniMMSFilters = pNewIniMMSFilters;
    *ppOldIniMMSFilters = pOldIniMMSFilters;
}


BOOL
EqualIniMMSFilterIfPKeys(
    PINIMMSFILTER pExsIniMMSFilter,
    PINIMMSFILTER pNewIniMMSFilter
    )
{
    BOOL  bCmp = FALSE;


    //
    // No need to compare: gParentID, pszFilterName, dwFlags
    //                     cRef, dwWeight, gMMAuthID and gPolicyID.
    // They will be the same for both the filters.
    //

    if (pExsIniMMSFilter->InterfaceType != pNewIniMMSFilter->InterfaceType) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pExsIniMMSFilter->SrcAddr, pNewIniMMSFilter->SrcAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pExsIniMMSFilter->DesAddr, pNewIniMMSFilter->DesAddr);
    if (!bCmp) {
        return (FALSE);
    }

    if (pExsIniMMSFilter->dwDirection != pNewIniMMSFilter->dwDirection) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
AllocateMMSFilterLinks(
    PINIMMSFILTER pIniMMSFilters,
    PDWORD pdwNumMMSFilters,
    PINIMMSFILTER ** pppIniMMSFilters
    )
{
    DWORD dwError = 0;
    PINIMMSFILTER pTemp = NULL;
    DWORD dwNumMMSFilters = 0;
    PINIMMSFILTER * ppIniMMSFilters = NULL;
    DWORD i = 0;


    pTemp = pIniMMSFilters;
    while (pTemp) {
        dwNumMMSFilters++;
        pTemp = pTemp->pNext;
    }

    if (dwNumMMSFilters) {
        ppIniMMSFilters = (PINIMMSFILTER *)
                          AllocSPDMem(
                              sizeof(PINIMMSFILTER)*
                              dwNumMMSFilters
                              );
        if (!ppIniMMSFilters) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);    
        }
    }

    for (i = 0; i < dwNumMMSFilters; i++) {
        *(ppIniMMSFilters + i) = NULL;
    }

    *pdwNumMMSFilters = dwNumMMSFilters;
    *pppIniMMSFilters = ppIniMMSFilters;
    return (dwError);

error:

    *pdwNumMMSFilters = 0;
    *pppIniMMSFilters = NULL;
    return (dwError);
}


VOID
SetMMSFilterLinks(
    PINIMMSFILTER pCurIniMMSFilters,
    PINIMMSFILTER pNewIniMMSFilters,
    DWORD dwNumMMSFilters,
    PINIMMSFILTER * ppIniMMSFilters
    )
{
    PINIMMSFILTER pTemp = NULL;
    DWORD i = 0;
    DWORD j = 0;


    pTemp = pCurIniMMSFilters;
    for (i = 0; (i < dwNumMMSFilters) && (pTemp != NULL); i++) {
        *(ppIniMMSFilters + i) = pTemp;
        pTemp = pTemp->pNext;
    }

    pTemp = pNewIniMMSFilters;
    for (j = i; (j < dwNumMMSFilters) && (pTemp != NULL); j++) {
        *(ppIniMMSFilters + j) = pTemp;
        pTemp = pTemp->pNext;
    }
}


DWORD
OpenMMFilterHandle(
    LPWSTR pServerName,
    DWORD dwVersion,
    PMM_FILTER pMMFilter,
    LPVOID pvReserved,
    PHANDLE phMMFilter
    )
{
    DWORD dwError = 0;
    PINIMMFILTER pIniExistingMMFilter = NULL;
    PMM_FILTER_HANDLE pMMFilterHandle = NULL;


    if (!phMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Validate the external MM filter.
    //

    dwError = ValidateMMFilter(
                  pMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateMMSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniExistingMMFilter = FindExactMMFilter(
                               gpIniMMFilter,
                               pMMFilter
                               );
    if (!pIniExistingMMFilter) {
        dwError = ERROR_IPSEC_MM_FILTER_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = CreateMMFilterHandle(
                  pIniExistingMMFilter,
                  pMMFilter->gFilterID,
                  &pMMFilterHandle
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniExistingMMFilter->cRef++;

    pMMFilterHandle->pNext = gpMMFilterHandle;
    gpMMFilterHandle = pMMFilterHandle;

    *phMMFilter = (HANDLE) pMMFilterHandle;
    LEAVE_SPD_SECTION();

cleanup:

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    if (pMMFilterHandle) {
        FreeMMFilterHandle(pMMFilterHandle);
    }

    *phMMFilter = NULL;
    goto cleanup;
}


DWORD
CloseMMFilterHandle(
    HANDLE hMMFilter
    )
{
    DWORD dwError = 0;
    PMM_FILTER_HANDLE pFilterHandle = NULL;
    PINIMMFILTER pIniMMFilter = NULL;


    if (!hMMFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    pFilterHandle = (PMM_FILTER_HANDLE) hMMFilter;

    ENTER_SPD_SECTION();

    dwError = ValidateMMSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniMMFilter = pFilterHandle->pIniMMFilter;

    if (!pIniMMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniMMFilter->cRef > 1) {

        pIniMMFilter->cRef--;

        RemoveMMFilterHandle(
            pFilterHandle
            );
        FreeMMFilterHandle(
            pFilterHandle
            );

        dwError = ERROR_SUCCESS;
        LEAVE_SPD_SECTION();
        return (dwError);

    }

    if (pIniMMFilter->bPendingDeletion) {

        dwError = DeleteIniMMFilter(
                      pIniMMFilter
                      );
        BAIL_ON_LOCK_ERROR(dwError);

    }
    else {
        pIniMMFilter->cRef--;
    }

    RemoveMMFilterHandle(
        pFilterHandle
        );
    FreeMMFilterHandle(
        pFilterHandle
        );

    LEAVE_SPD_SECTION();

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    return (dwError);
}


PINIMMFILTER
FindExactMMFilter(
    PINIMMFILTER pGenericMMList,
    PMM_FILTER pMMFilter
    )
{
    PINIMMFILTER pIniMMFilter = NULL;
    BOOL bEqual = FALSE;


    pIniMMFilter = pGenericMMList;

    while (pIniMMFilter) {

        bEqual = EqualMMFilterPKeys(
                     pIniMMFilter,
                     pMMFilter
                     );
        if (bEqual) {
            bEqual = EqualMMFilterNonPKeys(
                         pIniMMFilter,
                         pMMFilter
                         );
            if (bEqual) {
                return (pIniMMFilter);
            }
        }

        pIniMMFilter = pIniMMFilter->pNext;

    }

    return (NULL);
}


BOOL
IsConflictMirroredMMFilterPKeys(
    PINIMMFILTER pIniMMFilter,
    PMM_FILTER pMMFilter
    )
/*++

Routine Description:

    This function compares an internal and an external main mode
    filter for equality.

Arguments:

    pIniMMFilter - Filter to compare.

    pMMFilter - Filter to compare.

Return Value:

    TRUE - Filters are equal.

    FALSE - Filters are different.

--*/
{
    BOOL  bCmp = FALSE;


    bCmp = EqualExtIntAddresses(pIniMMFilter->DesAddr, pMMFilter->SrcAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualExtIntAddresses(pIniMMFilter->SrcAddr, pMMFilter->DesAddr);
    if (!bCmp) {
        return (FALSE);
    }

    if ((pIniMMFilter->InterfaceType != INTERFACE_TYPE_ALL) &&
        (pMMFilter->InterfaceType != INTERFACE_TYPE_ALL) &&
        (pIniMMFilter->InterfaceType != pMMFilter->InterfaceType)) {
        return (FALSE);
    }

    if (!pIniMMFilter->bCreateMirror && !pMMFilter->bCreateMirror) {
        return (FALSE);
    }

    return (TRUE);
}

DWORD
RefMMFilterHandle(
    PINIMMFILTER pIniMMFilter,
    GUID gFilterID,
    PMM_FILTER_HANDLE * ppMMFilterHandle
    )
{
    DWORD dwError = 0;
    PMM_FILTER_HANDLE pMMFilterHandle = NULL;

    dwError = CreateMMFilterHandle(
                  pIniMMFilter,
                  gFilterID,
                  &pMMFilterHandle
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pIniMMFilter->cRef++;

    pMMFilterHandle->pNext = gpMMFilterHandle;
    gpMMFilterHandle = pMMFilterHandle;

    *ppMMFilterHandle = pMMFilterHandle;

    return dwError;
error:
    *ppMMFilterHandle = NULL;
    return (dwError);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\mmspecific.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    mmspecific.h

Abstract:

    This module contains all of the code prototypes to
    drive the specific mm filter list management of 
    IPSecSPD Service.

Author:


Environment


Revision History:


--*/


DWORD
ApplyMMTransform(
    PINIMMFILTER pFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PSPECIAL_ADDR pSpecialAddrsList,
    PINIMMSFILTER * ppSpecificFilters
    );

DWORD
FormMMOutboundInboundAddresses(
    PINIMMFILTER pFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PSPECIAL_ADDR pSpecialAddrsList,
    PADDR_V4 * ppOutSrcAddrList,
    PDWORD pdwOutSrcAddrCnt,
    PADDR_V4 * ppInSrcAddrList,
    PDWORD pdwInSrcAddrCnt,
    PADDR_V4 * ppOutDesAddrList,
    PDWORD pdwOutDesAddrCnt,
    PADDR_V4 * ppInDesAddrList,
    PDWORD pdwInDesAddrCnt
    );

DWORD
FormSpecificMMFilters(
    PINIMMFILTER pFilter,
    PADDR_V4 pSrcAddrList,
    DWORD dwSrcAddrCnt,
    PADDR_V4 pDesAddrList,
    DWORD dwDesAddrCnt,
    DWORD dwDirection,
    PINIMMSFILTER * ppSpecificFilters
    );

DWORD
CreateSpecificMMFilter(
    PINIMMFILTER pGenericFilter,
    ADDR_V4 SrcAddr,
    ADDR_V4 DesAddr,
    PINIMMSFILTER * ppSpecificFilter
    );

VOID
AssignMMFilterWeight(
    PINIMMSFILTER pSpecificFilter
    );

VOID
AddToSpecificMMList(
    PINIMMSFILTER * ppSpecificMMFilterList,
    PINIMMSFILTER pSpecificMMFilters
    );

VOID
FreeIniMMSFilterList(
    PINIMMSFILTER pIniMMSFilterList
    );

VOID
FreeIniMMSFilter(
    PINIMMSFILTER pIniMMSFilter
    );

VOID
LinkMMSpecificFiltersToPolicy(
    PINIMMPOLICY pIniMMPolicy,
    PINIMMSFILTER pIniMMSFilters
    );

VOID
LinkMMSpecificFiltersToAuth(
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMSFILTER pIniMMSFilters
    );

VOID
RemoveIniMMSFilter(
    PINIMMSFILTER pIniMMSFilter
    );

DWORD
EnumSpecificMMFilters(
    PINIMMSFILTER pIniMMSFilterList,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PMM_FILTER * ppMMFilters,
    PDWORD pdwNumMMFilters
    );

DWORD
CopyMMSFilter(
    PINIMMSFILTER pIniMMSFilter,
    PMM_FILTER pMMFilter
    );

DWORD
EnumSelectSpecificMMFilters(
    PINIMMFILTER pIniMMFilter,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PMM_FILTER * ppMMFilters,
    PDWORD pdwNumMMFilters
    );

DWORD
ValidateMMFilterTemplate(
    PMM_FILTER pMMFilter
    );

BOOL
MatchIniMMSFilter(
    PINIMMSFILTER pIniMMSFilter,
    PMM_FILTER pMMFilter
    );

DWORD
CopyMMMatchDefaults(
    PMM_FILTER * ppMMFilters,
    PINT_MM_AUTH_METHODS * ppMMAuthMethods,
    PIPSEC_MM_POLICY * ppMMPolicies,
    PDWORD pdwNumMatches
    );

DWORD
CopyDefaultMMFilter(
    PMM_FILTER pMMFilter,
    PINIMMAUTHMETHODS pIniMMAuthMethods,
    PINIMMPOLICY pIniMMPolicy
    );

DWORD
IntMatchMMFilter(
    LPWSTR pServerName,
    DWORD dwVersion,
    PMM_FILTER pMMFilter,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PMM_FILTER * ppMatchedMMFilters,
    PIPSEC_MM_POLICY * ppMatchedMMPolicies,
    PINT_MM_AUTH_METHODS * ppMatchedMMAuthMethods,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\pamm-fil.h ===
//
// PAStore Interface types.
//

#define PASTORE_IF_TYPE_NONE    0x00000000
#define PASTORE_IF_TYPE_DIALUP  0xFFFFFFFF
#define PASTORE_IF_TYPE_LAN     0xFFFFFFFE
#define PASTORE_IF_TYPE_ALL     0xFFFFFFFD


typedef struct _mmfilterstate {
    GUID gFilterID;
    GUID gNFAIdentifier;
    GUID gPolicyID;
    GUID gMMAuthID;
    HANDLE hMMFilter;
    struct _mmfilterstate * pNext;
} MMFILTERSTATE, * PMMFILTERSTATE;


DWORD
PAAddMMFilters(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount,
    DWORD dwSource
    );

DWORD
PAAddMMFilterSpecs(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    DWORD dwSource
    );

DWORD
PACreateMMFilterState(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PMMFILTERSTATE * ppMMFilterState
    );

DWORD
PACreateMMFilter(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PMM_FILTER * ppSPDMMFilter
    );

VOID
PASetInterfaceType(
    DWORD dwInterfaceType,
    PIF_TYPE pInterfaceType
    );

VOID
PASetAddress(
    ULONG uMask,
    ULONG uAddr,
    PADDR pAddr
    );

VOID
PASetTunnelAddress(
    ULONG uAddr,
    PADDR pAddr
    );

VOID
PAFreeMMFilter(
    PMM_FILTER pSPDMMFilter
    );

DWORD
PADeleteAllMMFilters(
    );

VOID
PAFreeMMFilterStateList(
    PMMFILTERSTATE pMMFilterState
    );

DWORD
PADeleteMMFilters(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    );

DWORD
PADeleteMMFilterSpecs(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
PADeleteMMFilter(
    GUID gFilterID,
    GUID gNFAIdentifier
    );

VOID
PADeleteMMFilterState(
    PMMFILTERSTATE pMMFilterState
    );

PMMFILTERSTATE
FindMMFilterState(
    GUID gFilterID,
    GUID gNFAIdentifier
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\pamm-fil.c ===
#include "precomp.h"
#ifdef TRACE_ON
#include "pamm-fil.tmh"
#endif


DWORD
PAAddMMFilters(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    DWORD i = 0;


    for (i = 0; i < dwNumNFACount; i++) {

        dwError = PAAddMMFilterSpecs(
                      pIpsecISAKMPData,
                      *(ppIpsecNFAData + i),
                      dwSource
                      );

    }

    return (dwError);
}


DWORD
PAAddMMFilterSpecs(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    PMMPOLICYSTATE pMMPolicyState = NULL;
    PMMAUTHSTATE pMMAuthState = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppFilterSpecs = NULL;
    DWORD i = 0;
    PMMFILTERSTATE pMMFilterState = NULL;
    PMM_FILTER pSPDMMFilter = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwVersion = 0;

    TRACE(TRC_INFORMATION, ("Pastore adding MM filters for rule %!guid!.", &pIpsecNFAData->NFAIdentifier));

    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    if (!memcmp(
            &(pIpsecNegPolData->NegPolType), 
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {

        TRACE(TRC_INFORMATION, ("Pastore found default response rule: not adding an associated MM filter."));
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if (IsClearOnly(pIpsecNegPolData->NegPolAction) ||
        IsBlocking(pIpsecNegPolData->NegPolAction)) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pIpsecFilterData = pIpsecNFAData->pIpsecFilterData;

    if (!pIpsecFilterData) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pMMPolicyState = FindMMPolicyState(
                         pIpsecISAKMPData->ISAKMPIdentifier
                         );
    if (!pMMPolicyState || !(pMMPolicyState->bInSPD)) {
        TRACE(
            TRC_ERROR,
            ("Pastore failed to find associated ISAKMP policy %!guid! when adding rule %!guid!.",
            &pIpsecISAKMPData->ISAKMPIdentifier,
            &pIpsecNFAData->NFAIdentifier)
            );
            
        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
    }

    pMMAuthState = FindMMAuthState(
                       pIpsecNFAData->NFAIdentifier
                       );
    if (!pMMAuthState || !(pMMAuthState->bInSPD)) {
        TRACE(
            TRC_ERROR,
            ("Pastore failed to get associated MM auth methods %!guid! when adding rule %!guid!.",
            &pIpsecNFAData->NFAIdentifier,
            &pIpsecNFAData->NFAIdentifier)
            );
        
        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
    }

    dwNumFilterSpecs = pIpsecFilterData->dwNumFilterSpecs;
    ppFilterSpecs = pIpsecFilterData->ppFilterSpecs;
    

    for (i = 0; i < dwNumFilterSpecs; i++) {

        dwError = PACreateMMFilterState(
                      pIpsecISAKMPData,
                      pIpsecNFAData,
                      *(ppFilterSpecs + i),
                      &pMMFilterState
                      );
        if (dwError) {
            continue;
        }

        dwError = PACreateMMFilter(
                      pIpsecISAKMPData,
                      pIpsecNFAData,
                      *(ppFilterSpecs + i),
                      &pSPDMMFilter
                      );
        if (dwError) {

            pMMFilterState->hMMFilter = NULL;

            pMMFilterState->pNext = gpMMFilterState;
            gpMMFilterState = pMMFilterState;

            continue;

        }

        dwError = AddMMFilterInternal(
                      pServerName,
                      dwVersion,
                      0,
                      dwSource,
                      pSPDMMFilter,
                      NULL,
                      &(pMMFilterState->hMMFilter)
                      );

        pMMFilterState->pNext = gpMMFilterState;
        gpMMFilterState = pMMFilterState;

        PAFreeMMFilter(pSPDMMFilter);

    }

    return (dwError);
}


DWORD
PACreateMMFilterState(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PMMFILTERSTATE * ppMMFilterState
    )
{
    DWORD dwError = 0;
    PMMFILTERSTATE pMMFilterState = NULL;


    dwError = AllocateSPDMemory(
                  sizeof(MMFILTERSTATE),
                  &pMMFilterState
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pMMFilterState->gFilterID),
        &(pFilterSpec->FilterSpecGUID),
        sizeof(GUID)
        );

    memcpy(
        &(pMMFilterState->gNFAIdentifier),
        &(pIpsecNFAData->NFAIdentifier),
        sizeof(GUID)
        );

    memcpy(
        &(pMMFilterState->gPolicyID),
        &(pIpsecISAKMPData->ISAKMPIdentifier),
        sizeof(GUID)
        );

    memcpy(
        &(pMMFilterState->gMMAuthID),
        &(pIpsecNFAData->NFAIdentifier),
        sizeof(GUID)
        );

    pMMFilterState->hMMFilter = NULL;
    pMMFilterState->pNext = NULL;

    *ppMMFilterState = pMMFilterState;

    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        ("Pastore failed to create state node for MM filter %!guid!. %!winerr!", 
        &pFilterSpec->FilterSpecGUID,
        dwError)
        );

    *ppMMFilterState = NULL;

    return (dwError);
}


DWORD
PACreateMMFilter(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PMM_FILTER * ppSPDMMFilter
    )
{
    DWORD dwError = 0;
    PMM_FILTER pSPDMMFilter = NULL;
    WCHAR pszName[512];


    dwError = AllocateSPDMemory(
                  sizeof(MM_FILTER),
                  &pSPDMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pSPDMMFilter->IpVersion = IPSEC_PROTOCOL_V4;

    memcpy(
        &(pSPDMMFilter->gFilterID),
        &(pFilterSpec->FilterSpecGUID),
        sizeof(GUID)
        );

    if (pFilterSpec->pszDescription && *(pFilterSpec->pszDescription)) {

        dwError = AllocateSPDString(
                      pFilterSpec->pszDescription,
                      &(pSPDMMFilter->pszFilterName)
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }
    else {

        wsprintf(pszName, L"%d", ++gdwMMFilterCounter);

        dwError = AllocateSPDString(
                      pszName,
                      &(pSPDMMFilter->pszFilterName)
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    PASetInterfaceType(
        pIpsecNFAData->dwInterfaceType,
        &(pSPDMMFilter->InterfaceType)
        );

    pSPDMMFilter->bCreateMirror = (BOOL) pFilterSpec->dwMirrorFlag;

    pSPDMMFilter->dwFlags = 0;

    if (!(pIpsecNFAData->dwTunnelFlags)) {

        PASetAddress(
            pFilterSpec->Filter.SrcMask,
            pFilterSpec->Filter.SrcAddr,
            &(pSPDMMFilter->SrcAddr)
            );

        PASetAddress(
            pFilterSpec->Filter.DestMask,
            pFilterSpec->Filter.DestAddr, 
            &(pSPDMMFilter->DesAddr)
            );
            
        if (pFilterSpec->Filter.ExType) {
            if (pFilterSpec->Filter.ExType & EXT_DEST) {
              pSPDMMFilter->DesAddr.AddrType = ExTypeToAddrType(
                                                  pFilterSpec->Filter.ExType
                                                  );
            } else {
              pSPDMMFilter->SrcAddr.AddrType = ExTypeToAddrType(
                                                  pFilterSpec->Filter.ExType
                                                  );
            }
        }
    }
    else {

        PASetAddress(
            IP_ADDRESS_MASK_NONE,
            IP_ADDRESS_ME,
            &(pSPDMMFilter->SrcAddr)
            );
        pSPDMMFilter->bCreateMirror = TRUE;
                           
        PASetTunnelAddress(
            ((ULONG) pIpsecNFAData->dwTunnelIpAddr),
            &(pSPDMMFilter->DesAddr)
            );

    }

    pSPDMMFilter->dwDirection = 0;

    pSPDMMFilter->dwWeight = 0;

    memcpy(
        &(pSPDMMFilter->gPolicyID),
        &(pIpsecISAKMPData->ISAKMPIdentifier),
        sizeof(GUID)
        );

    memcpy(
        &(pSPDMMFilter->gMMAuthID),
        &(pIpsecNFAData->NFAIdentifier),
        sizeof(GUID)
        );

    *ppSPDMMFilter = pSPDMMFilter;

    return (dwError);

error:
    TRACE(
        TRC_WARNING,
        ("Pastore failed to create MM filter %!guid!. %!winerr!", 
        &pFilterSpec->FilterSpecGUID,
        dwError)
        );

    if (pSPDMMFilter) {
        PAFreeMMFilter(
            pSPDMMFilter
            );
    }

    *ppSPDMMFilter = NULL;

    return (dwError);
}


VOID
PASetInterfaceType(
    DWORD dwInterfaceType,
    PIF_TYPE pInterfaceType
    )
{
    if (dwInterfaceType == PASTORE_IF_TYPE_DIALUP) {
        *pInterfaceType = INTERFACE_TYPE_DIALUP;
    }
    else if (dwInterfaceType == PASTORE_IF_TYPE_LAN) {
        *pInterfaceType = INTERFACE_TYPE_LAN;
    }
    else {
        *pInterfaceType = INTERFACE_TYPE_ALL;
    }
}


VOID
PASetAddress(
    ULONG uMask,
    ULONG uAddr,
    PADDR pAddr
    )
{
    if (uMask == IP_ADDRESS_MASK_NONE) {
        pAddr->AddrType = IP_ADDR_UNIQUE;
        pAddr->uIpAddr = uAddr;
        pAddr->uSubNetMask = uMask;
    }
    else {
        pAddr->AddrType = IP_ADDR_SUBNET;
        pAddr->uIpAddr = uAddr;
        pAddr->uSubNetMask = uMask;
    }
    pAddr->pgInterfaceID = NULL;
}


VOID
PASetTunnelAddress(
    ULONG uAddr,
    PADDR pAddr
    )
{
    if (uAddr == SUBNET_ADDRESS_ANY) {
        pAddr->AddrType = IP_ADDR_SUBNET;
        pAddr->uIpAddr = uAddr;
        pAddr->uSubNetMask = SUBNET_MASK_ANY;
    }
    else {
        pAddr->AddrType = IP_ADDR_UNIQUE;
        pAddr->uIpAddr = uAddr;
        pAddr->uSubNetMask = IP_ADDRESS_MASK_NONE;
    }

    pAddr->pgInterfaceID = NULL;
}


VOID
PAFreeMMFilter(
    PMM_FILTER pSPDMMFilter
    )
{
    if (pSPDMMFilter) {

        if (pSPDMMFilter->pszFilterName) {
            FreeSPDString(pSPDMMFilter->pszFilterName);
        }

        FreeSPDMemory(pSPDMMFilter);

    }

    return;
}


DWORD
PADeleteAllMMFilters(
    )
{
    DWORD dwError = 0;
    PMMFILTERSTATE pMMFilterState = NULL;
    PMMFILTERSTATE pTemp = NULL;
    PMMFILTERSTATE pLeftMMFilterState = NULL;

    TRACE(TRC_INFORMATION, (L"Pastore deleting all its MM filters"));

    pMMFilterState = gpMMFilterState;

    while (pMMFilterState) {

        if (pMMFilterState->hMMFilter) {

            dwError = DeleteMMFilter(
                          pMMFilterState->hMMFilter
                          );
            if (!dwError) {
                pTemp = pMMFilterState;
                pMMFilterState = pMMFilterState->pNext;
                FreeSPDMemory(pTemp);
            } 
            else {
                pTemp = pMMFilterState;
                pMMFilterState = pMMFilterState->pNext;

                pTemp->pNext = pLeftMMFilterState;
                pLeftMMFilterState = pTemp;
            }

        }
        else {

            pTemp = pMMFilterState;
            pMMFilterState = pMMFilterState->pNext;
            FreeSPDMemory(pTemp);

        }

    }

    gpMMFilterState = pLeftMMFilterState;
    
    return (dwError);
}


VOID
PAFreeMMFilterStateList(
    PMMFILTERSTATE pMMFilterState
    )
{
    PMMFILTERSTATE pTemp = NULL;


    while (pMMFilterState) {

        pTemp = pMMFilterState;
        pMMFilterState = pMMFilterState->pNext;
        FreeSPDMemory(pTemp);

    }
}


DWORD
PADeleteMMFilters(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    )
{
    DWORD dwError = 0;
    DWORD i = 0;


    for (i = 0; i < dwNumNFACount; i++) {

        dwError = PADeleteMMFilterSpecs(
                      pIpsecISAKMPData,
                      *(ppIpsecNFAData + i)
                      );

    }

    return (dwError);
}


DWORD
PADeleteMMFilterSpecs(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppFilterSpecs = NULL;
    DWORD i = 0;
    PIPSEC_FILTER_SPEC pFilterSpec = NULL;

    TRACE(
        TRC_INFORMATION,
        ("Pastore deleting MM filters generated from rule %!guid!",
        &pIpsecNFAData->NFAIdentifier)
        );
    
    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    if (!memcmp(
            &(pIpsecNegPolData->NegPolType), 
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if (IsClearOnly(pIpsecNegPolData->NegPolAction) ||
        IsBlocking(pIpsecNegPolData->NegPolAction)) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pIpsecFilterData = pIpsecNFAData->pIpsecFilterData;

    if (!pIpsecFilterData) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    dwNumFilterSpecs = pIpsecFilterData->dwNumFilterSpecs;
    ppFilterSpecs = pIpsecFilterData->ppFilterSpecs;
    
    for (i = 0; i < dwNumFilterSpecs; i++) {

        pFilterSpec = *(ppFilterSpecs + i);

        dwError = PADeleteMMFilter(
                      pFilterSpec->FilterSpecGUID,
                      pIpsecNFAData->NFAIdentifier
                      );
    }

    return (dwError);
}


DWORD
PADeleteMMFilter(
    GUID gFilterID,
    GUID gNFAIdentifier
    )
{
    DWORD dwError = 0;
    PMMFILTERSTATE pMMFilterState = NULL;


    pMMFilterState = FindMMFilterState(
                         gFilterID,
                         gNFAIdentifier
                         );
    if (!pMMFilterState) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if (pMMFilterState->hMMFilter) {

        dwError = DeleteMMFilter(
                      pMMFilterState->hMMFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    PADeleteMMFilterState(pMMFilterState);

error:
#ifdef TRACE_ON
        if (dwError) {
            TRACE(
                TRC_ERROR,
                ("Pastore failed to delete MM filter %!guid!. %!winerr!", 
                &gFilterID,
                dwError)
                );
        }
#endif

    return (dwError);
}


VOID
PADeleteMMFilterState(
    PMMFILTERSTATE pMMFilterState
    )
{
    PMMFILTERSTATE * ppTemp = NULL;


    ppTemp = &gpMMFilterState;

    while (*ppTemp) {

        if (*ppTemp == pMMFilterState) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);

    }

    if (*ppTemp) {
        *ppTemp = pMMFilterState->pNext;
    }

    FreeSPDMemory(pMMFilterState);

    return;
}


PMMFILTERSTATE
FindMMFilterState(
    GUID gFilterID,
    GUID gNFAIdentifier
    )
{
    PMMFILTERSTATE pMMFilterState = NULL;


    pMMFilterState = gpMMFilterState;

    while (pMMFilterState) {

        if (!memcmp(&(pMMFilterState->gFilterID), &gFilterID, sizeof(GUID))
             && !memcmp(&(pMMFilterState->gNFAIdentifier), &gNFAIdentifier, sizeof(GUID))
            )
        {
            return (pMMFilterState);
        }

        pMMFilterState = pMMFilterState->pNext;

    }

    return (NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\pamm-pol.h ===
typedef struct _mmpolicystate {
    GUID gPolicyID;
    LPWSTR pszPolicyName;
    BOOL bInSPD;
    DWORD dwErrorCode;
    struct _mmpolicystate * pNext;
} MMPOLICYSTATE, * PMMPOLICYSTATE;


DWORD
PAAddMMPolicies(
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData,
    DWORD dwNumPolicies,
    DWORD dwSource
    );

DWORD
PACreateMMPolicyState(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PMMPOLICYSTATE * ppMMPolicyState
    );

VOID
PAFreeMMPolicyState(
    PMMPOLICYSTATE pMMPolicyState
    );

DWORD
PACreateMMPolicy(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PMMPOLICYSTATE pMMPolicyState,
    PIPSEC_MM_POLICY * ppSPDMMPolicy
    );

DWORD
PACreateMMOffers(
    DWORD dwNumISAKMPSecurityMethods,
    PCRYPTO_BUNDLE pSecurityMethods,
    PDWORD pdwOfferCount,
    PIPSEC_MM_OFFER * ppOffers
    );

VOID
PACopyMMOffer(
    PCRYPTO_BUNDLE pBundle,
    PIPSEC_MM_OFFER pOffer
    );

VOID
PAFreeMMPolicy(
    PIPSEC_MM_POLICY pSPDMMPolicy
    );

VOID
PAFreeMMOffers(
    DWORD dwOfferCount,
    PIPSEC_MM_OFFER pOffers
    );

DWORD
PADeleteAllMMPolicies(
    );

VOID
PAFreeMMPolicyStateList(
    PMMPOLICYSTATE pMMPolicyState
    );

PMMPOLICYSTATE
FindMMPolicyState(
    GUID gPolicyID
    );

DWORD
PADeleteMMPolicies(
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData,
    DWORD dwNumPolicies
    );

DWORD
PADeleteMMPolicy(
    GUID gPolicyID
    );

VOID
PADeleteMMPolicyState(
    PMMPOLICYSTATE pMMPolicyState
    );

DWORD
PADeleteInUseMMPolicies(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\pammauth.h ===
typedef struct _mmauthstate {
    GUID gMMAuthID;
    BOOL bInSPD;
    DWORD dwErrorCode;
    struct _mmauthstate * pNext;
} MMAUTHSTATE, * PMMAUTHSTATE;


DWORD
PAAddMMAuthMethods(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount,
    DWORD dwSource
    );

DWORD
PACreateMMAuthState(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PMMAUTHSTATE * ppMMAuthState
    );

DWORD
PACreateMMAuthMethods(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PINT_MM_AUTH_METHODS * ppSPDMMAuthMethods
    );

DWORD
PACreateMMAuthInfos(
    DWORD dwAuthMethodCount,
    PIPSEC_AUTH_METHOD * ppAuthMethods,
    PDWORD pdwNumAuthInfos,
    PINT_IPSEC_MM_AUTH_INFO * ppAuthenticationInfo
    );

VOID
PAFreeMMAuthMethods(
    PINT_MM_AUTH_METHODS pSPDMMAuthMethods
    );

VOID
PAFreeMMAuthInfos(
    DWORD dwNumAuthInfos,
    PINT_IPSEC_MM_AUTH_INFO pAuthenticationInfo
    );

DWORD
PADeleteAllMMAuthMethods(
    );

VOID
PAFreeMMAuthStateList(
    PMMAUTHSTATE pMMAuthState
    );

PMMAUTHSTATE
FindMMAuthState(
    GUID gMMAuthID
    );

DWORD
PADeleteMMAuthMethods(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    );

DWORD
PADeleteMMAuthMethod(
    GUID gMMAuthID
    );

VOID
PADeleteMMAuthState(
    PMMAUTHSTATE pMMAuthState
    );

DWORD
PADeleteInUseMMAuthMethods(
    );

DWORD
EncodeName(
    LPWSTR pszSubjectName,
    PBYTE * ppEncodedName,
    PDWORD pdwEncodedLength
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\pamm-pol.c ===
#include "precomp.h"
#ifdef TRACE_ON
#include "pamm-pol.tmh"
#endif

   
DWORD
PAAddMMPolicies(
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData,
    DWORD dwNumPolicies,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PMMPOLICYSTATE pMMPolicyState = NULL;
    PIPSEC_MM_POLICY pSPDMMPolicy = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwPersist = 0;
    DWORD dwVersion = 0;

    for (i = 0; i < dwNumPolicies; i++) {
        TRACE(
            TRC_INFORMATION,
            (L"Pastore adding MM policy based on ISAKMP data %!guid!",
            &(*(ppIpsecISAKMPData + i))->ISAKMPIdentifier)
            );
        
        dwError = PACreateMMPolicyState(
                      *(ppIpsecISAKMPData + i),
                      &pMMPolicyState
                      );
        if (dwError) {
            continue;
        }

        dwError = PACreateMMPolicy(
                      *(ppIpsecISAKMPData + i),
                      pMMPolicyState,
                      &pSPDMMPolicy
                      );
        if (dwError) {

            pMMPolicyState->bInSPD = FALSE;
            pMMPolicyState->dwErrorCode = dwError;

            pMMPolicyState->pNext = gpMMPolicyState;
            gpMMPolicyState = pMMPolicyState;

            continue;

        }

        dwError = AddMMPolicyInternal(
                      pServerName,
                      dwVersion,
                      dwPersist,
                      dwSource,
                      pSPDMMPolicy,
                      NULL
                      );
        if (dwError && dwError != WARNING_IPSEC_MM_POLICY_PRUNED) {
            pMMPolicyState->bInSPD = FALSE;
            pMMPolicyState->dwErrorCode = dwError;
        }
        else {
            pMMPolicyState->bInSPD = TRUE;
            pMMPolicyState->dwErrorCode = ERROR_SUCCESS;
            dwError = ERROR_SUCCESS;
        }

        pMMPolicyState->pNext = gpMMPolicyState;
        gpMMPolicyState = pMMPolicyState;

        PAFreeMMPolicy(pSPDMMPolicy);

    }

    return (dwError);
}


DWORD
PACreateMMPolicyState(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PMMPOLICYSTATE * ppMMPolicyState
    )
{
    DWORD dwError = 0;
    PMMPOLICYSTATE pMMPolicyState = NULL;
    WCHAR pszName[512];    


    dwError = AllocateSPDMemory(
                  sizeof(MMPOLICYSTATE),
                  &pMMPolicyState
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pMMPolicyState->gPolicyID),
        &(pIpsecISAKMPData->ISAKMPIdentifier),
        sizeof(GUID)
        );

    wsprintf(pszName, L"%d", ++gdwMMPolicyCounter);

    dwError = AllocateSPDString(
                  pszName,
                  &(pMMPolicyState->pszPolicyName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMMPolicyState->bInSPD = FALSE;
    pMMPolicyState->dwErrorCode = 0;
    pMMPolicyState->pNext = NULL;

    *ppMMPolicyState = pMMPolicyState;

    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        (L"Pastore failed to create MM policy state for %!guid!",
        &(pIpsecISAKMPData->ISAKMPIdentifier))
        );

    if (pMMPolicyState) {
        PAFreeMMPolicyState(pMMPolicyState);
    }

    *ppMMPolicyState = NULL;

    return (dwError);
}


VOID
PAFreeMMPolicyState(
    PMMPOLICYSTATE pMMPolicyState
    )
{
    if (pMMPolicyState) {
        if (pMMPolicyState->pszPolicyName) {
            FreeSPDString(pMMPolicyState->pszPolicyName);
        }
        FreeSPDMemory(pMMPolicyState);
    }
}


DWORD
PACreateMMPolicy(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PMMPOLICYSTATE pMMPolicyState,
    PIPSEC_MM_POLICY * ppSPDMMPolicy
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_POLICY pSPDMMPolicy = NULL;


    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_MM_POLICY),
                  &pSPDMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pSPDMMPolicy->gPolicyID),
        &(pIpsecISAKMPData->ISAKMPIdentifier),
        sizeof(GUID)
        );

    dwError = AllocateSPDString(
                  pMMPolicyState->pszPolicyName,
                  &(pSPDMMPolicy->pszPolicyName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pSPDMMPolicy->dwFlags = 0;
    pSPDMMPolicy->dwFlags |= IPSEC_MM_POLICY_DEFAULT_POLICY;
    
    dwError = PACreateMMOffers(
                  pIpsecISAKMPData->dwNumISAKMPSecurityMethods,
                  pIpsecISAKMPData->pSecurityMethods,
                  &(pSPDMMPolicy->dwOfferCount),
                  &(pSPDMMPolicy->pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pSPDMMPolicy->uSoftExpirationTime = 
    (pSPDMMPolicy->pOffers)->Lifetime.uKeyExpirationTime;

    pSPDMMPolicy->dwFlags |= pIpsecISAKMPData->ISAKMPPolicy.dwFlags;

    *ppSPDMMPolicy = pSPDMMPolicy;

    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        (L"Pastore failed to create MM policy for %!guid!",
        &(pIpsecISAKMPData->ISAKMPIdentifier))
    );


    if (pSPDMMPolicy) {
        PAFreeMMPolicy(
            pSPDMMPolicy
            );
    }

    *ppSPDMMPolicy = NULL;

    return (dwError);
}


DWORD
PACreateMMOffers(
    DWORD dwNumISAKMPSecurityMethods,
    PCRYPTO_BUNDLE pSecurityMethods,
    PDWORD pdwOfferCount,
    PIPSEC_MM_OFFER * ppOffers
    )
{
    DWORD dwError = 0;
    DWORD dwOfferCount = 0;
    PIPSEC_MM_OFFER pOffers = NULL;
    PIPSEC_MM_OFFER pTempOffer = NULL;
    PCRYPTO_BUNDLE pTempBundle = NULL;
    DWORD i = 0;


    if (!dwNumISAKMPSecurityMethods || !pSecurityMethods) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (dwNumISAKMPSecurityMethods > IPSEC_MAX_MM_OFFERS) {
        dwOfferCount = IPSEC_MAX_MM_OFFERS;
    }
    else {
        dwOfferCount = dwNumISAKMPSecurityMethods;
    }

    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_MM_OFFER)*dwOfferCount,
                  &(pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTempOffer = pOffers;
    pTempBundle = pSecurityMethods;

    for (i = 0; i < dwOfferCount; i++) {

        PACopyMMOffer(
            pTempBundle,
            pTempOffer
            );

        pTempOffer++;
        pTempBundle++;

    }

    *pdwOfferCount = dwOfferCount;
    *ppOffers = pOffers;
    return (dwError);

error:

    if (pOffers) {
        PAFreeMMOffers(
            i,
            pOffers
            );
    }

    *pdwOfferCount = 0;
    *ppOffers = NULL;
    return (dwError);
}


VOID
PACopyMMOffer(
    PCRYPTO_BUNDLE pBundle,
    PIPSEC_MM_OFFER pOffer
    )
{
    pOffer->Lifetime.uKeyExpirationKBytes = pBundle->Lifetime.KBytes;
    pOffer->Lifetime.uKeyExpirationTime = pBundle->Lifetime.Seconds;

    pOffer->dwFlags = 0;

    pOffer->dwQuickModeLimit = pBundle->QuickModeLimit;

    pOffer->dwDHGroup = pBundle->OakleyGroup;

    switch (pBundle->EncryptionAlgorithm.AlgorithmIdentifier) {

    case IPSEC_ESP_DES:
        pOffer->EncryptionAlgorithm.uAlgoIdentifier = CONF_ALGO_DES;
        break;

    case IPSEC_ESP_DES_40:
        pOffer->EncryptionAlgorithm.uAlgoIdentifier = CONF_ALGO_DES;
        break;

    case IPSEC_ESP_3_DES:
        pOffer->EncryptionAlgorithm.uAlgoIdentifier = CONF_ALGO_3_DES;
        break;

    default:
        pOffer->EncryptionAlgorithm.uAlgoIdentifier= CONF_ALGO_NONE;
        break;

    }

    pOffer->EncryptionAlgorithm.uAlgoKeyLen = 
    pBundle->EncryptionAlgorithm.KeySize;

    pOffer->EncryptionAlgorithm.uAlgoRounds = 
    pBundle->EncryptionAlgorithm.Rounds;

    switch(pBundle->HashAlgorithm.AlgorithmIdentifier) {

    case IPSEC_AH_MD5:
        pOffer->HashingAlgorithm.uAlgoIdentifier = AUTH_ALGO_MD5;
        break;

    case IPSEC_AH_SHA:
        pOffer->HashingAlgorithm.uAlgoIdentifier = AUTH_ALGO_SHA1;
        break;

    default:
        pOffer->HashingAlgorithm.uAlgoIdentifier = AUTH_ALGO_NONE;
        break;

    }

    pOffer->HashingAlgorithm.uAlgoKeyLen = 
    pBundle->HashAlgorithm.KeySize;

    pOffer->HashingAlgorithm.uAlgoRounds = 
    pBundle->HashAlgorithm.Rounds;
}


VOID
PAFreeMMPolicy(
    PIPSEC_MM_POLICY pSPDMMPolicy
    )
{
    if (pSPDMMPolicy) {

        if (pSPDMMPolicy->pszPolicyName) {
            FreeSPDString(pSPDMMPolicy->pszPolicyName);
        }

        PAFreeMMOffers(
            pSPDMMPolicy->dwOfferCount,
            pSPDMMPolicy->pOffers
            );

        FreeSPDMemory(pSPDMMPolicy);

    }
}


VOID
PAFreeMMOffers(
    DWORD dwOfferCount,
    PIPSEC_MM_OFFER pOffers
    )
{
    if (pOffers) {
        FreeSPDMemory(pOffers);
    }
}


DWORD
PADeleteAllMMPolicies(
    )
{
    DWORD dwError = 0;
    PMMPOLICYSTATE pMMPolicyState = NULL;
    LPWSTR pServerName = NULL;
    PMMPOLICYSTATE pTemp = NULL;
    PMMPOLICYSTATE pLeftMMPolicyState = NULL;
    DWORD dwVersion = 0;

    TRACE(TRC_INFORMATION, (L"Pastore deleting all MM polcies."));

    pMMPolicyState = gpMMPolicyState;

    while (pMMPolicyState) {

        if (pMMPolicyState->bInSPD) {

            dwError = DeleteMMPolicy(
                          pServerName,
                          dwVersion,
                          pMMPolicyState->pszPolicyName,
                          NULL
                          );
            if (!dwError) {
                pTemp = pMMPolicyState;
                pMMPolicyState = pMMPolicyState->pNext;
                PAFreeMMPolicyState(pTemp);
            } 
            else {
                pMMPolicyState->dwErrorCode = dwError;

                pTemp = pMMPolicyState;
                pMMPolicyState = pMMPolicyState->pNext;

                pTemp->pNext = pLeftMMPolicyState;
                pLeftMMPolicyState = pTemp;
            }

        }
        else {

            pTemp = pMMPolicyState;
            pMMPolicyState = pMMPolicyState->pNext;
            PAFreeMMPolicyState(pTemp);

        }

    }

    gpMMPolicyState = pLeftMMPolicyState;
    
    return (dwError);
}


VOID
PAFreeMMPolicyStateList(
    PMMPOLICYSTATE pMMPolicyState
    )
{
    PMMPOLICYSTATE pTemp = NULL;


    while (pMMPolicyState) {

        pTemp = pMMPolicyState;
        pMMPolicyState = pMMPolicyState->pNext;
        PAFreeMMPolicyState(pTemp);

    }
}


PMMPOLICYSTATE
FindMMPolicyState(
    GUID gPolicyID
    )
{
    PMMPOLICYSTATE pMMPolicyState = NULL;


    pMMPolicyState = gpMMPolicyState;

    while (pMMPolicyState) {

        if (!memcmp(&(pMMPolicyState->gPolicyID), &gPolicyID, sizeof(GUID))) {
            return (pMMPolicyState);
        }

        pMMPolicyState = pMMPolicyState->pNext;

    }

    return (NULL);
}


DWORD
PADeleteMMPolicies(
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData,
    DWORD dwNumPolicies
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData = NULL;


    for (i = 0; i < dwNumPolicies; i++) {

        pIpsecISAKMPData = *(ppIpsecISAKMPData + i);

        dwError = PADeleteMMPolicy(
                      pIpsecISAKMPData->ISAKMPIdentifier
                      );

    }

    return (dwError);
}


DWORD
PADeleteMMPolicy(
    GUID gPolicyID
    )
{
    DWORD dwError = 0;
    PMMPOLICYSTATE pMMPolicyState = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwVersion = 0;

    TRACE(
        TRC_INFORMATION,
        (L"Pastore deleting MM policy %!guid!",
        &gPolicyID)
        );

    pMMPolicyState = FindMMPolicyState(
                         gPolicyID
                         );
    if (!pMMPolicyState) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if (pMMPolicyState->bInSPD) {

        dwError = DeleteMMPolicy(
                      pServerName,
                      dwVersion,
                      pMMPolicyState->pszPolicyName,
                      NULL
                      );
        if (dwError) {
            pMMPolicyState->dwErrorCode = dwError;
        }
        BAIL_ON_WIN32_ERROR(dwError);

    }

    PADeleteMMPolicyState(pMMPolicyState);

error:

    return (dwError);
}


VOID
PADeleteMMPolicyState(
    PMMPOLICYSTATE pMMPolicyState
    )
{
    PMMPOLICYSTATE * ppTemp = NULL;


    ppTemp = &gpMMPolicyState;

    while (*ppTemp) {

        if (*ppTemp == pMMPolicyState) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);

    }

    if (*ppTemp) {
        *ppTemp = pMMPolicyState->pNext;
    }

    PAFreeMMPolicyState(pMMPolicyState);

    return;
}


DWORD
PADeleteInUseMMPolicies(
    )
{
    DWORD dwError = 0;
    PMMPOLICYSTATE pMMPolicyState = NULL;
    LPWSTR pServerName = NULL;
    PMMPOLICYSTATE pTemp = NULL;
    PMMPOLICYSTATE pLeftMMPolicyState = NULL;
    DWORD dwVersion = 0;

    TRACE(TRC_INFORMATION, (L"Pastore deleting in-use MM polcies."));
    
    pMMPolicyState = gpMMPolicyState;

    while (pMMPolicyState) {

        if (pMMPolicyState->bInSPD &&
            (pMMPolicyState->dwErrorCode == ERROR_IPSEC_MM_POLICY_IN_USE)) {

            dwError = DeleteMMPolicy(
                          pServerName,
                          dwVersion,
                          pMMPolicyState->pszPolicyName,
                          NULL
                          );
            if (!dwError) {
                pTemp = pMMPolicyState;
                pMMPolicyState = pMMPolicyState->pNext;
                PAFreeMMPolicyState(pTemp);
            }
            else {
                pTemp = pMMPolicyState;
                pMMPolicyState = pMMPolicyState->pNext;

                pTemp->pNext = pLeftMMPolicyState;
                pLeftMMPolicyState = pTemp;
            }

        }
        else {

            pTemp = pMMPolicyState;
            pMMPolicyState = pMMPolicyState->pNext;

            pTemp->pNext = pLeftMMPolicyState;
            pLeftMMPolicyState = pTemp;

        }

    }

    gpMMPolicyState = pLeftMMPolicyState;

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\paqm-pol.h ===
typedef struct _qmpolicystate {
    GUID gPolicyID;
    LPWSTR pszPolicyName;
    GUID gNegPolType;
    GUID gNegPolAction;
    BOOL bAllowsSoft;
    DWORD cRef;
    BOOL bInSPD;
    DWORD dwErrorCode;
    struct _qmpolicystate * pNext;
} QMPOLICYSTATE, * PQMPOLICYSTATE;


DWORD
PAAddQMPolicies(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount,
    DWORD dwSource
    );

DWORD
PACreateQMPolicyState(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE * ppQMPolicyState
    );

VOID
PAFreeQMPolicyState(
    PQMPOLICYSTATE pQMPolicyState
    );

BOOL
IsClearOnly(
    GUID gNegPolAction
    );

BOOL
IsBlocking(
    GUID gNegPolAction
    );

BOOL
IsInboundPassThru(
    GUID gNegPolAction
    );

BOOL
IsSecure(
    GUID gNegPolAction
    );

DWORD
PACreateQMPolicy(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_QM_POLICY * ppSPDQMPolicy
    );

DWORD
PACreateQMOffers(
    DWORD dwSecurityMethodCount,
    PIPSEC_SECURITY_METHOD pIpsecSecurityMethods,
    PQMPOLICYSTATE pQMPolicyState,
    PDWORD pdwOfferCount,
    PIPSEC_QM_OFFER * ppOffers
    );

VOID
PACopyQMOffers(
    PIPSEC_SECURITY_METHOD pMethod,
    PIPSEC_QM_OFFER pOffer
    );

VOID
PAFreeQMPolicy(
    PIPSEC_QM_POLICY pSPDQMPolicy
    );

VOID
PAFreeQMOffers(
    DWORD dwOfferCount,
    PIPSEC_QM_OFFER pOffers
    );

DWORD
PADeleteAllQMPolicies(
    );

VOID
PAFreeQMPolicyStateList(
    PQMPOLICYSTATE pQMPolicyState
    );

PQMPOLICYSTATE
FindQMPolicyState(
    GUID gPolicyID
    );

DWORD
PADeleteQMPolicies(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    );

DWORD
PADeleteQMPolicy(
    GUID gPolicyID
    );

VOID
PADeleteQMPolicyState(
    PQMPOLICYSTATE pQMPolicyState
    );

DWORD
PADeleteInUseQMPolicies(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\pastore.c ===
#include "precomp.h"
#ifdef TRACE_ON
#include "pastore.tmh"
#endif


VOID
InitializePolicyStateBlock(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    memset(pIpsecPolicyState, 0, sizeof(IPSEC_POLICY_STATE));
    pIpsecPolicyState->DefaultPollingInterval = gDefaultPollingInterval;
}


DWORD
StartStatePollingManager(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;


    if (IsDirectoryPolicySpecified()) {
        dwError = PlumbDirectoryPolicy(
                      pIpsecPolicyState
                      );

        if (dwError) {
            dwError = PlumbCachePolicy(
                          pIpsecPolicyState
                          );
        }
    } else if (IsLocalPolicySpecified()) {
        dwError = PlumbLocalPolicy(
                      pIpsecPolicyState
                      );
        BAIL_ON_WIN32_ERROR(dwError);
    }
#ifdef TRACE_ON
        else {
        TRACE(TRC_INFORMATION, ("Pastore did not detect any local or domain policy assigned."));
    }
#endif

    //
    // The new polling interval has been set by either the
    // registry code or the DS code or remains at initialized value.
    //

    gCurrentPollingInterval = pIpsecPolicyState->CurrentPollingInterval;
    TRACE(
        TRC_INFORMATION,
        ("Set global polling interval to %d",
        gCurrentPollingInterval)
        );

    return (dwError);

error:
    return (dwError);
}


DWORD
PlumbDirectoryPolicy(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszDirectoryPolicyDN = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD dwStoreType = IPSEC_DIRECTORY_PROVIDER;
    DWORD dwSlientErrorCode = 0;
    BOOL bIsActivePolicy = FALSE;
    SPD_ACTION SpdAction = SPD_POLICY_LOAD;

    TRACE(TRC_INFORMATION, (L"Plumbing directory policy"));
    
    dwError = GetDirectoryPolicyDN(
                  &pszDirectoryPolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    bIsActivePolicy = TRUE;

    dwError = LoadDirectoryPolicy(
                  pszDirectoryPolicyDN,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ProcessNFAs(
                  pIpsecPolicyObject,
                  dwStoreType,
                  &dwSlientErrorCode,
                  &pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    AuditIPSecPolicyEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_LOAD_DS_POLICY_SUCCESS,
        pIpsecPolicyData->pszIpsecName,
        TRUE,
        TRUE
        );

    SpdAction = SPD_POLICY_APPLY;

    if (pIpsecPolicyState->pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyState->pIpsecPolicyObject);
    }

    if (pIpsecPolicyState->pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyState->pIpsecPolicyData);
    }

    if (pIpsecPolicyState->pszDirectoryPolicyDN) {
        FreeSPDStr(pIpsecPolicyState->pszDirectoryPolicyDN);
    }

    pIpsecPolicyState->pIpsecPolicyObject = pIpsecPolicyObject;
    pIpsecPolicyObject = NULL;

    pIpsecPolicyState->pIpsecPolicyData = pIpsecPolicyData;
    pIpsecPolicyData = NULL;

    pIpsecPolicyState->pszDirectoryPolicyDN = pszDirectoryPolicyDN;
    pszDirectoryPolicyDN = NULL;

    //
    // Plumb the DS policy.
    //

    dwError = ApplyLoadedDirectoryPolicy(
                  pIpsecPolicyState
                  );
    // If error rollback. Ignoring rollback errors, because nothing can be done.
    //
    if (dwError) {
        TRACE(TRC_INFORMATION, ("Pastore rolling back policy application due to previous errors"));
        (VOID) DeletePolicyInformation(
              pIpsecPolicyState->pIpsecPolicyData
              );
    }
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ERROR_SUCCESS;
    if (dwSlientErrorCode) {
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_FAILED_SOME_NFA_APPLICATION,
            pIpsecPolicyState->pIpsecPolicyData->pszIpsecName,
            dwSlientErrorCode,
            FALSE,
            TRUE
            );
        
        TRACE(
            TRC_WARNING,
            ("Pastore failed to process one or more NFAs. Please compare active policy in SPD with static policy in storage: %!winerr!",
            dwSlientErrorCode)           
            );
            
    }

    return (dwError);

error:
    SetSpdStateOnError(
        IPSEC_SOURCE_DOMAIN,
        SpdAction,
        dwError,
        &pIpsecPolicyState->CurrentState
        );
    //
    // Audit if we had an error loading policy (ApplyLoadedDirectoryPolicy handles
    // auditing for policy pplication)
    //

    if (bIsActivePolicy && pszDirectoryPolicyDN &&
        SpdAction == SPD_POLICY_LOAD)
    {
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_LOAD_DS_POLICY_FAIL,
            pszDirectoryPolicyDN,
            dwError,
            FALSE,
            TRUE
            );
    }

    if (pszDirectoryPolicyDN) {
        FreeSPDStr(pszDirectoryPolicyDN);
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    // ASSERT: if ApplyLoadedDirectoryPolicy failed, then pIpsecPolicyState->pIpsecPolicyObject, are set to the
    // pIpsecPolicyState->pIpsecPolicyData and pIpsecPolicyState->pszCachePolicyDN are filled
    // with the values of the loaded BUT Unapplied policy.

    return (dwError);
}


DWORD
GetDirectoryPolicyDN(
    LPWSTR * ppszDirectoryPolicyDN
    )
{
    DWORD dwError = 0;
    HKEY hPolicyKey = NULL;
    LPWSTR pszIpsecPolicyName = NULL;
    DWORD dwSize = 0;
    LPWSTR pszPolicyDN = NULL;
    LPWSTR pszDirectoryPolicyDN = NULL;


    *ppszDirectoryPolicyDN = NULL;

    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszIpsecDSPolicyKey,
                  0,
                  KEY_ALL_ACCESS,
                  &hPolicyKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hPolicyKey,
                  L"DSIPSECPolicyPath",
                  REG_SZ,
                  (LPBYTE *)&pszIpsecPolicyName,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Move by LDAP:// to get the real DN and allocate
    // this string.
    // Fix this by fixing the gpo extension.
    //

    pszPolicyDN = pszIpsecPolicyName + wcslen(L"LDAP://");

    pszDirectoryPolicyDN = AllocSPDStr(pszPolicyDN);

    if (!pszDirectoryPolicyDN) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszDirectoryPolicyDN = pszDirectoryPolicyDN;

error:
#ifdef TRACE_ON
    if (dwError) {
        TRACE(TRC_ERROR, ("Failed to determine directory policy DN: %!winerr!", dwError));
    }
#endif

    if (pszIpsecPolicyName) {
        FreeSPDStr(pszIpsecPolicyName);
    }

    if (hPolicyKey) {
        CloseHandle(hPolicyKey);
    }

    return (dwError);
}


DWORD
LoadDirectoryPolicy(
    LPWSTR pszDirectoryPolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    )
{
    DWORD dwError = 0;
    LPWSTR pszDefaultDirectory = NULL;
    HLDAP hLdapBindHandle = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;

    TRACE(TRC_INFORMATION, (L"Loading directory policy."));
    
    dwError = ComputeDefaultDirectory(
                  &pszDefaultDirectory
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = OpenDirectoryServerHandle(
                  pszDefaultDirectory,
                  389,
                  &hLdapBindHandle
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ReadPolicyObjectFromDirectory(
                  hLdapBindHandle,
                  pszDirectoryPolicyDN,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecPolicyObject = pIpsecPolicyObject;

    TRACE(TRC_INFORMATION, (L"Loaded directory policy from \"%ls\"", pszDirectoryPolicyDN));
    
cleanup:

    if (pszDefaultDirectory) {
        FreeSPDStr(pszDefaultDirectory);
    }

    if (hLdapBindHandle) {
        CloseDirectoryServerHandle(hLdapBindHandle);
    }

    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        (L"Failed to load directory policy from \"%ls\": %!winerr!",
        pszDirectoryPolicyDN,
        dwError)
        );
    *ppIpsecPolicyObject = NULL;

    goto cleanup;
}

DWORD
ApplyLoadedDirectoryPolicy(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;

    TRACE(TRC_INFORMATION, (L"Applying loaded directory policy."));
    
    pIpsecPolicyData = pIpsecPolicyState->pIpsecPolicyData;
    
    //
    // Plumb the DS policy.
    //

    dwError = AddPolicyInformation(
                  pIpsecPolicyData,
                  IPSEC_SOURCE_DOMAIN
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Delete the old cache and write the new one in.
    //

    DeleteRegistryCache();

    CacheDirectorytoRegistry(pIpsecPolicyState->pIpsecPolicyObject);

    //
    // Set the state to DS_DOWNLOADED.
    //

    SetSpdStateOnError(
        IPSEC_SOURCE_DOMAIN,
        SPD_POLICY_APPLY,
        ERROR_SUCCESS,
        &pIpsecPolicyState->CurrentState
        );

    //
    // Compute the new polling interval.
    //

    pIpsecPolicyState->CurrentPollingInterval = pIpsecPolicyData->dwPollingInterval;

    pIpsecPolicyState->DSIncarnationNumber = pIpsecPolicyData->dwWhenChanged;

    pIpsecPolicyState->RegIncarnationNumber = 0;

    gCurrentPollingInterval = pIpsecPolicyState->CurrentPollingInterval;

    TRACE(
        TRC_INFORMATION,
        ("Set global polling interval to %d",
        gCurrentPollingInterval)
        );

    dwError = ERROR_SUCCESS;

    AuditIPSecPolicyEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_APPLIED_DS_POLICY,
        pIpsecPolicyData->pszIpsecName,
        TRUE,
        TRUE
        );

    TRACE(
        TRC_INFORMATION,
        (L"Applied directory policy %ls loaded from %ls",
        pIpsecPolicyData->pszIpsecName,
        pIpsecPolicyState->pszDirectoryPolicyDN)
        );

    return (dwError);
error:
    TRACE(
        TRC_ERROR,
        (L"Failed to apply directory policy %ls loaded from %ls",
        pIpsecPolicyData->pszIpsecName,
        pIpsecPolicyState->pszDirectoryPolicyDN)
        );
    
    SetSpdStateOnError(
        IPSEC_SOURCE_DOMAIN,
        SPD_POLICY_APPLY,
        dwError,
        &pIpsecPolicyState->CurrentState
        );
        
    AuditIPSecPolicyErrorEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_FAILED_DS_POLICY_APPLICATION,
        pIpsecPolicyData->pszIpsecName,
        dwError,
        FALSE,
        TRUE
        );
        
    return (dwError);
}

DWORD
PlumbCachePolicy(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszCachePolicyDN = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD dwStoreType = IPSEC_REGISTRY_PROVIDER;
    DWORD dwSlientErrorCode = 0;
    BOOL bIsActivePolicy = FALSE;
    SPD_ACTION SpdAction = SPD_POLICY_LOAD;

    TRACE(TRC_INFORMATION, (L"Plumbing cache policy."));
    
    dwError = GetCachePolicyDN(
                  &pszCachePolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    bIsActivePolicy = TRUE;

    dwError = LoadCachePolicy(
                  pszCachePolicyDN,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ProcessNFAs(
                  pIpsecPolicyObject,
                  dwStoreType,
                  &dwSlientErrorCode,
                  &pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    SpdAction = SPD_POLICY_APPLY;
    dwError = AddPolicyInformation(
                  pIpsecPolicyData,
                  IPSEC_SOURCE_CACHE
                  );
    // If error rollback. Ignoring rollback errors, because nothing can be done.
    //
    if (dwError) {
        TRACE(TRC_INFORMATION, ("Pastore rolling back policy application due to previous errors"));        
        (VOID) DeletePolicyInformation(
                    pIpsecPolicyData
                    );
    }
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecPolicyState->pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyState->pIpsecPolicyObject);
    }

    if (pIpsecPolicyState->pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyState->pIpsecPolicyData);
    }

    if (pIpsecPolicyState->pszCachePolicyDN) {
        FreeSPDStr(pIpsecPolicyState->pszCachePolicyDN);
    }

    pIpsecPolicyState->pIpsecPolicyObject = pIpsecPolicyObject;

    pIpsecPolicyState->pIpsecPolicyData = pIpsecPolicyData;

    pIpsecPolicyState->pszCachePolicyDN = pszCachePolicyDN;

    //
    // Set the state to SPD_STATE_CACHE_APPLY_SUCCESS.
    //
    //

    SetSpdStateOnError(
        IPSEC_SOURCE_CACHE,
        SPD_POLICY_APPLY,
        ERROR_SUCCESS,
        &pIpsecPolicyState->CurrentState
        );

    //
    // Compute the new polling interval.
    //

    pIpsecPolicyState->CurrentPollingInterval = pIpsecPolicyData->dwPollingInterval;

    pIpsecPolicyState->DSIncarnationNumber = 0;

    pIpsecPolicyState->RegIncarnationNumber = pIpsecPolicyData->dwWhenChanged;

    gCurrentPollingInterval = pIpsecPolicyState->CurrentPollingInterval;

    TRACE(
        TRC_INFORMATION,
        ("Set global polling interval to %d",
        gCurrentPollingInterval)
        );

    dwError = ERROR_SUCCESS;
    if (dwSlientErrorCode) {
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_FAILED_SOME_NFA_APPLICATION,
            pIpsecPolicyData->pszIpsecName,
            dwSlientErrorCode,
            FALSE,
            TRUE
            );

        TRACE(
            TRC_WARNING,
            ("Pastore failed to process one or more NFAs. Please compare active policy in SPD with policy in storage: %!winerr!",
            dwSlientErrorCode)           
            );
        
    }
    AuditIPSecPolicyEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_APPLIED_CACHED_POLICY,
        pIpsecPolicyData->pszIpsecName,
        TRUE,
        TRUE
        );

    TRACE(
        TRC_INFORMATION,
        (L"Applied cache policy %ls loaded from %ls",
        pIpsecPolicyData->pszIpsecName,
        pIpsecPolicyState->pszCachePolicyDN)
        );
    
    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        (L"Failed to plumb cache policy.")
        );
    
    SetSpdStateOnError(
        IPSEC_SOURCE_CACHE,
        SpdAction,
        dwError,
        &pIpsecPolicyState->CurrentState
        );
    //
    // Check pszCachePolicyDN for non-NULL.
    //

    if (bIsActivePolicy && pszCachePolicyDN) {
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_FAILED_CACHED_POLICY_APPLICATION,
            pszCachePolicyDN,
            dwError,
            FALSE,
            TRUE
            );
    }

    if (pszCachePolicyDN) {
        FreeSPDStr(pszCachePolicyDN);
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    return (dwError);
}


DWORD
GetCachePolicyDN(
    LPWSTR * ppszCachePolicyDN
    )
{
    DWORD dwError = 0;
    LPWSTR pszDirectoryPolicyDN = NULL;
    LPWSTR pszCachePolicyDN = NULL;


    *ppszCachePolicyDN = NULL;

    dwError = GetDirectoryPolicyDN(
                  &pszDirectoryPolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyPolicyDSToFQRegString(
                  pszDirectoryPolicyDN,
                  &pszCachePolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppszCachePolicyDN = pszCachePolicyDN;

error:
#ifdef TRACE_ON
    if (dwError) {
        TRACE(TRC_ERROR, ("Failed to determine cache policy DN: %!winerr!", dwError));
    }
#endif

    if (pszDirectoryPolicyDN) {
        FreeSPDStr(pszDirectoryPolicyDN);
    }

    return (dwError);
}


DWORD
LoadCachePolicy(
    LPWSTR pszCachePolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    )
{
    DWORD dwError = 0;
    HKEY hRegistryKey = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;

    TRACE(TRC_INFORMATION, (L"Loading cache policy."));
    
    dwError = OpenRegistryIPSECRootKey(
                  NULL,
                  gpszIpsecCachePolicyKey,
                  &hRegistryKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ReadPolicyObjectFromRegistry(
                  hRegistryKey,
                  pszCachePolicyDN,
                  gpszIpsecCachePolicyKey,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecPolicyObject = pIpsecPolicyObject;

cleanup:

    if (hRegistryKey) {
        CloseHandle(hRegistryKey);
    }

    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        (L"Failed to load cache policy from \"%ls\": %!winerr!",
        pszCachePolicyDN,
        dwError)
        );

    *ppIpsecPolicyObject = NULL;

    goto cleanup;
}


DWORD
PlumbLocalPolicy(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszRegistryPolicyDN = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD dwStoreType = IPSEC_REGISTRY_PROVIDER;
    DWORD dwSlientErrorCode = 0;
    BOOL bIsActivePolicy = FALSE;
    SPD_ACTION SpdAction = SPD_POLICY_LOAD;

    TRACE(TRC_INFORMATION, (L"Plumbing local policy."));
    
    dwError = GetRegistryPolicyDN(
                  &pszRegistryPolicyDN,
                  IPSEC_STORE_LOCAL
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    bIsActivePolicy = TRUE;

    dwError = LoadRegistryPolicy(
                  pszRegistryPolicyDN,
                  &pIpsecPolicyObject,
                  IPSEC_STORE_LOCAL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ProcessNFAs(
                  pIpsecPolicyObject,
                  dwStoreType,
                  &dwSlientErrorCode,
                  &pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    AuditIPSecPolicyEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_LOAD_LOCAL_POLICY_SUCCESS,
        pIpsecPolicyData->pszIpsecName,
        TRUE,
        TRUE
        );

    SpdAction = SPD_POLICY_APPLY;
    
    if (pIpsecPolicyState->pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyState->pIpsecPolicyObject);
    }

    if (pIpsecPolicyState->pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyState->pIpsecPolicyData);
    }

    if (pIpsecPolicyState->pszRegistryPolicyDN) {
        FreeSPDStr(pIpsecPolicyState->pszRegistryPolicyDN);
    }

    pIpsecPolicyState->pIpsecPolicyObject = pIpsecPolicyObject;
    pIpsecPolicyObject = NULL;
    
    pIpsecPolicyState->pIpsecPolicyData = pIpsecPolicyData;
    pIpsecPolicyData = NULL;
    
    pIpsecPolicyState->pszRegistryPolicyDN = pszRegistryPolicyDN;
    pszRegistryPolicyDN = NULL;

    dwError = ApplyLoadedLocalPolicy(
                pIpsecPolicyState
                );
    // If error rollback. Ignoring rollback errors, because nothing can be done.
    //
    if (dwError) {
        TRACE(TRC_INFORMATION, ("Pastore rolling back policy application due to previous errors"));        
        (VOID) DeletePolicyInformation(
              pIpsecPolicyState->pIpsecPolicyData
              );
    }
    BAIL_ON_WIN32_ERROR(dwError);
    
    dwError = ERROR_SUCCESS;
    if (dwSlientErrorCode) {
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_FAILED_SOME_NFA_APPLICATION,
            pIpsecPolicyState->pIpsecPolicyData->pszIpsecName,
            dwSlientErrorCode,
            FALSE,
            TRUE
            );
        TRACE(
            TRC_WARNING,
            ("Pastore failed to process one or more NFAs. Please compare active policy in SPD with policy in storage: %!winerr!",
            dwSlientErrorCode)            
            );
        
    }

    return (dwError);

error:
    SetSpdStateOnError(
        IPSEC_SOURCE_LOCAL,
        SpdAction,
        dwError,
        &pIpsecPolicyState->CurrentState
        );           
        
    //
    // Audit if we had an error loading policy (ApplyLoadedDirectoryPolicy handles
    // auditing for policy pplication)
    //

    if (bIsActivePolicy && pszRegistryPolicyDN &&
        SpdAction == SPD_POLICY_LOAD) 
    {
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_LOAD_LOCAL_POLICY_FAIL,
            pszRegistryPolicyDN,
            dwError,
            FALSE,
            TRUE
            );
    }

    if (pszRegistryPolicyDN) {
        FreeSPDStr(pszRegistryPolicyDN);
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    // ASSERT: if ApplyLoadedLocalPolicy failed, then pIpsecPolicyState->pIpsecPolicyObject, are set to the
    // pIpsecPolicyState->pIpsecPolicyData and pIpsecPolicyState->pszCachePolicyDN are filled
    // with the values of the loaded BUT Unapplied policy.

    return (dwError);
}

DWORD
ApplyLoadedLocalPolicy(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;

    TRACE(TRC_INFORMATION, (L"Applying loaded local policy."));
    
    pIpsecPolicyData = pIpsecPolicyState->pIpsecPolicyData;
    
    dwError = AddPolicyInformation(
                  pIpsecPolicyData,
                  IPSEC_SOURCE_LOCAL
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    
    SetSpdStateOnError(
        IPSEC_SOURCE_LOCAL,
        SPD_POLICY_APPLY,
        ERROR_SUCCESS,
        &pIpsecPolicyState->CurrentState
        );
    //
    // Compute the new polling interval.
    //

    pIpsecPolicyState->CurrentPollingInterval = pIpsecPolicyData->dwPollingInterval;

    pIpsecPolicyState->DSIncarnationNumber = 0;

    pIpsecPolicyState->RegIncarnationNumber = pIpsecPolicyData->dwWhenChanged;

    gCurrentPollingInterval = pIpsecPolicyState->CurrentPollingInterval;

    TRACE(
        TRC_INFORMATION,
        ("Set global polling interval to %d",
        gCurrentPollingInterval)
        );

    dwError = ERROR_SUCCESS;

    AuditIPSecPolicyEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_APPLIED_LOCAL_POLICY,
        pIpsecPolicyData->pszIpsecName,
        TRUE,
        TRUE
        );

    TRACE(
        TRC_INFORMATION,
        (L"Applied local policy %ls loaded from %ls",
        pIpsecPolicyData->pszIpsecName,        
        pIpsecPolicyState->pszRegistryPolicyDN)
        );
    
    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        (L"Failed to apply local policy %ls loaded from %ls",
        pIpsecPolicyData->pszIpsecName,
        pIpsecPolicyState->pszDirectoryPolicyDN)
        );
    
    SetSpdStateOnError(
        IPSEC_SOURCE_LOCAL,
        SPD_POLICY_APPLY,
        dwError,
        &pIpsecPolicyState->CurrentState
        );           
        
    AuditIPSecPolicyErrorEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_FAILED_LOCAL_POLICY_APPLICATION,
        pIpsecPolicyData->pszIpsecName,
        dwError,
        FALSE,
        TRUE
        );


    return (dwError);
}


DWORD
PlumbPersistentPolicy(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszRegistryPolicyDN = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD dwStoreType = IPSEC_REGISTRY_PROVIDER;
    DWORD dwSlientErrorCode = 0;
    BOOL bIsActivePolicy = FALSE;
    SPD_ACTION SpdAction = SPD_POLICY_LOAD;

    TRACE(TRC_INFORMATION, (L"Plumbing local policy."));

    dwError = GetRegistryPolicyDN(
                  &pszRegistryPolicyDN,
                  IPSEC_STORE_PERSISTENT
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    bIsActivePolicy = TRUE;


    dwError = LoadRegistryPolicy(
                  pszRegistryPolicyDN,
                  &pIpsecPolicyObject,
                  IPSEC_STORE_PERSISTENT
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ProcessNFAs(
                  pIpsecPolicyObject,
                  dwStoreType,
                  &dwSlientErrorCode,
                  &pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    AuditIPSecPolicyEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_LOAD_PERSISTENT_POLICY_SUCCESS,
        pIpsecPolicyData->pszIpsecName,
        TRUE,
        TRUE
        );

    SpdAction = SPD_POLICY_APPLY;
    dwError = AddPolicyInformation(
                  pIpsecPolicyData,
                  IPSEC_SOURCE_PERSISTENT
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    
    if (pIpsecPolicyState->pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyState->pIpsecPolicyObject);
    }

    if (pIpsecPolicyState->pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyState->pIpsecPolicyData);
    }

    if (pIpsecPolicyState->pszRegistryPolicyDN) {
        FreeSPDStr(pIpsecPolicyState->pszRegistryPolicyDN);
    }

    pIpsecPolicyState->pIpsecPolicyObject = pIpsecPolicyObject;

    pIpsecPolicyState->pIpsecPolicyData = pIpsecPolicyData;

    pIpsecPolicyState->pszRegistryPolicyDN = pszRegistryPolicyDN;

    SetSpdStateOnError(
        IPSEC_SOURCE_PERSISTENT,
        SPD_POLICY_APPLY,
        ERROR_SUCCESS,
        &gpIpsecPolicyState->CurrentState
        );
    gbPersistentPolicyApplied = TRUE;
    
    pIpsecPolicyState->PersIncarnationNumber = pIpsecPolicyData->dwWhenChanged;

    dwError = ERROR_SUCCESS;
    if (dwSlientErrorCode) {
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_FAILED_SOME_NFA_APPLICATION,
            pIpsecPolicyData->pszIpsecName,
            dwSlientErrorCode,
            FALSE,
            TRUE
            );
        TRACE(
            TRC_WARNING,
            ("Pastore failed to process one or more NFAs. Please compare active policy in SPD policy in storage: %!winerr!",
            dwSlientErrorCode)            
            );
    }
    AuditIPSecPolicyEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_APPLIED_PERSISTENT_POLICY,
        pIpsecPolicyData->pszIpsecName,
        TRUE,
        TRUE
        );

    TRACE(TRC_INFORMATION, ("Plumbed persistent policy"));
    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        (L"Failed to plumb persistent policy.")
        );
    
    SetSpdStateOnError(
        IPSEC_SOURCE_PERSISTENT,
        SpdAction,
        dwError,
        &gpIpsecPolicyState->CurrentState
        );

    gbPersistentPolicyApplied = FALSE;
    
    //
    // Check pszRegistryPolicyDN for non-NULL.
    //

    if (bIsActivePolicy && pszRegistryPolicyDN &&
        SpdAction == SPD_POLICY_LOAD) 
        {
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_LOAD_PERSISTENT_POLICY_FAIL,
            pszRegistryPolicyDN,
            dwError,
            FALSE,
            TRUE
            );
    } else if (SpdAction == SPD_POLICY_APPLY && pIpsecPolicyData) {
        // (Above pIPsecPolicyData can't be null if SPD_POLICY_APPLY,
        // but needed check to get prefast off our back)
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_FAILED_PERSISTENT_POLICY_APPLICATION,
            pIpsecPolicyData->pszIpsecName,
            dwError,
            FALSE,
            TRUE
            );
    }

    if (pszRegistryPolicyDN) {
        FreeSPDStr(pszRegistryPolicyDN);
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    return (dwError);
}

LPWSTR 
GetRegPathForStore(
    IN DWORD dwStore)
{
    if (dwStore == IPSEC_STORE_PERSISTENT) {
        return gpszIpsecPersistentPolicyKey;
    }
    else if (dwStore == IPSEC_STORE_LOCAL) {
        return gpszIpsecLocalPolicyKey;
    }

    return NULL;
}

DWORD
GetRegistryPolicyDN(
    LPWSTR * ppszRegistryPolicyDN,
    IN DWORD dwStore
    )
{
    DWORD dwError = 0;
    HKEY hPolicyKey = NULL;
    LPWSTR pszIpsecPolicyName = NULL;
    DWORD dwSize = 0;
    LPWSTR pszRegPath = NULL;

    pszRegPath = GetRegPathForStore(dwStore);
    if (pszRegPath == NULL) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  pszRegPath,
                  0,
                  KEY_ALL_ACCESS,
                  &hPolicyKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hPolicyKey,
                  L"ActivePolicy",
                  REG_SZ,
                  (LPBYTE *)&pszIpsecPolicyName,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!pszIpsecPolicyName || !*pszIpsecPolicyName) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppszRegistryPolicyDN = pszIpsecPolicyName;

cleanup:

    if (hPolicyKey) {
        CloseHandle(hPolicyKey);
    }

    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        (L"Failed to get %ls policy DN: %!winerr!",
        dwStore == IPSEC_STORE_LOCAL ? L"local" : L"persistent",
        dwError)
        );

    if (pszIpsecPolicyName) {
        FreeSPDStr(pszIpsecPolicyName);
    }

    *ppszRegistryPolicyDN = NULL;

    goto cleanup;
}

DWORD
LoadRegistryPolicy(
    LPWSTR pszRegistryPolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject,
    IN DWORD dwStore
    )
{
    DWORD dwError = 0;
    HKEY hRegistryKey = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    LPWSTR pszRegPath = NULL;

    TRACE(TRC_INFORMATION, (L"Loading registry policy."));
    
    pszRegPath = GetRegPathForStore(dwStore);
    if (pszRegPath == NULL) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = OpenRegistryIPSECRootKey(
                  NULL,
                  pszRegPath,
                  &hRegistryKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ReadPolicyObjectFromRegistry(
                  hRegistryKey,
                  pszRegistryPolicyDN,
                  pszRegPath,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIpsecPolicyObject = pIpsecPolicyObject;

cleanup:

    if (hRegistryKey) {
        CloseHandle(hRegistryKey);
    }

    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        (L"Failed to load %ls policy from \"%ls\": %!winerr!",
        dwStore == IPSEC_STORE_LOCAL ? L"local" : L"persistent",
        pszRegistryPolicyDN,
        dwError)
        );

    *ppIpsecPolicyObject = NULL;
    goto cleanup;
}


DWORD
LoadPersistedIPSecInformation(
    )
{
    DWORD dwError = ERROR_SUCCESS;
    IPSEC_POLICY_STATE IpsecPolicyState;
    
    // Initialize Policy State Block.
    //
    InitializePolicyStateBlock(&IpsecPolicyState);

    // Load and apply the persisted store
    //

    if (IsPersistentPolicySpecified()) {
        dwError = PlumbPersistentPolicy(
                    &IpsecPolicyState 
                    );
        BAIL_ON_WIN32_ERROR(dwError);                                    
    }
#ifdef TRACE_ON
        else {
        TRACE(TRC_INFORMATION, (L"No persistent policy specified."));
    }
#endif

cleanup:
    ClearPolicyStateBlock(&IpsecPolicyState);
    
    return (dwError);

error:
    goto cleanup;

}

DWORD
AddPolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    IN DWORD dwSource
    )
{
    DWORD dwError = 0;
    BOOL bHardError = FALSE;


    dwError = AddMMPolicyInformation(
                    pIpsecPolicyData,
                    dwSource
                    );

    dwError = AddQMPolicyInformation(
                pIpsecPolicyData,
                dwSource,
                &bHardError
                );

    if (bHardError) {
        return (dwError);
    } else {
        return ERROR_SUCCESS;
    }
}


DWORD
AddMMPolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    IN DWORD dwSource
    )
{
    DWORD dwError = 0;


    dwError = PAAddMMPolicies(
                  &(pIpsecPolicyData->pIpsecISAKMPData),
                  1,
                  dwSource
                  );

    dwError = PAAddMMAuthMethods(
                  pIpsecPolicyData->ppIpsecNFAData,
                  pIpsecPolicyData->dwNumNFACount,
                  dwSource
                  );

    dwError = PAAddMMFilters(
                  pIpsecPolicyData->pIpsecISAKMPData,
                  pIpsecPolicyData->ppIpsecNFAData,
                  pIpsecPolicyData->dwNumNFACount,
                  dwSource
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    return (dwError);
}


DWORD
AddQMPolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    IN DWORD dwSource,
    BOOL * pbHardError
    )
{
    DWORD dwError = 0;
    BOOL bHardError = FALSE;

    dwError = PAAddQMPolicies(
                  pIpsecPolicyData->ppIpsecNFAData,
                  pIpsecPolicyData->dwNumNFACount,
                  dwSource
                  );

    dwError = PAAddQMFilters(
                  pIpsecPolicyData->ppIpsecNFAData,
                  pIpsecPolicyData->dwNumNFACount,
                  dwSource,
                  &bHardError
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:
    *pbHardError = bHardError;

    return (dwError);
}


DWORD
OnPolicyChanged(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;


    //
    // Remove all the old policy that was plumbed.
    //
    TRACE(TRC_INFORMATION, ("Pastore deleting existing policy since policy assignment change detected or forced."));
    
    dwError = DeletePolicyInformation(
                  pIpsecPolicyState->pIpsecPolicyData
                  );

    ClearPolicyStateBlock(
         pIpsecPolicyState
         );
    // Don't lose track of the fact that we've loaded Persistent policy.    
    if (gbPersistentPolicyApplied) {
          SetSpdStateOnError(
                IPSEC_SOURCE_PERSISTENT,
                SPD_POLICY_APPLY,
                ERROR_SUCCESS,
                &pIpsecPolicyState->CurrentState
                );
    }        

    //
    // Calling the Initializer again.
    //

    dwError = StartStatePollingManager(
                  pIpsecPolicyState
                  );

    return (dwError);
}

DWORD
DeletePolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;


    if (!pIpsecPolicyData) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    dwError = DeleteMMPolicyInformation(pIpsecPolicyData);

    dwError = DeleteQMPolicyInformation(pIpsecPolicyData);

    dwError = ERROR_SUCCESS;

    return (dwError);
}


DWORD
DeleteMMPolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;


    dwError = PADeleteMMFilters(
                  pIpsecPolicyData->pIpsecISAKMPData,
                  pIpsecPolicyData->ppIpsecNFAData,
                  pIpsecPolicyData->dwNumNFACount
                  );

    dwError = PADeleteMMAuthMethods(
                  pIpsecPolicyData->ppIpsecNFAData,
                  pIpsecPolicyData->dwNumNFACount
                  );

    dwError = PADeleteMMPolicies(
                  &(pIpsecPolicyData->pIpsecISAKMPData),
                  1
                  );

    return (dwError);
}


DWORD
DeleteQMPolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    )
{
    DWORD dwError = 0;


    dwError = PADeleteQMFilters(
                  pIpsecPolicyData->ppIpsecNFAData,
                  pIpsecPolicyData->dwNumNFACount
                  );

    dwError = PADeleteQMPolicies(
                  pIpsecPolicyData->ppIpsecNFAData,
                  pIpsecPolicyData->dwNumNFACount
                  );

    return (dwError);
}


DWORD
DeleteAllPolicyInformation(
    )
{
    DWORD dwError = 0;

    TRACE(TRC_INFORMATION, (L"Deleting all policy information"));
    
    dwError = DeleteAllMMPolicyInformation();

    dwError = DeleteAllQMPolicyInformation();

    dwError = ERROR_SUCCESS;

    return (dwError);
}


DWORD
DeleteAllMMPolicyInformation(
    )
{
    DWORD dwError = 0;


    dwError = PADeleteAllMMFilters();

    dwError = PADeleteAllMMAuthMethods();

    dwError = PADeleteAllMMPolicies();

    return (dwError);
}


DWORD
DeleteAllQMPolicyInformation(
    )
{
    DWORD dwError = 0;


    dwError = PADeleteAllTxFilters();

    dwError = PADeleteAllTnFilters();

    dwError = PADeleteAllQMPolicies();

    return (dwError);
}


VOID
ClearPolicyStateBlock(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    if (pIpsecPolicyState->pIpsecPolicyObject) {
        FreeIpsecPolicyObject(
            pIpsecPolicyState->pIpsecPolicyObject
            );
        pIpsecPolicyState->pIpsecPolicyObject = NULL;
    }

    if (pIpsecPolicyState->pIpsecPolicyData) {
        FreeIpsecPolicyData(
            pIpsecPolicyState->pIpsecPolicyData
            );
        pIpsecPolicyState->pIpsecPolicyData = NULL;
    }

    if (pIpsecPolicyState->pszDirectoryPolicyDN) {
        FreeSPDStr(pIpsecPolicyState->pszDirectoryPolicyDN);
        pIpsecPolicyState->pszDirectoryPolicyDN = NULL;
    }

    pIpsecPolicyState->CurrentPollingInterval =  gDefaultPollingInterval;
    pIpsecPolicyState->DefaultPollingInterval =  gDefaultPollingInterval;
    pIpsecPolicyState->DSIncarnationNumber = 0;
    pIpsecPolicyState->RegIncarnationNumber = 0;
    pIpsecPolicyState->CurrentState = SPD_STATE_INITIAL;
}


DWORD
OnPolicyPoll(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;

    switch (pIpsecPolicyState->CurrentState) {
    case SPD_STATE_DS_APPLY_SUCCESS:
        // Tell group policy to refresh machine policy.
        // Our GP extension will ping us with NEW_DS_POLICY_EVENT
        // or GPUPDATE_REFRESH_EVENT when it's finished.

        TRACE(TRC_INFORMATION, (L"Requesting group policy to notify policy agent to check for policy changes."));
        RefreshPolicy(TRUE);
    break;

    case SPD_STATE_CACHE_APPLY_SUCCESS:
        dwError = ProcessCachePolicyPollState(pIpsecPolicyState);
    break;

    case SPD_STATE_LOCAL_APPLY_SUCCESS:
        dwError = ProcessLocalPolicyPollState(pIpsecPolicyState);
    break;

    case SPD_STATE_INITIAL:
    case SPD_STATE_PERSISTENT_APPLY_SUCCESS:
        // For these following states need to try to reload polcies from the start.
        //
        dwError = OnPolicyChanged(pIpsecPolicyState);
    break;
    
    case SPD_STATE_DS_APPLY_FAIL:
        // If DS apply failed, then still have loaded DS data so to reapply loaded data.
        //
        dwError = ApplyLoadedDirectoryPolicy(pIpsecPolicyState);
        
        // If error rollback. Ignoring rollback errors, because nothing can be done.
        //
        if (dwError) {
            TRACE(TRC_INFORMATION, ("Pastore rolling back policy application due to previous errors"));        
            (VOID) DeletePolicyInformation(
                  pIpsecPolicyState->pIpsecPolicyData
                  );
        }
    break;

    case SPD_STATE_LOCAL_APPLY_FAIL:
        // If apply failed, then still have loaded policy data so to reapply loaded data.
        //
        dwError = ApplyLoadedLocalPolicy(pIpsecPolicyState);
        
        // If error rollback. Ignoring rollback errors, because nothing can be done.
        //
        if (dwError) {
            TRACE(TRC_INFORMATION, ("Pastore rolling back policy application due to previous errors"));        
            (VOID) DeletePolicyInformation(
                  pIpsecPolicyState->pIpsecPolicyData
                  );
        }
    break;

    case SPD_STATE_LOCAL_LOAD_FAIL:
        dwError = PlumbLocalPolicy(pIpsecPolicyState);
    break;
    
    case SPD_STATE_DS_LOAD_FAIL:
    case SPD_STATE_CACHE_LOAD_FAIL:
    case SPD_STATE_CACHE_APPLY_FAIL:
    case SPD_STATE_CACHE_LOAD_SUCCESS:
        // if DS policy load failed so try to load *and* apply again.
        // In case of CACHE policy load/apply failue, little point in retrying again,
        // so directly try DS policy again.
        //
        dwError = PlumbDirectoryPolicy(pIpsecPolicyState);
    break;

    default:
            // Any other state is unexpected during polling
            // We should be in *APPLY_SUCCESS or *APPLY_FAIL or *LOAD_FAIL
            //    SPD_STATE_DS_LOAD_SUCCESS,
            //    SPD_STATE_LOCAL_LOAD_SUCCESS,
            //    SPD_STATE_PERSISTENT_LOAD_SUCCESS
            //    For the following errors we should have shutdown and not
            //    be here.
            //    SPD_STATE_PERSISTENT_LOAD_FAIL
            //    SPD_STATE_PERSISTENT_APPLY_FAIL

            ASSERT(FALSE);
    break;
    }

    //
    // Set the new polling interval.
    //

    gCurrentPollingInterval = pIpsecPolicyState->CurrentPollingInterval;
    TRACE(
        TRC_INFORMATION,
        ("Set global polling interval to %d",
        gCurrentPollingInterval)
        );

    if (InAcceptableState(pIpsecPolicyState->CurrentState)) {
        gdwRetryCount = 0;
    } else {
        gdwRetryCount++;
    }
    
    return (dwError);

}


DWORD
ProcessDirectoryPolicyPollState(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;
    DWORD dwIncarnationNumber = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD dwStoreType = IPSEC_DIRECTORY_PROVIDER;
    DWORD dwSlientErrorCode = 0;

    if (pIpsecPolicyState->CurrentState != SPD_STATE_DS_APPLY_SUCCESS) {
        TRACE(TRC_INFORMATION, (L"Pastore not checking whether directory policy has been modified because not in DS apply success."));
        return ERROR_SUCCESS;            
    }
        
    //
    // The directory policy DN has to be the same, otherwise the
    // IPSec extension in Winlogon would have already notified 
    // PA Store of the DS policy change.
    //
    TRACE(TRC_INFORMATION, (L"Pastore checking whether directory policy has been modified."));
    
    dwError = GetDirectoryIncarnationNumber(
                   pIpsecPolicyState->pszDirectoryPolicyDN,
                   &dwIncarnationNumber
                   );
    if (dwError) {
        dwError = MigrateFromDSToCache(pIpsecPolicyState);
        BAIL_ON_WIN32_ERROR(dwError);
        return (ERROR_SUCCESS);
    }

    if (dwIncarnationNumber == pIpsecPolicyState->DSIncarnationNumber) {

        //
        // The policy has not changed at all.
        //

        AuditEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_POLLING_NO_CHANGES,
            NULL,
            TRUE,
            TRUE
            );

        TRACE(TRC_INFORMATION, (L"Pastore did not detect any policy change."));        
          
        return (ERROR_SUCCESS);
    }

    //
    // The incarnation number is different, so there's a need to 
    // update the policy.
    //

    TRACE(TRC_INFORMATION, (L"Pastore detected that policy has been modified.  Performing policy update."));
    
    dwError = LoadDirectoryPolicy(
                  pIpsecPolicyState->pszDirectoryPolicyDN,
                  &pIpsecPolicyObject
                  );
    if (dwError) {
        dwError = MigrateFromDSToCache(pIpsecPolicyState);
        BAIL_ON_WIN32_ERROR(dwError);
        return (ERROR_SUCCESS);
    }

    dwError = ProcessNFAs(
                  pIpsecPolicyObject,
                  dwStoreType,
                  &dwSlientErrorCode,
                  &pIpsecPolicyData
                  );
    if (dwError) {
        TRACE(
            TRC_ERROR,
            (L"Pastore failure when processing NFAs.  Will migrate from directory to cache: %!winerr!",
            dwError)
            );
        dwError = MigrateFromDSToCache(pIpsecPolicyState);
        BAIL_ON_WIN32_ERROR(dwError);
        if (pIpsecPolicyObject) {
            FreeIpsecPolicyObject(pIpsecPolicyObject);
        }
        return (ERROR_SUCCESS);
    }

    dwError = UpdatePolicyInformation(
                  pIpsecPolicyState->pIpsecPolicyData,
                  pIpsecPolicyData,
                  IPSEC_SOURCE_DOMAIN
                  );

    if (pIpsecPolicyState->pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyState->pIpsecPolicyObject);
    }

    if (pIpsecPolicyState->pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyState->pIpsecPolicyData);
    }

    //
    // Now delete the old cache and write the new one in.
    //

    DeleteRegistryCache();

    CacheDirectorytoRegistry(pIpsecPolicyObject);

    pIpsecPolicyState->pIpsecPolicyObject = pIpsecPolicyObject;

    pIpsecPolicyState->pIpsecPolicyData = pIpsecPolicyData;

    pIpsecPolicyState->CurrentPollingInterval = pIpsecPolicyData->dwPollingInterval;

    pIpsecPolicyState->DSIncarnationNumber = dwIncarnationNumber;

    NotifyIpsecPolicyChange();

    dwError = ERROR_SUCCESS;
    if (dwSlientErrorCode) {
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_FAILED_SOME_NFA_APPLICATION,
            pIpsecPolicyData->pszIpsecName,
            dwSlientErrorCode,
            FALSE,
            TRUE
            );
        TRACE(
            TRC_WARNING,
            ("Pastore failed to process one or more NFAs. Please compare active policy in SPD with policy in storage: %!winerr!",
            dwSlientErrorCode)            
            );
    }
    AuditEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_POLLING_APPLIED_CHANGES,
        NULL,
        TRUE,
        TRUE
        );
    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        (L"Pastore failed when checking for policy change on poll: %!winerr!",
        dwError)
        );
    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    return (dwError);
}


DWORD
GetDirectoryIncarnationNumber(
    LPWSTR pszIpsecPolicyDN,
    DWORD * pdwIncarnationNumber
    )
{
    DWORD dwError = 0;
    LPWSTR pszDefaultDirectory = NULL;
    HLDAP hLdapBindHandle = NULL;
    LPWSTR Attributes[] = {L"whenChanged", NULL};
    LDAPMessage *res = NULL;
    LDAPMessage *e = NULL;
    WCHAR **strvalues = NULL;
    DWORD dwCount = 0;
    time_t t_WhenChanged = 0;


    *pdwIncarnationNumber = 0;

    //
    // Open the directory store.
    //

    dwError = ComputeDefaultDirectory(
                  &pszDefaultDirectory
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = OpenDirectoryServerHandle(
                  pszDefaultDirectory,
                  389,
                  &hLdapBindHandle
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapSearchST(
                  hLdapBindHandle,
                  pszIpsecPolicyDN,
                  LDAP_SCOPE_BASE,
                  L"(objectClass=*)",
                  Attributes,
                  0,
                  NULL,
                  &res
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapFirstEntry(
                  hLdapBindHandle,
                  res,
                  &e
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LdapGetValues(
                  hLdapBindHandle,
                  e,
                  L"whenChanged",
                  (WCHAR ***)&strvalues,
                  (int *)&dwCount
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = GeneralizedTimeToTime(
                LDAPOBJECT_STRING((PLDAPOBJECT)strvalues),
                &t_WhenChanged
                );
    BAIL_ON_WIN32_ERROR(dwError);                    

    *pdwIncarnationNumber = TIME_T_TO_DWORD(t_WhenChanged);

error:
#ifdef TRACE_ON
    if (dwError) {
        TRACE(TRC_ERROR, ("Pastore failed to get directory policy change date/time: %!winerr!", dwError));
    }
#endif
    

    if (pszDefaultDirectory) {
        FreeSPDStr(pszDefaultDirectory);
    }

    if (hLdapBindHandle) {
        CloseDirectoryServerHandle(hLdapBindHandle);
    }

    if (res) {
        LdapMsgFree(res);
    }

    if (strvalues) {
        LdapValueFree(strvalues);
    }

    return (dwError);
}


DWORD
MigrateFromDSToCache(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszCachePolicyDN = NULL;

    
    TRACE(TRC_INFORMATION, ("Migrating from directory to cache policy."));
    
    dwError = GetCachePolicyDN(
                  &pszCachePolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecPolicyState->pszDirectoryPolicyDN) {
        FreeSPDStr(pIpsecPolicyState->pszDirectoryPolicyDN);
        pIpsecPolicyState->pszDirectoryPolicyDN = NULL;
    }

    pIpsecPolicyState->pszCachePolicyDN = pszCachePolicyDN;

    //
    // Keep pIpsecPolicyState->pIpsecPolicyData.
    // Keep pIpsecPolicyState->pIpsecPolicyObject.
    // Change the incarnation numbers.
    //

    pIpsecPolicyState->RegIncarnationNumber = pIpsecPolicyState->DSIncarnationNumber;

    pIpsecPolicyState->DSIncarnationNumber = 0;

    SetSpdStateOnError(
        IPSEC_SOURCE_CACHE,
        SPD_POLICY_APPLY,
        ERROR_SUCCESS,
        &pIpsecPolicyState->CurrentState
        );

    //
    // Keep pIpsecPolicyState->CurrentPollingInterval.
    // Keep pIpsecPolicyState->DefaultPollingInterval.
    //

    gCurrentPollingInterval = pIpsecPolicyState->CurrentPollingInterval;
    TRACE(
        TRC_INFORMATION,
        ("Set global polling interval to %d",
        gCurrentPollingInterval)
        );

    AuditEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_MIGRATE_DS_TO_CACHE,
        NULL,
        TRUE,
        TRUE
        );
    TRACE(TRC_INFORMATION, (L"Pastore migrated from cache to directory policy."));
error:

    return (dwError);
}


DWORD
ProcessCachePolicyPollState(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszDirectoryPolicyDN = NULL;
    DWORD dwIncarnationNumber = 0;
    LPWSTR pszCachePolicyDN = NULL;

    TRACE(TRC_INFORMATION, (L"Detecting if cache change time is different from directory change time."));
    
    dwError = GetDirectoryPolicyDN(
                  &pszDirectoryPolicyDN
                  );

    if (!dwError) {

        dwError = GetDirectoryIncarnationNumber(
                      pszDirectoryPolicyDN,
                      &dwIncarnationNumber
                      );

        if (!dwError) {

            dwError = CopyPolicyDSToFQRegString(
                          pszDirectoryPolicyDN,
                          &pszCachePolicyDN
                          );

            if (!dwError) {

                if (!_wcsicmp(pIpsecPolicyState->pszCachePolicyDN, pszCachePolicyDN)) {

                    if (pIpsecPolicyState->RegIncarnationNumber == dwIncarnationNumber) {
                        dwError = MigrateFromCacheToDS(pIpsecPolicyState);
                    }
                    else {
                        dwError = UpdateFromCacheToDS(pIpsecPolicyState);
                    }

                    if (dwError) {
                        dwError = OnPolicyChanged(pIpsecPolicyState);
                    }

                }
                else {

                    dwError = OnPolicyChanged(pIpsecPolicyState);

                }

            }

        }

    }

    if (pszDirectoryPolicyDN) {
        FreeSPDStr(pszDirectoryPolicyDN);
    }

    if (pszCachePolicyDN) {
        FreeSPDStr(pszCachePolicyDN);
    }

    return (ERROR_SUCCESS);
}


DWORD
MigrateFromCacheToDS(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszDirectoryPolicyDN = NULL;


    dwError = GetDirectoryPolicyDN(
                  &pszDirectoryPolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIpsecPolicyState->pszCachePolicyDN) {
        FreeSPDStr(pIpsecPolicyState->pszCachePolicyDN);
        pIpsecPolicyState->pszCachePolicyDN = NULL;
    }

    pIpsecPolicyState->pszDirectoryPolicyDN = pszDirectoryPolicyDN; 

    //
    // Keep pIpsecPolicyState->pIpsecPolicyData.
    // Keep pIpsecPolicyState->pIpsecPolicyObject.
    // Change the incarnation numbers.
    //

    pIpsecPolicyState->DSIncarnationNumber = pIpsecPolicyState->RegIncarnationNumber;

    pIpsecPolicyState->RegIncarnationNumber = 0;

    SetSpdStateOnError(
        IPSEC_SOURCE_DOMAIN,
        SPD_POLICY_APPLY,
        ERROR_SUCCESS,
        &pIpsecPolicyState->CurrentState
        );

    //
    // Keep pIpsecPolicyState->CurrentPollingInterval.
    // Keep pIpsecPolicyState->DefaultPollingInterval.
    //

    gCurrentPollingInterval = pIpsecPolicyState->CurrentPollingInterval;

    AuditEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_MIGRATE_CACHE_TO_DS,
        NULL,
        TRUE,
        TRUE
        );

error:

    return (dwError);
}


DWORD
UpdateFromCacheToDS(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwError = 0;
    LPWSTR pszDirectoryPolicyDN = NULL;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD dwStoreType = IPSEC_DIRECTORY_PROVIDER;
    DWORD dwSlientErrorCode = 0;

    TRACE(TRC_INFORMATION, (L"Detect difference between plumbed cache, and directory policy.  Updating plumbed policy."));

    dwError = GetDirectoryPolicyDN(
                  &pszDirectoryPolicyDN
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = LoadDirectoryPolicy(
                  pszDirectoryPolicyDN,
                  &pIpsecPolicyObject
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ProcessNFAs(
                  pIpsecPolicyObject,
                  dwStoreType,
                  &dwSlientErrorCode,
                  &pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UpdatePolicyInformation(
                  pIpsecPolicyState->pIpsecPolicyData,
                  pIpsecPolicyData,
                  IPSEC_SOURCE_DOMAIN
                  );

    if (pIpsecPolicyState->pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyState->pIpsecPolicyObject);
    }

    if (pIpsecPolicyState->pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyState->pIpsecPolicyData);
    }

    if (pIpsecPolicyState->pszCachePolicyDN) {
        FreeSPDStr(pIpsecPolicyState->pszCachePolicyDN);
    }

    //
    // Now delete the old cache and write the new one in.
    //

    DeleteRegistryCache();

    CacheDirectorytoRegistry(pIpsecPolicyObject);

    pIpsecPolicyState->pIpsecPolicyObject = pIpsecPolicyObject;

    pIpsecPolicyState->pIpsecPolicyData = pIpsecPolicyData;

    pIpsecPolicyState->pszDirectoryPolicyDN = pszDirectoryPolicyDN;

    //
    // Set the state to DS-DOWNLOADED.
    //

    SetSpdStateOnError(
        IPSEC_SOURCE_DOMAIN,
        SPD_POLICY_APPLY,
        ERROR_SUCCESS,
        &pIpsecPolicyState->CurrentState
        );

    //
    // Compute the new polling interval.
    //

    pIpsecPolicyState->CurrentPollingInterval =  pIpsecPolicyData->dwPollingInterval;

    pIpsecPolicyState->DSIncarnationNumber = pIpsecPolicyData->dwWhenChanged;

    pIpsecPolicyState->RegIncarnationNumber = 0;

    gCurrentPollingInterval = pIpsecPolicyState->CurrentPollingInterval;

    NotifyIpsecPolicyChange();

    dwError = ERROR_SUCCESS;
    if (dwSlientErrorCode) {
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_FAILED_SOME_NFA_APPLICATION,
            pIpsecPolicyData->pszIpsecName,
            dwSlientErrorCode,
            FALSE,
            TRUE
            );
        TRACE(
            TRC_WARNING,
            ("Pastore failed to process one or more NFAs. Please compare active policy in SPD with policy in storage: %!winerr!",
            dwSlientErrorCode)            
            );
    }
    AuditEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_UPDATE_CACHE_TO_DS,
        NULL,
        TRUE,
        TRUE
        );
    return (dwError);

error:

    if (pszDirectoryPolicyDN) {
        FreeSPDStr(pszDirectoryPolicyDN);
    }

    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    return (dwError);
}


DWORD
ProcessLocalPolicyPollState(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    )
{
    DWORD dwStatus = 0;
    LPWSTR pszDirectoryPolicyDN = NULL;
    DWORD dwDSIncarnationNumber = 0;
    DWORD dwError = 0;
    BOOL bChanged = FALSE;
    DWORD dwIncarnationNumber = 0;
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject = NULL;
    PIPSEC_POLICY_DATA pIpsecPolicyData = NULL;
    DWORD dwStoreType = IPSEC_REGISTRY_PROVIDER;
    DWORD dwSlientErrorCode = 0;
    
    TRACE(TRC_INFORMATION, (L"Pastore checking whether local policy assignment has changed."));
    dwStatus = GetDirectoryPolicyDN(
                   &pszDirectoryPolicyDN
                   );
    if (!dwStatus) {

        dwStatus = GetDirectoryIncarnationNumber(
                       pszDirectoryPolicyDN,
                       &dwDSIncarnationNumber
                       );
        if (pszDirectoryPolicyDN) {
            FreeSPDStr(pszDirectoryPolicyDN);
        }
        if (!dwStatus) {
            dwStatus = OnPolicyChanged(pIpsecPolicyState);
            return (dwStatus);
        }

    }

    dwError = HasRegistryPolicyChanged(
                  pIpsecPolicyState->pszRegistryPolicyDN,
                  &bChanged
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (bChanged) {

        dwError = OnPolicyChanged(pIpsecPolicyState);
        return (dwError);

    }

    if (pIpsecPolicyState->CurrentState == SPD_STATE_INITIAL) {
        return (ERROR_SUCCESS);
    }

    dwError = GetRegistryIncarnationNumber(
                  pIpsecPolicyState->pszRegistryPolicyDN,
                  &dwIncarnationNumber
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwIncarnationNumber == pIpsecPolicyState->RegIncarnationNumber) {

        //
        // The policy has not changed at all.
        //

        AuditEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_POLLING_NO_CHANGES,
            NULL,
            TRUE,
            TRUE
            );

            TRACE(TRC_INFORMATION, (L"Pastore did not detect any policy change."));
        return (ERROR_SUCCESS);
    }

    TRACE(TRC_INFORMATION, (L"Pastore detected that policy has been modified.  Performing policy update."));
    dwError = LoadRegistryPolicy(
                  pIpsecPolicyState->pszRegistryPolicyDN,
                  &pIpsecPolicyObject,
                  IPSEC_STORE_LOCAL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ProcessNFAs(
                  pIpsecPolicyObject,
                  dwStoreType,
                  &dwSlientErrorCode,
                  &pIpsecPolicyData
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = UpdatePolicyInformation(
                  pIpsecPolicyState->pIpsecPolicyData,
                  pIpsecPolicyData,
                  IPSEC_SOURCE_LOCAL
                  );

    if (pIpsecPolicyState->pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyState->pIpsecPolicyObject);
    }

    if (pIpsecPolicyState->pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyState->pIpsecPolicyData);
    }

    pIpsecPolicyState->pIpsecPolicyObject = pIpsecPolicyObject;

    pIpsecPolicyState->pIpsecPolicyData = pIpsecPolicyData;

    pIpsecPolicyState->CurrentPollingInterval = pIpsecPolicyData->dwPollingInterval;

    pIpsecPolicyState->RegIncarnationNumber = dwIncarnationNumber;

    NotifyIpsecPolicyChange();

    dwError = ERROR_SUCCESS;
    if (dwSlientErrorCode) {
        AuditIPSecPolicyErrorEvent(
            SE_CATEGID_POLICY_CHANGE,
            SE_AUDITID_IPSEC_POLICY_CHANGED,
            PASTORE_FAILED_SOME_NFA_APPLICATION,
            pIpsecPolicyData->pszIpsecName,
            dwSlientErrorCode,
            FALSE,
            TRUE
            );
        TRACE(
            TRC_WARNING,
            ("Pastore failed to process one or more NFAs. Please compare active policy in SPD with policy in storage: %!winerr!",
            dwSlientErrorCode )           
            );
        
    }
    AuditEvent(
        SE_CATEGID_POLICY_CHANGE,
        SE_AUDITID_IPSEC_POLICY_CHANGED,
        PASTORE_POLLING_APPLIED_CHANGES,
        NULL,
        TRUE,
        TRUE
        );
    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        (L"Pastore failed when checking for policy change on poll: %!winerr!",
        dwError)
        );
    
    if (pIpsecPolicyObject) {
        FreeIpsecPolicyObject(pIpsecPolicyObject);
    }

    if (pIpsecPolicyData) {
        FreeIpsecPolicyData(pIpsecPolicyData);
    }

    return (dwError);
}


DWORD
HasRegistryPolicyChanged(
    LPWSTR pszCurrentPolicyDN,
    PBOOL pbChanged
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    LPWSTR  pszIpsecPolicyName = NULL;
    DWORD dwSize = 0;
    BOOL bChanged = FALSE;


    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  gpszIpsecLocalPolicyKey,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegstoreQueryValue(
                  hRegKey,
                  L"ActivePolicy",
                  REG_SZ,
                  (LPBYTE *)&pszIpsecPolicyName,
                  &dwSize
                  );
    //
    // Must not bail from here, as there can be no
    // active local policy.
    //

    if (pszIpsecPolicyName && *pszIpsecPolicyName) {

        if (!pszCurrentPolicyDN || !*pszCurrentPolicyDN) {
            bChanged = TRUE;
        }
        else {

            if (!_wcsicmp(pszIpsecPolicyName, pszCurrentPolicyDN)) {
                bChanged = FALSE;
            }
            else {
                bChanged = TRUE;
            }

        }

    }
    else {
        if (!pszCurrentPolicyDN || !*pszCurrentPolicyDN) {
            bChanged = FALSE;
        }
        else {
            bChanged = TRUE;
        }
    }

    *pbChanged = bChanged;
    dwError = ERROR_SUCCESS;

cleanup:

    if (hRegKey) {
        CloseHandle(hRegKey);
    }

    if (pszIpsecPolicyName) {
        FreeSPDStr(pszIpsecPolicyName);
    }

    return (dwError);

error:
    TRACE(TRC_ERROR, ("Pastore failed when trying to detect if local policy assigment has changed: %!winerr!", dwError));    
    
    *pbChanged = FALSE;

    goto cleanup;
}


DWORD
GetRegistryIncarnationNumber(
    LPWSTR pszIpsecPolicyDN,
    DWORD * pdwIncarnationNumber
    )
{
    DWORD dwError = 0;
    HKEY hRegKey = NULL;
    DWORD dwType = REG_DWORD;
    DWORD dwWhenChanged = 0;
    DWORD dwSize = sizeof(DWORD);


    *pdwIncarnationNumber = 0;

    dwError = RegOpenKeyExW(
                  HKEY_LOCAL_MACHINE,
                  pszIpsecPolicyDN,
                  0,
                  KEY_ALL_ACCESS,
                  &hRegKey
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = RegQueryValueExW(
                  hRegKey,
                  L"whenChanged",
                  NULL,
                  &dwType,
                  (LPBYTE)&dwWhenChanged,
                  &dwSize
                  );
    BAIL_ON_WIN32_ERROR(dwError);

     *pdwIncarnationNumber = dwWhenChanged;

error:
#ifdef TRACE_ON
    if (dwError) {
        TRACE(TRC_ERROR, ("Pastore failed to get registry change date/time: %!winerr!", dwError));
    }
#endif

    if (hRegKey) {
        CloseHandle(hRegKey);
    }

    return(dwError);
}


DWORD
UpdatePolicyInformation(
    PIPSEC_POLICY_DATA pOldIpsecPolicyData,
    PIPSEC_POLICY_DATA pNewIpsecPolicyData,
    IN DWORD dwSource
    )
{
    DWORD dwError = 0;
    PIPSEC_ISAKMP_DATA pOldIpsecISAKMPData = NULL;
    PIPSEC_NFA_DATA * ppOldIpsecNFAData = NULL;
    DWORD dwNumOldNFACount = 0;
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData = NULL;
    PIPSEC_NFA_DATA * ppNewIpsecNFAData = NULL;
    DWORD dwNumNewNFACount = 0;


    pOldIpsecISAKMPData = pOldIpsecPolicyData->pIpsecISAKMPData;
    ppOldIpsecNFAData = pOldIpsecPolicyData->ppIpsecNFAData;
    dwNumOldNFACount = pOldIpsecPolicyData->dwNumNFACount;

    pNewIpsecISAKMPData = pNewIpsecPolicyData->pIpsecISAKMPData;
    ppNewIpsecNFAData = pNewIpsecPolicyData->ppIpsecNFAData;
    dwNumNewNFACount = pNewIpsecPolicyData->dwNumNFACount;


    TRACE(
        TRC_INFORMATION,
        (L"Pastore performing policy update")
        );
        
    dwError = PADeleteObseleteISAKMPData(
                  &pOldIpsecISAKMPData,
                  1,
                  ppOldIpsecNFAData,
                  dwNumOldNFACount,
                  &pNewIpsecISAKMPData,
                  1
                  );

    dwError = PAUpdateISAKMPData(
                  &pNewIpsecISAKMPData,
                  1,
                  ppOldIpsecNFAData,
                  dwNumOldNFACount,
                  &pOldIpsecISAKMPData,
                  1,
                  dwSource
                  );

    dwError = PADeleteObseleteNFAData(
                  pNewIpsecISAKMPData,
                  ppOldIpsecNFAData,
                  dwNumOldNFACount,
                  ppNewIpsecNFAData,
                  dwNumNewNFACount
                  );

    dwError = PAUpdateNFAData(
                  pNewIpsecISAKMPData,
                  ppNewIpsecNFAData,
                  dwNumNewNFACount,
                  ppOldIpsecNFAData,
                  dwNumOldNFACount,
                  dwSource
                  );

    return (dwError);
}


DWORD
LoadDefaultISAKMPInformation(
    LPWSTR pszDefaultISAKMPDN
    )
{
    DWORD dwError = 0;

    gbLoadedISAKMPDefaults = TRUE;

    return (dwError);
}


VOID
UnLoadDefaultISAKMPInformation(
    LPWSTR pszDefaultISAKMPDN
    )
{
    return;
}

BOOL
IsDirectoryPolicySpecified(
    )
{
    DWORD dwError = ERROR_SUCCESS;
    LPWSTR pszDirectoryPolicyDN = NULL;

    dwError = GetDirectoryPolicyDN(
                  &pszDirectoryPolicyDN
                  );
    if (pszDirectoryPolicyDN) {
        FreeSPDStr(pszDirectoryPolicyDN);
    }

    if (dwError) {
        return FALSE;
    } else {
        return TRUE;
    }
}

BOOL
IsLocalPolicySpecified(
    )
{
    DWORD dwError = ERROR_SUCCESS;
    LPWSTR pszRegistryPolicyDN = NULL;

    dwError = GetRegistryPolicyDN(
                  &pszRegistryPolicyDN,
                  IPSEC_STORE_LOCAL
                  );    

    if (pszRegistryPolicyDN) {
        FreeSPDStr(pszRegistryPolicyDN);
    }

    if (dwError) {
        return FALSE;
    } else {
        return TRUE;
    }
}    

BOOL
IsPersistentPolicySpecified(
    )
{
    DWORD dwError = ERROR_SUCCESS;
    LPWSTR pszRegistryPolicyDN = NULL;

    dwError = GetRegistryPolicyDN(
                  &pszRegistryPolicyDN,
                  IPSEC_STORE_PERSISTENT
                  );    

    if (pszRegistryPolicyDN) {
        FreeSPDStr(pszRegistryPolicyDN);
    }

    if (dwError) {
        return FALSE;
    } else {
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\pammauth.c ===
#include "precomp.h"
#ifdef TRACE_ON
#include "pammauth.tmh"
#endif


DWORD
PAAddMMAuthMethods(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount,
    IN DWORD dwSource
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PMMAUTHSTATE pMMAuthState = NULL;
    PINT_MM_AUTH_METHODS pSPDMMAuthMethods = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwVersion = 0;


    for (i = 0; i < dwNumNFACount; i++) {
        TRACE(
            TRC_INFORMATION,
            (L"Pastore adding MM auth methods based on rule %!guid!",
            &(*(ppIpsecNFAData + i))->NFAIdentifier)
            );

        dwError = PACreateMMAuthState(
                      *(ppIpsecNFAData + i),
                      &pMMAuthState
                      );
        if (dwError) {
            continue;
        }

        dwError = PACreateMMAuthMethods(
                      *(ppIpsecNFAData + i),
                      &pSPDMMAuthMethods
                      );
        if (dwError) {

            pMMAuthState->bInSPD = FALSE;
            pMMAuthState->dwErrorCode = dwError;

            pMMAuthState->pNext = gpMMAuthState;
            gpMMAuthState = pMMAuthState;

            continue;

        }

        dwError = IntAddMMAuthMethods(
                      pServerName,
                      dwVersion,
                      0,
                      dwSource,
                      pSPDMMAuthMethods,
                      NULL
                      );
        if (dwError) {
            pMMAuthState->bInSPD = FALSE;
            pMMAuthState->dwErrorCode = dwError;
        }
        else {
            pMMAuthState->bInSPD = TRUE;
            pMMAuthState->dwErrorCode = ERROR_SUCCESS;
        }

        pMMAuthState->pNext = gpMMAuthState;
        gpMMAuthState = pMMAuthState;

        PAFreeMMAuthMethods(pSPDMMAuthMethods);

    }

    return (dwError);
}


DWORD
PACreateMMAuthState(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PMMAUTHSTATE * ppMMAuthState
    )
{
    DWORD dwError = 0;
    PMMAUTHSTATE pMMAuthState = NULL;


    dwError = AllocateSPDMemory(
                  sizeof(MMAUTHSTATE),
                  &pMMAuthState
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pMMAuthState->gMMAuthID),
        &(pIpsecNFAData->NFAIdentifier),
        sizeof(GUID)
        );

    pMMAuthState->bInSPD = FALSE;
    pMMAuthState->dwErrorCode = 0;
    pMMAuthState->pNext = NULL;

    *ppMMAuthState = pMMAuthState;

    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        ("Pastore failed to create MM auth method state for rule %!guid!: %!winerr!",
        &pIpsecNFAData->NFAIdentifier,
        dwError)
        );
    
    *ppMMAuthState = NULL;

    return (dwError);
}


DWORD
PACreateMMAuthMethods(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PINT_MM_AUTH_METHODS * ppSPDMMAuthMethods
    )
{
    DWORD dwError = 0;
    DWORD dwAuthMethodCount = 0;
    PIPSEC_AUTH_METHOD * ppAuthMethods = NULL;
    PINT_MM_AUTH_METHODS pSPDMMAuthMethods = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;


    dwAuthMethodCount = pIpsecNFAData->dwAuthMethodCount;
    ppAuthMethods = pIpsecNFAData->ppAuthMethods;

    if (!dwAuthMethodCount || !ppAuthMethods) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    } 

    dwError = AllocateSPDMemory(
                  sizeof(INT_MM_AUTH_METHODS),
                  &pSPDMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pSPDMMAuthMethods->gMMAuthID),
        &(pIpsecNFAData->NFAIdentifier),
        sizeof(GUID)
        );

    pSPDMMAuthMethods->dwFlags = 0;

    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    if (!memcmp(
            &(pIpsecNegPolData->NegPolType),
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {
        pSPDMMAuthMethods->dwFlags |= IPSEC_MM_AUTH_DEFAULT_AUTH;
    }

    dwError = PACreateMMAuthInfos(
                  dwAuthMethodCount,
                  ppAuthMethods,
                  &(pSPDMMAuthMethods->dwNumAuthInfos),
                  &(pSPDMMAuthMethods->pAuthenticationInfo)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppSPDMMAuthMethods = pSPDMMAuthMethods;
    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        ("Pastore failed to create MM auth methods for rule %!guid!: %!winerr!",
        &pIpsecNFAData->NFAIdentifier,
        dwError)
        );

    if (pSPDMMAuthMethods) {
        PAFreeMMAuthMethods(pSPDMMAuthMethods);
    }

    *ppSPDMMAuthMethods = NULL;
    return (dwError);
}


DWORD
PACreateMMAuthInfos(
    DWORD dwAuthMethodCount,
    PIPSEC_AUTH_METHOD * ppAuthMethods,
    PDWORD pdwNumAuthInfos,
    PINT_IPSEC_MM_AUTH_INFO * ppAuthenticationInfo
    )
{
    DWORD dwError = 0;
    PINT_IPSEC_MM_AUTH_INFO pAuthenticationInfo = NULL;
    PINT_IPSEC_MM_AUTH_INFO pTemp = NULL;
    PIPSEC_AUTH_METHOD pAuthMethod = NULL;
    DWORD i = 0;


    //
    // dwAuthMethodCount is not zero at this point.
    // ppAuthMethods is not null at this point.
    //

    dwError = AllocateSPDMemory(
                  sizeof(INT_IPSEC_MM_AUTH_INFO)*dwAuthMethodCount,
                  &(pAuthenticationInfo)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pAuthenticationInfo;

    for (i = 0; i < dwAuthMethodCount; i++) {

        pAuthMethod = *(ppAuthMethods + i);

        pTemp->AuthMethod = (MM_AUTH_ENUM) pAuthMethod->dwAuthType;

        switch(pTemp->AuthMethod) {

        case IKE_SSPI:

            pTemp->dwAuthInfoSize = 0;
            pTemp->pAuthInfo = NULL;
            break;

        case IKE_RSA_SIGNATURE:

            if (pAuthMethod->dwAltAuthLen && pAuthMethod->pAltAuthMethod) {

                dwError = AllocateSPDMemory(
                              pAuthMethod->dwAltAuthLen,
                              &(pTemp->pAuthInfo)
                              );
                BAIL_ON_WIN32_ERROR(dwError);
                pTemp->dwAuthInfoSize = pAuthMethod->dwAltAuthLen;

                //
                // Need to catch the exception when the size of auth info
                // specified is more than the actual size.
                //
                //

                memcpy(
                    pTemp->pAuthInfo,
                    pAuthMethod->pAltAuthMethod,
                    pAuthMethod->dwAltAuthLen
                    );
            }
            else {

                if (!(pAuthMethod->dwAuthLen) || !(pAuthMethod->pszAuthMethod)) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);
                }
                dwError = EncodeName(
                              pAuthMethod->pszAuthMethod,
                              &pTemp->pAuthInfo,
                              &pTemp->dwAuthInfoSize
                              );
                BAIL_ON_WIN32_ERROR(dwError);

            }
            pTemp->dwAuthFlags = pAuthMethod->dwAuthFlags;

            break;

        default:

            if (!(pAuthMethod->dwAuthLen) || !(pAuthMethod->pszAuthMethod)) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);
            }
            dwError = AllocateSPDMemory(
                          (pAuthMethod->dwAuthLen)*sizeof(WCHAR),
                          &(pTemp->pAuthInfo)
                          );
            BAIL_ON_WIN32_ERROR(dwError);
            pTemp->dwAuthInfoSize = (pAuthMethod->dwAuthLen)*sizeof(WCHAR);

            //
            // Need to catch the exception when the size of auth info
            // specified is more than the actual size.
            //
            //

            memcpy(
                pTemp->pAuthInfo,
                (LPBYTE) pAuthMethod->pszAuthMethod,
                (pAuthMethod->dwAuthLen)*sizeof(WCHAR)
                );
            break;

        }

        pTemp++;

    }

    *pdwNumAuthInfos = dwAuthMethodCount;
    *ppAuthenticationInfo = pAuthenticationInfo;
    return (dwError);

error:

    if (pAuthenticationInfo) {
        PAFreeMMAuthInfos(
            i,
            pAuthenticationInfo
            );
    }

    *pdwNumAuthInfos = 0;
    *ppAuthenticationInfo = NULL;
    return (dwError);
}


VOID
PAFreeMMAuthMethods(
    PINT_MM_AUTH_METHODS pSPDMMAuthMethods
    )
{
    if (pSPDMMAuthMethods) {

        PAFreeMMAuthInfos(
            pSPDMMAuthMethods->dwNumAuthInfos,
            pSPDMMAuthMethods->pAuthenticationInfo
            );

        FreeSPDMemory(pSPDMMAuthMethods);

    }
}


VOID
PAFreeMMAuthInfos(
    DWORD dwNumAuthInfos,
    PINT_IPSEC_MM_AUTH_INFO pAuthenticationInfo
    )
{
    DWORD i = 0;
    PINT_IPSEC_MM_AUTH_INFO pTemp = NULL;


    if (pAuthenticationInfo) {

        pTemp = pAuthenticationInfo;

        for (i = 0; i < dwNumAuthInfos; i++) {
            if (pTemp->pAuthInfo) {
                FreeSPDMemory(pTemp->pAuthInfo);
            }
            pTemp++;
        }

        FreeSPDMemory(pAuthenticationInfo);

    }
}


DWORD
PADeleteAllMMAuthMethods(
    )
{
    DWORD dwError = 0;
    PMMAUTHSTATE pMMAuthState = NULL;
    LPWSTR pServerName = NULL;
    PMMAUTHSTATE pTemp = NULL;
    PMMAUTHSTATE pLeftMMAuthState = NULL;
    DWORD dwVersion = 0;

    TRACE(TRC_INFORMATION, (L"Pastore deleting all MM auth methods."));

    pMMAuthState = gpMMAuthState;

    while (pMMAuthState) {

        if (pMMAuthState->bInSPD) {

            dwError = DeleteMMAuthMethods(
                          pServerName,
                          dwVersion,
                          pMMAuthState->gMMAuthID,
                          NULL
                          );
            if (!dwError) {
                pTemp = pMMAuthState;
                pMMAuthState = pMMAuthState->pNext;
                FreeSPDMemory(pTemp);
            } 
            else {
                pMMAuthState->dwErrorCode = dwError;

                pTemp = pMMAuthState;
                pMMAuthState = pMMAuthState->pNext;

                pTemp->pNext = pLeftMMAuthState;
                pLeftMMAuthState = pTemp;
            }

        }
        else {

            pTemp = pMMAuthState;
            pMMAuthState = pMMAuthState->pNext;
            FreeSPDMemory(pTemp);

        }

    }

    gpMMAuthState = pLeftMMAuthState;
    
    return (dwError);
}


VOID
PAFreeMMAuthStateList(
    PMMAUTHSTATE pMMAuthState
    )
{
    PMMAUTHSTATE pTemp = NULL;


    while (pMMAuthState) {

        pTemp = pMMAuthState;
        pMMAuthState = pMMAuthState->pNext;
        FreeSPDMemory(pTemp);

    }
}


PMMAUTHSTATE
FindMMAuthState(
    GUID gMMAuthID
    )
{
    PMMAUTHSTATE pMMAuthState = NULL;


    pMMAuthState = gpMMAuthState;

    while (pMMAuthState) {

        if (!memcmp(&(pMMAuthState->gMMAuthID), &gMMAuthID, sizeof(GUID))) {
            return (pMMAuthState);
        }

        pMMAuthState = pMMAuthState->pNext;

    }

    return (NULL);
}


DWORD
PADeleteMMAuthMethods(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;


    for (i = 0; i < dwNumNFACount; i++) {

        pIpsecNFAData = *(ppIpsecNFAData + i);

        dwError = PADeleteMMAuthMethod(
                      pIpsecNFAData->NFAIdentifier
                      );

    }

    return (dwError);
}


DWORD
PADeleteMMAuthMethod(
    GUID gMMAuthID
    )
{
    DWORD dwError = 0;
    PMMAUTHSTATE pMMAuthState = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwVersion = 0;

    TRACE(
        TRC_INFORMATION,
        (L"Pastore deleting MM auth method %!guid!",
        &gMMAuthID)
        );

    pMMAuthState = FindMMAuthState(
                       gMMAuthID
                       );
    if (!pMMAuthState) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if (pMMAuthState->bInSPD) {

        dwError = DeleteMMAuthMethods(
                      pServerName,
                      dwVersion,
                      pMMAuthState->gMMAuthID,
                      NULL
                      );
        if (dwError) {
            pMMAuthState->dwErrorCode = dwError;
        }
        BAIL_ON_WIN32_ERROR(dwError);

    }

    PADeleteMMAuthState(pMMAuthState);

error:

    return (dwError);
}


VOID
PADeleteMMAuthState(
    PMMAUTHSTATE pMMAuthState
    )
{
    PMMAUTHSTATE * ppTemp = NULL;


    ppTemp = &gpMMAuthState;

    while (*ppTemp) {

        if (*ppTemp == pMMAuthState) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);

    }

    if (*ppTemp) {
        *ppTemp = pMMAuthState->pNext;
    }

    FreeSPDMemory(pMMAuthState);

    return;
}


DWORD
PADeleteInUseMMAuthMethods(
    )
{
    DWORD dwError = 0;
    PMMAUTHSTATE pMMAuthState = NULL;
    LPWSTR pServerName = NULL;
    PMMAUTHSTATE pTemp = NULL;
    PMMAUTHSTATE pLeftMMAuthState = NULL;
    DWORD dwVersion = 0;

    TRACE(TRC_INFORMATION, (L"Pastore deleting in-use MM auth methods."));
    
    pMMAuthState = gpMMAuthState;

    while (pMMAuthState) {

        if (pMMAuthState->bInSPD &&
            (pMMAuthState->dwErrorCode == ERROR_IPSEC_MM_AUTH_IN_USE)) {

            dwError = DeleteMMAuthMethods(
                          pServerName,
                          dwVersion,
                          pMMAuthState->gMMAuthID,
                          NULL
                          );
            if (!dwError) {
                pTemp = pMMAuthState;
                pMMAuthState = pMMAuthState->pNext;
                FreeSPDMemory(pTemp);
            }
            else {
                pTemp = pMMAuthState;
                pMMAuthState = pMMAuthState->pNext;

                pTemp->pNext = pLeftMMAuthState;
                pLeftMMAuthState = pTemp;
            }

        }
        else {

            pTemp = pMMAuthState;
            pMMAuthState = pMMAuthState->pNext;

            pTemp->pNext = pLeftMMAuthState;
            pLeftMMAuthState = pTemp;

        }

    }

    gpMMAuthState = pLeftMMAuthState;

    return (dwError);
}


DWORD
EncodeName(
    LPWSTR pszSubjectName,
    PBYTE * ppEncodedName,
    PDWORD pdwEncodedLength
    )
{
    DWORD dwError = ERROR_SUCCESS;


    *ppEncodedName = NULL;
    *pdwEncodedLength = 0;


    if (!CertStrToName(
             X509_ASN_ENCODING,
             pszSubjectName,
             CERT_X500_NAME_STR,
             NULL,
             NULL,
             pdwEncodedLength,
             NULL)) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!*pdwEncodedLength) {
        dwError = ERROR_INVALID_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = AllocateSPDMemory(
                  *pdwEncodedLength,
                  (PVOID) ppEncodedName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!CertStrToName(
             X509_ASN_ENCODING,
             pszSubjectName,
             CERT_X500_NAME_STR,
             NULL,
             (*ppEncodedName),
             pdwEncodedLength,
             NULL)) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    return (dwError);

error:

    if (*ppEncodedName) {
        FreeSPDMemory(*ppEncodedName);
        *ppEncodedName = NULL;
    }
    *pdwEncodedLength = 0;

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\paqm-pol.c ===
#include "precomp.h"
#ifdef TRACE_ON
#include "paqm-pol.tmh"
#endif

   
DWORD
PAAddQMPolicies(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PQMPOLICYSTATE pQMPolicyState = NULL;
    PIPSEC_QM_POLICY pSPDQMPolicy = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwVersion = 0;


    for (i = 0; i < dwNumNFACount; i++) {

        pIpsecNFAData = *(ppIpsecNFAData + i);
        pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

        TRACE(
            TRC_INFORMATION,
            (L"Pastore adding QM policy based on Neg pol data %!guid!",
            &pIpsecNegPolData->NegPolIdentifier)
            );

        pQMPolicyState = FindQMPolicyState(
                             pIpsecNegPolData->NegPolIdentifier
                             );
        if (pQMPolicyState) {
            pQMPolicyState->cRef++;
            continue;
        }

        dwError = PACreateQMPolicyState(
                      *(ppIpsecNFAData + i),
                      &pQMPolicyState
                      );
        if (dwError) {
            continue;
        }

        if (IsClearOnly(pQMPolicyState->gNegPolAction) ||
            IsBlocking(pQMPolicyState->gNegPolAction)) {

            pQMPolicyState->bInSPD = FALSE;
            pQMPolicyState->dwErrorCode = 0;

            pQMPolicyState->pNext = gpQMPolicyState;
            gpQMPolicyState = pQMPolicyState;

            continue;

        }

        dwError = PACreateQMPolicy(
                      *(ppIpsecNFAData + i),
                      pQMPolicyState,
                      &pSPDQMPolicy
                      );
        if (dwError) {

            pQMPolicyState->bInSPD = FALSE;
            pQMPolicyState->dwErrorCode = dwError;

            pQMPolicyState->pNext = gpQMPolicyState;
            gpQMPolicyState = pQMPolicyState;

            continue;

        }

        dwError = AddQMPolicyInternal(
                      pServerName,
                      dwVersion,
                      0,
                      dwSource,
                      pSPDQMPolicy,
                      NULL
                      );
        if (dwError && dwError != WARNING_IPSEC_QM_POLICY_PRUNED) {
            pQMPolicyState->bInSPD = FALSE;
            pQMPolicyState->dwErrorCode = dwError;
        }
        else {
            pQMPolicyState->bInSPD = TRUE;
            pQMPolicyState->dwErrorCode = ERROR_SUCCESS;
            dwError = ERROR_SUCCESS;
        }

        pQMPolicyState->pNext = gpQMPolicyState;
        gpQMPolicyState = pQMPolicyState;

        PAFreeQMPolicy(pSPDQMPolicy);

    }

    return (dwError);
}


DWORD
PACreateQMPolicyState(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE * ppQMPolicyState
    )
{
    DWORD dwError = 0;
    PQMPOLICYSTATE pQMPolicyState = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    WCHAR pszName[512];


    dwError = AllocateSPDMemory(
                  sizeof(QMPOLICYSTATE),
                  &pQMPolicyState
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    memcpy(
        &(pQMPolicyState->gPolicyID),
        &(pIpsecNegPolData->NegPolIdentifier),
        sizeof(GUID)
        );

    if (pIpsecNegPolData->pszIpsecName && *(pIpsecNegPolData->pszIpsecName)) {

        dwError = AllocateSPDString(
                      pIpsecNegPolData->pszIpsecName,
                      &(pQMPolicyState->pszPolicyName)
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }
    else {

        wsprintf(pszName, L"%d", ++gdwQMPolicyCounter);

        dwError = AllocateSPDString(
                      pszName,
                      &(pQMPolicyState->pszPolicyName)
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    memcpy(
        &(pQMPolicyState->gNegPolType),
        &(pIpsecNegPolData->NegPolType),
        sizeof(GUID)
        );

    memcpy(
        &(pQMPolicyState->gNegPolAction),
        &(pIpsecNegPolData->NegPolAction),
        sizeof(GUID)
        );

    pQMPolicyState->bAllowsSoft = FALSE;

    pQMPolicyState->cRef = 1;

    pQMPolicyState->bInSPD = FALSE;
    pQMPolicyState->dwErrorCode = 0;

    pQMPolicyState->pNext = NULL;

    *ppQMPolicyState = pQMPolicyState;

    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        (L"Pastore failed to create QM policy state for %!guid!",
        &pIpsecNegPolData->NegPolIdentifier)
        );

    if (pQMPolicyState) {
        PAFreeQMPolicyState(pQMPolicyState);
    }

    *ppQMPolicyState = NULL;

    return (dwError);
}


VOID
PAFreeQMPolicyState(
    PQMPOLICYSTATE pQMPolicyState
    )
{
    if (pQMPolicyState) {
        if (pQMPolicyState->pszPolicyName) {
            FreeSPDString(pQMPolicyState->pszPolicyName);
        }
        FreeSPDMemory(pQMPolicyState);
    }
}


BOOL
IsClearOnly(
    GUID gNegPolAction
    )
{
    if (!memcmp(
            &gNegPolAction,
            &(GUID_NEGOTIATION_ACTION_NO_IPSEC),
            sizeof(GUID))) {
        return (TRUE);
    }
    else {
        return (FALSE);
    }
}


BOOL
IsBlocking(
    GUID gNegPolAction
    )
{
    if (!memcmp(
            &gNegPolAction,
            &(GUID_NEGOTIATION_ACTION_BLOCK),
            sizeof(GUID))) {
        return (TRUE);
    }
    else {
        return (FALSE);
    }
}


BOOL
IsInboundPassThru(
    GUID gNegPolAction
    )
{
    if (!memcmp(
            &gNegPolAction,
            &(GUID_NEGOTIATION_ACTION_INBOUND_PASSTHRU),
            sizeof(GUID))) {
        return (TRUE);
    }
    else {
        return (FALSE);
    }
}

BOOL
IsSecure(
    GUID gNegPolAction
    )
{
    if (!memcmp(
            &gNegPolAction,
            &(GUID_NEGOTIATION_ACTION_NORMAL_IPSEC),
            sizeof(GUID))) {
        return (TRUE);
    }
    else {
        return (FALSE);
    }
}

DWORD
PACreateQMPolicy(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_QM_POLICY * ppSPDQMPolicy
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_POLICY pSPDQMPolicy = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;


    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_QM_POLICY),
                  &pSPDQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pSPDQMPolicy->gPolicyID),
        &(pIpsecNegPolData->NegPolIdentifier),
        sizeof(GUID)
        );

    dwError = AllocateSPDString(
                  pQMPolicyState->pszPolicyName,
                  &(pSPDQMPolicy->pszPolicyName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);
            
    dwError = PACreateQMOffers(
                  pIpsecNegPolData->dwSecurityMethodCount,
                  pIpsecNegPolData->pIpsecSecurityMethods,
                  pQMPolicyState,
                  &(pSPDQMPolicy->dwOfferCount),
                  &(pSPDQMPolicy->pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pSPDQMPolicy->dwFlags = 0;

    if (!memcmp(
            &(pIpsecNegPolData->NegPolType),
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {
        pSPDQMPolicy->dwFlags |= IPSEC_QM_POLICY_DEFAULT_POLICY;
    }

    if (pIpsecNFAData->dwTunnelFlags) {
        pSPDQMPolicy->dwFlags |= IPSEC_QM_POLICY_TUNNEL_MODE;
    }

    if (pQMPolicyState->bAllowsSoft) {
        pSPDQMPolicy->dwFlags |= IPSEC_QM_POLICY_ALLOW_SOFT;
    }

    pSPDQMPolicy->dwReserved = 0;

    *ppSPDQMPolicy = pSPDQMPolicy;

    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        (L"Pastore failed to create MM policy for %!guid!",
        &pIpsecNegPolData->NegPolIdentifier)
        );

    if (pSPDQMPolicy) {
        PAFreeQMPolicy(
            pSPDQMPolicy
            );
    }

    *ppSPDQMPolicy = NULL;

    return (dwError);
}


DWORD
PACreateQMOffers(
    DWORD dwSecurityMethodCount,
    PIPSEC_SECURITY_METHOD pIpsecSecurityMethods,
    PQMPOLICYSTATE pQMPolicyState,
    PDWORD pdwOfferCount,
    PIPSEC_QM_OFFER * ppOffers
    )
{
    DWORD dwError = 0;
    DWORD dwTempOfferCount = 0;
    PIPSEC_SECURITY_METHOD pTempMethod = NULL;
    BOOL bAllowsSoft = FALSE;
    DWORD i = 0;
    DWORD dwOfferCount = 0;
    PIPSEC_QM_OFFER pOffers = NULL;
    PIPSEC_QM_OFFER pTempOffer = NULL;


    if (!dwSecurityMethodCount || !pIpsecSecurityMethods) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (dwSecurityMethodCount > IPSEC_MAX_QM_OFFERS) {
        dwTempOfferCount = IPSEC_MAX_QM_OFFERS;
    }
    else {
        dwTempOfferCount = dwSecurityMethodCount;
    }

    pTempMethod = pIpsecSecurityMethods;
 
    for (i = 0; i < dwTempOfferCount; i++) {

        if (pTempMethod->Count == 0) {
            bAllowsSoft = TRUE;
        }
        else {
            dwOfferCount++;
        }

        pTempMethod++;

    }

    if (!dwOfferCount) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_QM_OFFER)*dwOfferCount,
                  &(pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTempOffer = pOffers;
    pTempMethod = pIpsecSecurityMethods;
    i = 0;

    while (i < dwOfferCount) {

        if (pTempMethod->Count) {

            PACopyQMOffers(
                pTempMethod,
                pTempOffer
                );

            i++;
            pTempOffer++;

        }

        pTempMethod++;

    }

    pQMPolicyState->bAllowsSoft = bAllowsSoft;

    *pdwOfferCount = dwOfferCount;
    *ppOffers = pOffers;
    return (dwError);

error:

    if (pOffers) {
        PAFreeQMOffers(
            i,
            pOffers
            );
    }

    *pdwOfferCount = 0;
    *ppOffers = NULL;
    return (dwError);
}


VOID
PACopyQMOffers(
    PIPSEC_SECURITY_METHOD pMethod,
    PIPSEC_QM_OFFER pOffer
    )
{
    DWORD i = 0;
    DWORD j = 0;
    DWORD k = 0;


    pOffer->Lifetime.uKeyExpirationKBytes = pMethod->Lifetime.KeyExpirationBytes;
    pOffer->Lifetime.uKeyExpirationTime = pMethod->Lifetime.KeyExpirationTime;

    pOffer->dwFlags = pMethod->Flags;

    pOffer->bPFSRequired = pMethod->PfsQMRequired;

    if (pMethod->PfsQMRequired) {
        pOffer->dwPFSGroup = PFS_GROUP_MM;
    }
    else {
        pOffer->dwPFSGroup = PFS_GROUP_NONE;
    }

    i = 0;

    for (j = 0; (j < pMethod->Count) && (i < QM_MAX_ALGOS) ; j++) {

        switch (pMethod->Algos[j].operation) {

        case Auth:

            switch (pMethod->Algos[j].algoIdentifier) {

            case IPSEC_AH_MD5:
                pOffer->Algos[i].uAlgoIdentifier = AUTH_ALGO_MD5;
                break;

            case IPSEC_AH_SHA:
                pOffer->Algos[i].uAlgoIdentifier = AUTH_ALGO_SHA1;
                break;

            default:
                pOffer->Algos[i].uAlgoIdentifier = AUTH_ALGO_NONE;
                break;

            }

            pOffer->Algos[i].uSecAlgoIdentifier = HMAC_AUTH_ALGO_NONE;
            pOffer->Algos[i].Operation = AUTHENTICATION;
            pOffer->Algos[i].uAlgoKeyLen = pMethod->Algos[j].algoKeylen;
            pOffer->Algos[i].uAlgoRounds = pMethod->Algos[j].algoRounds;
            pOffer->Algos[i].uSecAlgoKeyLen = 0;
            pOffer->Algos[i].uSecAlgoRounds = 0;
            pOffer->Algos[i].MySpi = 0;
            pOffer->Algos[i].PeerSpi = 0;

            i++;
            break;

        case Encrypt:

            switch (pMethod->Algos[j].algoIdentifier) {

            case IPSEC_ESP_DES:
                pOffer->Algos[i].uAlgoIdentifier = CONF_ALGO_DES;
                break;

            case IPSEC_ESP_DES_40:
                pOffer->Algos[i].uAlgoIdentifier = CONF_ALGO_DES;
                break;

            case IPSEC_ESP_3_DES:
                pOffer->Algos[i].uAlgoIdentifier = CONF_ALGO_3_DES;
                break;

            default:
                pOffer->Algos[i].uAlgoIdentifier = CONF_ALGO_NONE;
                break;

            }

            switch (pMethod->Algos[j].secondaryAlgoIdentifier) {

            case IPSEC_AH_MD5:
                pOffer->Algos[i].uSecAlgoIdentifier = HMAC_AUTH_ALGO_MD5;
                break;

            case IPSEC_AH_SHA:
                pOffer->Algos[i].uSecAlgoIdentifier = HMAC_AUTH_ALGO_SHA1;
                break;

            default:
                pOffer->Algos[i].uSecAlgoIdentifier = HMAC_AUTH_ALGO_NONE;
                break;

            }

            pOffer->Algos[i].Operation = ENCRYPTION;
            pOffer->Algos[i].uAlgoKeyLen = pMethod->Algos[j].algoKeylen;
            pOffer->Algos[i].uAlgoRounds = pMethod->Algos[j].algoRounds;
            pOffer->Algos[i].uSecAlgoKeyLen = 0;
            pOffer->Algos[i].uSecAlgoRounds = 0;
            pOffer->Algos[i].MySpi = 0;
            pOffer->Algos[i].PeerSpi = 0;

            i++;
            break;

        case None:
        case Compress:
        default:
            break;

        }

    }

    for (k = i; k < QM_MAX_ALGOS; k++) {
         memset(&(pOffer->Algos[k]), 0, sizeof(IPSEC_QM_ALGO));
    }

    pOffer->dwNumAlgos = i;

    pOffer->dwReserved = 0;
}


VOID
PAFreeQMPolicy(
    PIPSEC_QM_POLICY pSPDQMPolicy
    )
{
    if (pSPDQMPolicy) {

        if (pSPDQMPolicy->pszPolicyName) {
            FreeSPDString(pSPDQMPolicy->pszPolicyName);
        }

        PAFreeQMOffers(
            pSPDQMPolicy->dwOfferCount,
            pSPDQMPolicy->pOffers
            );

        FreeSPDMemory(pSPDQMPolicy);

    }
}


VOID
PAFreeQMOffers(
    DWORD dwOfferCount,
    PIPSEC_QM_OFFER pOffers
    )
{
    if (pOffers) {
        FreeSPDMemory(pOffers);
    }
}


DWORD
PADeleteAllQMPolicies(
    )
{
    DWORD dwError = 0;
    PQMPOLICYSTATE pQMPolicyState = NULL;
    LPWSTR pServerName = NULL;
    PQMPOLICYSTATE pTemp = NULL;
    PQMPOLICYSTATE pLeftQMPolicyState = NULL;
    DWORD dwVersion = 0;

    TRACE(TRC_INFORMATION, (L"Pastore deleting all QM polcies."));
    
    pQMPolicyState = gpQMPolicyState;

    while (pQMPolicyState) {

        if (pQMPolicyState->bInSPD) {

            dwError = DeleteQMPolicy(
                          pServerName,
                          dwVersion,
                          pQMPolicyState->pszPolicyName,
                          NULL
                          );
            if (!dwError) {
                pTemp = pQMPolicyState;
                pQMPolicyState = pQMPolicyState->pNext;
                PAFreeQMPolicyState(pTemp);
            } 
            else {
                pQMPolicyState->dwErrorCode = dwError;

                pTemp = pQMPolicyState;
                pQMPolicyState = pQMPolicyState->pNext;

                pTemp->pNext = pLeftQMPolicyState;
                pLeftQMPolicyState = pTemp;
            }

        }
        else {

            pTemp = pQMPolicyState;
            pQMPolicyState = pQMPolicyState->pNext;
            PAFreeQMPolicyState(pTemp);

        }

    }

    gpQMPolicyState = pLeftQMPolicyState;

    return (dwError);
}


VOID
PAFreeQMPolicyStateList(
    PQMPOLICYSTATE pQMPolicyState
    )
{
    PQMPOLICYSTATE pTemp = NULL;


    while (pQMPolicyState) {

        pTemp = pQMPolicyState;
        pQMPolicyState = pQMPolicyState->pNext;
        PAFreeQMPolicyState(pTemp);

    }
}


PQMPOLICYSTATE
FindQMPolicyState(
    GUID gPolicyID
    )
{
    PQMPOLICYSTATE pQMPolicyState = NULL;


    pQMPolicyState = gpQMPolicyState;

    while (pQMPolicyState) {

        if (!memcmp(&(pQMPolicyState->gPolicyID), &gPolicyID, sizeof(GUID))) {
            return (pQMPolicyState);
        }

        pQMPolicyState = pQMPolicyState->pNext;

    }

    return (NULL);
}


DWORD
PADeleteQMPolicies(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;


    for (i = 0; i < dwNumNFACount; i++) {

        pIpsecNFAData = *(ppIpsecNFAData + i);

        pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

        dwError = PADeleteQMPolicy(
                      pIpsecNegPolData->NegPolIdentifier
                      );

    }

    return (dwError);
}


DWORD
PADeleteQMPolicy(
    GUID gPolicyID
    )
{
    DWORD dwError = 0;
    PQMPOLICYSTATE pQMPolicyState = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwVersion = 0;

    TRACE(
        TRC_INFORMATION,
        (L"Pastore deleting QM policy %!guid!",
        &gPolicyID)
        );

    pQMPolicyState = FindQMPolicyState(
                         gPolicyID
                         );
    if (!pQMPolicyState) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pQMPolicyState->cRef--;
    if (pQMPolicyState->cRef > 0) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if (pQMPolicyState->bInSPD) {

        dwError = DeleteQMPolicy(
                      pServerName,
                      dwVersion,
                      pQMPolicyState->pszPolicyName,
                      NULL
                      );
        if (dwError) {
            pQMPolicyState->cRef++;
            pQMPolicyState->dwErrorCode = dwError;
        }
        BAIL_ON_WIN32_ERROR(dwError);

    }

    PADeleteQMPolicyState(pQMPolicyState);

error:

    return (dwError);
}


VOID
PADeleteQMPolicyState(
    PQMPOLICYSTATE pQMPolicyState
    )
{
    PQMPOLICYSTATE * ppTemp = NULL;


    ppTemp = &gpQMPolicyState;

    while (*ppTemp) {

        if (*ppTemp == pQMPolicyState) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);

    }

    if (*ppTemp) {
        *ppTemp = pQMPolicyState->pNext;
    }

    PAFreeQMPolicyState(pQMPolicyState);

    return;
}


DWORD
PADeleteInUseQMPolicies(
    )
{
    DWORD dwError = 0;
    PQMPOLICYSTATE pQMPolicyState = NULL;
    LPWSTR pServerName = NULL;
    PQMPOLICYSTATE pTemp = NULL;
    PQMPOLICYSTATE pLeftQMPolicyState = NULL;
    DWORD dwVersion = 0;

    TRACE(TRC_INFORMATION, (L"Pastore deleting in-use QM polcies."));

    pQMPolicyState = gpQMPolicyState;

    while (pQMPolicyState) {

        if (pQMPolicyState->bInSPD &&
            (pQMPolicyState->dwErrorCode == ERROR_IPSEC_QM_POLICY_IN_USE)) {

            dwError = DeleteQMPolicy(
                          pServerName,
                          dwVersion,
                          pQMPolicyState->pszPolicyName,
                          NULL
                          );
            if (!dwError) {
                pTemp = pQMPolicyState;
                pQMPolicyState = pQMPolicyState->pNext;
                PAFreeQMPolicyState(pTemp);
            }
            else {
                pTemp = pQMPolicyState;
                pQMPolicyState = pQMPolicyState->pNext;

                pTemp->pNext = pLeftQMPolicyState;
                pLeftQMPolicyState = pTemp;
            }

        }
        else {

            pTemp = pQMPolicyState;
            pQMPolicyState = pQMPolicyState->pNext;

            pTemp->pNext = pLeftQMPolicyState;
            pLeftQMPolicyState = pTemp;

        }

    }

    gpQMPolicyState = pLeftQMPolicyState;

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\pastore.h ===
typedef struct _IPSEC_POLICY_STATE {
    SPD_STATE CurrentState;
    union {
        LPWSTR pszDirectoryPolicyDN;
        LPWSTR pszRegistryPolicyDN;
        LPWSTR pszCachePolicyDN;
    };
    DWORD CurrentPollingInterval;
    DWORD DefaultPollingInterval;
    DWORD DSIncarnationNumber;
    DWORD RegIncarnationNumber;
    DWORD PersIncarnationNumber;    
    PIPSEC_POLICY_OBJECT pIpsecPolicyObject;
    PIPSEC_POLICY_DATA pIpsecPolicyData;
} IPSEC_POLICY_STATE, * PIPSEC_POLICY_STATE;


VOID
InitializePolicyStateBlock(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
StartStatePollingManager(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
PlumbDirectoryPolicy(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
GetDirectoryPolicyDN(
    LPWSTR * ppszDirectoryPolicyDN
    );

DWORD
LoadDirectoryPolicy(
    LPWSTR pszDirectoryPolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    );

DWORD
ApplyLoadedDirectoryPolicy(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );
    
DWORD
PlumbCachePolicy(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
GetCachePolicyDN(
    LPWSTR * ppszCachePolicyDN
    );

DWORD
LoadCachePolicy(
    LPWSTR pszCachePolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject
    );

DWORD
PlumbLocalPolicy(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
GetRegistryPolicyDN(
    LPWSTR * ppszRegistryPolicyDN,
    IN DWORD dwStore
    );

DWORD
LoadRegistryPolicy(
    LPWSTR pszRegistryPolicyDN,
    PIPSEC_POLICY_OBJECT * ppIpsecPolicyObject,
    IN DWORD dwStore
    );

DWORD
ApplyLoadedLocalPolicy(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
AddPolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    IN DWORD dwSource
    );

DWORD
LoadPersistedIPSecInformation(
    );

DWORD
AddMMPolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    IN DWORD dwSource
    );

DWORD
AddQMPolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData,
    IN DWORD dwSource,
    BOOL * pbHardError
    );

DWORD
OnPolicyChanged(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
DeletePolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
DeleteMMPolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
DeleteQMPolicyInformation(
    PIPSEC_POLICY_DATA pIpsecPolicyData
    );

DWORD
DeleteAllPolicyInformation(
    );

DWORD
DeleteAllMMPolicyInformation(
    );

DWORD
DeleteAllQMPolicyInformation(
    );

VOID
ClearPolicyStateBlock(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
OnPolicyPoll(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
ProcessDirectoryPolicyPollState(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
GetDirectoryIncarnationNumber(
    LPWSTR pszIpsecPolicyDN,
    DWORD * pdwIncarnationNumber
    );

DWORD
MigrateFromDSToCache(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
ProcessCachePolicyPollState(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
MigrateFromCacheToDS(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
UpdateFromCacheToDS(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
ProcessLocalPolicyPollState(
    PIPSEC_POLICY_STATE pIpsecPolicyState
    );

DWORD
HasRegistryPolicyChanged(
    LPWSTR pszCurrentPolicyDN,
    PBOOL pbChanged
    );

DWORD
GetRegistryIncarnationNumber(
    LPWSTR pszIpsecPolicyDN,
    DWORD *pdwIncarnationNumber
    );

DWORD
UpdatePolicyInformation(
    PIPSEC_POLICY_DATA pOldIpsecPolicyData,
    PIPSEC_POLICY_DATA pNewIpsecPolicyData,
    IN DWORD dwSource
    );

DWORD
LoadDefaultISAKMPInformation(
    LPWSTR pszDefaultISAKMPDN
    );

VOID
UnLoadDefaultISAKMPInformation(
    LPWSTR pszDefaultISAKMPDN
    );

BOOL
IsLocalPolicySpecified(
    );
    
BOOL
IsDirectoryPolicySpecified(
    );

BOOL
IsPersistentPolicySpecified(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\patn-fil.h ===
typedef struct _tnfilterstate {
    GUID gFilterID;
    GUID gNFAIdentifier;    
    GUID gPolicyID;
    HANDLE hTnFilter;
    struct _tnfilterstate * pNext;
} TNFILTERSTATE, * PTNFILTERSTATE;

DWORD
PAAddTnFilterSpecs(
    PIPSEC_NFA_DATA pIpsecNFAData,
    DWORD dwSource,
    BOOL * pbHardError
    );

DWORD
PACreateTnFilterState(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PTNFILTERSTATE * ppTnFilterState
    );

DWORD
PACreateTnFilter(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PQMPOLICYSTATE pQMPolicyState,
    PTUNNEL_FILTER * ppSPDTnFilter
    );

VOID
PAFreeTnFilter(
    PTUNNEL_FILTER pSPDTnFilter
    );

DWORD
PADeleteAllTnFilters(
    );

VOID
PAFreeTnFilterStateList(
    PTNFILTERSTATE pTnFilterState
    );

DWORD
PADeleteTnFilterSpecs(
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
PADeleteTnFilter(
    GUID gFilterID,
    GUID gNFAIdentifier
    );

VOID
PADeleteTnFilterState(
    PTNFILTERSTATE pTnFilterState
    );

PTNFILTERSTATE
FindTnFilterState(
    GUID gFilterID,
    GUID gNFAIdentifier
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\patx-fil.h ===
typedef struct _txfilterstate {
    GUID gFilterID;
    GUID gNFAIdentifier;
    GUID gPolicyID;
    HANDLE hTxFilter;
    struct _txfilterstate * pNext;
} TXFILTERSTATE, * PTXFILTERSTATE;


DWORD
PAAddQMFilters(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount,
    DWORD dwSource,
    BOOL * pbHardError
    );

DWORD
PAAddTxFilterSpecs(
    PIPSEC_NFA_DATA pIpsecNFAData,
    DWORD dwSource,
    BOOL * pbHardError    
    );

DWORD
PACreateTxFilterState(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PTXFILTERSTATE * ppTxFilterState
    );

DWORD
PACreateTxFilter(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PQMPOLICYSTATE pQMPolicyState,
    PTRANSPORT_FILTER * ppSPDTxFilter
    );

VOID
SetFilterActions(
    PQMPOLICYSTATE pQMPolicyState,
    PFILTER_ACTION pInboundFilterAction,
    PFILTER_ACTION pOutboundFilterAction
    );

VOID
PAFreeTxFilter(
    PTRANSPORT_FILTER pSPDTxFilter
    );

DWORD
PADeleteAllTxFilters(
    );

VOID
PAFreeTxFilterStateList(
    PTXFILTERSTATE pTxFilterState
    );

DWORD
PADeleteQMFilters(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    );

DWORD
PADeleteTxFilterSpecs(
    PIPSEC_NFA_DATA pIpsecNFAData
    );

DWORD
PADeleteTxFilter(
    GUID gFilterID,
    GUID gNFAIdentifier    
    );

VOID
PADeleteTxFilterState(
    PTXFILTERSTATE pTxFilterState
    );

PTXFILTERSTATE
FindTxFilterState(
    GUID gFilterID,
    GUID gNFAIdentifier    
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\patn-fil.c ===
#include "precomp.h"
#ifdef TRACE_ON
#include "patn-fil.tmh"
#endif

DWORD
PAAddTnFilterSpecs(
    PIPSEC_NFA_DATA pIpsecNFAData,
    DWORD dwSource,
    BOOL * pbHardError
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    PQMPOLICYSTATE pQMPolicyState = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppFilterSpecs = NULL;
    DWORD i = 0;
    PTNFILTERSTATE pTnFilterState = NULL;
    PTUNNEL_FILTER pSPDTnFilter = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwVersion = 0;
    BOOL bHardError = FALSE;

    TRACE(TRC_INFORMATION, ("Pastore adding tunnel filters for rule %!guid!.", &pIpsecNFAData->NFAIdentifier));
    
    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    if (!memcmp(
            &(pIpsecNegPolData->NegPolType), 
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {
        TRACE(TRC_INFORMATION, ("Pastore found default response rule: not adding an associated tunnel filter."));                        
        dwError = ERROR_SUCCESS;
        BAIL_OUT;
    }

    pQMPolicyState = FindQMPolicyState(
                         pIpsecNegPolData->NegPolIdentifier
                         );
    if (!pQMPolicyState) {
        bHardError = TRUE;
        dwError = ERROR_INVALID_PARAMETER;

        TRACE(
            TRC_ERROR,
            ("Pastore failed to find associated QM policy %!guid! when adding rule %!guid!.",
            &pIpsecNegPolData->NegPolIdentifier,
            &pIpsecNFAData->NFAIdentifier)
            );
        
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!IsClearOnly(pQMPolicyState->gNegPolAction) &&
        !IsBlocking(pQMPolicyState->gNegPolAction) &&
        !(pQMPolicyState->bInSPD)) {
        bHardError = TRUE;
        dwError = ERROR_INVALID_PARAMETER;

        TRACE(
            TRC_ERROR,
            ("Pastore failed to get associated QM policy in SPD %!guid! when adding rule %!guid!.",
            &pIpsecNFAData->NFAIdentifier,
            &pIpsecNegPolData->NegPolIdentifier)
            );
        
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    pIpsecFilterData = pIpsecNFAData->pIpsecFilterData;

    if (!pIpsecFilterData) {
        TRACE(
            TRC_ERROR,
            ("Pastore found no associated filter data when adding rule %!guid!.",
            &pIpsecNFAData->NFAIdentifier)
            );
        
        dwError = ERROR_INVALID_PARAMETER;
        SET_IF_HARD_ERROR(
            dwError,
            pQMPolicyState->gNegPolAction,
            bHardError
            );
        if (!bHardError) {
            dwError = ERROR_SUCCESS;
        }
        BAIL_OUT;
    }

    dwNumFilterSpecs = pIpsecFilterData->dwNumFilterSpecs;
    ppFilterSpecs = pIpsecFilterData->ppFilterSpecs;
    

    for (i = 0; i < dwNumFilterSpecs; i++) {

        dwError = PACreateTnFilterState(
                      pIpsecNegPolData,
                      pIpsecNFAData,
                      *(ppFilterSpecs + i),
                      &pTnFilterState
                      );
        if (dwError) {
            SET_IF_HARD_ERROR(
                dwError,
                pQMPolicyState->gNegPolAction,
                bHardError
            );         
            continue;
        }

        dwError = PACreateTnFilter(
                      pIpsecNegPolData,
                      pIpsecNFAData,
                      *(ppFilterSpecs + i),
                      pQMPolicyState,
                      &pSPDTnFilter
                      );
        if (dwError) {

            pTnFilterState->hTnFilter = NULL;

            pTnFilterState->pNext = gpTnFilterState;
            gpTnFilterState = pTnFilterState;

            SET_IF_HARD_ERROR(
                dwError,
                pQMPolicyState->gNegPolAction,
                bHardError
            );         
            continue;

        }

        dwError = AddTunnelFilterInternal(
                      pServerName,
                      dwVersion,
                      0,
                      dwSource,
                      pSPDTnFilter,
                      NULL,
                      &(pTnFilterState->hTnFilter)
                      );
        // Catch the driver error that can happen because of adding duplicated 
        // expanded filters.  We don't want this to be a hard error.
        //
        if (dwError == STATUS_DUPLICATE_OBJECTID
            || dwError == GPC_STATUS_CONFLICT)
        {
            AuditIPSecPolicyErrorEvent(
                    SE_CATEGID_POLICY_CHANGE,
                    SE_AUDITID_IPSEC_POLICY_CHANGED,
                    PASTORE_ADD_QM_FILTER_FAIL,
                    pIpsecNFAData->pszIpsecName,
                    dwError,
                    FALSE,
                    TRUE
                    );
        }  else {        
            SET_IF_HARD_ERROR(
                dwError,
                pQMPolicyState->gNegPolAction,
                bHardError
            );
        }

        pTnFilterState->pNext = gpTnFilterState;
        gpTnFilterState = pTnFilterState;

        PAFreeTnFilter(pSPDTnFilter);

    }

error:
    *pbHardError = bHardError;

    return (dwError);
}

DWORD
PACreateTnFilterState(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PTNFILTERSTATE * ppTnFilterState
    )
{
    DWORD dwError = 0;
    PTNFILTERSTATE pTnFilterState = NULL;


    dwError = AllocateSPDMemory(
                  sizeof(TNFILTERSTATE),
                  &pTnFilterState
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pTnFilterState->gFilterID),
        &(pFilterSpec->FilterSpecGUID),
        sizeof(GUID)
        );

    memcpy(
        &(pTnFilterState->gNFAIdentifier),
        &(pIpsecNFAData->NFAIdentifier),
        sizeof(GUID)
        );

    memcpy(
        &(pTnFilterState->gPolicyID),
        &(pIpsecNegPolData->NegPolIdentifier),
        sizeof(GUID)
        );

    pTnFilterState->hTnFilter = NULL;
    pTnFilterState->pNext = NULL;

    *ppTnFilterState = pTnFilterState;

    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        ("Pastore failed to create state node for tunnel filter %!guid!. %!winerr!", 
        &pFilterSpec->FilterSpecGUID,
        dwError)
        );

    *ppTnFilterState = NULL;

    return (dwError);
}


DWORD
PACreateTnFilter(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PQMPOLICYSTATE pQMPolicyState,
    PTUNNEL_FILTER * ppSPDTnFilter
    )
{
    DWORD dwError = 0;
    PTUNNEL_FILTER pSPDTnFilter = NULL;
    WCHAR pszName[512];


    dwError = AllocateSPDMemory(
                  sizeof(TUNNEL_FILTER),
                  &pSPDTnFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pSPDTnFilter->IpVersion = IPSEC_PROTOCOL_V4;

    memcpy(
        &(pSPDTnFilter->gFilterID),
        &(pFilterSpec->FilterSpecGUID),
        sizeof(GUID)
        );

    if (pFilterSpec->pszDescription && *(pFilterSpec->pszDescription)) {

        dwError = AllocateSPDString(
                      pFilterSpec->pszDescription,
                      &(pSPDTnFilter->pszFilterName)
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }
    else {

        wsprintf(pszName, L"%d", ++gdwTnFilterCounter);

        dwError = AllocateSPDString(
                      pszName,
                      &(pSPDTnFilter->pszFilterName)
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    PASetInterfaceType(
        pIpsecNFAData->dwInterfaceType,
        &(pSPDTnFilter->InterfaceType)
        );

    pSPDTnFilter->bCreateMirror = FALSE;

    pSPDTnFilter->dwFlags = 0;

    PASetAddress(
        pFilterSpec->Filter.SrcMask,
        pFilterSpec->Filter.SrcAddr,
        &(pSPDTnFilter->SrcAddr)
        );

    PASetAddress(
        pFilterSpec->Filter.DestMask,
        pFilterSpec->Filter.DestAddr, 
        &(pSPDTnFilter->DesAddr)
        );

    if (pFilterSpec->Filter.ExType) {
        if (pFilterSpec->Filter.ExType & EXT_DEST) {
          pSPDTnFilter->DesAddr.AddrType = ExTypeToAddrType(
                                              pFilterSpec->Filter.ExType
                                              );
        } else {
          pSPDTnFilter->SrcAddr.AddrType = ExTypeToAddrType(
                                              pFilterSpec->Filter.ExType
                                              );
        }
    }

    PASetAddress(
        SUBNET_MASK_ANY,
        SUBNET_ADDRESS_ANY,
        &(pSPDTnFilter->SrcTunnelAddr)
        );

    PASetTunnelAddress(
        ((ULONG) pIpsecNFAData->dwTunnelIpAddr),
        &(pSPDTnFilter->DesTunnelAddr)
        );

    pSPDTnFilter->Protocol.ProtocolType = PROTOCOL_UNIQUE;
    pSPDTnFilter->Protocol.dwProtocol = pFilterSpec->Filter.Protocol;

    pSPDTnFilter->SrcPort.PortType = PORT_UNIQUE;
    pSPDTnFilter->SrcPort.wPort = pFilterSpec->Filter.SrcPort;

    pSPDTnFilter->DesPort.PortType = PORT_UNIQUE;
    pSPDTnFilter->DesPort.wPort = pFilterSpec->Filter.DestPort;

    SetFilterActions(
        pQMPolicyState,
        &(pSPDTnFilter->InboundFilterAction),
        &(pSPDTnFilter->OutboundFilterAction)
        );

    pSPDTnFilter->dwDirection = 0;

    pSPDTnFilter->dwWeight = 0;

    memcpy(
        &(pSPDTnFilter->gPolicyID),
        &(pIpsecNegPolData->NegPolIdentifier),
        sizeof(GUID)
        );

    *ppSPDTnFilter = pSPDTnFilter;

    return (dwError);

error:
    TRACE(
        TRC_WARNING,
        ("Pastore failed to create tunnel filter %!guid!. %!winerr!", 
        &pFilterSpec->FilterSpecGUID,
        dwError)
        );

    if (pSPDTnFilter) {
        PAFreeTnFilter(
            pSPDTnFilter
            );
    }

    *ppSPDTnFilter = NULL;

    return (dwError);
}


VOID
PAFreeTnFilter(
    PTUNNEL_FILTER pSPDTnFilter
    )
{
    if (pSPDTnFilter) {

        if (pSPDTnFilter->pszFilterName) {
            FreeSPDString(pSPDTnFilter->pszFilterName);
        }

        FreeSPDMemory(pSPDTnFilter);

    }

    return;
}


DWORD
PADeleteAllTnFilters(
    )
{
    DWORD dwError = 0;
    PTNFILTERSTATE pTnFilterState = NULL;
    PTNFILTERSTATE pTemp = NULL;
    PTNFILTERSTATE pLeftTnFilterState = NULL;

    TRACE(TRC_INFORMATION, (L"Pastore deleting all its tunnel filters"));
    
    pTnFilterState = gpTnFilterState;

    while (pTnFilterState) {

        if (pTnFilterState->hTnFilter) {

            dwError = DeleteTunnelFilter(
                          pTnFilterState->hTnFilter
                          );
            if (!dwError) {
                pTemp = pTnFilterState;
                pTnFilterState = pTnFilterState->pNext;
                FreeSPDMemory(pTemp);
            } 
            else {
                pTemp = pTnFilterState;
                pTnFilterState = pTnFilterState->pNext;

                pTemp->pNext = pLeftTnFilterState;
                pLeftTnFilterState = pTemp;
            }

        }
        else {

            pTemp = pTnFilterState;
            pTnFilterState = pTnFilterState->pNext;
            FreeSPDMemory(pTemp);

        }

    }

    gpTnFilterState = pLeftTnFilterState;
    
    return (dwError);
}


VOID
PAFreeTnFilterStateList(
    PTNFILTERSTATE pTnFilterState
    )
{
    PTNFILTERSTATE pTemp = NULL;


    while (pTnFilterState) {

        pTemp = pTnFilterState;
        pTnFilterState = pTnFilterState->pNext;
        FreeSPDMemory(pTemp);

    }
}


DWORD
PADeleteTnFilterSpecs(
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppFilterSpecs = NULL;
    DWORD i = 0;
    PIPSEC_FILTER_SPEC pFilterSpec = NULL;


    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    if (!memcmp(
            &(pIpsecNegPolData->NegPolType), 
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pIpsecFilterData = pIpsecNFAData->pIpsecFilterData;

    if (!pIpsecFilterData) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    dwNumFilterSpecs = pIpsecFilterData->dwNumFilterSpecs;
    ppFilterSpecs = pIpsecFilterData->ppFilterSpecs;
    
    for (i = 0; i < dwNumFilterSpecs; i++) {

        pFilterSpec = *(ppFilterSpecs + i);

        dwError = PADeleteTnFilter(
                      pFilterSpec->FilterSpecGUID,
                      pIpsecNFAData->NFAIdentifier
                      );

    }

    return (dwError);
}


DWORD
PADeleteTnFilter(
    GUID gFilterID,
    GUID gNFAIdentifier
    )
{
    DWORD dwError = 0;
    PTNFILTERSTATE pTnFilterState = NULL;

    pTnFilterState = FindTnFilterState(
                         gFilterID,
                         gNFAIdentifier
                         );
    if (!pTnFilterState) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if (pTnFilterState->hTnFilter) {

        dwError = DeleteTunnelFilter(
                      pTnFilterState->hTnFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    PADeleteTnFilterState(pTnFilterState);

error:
#ifdef TRACE_ON
        if (dwError) {
            TRACE(
                TRC_WARNING,
                ("Pastore failed to delete tunnel filter %!guid!. %!winerr!", 
                &gFilterID,
                dwError)
                );
        }
#endif

    return (dwError);
}


VOID
PADeleteTnFilterState(
    PTNFILTERSTATE pTnFilterState
    )
{
    PTNFILTERSTATE * ppTemp = NULL;


    ppTemp = &gpTnFilterState;

    while (*ppTemp) {

        if (*ppTemp == pTnFilterState) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);

    }

    if (*ppTemp) {
        *ppTemp = pTnFilterState->pNext;
    }

    FreeSPDMemory(pTnFilterState);

    return;
}


PTNFILTERSTATE
FindTnFilterState(
    GUID gFilterID,
    GUID gNFAIdentifier
    )
{
    PTNFILTERSTATE pTnFilterState = NULL;

    pTnFilterState = gpTnFilterState;

    while (pTnFilterState) {
        // gNFAIdentifier+gFilterID forms primary key for tunnel filter state
        //
        if (!memcmp(&(pTnFilterState->gFilterID), &gFilterID, sizeof(GUID))
            && !memcmp(&(pTnFilterState->gNFAIdentifier), &gNFAIdentifier, sizeof(GUID)))
        {
            return (pTnFilterState);
        }

        pTnFilterState = pTnFilterState->pNext;

    }

    return (NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\port.c ===
#include "precomp.h"


DWORD
VerifyPortsForProtocol(
    PORT        Port,
    PROTOCOL    Protocol
    )
{
    DWORD   dwError = 0;

    switch (Port.PortType) {

    case PORT_UNIQUE:

        if (Port.wPort < 0) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }

        switch (Protocol.ProtocolType) {

        case PROTOCOL_UNIQUE:
            if ((Protocol.dwProtocol != TCP_PROTOCOL) && 
                (Protocol.dwProtocol != UDP_PROTOCOL)) {
                if (Port.wPort != 0) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);
                }
            }
            break;

        default:
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
            break;
        }

        break;

    default:

        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

error:

    return (dwError);
}


BOOL
EqualPorts(
    IN PORT     OldPort,
    IN PORT     NewPort
    )
{
    BOOL bMatches = FALSE;

    if (OldPort.PortType == NewPort.PortType) {
        switch(OldPort.PortType) {
        case PORT_UNIQUE:
            if (OldPort.wPort == NewPort.wPort) {
                bMatches = TRUE;
            }
            break;
        }
    }

    return (bMatches);
}


VOID
CopyPorts(
    IN  PORT    InPort,
    OUT PPORT   pOutPort
    )
{
    memcpy(
        pOutPort,
        &InPort,
        sizeof(PORT)
        );
}


BOOL
MatchPorts(
    PORT PortToMatch,
    PORT PortTemplate
    )
{
    switch (PortTemplate.PortType) {

    case PORT_UNIQUE:
        if (PortToMatch.wPort) {
            if (PortToMatch.wPort != PortTemplate.wPort) {
                return (FALSE);
            }
        }
        break;

    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\paupdate.h ===
DWORD
PADeleteObseleteISAKMPData(
    PIPSEC_ISAKMP_DATA * ppOldIpsecISAKMPData,
    DWORD dwNumOldPolicies,
    PIPSEC_NFA_DATA * ppOldIpsecNFAData,
    DWORD dwNumOldNFACount,
    PIPSEC_ISAKMP_DATA * ppNewIpsecISAKMPData,
    DWORD dwNumNewPolicies
    );

PIPSEC_ISAKMP_DATA
FindISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData,
    DWORD dwNumPolicies
    );

DWORD
PADeleteObseleteNFAData(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA * ppOldIpsecNFAData,
    DWORD dwNumOldNFACount,
    PIPSEC_NFA_DATA * ppNewIpsecNFAData,
    DWORD dwNumNewNFACount
    );

PIPSEC_NFA_DATA
FindNFAData(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    );

DWORD
PAUpdateISAKMPData(
    PIPSEC_ISAKMP_DATA * ppNewIpsecISAKMPData,
    DWORD dwNumNewPolicies,
    PIPSEC_NFA_DATA * ppOldIpsecNFAData,
    DWORD dwNumOldNFACount,
    PIPSEC_ISAKMP_DATA * ppOldIpsecISAKMPData,
    DWORD dwNumOldPolicies,
    IN DWORD dwSource
    );

DWORD
PAUpdateNFAData(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA * ppNewIpsecNFAData,
    DWORD dwNumNewNFACount,
    PIPSEC_NFA_DATA * ppOldIpsecNFAData,
    DWORD dwNumOldNFACount,
    DWORD dwSource
    );

DWORD
PAProcessISAKMPUpdate(
    PIPSEC_ISAKMP_DATA pOldIpsecISAKMPData,
    PIPSEC_NFA_DATA * ppOldIpsecNFAData,
    DWORD dwNumOldNFACount,
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    IN DWORD dwSource
    );

BOOL
EqualISAKMPData(
    PIPSEC_ISAKMP_DATA pOldIpsecISAKMPData,
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData
    );

BOOL
EqualCryptoBundle(
    PCRYPTO_BUNDLE pOldBundle,
    PCRYPTO_BUNDLE pNewBundle
    );

DWORD
PAProcessNFAUpdate(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwSource
    );

DWORD
PAUpdateAuthMethod(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    PBOOL pbAddedMMFilters,
    DWORD dwSource
    );

BOOL
EqualAuthMethodData(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData
    );

BOOL
EqualAuthBundle(
    PIPSEC_AUTH_METHOD pOldAuthMethod,
    PIPSEC_AUTH_METHOD pNewAuthMethod
    );

DWORD
PAProcessQMNFAUpdate(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwSource
    );

DWORD
PADeleteQMInfoForNFA(
    PIPSEC_NFA_DATA pOldIpsecNFAData
    );

DWORD
PAAddQMInfoForNFA(
    PIPSEC_NFA_DATA pNewIpsecNFAData, 
    DWORD dwSource
    );

DWORD
PAProcessNegPolUpdate(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    PBOOL pbAddedQMFilters,
    DWORD dwSource
    );

BOOL
EqualNegPolData(
    PIPSEC_NEGPOL_DATA pOldIpsecNegPolData,
    PIPSEC_NEGPOL_DATA pNewIpsecNegPolData
    );

BOOL
EqualSecurityMethod(
    PIPSEC_SECURITY_METHOD pOldBundle,
    PIPSEC_SECURITY_METHOD pNewBundle
    );

DWORD
PAUpdateMMFilters(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    IN DWORD dwSource
    );

BOOL
EqualFilterKeysInNegPols(
    PIPSEC_NEGPOL_DATA pOldIpsecNegPolData,
    PIPSEC_NEGPOL_DATA pNewIpsecNegPolData
    );

BOOL
EqualFilterKeysInNFAs(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData
    );

DWORD
PAProcessMMFilterDataForNFAs(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwSource
    );

DWORD
PADeleteObseleteMMFilterSpecs(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    DWORD dwNumOldFilterSpecs,
    PIPSEC_FILTER_SPEC * ppOldFilterSpecs,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwNumNewFilterSpecs,
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs
    );

PIPSEC_FILTER_SPEC
FindFilterSpec(
    PIPSEC_FILTER_SPEC pFilterSpec,
    PIPSEC_FILTER_SPEC * ppFilterSpecs,
    DWORD dwNumFilterSpecs
    );

DWORD
PAUpdateMMFilterSpecs(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    DWORD dwNumOldFilterSpecs,
    PIPSEC_FILTER_SPEC * ppOldFilterSpecs,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwNumNewFilterSpecs,
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs,
    DWORD dwSource
    );

DWORD
PAAddMMFilterSpec(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    DWORD dwSource
    );

BOOL
EqualFilterSpecs(
    PIPSEC_FILTER_SPEC pOldFilterSpec,
    PIPSEC_FILTER_SPEC pNewFilterSpec
    );

DWORD
PAUpdateQMFilters(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwSource
    );

DWORD
PAAddQMFilterSpecs(
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwSource
    );

DWORD
PADeleteQMFilterSpecs(
    PIPSEC_NFA_DATA pOldIpsecNFAData
    );

DWORD
PAProcessQMFilterDataForNFAs(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwSource
    );

DWORD
PADeleteObseleteQMFilterSpecs(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    DWORD dwNumOldFilterSpecs,
    PIPSEC_FILTER_SPEC * ppOldFilterSpecs,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwNumNewFilterSpecs,
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs
    );

DWORD
PAUpdateQMFilterSpecs(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    DWORD dwNumOldFilterSpecs,
    PIPSEC_FILTER_SPEC * ppOldFilterSpecs,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwNumNewFilterSpecs,
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs,
    DWORD dwSource
    );

DWORD
PADeleteQMFilter(
    PIPSEC_NFA_DATA pIpsecNFAData,
    GUID FilterSpecGUID
    );

DWORD
PAAddQMFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec,
    DWORD dwSource
    );

DWORD
PAAddTxFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec,
    DWORD dwSource
    );

DWORD
PAAddTnFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec,
    DWORD dwSource
    );

BOOL
AllowsSoft(
    DWORD dwSecurityMethodCount,
    PIPSEC_SECURITY_METHOD pIpsecSecurityMethods
    );

DWORD
PAUpdateQMFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec,
    DWORD dwSource
    );

DWORD
PAUpdateTxFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec,
    DWORD dwSource
    );

DWORD
PAUpdateTnFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec,
    DWORD dwSource
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\paupdate.c ===
#include "precomp.h"
#ifdef TRACE_ON
#include "paupdate.tmh"
#endif


DWORD
PADeleteObseleteISAKMPData(
    PIPSEC_ISAKMP_DATA * ppOldIpsecISAKMPData,
    DWORD dwNumOldPolicies,
    PIPSEC_NFA_DATA * ppOldIpsecNFAData,
    DWORD dwNumOldNFACount,
    PIPSEC_ISAKMP_DATA * ppNewIpsecISAKMPData,
    DWORD dwNumNewPolicies
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_ISAKMP_DATA pOldIpsecISAKMPData = NULL;
    PIPSEC_ISAKMP_DATA pFoundISAKMPData = NULL;

    TRACE(TRC_INFORMATION, (L"Pastore update deleting obselete ISAKMP policy information"));
    for (i = 0; i < dwNumOldPolicies; i++) {

        pOldIpsecISAKMPData = *(ppOldIpsecISAKMPData + i);

        pFoundISAKMPData = FindISAKMPData(
                               pOldIpsecISAKMPData,
                               ppNewIpsecISAKMPData,
                               dwNumNewPolicies
                               );

        if (!pFoundISAKMPData) {

            dwError = PADeleteMMFilters(
                          pOldIpsecISAKMPData,
                          ppOldIpsecNFAData,
                          dwNumOldNFACount
                          );

            dwError = PADeleteMMPolicy(
                          pOldIpsecISAKMPData->ISAKMPIdentifier
                          );

        }

    }

    return (dwError);
}


PIPSEC_ISAKMP_DATA
FindISAKMPData(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_ISAKMP_DATA * ppIpsecISAKMPData,
    DWORD dwNumPolicies
    )
{
    DWORD i = 0;
    PIPSEC_ISAKMP_DATA pTemp = NULL;


    for (i = 0; i < dwNumPolicies; i++) {

        pTemp = *(ppIpsecISAKMPData + i);

        if (!memcmp(
                &(pIpsecISAKMPData->ISAKMPIdentifier),
                &(pTemp->ISAKMPIdentifier),
                sizeof(GUID))) {
            return (pTemp);
        }

    }

    return (NULL);
}


DWORD
PADeleteObseleteNFAData(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA * ppOldIpsecNFAData,
    DWORD dwNumOldNFACount,
    PIPSEC_NFA_DATA * ppNewIpsecNFAData,
    DWORD dwNumNewNFACount
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_DATA pOldIpsecNFAData = NULL;
    PIPSEC_NFA_DATA pFoundNFAData = NULL;

    TRACE(TRC_INFORMATION, (L"Pastore update deleting obselete MM and QM NFA-derived filters and policies"));
    
    for (i = 0; i < dwNumOldNFACount; i++) {

        pOldIpsecNFAData = *(ppOldIpsecNFAData + i);

        pFoundNFAData = FindNFAData(
                            pOldIpsecNFAData,
                            ppNewIpsecNFAData,
                            dwNumNewNFACount
                            );

        if (!pFoundNFAData) {
            dwError = PADeleteMMFilterSpecs(
                          pNewIpsecISAKMPData,
                          pOldIpsecNFAData
                          );

            dwError = PADeleteMMAuthMethod(
                          pOldIpsecNFAData->NFAIdentifier
                          );

            dwError = PADeleteQMInfoForNFA(
                          pOldIpsecNFAData
                          );

        }

    }

    return (dwError);
}


PIPSEC_NFA_DATA
FindNFAData(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    )
{
    DWORD i = 0;
    PIPSEC_NFA_DATA pTemp = NULL;


    for (i = 0; i < dwNumNFACount; i++) {

        pTemp = *(ppIpsecNFAData + i);

        if (!memcmp(
                &(pIpsecNFAData->NFAIdentifier),
                &(pTemp->NFAIdentifier),
                sizeof(GUID))) {
            return (pTemp);
        }

    }

    return (NULL);
}


DWORD
PAUpdateISAKMPData(
    PIPSEC_ISAKMP_DATA * ppNewIpsecISAKMPData,
    DWORD dwNumNewPolicies,
    PIPSEC_NFA_DATA * ppOldIpsecNFAData,
    DWORD dwNumOldNFACount,
    PIPSEC_ISAKMP_DATA * ppOldIpsecISAKMPData,
    DWORD dwNumOldPolicies,
    IN DWORD dwSource
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData = NULL;
    PIPSEC_ISAKMP_DATA pFoundISAKMPData = NULL;

    TRACE(
        TRC_INFORMATION,
        (L"Pastore updating MM filters based on new ISAKMP data")
        );

    for (i = 0; i < dwNumNewPolicies; i++) {

        pNewIpsecISAKMPData = *(ppNewIpsecISAKMPData + i);

        pFoundISAKMPData = FindISAKMPData(
                               pNewIpsecISAKMPData,
                               ppOldIpsecISAKMPData,
                               dwNumOldPolicies
                               );

        if (!pFoundISAKMPData) {
            dwError = PAAddMMPolicies(
                          &pNewIpsecISAKMPData,
                          1,
                          dwSource
                          );

            dwError = PAAddMMFilters(
                          pNewIpsecISAKMPData,
                          ppOldIpsecNFAData,
                          dwNumOldNFACount,
                          dwSource
                          );
        }
        else {
            dwError = PAProcessISAKMPUpdate(
                          pFoundISAKMPData,
                          ppOldIpsecNFAData,
                          dwNumOldNFACount,
                          pNewIpsecISAKMPData,
                          dwSource
                          );

        }

    }

    return (dwError);
}


DWORD
PAUpdateNFAData(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA * ppNewIpsecNFAData,
    DWORD dwNumNewNFACount,
    PIPSEC_NFA_DATA * ppOldIpsecNFAData,
    DWORD dwNumOldNFACount,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_DATA pNewIpsecNFAData = NULL;
    PIPSEC_NFA_DATA pFoundNFAData = NULL;

    for (i = 0; i < dwNumNewNFACount; i++) {

        pNewIpsecNFAData = *(ppNewIpsecNFAData + i);

        TRACE(
            TRC_INFORMATION,
            (L"Pastore updating QM and MM filters and polcies based on NFA %!guid! data.",
            &pNewIpsecNFAData->NFAIdentifier)
            );

        pFoundNFAData = FindNFAData(
                            pNewIpsecNFAData,
                            ppOldIpsecNFAData,
                            dwNumOldNFACount
                            );

        if (!pFoundNFAData) {

            dwError = PAAddMMAuthMethods(
                          &pNewIpsecNFAData,
                          1,
                          dwSource
                          );

            dwError = PAAddMMFilterSpecs(
                          pNewIpsecISAKMPData,
                          pNewIpsecNFAData,
                          dwSource
                          );

            dwError = PAAddQMInfoForNFA(
                          pNewIpsecNFAData,
                          dwSource
                          );

        }
        else {
            dwError = PAProcessNFAUpdate(
                          pNewIpsecISAKMPData,
                          pFoundNFAData,
                          pNewIpsecNFAData,
                          dwSource
                          );

        }

    }

    return (dwError);
}


DWORD
PAProcessISAKMPUpdate(
    PIPSEC_ISAKMP_DATA pOldIpsecISAKMPData,
    PIPSEC_NFA_DATA * ppOldIpsecNFAData,
    DWORD dwNumOldNFACount,
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    IN DWORD dwSource
    )
{
    DWORD dwError = 0;
    PMMPOLICYSTATE pMMPolicyState = NULL;
    BOOL bEqual = FALSE;
    PIPSEC_MM_POLICY pSPDMMPolicy = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwVersion = 0;


    pMMPolicyState = FindMMPolicyState(
                         pOldIpsecISAKMPData->ISAKMPIdentifier
                         );
    if (!pMMPolicyState) {
        dwError = PAAddMMPolicies(
                      &pNewIpsecISAKMPData,
                      1,
                      dwSource
                      );
        dwError = PAAddMMFilters(
                      pNewIpsecISAKMPData,
                      ppOldIpsecNFAData,
                      dwNumOldNFACount,
                      dwSource
                      );
        return (dwError);
    }

    if (!(pMMPolicyState->bInSPD)) {
        PADeleteMMPolicyState(pMMPolicyState);
        dwError = PAAddMMPolicies(
                      &pNewIpsecISAKMPData,
                      1,
                      dwSource
                      );
        dwError = PAAddMMFilters(
                      pNewIpsecISAKMPData,
                      ppOldIpsecNFAData,
                      dwNumOldNFACount,
                      dwSource
                      );
        return (dwError);
    }

    bEqual = EqualISAKMPData(
                 pOldIpsecISAKMPData,
                 pNewIpsecISAKMPData
                 );
    if (bEqual) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    dwError = PACreateMMPolicy(
                  pNewIpsecISAKMPData,
                  pMMPolicyState,
                  &pSPDMMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SetMMPolicy(
                  pServerName,
                  dwVersion,
                  pMMPolicyState->pszPolicyName,
                  pSPDMMPolicy,
                  NULL
                  );
    if (dwError != WARNING_IPSEC_MM_POLICY_PRUNED) {
        BAIL_ON_WIN32_ERROR(dwError);
    } else {
        dwError = ERROR_SUCCESS;
    }

error:
#ifdef TRACE_ON
    if (dwError) {
        TRACE(TRC_ERROR, (L"Pastore update failed during processing of ISAKMP policy update: %!winerr!", dwError));
    }
#endif

    
    if (pSPDMMPolicy) {
        PAFreeMMPolicy(pSPDMMPolicy);
    }

    return (dwError);
}


BOOL
EqualISAKMPData(
    PIPSEC_ISAKMP_DATA pOldIpsecISAKMPData,
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData
    )
{
    BOOL bEqual = FALSE;
    DWORD dwOldCnt = 0;
    PCRYPTO_BUNDLE pOldSecurityMethods = NULL;
    DWORD dwNewCnt = 0;
    PCRYPTO_BUNDLE pNewSecurityMethods = NULL;
    DWORD i = 0;
    PCRYPTO_BUNDLE pNewTemp = NULL;
    PCRYPTO_BUNDLE pOldTemp = NULL;


    //
    // At this point, pszPolicyName and ISAKMPIdentifier are same and
    // dwWhenChanged is different.
    //

    dwOldCnt = pOldIpsecISAKMPData->dwNumISAKMPSecurityMethods;
    pOldSecurityMethods = pOldIpsecISAKMPData->pSecurityMethods;

    dwNewCnt = pNewIpsecISAKMPData->dwNumISAKMPSecurityMethods;
    pNewSecurityMethods = pNewIpsecISAKMPData->pSecurityMethods;

    //
    // At this point, dwOldCnt >= 1 and pOldSecurityMethods != NULL.
    //

    if (!dwNewCnt || !pNewSecurityMethods) {
        return (FALSE);
    }

    if (dwOldCnt != dwNewCnt) {
        return (FALSE);
    }

    if (pOldIpsecISAKMPData->ISAKMPPolicy.dwFlags != pNewIpsecISAKMPData->ISAKMPPolicy.dwFlags) {
        return (FALSE);
    }

    pNewTemp = pNewSecurityMethods;
    pOldTemp = pOldSecurityMethods;

    for (i = 0; i < dwNewCnt; i++) {

        bEqual = FALSE;

        bEqual = EqualCryptoBundle(
                     pOldTemp,
                     pNewTemp
                     );
        if (!bEqual) {
            break;
        }

        pOldTemp++;

        pNewTemp++;

    }

    return (bEqual);
}


BOOL
EqualCryptoBundle(
    PCRYPTO_BUNDLE pOldBundle,
    PCRYPTO_BUNDLE pNewBundle
    )
{
    if (memcmp(
            &(pOldBundle->Lifetime),
            &(pNewBundle->Lifetime),
            sizeof(OAKLEY_LIFETIME))) {
       return (FALSE);
    }

    if (pOldBundle->QuickModeLimit != pNewBundle->QuickModeLimit) {
        return (FALSE);
    }

    if (pOldBundle->OakleyGroup != pNewBundle->OakleyGroup) {
        return (FALSE);
    }

    if (memcmp(
            &(pOldBundle->EncryptionAlgorithm),
            &(pNewBundle->EncryptionAlgorithm),
            sizeof(OAKLEY_ALGORITHM))) {
        return (FALSE);
    }

    if (memcmp(
            &(pOldBundle->HashAlgorithm),
            &(pNewBundle->HashAlgorithm),
            sizeof(OAKLEY_ALGORITHM))) {
        return (FALSE);
    }

    return (TRUE);
}

    
DWORD
PAProcessNFAUpdate(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    BOOL bAddedMMFilters = FALSE;

    dwError = PAUpdateAuthMethod(
                  pNewIpsecISAKMPData,
                  pOldIpsecNFAData,
                  pNewIpsecNFAData,
                  &bAddedMMFilters,
                  dwSource
                  );

    if (!bAddedMMFilters) {
        dwError = PAUpdateMMFilters(
                      pNewIpsecISAKMPData,
                      pOldIpsecNFAData,
                      pNewIpsecNFAData,
                      dwSource
                      );
    }

    dwError = PAProcessQMNFAUpdate(
                  pOldIpsecNFAData,
                  pNewIpsecNFAData,
                  dwSource
                  );

    return (dwError);
}


DWORD
PAUpdateAuthMethod(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    PBOOL pbAddedMMFilters,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    PMMAUTHSTATE pMMAuthState = NULL;
    BOOL bEqual = FALSE;
    PINT_MM_AUTH_METHODS pSPDMMAuthMethods = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwVersion = 0;

    *pbAddedMMFilters = FALSE;

    pMMAuthState = FindMMAuthState(
                       pOldIpsecNFAData->NFAIdentifier
                       );
    if (!pMMAuthState) {
        dwError = PAAddMMAuthMethods(
                      &pNewIpsecNFAData,
                      1,
                      dwSource
                      );
        dwError = PAAddMMFilterSpecs(
                      pNewIpsecISAKMPData,
                      pNewIpsecNFAData,
                      dwSource
                      );
        *pbAddedMMFilters = TRUE;
        return (dwError);
    }

    if (!(pMMAuthState->bInSPD)) {

        PADeleteMMAuthState(pMMAuthState);
        dwError = PAAddMMAuthMethods(
                      &pNewIpsecNFAData,
                      1,
                      dwSource
                      );
        dwError = PAAddMMFilterSpecs(
                      pNewIpsecISAKMPData,
                      pNewIpsecNFAData,
                      dwSource
                      );
        *pbAddedMMFilters = TRUE;
        return (dwError);
    }

    bEqual = EqualAuthMethodData(
                 pOldIpsecNFAData,
                 pNewIpsecNFAData
                 );
    if (bEqual) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    dwError = PACreateMMAuthMethods(
                  pNewIpsecNFAData,
                  &pSPDMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IntSetMMAuthMethods(
                  pServerName,
                  dwVersion,
                  pMMAuthState->gMMAuthID,
                  pSPDMMAuthMethods,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    if (pSPDMMAuthMethods) {
        PAFreeMMAuthMethods(pSPDMMAuthMethods);
    }

    return (dwError);
}


BOOL
EqualAuthMethodData(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData
    )
{
    BOOL bEqual = FALSE;
    DWORD dwOldCnt = 0;
    PIPSEC_AUTH_METHOD * ppOldAuthMethods = NULL;
    DWORD dwNewCnt = 0;
    PIPSEC_AUTH_METHOD * ppNewAuthMethods = NULL;
    DWORD i = 0;
    PIPSEC_AUTH_METHOD pNewAuthMethod = NULL;
    PIPSEC_AUTH_METHOD pOldAuthMethod = NULL;


    //
    // At this point, NFAIdentifier is same and
    // dwWhenChanged is different.
    //

    dwOldCnt = pOldIpsecNFAData->dwAuthMethodCount;
    ppOldAuthMethods = pOldIpsecNFAData->ppAuthMethods;

    dwNewCnt = pNewIpsecNFAData->dwAuthMethodCount;
    ppNewAuthMethods = pNewIpsecNFAData->ppAuthMethods;

    //
    // At this point, dwOldCnt >= 1 and ppOldAuthMethods != NULL.
    //

    if (!dwNewCnt || !ppNewAuthMethods) {
        return (FALSE);
    }

    if (dwOldCnt != dwNewCnt) {
        return (FALSE);
    }


    for (i = 0; i < dwNewCnt; i++) {

        pNewAuthMethod = *(ppNewAuthMethods + i);

        pOldAuthMethod = *(ppOldAuthMethods + i);

        bEqual = FALSE;

        bEqual = EqualAuthBundle(
                     pOldAuthMethod,
                     pNewAuthMethod
                     );

        if (!bEqual) {
            break;
        }

    }

    return (bEqual);
}


BOOL
EqualAuthBundle(
    PIPSEC_AUTH_METHOD pOldAuthMethod,
    PIPSEC_AUTH_METHOD pNewAuthMethod
    )
{
    BOOL bEqual = FALSE;
    DWORD dwOldAuthLen = 0;
    DWORD dwNewAuthLen = 0;


    if (pOldAuthMethod->dwAuthType != pNewAuthMethod->dwAuthType) {
        return (FALSE);
    }

    switch (pNewAuthMethod->dwAuthType) {

    case OAK_SSPI:

        bEqual = TRUE;
        break;

    default:

        //
        // Since auth version 2 also has auth version 1 fields filled in it, so
        // there is no need to explicitly compare exclusive auth version 2 fields.
        //

        dwOldAuthLen = pOldAuthMethod->dwAuthLen;
        dwNewAuthLen = pNewAuthMethod->dwAuthLen;

        if (pOldAuthMethod->dwAuthFlags != pNewAuthMethod->dwAuthFlags) {
            bEqual = FALSE;
            break;
        }

        if (!dwNewAuthLen || !(pNewAuthMethod->pszAuthMethod)) {
            bEqual = FALSE;
            break;
        }

        if (dwOldAuthLen != dwNewAuthLen) {
            bEqual = FALSE;
            break;
        }

        if (!memcmp(
                (LPBYTE) pNewAuthMethod->pszAuthMethod,
                (LPBYTE) pOldAuthMethod->pszAuthMethod,
                (dwNewAuthLen*sizeof(WCHAR)))) {
            bEqual = TRUE;
            break;
        }

        break;

    }
                
    return (bEqual);
}


DWORD
PAProcessQMNFAUpdate(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pOldIpsecNegPolData = NULL;
    PIPSEC_NEGPOL_DATA pNewIpsecNegPolData = NULL;
    BOOL bAddedQMFilters = FALSE;


    pOldIpsecNegPolData = pOldIpsecNFAData->pIpsecNegPolData;
    pNewIpsecNegPolData = pNewIpsecNFAData->pIpsecNegPolData;

    if (memcmp(
            &(pOldIpsecNegPolData->NegPolIdentifier),
            &(pNewIpsecNegPolData->NegPolIdentifier),
            sizeof(GUID))) {

        dwError = PADeleteQMInfoForNFA(pOldIpsecNFAData);

        dwError = PAAddQMInfoForNFA(pNewIpsecNFAData, dwSource);

    }
    else {

        dwError = PAProcessNegPolUpdate(
                      pOldIpsecNFAData,
                      pNewIpsecNFAData,
                      &bAddedQMFilters,
                      dwSource
                      );

        if (!bAddedQMFilters) {
            dwError = PAUpdateQMFilters(
                          pOldIpsecNFAData,
                          pNewIpsecNFAData,
                          dwSource
                          );
        }

    }

    return (dwError);
}


DWORD
PADeleteQMInfoForNFA(
    PIPSEC_NFA_DATA pOldIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pOldIpsecNegPolData = NULL;


    dwError = PADeleteQMFilterSpecs(
                  pOldIpsecNFAData
                  );

    pOldIpsecNegPolData = pOldIpsecNFAData->pIpsecNegPolData;

    dwError = PADeleteQMPolicy(
                  pOldIpsecNegPolData->NegPolIdentifier
                  );

    return (dwError);
}


DWORD
PAAddQMInfoForNFA(
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwSource
    )
{
    DWORD dwError = 0;


    dwError = PAAddQMPolicies(
                  &pNewIpsecNFAData,
                  1,
                  dwSource
                  );

    dwError = PAAddQMFilterSpecs(
                  pNewIpsecNFAData,
                  dwSource
                  );

    return (dwError);
}


DWORD
PAProcessNegPolUpdate(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    PBOOL pbAddedQMFilters,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pOldIpsecNegPolData = NULL;
    PIPSEC_NEGPOL_DATA pNewIpsecNegPolData = NULL;
    PQMPOLICYSTATE pQMPolicyState = NULL;
    BOOL bEqual = FALSE;
    PIPSEC_QM_POLICY pSPDQMPolicy = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwVersion = 0;

    *pbAddedQMFilters = FALSE;

    pOldIpsecNegPolData = pOldIpsecNFAData->pIpsecNegPolData;
    pNewIpsecNegPolData = pNewIpsecNFAData->pIpsecNegPolData;

    pQMPolicyState = FindQMPolicyState(
                         pOldIpsecNegPolData->NegPolIdentifier
                         );
    if (!pQMPolicyState) {
        dwError = PAAddQMInfoForNFA(pNewIpsecNFAData, dwSource);
        *pbAddedQMFilters = TRUE;
        return (dwError);
    }

    if (IsClearOnly(pQMPolicyState->gNegPolAction)) {
        if (IsClearOnly(pNewIpsecNegPolData->NegPolAction)) {
            dwError = ERROR_SUCCESS;
            return (dwError);
        }
        else {
            dwError = PADeleteQMInfoForNFA(pOldIpsecNFAData); 
            dwError = PAAddQMInfoForNFA(pNewIpsecNFAData, dwSource);
            *pbAddedQMFilters = TRUE;
            return (dwError);
        }
    }

    if (IsBlocking(pQMPolicyState->gNegPolAction)) {
        if (IsBlocking(pNewIpsecNegPolData->NegPolAction)) {
            dwError = ERROR_SUCCESS;
            return (dwError);
        }
        else {
            dwError = PADeleteQMInfoForNFA(pOldIpsecNFAData); 
            dwError = PAAddQMInfoForNFA(pNewIpsecNFAData, dwSource);
            *pbAddedQMFilters = TRUE;
            return (dwError);
        }
    }

    if (IsClearOnly(pNewIpsecNegPolData->NegPolAction)) {
        if (IsClearOnly(pQMPolicyState->gNegPolAction)) {
            dwError = ERROR_SUCCESS;
            return (dwError);
        }
        else {
            dwError = PADeleteQMInfoForNFA(pOldIpsecNFAData); 
            dwError = PAAddQMInfoForNFA(pNewIpsecNFAData, dwSource);
            *pbAddedQMFilters = TRUE;
            return (dwError);
        }
    }

    if (IsBlocking(pNewIpsecNegPolData->NegPolAction)) {
        if (IsBlocking(pQMPolicyState->gNegPolAction)) {
            dwError = ERROR_SUCCESS;
            return (dwError);
        }
        else {
            dwError = PADeleteQMInfoForNFA(pOldIpsecNFAData); 
            dwError = PAAddQMInfoForNFA(pNewIpsecNFAData, dwSource);
            *pbAddedQMFilters = TRUE;
            return (dwError);
        }
    }

    if (!(pQMPolicyState->bInSPD)) {
        PADeleteQMPolicy(pQMPolicyState->gPolicyID);
        dwError = PAAddQMInfoForNFA(pNewIpsecNFAData, dwSource);
        *pbAddedQMFilters = TRUE;
        return (dwError);
    }

    bEqual = EqualNegPolData(
                 pOldIpsecNegPolData,
                 pNewIpsecNegPolData
                 );
    if (bEqual) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    memcpy(
        &(pQMPolicyState->gNegPolType),
        &(pNewIpsecNegPolData->NegPolType),
        sizeof(GUID)
        );

    memcpy(
        &(pQMPolicyState->gNegPolAction),
        &(pNewIpsecNegPolData->NegPolAction),
        sizeof(GUID)
        );

    dwError = PACreateQMPolicy(
                  pNewIpsecNFAData,
                  pQMPolicyState,
                  &pSPDQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SetQMPolicy(
                  pServerName,
                  dwVersion,
                  pQMPolicyState->pszPolicyName,
                  pSPDQMPolicy,
                  NULL
                  );
    if (dwError != WARNING_IPSEC_QM_POLICY_PRUNED) {
        BAIL_ON_WIN32_ERROR(dwError);
    } else {
        dwError = ERROR_SUCCESS;
    }


error:

    if (pSPDQMPolicy) {
        PAFreeQMPolicy(pSPDQMPolicy);
    }

    return (dwError);
}


BOOL
EqualNegPolData(
    PIPSEC_NEGPOL_DATA pOldIpsecNegPolData,
    PIPSEC_NEGPOL_DATA pNewIpsecNegPolData
    )
{
    BOOL bEqual = FALSE;
    DWORD dwOldCnt = 0;
    PIPSEC_SECURITY_METHOD pOldSecurityMethods = NULL;
    DWORD dwNewCnt = 0;
    PIPSEC_SECURITY_METHOD pNewSecurityMethods = NULL;
    DWORD i = 0;
    PIPSEC_SECURITY_METHOD pNewTemp = NULL;
    PIPSEC_SECURITY_METHOD pOldTemp = NULL;


    //
    // At this point, pszPolicyName and NegPolIdentifier are same and
    // dwWhenChanged is different.
    //

    if (memcmp(
            &(pOldIpsecNegPolData->NegPolAction),
            &(pNewIpsecNegPolData->NegPolAction),
            sizeof(GUID))) {
        return (FALSE);
    }

    if (memcmp(
            &(pOldIpsecNegPolData->NegPolType),
            &(pNewIpsecNegPolData->NegPolType),
            sizeof(GUID))) {
        return (FALSE);
    }
 
    dwOldCnt = pOldIpsecNegPolData->dwSecurityMethodCount;
    pOldSecurityMethods = pOldIpsecNegPolData->pIpsecSecurityMethods;

    dwNewCnt = pNewIpsecNegPolData->dwSecurityMethodCount;
    pNewSecurityMethods = pNewIpsecNegPolData->pIpsecSecurityMethods;

    //
    // At this point, dwOldCnt >= 1 and pOldSecurityMethods != NULL.
    //

    if (!dwNewCnt || !pNewSecurityMethods) {
        return (FALSE);
    }

    if (dwOldCnt != dwNewCnt) {
        return (FALSE);
    }

    pNewTemp = pNewSecurityMethods;
    pOldTemp = pOldSecurityMethods;

    for (i = 0; i < dwNewCnt; i++) {

        bEqual = FALSE;

        bEqual = EqualSecurityMethod(
                     pOldTemp,
                     pNewTemp
                     );

        if (!bEqual) {
            break;
        }

        pOldTemp++;

        pNewTemp++;

    }

    return (bEqual);
}


BOOL
EqualSecurityMethod(
    PIPSEC_SECURITY_METHOD pOldBundle,
    PIPSEC_SECURITY_METHOD pNewBundle
    )
{
    DWORD i = 0;


    if (memcmp(
            &(pOldBundle->Lifetime),
            &(pNewBundle->Lifetime),
            sizeof(LIFETIME))) {
       return (FALSE);
    }

    if (pOldBundle->Flags != pNewBundle->Flags) {
        return (FALSE);
    }

    if (pOldBundle->PfsQMRequired != pNewBundle->PfsQMRequired) {
        return (FALSE);
    }

    if (pOldBundle->Count != pNewBundle->Count) {
        return (FALSE);
    }

    if (pNewBundle->Count == 0) {
        return (TRUE);
    }

    for (i = 0; i < (pNewBundle->Count); i++) {

        if (memcmp(
                &(pOldBundle->Algos[i]),
                &(pNewBundle->Algos[i]),
                sizeof(IPSEC_ALGO_INFO))) {
            return (FALSE);
        }

    }

    return (TRUE);
}


DWORD
PAUpdateMMFilters(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    BOOL bEqual = FALSE;
    PIPSEC_NEGPOL_DATA pOldIpsecNegPolData = NULL;
    PIPSEC_NEGPOL_DATA pNewIpsecNegPolData = NULL;

    pOldIpsecNegPolData = pOldIpsecNFAData->pIpsecNegPolData;
    pNewIpsecNegPolData = pNewIpsecNFAData->pIpsecNegPolData;

    bEqual = EqualFilterKeysInNegPols(
                 pOldIpsecNegPolData,
                 pNewIpsecNegPolData
                 );
    if (!bEqual) {
        dwError = PADeleteMMFilterSpecs(
                      pNewIpsecISAKMPData,
                      pOldIpsecNFAData
                      );
        dwError = PAAddMMFilterSpecs(
                      pNewIpsecISAKMPData,
                      pNewIpsecNFAData,
                      dwSource
                      );
        return (dwError);
    }

    bEqual = EqualFilterKeysInNFAs(
                 pOldIpsecNFAData,
                 pNewIpsecNFAData
                 );
    if (!bEqual) {
        dwError = PADeleteMMFilterSpecs(
                      pNewIpsecISAKMPData,
                      pOldIpsecNFAData
                      );
        dwError = PAAddMMFilterSpecs(
                      pNewIpsecISAKMPData,
                      pNewIpsecNFAData,
                      dwSource
                      );
        return (dwError);
    }

    if (!memcmp(
            &(pNewIpsecNegPolData->NegPolType), 
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if (IsClearOnly(pNewIpsecNegPolData->NegPolAction) ||
        IsBlocking(pNewIpsecNegPolData->NegPolAction)) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    dwError = PAProcessMMFilterDataForNFAs(
                  pNewIpsecISAKMPData,
                  pOldIpsecNFAData,
                  pNewIpsecNFAData,
                  dwSource
                  );

    return (dwError);
}


BOOL
EqualFilterKeysInNegPols(
    PIPSEC_NEGPOL_DATA pOldIpsecNegPolData,
    PIPSEC_NEGPOL_DATA pNewIpsecNegPolData
    )
{
    BOOL bOldAllowsSoft = FALSE;
    BOOL bNewAllowsSoft = FALSE;


    if (memcmp(
            &(pOldIpsecNegPolData->NegPolType),
            &(pNewIpsecNegPolData->NegPolType),
            sizeof(GUID))) {
        return (FALSE);
    }

    if (memcmp(
            &(pOldIpsecNegPolData->NegPolAction),
            &(pNewIpsecNegPolData->NegPolAction),
            sizeof(GUID))) {
        return (FALSE);
    }

    bOldAllowsSoft = AllowsSoft(
                         pOldIpsecNegPolData->dwSecurityMethodCount,
                         pOldIpsecNegPolData->pIpsecSecurityMethods
                         );

    bNewAllowsSoft = AllowsSoft(
                         pNewIpsecNegPolData->dwSecurityMethodCount,
                         pNewIpsecNegPolData->pIpsecSecurityMethods
                         );

    if (bOldAllowsSoft != bNewAllowsSoft) {
        return (FALSE);
    }

    return (TRUE);
}


BOOL
EqualFilterKeysInNFAs(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData
    )
{
    if (pOldIpsecNFAData->dwInterfaceType !=
        pNewIpsecNFAData->dwInterfaceType) {
        return (FALSE);
    }

    if (pOldIpsecNFAData->dwTunnelFlags !=
        pNewIpsecNFAData->dwTunnelFlags) {
        return (FALSE);
    }

    if (pOldIpsecNFAData->dwTunnelIpAddr !=
        pNewIpsecNFAData->dwTunnelIpAddr) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
PAProcessMMFilterDataForNFAs(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_DATA pOldIpsecFilterData = NULL;
    PIPSEC_FILTER_DATA pNewIpsecFilterData = NULL;
    DWORD dwNumOldFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppOldFilterSpecs = NULL;
    DWORD dwNumNewFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs = NULL;


    pOldIpsecFilterData = pOldIpsecNFAData->pIpsecFilterData;
    pNewIpsecFilterData = pNewIpsecNFAData->pIpsecFilterData;

    if (!pOldIpsecFilterData) {
        if (!pNewIpsecFilterData) {
            dwError = ERROR_SUCCESS;
            return (dwError);
        }
        else {
            dwError = PAAddMMFilterSpecs(
                          pNewIpsecISAKMPData,
                          pNewIpsecNFAData,
                          dwSource
                          );
            return (dwError);
        }
    }

    if (!pNewIpsecFilterData) {
        dwError = PADeleteMMFilterSpecs(
                      pNewIpsecISAKMPData,
                      pOldIpsecNFAData
                      );
        return (dwError);
    }

    if (memcmp(
            &(pOldIpsecFilterData->FilterIdentifier),
            &(pNewIpsecFilterData->FilterIdentifier),
            sizeof(GUID))) {
        dwError = PADeleteMMFilterSpecs(
                      pNewIpsecISAKMPData,
                      pOldIpsecNFAData
                      );
        dwError = PAAddMMFilterSpecs(
                      pNewIpsecISAKMPData,
                      pNewIpsecNFAData,
                      dwSource
                      );
        return (dwError);
    }

    dwNumOldFilterSpecs = pOldIpsecFilterData->dwNumFilterSpecs;
    ppOldFilterSpecs = pOldIpsecFilterData->ppFilterSpecs;

    dwNumNewFilterSpecs = pNewIpsecFilterData->dwNumFilterSpecs;
    ppNewFilterSpecs = pNewIpsecFilterData->ppFilterSpecs;

    dwError = PADeleteObseleteMMFilterSpecs(
                  pNewIpsecISAKMPData,
                  pOldIpsecNFAData,
                  dwNumOldFilterSpecs,
                  ppOldFilterSpecs,
                  pNewIpsecNFAData,
                  dwNumNewFilterSpecs,
                  ppNewFilterSpecs
                  );

    dwError = PAUpdateMMFilterSpecs(
                  pNewIpsecISAKMPData,
                  pOldIpsecNFAData,
                  dwNumOldFilterSpecs,
                  ppOldFilterSpecs,
                  pNewIpsecNFAData,
                  dwNumNewFilterSpecs,
                  ppNewFilterSpecs,
                  dwSource
                  );

    return (dwError);
}


DWORD
PADeleteObseleteMMFilterSpecs(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    DWORD dwNumOldFilterSpecs,
    PIPSEC_FILTER_SPEC * ppOldFilterSpecs,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwNumNewFilterSpecs,
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_FILTER_SPEC pOldFilterSpec = NULL;
    PIPSEC_FILTER_SPEC pFoundFilterSpec = NULL;

    for (i = 0; i < dwNumOldFilterSpecs; i++) {

        pOldFilterSpec = *(ppOldFilterSpecs + i);

        pFoundFilterSpec = FindFilterSpec(
                               pOldFilterSpec,
                               ppNewFilterSpecs,
                               dwNumNewFilterSpecs
                               );

        if (!pFoundFilterSpec) {
            dwError = PADeleteMMFilter(
                          pOldFilterSpec->FilterSpecGUID,
                          pOldIpsecNFAData->NFAIdentifier
                          );
        }

    }

    return (dwError);
}


PIPSEC_FILTER_SPEC
FindFilterSpec(
    PIPSEC_FILTER_SPEC pFilterSpec,
    PIPSEC_FILTER_SPEC * ppFilterSpecs,
    DWORD dwNumFilterSpecs
    )
{
    DWORD i = 0;
    PIPSEC_FILTER_SPEC pTemp = NULL;


    for (i = 0; i < dwNumFilterSpecs; i++) {

        pTemp = *(ppFilterSpecs + i);

        if (!memcmp(
                &(pFilterSpec->FilterSpecGUID),
                &(pTemp->FilterSpecGUID),
                sizeof(GUID))) {
            return (pTemp);
        }

    }

    return (NULL);
}


DWORD
PAUpdateMMFilterSpecs(
    PIPSEC_ISAKMP_DATA pNewIpsecISAKMPData,
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    DWORD dwNumOldFilterSpecs,
    PIPSEC_FILTER_SPEC * ppOldFilterSpecs,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwNumNewFilterSpecs,
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    PMMPOLICYSTATE pMMPolicyState = NULL;
    PMMAUTHSTATE pMMAuthState = NULL;
    DWORD i = 0;
    PIPSEC_FILTER_SPEC pNewFilterSpec = NULL;
    PIPSEC_FILTER_SPEC pFoundFilterSpec = NULL;
    BOOL bEqual = FALSE;
    PMMFILTERSTATE pMMFilterState = NULL;


    pMMPolicyState = FindMMPolicyState(
                         pNewIpsecISAKMPData->ISAKMPIdentifier
                         );
    if (!pMMPolicyState || !(pMMPolicyState->bInSPD)) {
        TRACE(
            TRC_ERROR,
            (L"Pastore update failed to find SPD MM policy state associated with ISAKMP policy %!guid!.",
            &pNewIpsecISAKMPData->ISAKMPIdentifier)
            );            
        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
    }

    pMMAuthState = FindMMAuthState(
                       pNewIpsecNFAData->NFAIdentifier
                       );
    if (!pMMAuthState || !(pMMAuthState->bInSPD)) {
        TRACE(
            TRC_ERROR,
            (L"Pastore update failed to find SPD MM auth method state associated with NFA %!guid!.",
            &pNewIpsecNFAData->NFAIdentifier)
            );            
        
        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
    }

    for (i = 0; i < dwNumNewFilterSpecs; i++) {

        pNewFilterSpec = *(ppNewFilterSpecs + i);

        pFoundFilterSpec = FindFilterSpec(
                               pNewFilterSpec,
                               ppOldFilterSpecs,
                               dwNumOldFilterSpecs
                               );

        if (!pFoundFilterSpec) {
            dwError = PAAddMMFilterSpec(
                          pNewIpsecISAKMPData,
                          pNewIpsecNFAData,
                          pNewFilterSpec,
                          dwSource
                          );
        }
        else {
            bEqual = FALSE;
            bEqual = EqualFilterSpecs(
                         pFoundFilterSpec,
                         pNewFilterSpec
                         );
            if (!bEqual) {
                // ASSERT: pOldIpsecNFAData->NFAIdentifier == pNewIpsecNFAData->NFAIdentifier 
                //
                dwError = PADeleteMMFilter(
                              pFoundFilterSpec->FilterSpecGUID,
                              pOldIpsecNFAData->NFAIdentifier
                              );
                dwError = PAAddMMFilterSpec(
                              pNewIpsecISAKMPData,
                              pNewIpsecNFAData,
                              pNewFilterSpec,
                              dwSource
                              ); 
            }
            else {
                // ASSERT: pOldIpsecNFAData->NFAIdentifier == pNewIpsecNFAData->NFAIdentifier 
                //
                pMMFilterState = FindMMFilterState(
                                     pFoundFilterSpec->FilterSpecGUID,
                                     pNewIpsecNFAData->NFAIdentifier
                                     );
                if (!pMMFilterState) {
                    dwError = PAAddMMFilterSpec(
                                  pNewIpsecISAKMPData,
                                  pNewIpsecNFAData,
                                  pNewFilterSpec,
                                  dwSource
                                  ); 
                }
                else {
                    if (!pMMFilterState->hMMFilter) {
                        PADeleteMMFilterState(pMMFilterState);
                        dwError = PAAddMMFilterSpec(
                                      pNewIpsecISAKMPData,
                                      pNewIpsecNFAData,
                                      pNewFilterSpec,
                                      dwSource
                                      );
                    }
                }
            }
        }
    }

    return (dwError);
}


DWORD
PAAddMMFilterSpec(
    PIPSEC_ISAKMP_DATA pIpsecISAKMPData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    PMMFILTERSTATE pMMFilterState = NULL;
    PMM_FILTER pSPDMMFilter = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwVersion = 0;


    dwError = PACreateMMFilterState(
                  pIpsecISAKMPData,
                  pIpsecNFAData,
                  pFilterSpec,
                  &pMMFilterState
                  );
    if (dwError) {
        return (dwError);
    }

    dwError = PACreateMMFilter(
                  pIpsecISAKMPData,
                  pIpsecNFAData,
                  pFilterSpec,
                  &pSPDMMFilter
                  );
    if (dwError) {

        pMMFilterState->hMMFilter = NULL;

        pMMFilterState->pNext = gpMMFilterState;
        gpMMFilterState = pMMFilterState;

        return (dwError);

    }

    dwError = AddMMFilterInternal(
                  pServerName,
                  dwVersion,
                  0,
                  dwSource,
                  pSPDMMFilter,
                  NULL,
                  &(pMMFilterState->hMMFilter)
                  );

    pMMFilterState->pNext = gpMMFilterState;
    gpMMFilterState = pMMFilterState;

    PAFreeMMFilter(pSPDMMFilter);

    return (dwError);
}


BOOL
EqualFilterSpecs(
    PIPSEC_FILTER_SPEC pOldFilterSpec,
    PIPSEC_FILTER_SPEC pNewFilterSpec
    )
{
    BOOL bEqual = FALSE;


    //
    // At this point, FilterSpecGUID is same.
    //

    bEqual = AreNamesEqual(
                 pOldFilterSpec->pszDescription,
                 pNewFilterSpec->pszDescription
                 );
    if (!bEqual) {
        return (FALSE);
    }

    if (pOldFilterSpec->dwMirrorFlag !=
        pNewFilterSpec->dwMirrorFlag) {
        return (FALSE);
    }

    if (memcmp(
            &(pOldFilterSpec->Filter),
            &(pNewFilterSpec->Filter),
            sizeof(IPSEC_FILTER))) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
PAUpdateQMFilters(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    BOOL bEqual = FALSE;
    PIPSEC_NEGPOL_DATA pOldIpsecNegPolData = NULL;
    PIPSEC_NEGPOL_DATA pNewIpsecNegPolData = NULL;
    BOOL bHardError = FALSE;

    pOldIpsecNegPolData = pOldIpsecNFAData->pIpsecNegPolData;
    pNewIpsecNegPolData = pNewIpsecNFAData->pIpsecNegPolData;

    bEqual = EqualFilterKeysInNegPols(
                 pOldIpsecNegPolData,
                 pNewIpsecNegPolData
                 );
    if (!bEqual) {
        dwError = PADeleteQMFilterSpecs(
                      pOldIpsecNFAData
                      );
        dwError = PAAddQMFilterSpecs(
                      pNewIpsecNFAData,
                      dwSource
                      );
        return (dwError);
    }

    bEqual = EqualFilterKeysInNFAs(
                 pOldIpsecNFAData,
                 pNewIpsecNFAData
                 );
    if (!bEqual) {
        dwError = PADeleteQMFilterSpecs(
                      pOldIpsecNFAData
                      );
        dwError = PAAddQMFilterSpecs(
                      pNewIpsecNFAData,
                      dwSource
                      );
        return (dwError);
    }

    if (!memcmp(
            &(pNewIpsecNegPolData->NegPolType), 
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    dwError = PAProcessQMFilterDataForNFAs(
                  pOldIpsecNFAData,
                  pNewIpsecNFAData,
                  dwSource
                  );

    // Not returning bHardError from here because for DCR 537526 we decided not to do
    // anything for errors during updates.

    return (dwError);
}


DWORD
PAAddQMFilterSpecs(
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    BOOL bHardError = FALSE;

    if (!(pNewIpsecNFAData->dwTunnelFlags)) {
        dwError = PAAddTxFilterSpecs(
                      pNewIpsecNFAData,
                      dwSource,
                      &bHardError
                      );
    }
    else {
        dwError = PAAddTnFilterSpecs(
                      pNewIpsecNFAData,
                      dwSource,
                      &bHardError                      
                      );
    }

    // Not returning bHardError from here because for DCR 537526 we decided not to do
    // anything for errors during updates.
    
    return (dwError);
}


DWORD
PADeleteQMFilterSpecs(
    PIPSEC_NFA_DATA pOldIpsecNFAData
    )
{
    DWORD dwError = 0;

    if (!(pOldIpsecNFAData->dwTunnelFlags)) {
        dwError = PADeleteTxFilterSpecs(
                      pOldIpsecNFAData
                      );
    }
    else {
        dwError = PADeleteTnFilterSpecs(
                      pOldIpsecNFAData
                      );
    }

    return (dwError);
}


DWORD
PAProcessQMFilterDataForNFAs(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    PIPSEC_FILTER_DATA pOldIpsecFilterData = NULL;
    PIPSEC_FILTER_DATA pNewIpsecFilterData = NULL;
    DWORD dwNumOldFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppOldFilterSpecs = NULL;
    DWORD dwNumNewFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs = NULL;


    pOldIpsecFilterData = pOldIpsecNFAData->pIpsecFilterData;
    pNewIpsecFilterData = pNewIpsecNFAData->pIpsecFilterData;

    if (!pOldIpsecFilterData) {
        if (!pNewIpsecFilterData) {
            dwError = ERROR_SUCCESS;
            return (dwError);
        }
        else {
            dwError = PAAddQMFilterSpecs(
                          pNewIpsecNFAData,
                          dwSource
                          );
            return (dwError);
        }
    }

    if (!pNewIpsecFilterData) {
        dwError = PADeleteQMFilterSpecs(
                      pOldIpsecNFAData
                      );
        return (dwError);
    }

    if (memcmp(
            &(pOldIpsecFilterData->FilterIdentifier),
            &(pNewIpsecFilterData->FilterIdentifier),
            sizeof(GUID))) {
        dwError = PADeleteQMFilterSpecs(
                      pOldIpsecNFAData
                      );
        dwError = PAAddQMFilterSpecs(
                      pNewIpsecNFAData,
                      dwSource
                      );
        return (dwError);
    }

    dwNumOldFilterSpecs = pOldIpsecFilterData->dwNumFilterSpecs;
    ppOldFilterSpecs = pOldIpsecFilterData->ppFilterSpecs;

    dwNumNewFilterSpecs = pNewIpsecFilterData->dwNumFilterSpecs;
    ppNewFilterSpecs = pNewIpsecFilterData->ppFilterSpecs;

    dwError = PADeleteObseleteQMFilterSpecs(
                  pOldIpsecNFAData,
                  dwNumOldFilterSpecs,
                  ppOldFilterSpecs,
                  pNewIpsecNFAData,
                  dwNumNewFilterSpecs,
                  ppNewFilterSpecs
                  );

    dwError = PAUpdateQMFilterSpecs(
                  pOldIpsecNFAData,
                  dwNumOldFilterSpecs,
                  ppOldFilterSpecs,
                  pNewIpsecNFAData,
                  dwNumNewFilterSpecs,
                  ppNewFilterSpecs,
                  dwSource
                  );

    return (dwError);
}


DWORD
PADeleteObseleteQMFilterSpecs(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    DWORD dwNumOldFilterSpecs,
    PIPSEC_FILTER_SPEC * ppOldFilterSpecs,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwNumNewFilterSpecs,
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_FILTER_SPEC pOldFilterSpec = NULL;
    PIPSEC_FILTER_SPEC pFoundFilterSpec = NULL;


    for (i = 0; i < dwNumOldFilterSpecs; i++) {

        pOldFilterSpec = *(ppOldFilterSpecs + i);

        pFoundFilterSpec = FindFilterSpec(
                               pOldFilterSpec,
                               ppNewFilterSpecs,
                               dwNumNewFilterSpecs
                               );

        if (!pFoundFilterSpec) {
            dwError = PADeleteQMFilter(
                          pOldIpsecNFAData,
                          pOldFilterSpec->FilterSpecGUID
                          );
        }

    }

    return (dwError);
}


DWORD
PAUpdateQMFilterSpecs(
    PIPSEC_NFA_DATA pOldIpsecNFAData,
    DWORD dwNumOldFilterSpecs,
    PIPSEC_FILTER_SPEC * ppOldFilterSpecs,
    PIPSEC_NFA_DATA pNewIpsecNFAData,
    DWORD dwNumNewFilterSpecs,
    PIPSEC_FILTER_SPEC * ppNewFilterSpecs,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pNewIpsecNegPolData = NULL;
    PQMPOLICYSTATE pQMPolicyState = NULL;
    DWORD i = 0;
    PIPSEC_FILTER_SPEC pNewFilterSpec = NULL;
    PIPSEC_FILTER_SPEC pFoundFilterSpec = NULL;
    BOOL bEqual = FALSE;


    pNewIpsecNegPolData = pNewIpsecNFAData->pIpsecNegPolData;

    pQMPolicyState = FindQMPolicyState(
                         pNewIpsecNegPolData->NegPolIdentifier
                         );
    if (!pQMPolicyState) {
        TRACE(
            TRC_ERROR,
            (L"Pastore update failed to find SPD QM policy state associated for neg pol %!guid!.",
            &pNewIpsecNegPolData->NegPolIdentifier)
            );            
        
        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
    }

    if (!IsClearOnly(pQMPolicyState->gNegPolAction) &&
        !IsBlocking(pQMPolicyState->gNegPolAction) &&
        !(pQMPolicyState->bInSPD)) {
        TRACE(
            TRC_ERROR,
            (L"Pastore update failed to find SPD QM policy plumbed into SPD for neg pol %!guid!.",
            &pNewIpsecNegPolData->NegPolIdentifier)
            );            
        
        dwError = ERROR_INVALID_PARAMETER;
        return (dwError);
    }

    for (i = 0; i < dwNumNewFilterSpecs; i++) {

        pNewFilterSpec = *(ppNewFilterSpecs + i);

        pFoundFilterSpec = FindFilterSpec(
                               pNewFilterSpec,
                               ppOldFilterSpecs,
                               dwNumOldFilterSpecs
                               );

        if (!pFoundFilterSpec) {
            dwError = PAAddQMFilterSpec(
                          pNewIpsecNFAData,
                          pQMPolicyState,
                          pNewFilterSpec,
                          dwSource
                          );
        }
        else {
            bEqual = FALSE;
            bEqual = EqualFilterSpecs(
                         pFoundFilterSpec,
                         pNewFilterSpec
                         );
            if (!bEqual) {
                dwError = PADeleteQMFilter(
                              pOldIpsecNFAData,
                              pFoundFilterSpec->FilterSpecGUID
                              );
                dwError = PAAddQMFilterSpec(
                              pNewIpsecNFAData,
                              pQMPolicyState,
                              pNewFilterSpec,
                              dwSource
                              ); 
            }
            else {
                dwError = PAUpdateQMFilterSpec(
                              pNewIpsecNFAData,
                              pQMPolicyState,
                              pNewFilterSpec,
                              dwSource
                              );
            }
        }
    }

    return (dwError);
}


DWORD
PADeleteQMFilter(
    PIPSEC_NFA_DATA pIpsecNFAData,
    GUID FilterSpecGUID
    )
{
    DWORD dwError = 0;


    if (!(pIpsecNFAData->dwTunnelFlags)) {
        dwError = PADeleteTxFilter(
                      FilterSpecGUID,
                      pIpsecNFAData->NFAIdentifier
                      );
    }
    else {
        dwError = PADeleteTnFilter(
                      FilterSpecGUID,
                      pIpsecNFAData->NFAIdentifier
                      );
    }

    return (dwError);
}


DWORD
PAAddQMFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec,
    DWORD dwSource
    )
{
    DWORD dwError = 0;


    if (!(pIpsecNFAData->dwTunnelFlags)) {
        dwError = PAAddTxFilterSpec(
                      pIpsecNFAData,
                      pQMPolicyState,
                      pFilterSpec,
                      dwSource
                      );
    }
    else {
        dwError = PAAddTnFilterSpec(
                      pIpsecNFAData,
                      pQMPolicyState,
                      pFilterSpec,
                      dwSource
                      );
    }

    return (dwError);
}


DWORD
PAAddTxFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PTXFILTERSTATE pTxFilterState = NULL;
    PTRANSPORT_FILTER pSPDTxFilter = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwVersion = 0;


    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    dwError = PACreateTxFilterState(
                  pIpsecNegPolData,
                  pIpsecNFAData,
                  pFilterSpec,
                  &pTxFilterState
                  );
    if (dwError) {
        return (dwError);
    }

    dwError = PACreateTxFilter(
                  pIpsecNegPolData,
                  pIpsecNFAData,
                  pFilterSpec,
                  pQMPolicyState,
                  &pSPDTxFilter
                  );
    if (dwError) {

        pTxFilterState->hTxFilter = NULL;

        pTxFilterState->pNext = gpTxFilterState;
        gpTxFilterState = pTxFilterState;

        return (dwError);

    }

    dwError = AddTransportFilterInternal(
                  pServerName,
                  dwVersion,
                  0,
                  dwSource,
                  pSPDTxFilter,
                  NULL,
                  &(pTxFilterState->hTxFilter)
                  );

    pTxFilterState->pNext = gpTxFilterState;
    gpTxFilterState = pTxFilterState;

    PAFreeTxFilter(pSPDTxFilter);

    return (dwError);
}


DWORD
PAAddTnFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PTNFILTERSTATE pTnFilterState = NULL;
    PTUNNEL_FILTER pSPDTnFilter = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwVersion = 0;


    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    dwError = PACreateTnFilterState(
                  pIpsecNegPolData,
                  pIpsecNFAData,
                  pFilterSpec,
                  &pTnFilterState
                  );
    if (dwError) {
        return (dwError);
    }

    dwError = PACreateTnFilter(
                  pIpsecNegPolData,
                  pIpsecNFAData,
                  pFilterSpec,
                  pQMPolicyState,
                  &pSPDTnFilter
                  );
    if (dwError) {

        pTnFilterState->hTnFilter = NULL;

        pTnFilterState->pNext = gpTnFilterState;
        gpTnFilterState = pTnFilterState;

        return (dwError);

    }

    dwError = AddTunnelFilterInternal(
                  pServerName,
                  dwVersion,
                  0,
                  dwSource,
                  pSPDTnFilter,
                  NULL,
                  &(pTnFilterState->hTnFilter)
                  );

    pTnFilterState->pNext = gpTnFilterState;
    gpTnFilterState = pTnFilterState;

    PAFreeTnFilter(pSPDTnFilter);

    return (dwError);
}


BOOL
AllowsSoft(
    DWORD dwSecurityMethodCount,
    PIPSEC_SECURITY_METHOD pIpsecSecurityMethods
    )
{
    DWORD dwTempOfferCount = 0;
    PIPSEC_SECURITY_METHOD pTempMethod = NULL;
    BOOL bAllowsSoft = FALSE;
    DWORD i = 0;


    if (!dwSecurityMethodCount || !pIpsecSecurityMethods) {
        return (FALSE);
    }

    if (dwSecurityMethodCount > IPSEC_MAX_QM_OFFERS) {
        dwTempOfferCount = IPSEC_MAX_QM_OFFERS;
    }
    else {
        dwTempOfferCount = dwSecurityMethodCount;
    }

    pTempMethod = pIpsecSecurityMethods;
 
    for (i = 0; i < dwTempOfferCount; i++) {

        if (pTempMethod->Count == 0) {
            bAllowsSoft = TRUE;
            break;
        }

        pTempMethod++;

    }

    return (bAllowsSoft);
}


DWORD
PAUpdateQMFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec,
    DWORD dwSource
    )
{
    DWORD dwError = 0;


    if (!(pIpsecNFAData->dwTunnelFlags)) {

        dwError = PAUpdateTxFilterSpec(
                      pIpsecNFAData,
                      pQMPolicyState,
                      pFilterSpec,
                      dwSource
                      );

    }
    else {

        dwError = PAUpdateTnFilterSpec(
                      pIpsecNFAData,
                      pQMPolicyState,
                      pFilterSpec,
                      dwSource
                      );

    }

    return (dwError);
}


DWORD
PAUpdateTxFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    PTXFILTERSTATE pTxFilterState = NULL;


    pTxFilterState = FindTxFilterState(
                         pFilterSpec->FilterSpecGUID,
                         pIpsecNFAData->NFAIdentifier
                         );
    if (!pTxFilterState) {
        dwError = PAAddTxFilterSpec(
                      pIpsecNFAData,
                      pQMPolicyState,
                      pFilterSpec,
                      dwSource
                      ); 
    }
    else {
        if (!pTxFilterState->hTxFilter) {
            PADeleteTxFilterState(pTxFilterState);
            dwError = PAAddTxFilterSpec(
                          pIpsecNFAData,
                          pQMPolicyState,
                          pFilterSpec,
                          dwSource
                          ); 
        }
    }

    return (dwError);
}


DWORD
PAUpdateTnFilterSpec(
    PIPSEC_NFA_DATA pIpsecNFAData,
    PQMPOLICYSTATE pQMPolicyState,
    PIPSEC_FILTER_SPEC pFilterSpec,
    DWORD dwSource
    )
{
    DWORD dwError = 0;
    PTNFILTERSTATE pTnFilterState = NULL;


    pTnFilterState = FindTnFilterState(
                         pFilterSpec->FilterSpecGUID,
                         pIpsecNFAData->NFAIdentifier
                         );
    if (!pTnFilterState) {
        dwError = PAAddTnFilterSpec(
                      pIpsecNFAData,
                      pQMPolicyState,
                      pFilterSpec,
                      dwSource
                      ); 
    }
    else {
        if (!pTnFilterState->hTnFilter) {
            PADeleteTnFilterState(pTnFilterState);
            dwError = PAAddTnFilterSpec(
                          pIpsecNFAData,
                          pQMPolicyState,
                          pFilterSpec,
                          dwSource
                          );
        }
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\patx-fil.c ===
#include "precomp.h"
#ifdef TRACE_ON
#include "patx-fil.tmh"
#endif


DWORD
PAAddQMFilters(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount,
    DWORD dwSource,
    BOOL * pbHardError
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;
    BOOL bHardError = FALSE;
    BOOL bTempHardError = FALSE;

    for (i = 0; i < dwNumNFACount; i++) {

        pIpsecNFAData = *(ppIpsecNFAData + i);

        if (!(pIpsecNFAData->dwTunnelFlags)) {

            dwError = PAAddTxFilterSpecs(
                          pIpsecNFAData,
                          dwSource,
                          &bTempHardError
                          );

        }
        else {

            dwError = PAAddTnFilterSpecs(
                          pIpsecNFAData,
                          dwSource,
                          &bTempHardError
                          );

        }
        
        if (bTempHardError) {
            bHardError = TRUE;
            AuditIPSecPolicyErrorEvent(
                SE_CATEGID_POLICY_CHANGE,
                SE_AUDITID_IPSEC_POLICY_CHANGED,
                PASTORE_ADD_QM_FILTER_FAIL,
                pIpsecNFAData->pszIpsecName,
                dwError,
                FALSE,
                TRUE
                );
        }
    }      

    (*pbHardError) = bHardError;
    
    return (dwError);
}

DWORD
PAAddTxFilterSpecs(
    PIPSEC_NFA_DATA pIpsecNFAData,
    DWORD dwSource,
    BOOL * pbHardError    
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    PQMPOLICYSTATE pQMPolicyState = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppFilterSpecs = NULL;
    DWORD i = 0;
    PTXFILTERSTATE pTxFilterState = NULL;
    PTRANSPORT_FILTER pSPDTxFilter = NULL;
    LPWSTR pServerName = NULL;
    DWORD dwVersion = 0;
    BOOL bHardError = FALSE;

    TRACE(TRC_INFORMATION, ("Pastore adding transport filters for rule %!guid!.", &pIpsecNFAData->NFAIdentifier));
    
    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    if (!memcmp(
            &(pIpsecNegPolData->NegPolType), 
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {
        TRACE(TRC_INFORMATION, ("Pastore found default response rule: not adding an associated transport filter."));            
        dwError = ERROR_SUCCESS;
        BAIL_OUT;
    }

    pQMPolicyState = FindQMPolicyState(
                         pIpsecNegPolData->NegPolIdentifier
                         );
    if (!pQMPolicyState) {
        bHardError = TRUE;
        dwError = ERROR_INVALID_PARAMETER;

        TRACE(
            TRC_ERROR,
            ("Pastore failed to find associated QM policy %!guid! when adding rule %!guid!.",
            &pIpsecNegPolData->NegPolIdentifier,
            &pIpsecNFAData->NFAIdentifier)
            );
        
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!IsClearOnly(pQMPolicyState->gNegPolAction) &&
        !IsBlocking(pQMPolicyState->gNegPolAction) &&
        !(pQMPolicyState->bInSPD)) {
        bHardError = TRUE;
        dwError = ERROR_INVALID_PARAMETER;

        TRACE(
            TRC_ERROR,
            ("Pastore failed to get associated QM policy in SPD %!guid! when adding rule %!guid!.",
            &pIpsecNFAData->NFAIdentifier,
            &pIpsecNegPolData->NegPolIdentifier)
            );
        
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    pIpsecFilterData = pIpsecNFAData->pIpsecFilterData;

    if (!pIpsecFilterData) {
        TRACE(
            TRC_ERROR,
            ("Pastore found no associated filter data when adding rule %!guid!.",
            &pIpsecNFAData->NFAIdentifier)
            );
        
        dwError = ERROR_INVALID_PARAMETER;
        SET_IF_HARD_ERROR(
            dwError,
            pQMPolicyState->gNegPolAction,
            bHardError
            );
        if (!bHardError) {
            dwError = ERROR_SUCCESS;
        }
        BAIL_OUT;
    }

    dwNumFilterSpecs = pIpsecFilterData->dwNumFilterSpecs;
    ppFilterSpecs = pIpsecFilterData->ppFilterSpecs;
    

    for (i = 0; i < dwNumFilterSpecs; i++) {

        dwError = PACreateTxFilterState(
                      pIpsecNegPolData,
                      pIpsecNFAData,
                      *(ppFilterSpecs + i),
                      &pTxFilterState
                      );
        if (dwError) {
            SET_IF_HARD_ERROR(
                dwError,
                pQMPolicyState->gNegPolAction,
                bHardError
            ); 
            continue;
        }

        dwError = PACreateTxFilter(
                      pIpsecNegPolData,
                      pIpsecNFAData,
                      *(ppFilterSpecs + i),
                      pQMPolicyState,
                      &pSPDTxFilter
                      );
        if (dwError) {
            pTxFilterState->hTxFilter = NULL;

            pTxFilterState->pNext = gpTxFilterState;
            gpTxFilterState = pTxFilterState;

            SET_IF_HARD_ERROR(
                dwError,
                pQMPolicyState->gNegPolAction,
                bHardError
            ); 

            continue;

        }

        dwError = AddTransportFilterInternal(
                      pServerName,
                      dwVersion,
                      0,
                      dwSource,
                      pSPDTxFilter,
                      NULL,
                      &(pTxFilterState->hTxFilter)
                      );
        // Catch the driver error that can happen because of adding duplicated 
        // expanded filters.  We don't want this to be a hard error.
        //
        if (dwError == STATUS_DUPLICATE_OBJECTID
            || dwError == GPC_STATUS_CONFLICT) 
        {
            AuditIPSecPolicyErrorEvent(
                    SE_CATEGID_POLICY_CHANGE,
                    SE_AUDITID_IPSEC_POLICY_CHANGED,
                    PASTORE_ADD_QM_FILTER_FAIL,
                    pIpsecNFAData->pszIpsecName,
                    dwError,
                    FALSE,
                    TRUE
                    );
        }  else {
            SET_IF_HARD_ERROR(
                dwError,
                pQMPolicyState->gNegPolAction,
                bHardError
            ); 
        }

        pTxFilterState->pNext = gpTxFilterState;
        gpTxFilterState = pTxFilterState;

        PAFreeTxFilter(pSPDTxFilter);

    }

error:
    *pbHardError = bHardError;

    return (dwError);
}

DWORD
PACreateTxFilterState(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PTXFILTERSTATE * ppTxFilterState
    )
{
    DWORD dwError = 0;
    PTXFILTERSTATE pTxFilterState = NULL;


    dwError = AllocateSPDMemory(
                  sizeof(TXFILTERSTATE),
                  &pTxFilterState
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pTxFilterState->gFilterID),
        &(pFilterSpec->FilterSpecGUID),
        sizeof(GUID)
        );

    memcpy(
        &(pTxFilterState->gNFAIdentifier),
        &(pIpsecNFAData->NFAIdentifier),
        sizeof(GUID)
        );

    memcpy(
        &(pTxFilterState->gPolicyID),
        &(pIpsecNegPolData->NegPolIdentifier),
        sizeof(GUID)
        );

    pTxFilterState->hTxFilter = NULL;
    pTxFilterState->pNext = NULL;

    *ppTxFilterState = pTxFilterState;

    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        ("Pastore failed to create state node for transport filter %!guid!. %!winerr!", 
        &pFilterSpec->FilterSpecGUID,
        dwError)
        );

    *ppTxFilterState = NULL;

    return (dwError);
}

DWORD
PACreateTxFilter(
    PIPSEC_NEGPOL_DATA pIpsecNegPolData,
    PIPSEC_NFA_DATA pIpsecNFAData,
    PIPSEC_FILTER_SPEC pFilterSpec,
    PQMPOLICYSTATE pQMPolicyState,
    PTRANSPORT_FILTER * ppSPDTxFilter
    )
{
    DWORD dwError = 0;
    PTRANSPORT_FILTER pSPDTxFilter = NULL;
    WCHAR pszName[512];


    dwError = AllocateSPDMemory(
                  sizeof(TRANSPORT_FILTER),
                  &pSPDTxFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pSPDTxFilter->IpVersion = IPSEC_PROTOCOL_V4;

    memcpy(
        &(pSPDTxFilter->gFilterID),
        &(pFilterSpec->FilterSpecGUID),
        sizeof(GUID)
        );

    if (pFilterSpec->pszDescription && *(pFilterSpec->pszDescription)) {

        dwError = AllocateSPDString(
                      pFilterSpec->pszDescription,
                      &(pSPDTxFilter->pszFilterName)
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }
    else {

        wsprintf(pszName, L"%d", ++gdwTxFilterCounter);

        dwError = AllocateSPDString(
                      pszName,
                      &(pSPDTxFilter->pszFilterName)
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    PASetInterfaceType(
        pIpsecNFAData->dwInterfaceType,
        &(pSPDTxFilter->InterfaceType)
        );

    pSPDTxFilter->bCreateMirror = (BOOL) pFilterSpec->dwMirrorFlag;

    pSPDTxFilter->dwFlags = 0;

    PASetAddress(
        pFilterSpec->Filter.SrcMask,
        pFilterSpec->Filter.SrcAddr,
        &(pSPDTxFilter->SrcAddr)
        );

    PASetAddress(
        pFilterSpec->Filter.DestMask,
        pFilterSpec->Filter.DestAddr, 
        &(pSPDTxFilter->DesAddr)
        );

    if (pFilterSpec->Filter.ExType) {
        if (pFilterSpec->Filter.ExType & EXT_DEST) {
          pSPDTxFilter->DesAddr.AddrType = ExTypeToAddrType(
                                              pFilterSpec->Filter.ExType
                                              );
        } else {
          pSPDTxFilter->SrcAddr.AddrType = ExTypeToAddrType(
                                              pFilterSpec->Filter.ExType
                                              );
        }
    }

        
    pSPDTxFilter->Protocol.ProtocolType = PROTOCOL_UNIQUE;
    pSPDTxFilter->Protocol.dwProtocol = pFilterSpec->Filter.Protocol;

    pSPDTxFilter->SrcPort.PortType = PORT_UNIQUE;
    pSPDTxFilter->SrcPort.wPort = pFilterSpec->Filter.SrcPort;

    pSPDTxFilter->DesPort.PortType = PORT_UNIQUE;
    pSPDTxFilter->DesPort.wPort = pFilterSpec->Filter.DestPort;

    SetFilterActions(
        pQMPolicyState,
        &(pSPDTxFilter->InboundFilterAction),
        &(pSPDTxFilter->OutboundFilterAction)
        );

    pSPDTxFilter->dwDirection = 0;

    pSPDTxFilter->dwWeight = 0;

    memcpy(
        &(pSPDTxFilter->gPolicyID),
        &(pIpsecNegPolData->NegPolIdentifier),
        sizeof(GUID)
        );

    *ppSPDTxFilter = pSPDTxFilter;

    return (dwError);

error:
    TRACE(
        TRC_WARNING,
        ("Pastore failed to create transport filter %!guid!. %!winerr!", 
        &pFilterSpec->FilterSpecGUID,
        dwError)
        );

    if (pSPDTxFilter) {
        PAFreeTxFilter(
            pSPDTxFilter
            );
    }

    *ppSPDTxFilter = NULL;

    return (dwError);
}


VOID
SetFilterActions(
    PQMPOLICYSTATE pQMPolicyState,
    PFILTER_ACTION pInboundFilterFlag,
    PFILTER_ACTION pOutboundFilterFlag
    )
{
    *pInboundFilterFlag = NEGOTIATE_SECURITY;
    *pOutboundFilterFlag = NEGOTIATE_SECURITY;

    if (IsBlocking(pQMPolicyState->gNegPolAction)) {
        *pInboundFilterFlag = BLOCKING;
        *pOutboundFilterFlag = BLOCKING;
    }
    else if (IsClearOnly(pQMPolicyState->gNegPolAction)) {
        *pInboundFilterFlag = PASS_THRU;
        *pOutboundFilterFlag = PASS_THRU;
    }
    else if (IsInboundPassThru(pQMPolicyState->gNegPolAction)) {
        *pInboundFilterFlag = PASS_THRU;
    }

    if (pQMPolicyState->bAllowsSoft && gbBackwardSoftSA) {
        *pInboundFilterFlag = PASS_THRU;
    }
}

    
VOID
PAFreeTxFilter(
    PTRANSPORT_FILTER pSPDTxFilter
    )
{
    if (pSPDTxFilter) {

        if (pSPDTxFilter->pszFilterName) {
            FreeSPDString(pSPDTxFilter->pszFilterName);
        }

        FreeSPDMemory(pSPDTxFilter);

    }

    return;
}


DWORD
PADeleteAllTxFilters(
    )
{
    DWORD dwError = 0;
    PTXFILTERSTATE pTxFilterState = NULL;
    PTXFILTERSTATE pTemp = NULL;
    PTXFILTERSTATE pLeftTxFilterState = NULL;

    TRACE(TRC_INFORMATION, (L"Pastore deleting all its transport filters"));

    pTxFilterState = gpTxFilterState;

    while (pTxFilterState) {

        if (pTxFilterState->hTxFilter) {

            dwError = DeleteTransportFilter(
                          pTxFilterState->hTxFilter
                          );
            if (!dwError) {
                pTemp = pTxFilterState;
                pTxFilterState = pTxFilterState->pNext;
                FreeSPDMemory(pTemp);
            } 
            else {
                pTemp = pTxFilterState;
                pTxFilterState = pTxFilterState->pNext;

                pTemp->pNext = pLeftTxFilterState;
                pLeftTxFilterState = pTemp;
            }

        }
        else {

            pTemp = pTxFilterState;
            pTxFilterState = pTxFilterState->pNext;
            FreeSPDMemory(pTemp);

        }

    }

    gpTxFilterState = pLeftTxFilterState;
    
    return (dwError);
}


VOID
PAFreeTxFilterStateList(
    PTXFILTERSTATE pTxFilterState
    )
{
    PTXFILTERSTATE pTemp = NULL;


    while (pTxFilterState) {

        pTemp = pTxFilterState;
        pTxFilterState = pTxFilterState->pNext;
        FreeSPDMemory(pTemp);

    }
}


DWORD
PADeleteQMFilters(
    PIPSEC_NFA_DATA * ppIpsecNFAData,
    DWORD dwNumNFACount
    )
{
    DWORD dwError = 0;
    DWORD i = 0;
    PIPSEC_NFA_DATA pIpsecNFAData = NULL;

    for (i = 0; i < dwNumNFACount; i++) {

        pIpsecNFAData = *(ppIpsecNFAData + i);

        TRACE(
            TRC_INFORMATION,
            ("Pastore deleting transport/tunnel filters generated from rule %!guid!",
            &pIpsecNFAData->NFAIdentifier)
            );
            
        if (!(pIpsecNFAData->dwTunnelFlags)) {

            dwError = PADeleteTxFilterSpecs(
                          pIpsecNFAData
                          );

        }
        else {

            dwError = PADeleteTnFilterSpecs(
                          pIpsecNFAData
                          );

        }

    }

    return (dwError);
}


DWORD
PADeleteTxFilterSpecs(
    PIPSEC_NFA_DATA pIpsecNFAData
    )
{
    DWORD dwError = 0;
    PIPSEC_NEGPOL_DATA pIpsecNegPolData = NULL;
    PIPSEC_FILTER_DATA pIpsecFilterData = NULL;
    DWORD dwNumFilterSpecs = 0;
    PIPSEC_FILTER_SPEC * ppFilterSpecs = NULL;
    DWORD i = 0;
    PIPSEC_FILTER_SPEC pFilterSpec = NULL;


    pIpsecNegPolData = pIpsecNFAData->pIpsecNegPolData;

    if (!memcmp(
            &(pIpsecNegPolData->NegPolType), 
            &(GUID_NEGOTIATION_TYPE_DEFAULT),
            sizeof(GUID))) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pIpsecFilterData = pIpsecNFAData->pIpsecFilterData;

    if (!pIpsecFilterData) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    dwNumFilterSpecs = pIpsecFilterData->dwNumFilterSpecs;
    ppFilterSpecs = pIpsecFilterData->ppFilterSpecs;
    
    for (i = 0; i < dwNumFilterSpecs; i++) {

        pFilterSpec = *(ppFilterSpecs + i);

        dwError = PADeleteTxFilter(
                      pFilterSpec->FilterSpecGUID,
                      pIpsecNFAData->NFAIdentifier
                      );

    }

    return (dwError);
}


DWORD
PADeleteTxFilter(
    GUID gFilterID,
    GUID gNFAIdentifier    
    )
{
    DWORD dwError = 0;
    PTXFILTERSTATE pTxFilterState = NULL;


    pTxFilterState = FindTxFilterState(
                         gFilterID,
                         gNFAIdentifier
                         );
    if (!pTxFilterState) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if (pTxFilterState->hTxFilter) {

        dwError = DeleteTransportFilter(
                      pTxFilterState->hTxFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    PADeleteTxFilterState(pTxFilterState);

error:
#ifdef TRACE_ON
        if (dwError) {
            TRACE(
                TRC_WARNING,
                ("Pastore failed to delete transport filter %!guid!. %!winerr!", 
                &gFilterID,
                dwError)
                );
        }
#endif

    return (dwError);
}


VOID
PADeleteTxFilterState(
    PTXFILTERSTATE pTxFilterState
    )
{
    PTXFILTERSTATE * ppTemp = NULL;


    ppTemp = &gpTxFilterState;

    while (*ppTemp) {

        if (*ppTemp == pTxFilterState) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);

    }

    if (*ppTemp) {
        *ppTemp = pTxFilterState->pNext;
    }

    FreeSPDMemory(pTxFilterState);

    return;
}


PTXFILTERSTATE
FindTxFilterState(
    GUID gFilterID,
    GUID gNFAIdentifier
    )
{
    PTXFILTERSTATE pTxFilterState = NULL;


    pTxFilterState = gpTxFilterState;

    while (pTxFilterState) {

        if (!memcmp(&(pTxFilterState->gFilterID), &gFilterID, sizeof(GUID))
            && !memcmp(&(pTxFilterState->gNFAIdentifier), &gNFAIdentifier, sizeof(GUID)))
        {
            return (pTxFilterState);
        }

        pTxFilterState = pTxFilterState->pNext;

    }

    return (NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\precomp.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    precomp.h

Abstract:

    Precompiled header for winipsec.dll.

Author:

    abhisheV    21-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <ntddrdr.h>
#include <gpcifc.h>

#ifdef __cplusplus
}
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <rpc.h>
#include <windows.h>
#include <imagehlp.h>
#include <tchar.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <dsgetdc.h>

#ifdef __cplusplus
}
#endif

#include "winioctl.h"
#include "winsock2.h"
#include "winsock.h"
#include <userenv.h>
#include <wchar.h>
#include <winldap.h>
#include "ipexport.h"
#include <iphlpapi.h>
#include <nhapi.h>
#include <seopaque.h>

#ifdef __cplusplus
extern "C" {
#endif

#include <msaudite.h>
#include <ntlsa.h>
#include <lsarpc.h>
#include <ntsam.h>
#include <lsaisrv.h>

#ifdef __cplusplus
}
#endif

#include "spd_s.h"
#include "winipsec.h"
#include "structs.h"
#include "spdaudit.h"

#include "audit.h"

#include "interface.h"
#include "address.h"
#include "port.h"
#include "protocol.h"
#include "utils.h"
#include "memory.h"
#include "security.h"
#include "init.h"
#include "rpcserv.h"
#include "iphlpwrp.h"
#include "loopmgr.h"
#include "ipsecspd.h"
#include "qm-policy.h"
#include "mm-policy.h"
#include "ipsecshr.h"
#include "mmauth.h"
#include "txfilter.h"
#include "txspecific.h"
#include "tnfilter.h"
#include "tnspecific.h"
#include "mmfilter.h"
#include "mmspecific.h"
#include "ipsec.h"
#include "driver.h"


//
// Policy Agent Store specific headers.
//

#include "oakdefs.h"
#include "polstructs.h"
#include "..\..\pastore\ldaputil.h"
#include "..\..\pastore\structs.h"
#include "..\..\pastore\dsstore.h"
#include "..\..\pastore\regstore.h"
#include "..\..\pastore\procrule.h"
#include "..\..\pastore\persist.h"
#include "..\..\pastore\utils.h"
#include "polguids.h"
#include "pamm-pol.h"
#include "pammauth.h"
#include "paqm-pol.h"
#include "pamm-fil.h"
#include "patx-fil.h"
#include "patn-fil.h"
#include "paupdate.h"
#include "pastore.h"

#include "oakdll.h"

#include "externs.h"

#include "safestr.h"

#include "tracing.h"

extern
DWORD
AllocateAndGetIfTableFromStack(
    OUT MIB_IFTABLE **ppIfTable,
    IN  BOOL        bOrder,
    IN  HANDLE      hHeap,
    IN  DWORD       dwFlags,
    IN  BOOL        bForceUpdate
    );


#ifdef BAIL_ON_WIN32_ERROR
#undef BAIL_ON_WIN32_ERROR
#endif

#ifdef BAIL_ON_LOCK_ERROR
#undef BAIL_ON_LOCK_ERROR
#endif


#define BAIL_ON_WIN32_ERROR(dwError)                \
    if (dwError) {                                  \
        goto error;                                 \
    }

#define BAIL_ON_LOCK_ERROR(dwError)                 \
    if (dwError) {                                  \
        goto lock;                                  \
    }

#define BAIL_OUT                                    \
        goto error;                                 \


#define SET_IF_HARD_ERROR(dwError, gNegPolAction, bHardError)      \
{                                                                  \
    if (dwError &&                                                 \
        (IsBlocking(gNegPolAction) || IsSecure(gNegPolAction))) {  \
        bHardError = TRUE;                                         \
    }                                                              \
}        



#define BAIL_ON_WIN32_SUCCESS(dwError) \
    if (!dwError) {                    \
        goto success;                  \
    }

#define BAIL_ON_LOCK_SUCCESS(dwError)  \
    if (!dwError) {                    \
        goto lock_success;             \
    }

#define BAIL_LOCK_SUCCESS              \
    goto lock_success                 \

#define ENTER_SPD_SECTION()             \
    EnterCriticalSection(&gcSPDSection) \

#define LEAVE_SPD_SECTION()             \
    LeaveCriticalSection(&gcSPDSection) \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\port.h ===
DWORD
VerifyPortsForProtocol(
    PORT        Port,
    PROTOCOL    Protocol
    );

BOOL
EqualPorts(
    IN PORT     OldPort,
    IN PORT     NewPort
    );

VOID
CopyPorts(
    IN  PORT    InPort,
    OUT PPORT   pOutPort
    );

BOOL
MatchPorts(
    PORT PortToMatch,
    PORT PortTemplate
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\protocol.h ===
DWORD
VerifyProtocols(
    PROTOCOL    Protocol
    );


BOOL
EqualProtocols(
    IN PROTOCOL OldProtocol,
    IN PROTOCOL NewProtocol
    );


VOID
CopyProtocols(
    IN  PROTOCOL    InProtocol,
    OUT PPROTOCOL   pOutProtocol
    );


BOOL
MatchProtocols(
    PROTOCOL ProtocolToMatch,
    PROTOCOL ProtocolTemplate
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\qm-policy.h ===
typedef struct _iniqmpolicy {
    GUID gPolicyID;
    LPWSTR pszPolicyName;
    DWORD  cRef;
    DWORD dwSource;
    DWORD dwFlags;
    DWORD dwReserved;
    DWORD dwOfferCount;
    PIPSEC_QM_OFFER pOffers;
    struct _iniqmpolicy * pNext;
} INIQMPOLICY, * PINIQMPOLICY;

DWORD
AddQMPolicyInternal(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    DWORD dwSource,
    PIPSEC_QM_POLICY pQMPolicy,
    LPVOID pvReserved
    );

DWORD
CreateIniQMPolicy(
    PIPSEC_QM_POLICY pQMPolicy,
    PINIQMPOLICY * ppIniQMPolicy
    );

DWORD
ValidateQMPolicy(
    PIPSEC_QM_POLICY pQMPolicy
    );

DWORD
ValidateQMOffers(
    DWORD dwOfferCount,
    PIPSEC_QM_OFFER pOffers
    );

DWORD
ValidateQMOffer(
    PIPSEC_QM_OFFER pOffer,
    BOOL *pbInitGroup,
    LPDWORD pdwPFSGroup
    );

PINIQMPOLICY
FindQMPolicy(
    PINIQMPOLICY pIniQMPolicyList,
    LPWSTR pszPolicyName
    );

VOID
FreeIniQMPolicy(
    PINIQMPOLICY pIniQMPolicy
    );

VOID
FreeIniQMOffers(
    DWORD dwOfferCount,
    PIPSEC_QM_OFFER pOffers
    );

DWORD
CreateIniQMOffers(
    DWORD dwInOfferCount,
    PIPSEC_QM_OFFER pInOffers,
    PDWORD pdwOfferCount,
    PIPSEC_QM_OFFER * ppOffers
    );

DWORD
SetIniQMPolicy(
    PINIQMPOLICY pIniQMPolicy,
    PIPSEC_QM_POLICY pQMPolicy
    );

DWORD
GetIniQMPolicy(
    DWORD dwFlags,
    PINIQMPOLICY pIniQMPolicy,
    PIPSEC_QM_POLICY * ppQMPolicy
    );

DWORD
CopyQMPolicy(
    DWORD dwFlags,
    PINIQMPOLICY pIniQMPolicy,
    PIPSEC_QM_POLICY pQMPolicy
    );

DWORD
CreateQMOffers(
    DWORD dwInOfferCount,
    PIPSEC_QM_OFFER pInOffers,
    PDWORD pdwOfferCount,
    PIPSEC_QM_OFFER * ppOffers
    );

DWORD
DeleteIniQMPolicy(
    PINIQMPOLICY pIniQMPolicy
    );

VOID
FreeQMOffers(
    DWORD dwOfferCount,
    PIPSEC_QM_OFFER pOffers
    );

VOID
FreeIniQMPolicyList(
    PINIQMPOLICY pIniQMPolicyList
    );

PINIQMPOLICY
FindQMPolicyByGuid(
    PINIQMPOLICY pIniQMPolicyList,
    GUID gPolicyID
    );

VOID
FreeQMPolicies(
    DWORD dwNumQMPolicies,
    PIPSEC_QM_POLICY pQMPolicies
    );

DWORD
LocateQMPolicy(
    DWORD dwFlags,
    GUID gPolicyID,
    PINIQMPOLICY * ppIniQMPolicy
    );

DWORD
CreateNonAHQMOffers(
    DWORD dwInOfferCount,
    PIPSEC_QM_OFFER pInOffers,
    PDWORD pdwOfferCount,
    PIPSEC_QM_OFFER * ppOffers
    );

BOOL
IsAHQMOffer(
    PIPSEC_QM_OFFER pIpsecQMOffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\rpcserv.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    rpcserv.h

Abstract:

    This module contains the RPC server startup
    and shutdown code prototypes.

Author:

    abhisheV    30-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif


DWORD
SPDStartRPCServer(
    );


DWORD
SPDStopRPCServer(
    );


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\rpcserv.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    rpcserv.c

Abstract:

    This module contains the RPC server startup
    and shutdown code.

Author:

    abhisheV    30-September-1999

Environment:

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


DWORD
SPDStartRPCServer(
    )
{
    DWORD dwStatus = 0;
    WCHAR * pszPrincipalName = NULL;
    RPC_BINDING_VECTOR * pBindingVector = NULL;
      
   //
   // Register dynamic end-point (Used to be static np in prior versions)
   
   dwStatus = RpcServerUseProtseq(
                   L"ncacn_np",
                   10,
                   NULL
                   );

    if (dwStatus) {
            return (dwStatus);
    }

    dwStatus = RpcServerUseProtseq(
                   L"ncalrpc",
                   10,
                   NULL
                   );

    if (dwStatus) {
        return (dwStatus);
    }

    dwStatus = RpcServerInqBindings(&pBindingVector);
    if (dwStatus) {
            return (dwStatus);
    }

    dwStatus = RpcEpRegister(
                      winipsec_ServerIfHandle,
                      pBindingVector,
                      NULL,
                      L"IPSec Policy agent endpoint"
                      );
    if (dwStatus) {
            RpcBindingVectorFree(&pBindingVector);
            return (dwStatus);
    }
    RpcBindingVectorFree(&pBindingVector);
    
   dwStatus = RpcServerRegisterIf(
                   winipsec_ServerIfHandle,
                   0,
                   0
                   );

    if (dwStatus) {
        return (dwStatus);
    }

    dwStatus = RpcServerRegisterAuthInfo(
                   0,
                   RPC_C_AUTHN_WINNT,
                   0,
                   0
                   );
    if (dwStatus) {
        (VOID) RpcServerUnregisterIfEx(
                   winipsec_ServerIfHandle,
                   0,
                   0
                   );
        return (dwStatus);
    }

    dwStatus = RpcServerInqDefaultPrincNameW(
                   RPC_C_AUTHN_GSS_KERBEROS,
                   &pszPrincipalName
                   );
    if (dwStatus == RPC_S_INVALID_AUTH_IDENTITY) {
        dwStatus = ERROR_SUCCESS;
        pszPrincipalName = NULL;
    }

    if (dwStatus) {
        (VOID) RpcServerUnregisterIfEx(
                   winipsec_ServerIfHandle,
                   0,
                   0
                   );
        return (dwStatus);
    }

    dwStatus = RpcServerRegisterAuthInfo(
                   pszPrincipalName,
                   RPC_C_AUTHN_GSS_KERBEROS,
                   0,
                   0
                   );
    if (dwStatus) {
        (VOID) RpcServerUnregisterIfEx(
                   winipsec_ServerIfHandle,
                   0,
                   0
                   );
        RpcStringFree(&pszPrincipalName);
        return (dwStatus);
    }

    dwStatus = RpcServerRegisterAuthInfo(
                   pszPrincipalName,
                   RPC_C_AUTHN_GSS_NEGOTIATE,
                   0,
                   0
                   );
    if (dwStatus) {
        (VOID) RpcServerUnregisterIfEx(
                   winipsec_ServerIfHandle,
                   0,
                   0
                   );
        RpcStringFree(&pszPrincipalName);
        return (dwStatus);
    }

    RpcStringFree(&pszPrincipalName);

    #if !defined(__IN_LSASS__)

        EnterCriticalSection(&gcServerListenSection);

        gdwServersListening++;

        if (gdwServersListening == 1) {

            dwStatus = RpcServerListen(
                           3,
                           RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                           TRUE
                           );

            if (dwStatus) {
                LeaveCriticalSection(&gcServerListenSection);
                (VOID) RpcServerUnregisterIfEx(
                           winipsec_ServerIfHandle,
                           0,
                           0
                           );
                return (dwStatus);
            }

        }

        LeaveCriticalSection(&gcServerListenSection);

    #endif

    gbSPDRPCServerUp = TRUE;
    return (dwStatus);
}


DWORD
SPDStopRPCServer(
    )
{

    DWORD dwStatus = 0;
    RPC_BINDING_VECTOR * pBindingVector = NULL;
    
    dwStatus = RpcServerInqBindings(&pBindingVector);
    if (!dwStatus) {
        dwStatus = RpcEpUnregister(
                      winipsec_ServerIfHandle,
                      pBindingVector,
                      NULL
                      );
         RpcBindingVectorFree(&pBindingVector);                      
    }

    dwStatus = RpcServerUnregisterIfEx(
                   winipsec_ServerIfHandle,
                   0,
                   0
                   );
   
    #if !defined(__IN_LSASS__)

        EnterCriticalSection(&gcServerListenSection);

        gdwServersListening--;

        if (gdwServersListening == 0) {
            RpcMgmtStopServerListening(0);
        }

        LeaveCriticalSection(&gcServerListenSection);

    #endif

    return (dwStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\qm-policy.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    qm-policy.c

Abstract:


Author:


Environment: User Mode


Revision History:


--*/


#include "precomp.h"
#ifdef TRACE_ON
#include "qm-policy.tmh"
#endif


DWORD
AddQMPolicyInternal(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    DWORD dwSource,
    PIPSEC_QM_POLICY pQMPolicy,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function adds a quick mode policy to the SPD.

Arguments:

    pServerName - Server on which the quick mode policy is to be added.

    pQMPolicy - Quick mode policy to be added.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIQMPOLICY pIniQMPolicy = NULL;

    //
    // Validate the quick mode policy.
    //

    dwError = ValidateQMPolicy(
                  pQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniQMPolicy = FindQMPolicy(
                       gpIniQMPolicy,
                       pQMPolicy->pszPolicyName
                       );
    if (pIniQMPolicy) {
        dwError = ERROR_IPSEC_QM_POLICY_EXISTS;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    pIniQMPolicy = FindQMPolicyByGuid(
                       gpIniQMPolicy,
                       pQMPolicy->gPolicyID
                       );
    if (pIniQMPolicy) {
        dwError = ERROR_IPSEC_QM_POLICY_EXISTS;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = CreateIniQMPolicy(
                  pQMPolicy,
                  &pIniQMPolicy
                  );
    if (dwError != WARNING_IPSEC_QM_POLICY_PRUNED) {
        BAIL_ON_LOCK_ERROR(dwError);
    }

    pIniQMPolicy->dwSource = dwSource;

    pIniQMPolicy->pNext = gpIniQMPolicy;
    gpIniQMPolicy = pIniQMPolicy;

    if ((pIniQMPolicy->dwFlags) & IPSEC_QM_POLICY_DEFAULT_POLICY) {
        gpIniDefaultQMPolicy = pIniQMPolicy;
        TRACE(
            TRC_INFORMATION,
            (L"Set default QM policy to \"%ls\" (%!guid!)",
            pQMPolicy->pszPolicyName,
            &pQMPolicy->gPolicyID)
            );
        
    }

    LEAVE_SPD_SECTION();

    TRACE(
        TRC_INFORMATION,
        (L"Added QM policy \"%ls\"(%!guid!)",
        pQMPolicy->pszPolicyName,
        &pQMPolicy->gPolicyID)
        );

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:
#ifdef TRACE_ON    
    if (pQMPolicy) {
        TRACE(
            TRC_ERROR,
            (L"Failed to add QM policy \"%ls\"(%!guid!): %!winerr!",
            pQMPolicy->pszPolicyName,
            &pQMPolicy->gPolicyID,
            dwError)
            );
    } else {
        TRACE(
            TRC_ERROR,
            (L"Failed to add MM policy. Policy details unavailable since pQMPolicy is null: %!winerr!",
            dwError)
            );
    }
#endif
    

    return (dwError);
}

DWORD
AddQMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PIPSEC_QM_POLICY pQMPolicy,
    LPVOID pvReserved
    )
{
    return
        AddQMPolicyInternal(
            pServerName,
            dwVersion,
            dwFlags,
            IPSEC_SOURCE_WINIPSEC,
            pQMPolicy,
            pvReserved);
}

DWORD
ValidateQMPolicy(
    PIPSEC_QM_POLICY pQMPolicy
    )
{
    DWORD dwError = 0;


    if (!pQMPolicy) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pQMPolicy->pszPolicyName) || !(*(pQMPolicy->pszPolicyName))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateQMOffers(
                  pQMPolicy->dwOfferCount,
                  pQMPolicy->pOffers
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:
#ifdef TRACE_ON
    if (dwError) {
        TRACE(TRC_ERROR, ("Failed QM policy validation: %!winerr!", dwError));
    }
#endif

    return (dwError);
}



DWORD
ValidateQMOffers(
    DWORD dwOfferCount,
    PIPSEC_QM_OFFER pOffers
    )
{
    DWORD dwError = 0;

    if (!dwOfferCount || !pOffers || (dwOfferCount > IPSEC_MAX_QM_OFFERS)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

error:
#ifdef TRACE_ON
    if (dwError) {
        TRACE(TRC_ERROR, ("Failed QM offers validation: %!winerr!", dwError));
    }
#endif

    return (dwError);
}

DWORD
ValidateQMOffer(
    PIPSEC_QM_OFFER pOffer,
    BOOL *pbInitGroup,
    LPDWORD pdwPFSGroup
    )
{
    DWORD dwError = 0;
    DWORD j = 0;
    BOOL bAH = FALSE;
    BOOL bESP = FALSE;
    DWORD dwPFSGroup = *pdwPFSGroup;
    BOOL bInitGroup = *pbInitGroup;

    if (!bInitGroup) {
        if (pOffer->bPFSRequired) {
            if ((pOffer->dwPFSGroup != PFS_GROUP_1) &&
                (pOffer->dwPFSGroup != PFS_GROUP_2) &&
                (pOffer->dwPFSGroup != PFS_GROUP_2048) &&
                (pOffer->dwPFSGroup != PFS_GROUP_MM)) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);                
            }
            dwPFSGroup=pOffer->dwPFSGroup;
        }
        else {
            if (pOffer->dwPFSGroup != PFS_GROUP_NONE) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);                
            }
            dwPFSGroup=PFS_GROUP_NONE;
        }
        bInitGroup = TRUE;
        
    }
        
    if (dwPFSGroup) {
        if ((!pOffer->bPFSRequired) || (pOffer->dwPFSGroup != dwPFSGroup)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);                
        } 
    } else {            
        if ((pOffer->bPFSRequired) || (pOffer->dwPFSGroup != PFS_GROUP_NONE)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);                
        }
    }
    
    if (!(pOffer->dwNumAlgos) || (pOffer->dwNumAlgos > QM_MAX_ALGOS)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);                
    }
    
    bAH = FALSE;
    bESP = FALSE;
    
    for (j = 0; j < (pOffer->dwNumAlgos); j++) {
        
        switch (pOffer->Algos[j].Operation) {
            
        case AUTHENTICATION:
            if (bAH) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);                
            }
            if ((pOffer->Algos[j].uAlgoIdentifier == AUTH_ALGO_NONE) ||
                (pOffer->Algos[j].uAlgoIdentifier >= AUTH_ALGO_MAX)) {
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);                
            }
                if (pOffer->Algos[j].uSecAlgoIdentifier != HMAC_AUTH_ALGO_NONE) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);                
                }
                bAH = TRUE;
                break;
                    
            case ENCRYPTION:
                if (bESP) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);                
                }
                if (pOffer->Algos[j].uAlgoIdentifier >= CONF_ALGO_MAX) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);                
                }
                if (pOffer->Algos[j].uSecAlgoIdentifier >= HMAC_AUTH_ALGO_MAX) {
                    dwError = ERROR_INVALID_PARAMETER;
                    BAIL_ON_WIN32_ERROR(dwError);                
                }
                if (pOffer->Algos[j].uAlgoIdentifier == CONF_ALGO_NONE) {
                    if (pOffer->Algos[j].uSecAlgoIdentifier == HMAC_AUTH_ALGO_NONE) {
                        dwError = ERROR_INVALID_PARAMETER;
                        BAIL_ON_WIN32_ERROR(dwError);                
                    }
                }
                bESP = TRUE;
                break;

            case NONE:
            case COMPRESSION:
            default:
                dwError = ERROR_INVALID_PARAMETER;
                BAIL_ON_WIN32_ERROR(dwError);                
                break;
                
        }
        
    }
    
    *pdwPFSGroup = dwPFSGroup;
    *pbInitGroup = bInitGroup;

error:
#ifdef TRACE_ON
    if (dwError) {
        TRACE(TRC_ERROR, ("Failed a QM offer validation: %!winerr!", dwError));
    }
#endif

    return (dwError);
}



DWORD
CreateIniQMPolicy(
    PIPSEC_QM_POLICY pQMPolicy,
    PINIQMPOLICY * ppIniQMPolicy
    )
{
    DWORD dwError = 0;
    PINIQMPOLICY pIniQMPolicy = NULL;



    dwError = AllocateSPDMemory(
                  sizeof(INIQMPOLICY),
                  &pIniQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    memcpy(
        &(pIniQMPolicy->gPolicyID),
        &(pQMPolicy->gPolicyID),
        sizeof(GUID)
        );

    dwError =  AllocateSPDString(
                   pQMPolicy->pszPolicyName,
                   &(pIniQMPolicy->pszPolicyName)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    pIniQMPolicy->cRef = 0;
    pIniQMPolicy->dwSource = 0;

    pIniQMPolicy->dwFlags = pQMPolicy->dwFlags;
    pIniQMPolicy->dwReserved = pQMPolicy->dwReserved;
    pIniQMPolicy->pNext = NULL;

    dwError = CreateIniQMOffers(
                  pQMPolicy->dwOfferCount,
                  pQMPolicy->pOffers,
                  &(pIniQMPolicy->dwOfferCount),
                  &(pIniQMPolicy->pOffers)
                  );
    if (dwError != WARNING_IPSEC_QM_POLICY_PRUNED) {
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppIniQMPolicy = pIniQMPolicy;
    return (dwError);

error:
    TRACE(TRC_ERROR, ("Failed to create QM Policy link node: %!winerr!", dwError));

    if (pIniQMPolicy) {
        FreeIniQMPolicy(
            pIniQMPolicy
            );
    }

    *ppIniQMPolicy = NULL;
    return (dwError);
}


DWORD
CreateIniQMOffers(
    DWORD dwInOfferCount,
    PIPSEC_QM_OFFER pInOffers,
    PDWORD pdwOfferCount,
    PIPSEC_QM_OFFER * ppOffers
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_OFFER pOffers = NULL;
    PIPSEC_QM_OFFER pTemp = NULL;
    PIPSEC_QM_OFFER pInTempOffer = NULL;
    DWORD i = 0;
    DWORD j = 0;

    BOOL bGroupInit = FALSE;
    DWORD dwPFSGroup = PFS_GROUP_NONE;
    DWORD dwOfferCount = 0;
    DWORD dwCurIndex = 0;
    
    for (i = 0; i < dwInOfferCount; i++) {

        dwError = ValidateQMOffer(&pInOffers[i],
                                  &bGroupInit,
                                  &dwPFSGroup);

        if (dwError == ERROR_SUCCESS) {
            dwOfferCount++;
        }
    }

    if (dwOfferCount == 0) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    //
    // Offer count and the offers themselves have already been validated.
    // 

    dwError = AllocateSPDMemory(
                  sizeof(IPSEC_QM_OFFER) * dwOfferCount,
                  &(pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    for (i = 0; i < dwInOfferCount; i++) {

        pTemp = &pOffers[dwCurIndex];
        pInTempOffer = &pInOffers[i];        

        dwError = ValidateQMOffer(pInTempOffer,
                                  &bGroupInit,
                                  &dwPFSGroup);
        if (dwError) {
            continue;
        }

        memcpy(
            &(pTemp->Lifetime),
            &(pInTempOffer->Lifetime),
            sizeof(KEY_LIFETIME)
            );

        pTemp->dwFlags = pInTempOffer->dwFlags;
        pTemp->bPFSRequired = pInTempOffer->bPFSRequired;
        pTemp->dwPFSGroup = pInTempOffer->dwPFSGroup;
        pTemp->dwNumAlgos = pInTempOffer->dwNumAlgos;

        for (j = 0; j < (pInTempOffer->dwNumAlgos); j++) {
            memcpy(
                &(pTemp->Algos[j]),
                &(pInTempOffer->Algos[j]),
                sizeof(IPSEC_QM_ALGO)
                );
        }

        pTemp->dwReserved = pInTempOffer->dwReserved;

        dwCurIndex++;

    }    

    *pdwOfferCount = dwOfferCount;
    *ppOffers = pOffers;

    if (dwOfferCount != dwInOfferCount) {
        return WARNING_IPSEC_QM_POLICY_PRUNED;
    }
    return (ERROR_SUCCESS);

error:
    TRACE(TRC_ERROR, ("Failed to create QM offers node: %!winerr!", dwError));
    
    if (pOffers) {
        FreeIniQMOffers(
            i,
            pOffers
            );
    }

    *pdwOfferCount = 0;
    *ppOffers = NULL;
    return (dwError);
}


VOID
FreeIniQMPolicy(
    PINIQMPOLICY pIniQMPolicy
    )
{
    if (pIniQMPolicy) {

        if (pIniQMPolicy->pszPolicyName) {
            FreeSPDString(pIniQMPolicy->pszPolicyName);
        }

        FreeIniQMOffers(
            pIniQMPolicy->dwOfferCount,
            pIniQMPolicy->pOffers
            );

        FreeSPDMemory(pIniQMPolicy);

    }
}


VOID
FreeIniQMOffers(
    DWORD dwOfferCount,
    PIPSEC_QM_OFFER pOffers
    )
{
    if (pOffers) {
        FreeSPDMemory(pOffers);
    }
}


PINIQMPOLICY
FindQMPolicy(
    PINIQMPOLICY pIniQMPolicyList,
    LPWSTR pszPolicyName
    )
{
    DWORD dwError = 0;
    PINIQMPOLICY pTemp = NULL;


    pTemp = pIniQMPolicyList;

    while (pTemp) {

        if (!_wcsicmp(pTemp->pszPolicyName, pszPolicyName)) {
            return (pTemp);
        }
        pTemp = pTemp->pNext;

    }

    return (NULL);
}


DWORD
DeleteQMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function deletes a quick mode policy from the SPD.

Arguments:

    pServerName - Server on which the quick mode policy is to be deleted.

    pszPolicyName - Quick mode policy to be deleted.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIQMPOLICY pIniQMPolicy = NULL;
    GUID gPolicyID;


    if (!pszPolicyName || !*pszPolicyName) {
        return (ERROR_INVALID_PARAMETER);
    }

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniQMPolicy = FindQMPolicy(
                       gpIniQMPolicy,
                       pszPolicyName
                       );
    if (!pIniQMPolicy) {
        dwError = ERROR_IPSEC_QM_POLICY_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniQMPolicy->cRef) {
        dwError = ERROR_IPSEC_QM_POLICY_IN_USE;
        memcpy(&gPolicyID, &pIniQMPolicy->gPolicyID, sizeof(GUID));
        BAIL_ON_LOCK_ERROR(dwError);
    }

    memcpy(&gPolicyID, &pIniQMPolicy->gPolicyID, sizeof(GUID));

    dwError = DeleteIniQMPolicy(
                  pIniQMPolicy
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    LEAVE_SPD_SECTION();

    if (gbIKENotify) {
        (VOID) IKENotifyPolicyChange(
                   &(gPolicyID),
                   POLICY_GUID_QM
                   );
    }

    TRACE(
        TRC_INFORMATION,
        ("Deleted QM Policy \"%ls\"(%!guid!)",
        pszPolicyName,
        &gPolicyID)
        );

    return (dwError);

lock:
#ifdef TRACE_ON    
    if (pIniQMPolicy) {
        TRACE(
            TRC_ERROR,
            (L"Failed to delete QM policy \"%ls\"(%!guid!): %!winerr!",
            pIniQMPolicy->pszPolicyName,
            &pIniQMPolicy->gPolicyID,
            dwError)
            );
    } else {
        TRACE(
            TRC_ERROR,
            (L"Failed to delete QM policy \"%ls\": %!winerr!",
            pszPolicyName,
            dwError)
            );
    }
#endif

    LEAVE_SPD_SECTION();

    if ((dwError == ERROR_IPSEC_QM_POLICY_IN_USE) && gbIKENotify) {
        (VOID) IKENotifyPolicyChange(
                   &(gPolicyID),
                   POLICY_GUID_QM
                   );
    }

    return (dwError);
}


DWORD
EnumQMPolicies(
    LPWSTR pServerName,
    DWORD dwVersion,
    PIPSEC_QM_POLICY pQMTemplatePolicy,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PIPSEC_QM_POLICY * ppQMPolicies,
    LPDWORD pdwNumPolicies,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function enumerates quick mode policies from the SPD.

Arguments:

    pServerName - Server on which the quick mode policies are to
                  be enumerated.

    ppQMPolicies - Enumerated quick mode policies returned to the 
                   caller.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    pdwNumPolicies - Number of quick mode policies actually enumerated.

    pdwResumeHandle - Handle to the location in the quick mode policy
                      list from which to resume enumeration.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwResumeHandle = 0;
    DWORD dwNumToEnum = 0;
    PINIQMPOLICY pIniQMPolicy = NULL;
    DWORD i = 0;
    PINIQMPOLICY pTemp = NULL;
    DWORD dwNumPolicies = 0;
    PIPSEC_QM_POLICY pQMPolicies = NULL;
    PIPSEC_QM_POLICY pQMPolicy = NULL;


    dwResumeHandle = *pdwResumeHandle;

    if (!dwPreferredNumEntries || (dwPreferredNumEntries > MAX_QMPOLICY_ENUM_COUNT)) {
        dwNumToEnum = MAX_QMPOLICY_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniQMPolicy = gpIniQMPolicy;

    for (i = 0; (i < dwResumeHandle) && (pIniQMPolicy != NULL); i++) {
        pIniQMPolicy = pIniQMPolicy->pNext;
    }

    if (!pIniQMPolicy) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    pTemp = pIniQMPolicy;

    while (pTemp && (dwNumPolicies < dwNumToEnum)) {
        dwNumPolicies++;
        pTemp = pTemp->pNext;
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_QM_POLICY)*dwNumPolicies,
                  &pQMPolicies
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pTemp = pIniQMPolicy;
    pQMPolicy = pQMPolicies;

    for (i = 0; i < dwNumPolicies; i++) {

        dwError = CopyQMPolicy(
                      dwFlags,
                      pTemp,
                      pQMPolicy
                      );
        BAIL_ON_LOCK_ERROR(dwError);

        pTemp = pTemp->pNext;
        pQMPolicy++;

    }

    *ppQMPolicies = pQMPolicies;
    *pdwResumeHandle = dwResumeHandle + dwNumPolicies;
    *pdwNumPolicies = dwNumPolicies;

    LEAVE_SPD_SECTION();
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    if (pQMPolicies) {
        FreeQMPolicies(
            i,
            pQMPolicies
            );
    }

    *ppQMPolicies = NULL;
    *pdwResumeHandle = dwResumeHandle;
    *pdwNumPolicies = 0;

    return (dwError);
}


DWORD
SetQMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    PIPSEC_QM_POLICY pQMPolicy,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function updates a quick mode policy in the SPD.

Arguments:

    pServerName - Server on which the quick mode policy is to be
                  updated.

    pszPolicyName - Name of the quick mode policy to be updated.

    pQMPolicy - New quick mode policy which will replace the 
                existing policy.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIQMPOLICY pIniQMPolicy = NULL;
    DWORD dwStatus = 0;

    if (!pszPolicyName || !*pszPolicyName) {
        return (ERROR_INVALID_PARAMETER);
    }
    
    //
    // Validate quick mode policy.
    //

    dwError = ValidateQMPolicy(
                  pQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniQMPolicy = FindQMPolicy(
                       gpIniQMPolicy,
                       pszPolicyName
                       );
    if (!pIniQMPolicy) {
        dwError = ERROR_IPSEC_QM_POLICY_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (memcmp(
            &(pIniQMPolicy->gPolicyID),
            &(pQMPolicy->gPolicyID),
            sizeof(GUID))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = SetIniQMPolicy(
                  pIniQMPolicy,
                  pQMPolicy
                  );
    if (dwError != WARNING_IPSEC_QM_POLICY_PRUNED) {
        BAIL_ON_LOCK_ERROR(dwError);
    } else {
        dwStatus = dwError;
    }

    LEAVE_SPD_SECTION();

    (VOID) IKENotifyPolicyChange(
               &(pQMPolicy->gPolicyID),
               POLICY_GUID_QM
               );

    TRACE(
        TRC_INFORMATION,
       (L"Changed QM Policy \"%ls\" (%!guid!)",
        pQMPolicy->pszPolicyName,
        &pQMPolicy->gPolicyID)
        );

    return (dwStatus);

lock:

    LEAVE_SPD_SECTION();

error:
#ifdef TRACE_ON    
    if (pIniQMPolicy) {
        TRACE(
            TRC_ERROR,
            (L"Failed to change QM policy \"%ls\"(%!guid!): %!winerr!",
            pIniQMPolicy->pszPolicyName,
            &pIniQMPolicy->gPolicyID,
            dwError)
            );
    } else {
        TRACE(
            TRC_ERROR,
            (L"Failed to change QM policy \"%ls\": %!winerr!",
            pszPolicyName,
            dwError)
            );
    }
#endif
    

    return (dwError);
}


DWORD
GetQMPolicy(
    LPWSTR pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    DWORD dwFlags,
    PIPSEC_QM_POLICY * ppQMPolicy,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function gets a quick mode policy from the SPD.

Arguments:

    pServerName - Server from which to get the quick mode policy.

    pszPolicyName - Name of the quick mode policy to get.

    ppQMPolicy - Quick mode policy found returned to the caller.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIQMPOLICY pIniQMPolicy = NULL;
    PIPSEC_QM_POLICY pQMPolicy = NULL;


    if (!pszPolicyName || !*pszPolicyName) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniQMPolicy = FindQMPolicy(
                       gpIniQMPolicy,
                       pszPolicyName
                       );
    if (!pIniQMPolicy) {
        dwError = ERROR_IPSEC_QM_POLICY_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = GetIniQMPolicy(
                  dwFlags,
                  pIniQMPolicy,
                  &pQMPolicy
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    *ppQMPolicy = pQMPolicy;

    LEAVE_SPD_SECTION();
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    *ppQMPolicy = NULL;
    return (dwError);
}


DWORD
SetIniQMPolicy(
    PINIQMPOLICY pIniQMPolicy,
    PIPSEC_QM_POLICY pQMPolicy
    )
{
    DWORD dwError = 0;
    DWORD dwOfferCount = 0;
    PIPSEC_QM_OFFER pOffers = NULL;


    dwError = CreateIniQMOffers(
                  pQMPolicy->dwOfferCount,
                  pQMPolicy->pOffers,
                  &dwOfferCount,
                  &pOffers
                  );
    if (dwError != WARNING_IPSEC_QM_POLICY_PRUNED) {
        BAIL_ON_WIN32_ERROR(dwError);
    }

    FreeIniQMOffers(
        pIniQMPolicy->dwOfferCount,
        pIniQMPolicy->pOffers
        );
    
    if ((pIniQMPolicy->dwFlags) & IPSEC_QM_POLICY_DEFAULT_POLICY) {
        gpIniDefaultQMPolicy = NULL;
        TRACE(
            TRC_INFORMATION,
            (L"Cleared default QM policy \"%ls\" (%!guid!)",
            pIniQMPolicy->pszPolicyName,
            &pIniQMPolicy->gPolicyID)
            );
        
    }

    pIniQMPolicy->dwFlags = pQMPolicy->dwFlags;
    pIniQMPolicy->dwReserved = pQMPolicy->dwReserved;
    pIniQMPolicy->dwOfferCount = dwOfferCount;
    pIniQMPolicy->pOffers = pOffers;

    if ((pIniQMPolicy->dwFlags) & IPSEC_QM_POLICY_DEFAULT_POLICY) {
        gpIniDefaultQMPolicy = pIniQMPolicy;
        TRACE(
            TRC_INFORMATION,
            (L"Set default QM policy to \"%ls\" (%!guid!)",
            pIniQMPolicy->pszPolicyName,
            &pIniQMPolicy->gPolicyID)
            );

    }

error:

    return (dwError);
}


DWORD
GetIniQMPolicy(
    DWORD dwFlags,
    PINIQMPOLICY pIniQMPolicy,
    PIPSEC_QM_POLICY * ppQMPolicy
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_POLICY pQMPolicy = NULL;


    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_QM_POLICY),
                  &pQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyQMPolicy(
                  dwFlags,
                  pIniQMPolicy,
                  pQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppQMPolicy = pQMPolicy;
    return (dwError);

error:

    if (pQMPolicy) {
        SPDApiBufferFree(pQMPolicy);
    }

    *ppQMPolicy = NULL;
    return (dwError);
}


DWORD
CopyQMPolicy(
    DWORD dwFlags,
    PINIQMPOLICY pIniQMPolicy,
    PIPSEC_QM_POLICY pQMPolicy
    )
{
    DWORD dwError = 0;


    memcpy(
        &(pQMPolicy->gPolicyID),
        &(pIniQMPolicy->gPolicyID),
        sizeof(GUID)
        );

    dwError =  SPDApiBufferAllocate(
                   wcslen(pIniQMPolicy->pszPolicyName)*sizeof(WCHAR)
                   + sizeof(WCHAR),
                   &(pQMPolicy->pszPolicyName)
                   );
    BAIL_ON_WIN32_ERROR(dwError);

    wcscpy(pQMPolicy->pszPolicyName, pIniQMPolicy->pszPolicyName);
 
    pQMPolicy->dwFlags = pIniQMPolicy->dwFlags;
    pQMPolicy->dwReserved = pIniQMPolicy->dwReserved;

    if (dwFlags & RETURN_NON_AH_OFFERS) {
        dwError = CreateNonAHQMOffers(
                      pIniQMPolicy->dwOfferCount,
                      pIniQMPolicy->pOffers,
                      &(pQMPolicy->dwOfferCount),
                      &(pQMPolicy->pOffers)
                      );
    }
    else {
        dwError = CreateQMOffers(
                      pIniQMPolicy->dwOfferCount,
                      pIniQMPolicy->pOffers,
                      &(pQMPolicy->dwOfferCount),
                      &(pQMPolicy->pOffers)
                      );
    }
    BAIL_ON_WIN32_ERROR(dwError);

    return (dwError);

error:

    if (pQMPolicy->pszPolicyName) {
        SPDApiBufferFree(pQMPolicy->pszPolicyName);
    }

    return (dwError);
}


DWORD
CreateQMOffers(
    DWORD dwInOfferCount,
    PIPSEC_QM_OFFER pInOffers,
    PDWORD pdwOfferCount,
    PIPSEC_QM_OFFER * ppOffers
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_OFFER pOffers = NULL;
    PIPSEC_QM_OFFER pTemp = NULL;
    PIPSEC_QM_OFFER pInTempOffer = NULL;
    DWORD i = 0;
    DWORD j = 0;
    DWORD k = 0;


    //
    // Offer count and the offers themselves have already been validated.
    // 

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_QM_OFFER) * dwInOfferCount,
                  &(pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pOffers;
    pInTempOffer = pInOffers;

    for (i = 0; i < dwInOfferCount; i++) {

        memcpy(
            &(pTemp->Lifetime),
            &(pInTempOffer->Lifetime),
            sizeof(KEY_LIFETIME)
            );

        pTemp->dwFlags = pInTempOffer->dwFlags;
        pTemp->bPFSRequired = pInTempOffer->bPFSRequired;
        pTemp->dwPFSGroup = pInTempOffer->dwPFSGroup;
        pTemp->dwNumAlgos = pInTempOffer->dwNumAlgos;

        for (j = 0; j < (pInTempOffer->dwNumAlgos); j++) {
            memcpy(
                &(pTemp->Algos[j]),
                &(pInTempOffer->Algos[j]),
                sizeof(IPSEC_QM_ALGO)
                );
        }

        for (k = j; k < QM_MAX_ALGOS; k++) {
            memset(&(pTemp->Algos[k]), 0, sizeof(IPSEC_QM_ALGO));
        }

        pTemp->dwReserved = pInTempOffer->dwReserved;

        pInTempOffer++;
        pTemp++;

    }

    *pdwOfferCount = dwInOfferCount;
    *ppOffers = pOffers;
    return (dwError);

error:
    TRACE(TRC_ERROR, ("Failed to create QM offers"));    

    if (pOffers) {
        FreeQMOffers(
            i,
            pOffers
            );
    }

    *pdwOfferCount = 0;
    *ppOffers = NULL;
    return (dwError);
}


DWORD
DeleteIniQMPolicy(
    PINIQMPOLICY pIniQMPolicy
    )
{
    DWORD dwError = 0;
    PINIQMPOLICY * ppTemp = NULL;


    ppTemp = &gpIniQMPolicy;

    while (*ppTemp) {

        if (*ppTemp == pIniQMPolicy) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);

    }

    if (*ppTemp) {
        *ppTemp = pIniQMPolicy->pNext;
    }

    if ((pIniQMPolicy->dwFlags) & IPSEC_QM_POLICY_DEFAULT_POLICY) {
        gpIniDefaultQMPolicy = NULL;
        TRACE(
            TRC_INFORMATION,
            (L"Cleared default QM policy \"%ls\" (%!guid!)",
            pIniQMPolicy->pszPolicyName,
            &pIniQMPolicy->gPolicyID)
            );
    }

    FreeIniQMPolicy(pIniQMPolicy);

    return (dwError);
}


VOID
FreeQMOffers(
    DWORD dwOfferCount,
    PIPSEC_QM_OFFER pOffers
    )
{
    if (pOffers) {
        SPDApiBufferFree(pOffers);
    }
}


VOID
FreeIniQMPolicyList(
    PINIQMPOLICY pIniQMPolicyList
    )
{
    PINIQMPOLICY pTemp = NULL;
    PINIQMPOLICY pIniQMPolicy = NULL;


    pTemp = pIniQMPolicyList;

    while (pTemp) {

         pIniQMPolicy = pTemp;
         pTemp = pTemp->pNext;

         FreeIniQMPolicy(pIniQMPolicy);

    }
}


PINIQMPOLICY
FindQMPolicyByGuid(
    PINIQMPOLICY pIniQMPolicyList,
    GUID gPolicyID
    )
{
    DWORD dwError = 0;
    PINIQMPOLICY pTemp = NULL;


    pTemp = pIniQMPolicyList;

    while (pTemp) {

        if (!memcmp(&(pTemp->gPolicyID), &gPolicyID, sizeof(GUID))) {
            return (pTemp);
        }
        pTemp = pTemp->pNext;

    }

    return (NULL);
}


VOID
FreeQMPolicies(
    DWORD dwNumQMPolicies,
    PIPSEC_QM_POLICY pQMPolicies
    )
{
    DWORD i = 0;

    if (pQMPolicies) {

        for (i = 0; i < dwNumQMPolicies; i++) {

            if (pQMPolicies[i].pszPolicyName) {
                SPDApiBufferFree(pQMPolicies[i].pszPolicyName);
            }

            FreeQMOffers(
                pQMPolicies[i].dwOfferCount,
                pQMPolicies[i].pOffers
                );

        }

        SPDApiBufferFree(pQMPolicies);

    }

}


DWORD
GetQMPolicyByID(
    LPWSTR pServerName,
    DWORD dwVersion,
    GUID gQMPolicyID,
    DWORD dwFlags,
    PIPSEC_QM_POLICY * ppQMPolicy,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function gets a quick mode policy from the SPD.

Arguments:

    pServerName - Server from which to get the quick mode policy.

    gQMFilter - Guid of the quick mode policy to get.

    ppQMPolicy - Quick mode policy found returned to the caller.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINIQMPOLICY pIniQMPolicy = NULL;
    PIPSEC_QM_POLICY pQMPolicy = NULL;


    ENTER_SPD_SECTION();

    dwError = ValidateSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniQMPolicy = FindQMPolicyByGuid(
                       gpIniQMPolicy,
                       gQMPolicyID
                       );
    if (!pIniQMPolicy) {
        dwError = ERROR_IPSEC_QM_POLICY_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = GetIniQMPolicy(
                  dwFlags,
                  pIniQMPolicy,
                  &pQMPolicy
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    *ppQMPolicy = pQMPolicy;

    LEAVE_SPD_SECTION();
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    *ppQMPolicy = NULL;
    return (dwError);
}


DWORD
LocateQMPolicy(
    DWORD dwFlags,
    GUID gPolicyID,
    PINIQMPOLICY * ppIniQMPolicy
    )
{
    DWORD dwError = 0;
    PINIQMPOLICY pIniQMPolicy = NULL;


    if (dwFlags & IPSEC_QM_POLICY_DEFAULT_POLICY) {

        if (!gpIniDefaultQMPolicy) {
            dwError = ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        pIniQMPolicy = gpIniDefaultQMPolicy;

    }
    else {

        pIniQMPolicy = FindQMPolicyByGuid(
                           gpIniQMPolicy,
                           gPolicyID
                           );
        if (!pIniQMPolicy) {
            dwError = ERROR_IPSEC_QM_POLICY_NOT_FOUND;
            BAIL_ON_WIN32_ERROR(dwError);
        }

    }

    *ppIniQMPolicy = pIniQMPolicy;
    return (dwError);

error:

    *ppIniQMPolicy = NULL;
    return (dwError);

}


DWORD
CreateNonAHQMOffers(
    DWORD dwInOfferCount,
    PIPSEC_QM_OFFER pInOffers,
    PDWORD pdwOfferCount,
    PIPSEC_QM_OFFER * ppOffers
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_OFFER pInTempOffer = NULL;
    DWORD i = 0;
    BOOL bAH = FALSE;
    DWORD dwNonAHOfferCount = 0;
    PIPSEC_QM_OFFER pOffers = NULL;
    PIPSEC_QM_OFFER pTemp = NULL;
    DWORD j = 0;
    DWORD k = 0;


    pInTempOffer = pInOffers;

    for (i = 0; i < dwInOfferCount; i++) {

        bAH = IsAHQMOffer(pInTempOffer);
        if (!bAH) {
            dwNonAHOfferCount++;
        }

        pInTempOffer++;

    }

    if (!dwNonAHOfferCount) {
        *pdwOfferCount = 0;
        *ppOffers = NULL;
        return (dwError);
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_QM_OFFER) * dwNonAHOfferCount,
                  &(pOffers)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pOffers;
    pInTempOffer = pInOffers;

    for (i = 0; i < dwInOfferCount; i++) {

        bAH = IsAHQMOffer(pInTempOffer);
        if (bAH) {
            pInTempOffer++;
            continue;
        }

        memcpy(
            &(pTemp->Lifetime),
            &(pInTempOffer->Lifetime),
            sizeof(KEY_LIFETIME)
            );

        pTemp->dwFlags = pInTempOffer->dwFlags;
        pTemp->bPFSRequired = pInTempOffer->bPFSRequired;
        pTemp->dwPFSGroup = pInTempOffer->dwPFSGroup;
        pTemp->dwNumAlgos = pInTempOffer->dwNumAlgos;

        for (j = 0; j < (pInTempOffer->dwNumAlgos); j++) {
            memcpy(
                &(pTemp->Algos[j]),
                &(pInTempOffer->Algos[j]),
                sizeof(IPSEC_QM_ALGO)
                );
        }

        for (k = j; k < QM_MAX_ALGOS; k++) {
            memset(&(pTemp->Algos[k]), 0, sizeof(IPSEC_QM_ALGO));
        }

        pTemp->dwReserved = pInTempOffer->dwReserved;

        pInTempOffer++;
        pTemp++;

    }

    *pdwOfferCount = dwNonAHOfferCount;
    *ppOffers = pOffers;
    return (dwError);

error:

    if (pOffers) {
        FreeQMOffers(
            i,
            pOffers
            );
    }

    *pdwOfferCount = 0;
    *ppOffers = NULL;
    return (dwError);
}


BOOL
IsAHQMOffer(
    PIPSEC_QM_OFFER pIpsecQMOffer
    )
{
    BOOL bAH = FALSE;
    DWORD j = 0;


    for (j = 0; j < (pIpsecQMOffer->dwNumAlgos); j++) {

        switch (pIpsecQMOffer->Algos[j].Operation) {

        case AUTHENTICATION:
            bAH = TRUE;
            break;

        case ENCRYPTION:
            break;

        case NONE:
        case COMPRESSION:
        default:
            ASSERT(FALSE);
            break;

        }

        if (bAH) {
            break;
        }

    }

    return (bAH);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\protocol.c ===
#include "precomp.h"


DWORD
VerifyProtocols(
    PROTOCOL    Protocol
    )
{
    DWORD   dwError = 0;

    switch (Protocol.ProtocolType) {

    case PROTOCOL_UNIQUE:
        if (Protocol.dwProtocol > 255) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
        break;

    default:
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

error:

    return (dwError);
}


BOOL
EqualProtocols(
    IN PROTOCOL OldProtocol,
    IN PROTOCOL NewProtocol
    )
{
    BOOL bMatches = FALSE;

    if (OldProtocol.ProtocolType == NewProtocol.ProtocolType) {
        switch(OldProtocol.ProtocolType) {
        case PROTOCOL_UNIQUE:
            if (OldProtocol.dwProtocol == NewProtocol.dwProtocol) {
                bMatches = TRUE;
            }
            break;
        }
    }

    return (bMatches);
}


VOID
CopyProtocols(
    IN  PROTOCOL    InProtocol,
    OUT PPROTOCOL   pOutProtocol
    )
{
    memcpy(
        pOutProtocol,
        &InProtocol,
        sizeof(PROTOCOL)
        );
}


BOOL
MatchProtocols(
    PROTOCOL ProtocolToMatch,
    PROTOCOL ProtocolTemplate
    )
{
    switch (ProtocolTemplate.ProtocolType) {

    case PROTOCOL_UNIQUE:
        if (ProtocolToMatch.dwProtocol) {
            if (ProtocolToMatch.dwProtocol != 
                ProtocolTemplate.dwProtocol) {
                return (FALSE);
            }
        }
        break;

    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\security.h ===
#define MAX_ACE 6

#define SPD_OBJECT_SERVER 0

#define SPD_OBJECT_COUNT 1

#define SERVER_ACCESS_ADMINISTER 0x00000001

#define SERVER_ACCESS_ENUMERATE 0x00000002

#define SERVER_READ (STANDARD_RIGHTS_READ |\
                     SERVER_ACCESS_ENUMERATE)

#define SERVER_WRITE (STANDARD_RIGHTS_WRITE |\
                      SERVER_ACCESS_ADMINISTER |\
                      SERVER_ACCESS_ENUMERATE)

#define SERVER_EXECUTE (STANDARD_RIGHTS_EXECUTE |\
                        SERVER_ACCESS_ENUMERATE)

#define SERVER_ALL_ACCESS (STANDARD_RIGHTS_REQUIRED |\
                           SERVER_ACCESS_ADMINISTER |\
                           SERVER_ACCESS_ENUMERATE)


DWORD
InitializeSPDSecurity(
    PSECURITY_DESCRIPTOR * ppSPDSD
    );

DWORD
BuildSPDObjectProtection(
    DWORD dwAceCount,
    PUCHAR pAceType,
    PSID * ppAceSid,
    PACCESS_MASK pAceMask,
    PBYTE pInheritFlags,
    PSID pOwnerSid,
    PSID pGroupSid,
    PGENERIC_MAPPING pGenericMap,
    PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    );

DWORD
ValidateSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    );

VOID
MapGenericToSpecificAccess(
    DWORD dwObjectType,
    ACCESS_MASK GenericAccess,
    PACCESS_MASK pSpecificAccess
    );

BOOL
GetTokenHandle(
    PHANDLE phToken
    );

DWORD
ValidateMMSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    );

DWORD
ValidateTxSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    );

DWORD
ValidateTnSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\security.c ===
#include "precomp.h"


GENERIC_MAPPING GenericMapping[SPD_OBJECT_COUNT] = {
    {
      SERVER_READ,
      SERVER_WRITE,
      SERVER_EXECUTE,
      SERVER_ALL_ACCESS
    }
};


DWORD
InitializeSPDSecurity(
    PSECURITY_DESCRIPTOR * ppSPDSD
    )
{
    DWORD dwError = 0;
    BOOL bOK = FALSE;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID pAdminAliasSid = NULL;
    DWORD dwAceCount = 0;
    UCHAR AceType[MAX_ACE];
    PSID AceSid[MAX_ACE];
    ACCESS_MASK AceMask[MAX_ACE];
    BYTE InheritFlags[MAX_ACE];
    DWORD dwObjectType = SPD_OBJECT_SERVER;
    PSECURITY_DESCRIPTOR pSPDSD = NULL;


    //
    // Administrator Alias SID.
    //

    bOK = AllocateAndInitializeSid(
              &NtAuthority,
              2,
              SECURITY_BUILTIN_DOMAIN_RID,
              DOMAIN_ALIAS_RID_ADMINS,
              0, 0, 0, 0, 0, 0,
              &pAdminAliasSid
              );
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    AceType[dwAceCount] = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[dwAceCount] = pAdminAliasSid;
    AceMask[dwAceCount] = SERVER_ALL_ACCESS;
    InheritFlags[dwAceCount] = 0;
    dwAceCount++;

    AceType[dwAceCount] = ACCESS_ALLOWED_ACE_TYPE;
    AceSid[dwAceCount] = pAdminAliasSid;
    AceMask[dwAceCount] = GENERIC_ALL;
    InheritFlags[dwAceCount] = INHERIT_ONLY_ACE |
                               CONTAINER_INHERIT_ACE |
                               OBJECT_INHERIT_ACE;
    dwAceCount++;

    if (dwAceCount > MAX_ACE) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = BuildSPDObjectProtection(
                  dwAceCount,
                  AceType,
                  AceSid,
                  AceMask,
                  InheritFlags,
                  pAdminAliasSid,
                  pAdminAliasSid,
                  &GenericMapping[dwObjectType],
                  &pSPDSD
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppSPDSD = pSPDSD;

cleanup:

    if (pAdminAliasSid) {
        FreeSid(pAdminAliasSid);
    }

    return (dwError);

error:

    *ppSPDSD = NULL;

    goto cleanup;
}


DWORD
BuildSPDObjectProtection(
    DWORD dwAceCount,
    PUCHAR pAceType,
    PSID * ppAceSid,
    PACCESS_MASK pAceMask,
    PBYTE pInheritFlags,
    PSID pOwnerSid,
    PSID pGroupSid,
    PGENERIC_MAPPING pGenericMap,
    PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    )
{
    DWORD dwError = 0;
    BOOL bOK = FALSE;
    SECURITY_DESCRIPTOR Absolute;
    DWORD dwDaclLength = 0;
    DWORD i = 0;
    PACL pTmpAcl= NULL;
    PACCESS_ALLOWED_ACE pTmpAce = NULL;
    DWORD dwSDLength = 0;
    PSECURITY_DESCRIPTOR pRelative = NULL;


    bOK = InitializeSecurityDescriptor(
              &Absolute,
              SECURITY_DESCRIPTOR_REVISION1
              );
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    bOK = SetSecurityDescriptorOwner(
              &Absolute,
              pOwnerSid,
              FALSE
              );
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    bOK = SetSecurityDescriptorGroup(
              &Absolute,
              pGroupSid,
              FALSE
              );
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Build the Discretionary ACL:
    //     Calculate its length.
    //     Allocate it.
    //     Initialize it.
    //     Add each ACE.
    //     Set ACE as InheritOnly if necessary.
    //     Add it to the security descriptor.
    //

    dwDaclLength = (DWORD) sizeof(ACL);

    for (i = 0; i < dwAceCount; i++) {

        dwDaclLength += GetLengthSid(ppAceSid[i]) +
                        (DWORD) sizeof(ACCESS_ALLOWED_ACE) -
                        (DWORD) sizeof(DWORD);

        //
        // Subtract out SidStart field length.
        //

    }

    pTmpAcl = (PACL) AllocSPDMem(dwDaclLength);

    if (!pTmpAcl) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    bOK = InitializeAcl(
              pTmpAcl,
              dwDaclLength,
              ACL_REVISION2
              );
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    for (i = 0; i < dwAceCount; i++) {

        if (pAceType[i] == ACCESS_ALLOWED_ACE_TYPE) {
            bOK = AddAccessAllowedAce(
                      pTmpAcl,
                      ACL_REVISION2,
                      pAceMask[i],
                      ppAceSid[i]
                      );
        }
        else {
            bOK = AddAccessDeniedAce(
                      pTmpAcl,
                      ACL_REVISION2,
                      pAceMask[i],
                      ppAceSid[i]
                      );
        }
        if (!bOK) {
            dwError = GetLastError();
            BAIL_ON_WIN32_ERROR(dwError);
        }

        if (pInheritFlags[i] != 0) {

            bOK = GetAce(pTmpAcl, i, (LPVOID *) &pTmpAce);
            if (!bOK) {
                dwError = GetLastError();
                BAIL_ON_WIN32_ERROR(dwError);
            }

            pTmpAce->Header.AceFlags = pInheritFlags[i];

        }

    }

    bOK = SetSecurityDescriptorDacl(
              &Absolute,
              TRUE,
              pTmpAcl,
              FALSE
              );
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // Convert the security descriptor from absolute to self-relative:
    //     Get the length needed.
    //     Allocate that much memory.
    //     Copy it.
    //     Free the generated absolute ACLs.
    //

    dwSDLength = GetSecurityDescriptorLength(&Absolute);

    //
    // Must allocate the relative SD from heap.
    //

    pRelative = LocalAlloc(0, dwSDLength);
    if (!pRelative) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    bOK = MakeSelfRelativeSD(&Absolute, pRelative, &dwSDLength);
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    *ppSecurityDescriptor = pRelative;

cleanup:

    if (pTmpAcl){
        FreeSPDMem(pTmpAcl);
    }

    return (dwError);

error:

    *ppSecurityDescriptor = NULL;

    if (pRelative) {
        LocalFree(pRelative);
    }

    goto cleanup;
}


DWORD
ValidateSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    )
{
    DWORD dwError = 0;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    ACCESS_MASK MappedDesiredAccess = 0;
    BOOL bOK = FALSE;
    HANDLE hClientToken = NULL;
    BYTE PrivilegeSetBuffer[256];
    DWORD dwPrivilegeSetBufferLen = 256;
    PPRIVILEGE_SET pPrivilegeSet = NULL;
    BOOL bAccessCheckOK = FALSE;
    ACCESS_MASK GrantedAccess = 0;
    BOOL bAccessStatus = FALSE;


    memset(PrivilegeSetBuffer, 0, dwPrivilegeSetBufferLen);

    switch (dwObjectType) {

    case SPD_OBJECT_SERVER:
        pSecurityDescriptor = gpSPDSD;
        break;

    default:
        dwError = ERROR_ACCESS_DENIED;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    MapGenericToSpecificAccess(
        dwObjectType,
        DesiredAccess,
        &MappedDesiredAccess
        );

    bOK = GetTokenHandle(&hClientToken);
    if (!bOK) {
        dwError = GetLastError();
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pPrivilegeSet = (PPRIVILEGE_SET) PrivilegeSetBuffer;

    bAccessCheckOK = AccessCheck(
                         pSecurityDescriptor,
                         hClientToken,
                         MappedDesiredAccess,
                         &GenericMapping[dwObjectType],
                         pPrivilegeSet,
                         &dwPrivilegeSetBufferLen,
                         &GrantedAccess,
                         &bAccessStatus
                         );
    if (!bAccessCheckOK) {
        if (GetLastError() == ERROR_NO_IMPERSONATION_TOKEN) {
            dwError = ERROR_SUCCESS;
            GrantedAccess = MappedDesiredAccess;
        }
        else {
            dwError = GetLastError();
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }
    else {
        if (!bAccessStatus) {
            dwError = GetLastError();
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

    if (pGrantedAccess) {
        *pGrantedAccess = GrantedAccess;
    }

cleanup:

    if (hClientToken) {
        CloseHandle(hClientToken);
    }

    return (dwError);

error:

    if (pGrantedAccess) {
        *pGrantedAccess = 0;
    }

    goto cleanup;
}


VOID
MapGenericToSpecificAccess(
    DWORD dwObjectType,
    ACCESS_MASK GenericAccess,
    PACCESS_MASK pSpecificAccess
    )
{
    *pSpecificAccess = GenericAccess;

    MapGenericMask(
        pSpecificAccess,
        &GenericMapping[dwObjectType]
        );
}


BOOL
GetTokenHandle(
    PHANDLE phToken
    )
{
    if (!OpenThreadToken(
            GetCurrentThread(),
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
            TRUE,
            phToken)) {

        if (GetLastError() == ERROR_NO_TOKEN) {

            //
            // This means that there's no impersonation.
            // Get the token out of the process.
            //

            if (!OpenProcessToken(
                    GetCurrentProcess(),
                    TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                    phToken)) {
                return (FALSE);
            }

        } 
        else {
            return (FALSE);
        }

    }

    return (TRUE);
}


DWORD
ValidateMMSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    )
{
    DWORD dwError = 0;
    ACCESS_MASK GrantedAccess = 0;


    dwError = ValidateSecurity(
                  dwObjectType,
                  DesiredAccess,
                  pObjectHandle,
                  &GrantedAccess
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pGrantedAccess) {
        *pGrantedAccess = GrantedAccess;
    }

    return (dwError);

error:

    if (pGrantedAccess) {
        *pGrantedAccess = 0;
    }

    return (dwError);
}


DWORD
ValidateTxSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    )
{
    DWORD dwError = 0;
    ACCESS_MASK GrantedAccess = 0;


    dwError = ValidateSecurity(
                  dwObjectType,
                  DesiredAccess,
                  pObjectHandle,
                  &GrantedAccess
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pGrantedAccess) {
        *pGrantedAccess = GrantedAccess;
    }

    return (dwError);

error:

    if (pGrantedAccess) {
        *pGrantedAccess = 0;
    }

    return (dwError);
}


DWORD
ValidateTnSecurity(
    DWORD dwObjectType,
    ACCESS_MASK DesiredAccess,
    LPVOID pObjectHandle,
    PACCESS_MASK pGrantedAccess
    )
{
    DWORD dwError = 0;
    ACCESS_MASK GrantedAccess = 0;


    dwError = ValidateSecurity(
                  dwObjectType,
                  DesiredAccess,
                  pObjectHandle,
                  &GrantedAccess
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pGrantedAccess) {
        *pGrantedAccess = GrantedAccess;
    }

    return (dwError);

error:

    if (pGrantedAccess) {
        *pGrantedAccess = 0;
    }

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\spd_s_stub.c ===
#include "spd_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\spdrpc.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    spdrpc.c

Abstract:

    This module contains all of the code to service the
    RPC calls made to the SPD server.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


VOID
TRANSPORTFILTER_HANDLE_rundown(
    TRANSPORTFILTER_HANDLE hFilter
    )
{
    if (!gbSPDRPCServerUp) {
        return;
    }

    if (hFilter) {
        (VOID) DeleteTransportFilter(
                   hFilter
                   );
    }

    return;
}


DWORD
RpcAddTransportFilter(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PTRANSPORT_FILTER_CONTAINER pFilterContainer,
    TRANSPORTFILTER_HANDLE * phFilter
    )
{
    DWORD dwError = 0;
    PTRANSPORT_FILTER pTransportFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!pFilterContainer || !phFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pFilterContainer->pTransportFilters) ||
        !(pFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTransportFilter = pFilterContainer->pTransportFilters;

    if (pTransportFilter && (pTransportFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = AddTransportFilter(
                  pServerName,
                  dwVersion,
                  dwFlags,
                  pTransportFilter,
                  NULL,
                  phFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcDeleteTransportFilter(
    TRANSPORTFILTER_HANDLE * phFilter
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!phFilter) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = DeleteTransportFilter(
                  *phFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *phFilter = NULL;

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcEnumTransportFilters(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    PTRANSPORT_FILTER_CONTAINER pTemplateFilterContainer,
    DWORD dwLevel,
    GUID gGenericFilterID,
    DWORD dwPreferredNumEntries,
    PTRANSPORT_FILTER_CONTAINER * ppFilterContainer,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    PTRANSPORT_FILTER pTransportFilters = NULL;
    DWORD dwNumFilters = 0;
    BOOL bImpersonating = FALSE;
    PTRANSPORT_FILTER pTransportTemplateFilter = NULL;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pTemplateFilterContainer || !ppFilterContainer || !pdwResumeHandle ||
       !*ppFilterContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    switch (dwLevel) {

    case ENUM_GENERIC_FILTERS:
    case ENUM_SELECT_SPECIFIC_FILTERS:
    case ENUM_SPECIFIC_FILTERS:
        break;

    default:
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    if ((pTemplateFilterContainer->dwNumFilters) ||
        (pTemplateFilterContainer->pTransportFilters)) {
         dwError = ERROR_NOT_SUPPORTED;
         BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = EnumTransportFilters(
                  pServerName,
                  dwVersion,
                  pTransportTemplateFilter,
                  dwLevel,
                  gGenericFilterID,
                  dwPreferredNumEntries,
                  &pTransportFilters,
                  &dwNumFilters,
                  pdwResumeHandle,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppFilterContainer)->pTransportFilters = pTransportFilters;
    (*ppFilterContainer)->dwNumFilters = dwNumFilters;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppFilterContainer)->pTransportFilters = NULL;
    (*ppFilterContainer)->dwNumFilters = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcSetTransportFilter(
    TRANSPORTFILTER_HANDLE hFilter,
    DWORD dwVersion,
    PTRANSPORT_FILTER_CONTAINER pFilterContainer
    )
{
    DWORD dwError = 0;
    PTRANSPORT_FILTER pTransportFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!hFilter || !pFilterContainer) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pFilterContainer->pTransportFilters) ||
        !(pFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTransportFilter = pFilterContainer->pTransportFilters;

    if (pTransportFilter && (pTransportFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = SetTransportFilter(
                  hFilter,
                  dwVersion,
                  pTransportFilter,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcGetTransportFilter(
    TRANSPORTFILTER_HANDLE hFilter,
    DWORD dwVersion,
    PTRANSPORT_FILTER_CONTAINER * ppFilterContainer
    )
{
    DWORD dwError = 0;
    PTRANSPORT_FILTER pTransportFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!hFilter || !ppFilterContainer || !*ppFilterContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = GetTransportFilter(
                  hFilter,
                  dwVersion,
                  &pTransportFilter,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppFilterContainer)->pTransportFilters = pTransportFilter;
    (*ppFilterContainer)->dwNumFilters = 1;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppFilterContainer)->pTransportFilters = NULL;
    (*ppFilterContainer)->dwNumFilters = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcAddQMPolicy(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_POLICY pQMPolicy = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!pQMPolicyContainer) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pQMPolicyContainer->pPolicies) ||
        !(pQMPolicyContainer->dwNumPolicies)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pQMPolicy = pQMPolicyContainer->pPolicies;

    dwError = AddQMPolicy(
                  pServerName,
                  dwVersion,
                  dwFlags,
                  pQMPolicy,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcDeleteQMPolicy(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!pszPolicyName || !*pszPolicyName) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = DeleteQMPolicy(
                  pServerName,
                  dwVersion,
                  pszPolicyName,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcEnumQMPolicies(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    PIPSEC_QM_POLICY_CONTAINER pQMTempPolicyContainer,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PIPSEC_QM_POLICY_CONTAINER * ppQMPolicyContainer,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_POLICY pQMPolicies = NULL;
    DWORD dwNumPolicies = 0;
    BOOL bImpersonating = FALSE;
    PIPSEC_QM_POLICY pQMTemplatePolicy = NULL;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pQMTempPolicyContainer || !ppQMPolicyContainer || !pdwResumeHandle ||
        !*ppQMPolicyContainer) {
        //
        // Do not bail to error from here.
        //
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    if ((pQMTempPolicyContainer->dwNumPolicies) ||
        (pQMTempPolicyContainer->pPolicies)) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = EnumQMPolicies(
                  pServerName,
                  dwVersion,
                  pQMTemplatePolicy,
                  dwFlags,
                  dwPreferredNumEntries,
                  &pQMPolicies,
                  &dwNumPolicies,
                  pdwResumeHandle,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppQMPolicyContainer)->pPolicies = pQMPolicies;
    (*ppQMPolicyContainer)->dwNumPolicies = dwNumPolicies;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppQMPolicyContainer)->pPolicies = NULL;
    (*ppQMPolicyContainer)->dwNumPolicies = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcSetQMPolicy(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    PIPSEC_QM_POLICY_CONTAINER pQMPolicyContainer
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_POLICY pQMPolicy = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!pszPolicyName || !*pszPolicyName ||
        !pQMPolicyContainer) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pQMPolicyContainer->pPolicies) ||
        !(pQMPolicyContainer->dwNumPolicies)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pQMPolicy = pQMPolicyContainer->pPolicies;

    dwError = SetQMPolicy(
                  pServerName,
                  dwVersion,
                  pszPolicyName,
                  pQMPolicy,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcGetQMPolicy(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    DWORD dwFlags,
    PIPSEC_QM_POLICY_CONTAINER * ppQMPolicyContainer
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_POLICY pQMPolicy = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pszPolicyName || !*pszPolicyName || !ppQMPolicyContainer ||
        !*ppQMPolicyContainer) {
        //
        // Do not bail to error from here.
        //
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = GetQMPolicy(
                  pServerName,
                  dwVersion,
                  pszPolicyName,
                  dwFlags,
                  &pQMPolicy,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppQMPolicyContainer)->pPolicies = pQMPolicy;
    (*ppQMPolicyContainer)->dwNumPolicies = 1;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppQMPolicyContainer)->pPolicies = NULL;
    (*ppQMPolicyContainer)->dwNumPolicies = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcAddMMPolicy(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PIPSEC_MM_POLICY_CONTAINER pMMPolicyContainer
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_POLICY pMMPolicy = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!pMMPolicyContainer) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMPolicyContainer->pPolicies) ||
        !(pMMPolicyContainer->dwNumPolicies)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMMPolicy = pMMPolicyContainer->pPolicies;

    dwError = AddMMPolicy(
                  pServerName,
                  dwVersion,
                  dwFlags,
                  pMMPolicy,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcDeleteMMPolicy(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!pszPolicyName || !*pszPolicyName) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = DeleteMMPolicy(
                  pServerName,
                  dwVersion,
                  pszPolicyName,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcEnumMMPolicies(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    PIPSEC_MM_POLICY_CONTAINER pMMTempPolicyContainer,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PIPSEC_MM_POLICY_CONTAINER * ppMMPolicyContainer,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_POLICY pMMPolicies = NULL;
    DWORD dwNumPolicies = 0;
    BOOL bImpersonating = FALSE;
    PIPSEC_MM_POLICY pMMTemplatePolicy = NULL;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pMMTempPolicyContainer || !ppMMPolicyContainer || !pdwResumeHandle ||
        !*ppMMPolicyContainer) {
        //
        // Do not bail to error from here.
        //
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    if ((pMMTempPolicyContainer->dwNumPolicies) ||
        (pMMTempPolicyContainer->pPolicies)) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = EnumMMPolicies(
                  pServerName,
                  dwVersion,
                  pMMTemplatePolicy,
                  dwFlags,
                  dwPreferredNumEntries,
                  &pMMPolicies,
                  &dwNumPolicies,
                  pdwResumeHandle,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppMMPolicyContainer)->pPolicies = pMMPolicies;
    (*ppMMPolicyContainer)->dwNumPolicies = dwNumPolicies;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppMMPolicyContainer)->pPolicies = NULL;
    (*ppMMPolicyContainer)->dwNumPolicies = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcSetMMPolicy(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    PIPSEC_MM_POLICY_CONTAINER pMMPolicyContainer
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_POLICY pMMPolicy = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!pszPolicyName || !*pszPolicyName ||
        !pMMPolicyContainer) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMPolicyContainer->pPolicies) ||
        !(pMMPolicyContainer->dwNumPolicies)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMMPolicy = pMMPolicyContainer->pPolicies;

    dwError = SetMMPolicy(
                  pServerName,
                  dwVersion,
                  pszPolicyName,
                  pMMPolicy,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcGetMMPolicy(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    LPWSTR pszPolicyName,
    PIPSEC_MM_POLICY_CONTAINER * ppMMPolicyContainer
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_POLICY pMMPolicy = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pszPolicyName || !*pszPolicyName || !ppMMPolicyContainer ||
        !*ppMMPolicyContainer) {
        //
        // Do not bail to error from here.
        //
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = GetMMPolicy(
                  pServerName,
                  dwVersion,
                  pszPolicyName,
                  &pMMPolicy,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppMMPolicyContainer)->pPolicies = pMMPolicy;
    (*ppMMPolicyContainer)->dwNumPolicies = 1;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppMMPolicyContainer)->pPolicies = NULL;
    (*ppMMPolicyContainer)->dwNumPolicies = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


VOID
MMFILTER_HANDLE_rundown(
    MMFILTER_HANDLE hMMFilter
    )
{
    if (!gbSPDRPCServerUp) {
        return;
    }

    if (hMMFilter) {
        (VOID) DeleteMMFilter(
                   hMMFilter
                   );
    }

    return;
}


DWORD
RpcAddMMFilter(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PMM_FILTER_CONTAINER pMMFilterContainer,
    MMFILTER_HANDLE * phMMFilter
    )
{
    DWORD dwError = 0;
    PMM_FILTER pMMFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!pMMFilterContainer || !phMMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMFilterContainer->pMMFilters) ||
        !(pMMFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMMFilter = pMMFilterContainer->pMMFilters;

    if (pMMFilter && (pMMFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = AddMMFilter(
                  pServerName,
                  dwVersion,
                  dwFlags,
                  pMMFilter,
                  NULL,
                  phMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcDeleteMMFilter(
    MMFILTER_HANDLE * phMMFilter
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!phMMFilter) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = DeleteMMFilter(
                  *phMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *phMMFilter = NULL;

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcEnumMMFilters(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    PMM_FILTER_CONTAINER pTemplateFilterContainer,
    DWORD dwLevel,
    GUID gGenericFilterID,
    DWORD dwPreferredNumEntries,
    PMM_FILTER_CONTAINER * ppMMFilterContainer,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    PMM_FILTER pMMFilters = NULL;
    DWORD dwNumFilters = 0;
    BOOL bImpersonating = FALSE;
    PMM_FILTER pMMTemplateFilter = NULL;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pTemplateFilterContainer || !ppMMFilterContainer || !pdwResumeHandle ||
        !*ppMMFilterContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    switch (dwLevel) {

    case ENUM_GENERIC_FILTERS:
    case ENUM_SELECT_SPECIFIC_FILTERS:
    case ENUM_SPECIFIC_FILTERS:
        break;

    default:
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    if ((pTemplateFilterContainer->dwNumFilters) ||
        (pTemplateFilterContainer->pMMFilters)) {
         dwError = ERROR_NOT_SUPPORTED;
         BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = EnumMMFilters(
                  pServerName,
                  dwVersion,
                  pMMTemplateFilter,
                  dwLevel,
                  gGenericFilterID,
                  dwPreferredNumEntries,
                  &pMMFilters,
                  &dwNumFilters,
                  pdwResumeHandle,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppMMFilterContainer)->pMMFilters = pMMFilters;
    (*ppMMFilterContainer)->dwNumFilters = dwNumFilters;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppMMFilterContainer)->pMMFilters = NULL;
    (*ppMMFilterContainer)->dwNumFilters = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcSetMMFilter(
    MMFILTER_HANDLE hMMFilter,
    DWORD dwVersion,
    PMM_FILTER_CONTAINER pMMFilterContainer
    )
{
    DWORD dwError = 0;
    PMM_FILTER pMMFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!hMMFilter || !pMMFilterContainer) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMFilterContainer->pMMFilters) ||
        !(pMMFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMMFilter = pMMFilterContainer->pMMFilters;

    if (pMMFilter && (pMMFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = SetMMFilter(
                  hMMFilter,
                  dwVersion,
                  pMMFilter,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcGetMMFilter(
    MMFILTER_HANDLE hMMFilter,
    DWORD dwVersion,
    PMM_FILTER_CONTAINER * ppMMFilterContainer
    )
{
    DWORD dwError = 0;
    PMM_FILTER pMMFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!hMMFilter || !ppMMFilterContainer || !*ppMMFilterContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = GetMMFilter(
                  hMMFilter,
                  dwVersion,
                  &pMMFilter,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppMMFilterContainer)->pMMFilters = pMMFilter;
    (*ppMMFilterContainer)->dwNumFilters = 1;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppMMFilterContainer)->pMMFilters = NULL;
    (*ppMMFilterContainer)->dwNumFilters = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcMatchMMFilter(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    PMM_FILTER_CONTAINER pMMFilterContainer,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PMM_FILTER_CONTAINER * ppMMFilterContainer,
    PIPSEC_MM_POLICY_CONTAINER * ppMMPolicyContainer,
    PMM_AUTH_METHODS_CONTAINER * ppMMAuthContainer,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    PMM_FILTER pMMFilter = NULL;
    PMM_FILTER pMatchedMMFilters = NULL;
    PIPSEC_MM_POLICY pMatchedMMPolicies = NULL;
    PINT_MM_AUTH_METHODS pMatchedMMAuthMethods = NULL;
    DWORD dwNumMatches = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pMMFilterContainer || !ppMMFilterContainer ||
        !ppMMPolicyContainer || !ppMMAuthContainer || !pdwResumeHandle ||
        !*ppMMFilterContainer || !*ppMMPolicyContainer || !*ppMMAuthContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    if (!(pMMFilterContainer->pMMFilters) ||
        !(pMMFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMMFilter = pMMFilterContainer->pMMFilters;

    if (pMMFilter && (pMMFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = IntMatchMMFilter(
                  pServerName,
                  dwVersion,
                  pMMFilter,
                  dwFlags,
                  dwPreferredNumEntries,
                  &pMatchedMMFilters,
                  &pMatchedMMPolicies,
                  &pMatchedMMAuthMethods,
                  &dwNumMatches,
                  pdwResumeHandle,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppMMFilterContainer)->pMMFilters = pMatchedMMFilters;
    (*ppMMFilterContainer)->dwNumFilters = dwNumMatches;
    (*ppMMPolicyContainer)->pPolicies = pMatchedMMPolicies;
    (*ppMMPolicyContainer)->dwNumPolicies = dwNumMatches;
    dwError = SPDConvertArrayIntMMAuthToExt(
                  pMatchedMMAuthMethods,
                  &(*ppMMAuthContainer)->pMMAuthMethods,
                  dwNumMatches
                  );
    BAIL_ON_WIN32_ERROR(dwError);                                    
    (*ppMMAuthContainer)->dwNumAuthMethods = dwNumMatches;

    SPDFreeIntMMAuthMethodsArray(
        pMatchedMMAuthMethods,
        dwNumMatches
        );
    pMatchedMMAuthMethods = NULL;    
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:
    if (pMatchedMMFilters) {
        FreeMMFilters(
            dwNumMatches,
            pMatchedMMFilters
            );
    }

    if (pMatchedMMPolicies) {
        FreeMMPolicies(
            dwNumMatches,
            pMatchedMMPolicies
            );
    }

    SPDFreeIntMMAuthMethodsArray(
        pMatchedMMAuthMethods,
        dwNumMatches
        );

    (*ppMMFilterContainer)->pMMFilters = NULL;
    (*ppMMFilterContainer)->dwNumFilters = 0;
    (*ppMMPolicyContainer)->pPolicies = NULL;
    (*ppMMPolicyContainer)->dwNumPolicies = 0;
    (*ppMMAuthContainer)->pMMAuthMethods = NULL;
    (*ppMMAuthContainer)->dwNumAuthMethods = 0;

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcMatchTransportFilter(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    PTRANSPORT_FILTER_CONTAINER pTxFilterContainer,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PTRANSPORT_FILTER_CONTAINER * ppTxFilterContainer,
    PIPSEC_QM_POLICY_CONTAINER * ppQMPolicyContainer,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    PTRANSPORT_FILTER pTxFilter = NULL;
    PTRANSPORT_FILTER pMatchedTxFilters = NULL;
    PIPSEC_QM_POLICY pMatchedQMPolicies = NULL;
    DWORD dwNumMatches = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pTxFilterContainer || !ppTxFilterContainer ||
        !ppQMPolicyContainer || !pdwResumeHandle ||
        !*ppTxFilterContainer || !*ppQMPolicyContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    if (!(pTxFilterContainer->pTransportFilters) ||
        !(pTxFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTxFilter = pTxFilterContainer->pTransportFilters;

    if (pTxFilter && (pTxFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = MatchTransportFilter(
                  pServerName,
                  dwVersion,
                  pTxFilter,
                  dwFlags,
                  dwPreferredNumEntries,
                  &pMatchedTxFilters,
                  &pMatchedQMPolicies,
                  &dwNumMatches,
                  pdwResumeHandle,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppTxFilterContainer)->pTransportFilters = pMatchedTxFilters;
    (*ppTxFilterContainer)->dwNumFilters = dwNumMatches;
    (*ppQMPolicyContainer)->pPolicies = pMatchedQMPolicies;
    (*ppQMPolicyContainer)->dwNumPolicies = dwNumMatches;

    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppTxFilterContainer)->pTransportFilters = NULL;
    (*ppTxFilterContainer)->dwNumFilters = 0;
    (*ppQMPolicyContainer)->pPolicies = NULL;
    (*ppQMPolicyContainer)->dwNumPolicies = 0;

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcGetQMPolicyByID(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    GUID gQMPolicyID,
    DWORD dwFlags,
    PIPSEC_QM_POLICY_CONTAINER * ppQMPolicyContainer
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_POLICY pQMPolicy = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!ppQMPolicyContainer || !*ppQMPolicyContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = GetQMPolicyByID(
                  pServerName,
                  dwVersion,
                  gQMPolicyID,
                  dwFlags,
                  &pQMPolicy,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppQMPolicyContainer)->pPolicies = pQMPolicy;
    (*ppQMPolicyContainer)->dwNumPolicies = 1;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppQMPolicyContainer)->pPolicies = NULL;
    (*ppQMPolicyContainer)->dwNumPolicies = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcGetMMPolicyByID(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    GUID gMMPolicyID,
    PIPSEC_MM_POLICY_CONTAINER * ppMMPolicyContainer
    )
{
    DWORD dwError = 0;
    PIPSEC_MM_POLICY pMMPolicy = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!ppMMPolicyContainer || !*ppMMPolicyContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = GetMMPolicyByID(
                  pServerName,
                  dwVersion,
                  gMMPolicyID,
                  &pMMPolicy,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppMMPolicyContainer)->pPolicies = pMMPolicy;
    (*ppMMPolicyContainer)->dwNumPolicies = 1;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppMMPolicyContainer)->pPolicies = NULL;
    (*ppMMPolicyContainer)->dwNumPolicies = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcAddMMAuthMethods(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PMM_AUTH_METHODS_CONTAINER pMMAuthContainer
    )
{
    DWORD dwError = 0;
    PINT_MM_AUTH_METHODS pMMAuthMethods = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!pMMAuthContainer) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMAuthContainer->pMMAuthMethods) ||
        !(pMMAuthContainer->dwNumAuthMethods)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ConvertExtMMAuthToInt(
                  pMMAuthContainer->pMMAuthMethods,
                  &pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IntAddMMAuthMethods(
                  pServerName,
                  dwVersion,
                  dwFlags,
                  IPSEC_SOURCE_WINIPSEC,
                  pMMAuthMethods,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:
    FreeIntMMAuthMethods(pMMAuthMethods);
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcDeleteMMAuthMethods(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    GUID gMMAuthID
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = DeleteMMAuthMethods(
                  pServerName,
                  dwVersion,
                  gMMAuthID,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcEnumMMAuthMethods(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    PMM_AUTH_METHODS_CONTAINER pMMTempAuthContainer,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PMM_AUTH_METHODS_CONTAINER * ppMMAuthContainer,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    PINT_MM_AUTH_METHODS pMMAuthMethods = NULL;
    DWORD dwNumAuthMethods = 0;
    BOOL bImpersonating = FALSE;
    PINT_MM_AUTH_METHODS pMMTemplateAuthMethods = NULL;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pMMTempAuthContainer || !ppMMAuthContainer || !pdwResumeHandle ||
        !*ppMMAuthContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    if ((pMMTempAuthContainer->dwNumAuthMethods) ||
        (pMMTempAuthContainer->pMMAuthMethods)) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = IntEnumMMAuthMethods(
                  pServerName,
                  dwVersion,
                  pMMTemplateAuthMethods,
                  dwFlags,
                  dwPreferredNumEntries,
                  &pMMAuthMethods,
                  &dwNumAuthMethods,
                  pdwResumeHandle,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDConvertArrayIntMMAuthToExt(
                  pMMAuthMethods,
                  &(*ppMMAuthContainer)->pMMAuthMethods,
                  dwNumAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    (*ppMMAuthContainer)->dwNumAuthMethods = dwNumAuthMethods;

    SPDFreeIntMMAuthMethodsArray(
        pMMAuthMethods,
        dwNumAuthMethods
        );

    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:
    (*ppMMAuthContainer)->pMMAuthMethods = NULL;
    (*ppMMAuthContainer)->dwNumAuthMethods = 0;

    SPDFreeIntMMAuthMethodsArray(
        pMMAuthMethods,
        dwNumAuthMethods
        );
    
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcSetMMAuthMethods(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    GUID gMMAuthID,
    PMM_AUTH_METHODS_CONTAINER pMMAuthContainer
    )
{
    DWORD dwError = 0;
    PINT_MM_AUTH_METHODS pMMAuthMethods = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!pMMAuthContainer) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMAuthContainer->pMMAuthMethods) ||
        !(pMMAuthContainer->dwNumAuthMethods)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ConvertExtMMAuthToInt(
                  pMMAuthContainer->pMMAuthMethods,
                  &pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = IntSetMMAuthMethods(
                  pServerName,
                  dwVersion,
                  gMMAuthID,
                  pMMAuthMethods,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:
    FreeIntMMAuthMethods(pMMAuthMethods);
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcGetMMAuthMethods(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    GUID gMMAuthID,
    PMM_AUTH_METHODS_CONTAINER * ppMMAuthContainer
    )
{
    DWORD dwError = 0;
    PINT_MM_AUTH_METHODS pMMAuthMethods = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!ppMMAuthContainer || !*ppMMAuthContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = IntGetMMAuthMethods(
                  pServerName,
                  dwVersion,
                  gMMAuthID,
                  &pMMAuthMethods,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDConvertIntMMAuthToExt(
                  pMMAuthMethods,
                  &(*ppMMAuthContainer)->pMMAuthMethods
                  );
    BAIL_ON_WIN32_ERROR(dwError);                  
    (*ppMMAuthContainer)->dwNumAuthMethods = 1;

    SPDFreeIntMMAuthMethods(pMMAuthMethods, TRUE);    
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:
    SPDFreeIntMMAuthMethods(pMMAuthMethods, TRUE);
    (*ppMMAuthContainer)->pMMAuthMethods = NULL;
    (*ppMMAuthContainer)->dwNumAuthMethods = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcQueryIPSecStatistics(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    PIPSEC_STATISTICS_CONTAINER * ppIpsecStatsContainer
    )
{
    DWORD dwError = 0;
    PIPSEC_STATISTICS pIpsecStatistics = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!ppIpsecStatsContainer || !*ppIpsecStatsContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = QueryIPSecStatistics(
                  pServerName,
                  dwVersion,
                  &pIpsecStatistics,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppIpsecStatsContainer)->pIpsecStatistics = pIpsecStatistics;
    (*ppIpsecStatsContainer)->dwNumIpsecStats = 1;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppIpsecStatsContainer)->pIpsecStatistics = NULL;
    (*ppIpsecStatsContainer)->dwNumIpsecStats = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcEnumQMSAs(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    PQM_SA_CONTAINER pQMSATempContainer,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PQM_SA_CONTAINER * ppQMSAContainer,
    LPDWORD pdwNumTotalQMSAs,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    PIPSEC_QM_SA pQMSATemplate = NULL;
    PIPSEC_QM_SA pQMSAs = NULL;
    DWORD dwNumQMSAs = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pQMSATempContainer || !ppQMSAContainer ||
        !pdwNumTotalQMSAs || !pdwResumeHandle ||
        !*ppQMSAContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    if ((pQMSATempContainer->dwNumQMSAs) || (pQMSATempContainer->pQMSAs)) {
         dwError = ERROR_NOT_SUPPORTED;
         BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = EnumQMSAs(
                  pServerName,
                  dwVersion,
                  pQMSATemplate,
                  dwFlags,
                  dwPreferredNumEntries,
                  &pQMSAs,
                  &dwNumQMSAs,
                  pdwNumTotalQMSAs,
                  pdwResumeHandle,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppQMSAContainer)->pQMSAs = pQMSAs;
    (*ppQMSAContainer)->dwNumQMSAs = dwNumQMSAs;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppQMSAContainer)->pQMSAs = NULL;
    (*ppQMSAContainer)->dwNumQMSAs = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


VOID
TUNNELFILTER_HANDLE_rundown(
    TUNNELFILTER_HANDLE hFilter
    )
{
    if (!gbSPDRPCServerUp) {
        return;
    }

    if (hFilter) {
        (VOID) DeleteTunnelFilter(
                   hFilter
                   );
    }

    return;
}


DWORD
RpcAddTunnelFilter(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PTUNNEL_FILTER_CONTAINER pFilterContainer,
    TUNNELFILTER_HANDLE * phFilter
    )
{
    DWORD dwError = 0;
    PTUNNEL_FILTER pTunnelFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!pFilterContainer || !phFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pFilterContainer->pTunnelFilters) ||
        !(pFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTunnelFilter = pFilterContainer->pTunnelFilters;

    if (pTunnelFilter && (pTunnelFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = AddTunnelFilter(
                  pServerName,
                  dwVersion,
                  dwFlags,
                  pTunnelFilter,
                  NULL,
                  phFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcDeleteTunnelFilter(
    TUNNELFILTER_HANDLE * phFilter
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!phFilter) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = DeleteTunnelFilter(
                  *phFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *phFilter = NULL;

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcEnumTunnelFilters(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    PTUNNEL_FILTER_CONTAINER pTemplateFilterContainer,
    DWORD dwLevel,
    GUID gGenericFilterID,
    DWORD dwPreferredNumEntries,
    PTUNNEL_FILTER_CONTAINER * ppFilterContainer,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    PTUNNEL_FILTER pTunnelFilters = NULL;
    DWORD dwNumFilters = 0;
    BOOL bImpersonating = FALSE;
    PTUNNEL_FILTER pTunnelTemplateFilter = NULL;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pTemplateFilterContainer || !ppFilterContainer || !pdwResumeHandle ||
        !*ppFilterContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    switch (dwLevel) {

    case ENUM_GENERIC_FILTERS:
    case ENUM_SELECT_SPECIFIC_FILTERS:
    case ENUM_SPECIFIC_FILTERS:
        break;

    default:
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
        break;

    }

    if ((pTemplateFilterContainer->dwNumFilters) ||
        (pTemplateFilterContainer->pTunnelFilters)) {
         dwError = ERROR_NOT_SUPPORTED;
         BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = EnumTunnelFilters(
                  pServerName,
                  dwVersion,
                  pTunnelTemplateFilter,
                  dwLevel,
                  gGenericFilterID,
                  dwPreferredNumEntries,
                  &pTunnelFilters,
                  &dwNumFilters,
                  pdwResumeHandle,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppFilterContainer)->pTunnelFilters = pTunnelFilters;
    (*ppFilterContainer)->dwNumFilters = dwNumFilters;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppFilterContainer)->pTunnelFilters = NULL;
    (*ppFilterContainer)->dwNumFilters = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcSetTunnelFilter(
    TUNNELFILTER_HANDLE hFilter,
    DWORD dwVersion,
    PTUNNEL_FILTER_CONTAINER pFilterContainer
    )
{
    DWORD dwError = 0;
    PTUNNEL_FILTER pTunnelFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!hFilter || !pFilterContainer) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pFilterContainer->pTunnelFilters) ||
        !(pFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTunnelFilter = pFilterContainer->pTunnelFilters;

    if (pTunnelFilter && (pTunnelFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = SetTunnelFilter(
                  hFilter,
                  dwVersion,
                  pTunnelFilter,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcGetTunnelFilter(
    TUNNELFILTER_HANDLE hFilter,
    DWORD dwVersion,
    PTUNNEL_FILTER_CONTAINER * ppFilterContainer
    )
{
    DWORD dwError = 0;
    PTUNNEL_FILTER pTunnelFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!hFilter || !ppFilterContainer || !*ppFilterContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = GetTunnelFilter(
                  hFilter,
                  dwVersion,
                  &pTunnelFilter,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppFilterContainer)->pTunnelFilters = pTunnelFilter;
    (*ppFilterContainer)->dwNumFilters = 1;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppFilterContainer)->pTunnelFilters = NULL;
    (*ppFilterContainer)->dwNumFilters = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcMatchTunnelFilter(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    PTUNNEL_FILTER_CONTAINER pTnFilterContainer,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PTUNNEL_FILTER_CONTAINER * ppTnFilterContainer,
    PIPSEC_QM_POLICY_CONTAINER * ppQMPolicyContainer,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    PTUNNEL_FILTER pTnFilter = NULL;
    PTUNNEL_FILTER pMatchedTnFilters = NULL;
    PIPSEC_QM_POLICY pMatchedQMPolicies = NULL;
    DWORD dwNumMatches = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pTnFilterContainer || !ppTnFilterContainer ||
        !ppQMPolicyContainer || !pdwResumeHandle ||
        !*ppTnFilterContainer || !*ppQMPolicyContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    if (!(pTnFilterContainer->pTunnelFilters) ||
        !(pTnFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTnFilter = pTnFilterContainer->pTunnelFilters;

    if (pTnFilter && (pTnFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = MatchTunnelFilter(
                  pServerName,
                  dwVersion,
                  pTnFilter,
                  dwFlags,
                  dwPreferredNumEntries,
                  &pMatchedTnFilters,
                  &pMatchedQMPolicies,
                  &dwNumMatches,
                  pdwResumeHandle,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppTnFilterContainer)->pTunnelFilters = pMatchedTnFilters;
    (*ppTnFilterContainer)->dwNumFilters = dwNumMatches;
    (*ppQMPolicyContainer)->pPolicies = pMatchedQMPolicies;
    (*ppQMPolicyContainer)->dwNumPolicies = dwNumMatches;

    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppTnFilterContainer)->pTunnelFilters = NULL;
    (*ppTnFilterContainer)->dwNumFilters = 0;
    (*ppQMPolicyContainer)->pPolicies = NULL;
    (*ppQMPolicyContainer)->dwNumPolicies = 0;

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcOpenMMFilterHandle(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    PMM_FILTER_CONTAINER pMMFilterContainer,
    MMFILTER_HANDLE * phMMFilter
    )
{
    DWORD dwError = 0;
    PMM_FILTER pMMFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!pMMFilterContainer || !phMMFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pMMFilterContainer->pMMFilters) ||
        !(pMMFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pMMFilter = pMMFilterContainer->pMMFilters;

    if (pMMFilter && (pMMFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = OpenMMFilterHandle(
                  pServerName,
                  dwVersion,
                  pMMFilter,
                  NULL,
                  phMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcCloseMMFilterHandle(
    MMFILTER_HANDLE * phMMFilter
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!phMMFilter) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = CloseMMFilterHandle(
                  *phMMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *phMMFilter = NULL;

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcOpenTransportFilterHandle(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    PTRANSPORT_FILTER_CONTAINER pFilterContainer,
    TRANSPORTFILTER_HANDLE * phFilter
    )
{
    DWORD dwError = 0;
    PTRANSPORT_FILTER pTransportFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!pFilterContainer || !phFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pFilterContainer->pTransportFilters) ||
        !(pFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTransportFilter = pFilterContainer->pTransportFilters;

    if (pTransportFilter && (pTransportFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = OpenTransportFilterHandle(
                  pServerName,
                  dwVersion,
                  pTransportFilter,
                  NULL,
                  phFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcCloseTransportFilterHandle(
    TRANSPORTFILTER_HANDLE * phFilter
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!phFilter) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = CloseTransportFilterHandle(
                  *phFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *phFilter = NULL;

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcOpenTunnelFilterHandle(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    PTUNNEL_FILTER_CONTAINER pFilterContainer,
    TUNNELFILTER_HANDLE * phFilter
    )
{
    DWORD dwError = 0;
    PTUNNEL_FILTER pTunnelFilter = NULL;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!pFilterContainer || !phFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pFilterContainer->pTunnelFilters) ||
        !(pFilterContainer->dwNumFilters)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTunnelFilter = pFilterContainer->pTunnelFilters;

    if (pTunnelFilter && (pTunnelFilter->IpVersion != IPSEC_PROTOCOL_V4)) {
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = OpenTunnelFilterHandle(
                  pServerName,
                  dwVersion,
                  pTunnelFilter,
                  NULL,
                  phFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcCloseTunnelFilterHandle(
    TUNNELFILTER_HANDLE * phFilter
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!phFilter) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = CloseTunnelFilterHandle(
                  *phFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *phFilter = NULL;

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcEnumIpsecInterfaces(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    PIPSEC_INTERFACE_CONTAINER pIpsecIfTempContainer,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PIPSEC_INTERFACE_CONTAINER * ppIpsecIfContainer,
    LPDWORD pdwNumTotalInterfaces,
    LPDWORD pdwResumeHandle
    )
{
    DWORD dwError = 0;
    PIPSEC_INTERFACE_INFO pIpsecIfTemplate = NULL;
    PIPSEC_INTERFACE_INFO pIpsecInterfaces = NULL;
    DWORD dwNumInterfaces = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!pIpsecIfTempContainer || !ppIpsecIfContainer ||
        !pdwNumTotalInterfaces || !pdwResumeHandle ||
        !*ppIpsecIfContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    if ((pIpsecIfTempContainer->dwNumInterfaces) ||
        (pIpsecIfTempContainer->pIpsecInterfaces)) {
         dwError = ERROR_NOT_SUPPORTED;
         BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = EnumIPSecInterfaces(
                  pServerName,
                  dwVersion,
                  pIpsecIfTemplate,
                  dwFlags,
                  dwPreferredNumEntries,
                  &pIpsecInterfaces,
                  &dwNumInterfaces,
                  pdwNumTotalInterfaces,
                  pdwResumeHandle,
                  NULL
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppIpsecIfContainer)->pIpsecInterfaces = pIpsecInterfaces;
    (*ppIpsecIfContainer)->dwNumInterfaces = dwNumInterfaces;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

    (*ppIpsecIfContainer)->pIpsecInterfaces = NULL;
    (*ppIpsecIfContainer)->dwNumInterfaces = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}


DWORD
RpcDeleteQMSAs(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    PQM_SA_CONTAINER pQMSAContainer,
    DWORD dwFlags
    )
{
    DWORD dwError = 0;
    BOOL bImpersonating = FALSE;


    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (dwVersion) {
        dwError = ERROR_NOT_SUPPORTED;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!pQMSAContainer) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (!(pQMSAContainer->pQMSAs) ||
        !(pQMSAContainer->dwNumQMSAs)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    if (pQMSAContainer->pQMSAs &&
        (pQMSAContainer->pQMSAs->IpsecQMFilter.IpVersion != IPSEC_PROTOCOL_V4)) {
        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateQMFilterAddresses(
                  &pQMSAContainer->pQMSAs->IpsecQMFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = DeleteQMSAs(
                 pServerName,
                 dwVersion,
                 pQMSAContainer->pQMSAs,
                 dwFlags,
                 NULL
                 );
    BAIL_ON_WIN32_ERROR(dwError);

error:

    SPDRevertToSelf(bImpersonating);
    return (dwError);
}

DWORD
WINAPI
RpcQuerySpdPolicyState(
    STRING_HANDLE pServerName,
    DWORD dwVersion,
    PSPD_POLICY_STATE_CONTAINER * ppSpdPolicyStateContainer
    )
{
    DWORD dwError = 0;
    PSPD_POLICY_STATE pSpdPolicyState = NULL;
    BOOL bImpersonating = FALSE;

    dwError = SPDImpersonateClient(
                  &bImpersonating
                  );
    if (dwError) {
        return (dwError);
    }

    if (dwVersion) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_NOT_SUPPORTED);
    }

    if (!ppSpdPolicyStateContainer || !*ppSpdPolicyStateContainer) {
        SPDRevertToSelf(bImpersonating);
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = QuerySpdPolicyState(
                pServerName,
                dwVersion,
                &pSpdPolicyState,
                NULL
                );
            
    BAIL_ON_WIN32_ERROR(dwError);

    (*ppSpdPolicyStateContainer)->pSpdPolicyStates = pSpdPolicyState;
    (*ppSpdPolicyStateContainer)->dwNumPolicyStates = 1;
    SPDRevertToSelf(bImpersonating);
    return (dwError);

error:

   (*ppSpdPolicyStateContainer)->pSpdPolicyStates = NULL;
   (*ppSpdPolicyStateContainer)->dwNumPolicyStates = 0;
    SPDRevertToSelf(bImpersonating);
    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\tnfilter.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    tnfilter.h

Abstract:

    This module contains all of the code prototypes to
    drive the tunnel filter list management of
    IPSecSPD Service.

Author:


Environment: User Mode


Revision History:


--*/


typedef struct _initnfilter {
    IP_PROTOCOL_VERSION IpVersion;
    GUID gFilterID;
    LPWSTR pszFilterName;
    IF_TYPE InterfaceType;
    BOOL bCreateMirror;
    DWORD dwFlags;
    ADDR_V4 SrcAddr;
    ADDR_V4 DesAddr;
    ADDR_V4 SrcTunnelAddr;
    ADDR_V4 DesTunnelAddr;
    PROTOCOL Protocol;
    PORT SrcPort;
    PORT DesPort;
    FILTER_ACTION InboundFilterAction;
    FILTER_ACTION OutboundFilterAction;
    DWORD cRef;
    DWORD dwSource;
    BOOL bPendingDeletion;
    GUID gPolicyID;
    PINIQMPOLICY pIniQMPolicy;
    DWORD dwNumTnSFilters;
    struct _initnsfilter ** ppIniTnSFilters;
    struct _initnfilter * pNext;
} INITNFILTER, * PINITNFILTER;


typedef struct _initnsfilter {
    IP_PROTOCOL_VERSION IpVersion;
    GUID gParentID;
    LPWSTR pszFilterName;
    IF_TYPE InterfaceType;
    DWORD dwFlags;
    ADDR_V4 SrcAddr;
    ADDR_V4 DesAddr;
    ADDR_V4 SrcTunnelAddr;
    ADDR_V4 DesTunnelAddr;
    PROTOCOL Protocol;
    PORT SrcPort;
    PORT DesPort;
    FILTER_ACTION InboundFilterAction;
    FILTER_ACTION OutboundFilterAction;
    DWORD cRef;
    DWORD dwDirection;
    DWORD dwWeight;
    GUID gPolicyID;
    PINIQMPOLICY pIniQMPolicy;
    struct _initnsfilter * pNext;
} INITNSFILTER, * PINITNSFILTER;


typedef struct _tn_filter_handle {
    IP_PROTOCOL_VERSION IpVersion;
    PINITNFILTER pIniTnFilter;
    GUID gFilterID;
    struct _tn_filter_handle * pNext;
} TN_FILTER_HANDLE, * PTN_FILTER_HANDLE;

DWORD
AddTunnelFilterInternal(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    DWORD dwSource,
    PTUNNEL_FILTER pTunnelFilter,
    LPVOID pvReserved,
    PHANDLE phTnFilter
    );

DWORD
ValidateTunnelFilter(
    PTUNNEL_FILTER pTnFilter
    );

PINITNFILTER
FindTnFilterByGuid(
    PTN_FILTER_HANDLE pTnFilterHandleList,
    PINITNFILTER pIniTnFilterList,
    GUID gFilterID
    );
  
PINITNFILTER
FindTnFilter(
    PINITNFILTER pGenericTnList,
    PTUNNEL_FILTER pTnFilter
    );

BOOL
EqualTnFilterPKeys(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER pTnFilter
    );

DWORD
CreateIniTnFilter(
    PTUNNEL_FILTER pTnFilter,
    PINIQMPOLICY pIniQMPolicy,
    PINITNFILTER * ppIniTnFilter
    );

DWORD
CreateIniTnSFilters(
    PINITNFILTER pIniTnFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PSPECIAL_ADDR pSpecialAddrsList,
    PINITNSFILTER * ppIniTnSFilters
    );

DWORD
CreateIniMirroredTnFilter(
    PINITNFILTER pFilter,
    PINITNFILTER * ppMirroredFilter
    );

BOOL
EqualIniTnFilterPKeys(
    PINITNFILTER pIniTnFilter,
    PINITNFILTER pFilter
    );

DWORD
CreateTnFilterHandle(
    PINITNFILTER pIniTnFilter,
    GUID gFilterID,
    PTN_FILTER_HANDLE * ppTnFilterHandle
    );

DWORD
CreateSpecificTnFilterLinks(
    PINITNFILTER pIniTnFilter,
    PINITNSFILTER pIniTnSFilters
    );

VOID
LinkTnFilter(
    PINIQMPOLICY pIniQMPolicy,
    PINITNFILTER pIniTnFilter
    );

VOID
FreeIniTnFilterList(
    PINITNFILTER pIniTnFilterList
    );

VOID
FreeIniTnFilter(
    PINITNFILTER pIniTnFilter
    );

DWORD
DeleteIniTnFilter(
    PINITNFILTER pIniTnFilter
    );

VOID
DelinkTnFilter(
    PINIQMPOLICY pIniQMPolicy,
    PINITNFILTER pIniTnFilter
    );

DWORD
DeleteIniTnSFilters(
    PINITNFILTER pIniTnFilter
    );

VOID
RemoveIniTnFilter(
    PINITNFILTER pIniTnFilter
    );

VOID
RemoveTnFilterHandle(
    PTN_FILTER_HANDLE pTnFilterHandle
    );

VOID
FreeTnFilterHandleList(
    PTN_FILTER_HANDLE pTnFilterHandleList
    );

VOID
FreeTnFilterHandle(
    PTN_FILTER_HANDLE pTnFilterHandle
    );

DWORD
EnumGenericTnFilters(
    PINITNFILTER pIniTnFilterList,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PTUNNEL_FILTER * ppTnFilters,
    PDWORD pdwNumTnFilters
    );

DWORD
CopyTnFilter(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER pTnFilter
    );

VOID
FreeTnFilters(
    DWORD dwNumTnFilters,
    PTUNNEL_FILTER pTnFilters
    );

DWORD
SetIniTnFilter(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER pTnFilter
    );

BOOL
EqualTnFilterNonPKeys(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER pTnFilter
    );

DWORD
CreateTnSFilterLinks(
    PINITNSFILTER pIniTnSFilters,
    PDWORD pdwNumTnSFilters,
    PINITNSFILTER ** pppIniTnSFilters
    );

VOID
RemoveTnSFilters(
    PINITNFILTER pIniTnFilter,
    PINITNSFILTER * ppIniCurTnSFilters 
    );

VOID
UpdateTnSFilterLinks(
    PINITNFILTER pIniTnFilter,
    DWORD dwNumTnSFilters,
    PINITNSFILTER * ppIniTnSFilters
    );

VOID
UpdateTnFilterNonPKeys(
    PINITNFILTER pIniTnFilter,
    LPWSTR pszFilterName,
    PTUNNEL_FILTER pTnFilter,
    PINIQMPOLICY pIniQMPolicy
    );

DWORD
GetIniTnFilter(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER * ppTnFilter
    );

DWORD
ApplyIfChangeToIniTnFilters(
    PDWORD pdwTnError,
    PIPSEC_INTERFACE pLatestIfList,
    PSPECIAL_ADDR    pLatestSpecialAddrsList    
    );

DWORD
UpdateIniTnFilterThruIfChange(
    PINITNFILTER pIniTnFilter,
    PIPSEC_INTERFACE pLatestIfList,
    PSPECIAL_ADDR    pLatestSpecialAddrsList    
    );

DWORD
FormIniTnSFilters(
    PINITNFILTER pIniTnFilter,
    PIPSEC_INTERFACE pIfList,
    PSPECIAL_ADDR  pLatestSpecialAddrsList,    
    PINITNSFILTER * ppIniTnSFilters
    );

VOID
ProcessIniTnSFilters(
    PINITNSFILTER * ppLatestIniTnSFilters,
    PINITNSFILTER * ppCurIniTnSFilters,
    PINITNSFILTER * ppNewIniTnSFilters,
    PINITNSFILTER * ppOldIniTnSFilters
    );

BOOL
EqualIniTnSFilterIfPKeys(
    PINITNSFILTER pExsIniTnSFilter,
    PINITNSFILTER pNewIniTnSFilter
    );

DWORD
AllocateTnSFilterLinks(
    PINITNSFILTER pIniTnSFilters,
    PDWORD pdwNumTnSFilters,
    PINITNSFILTER ** pppIniTnSFilters
    );

VOID
SetTnSFilterLinks(
    PINITNSFILTER pCurIniTnSFilters,
    PINITNSFILTER pNewIniTnSFilters,
    DWORD dwNumTnSFilters,
    PINITNSFILTER * ppIniTnSFilters
    );

VOID
AddToGenericTnList(
    PINITNFILTER pIniTnFilter
    );

PINITNFILTER
FindExactTnFilter(
    PINITNFILTER pGenericTnList,
    PTUNNEL_FILTER pTnFilter
    );

BOOL
EqualMirroredTnFilterPKeys(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER pTnFilter
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\structs.h ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    structs.h

Abstract:

    This module contains all of the internal structures
    for IPSecSPD Service.

Author:

    abhisheV    30-September-1999

Environment

    User Level: Win32

Revision History:


--*/


#ifdef __cplusplus
extern "C" {
#endif


#define TCP_PROTOCOL     6

#define UDP_PROTOCOL    17


#define WEIGHT_ADDRESS_TIE_BREAKER          0x00000001
#define WEIGHT_SPECIFIC_SOURCE_PORT         0x00000002
#define WEIGHT_SPECIFIC_DESTINATION_PORT    0x00000004
#define WEIGHT_SPECIFIC_PROTOCOL            0x00000100

#define WEIGHT_TUNNEL_FILTER                0x00001000
#define WEIGHT_SPECIFIC_TUNNEL_FILTER       0x00002000


typedef struct _IPSEC_INTERFACE {

    DWORD dwInterfaceType;
    ULONG IpAddress;
    DWORD dwIndex;
    BOOL bIsASuspect;
    GUID gInterfaceID;
    LPWSTR pszInterfaceName;
    LPWSTR pszDeviceName;
    struct _IPSEC_INTERFACE * pNext;

} IPSEC_INTERFACE, * PIPSEC_INTERFACE;


typedef struct _matching_addr {
    ULONG uIpAddr;
    GUID gInterfaceID;
} MATCHING_ADDR, * PMATCHING_ADDR;

typedef struct _SPECIAL_ADDR {
    ADDR_TYPE AddrType;
    ULONG uIpAddr;
    IF_TYPE InterfaceType;
    BOOL bDupInterface;
    struct _SPECIAL_ADDR * pNext;
} SPECIAL_ADDR, * PSPECIAL_ADDR;

typedef struct _ADDR_V4 {
    ADDR_TYPE AddrType;
    ULONG uIpAddr;
    ULONG uSubNetMask;
    GUID gInterfaceID;
} ADDR_V4, * PADDR_V4;


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\tnspecific.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    tnspecific.c

Abstract:

    This module contains all of the code to drive the
    specific tunnel filter list management of IPSecSPD
    Service.

Author:

    abhisheV    29-October-1999

Environment

    User Level: Win32

Revision History:


--*/


#include "precomp.h"


DWORD
ApplyTnTransform(
    PINITNFILTER pFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PSPECIAL_ADDR pSpecialAddrsList,
    PINITNSFILTER * ppSpecificFilters
    )
/*++

Routine Description:

    This function expands a generic tunnel filter into its
    corresponding specific filters.

Arguments:

    pFilter - Generic filter to expand.

    pMatchingAddresses - List of local ip addresses whose interface
                         type matches that of the filter.

    dwAddrCnt - Number of local ip addresses in the list.

    ppSpecificFilters - List of specific filters expanded for the
                        given generic filter.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITNSFILTER pSpecificFilters = NULL;
    PINITNSFILTER pOutboundSpecificFilters = NULL;
    PINITNSFILTER pInboundSpecificFilters = NULL;

    PADDR_V4 pSrcAddrList = NULL;
    DWORD dwSrcAddrCnt = 0;
    PADDR_V4 pDesAddrList = NULL;
    DWORD dwDesAddrCnt = 0;

    PADDR_V4 pOutDesTunAddrList = NULL;
    DWORD dwOutDesTunAddrCnt = 0;
    PADDR_V4 pInDesTunAddrList = NULL;
    DWORD dwInDesTunAddrCnt = 0;


    //
    // Replace wild card information to generate the new source
    // address list.
    //

    dwError = FormAddressList(
                  pFilter->SrcAddr,
                  pMatchingAddresses,
                  dwAddrCnt,
                  pSpecialAddrsList,
                  pFilter->InterfaceType,                  
                  &pSrcAddrList,
                  &dwSrcAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Replace wild card information to generate the new destination
    // address list.
    //

    dwError = FormAddressList(
                  pFilter->DesAddr,
                  pMatchingAddresses,
                  dwAddrCnt,
                  pSpecialAddrsList,
                  pFilter->InterfaceType,
                  &pDesAddrList,
                  &dwDesAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    // 
    // Form the outbound and inbound destination tunnel address lists.
    // 

    dwError = FormTnOutboundInboundAddresses(
                  pFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  pSpecialAddrsList,
                  &pOutDesTunAddrList,
                  &dwOutDesTunAddrCnt,
                  &pInDesTunAddrList,
                  &dwInDesTunAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    //
    // Form outbound specific filters.
    //

    dwError = FormSpecificTnFilters(
                  pFilter,
                  pSrcAddrList,
                  dwSrcAddrCnt,
                  pDesAddrList,
                  dwDesAddrCnt,
                  pOutDesTunAddrList,
                  dwOutDesTunAddrCnt,
                  FILTER_DIRECTION_OUTBOUND,
                  &pOutboundSpecificFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    //
    // Form inbound specific filters.
    //

    dwError = FormSpecificTnFilters(
                  pFilter,
                  pSrcAddrList,
                  dwSrcAddrCnt,
                  pDesAddrList,
                  dwDesAddrCnt,
                  pInDesTunAddrList,
                  dwInDesTunAddrCnt,
                  FILTER_DIRECTION_INBOUND,
                  &pInboundSpecificFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);


    pSpecificFilters = pOutboundSpecificFilters;

    AddToSpecificTnList(
        &pSpecificFilters,
        pInboundSpecificFilters
        );


    *ppSpecificFilters = pSpecificFilters;

cleanup:

    if (pSrcAddrList) {
        FreeSPDMemory(pSrcAddrList);
    }

    if (pDesAddrList) {
        FreeSPDMemory(pDesAddrList);
    }

    if (pOutDesTunAddrList) {
        FreeSPDMemory(pOutDesTunAddrList);
    }

    if (pInDesTunAddrList) {
        FreeSPDMemory(pInDesTunAddrList);
    }

    return (dwError);

error:

    if (pOutboundSpecificFilters) {
        FreeIniTnSFilterList(pOutboundSpecificFilters);
    }

    if (pInboundSpecificFilters) {
        FreeIniTnSFilterList(pInboundSpecificFilters);
    }


    *ppSpecificFilters = NULL;
    goto cleanup;
}


DWORD
FormTnOutboundInboundAddresses(
    PINITNFILTER pFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PSPECIAL_ADDR pSpecialAddrsList,
    PADDR_V4 * ppOutDesTunAddrList,
    PDWORD pdwOutDesTunAddrCnt,
    PADDR_V4 * ppInDesTunAddrList,
    PDWORD pdwInDesTunAddrCnt
    )
/*++

Routine Description:

    This function forms the outbound and inbound
    destination  tunnel address sets for a generic filter.

Arguments:

    pFilter - Generic filter under consideration.

    pMatchingAddresses - List of local ip addresses whose interface
                         type matches that of the filter.

    dwAddrCnt - Number of local ip addresses in the list.

    ppOutDesTunAddrList - List of outbound destination tunnel addresses.

    pdwOutDesTunAddrCnt - Number of addresses in the outbound
                          destination tunnel address list.

    ppInDesTunAddrList - List of inbound destination tunnel addresses.

    pdwInDesTunAddrCnt - Number of addresses in the inbound
                         destination tunnel address list.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;

    PADDR_V4 pDesTunAddrList = NULL;
    DWORD dwDesTunAddrCnt = 0;

    PADDR_V4 pOutDesTunAddrList = NULL;
    DWORD dwOutDesTunAddrCnt = 0;
    PADDR_V4 pInDesTunAddrList = NULL;
    DWORD dwInDesTunAddrCnt = 0;


    //
    // Replace wild card information to generate the new destination
    // tunnel address list.
    //

    dwError = FormAddressList(
                  pFilter->DesTunnelAddr,
                  pMatchingAddresses,
                  dwAddrCnt,
                  pSpecialAddrsList,
                  pFilter->InterfaceType,
                  &pDesTunAddrList,
                  &dwDesTunAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Separate the destination tunnel address list into outbound
    // and inbound destination tunnel address sets based on the local 
    // machine's ip addresses.
    //

    dwError = SeparateAddrList(
                  pFilter->DesTunnelAddr.AddrType,
                  pDesTunAddrList,
                  dwDesTunAddrCnt,
                  pMatchingAddresses,
                  dwAddrCnt,
                  &pInDesTunAddrList,
                  &dwInDesTunAddrCnt,
                  &pOutDesTunAddrList,
                  &dwOutDesTunAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppOutDesTunAddrList = pOutDesTunAddrList;
    *pdwOutDesTunAddrCnt = dwOutDesTunAddrCnt;
    *ppInDesTunAddrList = pInDesTunAddrList;
    *pdwInDesTunAddrCnt = dwInDesTunAddrCnt;

cleanup:

    if (pDesTunAddrList) {
        FreeSPDMemory(pDesTunAddrList);
    }

    return (dwError);

error:

    if (pOutDesTunAddrList) {
        FreeSPDMemory(pOutDesTunAddrList);
    }

    if (pInDesTunAddrList) {
        FreeSPDMemory(pInDesTunAddrList);
    }

    *ppOutDesTunAddrList = NULL;
    *pdwOutDesTunAddrCnt = 0;
    *ppInDesTunAddrList = NULL;
    *pdwInDesTunAddrCnt = 0;

    goto cleanup;
}

    
DWORD
FormSpecificTnFilters(
    PINITNFILTER pFilter,
    PADDR_V4 pSrcAddrList,
    DWORD dwSrcAddrCnt,
    PADDR_V4 pDesAddrList,
    DWORD dwDesAddrCnt,
    PADDR_V4 pDesTunAddrList,
    DWORD dwDesTunAddrCnt,
    DWORD dwDirection,
    PINITNSFILTER * ppSpecificFilters
    )
/*++

Routine Description:

    This function forms the specific tunnel filters
    for the given generic filter and the source and 
    destination address sets.

Arguments:

    pFilter - Generic filter for which specific filters
              are to be created.

    pSrcAddrList - List of source addresses.

    dwSrcAddrCnt - Number of addresses in the source
                   address list.

    pDesAddrList - List of destination addresses.

    dwDesAddrCnt - Number of addresses in the destination
                   address list.

    pDesTunAddrList - List of destination tunnel addresses.

    dwDesTunAddrCnt - Number of addresses in the destination
                      tunnel address list.

    dwDirection - direction of the resulting specific filters.

    ppSpecificFilters - Specific filters created for the given
                        generic filter and the given addresses.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITNSFILTER pSpecificFilters = NULL;
    DWORD i = 0, j = 0, k = 0;
    PINITNSFILTER pSpecificFilter = NULL;


    for (k = 0; k < dwDesTunAddrCnt; k++) {

        for (i = 0; i < dwSrcAddrCnt; i++) {

            for (j = 0; j < dwDesAddrCnt; j++) {

                dwError = CreateSpecificTnFilter(
                               pFilter,
                               pSrcAddrList[i],
                               pDesAddrList[j],
                               pDesTunAddrList[k],
                               &pSpecificFilter
                               );
                BAIL_ON_WIN32_ERROR(dwError);

                //
                // Set the direction of the filter.
                //

                pSpecificFilter->dwDirection = dwDirection;

                AssignTnFilterWeight(pSpecificFilter);

                AddToSpecificTnList(
                    &pSpecificFilters,
                    pSpecificFilter
                    );

            }

        }

    }

    *ppSpecificFilters = pSpecificFilters;
    return (dwError);

error:

    if (pSpecificFilters) {
        FreeIniTnSFilterList(pSpecificFilters);
    }

    *ppSpecificFilters = NULL;
    return (dwError);
}


DWORD
CreateSpecificTnFilter(
    PINITNFILTER pGenericFilter,
    ADDR_V4 SrcAddr,
    ADDR_V4 DesAddr,
    ADDR_V4 DesTunnelAddr,
    PINITNSFILTER * ppSpecificFilter
    )
{
    DWORD dwError = 0; 
    PINITNSFILTER pSpecificFilter = NULL;


    dwError = AllocateSPDMemory(
                    sizeof(INITNSFILTER),
                    &pSpecificFilter
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pSpecificFilter->cRef = 0;

    pSpecificFilter->IpVersion = pGenericFilter->IpVersion;

    CopyGuid(pGenericFilter->gFilterID, &(pSpecificFilter->gParentID));

    dwError = AllocateSPDString(
                  pGenericFilter->pszFilterName,
                  &(pSpecificFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pSpecificFilter->InterfaceType = pGenericFilter->InterfaceType;

    pSpecificFilter->dwFlags = pGenericFilter->dwFlags;

    CopyAddresses(SrcAddr, &(pSpecificFilter->SrcAddr));

    CopyAddresses(DesAddr, &(pSpecificFilter->DesAddr));

    CopyAddresses(
        pGenericFilter->SrcTunnelAddr, 
        &(pSpecificFilter->SrcTunnelAddr)
        );

    CopyAddresses(DesTunnelAddr, &(pSpecificFilter->DesTunnelAddr));

    CopyPorts(pGenericFilter->SrcPort, &(pSpecificFilter->SrcPort));

    CopyPorts(pGenericFilter->DesPort, &(pSpecificFilter->DesPort));

    CopyProtocols(pGenericFilter->Protocol, &(pSpecificFilter->Protocol));

    pSpecificFilter->InboundFilterAction = pGenericFilter->InboundFilterAction;

    pSpecificFilter->OutboundFilterAction = pGenericFilter->OutboundFilterAction;

    //
    // Direction must be set in the calling routine.
    //

    pSpecificFilter->dwDirection = 0;

    //
    // Weight must be set in the calling routine.
    //

    pSpecificFilter->dwWeight = 0;

    CopyGuid(pGenericFilter->gPolicyID, &(pSpecificFilter->gPolicyID));

    pSpecificFilter->pIniQMPolicy = NULL;

    pSpecificFilter->pNext = NULL;

    *ppSpecificFilter = pSpecificFilter;
    return (dwError);

error:

    if (pSpecificFilter) {
        FreeIniTnSFilter(pSpecificFilter);
    }

    *ppSpecificFilter = NULL;
    return (dwError);
}


VOID
AssignTnFilterWeight(
    PINITNSFILTER pSpecificFilter
    )
/*++

Routine Description:

    Computes and assigns the weight to a specific tunnel filter.

    The tunnel filter weight consists of the following:

    31         16          12           8        0
    +-----------+-----------+-----------+--------+
    |AddrMaskWgt| TunnelWgt |ProtocolWgt|PortWgts|
    +-----------+-----------+-----------+--------+

Arguments:

    pSpecificFilter - Specific tunnel filter to which the weight 
                      is to be assigned.

Return Value:

    None.

--*/
{
    DWORD dwWeight = 0;
    ULONG SrcMask = 0;
    ULONG DesMask = 0;
    DWORD dwSrcMaskWeight = 0;
    DWORD dwDesMaskWeight = 0;
    DWORD dwMaskWeight = 0;
    DWORD i = 0;


    //
    // Weight Rule:
    // A field with a more specific value gets a higher weight than
    // the same field with a lesser specific value.
    //

    //
    // If the protocol is specific then assign the specific protocol
    // weight else the weight is zero.
    // All the specific filters that have a specific protocol and
    // differ only in the protocol field will have the same weight.
    //

    if (pSpecificFilter->Protocol.dwProtocol != 0) {
        dwWeight |= WEIGHT_SPECIFIC_PROTOCOL;
    }

    //
    // If the source port is specific then assign the specific source
    // port weight else the weight is zero.
    // All the specific filters that have a specific source port and 
    // differ only in the source port field will have the same weight.
    //

    if (pSpecificFilter->SrcPort.wPort != 0) {
        dwWeight |= WEIGHT_SPECIFIC_SOURCE_PORT;
    }

    //
    // If the destination port is specific then assign the specific
    // destination port weight else the weight is zero. 
    // All the specific filters that have a specific destination port
    // and differ only in the destination port field will have the
    // same weight.
    //

    if (pSpecificFilter->DesPort.wPort != 0) {
        dwWeight |= WEIGHT_SPECIFIC_DESTINATION_PORT;
    }

    dwWeight |= WEIGHT_TUNNEL_FILTER;

    if (pSpecificFilter->DesTunnelAddr.uIpAddr != SUBNET_ADDRESS_ANY) {
        dwWeight |= WEIGHT_SPECIFIC_TUNNEL_FILTER;
    }

    //
    // IP addresses get the weight values based on their mask values.
    // In the address case, the weight is computed as a sum of the 
    // bit positions starting from the position that contains the 
    // first least significant non-zero bit to the most significant
    // bit position of the mask. 
    // All unique ip addresses have a mask of 0xFFFFFFFF and thus get
    // the same weight, which is 1 + 2 + .... + 32.
    // A subnet address has a mask with atleast the least significant
    // bit zero and thus gets weight in the range (2 + .. + 32) to 0.
    //
  
    DesMask = ntohl(pSpecificFilter->DesAddr.uSubNetMask);

    for (i = 0; i < sizeof(ULONG) * 8; i++) {

         //
         // If the bit position contains a non-zero bit, add the bit
         // position to the sum.
         //

         if ((DesMask & 0x1) == 0x1) {
             dwMaskWeight += (i+1);
             dwDesMaskWeight += (i+1);
         }

         //
         // Move to the next bit position.
         //

         DesMask = DesMask >> 1;

    }


    SrcMask = ntohl(pSpecificFilter->SrcAddr.uSubNetMask);

    for (i = 0; i < sizeof(ULONG) * 8; i++) {

         //
         // If the bit position contains a non-zero bit, add the bit
         // position to the sum.
         //

         if ((SrcMask & 0x1) == 0x1) {
             dwMaskWeight += (i+1);
             dwSrcMaskWeight += (i+1);
         }

         //
         // Move to the next bit position.
         //

         SrcMask = SrcMask >> 1;

    }

    if (dwDesMaskWeight >= dwSrcMaskWeight) {
        dwWeight |= WEIGHT_ADDRESS_TIE_BREAKER;
    }

    //
    // Move the mask weight to the set of bits in the overall weight
    // that it occupies.
    //

    dwMaskWeight = dwMaskWeight << 16;

    dwWeight += dwMaskWeight;

    pSpecificFilter->dwWeight = dwWeight;
}


VOID
AddToSpecificTnList(
    PINITNSFILTER * ppSpecificTnFilterList,
    PINITNSFILTER pSpecificTnFilters
    )
{
    PINITNSFILTER pListOne = NULL;
    PINITNSFILTER pListTwo = NULL;
    PINITNSFILTER pListMerge = NULL;
    PINITNSFILTER pLast = NULL;

    if (!(*ppSpecificTnFilterList) && !pSpecificTnFilters) {
        return;
    }

    if (!(*ppSpecificTnFilterList)) {
        *ppSpecificTnFilterList = pSpecificTnFilters;
        return;
    }

    if (!pSpecificTnFilters) {
        return;
    }

    pListOne = *ppSpecificTnFilterList;
    pListTwo = pSpecificTnFilters;

    while (pListOne && pListTwo) {

        if ((pListOne->dwWeight) > (pListTwo->dwWeight)) {

            if (!pListMerge) {
                pListMerge = pListOne;
                pLast = pListOne;
                pListOne = pListOne->pNext;
            }
            else {
                pLast->pNext = pListOne;
                pListOne = pListOne->pNext;
                pLast = pLast->pNext;
            }

        }
        else {

            if (!pListMerge) {
                pListMerge = pListTwo;
                pLast = pListTwo;
                pListTwo = pListTwo->pNext;
            }
            else {
                pLast->pNext = pListTwo;
                pListTwo = pListTwo->pNext;
                pLast = pLast->pNext;
            }

        }

    }
    
    if (pListMerge) {
        if (pListOne) {
            pLast->pNext = pListOne;
        }
        else {
            pLast->pNext = pListTwo;
        }
    }

    *ppSpecificTnFilterList = pListMerge;
    return;
}


VOID
FreeIniTnSFilterList(
    PINITNSFILTER pIniTnSFilterList
    )
{
    PINITNSFILTER pFilter = NULL;
    PINITNSFILTER pTempFilter = NULL;

    pFilter = pIniTnSFilterList;

    while (pFilter) {
        pTempFilter = pFilter;
        pFilter = pFilter->pNext;
        FreeIniTnSFilter(pTempFilter);
    }
}


VOID
FreeIniTnSFilter(
    PINITNSFILTER pIniTnSFilter
    )
{
    if (pIniTnSFilter) {
        if (pIniTnSFilter->pszFilterName) {
            FreeSPDString(pIniTnSFilter->pszFilterName);
        }

        //
        // Must not ever free pIniTnSFilter->pIniQMPolicy.
        //

        FreeSPDMemory(pIniTnSFilter);
    }
}


VOID
LinkTnSpecificFilters(
    PINIQMPOLICY pIniQMPolicy,
    PINITNSFILTER pIniTnSFilters
    )
{
    PINITNSFILTER pTemp = NULL;

    pTemp = pIniTnSFilters;

    while (pTemp) {
        pTemp->pIniQMPolicy = pIniQMPolicy;
        pTemp = pTemp->pNext;
    }

    return;
}


VOID
RemoveIniTnSFilter(
    PINITNSFILTER pIniTnSFilter
    )
{
    PINITNSFILTER * ppTemp = NULL;

    ppTemp = &gpIniTnSFilter;

    while (*ppTemp) {

        if (*ppTemp == pIniTnSFilter) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);
    }

    if (*ppTemp) {
        *ppTemp = pIniTnSFilter->pNext;
    }

    return;
}


DWORD
EnumSpecificTnFilters(
    PINITNSFILTER pIniTnSFilterList,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PTUNNEL_FILTER * ppTnFilters,
    PDWORD pdwNumTnFilters
    )
/*++

Routine Description:

    This function creates enumerated specific filters.

Arguments:

    pIniTnSFilterList - List of specific filters to enumerate.

    dwResumeHandle - Location in the specific filter list from which
                     to resume enumeration.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    ppTnFilters - Enumerated filters returned to the caller.

    pdwNumTnFilters - Number of filters actually enumerated.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwNumToEnum = 0;
    PINITNSFILTER pIniTnSFilter = NULL;
    DWORD i = 0;
    PINITNSFILTER pTemp = NULL;
    DWORD dwNumTnFilters = 0;
    PTUNNEL_FILTER pTnFilters = 0;
    PTUNNEL_FILTER pTnFilter = 0;


    if (!dwPreferredNumEntries || 
        (dwPreferredNumEntries > MAX_TUNNELFILTER_ENUM_COUNT)) {
        dwNumToEnum = MAX_TUNNELFILTER_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    pIniTnSFilter = pIniTnSFilterList;

    for (i = 0; (i < dwResumeHandle) && (pIniTnSFilter != NULL); i++) {
        pIniTnSFilter = pIniTnSFilter->pNext;
    }

    if (!pIniTnSFilter) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTemp = pIniTnSFilter;

    while (pTemp && (dwNumTnFilters < dwNumToEnum)) {
        dwNumTnFilters++;
        pTemp = pTemp->pNext;
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(TUNNEL_FILTER)*dwNumTnFilters,
                  &pTnFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pIniTnSFilter;
    pTnFilter = pTnFilters;

    for (i = 0; i < dwNumTnFilters; i++) {

        dwError = CopyTnSFilter(
                      pTemp,
                      pTnFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        pTemp = pTemp->pNext;
        pTnFilter++;

    }

    *ppTnFilters = pTnFilters;
    *pdwNumTnFilters = dwNumTnFilters;
    return (dwError);

error:

    if (pTnFilters) {
        FreeTnFilters(
            i,
            pTnFilters
            );
    }

    *ppTnFilters = NULL;
    *pdwNumTnFilters = 0;

    return (dwError);
}


DWORD
CopyTnSFilter(
    PINITNSFILTER pIniTnSFilter,
    PTUNNEL_FILTER pTnFilter
    )
/*++

Routine Description:

    This function copies an internal filter into an external filter
    container.

Arguments:

    pIniTnSFilter - Internal filter to copy.

    pTnFilter - External filter container in which to copy.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;


    pTnFilter->IpVersion = pIniTnSFilter->IpVersion;

    CopyGuid(pIniTnSFilter->gParentID, &(pTnFilter->gFilterID));

    dwError = CopyName(
                  pIniTnSFilter->pszFilterName,
                  &(pTnFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTnFilter->InterfaceType = pIniTnSFilter->InterfaceType;

    pTnFilter->bCreateMirror = FALSE;

    pTnFilter->dwFlags = pIniTnSFilter->dwFlags;

    dwError = CopyIntToExtAddresses(pIniTnSFilter->SrcAddr, &(pTnFilter->SrcAddr));
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyIntToExtAddresses(pIniTnSFilter->DesAddr, &(pTnFilter->DesAddr));
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyIntToExtAddresses(
                  pIniTnSFilter->SrcTunnelAddr,
                  &(pTnFilter->SrcTunnelAddr)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyIntToExtAddresses(
                  pIniTnSFilter->DesTunnelAddr,
                  &(pTnFilter->DesTunnelAddr)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    CopyProtocols(pIniTnSFilter->Protocol, &(pTnFilter->Protocol));

    CopyPorts(pIniTnSFilter->SrcPort, &(pTnFilter->SrcPort));

    CopyPorts(pIniTnSFilter->DesPort, &(pTnFilter->DesPort));

    pTnFilter->InboundFilterAction = pIniTnSFilter->InboundFilterAction;

    pTnFilter->OutboundFilterAction = pIniTnSFilter->OutboundFilterAction;

    pTnFilter->dwDirection = pIniTnSFilter->dwDirection;

    pTnFilter->dwWeight = pIniTnSFilter->dwWeight;

    CopyGuid(pIniTnSFilter->gPolicyID, &(pTnFilter->gPolicyID));

    return (dwError);

error:

    if (pTnFilter->pszFilterName) {
        SPDApiBufferFree(pTnFilter->pszFilterName);
        pTnFilter->pszFilterName = NULL;
    }

    if (pTnFilter->SrcAddr.pgInterfaceID) {
        SPDApiBufferFree(pTnFilter->SrcAddr.pgInterfaceID);
        pTnFilter->SrcAddr.pgInterfaceID = NULL;
    }

    if (pTnFilter->DesAddr.pgInterfaceID) {
        SPDApiBufferFree(pTnFilter->DesAddr.pgInterfaceID);
        pTnFilter->DesAddr.pgInterfaceID = NULL;
    }

    if (pTnFilter->SrcTunnelAddr.pgInterfaceID) {
        SPDApiBufferFree(pTnFilter->SrcTunnelAddr.pgInterfaceID);
        pTnFilter->SrcTunnelAddr.pgInterfaceID = NULL;
    }

    if (pTnFilter->DesTunnelAddr.pgInterfaceID) {
        SPDApiBufferFree(pTnFilter->DesTunnelAddr.pgInterfaceID);
        pTnFilter->DesTunnelAddr.pgInterfaceID = NULL;
    }

    return (dwError);
}


DWORD
EnumSelectSpecificTnFilters(
    PINITNFILTER pIniTnFilter,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PTUNNEL_FILTER * ppTnFilters,
    PDWORD pdwNumTnFilters
    )
/*++

Routine Description:

    This function creates enumerated specific filters for
    the given generic filter.

Arguments:

    pIniTnFilter - Generic filter for which specific filters
                   are to be enumerated.

    dwResumeHandle - Location in the specific filter list for the
                     given generic filter from which to resume
                     enumeration.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    ppTnFilters - Enumerated filters returned to the caller.

    pdwNumTnFilters - Number of filters actually enumerated.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwNumToEnum = 0;
    DWORD dwNumTnSFilters = 0; 
    PINITNSFILTER * ppIniTnSFilters = NULL;
    DWORD i = 0;
    DWORD dwNumTnFilters = 0;
    PTUNNEL_FILTER pTnFilters = 0;
    PTUNNEL_FILTER pTnFilter = 0;


    if (!dwPreferredNumEntries || 
        (dwPreferredNumEntries > MAX_TUNNELFILTER_ENUM_COUNT)) {
        dwNumToEnum = MAX_TUNNELFILTER_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    dwNumTnSFilters = pIniTnFilter->dwNumTnSFilters;
    ppIniTnSFilters = pIniTnFilter->ppIniTnSFilters;

    if (!dwNumTnSFilters || (dwNumTnSFilters <= dwResumeHandle)) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwNumTnFilters = min((dwNumTnSFilters-dwResumeHandle),
                         dwNumToEnum);
 
    dwError = SPDApiBufferAllocate(
                  sizeof(TUNNEL_FILTER)*dwNumTnFilters,
                  &pTnFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTnFilter = pTnFilters;

    for (i = 0; i < dwNumTnFilters; i++) {

        dwError = CopyTnSFilter(
                      *(ppIniTnSFilters + (dwResumeHandle + i)),
                      pTnFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);
        pTnFilter++;

    }

    *ppTnFilters = pTnFilters;
    *pdwNumTnFilters = dwNumTnFilters;
    return (dwError);

error:

    if (pTnFilters) {
        FreeTnFilters(
            i,
            pTnFilters
            );
    }

    *ppTnFilters = NULL;
    *pdwNumTnFilters = 0;

    return (dwError);
}


DWORD
MatchTunnelFilter(
    LPWSTR pServerName,
    DWORD dwVersion,
    PTUNNEL_FILTER pTnFilter,
    DWORD dwFlags,
    DWORD dwPreferredNumEntries,
    PTUNNEL_FILTER * ppMatchedTnFilters,
    PIPSEC_QM_POLICY * ppMatchedQMPolicies,
    LPDWORD pdwNumMatches,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function finds the matching tunnel filters for the 
    given tunnel filter template. The matched filters can not
    be more specific than the given filter template.

Arguments:

    pServerName - Server on which a filter template is to be matched.

    pTnFilter - Filter template to match.

    dwFlags - Flags.

    ppMatchedTnFilters - Matched tunnel filters returned to the
                         caller.

    ppMatchedQMPolicies - Quick mode policies corresponding to the 
                          matched tunnel filters returned to the
                          caller.

    dwPreferredNumEntries - Preferred number of matched entries.

    pdwNumMatches - Number of filters actually matched.

    pdwResumeHandle - Handle to the location in the matched filter 
                      list from which to resume enumeration.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwResumeHandle = 0;
    DWORD dwNumToMatch = 0;
    PINITNSFILTER pIniTnSFilter = NULL;
    DWORD i = 0;
    BOOL bMatches = FALSE;
    PINITNSFILTER pTemp = NULL;
    DWORD dwNumMatches = 0;
    PINITNSFILTER pLastMatchedFilter = NULL;
    PTUNNEL_FILTER pMatchedTnFilters = NULL;
    PIPSEC_QM_POLICY pMatchedQMPolicies = NULL;
    DWORD dwNumFilters = 0;
    DWORD dwNumPolicies = 0;
    PTUNNEL_FILTER pMatchedTnFilter = NULL;
    PIPSEC_QM_POLICY pMatchedQMPolicy = NULL;


    dwError = ValidateTnFilterTemplate(
                  pTnFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwResumeHandle = *pdwResumeHandle;

    if (!dwPreferredNumEntries) {
        dwNumToMatch = 1;
    }
    else if (dwPreferredNumEntries > MAX_TUNNELFILTER_ENUM_COUNT) {
        dwNumToMatch = MAX_TUNNELFILTER_ENUM_COUNT;
    }
    else {
        dwNumToMatch = dwPreferredNumEntries;
    }

    ENTER_SPD_SECTION();

    dwError = ValidateTnSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniTnSFilter = gpIniTnSFilter;

    while ((i < dwResumeHandle) && (pIniTnSFilter != NULL)) {
        bMatches = MatchIniTnSFilter(
                       pIniTnSFilter,
                       pTnFilter
                       );
        if (bMatches) {
            i++;
        }
        pIniTnSFilter = pIniTnSFilter->pNext;
    }

    if (!pIniTnSFilter) {
        if (!(dwFlags & RETURN_DEFAULTS_ON_NO_MATCH)) {
            dwError = ERROR_NO_DATA;
            BAIL_ON_LOCK_ERROR(dwError);
        }
        else {
            dwError = CopyTnMatchDefaults(
                          dwFlags,
                          &pMatchedTnFilters,
                          &pMatchedQMPolicies,
                          &dwNumMatches
                          );
            BAIL_ON_LOCK_ERROR(dwError);
            BAIL_ON_LOCK_SUCCESS(dwError);
        }
    }

    pTemp = pIniTnSFilter;

    while (pTemp && (dwNumMatches < dwNumToMatch)) {
        bMatches = MatchIniTnSFilter(
                       pTemp,
                       pTnFilter
                       );
        if (bMatches) {
            pLastMatchedFilter = pTemp;
            dwNumMatches++;
        }
        pTemp = pTemp->pNext;
    }

    if (!dwNumMatches) {
        if (!(dwFlags & RETURN_DEFAULTS_ON_NO_MATCH)) {
            dwError = ERROR_NO_DATA;
            BAIL_ON_LOCK_ERROR(dwError);
        }
        else {
            dwError = CopyTnMatchDefaults(
                          dwFlags,
                          &pMatchedTnFilters,
                          &pMatchedQMPolicies,
                          &dwNumMatches
                          );
            BAIL_ON_LOCK_ERROR(dwError);
            BAIL_ON_LOCK_SUCCESS(dwError);
        }
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(TUNNEL_FILTER)*dwNumMatches,
                  &pMatchedTnFilters
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_QM_POLICY)*dwNumMatches,
                  &pMatchedQMPolicies
                  );
    BAIL_ON_LOCK_ERROR(dwError);


    if (dwNumMatches == 1) {

        dwError = CopyTnSFilter(
                      pLastMatchedFilter,
                      pMatchedTnFilters
                      );
        BAIL_ON_LOCK_ERROR(dwError);
        dwNumFilters++;

        if (pLastMatchedFilter->pIniQMPolicy) {
            dwError = CopyQMPolicy(
                          dwFlags,
                          pLastMatchedFilter->pIniQMPolicy,
                          pMatchedQMPolicies
                          );
            BAIL_ON_LOCK_ERROR(dwError);
        }
        else {
            memset(pMatchedQMPolicies, 0, sizeof(IPSEC_QM_POLICY));
        }
        dwNumPolicies++;

    }
    else {

        pTemp = pIniTnSFilter;
        pMatchedTnFilter = pMatchedTnFilters;
        pMatchedQMPolicy = pMatchedQMPolicies;
        i = 0;

        while (i < dwNumMatches) {

            bMatches = MatchIniTnSFilter(
                           pTemp,
                           pTnFilter
                           );
            if (bMatches) {

                dwError = CopyTnSFilter(
                              pTemp,
                              pMatchedTnFilter
                              );
                BAIL_ON_LOCK_ERROR(dwError);
                pMatchedTnFilter++;
                dwNumFilters++;

                if (pTemp->pIniQMPolicy) {
                    dwError = CopyQMPolicy(
                                  dwFlags,
                                  pTemp->pIniQMPolicy,
                                  pMatchedQMPolicy
                                  );
                    BAIL_ON_LOCK_ERROR(dwError);
                }
                else {
                    memset(pMatchedQMPolicy, 0, sizeof(IPSEC_QM_POLICY));
                }
                pMatchedQMPolicy++;
                dwNumPolicies++;

                i++;

            }

            pTemp = pTemp->pNext;

        }

    }

lock_success:

    LEAVE_SPD_SECTION();

    *ppMatchedTnFilters = pMatchedTnFilters;
    *ppMatchedQMPolicies = pMatchedQMPolicies;
    *pdwNumMatches = dwNumMatches;
    *pdwResumeHandle = dwResumeHandle + dwNumMatches;

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    if (pMatchedTnFilters) {
        FreeTnFilters(
            dwNumFilters,
            pMatchedTnFilters
            );
    }

    if (pMatchedQMPolicies) {
        FreeQMPolicies(
            dwNumPolicies,
            pMatchedQMPolicies
            );
    }

    *ppMatchedTnFilters = NULL;
    *ppMatchedQMPolicies = NULL;
    *pdwNumMatches = 0;
    *pdwResumeHandle = dwResumeHandle;

    return (dwError);
}


DWORD
ValidateTnFilterTemplate(
    PTUNNEL_FILTER pTnFilter
    )
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pTnFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(&(pTnFilter->SrcAddr), TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(&(pTnFilter->DesAddr), TRUE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = AddressesConflict(
                     pTnFilter->SrcAddr,
                     pTnFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateAddr(&(pTnFilter->SrcTunnelAddr));
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(&(pTnFilter->DesTunnelAddr), TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyProtocols(pTnFilter->Protocol);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTnFilter->SrcPort,
                  pTnFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTnFilter->DesPort,
                  pTnFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pTnFilter->dwDirection) {
        if ((pTnFilter->dwDirection != FILTER_DIRECTION_INBOUND) &&
            (pTnFilter->dwDirection != FILTER_DIRECTION_OUTBOUND)) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_WIN32_ERROR(dwError);
        }
    }

error:

    return (dwError);
}


BOOL
MatchIniTnSFilter(
    PINITNSFILTER pIniTnSFilter,
    PTUNNEL_FILTER pTnFilter
    )
{
    BOOL bMatches = FALSE;

    if (pTnFilter->dwDirection) {
        if (pTnFilter->dwDirection != pIniTnSFilter->dwDirection) {
            return (FALSE);
        }
    }

    if ((pIniTnSFilter->InboundFilterAction != NEGOTIATE_SECURITY) &&
        (pIniTnSFilter->OutboundFilterAction != NEGOTIATE_SECURITY)) {
        return (FALSE);
    }

    bMatches = MatchAddresses(
                   pIniTnSFilter->SrcAddr,
                   pTnFilter->SrcAddr
                   );
    if (!bMatches) {
        return (FALSE);
    }

    bMatches = MatchAddresses(
                   pIniTnSFilter->DesAddr,
                   pTnFilter->DesAddr
                   );
    if (!bMatches) {
        return (FALSE);
    }

    bMatches = MatchAddresses(
                   pIniTnSFilter->DesTunnelAddr,
                   pTnFilter->DesTunnelAddr
                   );
    if (!bMatches) {
        return (FALSE);
    }

    bMatches = MatchPorts(
                   pIniTnSFilter->SrcPort,
                   pTnFilter->SrcPort
                   );
    if (!bMatches) {
        return (FALSE);
    }

    bMatches = MatchPorts(
                   pIniTnSFilter->DesPort,
                   pTnFilter->DesPort
                   );
    if (!bMatches) {
        return (FALSE);
    }

    bMatches = MatchProtocols(
                   pIniTnSFilter->Protocol,
                   pTnFilter->Protocol
                   );
    if (!bMatches) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
CopyTnMatchDefaults(
    DWORD dwFlags,
    PTUNNEL_FILTER * ppTnFilters,
    PIPSEC_QM_POLICY * ppQMPolicies,
    PDWORD pdwNumMatches
    )
{
    DWORD dwError = 0;
    PTUNNEL_FILTER pTnFilters = NULL;
    PIPSEC_QM_POLICY pQMPolicies = NULL;
    DWORD dwNumFilters = 0;
    DWORD dwNumPolicies = 0;


    if (!gpIniDefaultQMPolicy) {
        dwError = ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(TUNNEL_FILTER),
                  &pTnFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = SPDApiBufferAllocate(
                  sizeof(IPSEC_QM_POLICY),
                  &pQMPolicies
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyDefaultTnFilter(
                  pTnFilters,
                  gpIniDefaultQMPolicy
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    dwNumFilters++;

    dwError = CopyQMPolicy(
                  dwFlags,
                  gpIniDefaultQMPolicy,
                  pQMPolicies
                  );
    BAIL_ON_WIN32_ERROR(dwError);
    dwNumPolicies++;

    *ppTnFilters = pTnFilters;
    *ppQMPolicies = pQMPolicies;
    *pdwNumMatches = 1;

    return (dwError);

error:

    if (pTnFilters) {
        FreeTnFilters(
            dwNumFilters,
            pTnFilters
            );
    }

    if (pQMPolicies) {
        FreeQMPolicies(
            dwNumPolicies,
            pQMPolicies
            );
    }

    *ppTnFilters = NULL;
    *ppQMPolicies = NULL;
    *pdwNumMatches = 0;

    return (dwError);
}


DWORD
CopyDefaultTnFilter(
    PTUNNEL_FILTER pTnFilter,
    PINIQMPOLICY pIniQMPolicy
    )
{
    DWORD dwError = 0;
    RPC_STATUS RpcStatus = RPC_S_OK;

    pTnFilter->IpVersion = IPSEC_PROTOCOL_V4;

    RpcStatus = UuidCreate(&(pTnFilter->gFilterID));
    if (!(RpcStatus == RPC_S_OK ||  RpcStatus == RPC_S_UUID_LOCAL_ONLY)) {
        dwError = RPC_S_CALL_FAILED;
        BAIL_ON_WIN32_ERROR(dwError);
    }
    
    dwError = CopyName(
                  L"0",
                  &(pTnFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTnFilter->InterfaceType = INTERFACE_TYPE_ALL;

    pTnFilter->bCreateMirror = TRUE;

    pTnFilter->dwFlags = 0;
    pTnFilter->dwFlags |= IPSEC_QM_POLICY_DEFAULT_POLICY;

    pTnFilter->SrcAddr.AddrType = IP_ADDR_SUBNET;
    pTnFilter->SrcAddr.uIpAddr = SUBNET_ADDRESS_ANY;
    pTnFilter->SrcAddr.uSubNetMask = SUBNET_MASK_ANY;
    pTnFilter->SrcAddr.pgInterfaceID = NULL;

    pTnFilter->DesAddr.AddrType = IP_ADDR_SUBNET;
    pTnFilter->DesAddr.uIpAddr = SUBNET_ADDRESS_ANY;
    pTnFilter->DesAddr.uSubNetMask = SUBNET_MASK_ANY;
    pTnFilter->DesAddr.pgInterfaceID = NULL;

    pTnFilter->SrcTunnelAddr.AddrType = IP_ADDR_SUBNET;
    pTnFilter->SrcTunnelAddr.uIpAddr = SUBNET_ADDRESS_ANY;
    pTnFilter->SrcTunnelAddr.uSubNetMask = SUBNET_MASK_ANY;
    pTnFilter->SrcTunnelAddr.pgInterfaceID = NULL;

    pTnFilter->DesTunnelAddr.AddrType = IP_ADDR_SUBNET;
    pTnFilter->DesTunnelAddr.uIpAddr = SUBNET_ADDRESS_ANY;
    pTnFilter->DesTunnelAddr.uSubNetMask = SUBNET_MASK_ANY;
    pTnFilter->DesTunnelAddr.pgInterfaceID = NULL;

    pTnFilter->Protocol.ProtocolType = PROTOCOL_UNIQUE;
    pTnFilter->Protocol.dwProtocol = 0;

    pTnFilter->SrcPort.PortType = PORT_UNIQUE;
    pTnFilter->SrcPort.wPort = 0;

    pTnFilter->DesPort.PortType = PORT_UNIQUE;
    pTnFilter->DesPort.wPort = 0;

    pTnFilter->InboundFilterAction = NEGOTIATE_SECURITY;

    pTnFilter->OutboundFilterAction = NEGOTIATE_SECURITY;

    pTnFilter->dwDirection = 0;

    pTnFilter->dwWeight = 0;

    CopyGuid(pIniQMPolicy->gPolicyID, &(pTnFilter->gPolicyID));

error:

    return (dwError);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\ipsec\spd\server\tnfilter.c ===
/*++

Copyright (c) 1999 Microsoft Corporation


Module Name:

    tnfilter.c

Abstract:

    This module contains all of the code to drive
    the tunnel filter list management of IPSecSPD
    Service.

Author:

    abhisheV    05-October-1999

Environment: User Mode


Revision History:


--*/


#include "precomp.h"
#ifdef TRACE_ON
#include "tnfilter.tmh"
#endif


DWORD
AddTunnelFilterInternal(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    DWORD dwSource,
    PTUNNEL_FILTER pTunnelFilter,
    LPVOID pvReserved,
    PHANDLE phTnFilter
    )
/*++

Routine Description:

    This function adds a generic tunnel filter to the SPD.

Arguments:

    pServerName - Server on which the tunnel filter is to be added.

    pTunnelFilter - Tunnel Filter to be added.

    phTnFilter -  Handle to the filter returned to the caller.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITNFILTER pIniExistsTnFilter = NULL;
    PINITNFILTER pIniTnFilter = NULL;
    PINIQMPOLICY pIniQMPolicy = NULL;
    PINITNSFILTER pIniTnSFilters = NULL;
    PTN_FILTER_HANDLE pTnFilterHandle = NULL;
    MATCHING_ADDR * pMatchingAddresses = NULL;
    DWORD dwAddrCnt = 0;

    if (!phTnFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Validate the external tunnel filter.
    //

    dwError = ValidateTunnelFilter(
                  pTunnelFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateTnSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniExistsTnFilter = FindTnFilter(
                             gpIniTnFilter,
                             pTunnelFilter
                             );
    if (pIniExistsTnFilter) {
        //
        // TODO: Also need to check for filter flags and policy id.
        //
        dwError = ERROR_IPSEC_TUNNEL_FILTER_EXISTS;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    pIniExistsTnFilter = FindTnFilterByGuid(
                             gpTnFilterHandle,
                             gpIniTnFilter,
                             pTunnelFilter->gFilterID
                             );
    if (pIniExistsTnFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if ((pTunnelFilter->InboundFilterAction == NEGOTIATE_SECURITY) ||
        (pTunnelFilter->OutboundFilterAction == NEGOTIATE_SECURITY)) {

        dwError = LocateQMPolicy(
                      pTunnelFilter->dwFlags,
                      pTunnelFilter->gPolicyID,
                      &pIniQMPolicy
                      );
        BAIL_ON_LOCK_ERROR(dwError);

    }

    dwError = CreateIniTnFilter(
                  pTunnelFilter,
                  pIniQMPolicy,
                  &pIniTnFilter
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniTnFilter->dwSource = 0;

    dwError = GetMatchingInterfaces(
                  pIniTnFilter->InterfaceType,
                  gpInterfaceList,
                  &pMatchingAddresses,
                  &dwAddrCnt
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = CreateIniTnSFilters(
                  pIniTnFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  gpSpecialAddrsList,
                  &pIniTnSFilters
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = CreateTnFilterHandle(
                  pIniTnFilter,
                  pTunnelFilter->gFilterID,
                  &pTnFilterHandle
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = CreateSpecificTnFilterLinks(
                  pIniTnFilter,
                  pIniTnSFilters
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    dwError = InsertTunnelFiltersIntoIPSec(
                  pIniTnSFilters
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    if (pIniQMPolicy) {
        LinkTnFilter(
            pIniQMPolicy,
            pIniTnFilter
            );
        LinkTnSpecificFilters(
            pIniQMPolicy,
            pIniTnSFilters
            );
    }

    AddToSpecificTnList(
        &gpIniTnSFilter,
        pIniTnSFilters
        );

    pIniTnFilter->cRef = 1;

    AddToGenericTnList(
        pIniTnFilter
        );

    pTnFilterHandle->pNext = gpTnFilterHandle;
    gpTnFilterHandle = pTnFilterHandle;

    *phTnFilter = (HANDLE) pTnFilterHandle;
    LEAVE_SPD_SECTION();

    TRACE(
        TRC_INFORMATION,
        (L"Added tunnel filter \"%ls\"(%!guid!).",
        pTunnelFilter->pszFilterName,
        &pTunnelFilter->gFilterID)
        );

cleanup:

    if (pMatchingAddresses) {
        FreeSPDMemory(pMatchingAddresses);
    }

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:
#ifdef TRACE_ON    
    if (pTunnelFilter) {
        TRACE(
            TRC_ERROR,
            (L"Failed to add tunnel filter \"%ls\"(%!guid!): %!winerr!",
            pTunnelFilter->pszFilterName,
            &pTunnelFilter->gFilterID,
            dwError)
            );
    } else {
        TRACE(
            TRC_ERROR,
            (L"Failed to add tunnel filter.  Details unavailabe since pTunneFilter is null: %!winerr!",
            dwError)
            );
    }
#endif
    

    if (pIniTnFilter) {
        FreeIniTnFilter(pIniTnFilter);
    }

    if (pIniTnSFilters) {
        FreeIniTnSFilterList(pIniTnSFilters);
    }

    if (pTnFilterHandle) {
        FreeTnFilterHandle(pTnFilterHandle);
    }

    *phTnFilter = NULL;
    goto cleanup;
}

DWORD
AddTunnelFilter(
    LPWSTR pServerName,
    DWORD dwVersion,
    DWORD dwFlags,
    PTUNNEL_FILTER pTunnelFilter,
    LPVOID pvReserved,
    PHANDLE phTnFilter
    )
{
    return 
        AddTunnelFilterInternal(
            pServerName,
            dwVersion,
            dwFlags,
            IPSEC_SOURCE_WINIPSEC,
            pTunnelFilter,
            pvReserved,
            phTnFilter);
}

DWORD
ValidateTunnelFilter(
    PTUNNEL_FILTER pTnFilter
    )
/*++

Routine Description:

    This function validates an external generic tunnel filter.

Arguments:

    pTnFilter - Filter to validate.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    BOOL bConflicts = FALSE;


    if (!pTnFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = VerifyAddresses(&(pTnFilter->SrcAddr), TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(&(pTnFilter->DesAddr), TRUE, TRUE);
    BAIL_ON_WIN32_ERROR(dwError);

    bConflicts = AddressesConflict(
                     pTnFilter->SrcAddr,
                     pTnFilter->DesAddr
                     );
    if (bConflicts) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateAddr(&(pTnFilter->SrcTunnelAddr));
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyAddresses(&(pTnFilter->DesTunnelAddr), TRUE, FALSE);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyProtocols(pTnFilter->Protocol);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTnFilter->SrcPort,
                  pTnFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = VerifyPortsForProtocol(
                  pTnFilter->DesPort,
                  pTnFilter->Protocol
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (!(pTnFilter->pszFilterName) || !(*(pTnFilter->pszFilterName))) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateInterfaceType(pTnFilter->InterfaceType);
    BAIL_ON_WIN32_ERROR(dwError);
 
    if (pTnFilter->bCreateMirror) { 
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    dwError = ValidateFilterAction(pTnFilter->InboundFilterAction);
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = ValidateFilterAction(pTnFilter->OutboundFilterAction);
    BAIL_ON_WIN32_ERROR(dwError);
    
    if (pTnFilter->dwFlags &&
        !(pTnFilter->dwFlags & IPSEC_QM_POLICY_DEFAULT_POLICY)) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    //
    // No need to call ApplyMulticastFilterValidation as bCreateMirror
    // is always false for a tunnel filter.
    //

error:
#ifdef TRACE_ON    
    if (dwError) {
        if (pTnFilter) {
            TRACE(
                TRC_ERROR,
                (L"Failed tunnel filter validation \"%ls\"(%!guid!): %!winerr!",
                pTnFilter->pszFilterName,
                &pTnFilter->gFilterID,
                dwError)
                );
        } else {
            TRACE(
                TRC_ERROR,
                (L"Failed tunnel filter validation. Details unavailable since pTnFilter is null: %!winerr!",
                dwError)
                );
        }
    }   
#endif

    return (dwError);
}


PINITNFILTER
FindTnFilterByGuid(
    PTN_FILTER_HANDLE pTnFilterHandleList,
    PINITNFILTER pIniTnFilterList,
    GUID gFilterID
    )
{
    BOOL bEqual = FALSE;
    PTN_FILTER_HANDLE pTnFilterHandle = NULL;
    PINITNFILTER pIniTnFilter = NULL;


    pTnFilterHandle = pTnFilterHandleList;

    while (pTnFilterHandle) {

        bEqual = AreGuidsEqual(
                     pTnFilterHandle->gFilterID,
                     gFilterID
                     );
        if (bEqual) {
            return (pTnFilterHandle->pIniTnFilter);
        }
        pTnFilterHandle = pTnFilterHandle->pNext;

    }

    //
    // It could happen that the client closed its handle, so walking through
    // the handle list is not enough. Walk through the filter list as well.
    // Walking through the handle list is necessary and must be done before
    // walking through the filter list.
    //

    pIniTnFilter = pIniTnFilterList;

    while (pIniTnFilter) {

        bEqual = AreGuidsEqual(
                     pIniTnFilter->gFilterID,
                     gFilterID
                     );
        if (bEqual) {
            return (pIniTnFilter);
        }
        pIniTnFilter = pIniTnFilter->pNext;

    }

    return (NULL);
}


PINITNFILTER
FindTnFilter(
    PINITNFILTER pGenericTnList,
    PTUNNEL_FILTER pTnFilter
    )
/*++

Routine Description:

    This function looks for a filter in the filter list.

Arguments:

    pGenericTnList - Filter list in which to search.

    pTnFilter - Filter to search for in the filter list.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    PINITNFILTER pIniTnFilter = NULL;
    BOOL bEqual = FALSE;

    pIniTnFilter = pGenericTnList;

    while (pIniTnFilter) {

        bEqual = EqualTnFilterPKeys(
                     pIniTnFilter,
                     pTnFilter
                     );
        if (bEqual) {
            return (pIniTnFilter);
        }

        bEqual = EqualMirroredTnFilterPKeys(
                     pIniTnFilter,
                     pTnFilter
                     );
        if (bEqual) {
            return (pIniTnFilter);
        }

        pIniTnFilter = pIniTnFilter->pNext;

    }

    return (NULL);
}


BOOL
EqualTnFilterPKeys(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER pTnFilter
    )
/*++

Routine Description:

    This function compares an internal and an external tunnel 
    filter for equality.

Arguments:

    pIniTnFilter - Filter to compare.

    pTnFilter - Filter to compare.

Return Value:

    TRUE - Filters are equal.

    FALSE - Filters are different.

--*/
{
    BOOL  bCmp = FALSE;


    bCmp = EqualExtIntAddresses(pIniTnFilter->SrcAddr, pTnFilter->SrcAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualExtIntAddresses(pIniTnFilter->DesAddr, pTnFilter->DesAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualExtIntAddresses(pIniTnFilter->DesTunnelAddr, pTnFilter->DesTunnelAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualPorts(pIniTnFilter->SrcPort, pTnFilter->SrcPort);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualPorts(pIniTnFilter->DesPort, pTnFilter->DesPort);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualProtocols(pIniTnFilter->Protocol, pTnFilter->Protocol);
    if (!bCmp) {
        return (FALSE);
    }

    if (pIniTnFilter->InterfaceType != pTnFilter->InterfaceType) {
        return (FALSE);
    }

    if (pIniTnFilter->bCreateMirror != pTnFilter->bCreateMirror) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
CreateIniTnFilter(
    PTUNNEL_FILTER pTnFilter,
    PINIQMPOLICY pIniQMPolicy,
    PINITNFILTER * ppIniTnFilter
    )
/*++

Routine Description:

    This function creates an internal generic tunnel filter from
    the external filter.

Arguments:

    pTnFilter - External generic tunnel filter.

    pIniQMPolicy - QM Policy corresponding to the filter.

    ppIniTnFilter - Internal generic tunnel filter created from
                    the external filter.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITNFILTER pIniTnFilter = NULL;


    dwError = AllocateSPDMemory(
                    sizeof(INITNFILTER),
                    &pIniTnFilter
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pIniTnFilter->cRef = 0;

    pIniTnFilter->dwSource = 0;

    pIniTnFilter->bPendingDeletion = FALSE;

    pIniTnFilter->IpVersion = pTnFilter->IpVersion;

    CopyGuid(pTnFilter->gFilterID, &(pIniTnFilter->gFilterID));

    dwError = AllocateSPDString(
                  pTnFilter->pszFilterName,
                  &(pIniTnFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pIniTnFilter->InterfaceType = pTnFilter->InterfaceType;

    pIniTnFilter->bCreateMirror = pTnFilter->bCreateMirror;

    pIniTnFilter->dwFlags = pTnFilter->dwFlags;

    CopyExtToIntAddresses(pTnFilter->SrcAddr, &(pIniTnFilter->SrcAddr));

    CopyExtToIntAddresses(pTnFilter->DesAddr, &(pIniTnFilter->DesAddr));

    CopyExtToIntAddresses(pTnFilter->SrcTunnelAddr, &(pIniTnFilter->SrcTunnelAddr));

    CopyExtToIntAddresses(pTnFilter->DesTunnelAddr, &(pIniTnFilter->DesTunnelAddr));

    CopyPorts(pTnFilter->SrcPort, &(pIniTnFilter->SrcPort));

    CopyPorts(pTnFilter->DesPort, &(pIniTnFilter->DesPort));

    CopyProtocols(pTnFilter->Protocol, &(pIniTnFilter->Protocol));

    pIniTnFilter->InboundFilterAction = pTnFilter->InboundFilterAction;

    pIniTnFilter->OutboundFilterAction = pTnFilter->OutboundFilterAction;

    if (pIniQMPolicy) {
        CopyGuid(pIniQMPolicy->gPolicyID, &(pIniTnFilter->gPolicyID));
    }
    else {
        CopyGuid(pTnFilter->gPolicyID, &(pIniTnFilter->gPolicyID));
    }

    pIniTnFilter->pIniQMPolicy = NULL;

    pIniTnFilter->dwNumTnSFilters = 0;

    pIniTnFilter->ppIniTnSFilters = NULL;

    pIniTnFilter->pNext = NULL;

    *ppIniTnFilter = pIniTnFilter;
    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        (L"Failed to create generic tunnel filter node \"%ls\"(%!guid!): %!winerr!",
        pTnFilter->pszFilterName,
        &pTnFilter->gFilterID,
        dwError)
        );

    if (pIniTnFilter) {
        FreeIniTnFilter(pIniTnFilter);
    }

    *ppIniTnFilter = NULL;
    return (dwError);
}


DWORD
CreateIniTnSFilters(
    PINITNFILTER pIniTnFilter,
    MATCHING_ADDR * pMatchingAddresses,
    DWORD dwAddrCnt,
    PSPECIAL_ADDR pSpecialAddrsList,
    PINITNSFILTER * ppIniTnSFilters
    )
/*++

Routine Description:

    This function expands a generic filter into a set of specific
    filters.

Arguments:

    pIniTnFilter - Generic filter to expand.

    pMatchingAddresses - List of local ip addresses whose interface
                         type matches that of the filter.

    dwAddrCnt - Count of local ip addresses in the list.

    ppIniTnSFilters - Expanded specific filters.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITNSFILTER pSpecificFilters = NULL;
    PINITNFILTER pMirroredFilter = NULL;
    PINITNSFILTER pMirroredSpecificFilters = NULL;
    BOOL bEqual = FALSE;


    if (!dwAddrCnt) {
        dwError = ERROR_SUCCESS;
        BAIL_ON_WIN32_SUCCESS(dwError);
    }

    dwError = ApplyTnTransform(
                  pIniTnFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  pSpecialAddrsList,
                  &pSpecificFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIniTnFilter->bCreateMirror) {

        dwError = CreateIniMirroredTnFilter(
                      pIniTnFilter,
                      &pMirroredFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        bEqual = EqualIniTnFilterPKeys(
                     pIniTnFilter,
                     pMirroredFilter
                     );
        if (!bEqual) {

            dwError = ApplyTnTransform(
                          pMirroredFilter,
                          pMatchingAddresses,
                          dwAddrCnt,
                          pSpecialAddrsList,
                          &pMirroredSpecificFilters
                          );
            BAIL_ON_WIN32_ERROR(dwError);

            AddToSpecificTnList(
                &pSpecificFilters,
                pMirroredSpecificFilters
                );

        }

    }

    *ppIniTnSFilters = pSpecificFilters;

    TRACE(
        TRC_INFORMATION,
        (L"Successfully generated specific tunnel filters from \"%ls\" (%!guid!)",
        pIniTnFilter->pszFilterName,
        &pIniTnFilter->gFilterID)
        );
    
cleanup:

    if (pMirroredFilter) {
        FreeIniTnFilter(pMirroredFilter);
    }

    return (dwError);

success:
error:
#ifdef TRACE_ON
    if (dwError) {
        TRACE(
            TRC_ERROR,
            (L"Failed to generate specific tunnel filters from \"%ls\"(%!guid!): %!winerr!",
            pIniTnFilter->pszFilterName,
            &pIniTnFilter->gFilterID,
            dwError)
            );
    }   
#endif

    if (pSpecificFilters) {
        FreeIniTnSFilterList(pSpecificFilters);
    }

    *ppIniTnSFilters = NULL;
    goto cleanup;
}


DWORD
CreateIniMirroredTnFilter(
    PINITNFILTER pFilter,
    PINITNFILTER * ppMirroredFilter
    )
/*++

Routine Description:

    This function creates a mirrored filter for the given filter.

Arguments:

    pFilter - Filter for which to create the mirror.

    ppMirroredFilter - Mirrored filter created for the given filter.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PINITNFILTER pMirroredFilter = NULL;


    dwError = AllocateSPDMemory(
                  sizeof(INITNFILTER),
                  &pMirroredFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMirroredFilter->cRef = pFilter->cRef;

    pMirroredFilter->dwSource = pFilter->dwSource;

    pMirroredFilter->bPendingDeletion = pFilter->bPendingDeletion;

    pMirroredFilter->IpVersion = pFilter->IpVersion;

    CopyGuid(pFilter->gFilterID, &(pMirroredFilter->gFilterID));

    dwError = AllocateSPDString(
                  pFilter->pszFilterName,
                  &(pMirroredFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pMirroredFilter->InterfaceType = pFilter->InterfaceType;

    pMirroredFilter->bCreateMirror = pFilter->bCreateMirror;

    pMirroredFilter->dwFlags = pFilter->dwFlags;

    CopyAddresses(pFilter->DesAddr, &(pMirroredFilter->SrcAddr));

    CopyAddresses(pFilter->SrcAddr, &(pMirroredFilter->DesAddr));

    CopyAddresses(pFilter->DesTunnelAddr, &(pMirroredFilter->SrcTunnelAddr));

    CopyAddresses(pFilter->SrcTunnelAddr, &(pMirroredFilter->DesTunnelAddr));

    CopyPorts(pFilter->DesPort, &(pMirroredFilter->SrcPort));

    CopyPorts(pFilter->SrcPort, &(pMirroredFilter->DesPort));

    CopyProtocols(pFilter->Protocol, &(pMirroredFilter->Protocol));

    pMirroredFilter->InboundFilterAction = pFilter->InboundFilterAction;

    pMirroredFilter->OutboundFilterAction = pFilter->OutboundFilterAction;

    CopyGuid(pFilter->gPolicyID, &(pMirroredFilter->gPolicyID));

    pMirroredFilter->pIniQMPolicy = NULL;

    pMirroredFilter->dwNumTnSFilters = 0;

    pMirroredFilter->ppIniTnSFilters = NULL;

    pMirroredFilter->pNext = NULL;

    *ppMirroredFilter = pMirroredFilter;
    return (dwError);

error:

    if (pMirroredFilter) {
        FreeIniTnFilter(pMirroredFilter);
    }

    *ppMirroredFilter = NULL;
    return (dwError);
}


BOOL
EqualIniTnFilterPKeys(
    PINITNFILTER pIniTnFilter,
    PINITNFILTER pFilter
    )
{
    BOOL  bCmp = FALSE;


    bCmp = EqualAddresses(pIniTnFilter->SrcAddr, pFilter->SrcAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pIniTnFilter->DesAddr, pFilter->DesAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pIniTnFilter->DesTunnelAddr, pFilter->DesTunnelAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualPorts(pIniTnFilter->SrcPort, pFilter->SrcPort);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualPorts(pIniTnFilter->DesPort, pFilter->DesPort);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualProtocols(pIniTnFilter->Protocol, pFilter->Protocol);
    if (!bCmp) {
        return (FALSE);
    }

    if (pIniTnFilter->InterfaceType != pFilter->InterfaceType) {
        return (FALSE);
    }

    if (pIniTnFilter->bCreateMirror != pFilter->bCreateMirror) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
CreateTnFilterHandle(
    PINITNFILTER pIniTnFilter,
    GUID gFilterID,
    PTN_FILTER_HANDLE * ppTnFilterHandle
    )
{
    DWORD dwError = 0;
    PTN_FILTER_HANDLE pTnFilterHandle = NULL;


    dwError = AllocateSPDMemory(
                    sizeof(TN_FILTER_HANDLE),
                    &pTnFilterHandle
                    );
    BAIL_ON_WIN32_ERROR(dwError);

    pTnFilterHandle->IpVersion = pIniTnFilter->IpVersion;
    pTnFilterHandle->pIniTnFilter= pIniTnFilter;
    CopyGuid(gFilterID, &(pTnFilterHandle->gFilterID));
    pTnFilterHandle->pNext = NULL;

    *ppTnFilterHandle = pTnFilterHandle;
    return (dwError);

error:

    *ppTnFilterHandle = NULL;
    return (dwError);
}


DWORD
CreateSpecificTnFilterLinks(
    PINITNFILTER pIniTnFilter,
    PINITNSFILTER pIniTnSFilters
    )
{
    DWORD dwError = 0;
    PINITNSFILTER pTemp = NULL;
    DWORD dwCnt = 0;
    PINITNSFILTER * ppIniTnSFilters = NULL;
    DWORD i = 0;


    pTemp = pIniTnSFilters;

    while (pTemp) {
        dwCnt++;
        pTemp = pTemp->pNext;
    }

    if (!dwCnt) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    pIniTnFilter->ppIniTnSFilters = (PINITNSFILTER *)
                                    AllocSPDMem(
                                        sizeof(PINITNSFILTER)*dwCnt
                                        );
    if (!(pIniTnFilter->ppIniTnSFilters)) {
        dwError = ERROR_OUTOFMEMORY;
        BAIL_ON_WIN32_ERROR(dwError);    
    }

    pTemp = pIniTnSFilters;
    ppIniTnSFilters = pIniTnFilter->ppIniTnSFilters;

    for (i = 0; i < dwCnt; i++) {
        *(ppIniTnSFilters + i) = pTemp; 
        pTemp = pTemp->pNext;
    }
    pIniTnFilter->dwNumTnSFilters = dwCnt;

error:

    return (dwError);
}


VOID
LinkTnFilter(
    PINIQMPOLICY pIniQMPolicy,
    PINITNFILTER pIniTnFilter
    )
{
    pIniQMPolicy->cRef++;
    pIniTnFilter->pIniQMPolicy = pIniQMPolicy;
    return;
}


VOID
FreeIniTnFilterList(
    PINITNFILTER pIniTnFilterList
    )
{
    PINITNFILTER pFilter = NULL;
    PINITNFILTER pTempFilter = NULL;

    pFilter = pIniTnFilterList;

    while (pFilter) {
        pTempFilter = pFilter;
        pFilter = pFilter->pNext;
        FreeIniTnFilter(pTempFilter);
    }
}


VOID
FreeIniTnFilter(
    PINITNFILTER pIniTnFilter
    )
{
    if (pIniTnFilter) {
        if (pIniTnFilter->pszFilterName) {
            FreeSPDString(pIniTnFilter->pszFilterName);
        }

        //
        // Must not ever free pIniTnFilter->pIniQMPolicy.
        //

        //
        // Must not ever free memory pointed by each of
        // the pointers in pIniTnFilter->ppIniTnSFilters.
        //

        if (pIniTnFilter->ppIniTnSFilters) {
            FreeSPDMemory(pIniTnFilter->ppIniTnSFilters);
        }

        FreeSPDMemory(pIniTnFilter);
    }
}


DWORD
DeleteTunnelFilter(
    HANDLE hTnFilter
    )
/*++

Routine Description:

    This function deletes a generic tunnel filter from the SPD.

Arguments:

    hTnFilter -  Handle to the filter to be deleted.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PTN_FILTER_HANDLE pFilterHandle = NULL;
    PINITNFILTER pIniTnFilter = NULL;
#ifdef TRACE_ON
    GUID gTraceFilterID;    
    if (!hTnFilter) {
        CopyGuid(((PTN_FILTER_HANDLE) hTnFilter)->gFilterID, &gTraceFilterID);
    }
#endif

    if (!hTnFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    pFilterHandle = (PTN_FILTER_HANDLE) hTnFilter;

    ENTER_SPD_SECTION();

    dwError = ValidateTnSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniTnFilter = pFilterHandle->pIniTnFilter;

    if (!pIniTnFilter) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniTnFilter->cRef > 1) {

        pIniTnFilter->cRef--;
        pIniTnFilter->bPendingDeletion = TRUE;

        RemoveTnFilterHandle(
            pFilterHandle
            );

        FreeTnFilterHandle(
            pFilterHandle
            );


        dwError = ERROR_SUCCESS;
        LEAVE_SPD_SECTION();
        return (dwError);

    }

    dwError = DeleteIniTnFilter(
                  pIniTnFilter
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    //
    // Delete the filter handle from the list of tunnel handles.
    //

    RemoveTnFilterHandle(
        pFilterHandle
        );

    FreeTnFilterHandle(
        pFilterHandle
        );

    LEAVE_SPD_SECTION();

    TRACE(
        TRC_INFORMATION,
        (L"Deleted tunnel filter %!guid!",
        &gTraceFilterID)
        );
    
    return (dwError);

lock:
#ifdef TRACE_ON
    if (hTnFilter) {
        TRACE(
            TRC_ERROR,
            ("Failed to delete tunnel filter %!guid!: %!winerr!",
            &gTraceFilterID,
            dwError)
            );
    } else {
        TRACE(
            TRC_ERROR,
            ("Failed to delete tunnel filter.  Details unavailable since hTnFilter null: %!winerr!",
            dwError)
            );
    }
#endif


    LEAVE_SPD_SECTION();

    return (dwError);
}


DWORD
DeleteIniTnFilter(
    PINITNFILTER pIniTnFilter
    )
/*++

Routine Description:

    This function physically deletes a tunnel filter and all the
    specific tunnel filters expanded out of it.

Arguments:

    pIniTnFilter - Generic filter to be deleted.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;


    dwError = DeleteIniTnSFilters(
                  pIniTnFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIniTnFilter->pIniQMPolicy) {
        DelinkTnFilter(
            pIniTnFilter->pIniQMPolicy,
            pIniTnFilter
            );
    }

    RemoveIniTnFilter(
        pIniTnFilter
        );

    FreeIniTnFilter(pIniTnFilter);

error:

    return (dwError);
}


VOID
DelinkTnFilter(
    PINIQMPOLICY pIniQMPolicy,
    PINITNFILTER pIniTnFilter
    )
{
    pIniQMPolicy->cRef--;
    pIniTnFilter->pIniQMPolicy = NULL;
    return;
}


DWORD
DeleteIniTnSFilters(
    PINITNFILTER pIniTnFilter
    )
{
    DWORD dwError = 0;
    PINITNSFILTER * ppIniTnSFilters = NULL;
    DWORD dwNumTnSFilters = 0;
    DWORD i = 0;
    PINITNSFILTER pIniTnSFilter = NULL;
    PINITNSFILTER pIniRemoveTnSFilter = NULL;
    PINITNSFILTER pTemp = NULL;


    ppIniTnSFilters = pIniTnFilter->ppIniTnSFilters;
    dwNumTnSFilters = pIniTnFilter->dwNumTnSFilters;

    for (i = 0; i < dwNumTnSFilters; i++) {

       //
       // Remove each entry from the Tunnel Specific Filter List.
       //

        pIniTnSFilter =  *(ppIniTnSFilters + i);
        RemoveIniTnSFilter(pIniTnSFilter);

        //
        // Add each entry removed to a removed list.
        //

        pIniTnSFilter->pNext = NULL;
        AddToSpecificTnList(
            &pIniRemoveTnSFilter,
            pIniTnSFilter
            );

    }

    //
    // Delete the specific filters from the IPSec Driver.
    //

    dwError = DeleteTunnelFiltersFromIPSec(
                  pIniRemoveTnSFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    //
    // Physically delete the removed list.
    //

    while (pIniRemoveTnSFilter) {
        pTemp = pIniRemoveTnSFilter;
        pIniRemoveTnSFilter = pIniRemoveTnSFilter->pNext;
        FreeIniTnSFilter(pTemp);
    }

    return (dwError);

error :

    if (pIniRemoveTnSFilter) {
        AddToSpecificTnList(
            &gpIniTnSFilter,
            pIniRemoveTnSFilter
            );
    }

    return (dwError);
}


VOID
RemoveIniTnFilter(
    PINITNFILTER pIniTnFilter
    )
{
    PINITNFILTER * ppTemp = NULL;

    ppTemp = &gpIniTnFilter;

    while (*ppTemp) {

        if (*ppTemp == pIniTnFilter) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);
    }

    if (*ppTemp) {
        *ppTemp = pIniTnFilter->pNext;
    }

    return;
}


VOID
RemoveTnFilterHandle(
    PTN_FILTER_HANDLE pTnFilterHandle
    )
{
    PTN_FILTER_HANDLE * ppTemp = NULL;

    ppTemp = &gpTnFilterHandle;

    while (*ppTemp) {

        if (*ppTemp == pTnFilterHandle) {
            break;
        }
        ppTemp = &((*ppTemp)->pNext);
    }

    if (*ppTemp) {
        *ppTemp = pTnFilterHandle->pNext;
    }

    return;
}


VOID
FreeTnFilterHandleList(
    PTN_FILTER_HANDLE pTnFilterHandleList
    )
{
    PTN_FILTER_HANDLE pTnFilterHandle = NULL;
    PTN_FILTER_HANDLE pTemp = NULL;

    pTnFilterHandle = pTnFilterHandleList;

    while (pTnFilterHandle) {
        pTemp = pTnFilterHandle;
        pTnFilterHandle = pTnFilterHandle->pNext;
        FreeTnFilterHandle(pTemp);
    }
}


VOID
FreeTnFilterHandle(
    PTN_FILTER_HANDLE pTnFilterHandle
    )
{
    if (pTnFilterHandle) {
        FreeSPDMemory(pTnFilterHandle);
    }
    return;
}


DWORD
EnumTunnelFilters(
    LPWSTR pServerName,
    DWORD dwVersion,
    PTUNNEL_FILTER pTunnelTemplateFilter,
    DWORD dwLevel,
    GUID gGenericFilterID,
    DWORD dwPreferredNumEntries,
    PTUNNEL_FILTER * ppTunnelFilters,
    LPDWORD pdwNumTnFilters,
    LPDWORD pdwResumeHandle,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function enumerates tunnel filters from the SPD.

Arguments:

    pServerName - Server on which the filters are to be enumerated.

    dwLevel - Level to identify the type of enumeration desired:
              (i) enumerate generic tunnel filters or
              (ii) enumerate specific tunnel filters or
              (iii) enumerate specific tunnel filters for a 
                    generic tunnel filter.

    gGenericFilterID - Filter id of the generic tunnel filter 
                       in the case when the specific tunnel filters
                       for a generic filter are to be enumerated.
 
    ppTunnelFilters - Enumerated Filters returned to the caller.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    pdwNumTnFilters - Number of filters actually enumerated.

    pdwResumeHandle - Handle to the location in the filter list from
                      which to resume enumeration.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PTUNNEL_FILTER pTnFilters = 0;
    DWORD dwNumTnFilters = 0;
    PINITNFILTER pIniTnFilter = NULL;


    if (!ppTunnelFilters || !pdwNumTnFilters || !pdwResumeHandle) {
        return (ERROR_INVALID_PARAMETER);
    }

    ENTER_SPD_SECTION();

    dwError = ValidateTnSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    switch (dwLevel) {

    case ENUM_GENERIC_FILTERS:

        dwError = EnumGenericTnFilters(
                      gpIniTnFilter,
                      *pdwResumeHandle,
                      dwPreferredNumEntries,
                      &pTnFilters,
                      &dwNumTnFilters
                      );
        BAIL_ON_LOCK_ERROR(dwError);
        break;

    case ENUM_SELECT_SPECIFIC_FILTERS:

        pIniTnFilter = FindTnFilterByGuid(
                           gpTnFilterHandle,
                           gpIniTnFilter,
                           gGenericFilterID
                           );
        if (!pIniTnFilter) {
            dwError = ERROR_INVALID_PARAMETER;
            BAIL_ON_LOCK_ERROR(dwError);
        }
        dwError = EnumSelectSpecificTnFilters(
                      pIniTnFilter,
                      *pdwResumeHandle,
                      dwPreferredNumEntries,
                      &pTnFilters,
                      &dwNumTnFilters
                      );
        BAIL_ON_LOCK_ERROR(dwError);
        break;

    case ENUM_SPECIFIC_FILTERS:

        dwError = EnumSpecificTnFilters(
                      gpIniTnSFilter,
                      *pdwResumeHandle,
                      dwPreferredNumEntries,
                      &pTnFilters,
                      &dwNumTnFilters
                      );
        BAIL_ON_LOCK_ERROR(dwError);
        break;

    default:

        dwError = ERROR_INVALID_LEVEL;
        BAIL_ON_LOCK_ERROR(dwError);
        break;

    }

    *ppTunnelFilters = pTnFilters;
    *pdwNumTnFilters = dwNumTnFilters;
    *pdwResumeHandle = *pdwResumeHandle + dwNumTnFilters;

    LEAVE_SPD_SECTION();

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    *ppTunnelFilters = NULL;
    *pdwNumTnFilters = 0;
    *pdwResumeHandle = *pdwResumeHandle;

    return (dwError);
}


DWORD
EnumGenericTnFilters(
    PINITNFILTER pIniTnFilterList,
    DWORD dwResumeHandle,
    DWORD dwPreferredNumEntries,
    PTUNNEL_FILTER * ppTnFilters,
    PDWORD pdwNumTnFilters
    )
/*++

Routine Description:

    This function creates enumerated generic filters.

Arguments:

    pIniTnFilterList - List of generic filters to enumerate.

    dwResumeHandle - Location in the generic filter list from which
                     to resume enumeration.

    dwPreferredNumEntries - Preferred number of enumeration entries.

    ppTnFilters - Enumerated filters returned to the caller.

    pdwNumTnFilters - Number of filters actually enumerated.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    DWORD dwNumToEnum = 0;
    PINITNFILTER pIniTnFilter = NULL;
    DWORD i = 0;
    PINITNFILTER pTemp = NULL;
    DWORD dwNumTnFilters = 0;
    PTUNNEL_FILTER pTnFilters = 0;
    PTUNNEL_FILTER pTnFilter = 0;


    if (!dwPreferredNumEntries || 
        (dwPreferredNumEntries > MAX_TUNNELFILTER_ENUM_COUNT)) {
        dwNumToEnum = MAX_TUNNELFILTER_ENUM_COUNT;
    }
    else {
        dwNumToEnum = dwPreferredNumEntries;
    }

    pIniTnFilter = pIniTnFilterList;

    for (i = 0; (i < dwResumeHandle) && (pIniTnFilter != NULL); i++) {
        pIniTnFilter = pIniTnFilter->pNext;
    }

    if (!pIniTnFilter) {
        dwError = ERROR_NO_DATA;
        BAIL_ON_WIN32_ERROR(dwError);
    }

    pTemp = pIniTnFilter;

    while (pTemp && (dwNumTnFilters < dwNumToEnum)) {
        dwNumTnFilters++;
        pTemp = pTemp->pNext;
    }

    dwError = SPDApiBufferAllocate(
                  sizeof(TUNNEL_FILTER)*dwNumTnFilters,
                  &pTnFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTemp = pIniTnFilter;
    pTnFilter = pTnFilters;

    for (i = 0; i < dwNumTnFilters; i++) {

        dwError = CopyTnFilter(
                      pTemp,
                      pTnFilter
                      );
        BAIL_ON_WIN32_ERROR(dwError);

        pTemp = pTemp->pNext;
        pTnFilter++;

    }

    *ppTnFilters = pTnFilters;
    *pdwNumTnFilters = dwNumTnFilters;
    return (dwError);

error:

    if (pTnFilters) {
        FreeTnFilters(
            i,
            pTnFilters
            );
    }

    *ppTnFilters = NULL;
    *pdwNumTnFilters = 0;

    return (dwError);
}


DWORD
CopyTnFilter(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER pTnFilter
    )
/*++

Routine Description:

    This function copies an internal filter into an external filter
    container.

Arguments:

    pIniTnFilter - Internal filter to copy.

    pTnFilter - External filter container in which to copy.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;


    pTnFilter->IpVersion = pIniTnFilter->IpVersion;

    CopyGuid(pIniTnFilter->gFilterID, &(pTnFilter->gFilterID));

    dwError = CopyName(
                  pIniTnFilter->pszFilterName,
                  &(pTnFilter->pszFilterName)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    pTnFilter->InterfaceType = pIniTnFilter->InterfaceType;

    pTnFilter->bCreateMirror = pIniTnFilter->bCreateMirror;

    pTnFilter->dwFlags = pIniTnFilter->dwFlags;

    dwError = CopyIntToExtAddresses(pIniTnFilter->SrcAddr, &(pTnFilter->SrcAddr));
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyIntToExtAddresses(pIniTnFilter->DesAddr, &(pTnFilter->DesAddr));
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyIntToExtAddresses(
                  pIniTnFilter->SrcTunnelAddr,
                  &(pTnFilter->SrcTunnelAddr)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyIntToExtAddresses(
                  pIniTnFilter->DesTunnelAddr,
                  &(pTnFilter->DesTunnelAddr)
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    CopyProtocols(pIniTnFilter->Protocol, &(pTnFilter->Protocol));

    CopyPorts(pIniTnFilter->SrcPort, &(pTnFilter->SrcPort));

    CopyPorts(pIniTnFilter->DesPort, &(pTnFilter->DesPort));

    pTnFilter->InboundFilterAction = pIniTnFilter->InboundFilterAction;

    pTnFilter->OutboundFilterAction = pIniTnFilter->OutboundFilterAction;

    pTnFilter->dwDirection = 0;

    pTnFilter->dwWeight = 0;

    CopyGuid(pIniTnFilter->gPolicyID, &(pTnFilter->gPolicyID));

    return (dwError);

error:

    if (pTnFilter->pszFilterName) {
        SPDApiBufferFree(pTnFilter->pszFilterName);
        pTnFilter->pszFilterName = NULL;
    }

    if (pTnFilter->SrcAddr.pgInterfaceID) {
        SPDApiBufferFree(pTnFilter->SrcAddr.pgInterfaceID);
        pTnFilter->SrcAddr.pgInterfaceID = NULL;
    }

    if (pTnFilter->DesAddr.pgInterfaceID) {
        SPDApiBufferFree(pTnFilter->DesAddr.pgInterfaceID);
        pTnFilter->DesAddr.pgInterfaceID = NULL;
    }

    if (pTnFilter->SrcTunnelAddr.pgInterfaceID) {
        SPDApiBufferFree(pTnFilter->SrcTunnelAddr.pgInterfaceID);
        pTnFilter->SrcTunnelAddr.pgInterfaceID = NULL;
    }

    if (pTnFilter->DesTunnelAddr.pgInterfaceID) {
        SPDApiBufferFree(pTnFilter->DesTunnelAddr.pgInterfaceID);
        pTnFilter->DesTunnelAddr.pgInterfaceID = NULL;
    }

    return (dwError);
}


VOID
FreeTnFilters(
    DWORD dwNumTnFilters,
    PTUNNEL_FILTER pTnFilters
    )
{
    DWORD i = 0;

    if (pTnFilters) {

        for (i = 0; i < dwNumTnFilters; i++) {

            if (pTnFilters[i].pszFilterName) {
                SPDApiBufferFree(pTnFilters[i].pszFilterName);
            }

            if (pTnFilters[i].SrcAddr.pgInterfaceID) {
                SPDApiBufferFree(pTnFilters[i].SrcAddr.pgInterfaceID);
            }

            if (pTnFilters[i].DesAddr.pgInterfaceID) {
                SPDApiBufferFree(pTnFilters[i].DesAddr.pgInterfaceID);
            }

            if (pTnFilters[i].SrcTunnelAddr.pgInterfaceID) {
                SPDApiBufferFree(pTnFilters[i].SrcTunnelAddr.pgInterfaceID);
            }

            if (pTnFilters[i].DesTunnelAddr.pgInterfaceID) {
                SPDApiBufferFree(pTnFilters[i].DesTunnelAddr.pgInterfaceID);
            }

        }

        SPDApiBufferFree(pTnFilters);

    }

}


DWORD
SetTunnelFilter(
    HANDLE hTnFilter,
    DWORD dwVersion,
    PTUNNEL_FILTER pTunnelFilter,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function sets (updates) a tunnel filter in the SPD.

Arguments:

    hTnFilter - Handle to the filter to be replaced.

    pTunnelFilter - Filter that will replace the existing filter.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PTN_FILTER_HANDLE pFilterHandle = NULL;
    PINITNFILTER pIniTnFilter = NULL;
    BOOL bEqualPKeys = FALSE;

    if (!hTnFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    dwError = ValidateTunnelFilter(
                  pTunnelFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateTnSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pFilterHandle = (PTN_FILTER_HANDLE) hTnFilter;

    pIniTnFilter = pFilterHandle->pIniTnFilter;

    if (!pIniTnFilter) {
        dwError = ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniTnFilter->bPendingDeletion) {
        dwError = ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    bEqualPKeys = EqualTnFilterPKeys(
                      pIniTnFilter,
                      pTunnelFilter
                      );
    if (!bEqualPKeys) {
        dwError = ERROR_INVALID_PARAMETER;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = SetIniTnFilter(
                  pIniTnFilter,
                  pTunnelFilter
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    LEAVE_SPD_SECTION();

    TRACE(
        TRC_INFORMATION,
        (L"Changed tunnel filter %!guid!.  New guid %!guid!",
        &pFilterHandle->gFilterID,
        &pTunnelFilter->gFilterID)
        );
    
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:
#ifdef TRACE_ON
    if (hTnFilter) {
        pFilterHandle = (PTN_FILTER_HANDLE) hTnFilter;        
        TRACE(
            TRC_ERROR,
            ("Failed to change tunnel filter to %!guid!: %!winerr!",
            &pFilterHandle->gFilterID,
            dwError)
            );
    } else {
        TRACE(
            TRC_ERROR,
            ("Failed to change tunnel filter.  Details unavailable since hTnFilter null: %!winerr!",
            dwError)
            );
    }
#endif

    return (dwError);
}


DWORD
SetIniTnFilter(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER pTnFilter
    )
{
    DWORD dwError = 0;
    BOOL bEqualNonPKeys = FALSE;
    PINIQMPOLICY pIniNewQMPolicy = NULL;
    PINITNFILTER pIniNewTnFilter = NULL;
    MATCHING_ADDR * pMatchingAddresses = NULL;
    DWORD dwAddrCnt = 0;
    PINITNSFILTER pIniNewTnSFilters = NULL;
    DWORD dwNumTnSFilters = 0;
    PINITNSFILTER * ppIniTnSFilters = NULL;
    LPWSTR pszFilterName = NULL;
    PINITNSFILTER pIniCurTnSFilters = NULL;


    bEqualNonPKeys = EqualTnFilterNonPKeys(
                         pIniTnFilter,
                         pTnFilter
                         );
    if (bEqualNonPKeys) {
        dwError = ERROR_SUCCESS;
        return (dwError);
    }

    if ((pTnFilter->InboundFilterAction == NEGOTIATE_SECURITY) ||
        (pTnFilter->OutboundFilterAction == NEGOTIATE_SECURITY)) {

        dwError = LocateQMPolicy(
                      pTnFilter->dwFlags,
                      pTnFilter->gPolicyID,
                      &pIniNewQMPolicy
                      );
        BAIL_ON_WIN32_ERROR(dwError);

    }

    dwError = CreateIniTnFilter(
                  pTnFilter,
                  pIniNewQMPolicy,
                  &pIniNewTnFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = GetMatchingInterfaces(
                  pIniNewTnFilter->InterfaceType,
                  gpInterfaceList,
                  &pMatchingAddresses,
                  &dwAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateIniTnSFilters(
                  pIniNewTnFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  gpSpecialAddrsList,
                  &pIniNewTnSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateTnSFilterLinks(
                  pIniNewTnSFilters,
                  &dwNumTnSFilters,
                  &ppIniTnSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateSPDString(
                  pTnFilter->pszFilterName,
                  &pszFilterName
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    RemoveTnSFilters(
        pIniTnFilter,
        &pIniCurTnSFilters
        );

    dwError = DeleteTunnelFiltersFromIPSec(
                  pIniCurTnSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = InsertTunnelFiltersIntoIPSec(
                  pIniNewTnSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    UpdateTnSFilterLinks(
        pIniTnFilter,
        dwNumTnSFilters,
        ppIniTnSFilters
        );

    if (pIniTnFilter->pIniQMPolicy) {
        DelinkTnFilter(
            pIniTnFilter->pIniQMPolicy,
            pIniTnFilter
            );
    }

    if (pIniNewQMPolicy) {
        LinkTnFilter(
            pIniNewQMPolicy,
            pIniTnFilter
            );
        LinkTnSpecificFilters(
            pIniNewQMPolicy,
            pIniNewTnSFilters
            );
    }

    UpdateTnFilterNonPKeys(
        pIniTnFilter,
        pszFilterName,
        pTnFilter,
        pIniNewQMPolicy
        );

    AddToSpecificTnList(
        &gpIniTnSFilter,
        pIniNewTnSFilters
        );

    if (pIniCurTnSFilters) {
        FreeIniTnSFilterList(pIniCurTnSFilters);
    }

cleanup:

    if (pIniNewTnFilter) {
        FreeIniTnFilter(pIniNewTnFilter);
    }

    if (pMatchingAddresses) {
        FreeSPDMemory(pMatchingAddresses);
    }

    return (dwError);

error:

    if (pIniNewTnSFilters) {
        FreeIniTnSFilterList(pIniNewTnSFilters);
    }

    if (ppIniTnSFilters) {
        FreeSPDMemory(ppIniTnSFilters);
    }

    if (pszFilterName) {
        FreeSPDString(pszFilterName);
    }

    if (pIniCurTnSFilters) {
        AddToSpecificTnList(
            &gpIniTnSFilter,
            pIniCurTnSFilters
            );
    }

    goto cleanup;
}


BOOL
EqualTnFilterNonPKeys(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER pTnFilter
    )
{
    if (_wcsicmp(
            pIniTnFilter->pszFilterName,
            pTnFilter->pszFilterName)) {
        return (FALSE);
    }

    if (pIniTnFilter->InboundFilterAction != 
        pTnFilter->InboundFilterAction) {
        return (FALSE);
    }

    if (pIniTnFilter->OutboundFilterAction != 
        pTnFilter->OutboundFilterAction) {
        return (FALSE);
    }

    if ((pIniTnFilter->InboundFilterAction == NEGOTIATE_SECURITY) ||
        (pIniTnFilter->OutboundFilterAction == NEGOTIATE_SECURITY)) {
        if ((pIniTnFilter->dwFlags) != (pTnFilter->dwFlags)) {
            return (FALSE);
        }

        if (memcmp(
                &(pIniTnFilter->gPolicyID),
                &(pTnFilter->gPolicyID),
                sizeof(GUID))) {
            return (FALSE);
        }
    }

    return (TRUE);
}


DWORD
CreateTnSFilterLinks(
    PINITNSFILTER pIniTnSFilters,
    PDWORD pdwNumTnSFilters,
    PINITNSFILTER ** pppIniTnSFilters
    )
{
    DWORD dwError = 0;
    PINITNSFILTER pTemp = NULL;
    DWORD dwNumTnSFilters = 0;
    PINITNSFILTER * ppIniTnSFilters = NULL;
    DWORD i = 0;


    pTemp = pIniTnSFilters;
    while (pTemp) {
        dwNumTnSFilters++;
        pTemp = pTemp->pNext;
    }

    if (dwNumTnSFilters) {
        ppIniTnSFilters = (PINITNSFILTER *)
                          AllocSPDMem(
                              sizeof(PINITNSFILTER)*
                              dwNumTnSFilters
                              );
        if (!ppIniTnSFilters) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);    
        }
    }

    pTemp = pIniTnSFilters;
    for (i = 0; i < dwNumTnSFilters; i++) {
        *(ppIniTnSFilters + i) = pTemp;
        pTemp = pTemp->pNext;
    }

    *pdwNumTnSFilters = dwNumTnSFilters;
    *pppIniTnSFilters = ppIniTnSFilters;
    return (dwError);

error:

    *pdwNumTnSFilters = 0;
    *pppIniTnSFilters = NULL;
    return (dwError);
}


VOID
RemoveTnSFilters(
    PINITNFILTER pIniTnFilter,
    PINITNSFILTER * ppIniCurTnSFilters 
    )
{
    PINITNSFILTER * ppIniTnSFilters = NULL;
    DWORD dwNumTnSFilters = 0;
    DWORD i = 0;
    PINITNSFILTER pIniTnSFilter = NULL;
    PINITNSFILTER pIniCurTnSFilters = NULL;


    ppIniTnSFilters = pIniTnFilter->ppIniTnSFilters;
    dwNumTnSFilters = pIniTnFilter->dwNumTnSFilters;

    for (i = 0; i < dwNumTnSFilters; i++) {

        //
        // Remove each entry from the Tunnel Specific Filter List.
        //

        pIniTnSFilter =  *(ppIniTnSFilters + i);
        RemoveIniTnSFilter(pIniTnSFilter);

        //
        // Add each entry removed to a removed list.
        //

        pIniTnSFilter->pNext = NULL;
        AddToSpecificTnList(
            &pIniCurTnSFilters,
            pIniTnSFilter
            );

    }

    *ppIniCurTnSFilters = pIniCurTnSFilters;
}


VOID
UpdateTnSFilterLinks(
    PINITNFILTER pIniTnFilter,
    DWORD dwNumTnSFilters,
    PINITNSFILTER * ppIniTnSFilters
    )
{
    if (pIniTnFilter->ppIniTnSFilters) {
        FreeSPDMemory(pIniTnFilter->ppIniTnSFilters);
    }

    pIniTnFilter->ppIniTnSFilters = ppIniTnSFilters;
    pIniTnFilter->dwNumTnSFilters = dwNumTnSFilters;
}


VOID
UpdateTnFilterNonPKeys(
    PINITNFILTER pIniTnFilter,
    LPWSTR pszFilterName,
    PTUNNEL_FILTER pTnFilter,
    PINIQMPOLICY pIniQMPolicy
    )
{
    if (pIniTnFilter->pszFilterName) {
        FreeSPDString(pIniTnFilter->pszFilterName);
    }
    pIniTnFilter->pszFilterName = pszFilterName;

    pIniTnFilter->dwFlags = pTnFilter->dwFlags;

    pIniTnFilter->InboundFilterAction = pTnFilter->InboundFilterAction;

    pIniTnFilter->OutboundFilterAction = pTnFilter->OutboundFilterAction;

    if (pIniQMPolicy) {
        CopyGuid(pIniQMPolicy->gPolicyID, &(pIniTnFilter->gPolicyID));
    }
    else {
        CopyGuid(pTnFilter->gPolicyID, &(pIniTnFilter->gPolicyID));
    }
}


DWORD
GetTunnelFilter(
    HANDLE hTnFilter,
    DWORD dwVersion,
    PTUNNEL_FILTER * ppTunnelFilter,
    LPVOID pvReserved
    )
/*++

Routine Description:

    This function retrieves a tunnel filter from the SPD.

Arguments:

    hTnFilter - Handle to the filter to be retrieved.

    ppTunnelFilter -  Filter returned to the caller.

Return Value:

    ERROR_SUCCESS - Success.

    Win32 Error - Failure.

--*/
{
    DWORD dwError = 0;
    PTN_FILTER_HANDLE pFilterHandle = NULL;
    PINITNFILTER pIniTnFilter = NULL;
    PTUNNEL_FILTER pTunnelFilter = NULL;


    if (!hTnFilter || !ppTunnelFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    ENTER_SPD_SECTION();

    dwError = ValidateTnSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pFilterHandle = (PTN_FILTER_HANDLE) hTnFilter;

    pIniTnFilter = pFilterHandle->pIniTnFilter;

    if (!pIniTnFilter) {
        dwError = ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = GetIniTnFilter(
                  pIniTnFilter,
                  &pTunnelFilter
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    LEAVE_SPD_SECTION();

    *ppTunnelFilter = pTunnelFilter;
    return (dwError);

lock:

    LEAVE_SPD_SECTION();

    *ppTunnelFilter = NULL;
    return (dwError);
}


DWORD
GetIniTnFilter(
    PINITNFILTER pIniTnFilter,
    PTUNNEL_FILTER * ppTnFilter
    )
{
    DWORD dwError = 0;
    PTUNNEL_FILTER pTnFilter = NULL;


    dwError = SPDApiBufferAllocate(
                  sizeof(TUNNEL_FILTER),
                  &pTnFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CopyTnFilter(
                  pIniTnFilter,
                  pTnFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppTnFilter = pTnFilter;
    return (dwError);

error:

    if (pTnFilter) {
        SPDApiBufferFree(pTnFilter);
    }

    *ppTnFilter = NULL;
    return (dwError);
}


DWORD
ApplyIfChangeToIniTnFilters(
    PDWORD pdwTnError,
    PIPSEC_INTERFACE pLatestIfList,
    PSPECIAL_ADDR    pLatestSpecialAddrsList    
    )
{
    DWORD dwError = 0;
    PINITNFILTER pIniTnFilter = NULL;


    pIniTnFilter = gpIniTnFilter;

    while (pIniTnFilter) {

        dwError = UpdateIniTnFilterThruIfChange(
                      pIniTnFilter,
                      pLatestIfList,
                      pLatestSpecialAddrsList
                      );
        if (dwError) {
            *pdwTnError = dwError;
        }

        pIniTnFilter = pIniTnFilter->pNext;

    }

    dwError = ERROR_SUCCESS;
    return (dwError);
}


DWORD
UpdateIniTnFilterThruIfChange(
    PINITNFILTER pIniTnFilter,
    PIPSEC_INTERFACE pLatestIfList,
    PSPECIAL_ADDR  pLatestSpecialAddrsList    
    )
{
    DWORD dwError = 0;
    PINITNSFILTER pLatestIniTnSFilters = NULL;
    DWORD dwNumTnSFilters = 0;
    PINITNSFILTER * ppIniTnSFilters = NULL;
    PINITNSFILTER pCurIniTnSFilters = NULL;
    PINITNSFILTER pNewIniTnSFilters = NULL;
    PINITNSFILTER pOldIniTnSFilters = NULL;
    BOOL bDeletedFromDriver = FALSE;
 

    dwError = FormIniTnSFilters(
                  pIniTnFilter,
                  pLatestIfList,
                  pLatestSpecialAddrsList,
                  &pLatestIniTnSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = AllocateTnSFilterLinks(
                  pLatestIniTnSFilters,
                  &dwNumTnSFilters,
                  &ppIniTnSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    RemoveTnSFilters(
        pIniTnFilter,
        &pCurIniTnSFilters
        );

    ProcessIniTnSFilters(
        &pLatestIniTnSFilters,
        &pCurIniTnSFilters,
        &pNewIniTnSFilters,
        &pOldIniTnSFilters
        );

    dwError = DeleteTunnelFiltersFromIPSec(
                  pOldIniTnSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    bDeletedFromDriver = TRUE;

    dwError = InsertTunnelFiltersIntoIPSec(
                  pNewIniTnSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    if (pIniTnFilter->pIniQMPolicy) {
        LinkTnSpecificFilters(
            pIniTnFilter->pIniQMPolicy,
            pCurIniTnSFilters
            );
        LinkTnSpecificFilters(
            pIniTnFilter->pIniQMPolicy,
            pNewIniTnSFilters
            );
    }

    SetTnSFilterLinks(
        pCurIniTnSFilters,
        pNewIniTnSFilters,
        dwNumTnSFilters,
        ppIniTnSFilters
        );

    UpdateTnSFilterLinks(
        pIniTnFilter,
        dwNumTnSFilters,
        ppIniTnSFilters
        );

    AddToSpecificTnList(
        &gpIniTnSFilter,
        pCurIniTnSFilters
        );

    AddToSpecificTnList(
        &gpIniTnSFilter,
        pNewIniTnSFilters
        );

    if (pOldIniTnSFilters) {
        FreeIniTnSFilterList(pOldIniTnSFilters);
    }

    TRACE(
        TRC_INFORMATION,
        (L"Succesfully updated tunnel filter \"%ls\" (%!guid!) after interface change",
        pIniTnFilter->pszFilterName,
        &pIniTnFilter->gFilterID)
        );

    return (dwError);

error:
    TRACE(
        TRC_ERROR,
        (L"Failed to update tunnel filter \"%ls\" (%!guid!) after interface change: %!winerr!",
        pIniTnFilter->pszFilterName,
        &pIniTnFilter->gFilterID,
        dwError)
        );

    if (pLatestIniTnSFilters) {
        FreeIniTnSFilterList(pLatestIniTnSFilters);
    }

    if (ppIniTnSFilters) {
        FreeSPDMemory(ppIniTnSFilters);
    }

    if (pCurIniTnSFilters) {
        AddToSpecificTnList(
            &gpIniTnSFilter,
            pCurIniTnSFilters
            );
    }

    if (pNewIniTnSFilters) {
        FreeIniTnSFilterList(pNewIniTnSFilters);
    }

    if (pOldIniTnSFilters) {
        if (bDeletedFromDriver) {
            (VOID) InsertTunnelFiltersIntoIPSec(
                       pOldIniTnSFilters
                       );
        }
        AddToSpecificTnList(
            &gpIniTnSFilter,
            pOldIniTnSFilters
            );
    }

    return (dwError);
}


DWORD
FormIniTnSFilters(
    PINITNFILTER pIniTnFilter,
    PIPSEC_INTERFACE pIfList,
    PSPECIAL_ADDR  pLatestSpecialAddrsList,    
    PINITNSFILTER * ppIniTnSFilters
    )
{
    DWORD dwError = 0;
    MATCHING_ADDR * pMatchingAddresses = NULL;
    DWORD dwAddrCnt = 0;
    PINITNSFILTER pIniTnSFilters = NULL;


    dwError = GetMatchingInterfaces(
                  pIniTnFilter->InterfaceType,
                  pIfList,
                  &pMatchingAddresses,
                  &dwAddrCnt
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    dwError = CreateIniTnSFilters(
                  pIniTnFilter,
                  pMatchingAddresses,
                  dwAddrCnt,
                  pLatestSpecialAddrsList,
                  &pIniTnSFilters
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    *ppIniTnSFilters = pIniTnSFilters;

cleanup:

    if (pMatchingAddresses) {
        FreeSPDMemory(pMatchingAddresses);
    }

    return (dwError);

error:

    *ppIniTnSFilters = NULL;

    goto cleanup;
}


VOID
ProcessIniTnSFilters(
    PINITNSFILTER * ppLatestIniTnSFilters,
    PINITNSFILTER * ppCurIniTnSFilters,
    PINITNSFILTER * ppNewIniTnSFilters,
    PINITNSFILTER * ppOldIniTnSFilters
    )
{
    PINITNSFILTER pLatestIniTnSFilters = NULL;
    PINITNSFILTER pCurIniTnSFilters = NULL;
    PINITNSFILTER pTempCur = NULL;
    BOOL bEqual = FALSE;
    PINITNSFILTER pTempLatest = NULL;
    PINITNSFILTER pTemp = NULL;
    PINITNSFILTER pNewIniTnSFilters = NULL;
    PINITNSFILTER pOldIniTnSFilters = NULL;
    PINITNSFILTER pTempPreToCur = NULL;
    PINITNSFILTER pTempPreToLatest = NULL;


    pCurIniTnSFilters = *ppCurIniTnSFilters;
    pTempCur = *ppCurIniTnSFilters;

    while (pTempCur) {

        bEqual = FALSE;
        pTempLatest = *ppLatestIniTnSFilters;

        while (pTempLatest) {

            bEqual = EqualIniTnSFilterIfPKeys(
                         pTempLatest,
                         pTempCur
                         );
            if (bEqual) {
                break;
            }

            pTempLatest = pTempLatest->pNext;

        }

        if (bEqual) {
            pTempPreToCur  = pTempCur;
            pTempCur = pTempCur->pNext;
        }
        else {
            pTemp = pTempCur;
            pTempCur = pTempCur->pNext;
            if (pTempPreToCur) {
                pTempPreToCur->pNext = pTempCur;
            }
            else {
                pCurIniTnSFilters = pTempCur;
            }
            pTemp->pNext = NULL;
            AddToSpecificTnList(
                &pOldIniTnSFilters,
                pTemp
                );
        }

    }

    pLatestIniTnSFilters = *ppLatestIniTnSFilters;
    pTempLatest = *ppLatestIniTnSFilters;

    while (pTempLatest) {

        bEqual = FALSE;
        pTempCur = pCurIniTnSFilters;

        while (pTempCur) {

            bEqual = EqualIniTnSFilterIfPKeys(
                         pTempCur,
                         pTempLatest
                         );
            if (bEqual) {
                break;
            }

            pTempCur = pTempCur->pNext;

        }

        if (bEqual) {
            pTemp = pTempLatest;
            pTempLatest = pTempLatest->pNext;
            if (pTempPreToLatest) {
                pTempPreToLatest->pNext = pTempLatest;
            }
            else {
                pLatestIniTnSFilters = pTempLatest;
            }
            FreeIniTnSFilter(pTemp);
        }
        else {
            pTemp = pTempLatest;
            pTempLatest = pTempLatest->pNext;
            if (pTempPreToLatest) {
                pTempPreToLatest->pNext = pTempLatest;
            }
            else {
                pLatestIniTnSFilters = pTempLatest;
            }
            pTemp->pNext = NULL;
            AddToSpecificTnList(
                &pNewIniTnSFilters,
                pTemp
                );
        }

    }

    *ppLatestIniTnSFilters = pLatestIniTnSFilters;
    *ppCurIniTnSFilters = pCurIniTnSFilters;
    *ppNewIniTnSFilters = pNewIniTnSFilters;
    *ppOldIniTnSFilters = pOldIniTnSFilters;
}


BOOL
EqualIniTnSFilterIfPKeys(
    PINITNSFILTER pExsIniTnSFilter,
    PINITNSFILTER pNewIniTnSFilter
    )
{
    BOOL  bCmp = FALSE;


    //
    // No need to compare: gParentID, pszFilterName, dwFlags
    //                     cRef, Protocol, SrcPort, DesPort,
    //                     InboundFilterAction, OutboundFilterAction,
    //                     dwWeight and gPolicyID.
    // They will be the same for both the filters.
    //

    if (pExsIniTnSFilter->InterfaceType != pNewIniTnSFilter->InterfaceType) {
        return (FALSE);
    }

    bCmp = EqualAddresses(
               pExsIniTnSFilter->DesTunnelAddr,
               pNewIniTnSFilter->DesTunnelAddr
               );
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pExsIniTnSFilter->SrcAddr, pNewIniTnSFilter->SrcAddr);
    if (!bCmp) {
        return (FALSE);
    }

    bCmp = EqualAddresses(pExsIniTnSFilter->DesAddr, pNewIniTnSFilter->DesAddr);
    if (!bCmp) {
        return (FALSE);
    }

    if (pExsIniTnSFilter->dwDirection != pNewIniTnSFilter->dwDirection) {
        return (FALSE);
    }

    return (TRUE);
}


DWORD
AllocateTnSFilterLinks(
    PINITNSFILTER pIniTnSFilters,
    PDWORD pdwNumTnSFilters,
    PINITNSFILTER ** pppIniTnSFilters
    )
{
    DWORD dwError = 0;
    PINITNSFILTER pTemp = NULL;
    DWORD dwNumTnSFilters = 0;
    PINITNSFILTER * ppIniTnSFilters = NULL;
    DWORD i = 0;


    pTemp = pIniTnSFilters;
    while (pTemp) {
        dwNumTnSFilters++;
        pTemp = pTemp->pNext;
    }

    if (dwNumTnSFilters) {
        ppIniTnSFilters = (PINITNSFILTER *)
                          AllocSPDMem(
                              sizeof(PINITNSFILTER)*
                              dwNumTnSFilters
                              );
        if (!ppIniTnSFilters) {
            dwError = ERROR_OUTOFMEMORY;
            BAIL_ON_WIN32_ERROR(dwError);    
        }
    }

    for (i = 0; i < dwNumTnSFilters; i++) {
        *(ppIniTnSFilters + i) = NULL;
    }

    *pdwNumTnSFilters = dwNumTnSFilters;
    *pppIniTnSFilters = ppIniTnSFilters;
    return (dwError);

error:

    *pdwNumTnSFilters = 0;
    *pppIniTnSFilters = NULL;
    return (dwError);
}


VOID
SetTnSFilterLinks(
    PINITNSFILTER pCurIniTnSFilters,
    PINITNSFILTER pNewIniTnSFilters,
    DWORD dwNumTnSFilters,
    PINITNSFILTER * ppIniTnSFilters
    )
{
    PINITNSFILTER pTemp = NULL;
    DWORD i = 0;
    DWORD j = 0;


    pTemp = pCurIniTnSFilters;
    for (i = 0; (i < dwNumTnSFilters) && (pTemp != NULL); i++) {
        *(ppIniTnSFilters + i) = pTemp;
        pTemp = pTemp->pNext;
    }

    pTemp = pNewIniTnSFilters;
    for (j = i; (j < dwNumTnSFilters) && (pTemp != NULL); j++) {
        *(ppIniTnSFilters + j) = pTemp;
        pTemp = pTemp->pNext;
    }
}


VOID
AddToGenericTnList(
    PINITNFILTER pIniTnFilter
    )
{
    PINITNFILTER pTemp = NULL;


    if (!gpIniTnFilter) {
        gpIniTnFilter = pIniTnFilter;
        return;
    }

    pTemp = gpIniTnFilter;

    while (pTemp->pNext) {
        pTemp = pTemp->pNext;
    }

    pTemp->pNext = pIniTnFilter;

    return;
}


DWORD
OpenTunnelFilterHandle(
    LPWSTR pServerName,
    DWORD dwVersion,
    PTUNNEL_FILTER pTunnelFilter,
    LPVOID pvReserved,
    PHANDLE phTnFilter
    )
{
    DWORD dwError = 0;
    PINITNFILTER pIniExistingTnFilter = NULL;
    PTN_FILTER_HANDLE pTnFilterHandle = NULL;


    if (!phTnFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Validate the external Tunnel filter.
    //

    dwError = ValidateTunnelFilter(
                  pTunnelFilter
                  );
    BAIL_ON_WIN32_ERROR(dwError);

    ENTER_SPD_SECTION();

    dwError = ValidateTnSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_ACCESS_ADMINISTER,
                  NULL,
                  NULL
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniExistingTnFilter = FindExactTnFilter(
                               gpIniTnFilter,
                               pTunnelFilter
                               );
    if (!pIniExistingTnFilter) {
        dwError = ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    if (pIniExistingTnFilter->bPendingDeletion) {
        dwError = ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION;
        BAIL_ON_LOCK_ERROR(dwError);
    }

    dwError = CreateTnFilterHandle(
                  pIniExistingTnFilter,
                  pTunnelFilter->gFilterID,
                  &pTnFilterHandle
                  );
    BAIL_ON_LOCK_ERROR(dwError);

    pIniExistingTnFilter->cRef++;

    pTnFilterHandle->pNext = gpTnFilterHandle;
    gpTnFilterHandle = pTnFilterHandle;

    *phTnFilter = (HANDLE) pTnFilterHandle;
    LEAVE_SPD_SECTION();

cleanup:

    return (dwError);

lock:

    LEAVE_SPD_SECTION();

error:

    if (pTnFilterHandle) {
        FreeTnFilterHandle(pTnFilterHandle);
    }

    *phTnFilter = NULL;
    goto cleanup;
}


DWORD
CloseTunnelFilterHandle(
    HANDLE hTnFilter
    )
{
    DWORD dwError = 0;
    PTN_FILTER_HANDLE pFilterHandle = NULL;
    PINITNFILTER pIniTnFilter = NULL;


    if (!hTnFilter) {
        return (ERROR_INVALID_PARAMETER);
    }

    pFilterHandle = (PTN_FILTER_HANDLE) hTnFilter;

    ENTER_SPD_SECTION();

    dwError = ValidateTnSecurity(
                  SPD_OBJECT_SERVER,
                  SERVER_