ights Reserved.
 *
 *  File:	drvinfo.c
 *  Content:	DirectDraw driver info implementation
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   17-jun-98	jeffno  initial implementation, after michael lyons and toddla
 *   14-jun-99  mregen  return WHQL certification level -- postponed
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#include "ddrawpr.h"

#include <tchar.h>
#include <stdio.h>
#include <wincrypt.h>
#include <wintrust.h>
#include <softpub.h>
#include <mscat.h>



//========================================================================
//
// just some handy forward declarations
//
DWORD GetWHQLLevel(LPTSTR lpszDriver, LPSTR lpszWin9xDriver);
DWORD IsFileDigitallySigned(LPTSTR lpszDriver);
BOOL FileIsSignedOld(LPTSTR lpszFile);

//
//  These functions are defined in mscat.h. They are not available on win95,
//  so we have to use LoadLibrary to load mscat32.dll and wincrypt.dll
//
typedef HCATINFO WINAPI funcCryptCATAdminEnumCatalogFromHash(HCATADMIN hCatAdmin,
                                                             BYTE *pbHash,
                                                             DWORD cbHash,
                                                             DWORD dwFlags,
                                                             HCATINFO *phPrevCatInfo);
typedef BOOL WINAPI funcCryptCATAdminCalcHashFromFileHandle(HANDLE hFile,
                                                            DWORD *pcbHash,
                                                            BYTE *pbHash,
                                                            DWORD dwFlags);
typedef HANDLE WINAPI funcCryptCATOpen( LPWSTR pwszFileName, 
                                        DWORD fdwOpenFlags,
                                        HCRYPTPROV hProv,
                                        DWORD dwPublicVersion,
                                        DWORD dwEncodingType);
typedef BOOL WINAPI funcCryptCATClose(IN HANDLE hCatalog);
typedef CRYPTCATATTRIBUTE * WINAPI funcCryptCATGetCatAttrInfo( HANDLE hCatalog,
                                                           LPWSTR pwszReferenceTag);
typedef BOOL WINAPI      funcCryptCATAdminAcquireContext(HCATADMIN *phCatAdmin, 
                                                        GUID *pgSubsystem, 
                                                        DWORD dwFlags);
typedef BOOL WINAPI      funcCryptCATAdminReleaseContext(HCATADMIN hCatAdmin,
                                                         DWORD dwFlags);
typedef BOOL WINAPI funcCryptCATAdminReleaseCatalogContext(HCATADMIN hCatAdmin,
                                                       HCATINFO hCatInfo,
                                                       DWORD dwFlags);
typedef BOOL WINAPI funcCryptCATCatalogInfoFromContext(HCATINFO hCatInfo,
                                                   CATALOG_INFO *psCatInfo,
                                                   DWORD dwFlags);

typedef CRYPTCATATTRIBUTE * WINAPI funcCryptCATEnumerateCatAttr(HCATINFO hCatalog,
                                                           CRYPTCATATTRIBUTE *lpCat);


//
//  function defined in wincrypt.dll
//
typedef LONG WINAPI funcWinVerifyTrust(HWND hwnd, GUID *pgActionID,
                                  LPVOID pWVTData);

//
//  our storage for the mscat32/wincrypt dll loader
//
typedef struct tagCatApi {
    BOOL bInitialized;
    HINSTANCE hLibMSCat;
    HINSTANCE hLibWinTrust;
    HCATADMIN hCatAdmin;
    funcCryptCATClose *pCryptCATClose;
    funcCryptCATGetCatAttrInfo *pCryptCATGetCatAttrInfo;
    funcCryptCATOpen *pCryptCATOpen;
    funcCryptCATAdminEnumCatalogFromHash *pCryptCATAdminEnumCatalogFromHash;
    funcCryptCATAdminCalcHashFromFileHandle *pCryptCATAdminCalcHashFromFileHandle;
    funcCryptCATAdminAcquireContext *pCryptCATAdminAcquireContext;
    funcCryptCATAdminReleaseContext *pCryptCATAdminReleaseContext;
    funcCryptCATAdminReleaseCatalogContext *pCryptCATAdminReleaseCatalogContext;
    funcCryptCATCatalogInfoFromContext *pCryptCATCatalogInfoFromContext;
    funcCryptCATEnumerateCatAttr *pCryptCATEnumerateCatAttr;
    funcWinVerifyTrust *pWinVerifyTrust;
} CATAPI,* LPCATAPI;

//========================================================================
//
// some helper functions to open/close crypt API
//

BOOL InitCATAPI(LPCATAPI lpCatApi)
{
    UINT uiOldErrorMode;
    HINSTANCE hLibMSCat;
    HINSTANCE hLibWinTrust;

    DDASSERT(lpCatApi!=NULL);
    ZeroMemory( lpCatApi, sizeof(CATAPI));

    // already initialized by ZeroMemory
    // lpCatApi->bInitialized=FALSE:

    uiOldErrorMode=SetErrorMode(SEM_NOOPENFILEERRORBOX);
    hLibMSCat=LoadLibrary("mscat32.dll");
    hLibWinTrust=LoadLibrary("wintrust.dll");

    if (hLibMSCat!=NULL &&
        hLibWinTrust!=NULL)
    {
        lpCatApi->pCryptCATOpen=(funcCryptCATOpen *)
            GetProcAddress ( hLibMSCat, "CryptCATOpen");
        lpCatApi->pCryptCATClose=(funcCryptCATClose *)
            GetProcAddress ( hLibMSCat, "CryptCATClose");
        lpCatApi->pCryptCATGetCatAttrInfo=(funcCryptCATGetCatAttrInfo *)
            GetProcAddress ( hLibMSCat, "CryptCATGetCatAttrInfo");
        lpCatApi->pCryptCATAdminCalcHashFromFileHandle=(funcCryptCATAdminCalcHashFromFileHandle*)
            GetProcAddress ( hLibMSCat, "CryptCATAdminCalcHashFromFileHandle");
        lpCatApi->pCryptCATAdminEnumCatalogFromHash=(funcCryptCATAdminEnumCatalogFromHash*)
            GetProcAddress ( hLibMSCat, "CryptCATAdminEnumCatalogFromHash");
        lpCatApi->pCryptCATAdminAcquireContext=(funcCryptCATAdminAcquireContext*)
            GetProcAddress ( hLibMSCat, "CryptCATAdminAcquireContext");
        lpCatApi->pCryptCATAdminReleaseContext=(funcCryptCATAdminReleaseContext*)
            GetProcAddress ( hLibMSCat, "CryptCATAdminReleaseContext");
        lpCatApi->pCryptCATAdminReleaseCatalogContext=(funcCryptCATAdminReleaseCatalogContext*)
            GetProcAddress ( hLibMSCat, "CryptCATAdminReleaseCatalogContext");
        lpCatApi->pCryptCATCatalogInfoFromContext=(funcCryptCATCatalogInfoFromContext*)
            GetProcAddress ( hLibMSCat, "CryptCATCatalogInfoFromContext");
        lpCatApi->pCryptCATEnumerateCatAttr=(funcCryptCATEnumerateCatAttr*)
            GetProcAddress ( hLibMSCat, "CryptCATEnumerateCatAttr");
        lpCatApi->pWinVerifyTrust=(funcWinVerifyTrust*)
            GetProcAddress ( hLibWinTrust,"WinVerifyTrust");

        if (lpCatApi->pCryptCATOpen!=NULL &&
            lpCatApi->pCryptCATClose!=NULL &&
            lpCatApi->pCryptCATGetCatAttrInfo!=NULL &&
            lpCatApi->pCryptCATAdminCalcHashFromFileHandle!=NULL &&
            lpCatApi->pCryptCATAdminEnumCatalogFromHash!=NULL &&
            lpCatApi->pCryptCATAdminAcquireContext!=NULL &&
            lpCatApi->pCryptCATAdminReleaseContext!=NULL &&
            lpCatApi->pCryptCATAdminReleaseCatalogContext!=NULL &&
            lpCatApi->pCryptCATCatalogInfoFromContext!=NULL &&
            lpCatApi->pCryptCATEnumerateCatAttr !=NULL &&
            lpCatApi->pWinVerifyTrust!=NULL
            )
        {
            if ((*lpCatApi->pCryptCATAdminAcquireContext)(&lpCatApi->hCatAdmin,NULL,0))
            {
                lpCatApi->hLibMSCat=hLibMSCat;
                lpCatApi->hLibWinTrust=hLibWinTrust;
                lpCatApi->bInitialized=TRUE;
            }
        } 
    }

    if (!lpCatApi->bInitialized)
    {
       FreeLibrary(hLibMSCat);
       FreeLibrary(hLibWinTrust);
    }

    SetErrorMode(uiOldErrorMode);

    return lpCatApi->bInitialized;
}

BOOL ReleaseCATAPI(LPCATAPI lpCatApi)
{
    DDASSERT(lpCatApi!=NULL);

    if (lpCatApi->bInitialized)
    {
        (*lpCatApi->pCryptCATAdminReleaseContext)( lpCatApi->hCatAdmin, 0);

        FreeLibrary(lpCatApi->hLibMSCat);
        FreeLibrary(lpCatApi->hLibWinTrust);
        ZeroMemory( lpCatApi, sizeof(CATAPI));        

        return TRUE;
    }

    return FALSE;
}

//========================================================================
//
// _strstr
//
// String-in-string function, written to avoid RTL inclusion necessity.
//
//========================================================================
char *_strstr(char *s1, char *s2)
{
	if (s1 && s2)
	{
		while (*s1)
		{
			char *p1=s1;
			char *p2=s2;

			while (*p2 && (*p1==*p2))
			{
				p1++;
				p2++;
			}
			if (*p2==0)
				return s1;

			s1++;
		}
	}

	return NULL;
}
//***&&*%**!!ing c runtime

DWORD _atoi(char * p)
{
    DWORD dw=0;
    while ( (*p >= '0' && *p <= '9') || (*p >= 'A' && *p <= 'F') || (*p >= 'A' && *p <= 'F') )
    {
        dw = dw*16;
        if (*p >= 'a')
            dw += *p-'a' + 10;
        else if (*p >= 'A')
            dw += *p-'A' + 10;
        else
            dw += *p-'0';

        p++;
    }
    return dw;
}

char *FindLast(char * s, char c)
{
    char * pFound=0;
    if (s)
    {
        while (*s)
        {
            if (*s == c)
                pFound = s;
            s++;
        }
    }
    return pFound;
}

//========================================================================
// hard-coded vendor IDs
//========================================================================
#define VEN_3DFX			"VEN_121A"
#define VEN_3DFXVOODOO1                 "VEN_121A&DEV_0001"
#define VEN_POWERVR			"VEN_1033"

#ifdef WIN95

void GetFileVersionData(
    LPDDDRIVERINFOEX pDI)
{
    void *				buffer;
    VS_FIXEDFILEINFO *	verinfo;
    DWORD				dwSize;
    DWORD                               dwHi,dwLo;

    //Failure means 0 returned
    pDI->di.liDriverVersion.HighPart = 0;
    pDI->di.liDriverVersion.LowPart = 0;


    dwSize=GetFileVersionInfoSize(pDI->di.szDriver, 0);

    if (!dwSize)
	    return;

    buffer=LocalAlloc(LPTR, dwSize);
    if (!buffer)
	    return;

    if (!GetFileVersionInfo(pDI->di.szDriver, 0, dwSize, buffer))
    {
	    LocalFree(buffer);
	    return;
    }

    if (!VerQueryValue(buffer, "\\", (void **)&verinfo, (UINT *)&dwSize))
    {
	    LocalFree(buffer);
	    return;
    }

    pDI->di.liDriverVersion.HighPart = verinfo->dwFileVersionMS;
    pDI->di.liDriverVersion.LowPart  = verinfo->dwFileVersionLS;

    LocalFree(buffer);
}


extern HRESULT _GetDriverInfoFromRegistry(char *szClass, char *szClassNot, char *szVendor, LPDDDRIVERINFOEX pDI);

/*
 * following are all the 9x-specific version functions
 */
void GetHALName(
    LPDDRAWI_DIRECTDRAW_GBL pdrv,
    LPDDDRIVERINFOEX        pDI)
{
    pDI->di.szDriver[0] = 0;
    lstrcpyn(pDI->di.szDriver, pdrv->dd32BitDriverData.szName, sizeof(pDI->di.szDriver) );
}


BOOL CheckPowerVR(LPDDRAWI_DIRECTDRAW_GBL pdrv, LPDDDRIVERINFOEX pDI)
{
    BOOL    bFound=FALSE;
    HKEY    hKey;
    DWORD   dwSize;
    DWORD   dwType;

    if (pdrv->dwFlags & DDRAWI_SECONDARYDRIVERLOADED)
    {
        /*
         * Any secondary driver information in the registry at all? (assert this is true)
         */
        if( ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE,
				         REGSTR_PATH_SECONDARY,
				         &hKey ) )
        {
	    /*
	     * Extract the name of the secondary driver's DLL. (assert this works)
	     */
	    dwSize = sizeof( pDI->di.szDriver ) - 1;
	    if( ERROR_SUCCESS == RegQueryValueEx( hKey,
					          REGSTR_VALUE_SECONDARY_DRIVERNAME,
					          NULL,
					          &dwType,
					          pDI->di.szDriver,
					          &dwSize ) )
	    {
	        if( REG_SZ == dwType )
	        {
                    GetFileVersionData(pDI);
                }
            }
            RegCloseKey(hKey);
        }

        if (SUCCEEDED(_GetDriverInfoFromRegistry(NULL, "Display", VEN_POWERVR, pDI)))
        {
            //got PVR data...
            bFound = TRUE;
        }
    }
    return bFound;
}

HRESULT Check3Dfx(LPDDDRIVERINFOEX pDI)
{
    HRESULT hr = DD_OK;

    if (FAILED(_GetDriverInfoFromRegistry(NULL, "Display", VEN_3DFX, pDI)))
    {
        DPF_ERR("Couldn't get registry data for this device");
        hr = DDERR_NOTFOUND;
    }

    return hr;
}

HRESULT GetDriverInfoFromRegistry(char *szClass, char *szClassNot, char *szVendor, LPDDDRIVERINFOEX pDI)
{
    return _GetDriverInfoFromRegistry(szClass, szClassNot, szVendor, pDI);
}

/*
 * Given a DISPLAY_DEVICE, get driver name
 * NOTE::: THIS FUNCTION NUKES THE DISPLAY_DEVICE.DeviceKey STRING!!!!
 */
void GetWin9XDriverName(DISPLAY_DEVICEA * pdd, LPSTR pDrvName)
{
    HKEY hKey;

    lstrcat( pdd->DeviceKey, "\\DEFAULT" );
    if( ERROR_SUCCESS == RegOpenKeyEx( 
                            HKEY_LOCAL_MACHINE,
                            pdd->DeviceKey,
                            0,
                            KEY_QUERY_VALUE ,
                            &hKey ) )
    {
        DWORD dwSize = MAX_DDDEVICEID_STRING;
        DWORD dwType = 0;

        RegQueryValueEx( hKey,
                         TEXT("drv"),
                         NULL,
                         &dwType,
                         pDrvName,
                         &dwSize );

        RegCloseKey(hKey);
    }
}

#else //win95

/*
 * following are all the NT-specific version functions
 */
void GetFileVersionData(
    LPDDDRIVERINFOEX pDI)
{
    //Failure means 0 returned
    pDI->di.liDriverVersion.HighPart = 0;
    pDI->di.liDriverVersion.LowPart = 0;
}

void GetHALName(
    LPDDRAWI_DIRECTDRAW_GBL pdrv,
    LPDDDRIVERINFOEX pDI)
{
    pDI->di.szDriver[0] = 0;
}

BOOL CheckPowerVR(LPDDRAWI_DIRECTDRAW_GBL pdrv, LPDDDRIVERINFOEX pdi)
{
    return FALSE;
}

HRESULT Check3Dfx(LPDDDRIVERINFOEX pDI)
{
    return DDERR_GENERIC;
}

HRESULT GetDriverInfoFromRegistry(char *szClass, char *szClassNot, char *szVendor, LPDDDRIVERINFOEX pDI)
{
    return DDERR_GENERIC;
}

/*
 * Given a DISPLAY_DEVICE, get driver name, assuming winnt5
 * NOTE::: THIS FUNCTION NUKES THE DISPLAY_DEVICE.DeviceKey STRING!!!!
 */
void GetNTDriverNameAndVersion(DISPLAY_DEVICEA * pdd, LPDDDRIVERINFOEX pDI)
{
    HKEY hKey;

    //
    //  old style to determine display driver...returns name of miniport!
    //

    char * pTemp;

    // The device key has the form blah\blah\services\<devicekey>\DeviceN
    // So we back up one node:
    if ( (pTemp = FindLast(pdd->DeviceKey,'\\')) )
    {
        char * pTempX;
        char cOld=*pTemp;
        *pTemp = 0;

        //If we back up one node, we'll have the registry key under which the driver is stored. Let's use that!
        if ( (pTempX = FindLast(pdd->DeviceKey,'\\')) )
        {
            lstrcpyn(pDI->di.szDriver, pTemp+1, sizeof(pDI->di.szDriver));
            //ATTENTION No point getting version data without a filname:
            //We need a new service or something to get the used display driver name
            //GetFileVersionData(pDI);
        }

        *pTemp=cOld;
    }

    //
    //  we can find the display driver in a registry key
    //
    //  note: InstalledDisplayDrivers can contain several entries
    //  to display drivers Since there is no way to find out which
    //  one is the active one, we always return the first as being
    //  the display driver!
    //
    if( ERROR_SUCCESS == RegOpenKeyEx( 
                         HKEY_LOCAL_MACHINE,
				         pdd->DeviceKey+18,
                         0,
                         KEY_QUERY_VALUE ,
				         &hKey ) )
    {
        DWORD dwSize=sizeof(pDI->di.szDriver), dwType=0;
        if( ERROR_SUCCESS == RegQueryValueEx( hKey,
					          TEXT("InstalledDisplayDrivers"),
					          NULL,
					          &dwType,
					          pDI->di.szDriver,
					          &dwSize ) )
        {   
            lstrcat(pDI->di.szDriver, TEXT(".dll"));
        }

        RegCloseKey(hKey);
    }
}
#endif //win95



void GenerateIdentifier(LPDDDRIVERINFOEX pDI)
{
    LPDWORD pdw;

    CopyMemory(&pDI->di.guidDeviceIdentifier, &CLSID_DirectDraw, sizeof(pDI->di.guidDeviceIdentifier));

    //The device IDs get XORed into the whole GUID with the vendor and device ID in the 
    //first two DWORDs so they don't get XORed with anything else. This makes it 
    DDASSERT(sizeof(GUID) >= 4*sizeof(DWORD));
    pdw = (LPDWORD) &pDI->di.guidDeviceIdentifier;
    pdw[0] ^= pDI->di.dwVendorId;
    pdw[1] ^= pDI->di.dwDeviceId;
    pdw[2] ^= pDI->di.dwSubSysId;
    pdw[3] ^= pDI->di.dwRevision;

    // The driver version gets XORed into the last two DWORDs of the GUID:
    pdw[2] ^= pDI->di.liDriverVersion.LowPart;
    pdw[3] ^= pDI->di.liDriverVersion.HighPart;
}


void ParseDeviceId(LPDDDRIVERINFOEX pDI)
{
    char * p;

    DPF(5,"Parsing %s",pDI->szDeviceID);

    pDI->di.dwVendorId = 0;
    pDI->di.dwDeviceId = 0;
    pDI->di.dwSubSysId = 0;
    pDI->di.dwRevision = 0;

    if(p =_strstr(pDI->szDeviceID, "VEN_"))
        pDI->di.dwVendorId = _atoi( p + 4);

    if(p = _strstr(pDI->szDeviceID, "DEV_"))
        pDI->di.dwDeviceId = _atoi( p + 4);

    if(p = _strstr(pDI->szDeviceID, "SUBSYS_"))
        pDI->di.dwSubSysId = _atoi( p + 7);

    if(p = _strstr(pDI->szDeviceID, "REV_"))
        pDI->di.dwRevision = _atoi( p + 4);
}


HRESULT DDAPI DD_GetDeviceIdentifier( LPDIRECTDRAW lpDD, LPDDDEVICEIDENTIFIER pDI, DWORD dwFlags)
{
    DDDEVICEIDENTIFIER2         ddi2;
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    HRESULT                     hr;

    ZeroMemory(&ddi2, sizeof(ddi2));

    hr = DD_GetDeviceIdentifier7(lpDD, &ddi2, dwFlags);

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( VALID_DIRECTDRAW_PTR( this_int ) )
        {
            if (VALIDEX_DDDEVICEIDENTIFIER_PTR( pDI ))
            {
                CopyMemory(pDI,&ddi2,sizeof(*pDI));
            }
            else
            {
	        DPF_ERR( "Invalid version struct passed" );
	        hr = DDERR_INVALIDPARAMS;
            }
        }
        else
	{
	    DPF_ERR( "Invalid driver object passed" );
	    hr = DDERR_INVALIDOBJECT;
	}
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
        DPF_ERR("Exception encountered querying device info");
        hr = DDERR_INVALIDPARAMS;
    }


    return hr;
}

HRESULT InternalGetDeviceIdentifier7( LPDIRECTDRAW lpDD, LPDDDEVICEIDENTIFIER2 pDI, DWORD dwFlags, BOOL bWHQL)
{
    HRESULT                     hr=DD_OK;
    LPDDRAWI_DIRECTDRAW_INT     this_int;
    LPDDRAWI_DIRECTDRAW_LCL     this_lcl;
    LPDDRAWI_DIRECTDRAW_GBL     pdrv;
    int                         n;
    DISPLAY_DEVICEA             dd;
    DDDRIVERINFOEX              di;
    BOOL                        bFound;
#ifndef WINNT
    static char                 szWin9xName[MAX_DDDEVICEID_STRING];
#endif

    ENTER_DDRAW();

    TRY
    {
	this_int = (LPDDRAWI_DIRECTDRAW_INT) lpDD;
	if( VALID_DIRECTDRAW_PTR( this_int ) )
        {
	    this_lcl = this_int->lpLcl;
	    pdrv = this_lcl->lpGbl;

            if (VALIDEX_DDDEVICEIDENTIFIER2_PTR( pDI ))
            {
                /*
                 * Reset to something sensible
                 */
                ZeroMemory(&di,sizeof(di));
                #ifndef WINNT
                    szWin9xName[0] = '\0';
                #endif

                if (0 == (dwFlags & ~DDGDI_VALID) )
                {
                    /*
                     * First step: version info and name for the ddraw HAL driver (on 9x), and format it into a string
                     */
                    GetHALName(pdrv, &di);
                    GetFileVersionData(&di);

                    /* 
                     * If it's a 3dfx, it's easy
                     */
                    if ( 0 == (pdrv->dwFlags & DDRAWI_DISPLAYDRV) )
                    {
                        hr = Check3Dfx(&di);
                    }
                    else
                    {
                        /*
                         * Not a 3dfx.
                         */

                        /*
                         * Next step: Figure out which display device we really are and get description string for it
                         */
                        ZeroMemory(&dd, sizeof(dd));
                        dd.cb = sizeof(dd);

                        bFound=FALSE;

                        for( n=0; xxxEnumDisplayDevicesA( NULL, n, &dd, 0 ); n++ )
                        {
                            char * pDeviceName = pdrv->cDriverName;
            
                            //DDraw has this convention that the primary device is always DISPLAY. 

                            if (0 == _stricmp(dd.DeviceName, pdrv->cDriverName ) || 
                                ((dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE) &&
                                 (0 == _stricmp(pdrv->cDriverName , "DISPLAY")) ) )
                            {
                                /*
                                 * Found the device. Now we can get some data for it.
                                 */
                                lstrcpyn(di.di.szDescription, dd.DeviceString, sizeof(di.di.szDescription));
                                lstrcpyn(di.szDeviceID, dd.DeviceID, sizeof(di.szDeviceID) );

                                bFound = TRUE;

#ifdef WINNT
                                GetNTDriverNameAndVersion(&dd,&di);
#else

                                GetWin9XDriverName(&dd, szWin9xName);
                                if( di.di.szDriver[0] == '\0' )
                                {
                                    lstrcpyn( di.di.szDriver, szWin9xName, sizeof(di.di.szDriver) );
                                }
#endif

                                break;
                            }

                            ZeroMemory(&dd, sizeof(dd));
                            dd.cb = sizeof(dd);
                        }

                        /*
                         * Final step: Go get the pnp id of the chipset
                         */
                        if (!bFound)
                        {
                            /*
                             * Didn't find it: xxxEnumDisplayDevices failed, i.e. we're on 9x or NT4,
                             */
                            if (FAILED(GetDriverInfoFromRegistry("Display", NULL, NULL, &di)))
		            {
			        DPF_ERR("Couldn't get registry data for display");
                                hr = DDERR_NOTFOUND;
		            }
                        }
                    }

                    if (SUCCEEDED(hr))
                    {
                        ParseDeviceId(&di);

                        /*
                         * Finally, for the primary only, check if a PowerVR is in and functioning
                         */
                        if (0 == (dwFlags & DDGDI_GETHOSTIDENTIFIER) )
                        {
                            if (IsVGADevice(pdrv->cDriverName) && CheckPowerVR(pdrv, &di))
                            {
                                ParseDeviceId(&di);
                            }
                        }

                        /*
                         * Munge driver version and ID into the identifier GUID.
                         */
                        GenerateIdentifier(&di);
                    }

                }
                else
                {
	            DPF_ERR( "Invalid flags passed" );
	            hr = DDERR_INVALIDPARAMS;
                }

                /*
                 * Finally copy the struct, or 0s if failed, to the app's buffer
                 */
                CopyMemory(pDI,&di.di,offsetof(DDDEVICEIDENTIFIER2,dwWHQLLevel) + sizeof(DWORD));

                /*
                 * Our compiler packs structs to 8 byte boundaries, but this struct is only 4 byte aligned.
                 * In short, sizeof(*pDI) == 1072, but the actual size is 1068, so we cannot copy the 
                 * buffer using sizeof, so we instead do the above wackiness.  We need to assert, however,
                 * so we can fix this if this structure ever grows.
                 */
                DDASSERT((sizeof(*pDI) - (offsetof(DDDEVICEIDENTIFIER2,dwWHQLLevel) + sizeof(DWORD))) <= 4);

                if (bWHQL)
                {
                    #ifdef WINNT
                        pDI->dwWHQLLevel=GetWHQLLevel((LPTSTR)&di.di.szDriver, NULL);
                    #else
                        pDI->dwWHQLLevel=GetWHQLLevel((LPTSTR)&di.di.szDriver, szWin9xName);
                    #endif
                }
                else
                {
                    pDI->dwWHQLLevel = 0;
                }

                /*
                 * lets find out here if driver is WHQL certified
                 */

            }
            else
            {
	        DPF_ERR( "Invalid version struct passed" );
	        hr = DDERR_INVALIDPARAMS;
            }
        }
        else
	{
	    DPF_ERR( "Invalid driver object passed" );
	    hr = DDERR_INVALIDOBJECT;
	}
    }
    EXCEPT(EXCEPTION_EXECUTE_HANDLER)
    {
        DPF_ERR("Exception encountered querying device info");
        hr = DDERR_INVALIDPARAMS;
    }

    LEAVE_DDRAW();
    return hr;
}


HRESULT DDAPI DD_GetDeviceIdentifier7( LPDIRECTDRAW lpDD, LPDDDEVICEIDENTIFIER2 pDI, DWORD dwFlags)
{
    return InternalGetDeviceIdentifier7 (lpDD, pDI, dwFlags, TRUE);
}


/*
 * Voodoo1GoodToGo
 *
 * The Voodoo 1 driver will succeed the CreateDC call on Voodoo 2, Voodoo 3,
 * or Banshee hardware, but if we use the driver beyond that it will hang
 * the hardware.  This is a work around to not enumerate a Voodoo 1
 * driver if the hardware isn't there.
 *
 * To our knowledge, only two guids were ever used to enumerate Voodoo1
 * hardware, so we will look for those guids and assume that anything else
 * doesn't need to be checked.
 */
BOOL Voodoo1GoodToGo( GUID * pGuid )
{
    DDDRIVERINFOEX DI;

    if (IsEqualIID(pGuid, &guidVoodoo1A) || IsEqualIID(pGuid, &guidVoodoo1B) )
    {
        #ifdef WIN95
            /*
             * Now search the hardware enum key to see if Voodoo 1 hardware exists
             */
            if (FAILED(_GetDriverInfoFromRegistry(NULL, "Display", VEN_3DFXVOODOO1, &DI)))
            {
                return FALSE;
            }
        #else
            return FALSE;
        #endif
    }
    return TRUE;
}

#ifndef WINNT
/****************************************************************************
 *
 *  FileIsSignedOld
 *
 *  find win95 style of signature
 *
 ****************************************************************************/
BOOL FileIsSignedOld(LPTSTR lpszFile)
{
typedef struct tagIMAGE_DOS_HEADER      // DOS .EXE header
{
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
} IMAGE_DOS_HEADER, * PIMAGE_DOS_HEADER, FAR* LPIMAGE_DOS_HEADER;

typedef struct tagIMAGE_OS2_HEADER      // OS/2 .EXE header
{
    WORD   ne_magic;                    // Magic number
    CHAR   ne_ver;                      // Version number
    CHAR   ne_rev;                      // Revision number
    WORD   ne_enttab;                   // Offset of Entry Table
    WORD   ne_cbenttab;                 // Number of bytes in Entry Table
    LONG   ne_crc;                      // Checksum of whole file
    WORD   ne_flags;                    // Flag word
    WORD   ne_autodata;                 // Automatic data segment number
    WORD   ne_heap;                     // Initial heap allocation
    WORD   ne_stack;                    // Initial stack allocation
    LONG   ne_csip;                     // Initial CS:IP setting
    LONG   ne_sssp;                     // Initial SS:SP setting
    WORD   ne_cseg;                     // Count of file segments
    WORD   ne_cmod;                     // Entries in Module Reference Table
    WORD   ne_cbnrestab;                // Size of non-resident name table
    WORD   ne_segtab;                   // Offset of Segment Table
    WORD   ne_rsrctab;                  // Offset of Resource Table
    WORD   ne_restab;                   // Offset of resident name table
    WORD   ne_modtab;                   // Offset of Module Reference Table
    WORD   ne_imptab;                   // Offset of Imported Names Table
    LONG   ne_nrestab;                  // Offset of Non-resident Names Table
    WORD   ne_cmovent;                  // Count of movable entries
    WORD   ne_align;                    // Segment alignment shift count
    WORD   ne_cres;                     // Count of resource segments
    BYTE   ne_exetyp;                   // Target Operating system
    BYTE   ne_flagsothers;              // Other .EXE flags
    WORD   ne_pretthunks;               // offset to return thunks
    WORD   ne_psegrefbytes;             // offset to segment ref. bytes
    WORD   ne_swaparea;                 // Minimum code swap area size
    WORD   ne_expver;                   // Expected Windows version number
} IMAGE_OS2_HEADER, * PIMAGE_OS2_HEADER, FAR* LPIMAGE_OS2_HEADER;

typedef struct tagWINSTUB
{
    IMAGE_DOS_HEADER idh;
    BYTE             rgb[14];
} WINSTUB, * PWINSTUB, FAR* LPWINSTUB;

typedef struct tagFILEINFO
{
    BYTE   cbInfo[0x120];
} FILEINFO, * PFILEINFO, FAR* LPFILEINFO;


    FILEINFO           fi;
    int                nRC;
    LPIMAGE_DOS_HEADER lpmz;
    LPIMAGE_OS2_HEADER lpne;
    BYTE               cbInfo[9+32+2];
    BOOL               IsSigned = FALSE;
    OFSTRUCT           OpenStruct;
    HFILE              hFile;

    static WINSTUB winstub = {
        {
            IMAGE_DOS_SIGNATURE,            /* magic */
            0,                              /* bytes on last page - varies */
            0,                              /* pages in file - varies */
            0,                              /* relocations */
            4,                              /* paragraphs in header */
            1,                              /* min allocation */
            0xFFFF,                         /* max allocation */
            0,                              /* initial SS */
            0xB8,                           /* initial SP */
            0,                              /* checksum (ha!) */
            0,                              /* initial IP */
            0,                              /* initial CS */
            0x40,                           /* lfarlc */
            0,                              /* overlay number */
            { 0, 0, 0, 0},                 /* reserved */
           0,                              /* oem id */
            0,                              /* oem info */
            0,                              /* compiler bug */
            { 0},                          /* reserved */
            0x80,                           /* lfanew */
        },
        {
            0x0E, 0x1F, 0xBA, 0x0E, 0x00, 0xB4, 0x09, 0xCD,
            0x21, 0xB8, 0x01, 0x4C, 0xCD, 0x21,
        }
    };

    OpenStruct.cBytes = sizeof( OpenStruct );
    lstrcpyn( OpenStruct.szPathName, lpszFile, OFS_MAXPATHNAME );
    hFile = OpenFile(lpszFile, &OpenStruct, OF_READ);
    if (hFile == HFILE_ERROR )
    {
        return FALSE;
    }

    nRC = 0;
    ReadFile( (HANDLE) hFile, (LPVOID)&fi, sizeof(FILEINFO), &nRC, NULL);
    if (nRC != sizeof(FILEINFO))
    {
        goto FileIsSigned_exit;
    }

    lpmz = (LPIMAGE_DOS_HEADER)(&fi);
    lpne = (LPIMAGE_OS2_HEADER)((WORD)&fi + 0x80);

    winstub.idh.e_cblp = lpmz->e_cblp;
    winstub.idh.e_cp   = lpmz->e_cp;

    if (memcmp(&fi, &winstub, sizeof(winstub)) == 0)
    {
        goto FileIsSigned_exit;
    }

    memcpy(cbInfo, &((PWINSTUB)(&fi)->cbInfo)->rgb[14], sizeof(cbInfo));

    if ( (cbInfo[4]      != ' ' ) ||    // space
         (cbInfo[8]      != ' ' ) ||    // space
         (cbInfo[9+32]   != '\n') ||    // return
         (cbInfo[9+32+1] != '$' ) )     // Dollar Sign
    {
        goto FileIsSigned_exit;
    }

    cbInfo[4] = 0;
    cbInfo[8] = 0;

    if ( (strcmp((const char*)&cbInfo[0], "Cert") != 0) ||
         (strcmp((const char*)&cbInfo[5], "DX2")  != 0) )
    {
        goto FileIsSigned_exit;
    }

    IsSigned=TRUE;

    FileIsSigned_exit:

    _lclose( hFile );

    return IsSigned;
}
#endif


/*
 * GetWHQLLevel - On Win95, look for old stamp only.  On Win2000, use digital
 *		signature only.  On Win98, look for old stamp first, then digital signature
 *		if no old stamp.
 *
 *      return 0 -- unsigned or uncertified
 *      return 1 -- driver certified
 *      return 1997 -- driver certified, PC97 compliant...
 *      return 1998...
 *
 *
 * arguments:
 *      
 * lpszDriver----Path of driver file
 * 
 */

DWORD GetWHQLLevel(LPTSTR lpszDriver, LPSTR lpszWin9xDriver)
{
    TCHAR szTmp[MAX_PATH];
    DWORD dwWhqlLevel = 0;

    // here we should rather call 
    if (GetSystemDirectory( szTmp, MAX_PATH-lstrlen(lpszDriver)-2)==0)
        return 0;

    lstrcat( szTmp, TEXT("\\"));
    lstrcat( szTmp, lpszDriver); 
    _tcslwr( szTmp);

    //
    // Look for a digital signature
    //
    dwWhqlLevel = IsFileDigitallySigned(szTmp);
    if( dwWhqlLevel != 0 )
    {
        return dwWhqlLevel;
    }


#ifndef WINNT 
    
    // It wasn't digitally signed, but it may still have been signed
    // the old way.  On Win9X, however, lpszDriver actually contains the
    // 32 bit HAL name rather than the display driver, but we typically only
    // signed the display driver, so we should use lpszWin9xDriver.

    if( lpszWin9xDriver[0] != '\0' )
    {
        GetSystemDirectory( szTmp, MAX_PATH-lstrlen(lpszWin9xDriver)-2);
        lstrcat( szTmp, TEXT("\\"));
        lstrcat( szTmp, lpszWin9xDriver); 
    }
    else
    {
        GetSystemDirectory( szTmp, MAX_PATH-lstrlen(lpszDriver)-2);
        lstrcat( szTmp, TEXT("\\"));
        lstrcat( szTmp, lpszDriver); 
    }

    if (FileIsSignedOld(szTmp))
    {
        return 1;
    }
#endif

    return 0;
}


DWORD IsFileDigitallySigned(LPTSTR lpszDriver)
{
    DWORD  dwWHQLLevel=0;         // default, driver not certified
    CATAPI catapi;
    WCHAR *lpFileName;
    DRIVER_VER_INFO VerInfo;
    TCHAR szBuffer[50];
    LPSTR lpAttr;
#ifndef UNICODE
    WCHAR wszDriver[MAX_PATH];
    MultiByteToWideChar(CP_ACP, 0, lpszDriver, -1, wszDriver, MAX_PATH);
    lpFileName = wcsrchr(wszDriver, TEXT('\\'));
    if (lpFileName==NULL)
    {
        lpFileName = wszDriver;
    }
    else
    {
        lpFileName++;
    }
#else
    lpFileName = _tcsrchr(lpszDriver, TEXT('\\'));
    if (lpFileName==NULL) lpFileName = lpszDriver;
#endif


    //
    //  try to load and initialize the mscat32.dll and wintrust.dll
    //  these dlls are not available on win95
    //
    if (InitCATAPI(&catapi))
    {
        HANDLE hFile;
        DWORD  cbHashSize=0;
        BYTE  *pbHash;
        BOOL   bResult;

        //
        //  create a handle to our driver, because cat api wants handle to file
        //
        hFile = CreateFile( lpszDriver,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            0,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            0
                            );

        if (hFile!=INVALID_HANDLE_VALUE) 
        {
            // first query hash size...
            bResult=(*catapi.pCryptCATAdminCalcHashFromFileHandle)(hFile,
                                &cbHashSize,
                                NULL,
                                0);
            pbHash=NULL;
            if (bResult)
            {
                // allocate hash
                pbHash = LocalAlloc( LPTR, cbHashSize);                                       
            } 

            if (pbHash!=NULL)
            {
                HCATINFO hPrevCat=NULL;
                HANDLE hCatalog=NULL;
                WINTRUST_DATA WinTrustData;
                WINTRUST_CATALOG_INFO WinTrustCatalogInfo;
                GUID  guidSubSystemDriver = DRIVER_ACTION_VERIFY;
                CRYPTCATATTRIBUTE *lpCat = NULL;

                //
                //  Now get the hash for our file
                //

                bResult=(*catapi.pCryptCATAdminCalcHashFromFileHandle)(hFile,
                                    &cbHashSize,
                                    pbHash,
                                    0);

                if (bResult)
                {
                    hCatalog=(*catapi.pCryptCATAdminEnumCatalogFromHash)(
                                    catapi.hCatAdmin,
                                    pbHash,
                                    cbHashSize,
                                    0,
                                    &hPrevCat);
                }

                //
                // Initialize the structures that
                // will be used later on in calls to WinVerifyTrust.
                //
                ZeroMemory(&WinTrustData, sizeof(WINTRUST_DATA));
                WinTrustData.cbStruct = sizeof(WINTRUST_DATA);
                WinTrustData.dwUIChoice = WTD_UI_NONE;
                WinTrustData.fdwRevocationChecks = WTD_REVOKE_NONE;
                WinTrustData.dwUnionChoice = WTD_CHOICE_CATALOG;
                WinTrustData.dwStateAction = WTD_STATEACTION_AUTO_CACHE;
                WinTrustData.pPolicyCallbackData = (LPVOID)&VerInfo;

                ZeroMemory(&VerInfo, sizeof(DRIVER_VER_INFO));
                VerInfo.cbStruct = sizeof(DRIVER_VER_INFO);

                WinTrustData.pCatalog = &WinTrustCatalogInfo;
        
                ZeroMemory(&WinTrustCatalogInfo, sizeof(WINTRUST_CATALOG_INFO));
                WinTrustCatalogInfo.cbStruct = sizeof(WINTRUST_CATALOG_INFO);
                WinTrustCatalogInfo.pbCalculatedFileHash = pbHash;
                WinTrustCatalogInfo.cbCalculatedFileHash = cbHashSize;
                WinTrustCatalogInfo.pcwszMemberTag = lpFileName;

                while (hCatalog)
                {
                    CATALOG_INFO CatInfo;

                    ZeroMemory(&CatInfo, sizeof(CATALOG_INFO));
                    CatInfo.cbStruct = sizeof(CATALOG_INFO);
                    if((*catapi.pCryptCATCatalogInfoFromContext)(hCatalog, &CatInfo, 0)) 
                    {
                        HRESULT hRes;

                        WinTrustCatalogInfo.pcwszCatalogFilePath = CatInfo.wszCatalogFile;

                        // Now verify that the file is an actual member of the catalog.
                        hRes = (*catapi.pWinVerifyTrust)
                            (NULL, &guidSubSystemDriver, &WinTrustData);

                        if (hRes == ERROR_SUCCESS)
                        {
                            //
                            // Our driver is certified!  Now see if the cat
                            // info contains the WHQL level
                            //
                            CRYPTCATATTRIBUTE *lpCat = NULL;
                            HANDLE hCat;

                            dwWHQLLevel=1;              // return "certified"

                            hCat =  (*catapi.pCryptCATOpen)(CatInfo.wszCatalogFile, (DWORD)CRYPTCAT_OPEN_EXISTING, (HCRYPTPROV)NULL, 0, 0);
                            lpCat = (*catapi.pCryptCATGetCatAttrInfo) (hCat, L"KV_DISPLAY");
                            if( lpCat != NULL )
                            {
                                WideCharToMultiByte(CP_ACP, 0, (PUSHORT)lpCat->pbValue, -1, szBuffer, 50, NULL, NULL);

                                // The value looks like "1:yyyy-mm-dd".
          
                                lpAttr = _strstr( szBuffer, ":");
                                lpAttr++;
                                lpAttr[4] = '\0';
                                dwWHQLLevel = atoi( lpAttr ) * 0x10000;
                                lpAttr[7] = '\0';
                                dwWHQLLevel |= atoi( &lpAttr[5]) * 0x100;
                                dwWHQLLevel |= atoi( &lpAttr[8]);
                            }

                            (*catapi.pCryptCATClose)(hCat);
                            break;
                        }
                    }

                    //
                    // iterate through catalogs...
                    //
                    hPrevCat=hCatalog;
                    hCatalog=(*catapi.pCryptCATAdminEnumCatalogFromHash)(
                                catapi.hCatAdmin,
                                pbHash,
                                cbHashSize,
                                0,
                                &hPrevCat);
                }

                //
                // we might have to free a catalog context!
                //
                if (hCatalog)
                {
                    (*catapi.pCryptCATAdminReleaseCatalogContext)
                        (catapi.hCatAdmin, hCatalog, 0);
                }

                //
                //  free hash
                //
                LocalFree(pbHash);

            }

            CloseHandle(hFile);
        }
    }

    ReleaseCATAPI(&catapi);

    return dwWHQLLevel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\decoder.h ===
#include <atlbase.h>
//extern CComModule _Module;

struct FILTERINFO
{
int                 _colorMode;
ULONG               m_nBytesPerPixel;
DWORD               dwEvents;
IDirectDrawSurface  *m_pDDrawSurface;
};

class CImageDecodeEventSink : public IImageDecodeEventSink
{
public:
    void Init( FILTERINFO * pFilter );
//    CImageDecodeEventSink( FILTERINFO * pFilter );
//    ~CImageDecodeEventSink();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHOD(QueryInterface)(REFIID iid, void** ppInterface);

    STDMETHOD(GetSurface)(LONG nWidth, LONG nHeight, REFGUID bfid, 
        ULONG nPasses, DWORD dwHints, IUnknown** ppSurface);
    STDMETHOD(GetDDrawSurface)(LONG nWidth, LONG nHeight, REFGUID bfid, 
        ULONG nPasses, DWORD dwHints, IUnknown** ppSurface);
    STDMETHOD(OnBeginDecode)(DWORD* pdwEvents, ULONG* pnFormats, 
        GUID** ppFormats);
    STDMETHOD(OnBitsComplete)();
    STDMETHOD(OnDecodeComplete)(HRESULT hrStatus);
    STDMETHOD(OnPalette)();
    STDMETHOD(OnProgress)(RECT* pBounds, BOOL bFinal);

    void SetDDraw( IDirectDraw4 *pDDraw ) {m_pDirectDrawEx = pDDraw;}

    ULONG                       m_nRefCount;
    FILTERINFO                  *m_pFilter;
    IDirectDrawSurface          *m_pDDrawSurface;
    RECT                        m_rcProg;
    DWORD                       m_dwLastTick;
    IDirectDraw4                *m_pDirectDrawEx;
//    friend CDirectDrawEx;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\init.cpp ===
#define INITGUID

#define this _this
#include "ddrawpr.h"
#undef this
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\dmemmgr.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	dmemmgr.h
 *  Content:	Direct Memory Manager include file
 *
 ***************************************************************************/

#ifndef __DMEMMGR_INCLUDED__
#define __DMEMMGR_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __NTDDKCOMP__

/*
 * pointer to video memory
 */
typedef ULONG_PTR FLATPTR;

typedef struct _VIDMEM *LPVIDMEM;

#else

/*
 * pointer to video memory, potentially 64-bit
 */
typedef ULONG_PTR FLATPTR;

typedef struct _VIDEOMEMORY *LPVIDMEM;

#endif

/*
 * Structure for querying extended heap alignment requirements
 */

typedef struct _SURFACEALIGNMENT
{
    union
    {
        struct
        {
            DWORD       dwStartAlignment;
            DWORD       dwPitchAlignment;
            DWORD       dwReserved1;
            DWORD       dwReserved2;
        } Linear;
        struct
        {
            DWORD       dwXAlignment;
            DWORD       dwYAlignment;
            DWORD       dwReserved1;
            DWORD       dwReserved2;
        } Rectangular;
    };
} SURFACEALIGNMENT;
typedef struct _SURFACEALIGNMENT FAR *LPSURFACEALIGNMENT;

typedef struct _HEAPALIGNMENT
{
    DWORD                dwSize;
    DDSCAPS              ddsCaps;       /* Indicates which alignment fields are valid.*/
    DWORD                dwReserved;
    SURFACEALIGNMENT     ExecuteBuffer; /* Surfaces tagged with DDSCAPS_EXECUTEBUFFER */
    SURFACEALIGNMENT     Overlay;       /* Surfaces tagged with DDSCAPS_OVERLAY       */
    SURFACEALIGNMENT     Texture;       /* Surfaces tagged with DDSCAPS_TEXTURE       */
    SURFACEALIGNMENT     ZBuffer;       /* Surfaces tagged with DDSCAPS_ZBUFFER       */
    SURFACEALIGNMENT     AlphaBuffer;   /* Surfaces tagged with DDSCAPS_ALPHA         */
    SURFACEALIGNMENT     Offscreen;     /* Surfaces tagged with DDSCAPS_OFFSCREENPLAIN*/
    SURFACEALIGNMENT     FlipTarget;    /* Surfaces whose bits are potential primaries i.e. back buffers*/
} HEAPALIGNMENT;
typedef struct _HEAPALIGNMENT FAR *LPHEAPALIGNMENT;

/*
 * video memory manager structures
 */
typedef struct _VMEML
{
    struct _VMEML 	FAR *next;
    FLATPTR		ptr;
    DWORD		size;
} VMEML, FAR *LPVMEML, FAR * FAR *LPLPVMEML;

typedef struct _VMEMR
{
    struct _VMEMR 	FAR *next;
    struct _VMEMR       FAR *prev;
    /*
     * The pUp, pDown, pLeft and pRight members were removed in DX5
     */
    struct _VMEMR 	FAR *pUp;
    struct _VMEMR 	FAR *pDown;
    struct _VMEMR 	FAR *pLeft;
    struct _VMEMR 	FAR *pRight;
    FLATPTR		ptr;
    DWORD		size;
    DWORD               x;
    DWORD               y;
    DWORD               cx;
    DWORD               cy;
    DWORD		flags;
    FLATPTR             pBits;
} VMEMR, FAR *LPVMEMR, FAR * FAR *LPLPVMEMR;

typedef struct _VMEMHEAP
{
    DWORD		        dwFlags;
    DWORD                       stride;
    LPVOID		        freeList;
    LPVOID		        allocList;
    DWORD                       dwTotalSize;
    FLATPTR                     fpGARTLin;      /* AGP: GART linear base of heap (app. visible)   */
    FLATPTR                     fpGARTDev;      /* AGP: GART device base of heap (driver visible) */
    DWORD                       dwCommitedSize; /* AGP: Number of bytes commited to heap          */
    /*
     * Extended alignment data:
     * Filled in by DirectDraw in response to a GetHeapAlignment HAL call.
     */
    DWORD                       dwCoalesceCount;
    HEAPALIGNMENT               Alignment;
    /*
     * These are analogous to VIDMEM.ddsCaps and VIDMEM.ddsCapsAlt. These values are queried from the
     * driver by a GetDriverInfo call. See the documentation for GUID_DDMoreSurfaceCaps
     */
    DDSCAPSEX                   ddsCapsEx;
    DDSCAPSEX                   ddsCapsExAlt;
#ifndef IS_16
    // Full physical address of heap base for NT AGP heaps.
    LARGE_INTEGER               liPhysAGPBase;
#endif
    // hdev for use with VidMemAllocAligned on NT.  Set by the system at
    // initialization time.
    HANDLE                      hdevAGP;
    // Physical reservation handle for NT heaps.
    LPVOID                      pvPhysRsrv;
} VMEMHEAP;

typedef VMEMHEAP FAR *LPVMEMHEAP;

#define VMEMHEAP_LINEAR			0x00000001l /* Heap is linear                    */
#define VMEMHEAP_RECTANGULAR		0x00000002l /* Heap is rectangular               */
#define VMEMHEAP_ALIGNMENT  		0x00000004l /* Heap has extended alignment info  */

/*
 * This legacy export doesn't handle nonlocal heaps
 * This function is not available on Windows NT
 */
#ifndef __NTDDKCOMP__
extern FLATPTR WINAPI VidMemAlloc( LPVMEMHEAP pvmh, DWORD width, DWORD height );
#endif

/*
 * This export can be used by drivers to allocate aligned surfaces from heaps which
 * they have previously exposed to DirectDraw. This function can allocate from nonlocal heaps.
 */
extern FLATPTR WINAPI HeapVidMemAllocAligned(
                LPVIDMEM lpVidMem,
                DWORD dwWidth,
                DWORD dwHeight,
                LPSURFACEALIGNMENT lpAlignment ,
                LPLONG lpNewPitch );

/*
 * This export can free memory allocated via either allocation function
 */
extern void WINAPI VidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\dllmain.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dllinit.c
 *  Content:	DDRAW.DLL initialization
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   20-jan-95	craige	initial implementation
 *   21-feb-95	craige	disconnect anyone who forgot to do it themselves,
 *			use critical sections on Win95
 *   27-feb-95	craige 	new sync. macros
 *   30-mar-95	craige	process tracking/cleanup for Win95
 *   01-apr-95	craige	happy fun joy updated header file
 *   12-apr-95	craige	debug stuff for csects
 *   12-may-95	craige	define GUIDs
 *   24-jun-95	craige	track which processes attach to the DLL
 *   25-jun-95	craige	one ddraw mutex
 *   13-jul-95	craige	ENTER_DDRAW is now the win16 lock;
 *			proper initialization of csects
 *   16-jul-95	craige	work around weird kernel "feature" of getting a
 *			process attach of the same process during process detach
 *   19-jul-95	craige	process detach too much grief; let DDNotify handle it
 *   20-jul-95	craige	internal reorg to prevent thunking during modeset
 *   19-aug-95 davidmay restored call to disconnect thunk from 19-jul change
 *   26-sep-95	craige	bug 1364: create new csect to avoid dsound deadlock
 *   08-dec-95 jeffno 	For NT, critical section macros expand to use mutexes
 *   16-mar-96  colinmc Callback table initialization now happens on process
 *                      attach
 *   20-mar-96  colinmc Bug 13341: Made MemState() dump in process detach
 *                      thread safe
 *   07-may-96  colinmc Bug 20219: Simultaneous calls to LoadLibrary cause
 *                      a deadlock
 *   09-may-96  colinmc Bug 20219 (again): Yes the deadlock again - previous
 *                      fix was not enough.
 *   19-jan-97  colinmc AGP support
 *   26-jan-97	ketand	Kill globals for multi-mon.
 *   24-feb-97	ketand	Set up callback from DDHelp to update rects.
 *   03-mar-97  jeffno  Structure name change to avoid conflict w/ ActiveAccessibility
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   31-jul-97 jvanaken Bug 7907: Notify Memphis GDI when ddraw starts up
 *
 ***************************************************************************/

/*
 * unfortunately we have to break our pre-compiled headers to get our
 * GUIDS defined...
 */
#define INITGUID
#include "ddrawpr.h"
#include <initguid.h>
#ifdef WINNT
    #undef IUnknown
    #include <objbase.h>
#endif
#include "apphack.h"

#include "aclapi.h"

#ifdef WIN95
int main; // this is so we can avoid calling DllMainCRTStartup

extern BOOL _stdcall thk3216_ThunkConnect32(LPSTR      pszDll16,
                                 LPSTR      pszDll32,
                                 HINSTANCE  hInst,
                                 DWORD      dwReason);

extern BOOL _stdcall thk1632_ThunkConnect32(LPSTR      pszDll16,
                                 LPSTR      pszDll32,
                                 HINSTANCE  hInst,
                                 DWORD      dwReason);

DWORD _stdcall wWinMain(DWORD a, DWORD b, DWORD c, DWORD d)
{
#ifdef DEBUG
    OutputDebugString("WARNING: wWinMain called. \n");
#endif // DEBUG
    return 0;
}
#endif

#ifdef USE_CRITSECTS
    #define TMPDLLEVENT	"__DDRAWDLL_EVENT__"
#endif

#ifndef WIN16_SEPARATE
    #ifdef WIN95
        #define INITCSINIT() \
	        ReinitializeCriticalSection( &csInit ); \
	        MakeCriticalSectionGlobal( &csInit );
        #define ENTER_CSINIT() EnterCriticalSection( &csInit )
        #define LEAVE_CSINIT() LeaveCriticalSection( &csInit )
        extern CRITICAL_SECTION ddcCS;
        #define INITCSDDC() \
	        ReinitializeCriticalSection( &ddcCS ); \
	        MakeCriticalSectionGlobal( &ddcCS );
    #else
        #define CSINITMUTEXNAME "InitMutexName"
        #define INITCSINIT() \
                csInitMutex = CreateMutex(NULL,FALSE,CSINITMUTEXNAME);
        #define ENTER_CSINIT() \
                WaitForSingleObject(csInitMutex,INFINITE);
        #define LEAVE_CSINIT() \
                ReleaseMutex(csInitMutex);
        #define INITDDC()
    #endif
#endif

#ifdef WIN95
#define INITCSWINDLIST() \
	ReinitializeCriticalSection( &csWindowList ); \
	MakeCriticalSectionGlobal( &csWindowList );
#define INITCSDRIVEROBJECTLIST() \
	ReinitializeCriticalSection( &csDriverObjectList ); \
	MakeCriticalSectionGlobal( &csDriverObjectList );
#define FINIWINDLIST() 
#define FINICSDRIVEROBJECTLIST() 
#else
    // Each process needs its own handle, so these are not initialised so theyu won't end up in shared mem
    HANDLE              hDirectDrawMutex=(HANDLE)0;
    //This counts recursions into ddraw, so we don't try to do the mode uniqueness thing on recursive entries into ddraw
    DWORD               gdwRecursionCount=0;

    HANDLE              hWindowListMutex; //=(HANDLE)0;
    HANDLE              hDriverObjectListMutex; //=(HANDLE)0;
    HANDLE              csInitMutex;

    DWORD               dwNumLockedWhenModeSwitched;

    #define WINDOWLISTMUTEXNAME "DDrawWindowListMutex"
    #define DRIVEROBJECTLISTMUTEXNAME "DDrawDriverObjectListMutex"
    #define INITCSWINDLIST() \
	hWindowListMutex = CreateMutex(NULL,FALSE,WINDOWLISTMUTEXNAME);
    #define INITCSDRIVEROBJECTLIST() \
	hDriverObjectListMutex = CreateMutex(NULL,FALSE,DRIVEROBJECTLISTMUTEXNAME);
    #define FINIWINDLIST() CloseHandle(hWindowListMutex);
    #define FINICSDRIVEROBJECTLIST() CloseHandle(hDriverObjectListMutex);


#endif //win95

DWORD		            dwRefCnt=0;

DWORD                       dwLockCount=0;

DWORD                       dwFakeCurrPid=0;
DWORD                       dwGrimReaperPid=0;

LPDDWINDOWINFO	            lpWindowInfo=0;  // the list of WINDOWINFO structures
LPDDRAWI_DIRECTDRAW_LCL     lpDriverLocalList=0;
LPDDRAWI_DIRECTDRAW_INT     lpDriverObjectList=0;
volatile DWORD	            dwMarker=0;
    /*
     * This is the globally maintained list of clippers not owned by any
     * DirectDraw object. All clippers created with DirectDrawClipperCreate
     * are placed on this list. Those created by IDirectDraw_CreateClipper
     * are placed on the clipper list of thier owning DirectDraw object.
     *
     * The objects on this list are NOT released when an app's DirectDraw
     * object is released. They remain alive until explictly released or
     * the app. dies.
     */
LPDDRAWI_DDRAWCLIPPER_INT   lpGlobalClipperList=0;

HINSTANCE		    hModule=0;
LPATTACHED_PROCESSES        lpAttachedProcesses=0;
BOOL		            bFirstTime=0;

#ifdef DEBUG
    int	                    iDLLCSCnt=0;
    int	                    iWin16Cnt=0;
#endif

    /*
     * These variable are so we can handle more than one window in the
     * topmost window timer.
     */
HWND 			    ghwndTopmostList[MAX_TIMER_HWNDS];
int 			    giTopmostCnt = 0;

        /*
         * Winnt specific global statics
         */
#ifdef WINNT
    ULONG                   uDisplaySettingsUnique=0;
#endif

        /*
         *Hel globals:
         */

    // used to count how many drivers are currently using the HEL
DWORD	                    dwHELRefCnt=0;
    // keep these around to pass to blitlib. everytime we blt to/from a surface, we
    // construct a BITMAPINFO for that surface using gpbmiSrc and gpbmiDest
LPBITMAPINFO                gpbmiSrc=0;
LPBITMAPINFO                gpbmiDest=0;

#ifdef DEBUG
        // these are used by myCreateSurface
    int                     gcSurfMem=0; // surface memory in bytes
    int                     gcSurf=0;  // number of surfaces
#endif

DWORD	                    dwHelperPid=0;

#ifdef USE_CHEAP_MUTEX
    #ifdef WINNT
        #pragma data_seg("share")
    #endif

    GLOBAL_SHARED_CRITICAL_SECTION CheapMutexCrossProcess={0};

    #ifdef WINNT
        #pragma data_seg(".data")
    #endif

#endif //0

/*
 * App compatibility stuff. Moved here from apphack.c
 */

BOOL	                    bReloadReg=FALSE;
BOOL		            bHaveReadReg=FALSE;
LPAPPHACKS	            lpAppList=NULL;
LPAPPHACKS	            *lpAppArray=NULL;
DWORD		            dwAppArraySize=0;

/*
 * Global head of DC/Surface association list
 * This list is usually very very short, so we take the hit of extra pointers
 * just so that we don't have to traverse the entire list of surfaces.
 */
DCINFO *g_pdcinfoHead = NULL;


BYTE szDeviceWndClass[] = "DirectDrawDeviceWnd";

/*
 * Gamma calibration globals.  This determines weather a calibrator exists
 * and the handle to the DLL if it's loaded.
 */
BOOL                       bGammaCalibratorExists=FALSE;
BYTE                       szGammaCalibrator[MAX_PATH]="";

/*
 * Optional refresh rate to force for all modes.
 */
DWORD dwForceRefreshRate;

/*
 * Spinlocks for startup synchronization.
 * It's just too hard to use events when NT ddraw is per-process and 9x is cross-
 */
DWORD   dwSpinStartup=0;
DWORD   dwHelperSpinStartup=0;


#ifdef USE_CHEAP_MUTEX
    /*
     * This is the global variable pointer.
     */
    GLOBAL_LOCAL_CRITICAL_SECTION CheapMutexPerProcess;
#endif

/*
 * These two keep w95help.c happy. They point to the dwHelperPid and hModule entries in the process's
 * mapping of the GLOBALS structure.
 */
DWORD	* pdwHelperPid=&dwHelperPid;
HANDLE	* phModule=&hModule;

#ifdef WINNT
/*
 * This mutex is owned by the exclusive mode owner
 */
HANDLE              hExclusiveModeMutex=0;
HANDLE              hCheckExclusiveModeMutex=0;
#define EXCLUSIVE_MODE_MUTEX_NAME "__DDrawExclMode__"
#define CHECK_EXCLUSIVE_MODE_MUTEX_NAME "__DDrawCheckExclMode__"
#endif

//#endif

/*
 *-------------------------------------------------------------------------
 */

#if defined(WIN95) || defined(NT_USES_CRITICAL_SECTION)
    static CRITICAL_SECTION DirectDrawCSect;
    CSECT_HANDLE	lpDDCS;
#endif

/*
 * Win95 specific global statics
 */

#ifdef WIN95
    LPVOID	        lpWin16Lock;

    static CRITICAL_SECTION csInit = {0};
    CRITICAL_SECTION	csWindowList;
    CRITICAL_SECTION    csDriverObjectList;
#endif

#define HELPERINITDLLEVENT "__DDRAWDLL_HELPERINIT_EVENT__"

/*
 * DllMain
 */
BOOL WINAPI DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{
    LPATTACHED_PROCESSES	lpap;
    DWORD			pid;
    BOOL                        didhelp;

    dwMarker = 0x56414C4D;

    pid = GetCurrentProcessId();

    switch( dwReason )
    {
    case DLL_PROCESS_ATTACH:

        pdwHelperPid=&dwHelperPid;
        phModule=&hModule;


        DisableThreadLibraryCalls( hmod );
	DPFINIT();

	/*
	 * create the DirectDraw csect
	 */
	DPF( 4, "====> ENTER: DLLMAIN(%08lx): Process Attach: %08lx, tid=%08lx", DllMain,
			pid, GetCurrentThreadId() );

	#ifdef WIN95
	    if( lpWin16Lock == NULL )
	    {
		GetpWin16Lock( &lpWin16Lock );
	    }
	#endif
	#ifdef USE_CRITSECTS
	{

	    #if defined( WIN16_SEPARATE ) && (defined(WIN95) || defined(NT_USES_CRITICAL_SECTION))
		lpDDCS = &DirectDrawCSect;
	    #endif

	    /*
	     * is this the first time?
	     */
	    if( FALSE == InterlockedExchange( &bFirstTime, TRUE ) )
	    {
		#ifdef WIN16_SEPARATE
		    INIT_DDRAW_CSECT();
		    INITCSWINDLIST();
		    INITCSDRIVEROBJECTLIST();
		    ENTER_DDRAW_INDLLMAIN();
		#else
		    INITCSDDC();		// used in DirectDrawCreate
		    INITCSINIT();
		    ENTER_CSINIT();
		#endif

                hModule = hmod;
	        /*
	         * This event is signaled when DDHELP has successfully finished
	         * initializing. Threads other that the very first one to connect
	         * and the one spawned by DDHELP must wait for this event to
	         * be signaled as deadlock will result if they run through
	         * process attach before the DDHELP thread has.
	         *
	         * NOTE: The actual deadlock this prevents is pretty unusual so
	         * if we fail to create this event we will simply continue. Its
	         * highly unlikely anyone will notice (famous last words).
	         *
	         * CMcC
	         */
                /*
                 * Replaced events with spinlocks to work around a handle leak
                 */
                InterlockedExchange( & dwSpinStartup , 1);
	    }
	    /*
	     * second or later time through, wait for first time to
	     * finish and then take the csect
	     */
	    else
	    {
                /*
                 * Spin waiting for the first thread to exit the clause above
                 * This strange construction works around a compiler bug.
                 * while (dwHelperSpinStartup==1); generates an infinite loop.
                 */
                while (1)
                {
                    if (dwSpinStartup==1)
                        break;
                }

		#ifdef WIN16_SEPARATE
                #if defined( WINNT )
                    //Each process needs its own handle in NT
		    INIT_DDRAW_CSECT();
                #endif
		    ENTER_DDRAW_INDLLMAIN();
		#else
		    ENTER_CSINIT();
		#endif

	    }
	}
	#endif

        #ifdef WINNT
            {
                SECURITY_ATTRIBUTES sa;
                SID_IDENTIFIER_AUTHORITY sia = SECURITY_WORLD_SID_AUTHORITY;
                PSID adminSid = 0;
                ULONG cbAcl;
                PACL acl=0;
                PSECURITY_DESCRIPTOR pSD;
                BYTE buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
                BOOL bSecurityGooSucceeded = FALSE;
                //Granny's old fashioned LocalAlloc:
                BYTE Buffer1[256];
                BYTE Buffer2[16];

                // Create the SID for world
                cbAcl = GetSidLengthRequired(1);
                if (cbAcl < sizeof(Buffer2))
                {
                    adminSid = (PSID) Buffer2;
                    InitializeSid(
                        adminSid,
                        &sia,
                        1
                        );
                    *GetSidSubAuthority(adminSid, 0) = SECURITY_WORLD_RID;
                  
                   // Create an ACL giving World all access.
                    cbAcl = sizeof(ACL) +
                                 (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                                 GetLengthSid(adminSid);
                    if (cbAcl < sizeof(Buffer1))
                    {
                        acl = (PACL)&Buffer1;
                        if (InitializeAcl(
                            acl,
                            cbAcl,
                            ACL_REVISION
                            ))
                        {
                            if (AddAccessAllowedAce(
                                acl,
                                ACL_REVISION,
                                SYNCHRONIZE|MUTANT_QUERY_STATE|DELETE|READ_CONTROL, //|WRITE_OWNER|WRITE_DAC,
                                adminSid
                                ))
                            {
                                // Create a security descriptor with the above ACL.
                                pSD = (PSECURITY_DESCRIPTOR)buffer;
                                if (InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
                                {
                                    if (SetSecurityDescriptorDacl(pSD, TRUE, acl, FALSE))
                                    {
                                        // Fill in the SECURITY_ATTRIBUTES struct.
                                        sa.nLength = sizeof(sa);
                                        sa.lpSecurityDescriptor = pSD;
                                        sa.bInheritHandle = TRUE;

                                        bSecurityGooSucceeded = TRUE;
                                    }
                                }
                            }
                        }
                    }
                } 

                // Use the security attributes to create the mutexes
                DDASSERT(0 == hExclusiveModeMutex);
                hExclusiveModeMutex = CreateMutex( 
                    bSecurityGooSucceeded ? &sa : NULL,     //use default access if security goo failed.
                    FALSE, 
                    EXCLUSIVE_MODE_MUTEX_NAME );

                if (0 == hExclusiveModeMutex)
                {
                    hExclusiveModeMutex = OpenMutex(
                        SYNCHRONIZE|DELETE,  // access flag
                        FALSE,    // inherit flag
                        EXCLUSIVE_MODE_MUTEX_NAME          // pointer to mutex-object name
                        );
                }
 
	        if( hExclusiveModeMutex == 0 )
	        {
		    DPF_ERR("Could not create exclusive mode mutex. exiting" );
		    #ifdef WIN16_SEPARATE
		        LEAVE_DDRAW();
		    #else
		        LEAVE_CSINIT();
		    #endif
		    return FALSE;
	        }

                DDASSERT(0 == hCheckExclusiveModeMutex);
                hCheckExclusiveModeMutex = CreateMutex( 
                    bSecurityGooSucceeded ? &sa : NULL,     //use default access if security goo failed.
                    FALSE, 
                    CHECK_EXCLUSIVE_MODE_MUTEX_NAME );

                if (0 == hCheckExclusiveModeMutex)
                {
                    hCheckExclusiveModeMutex = OpenMutex(
                        SYNCHRONIZE|DELETE,  // access flag
                        FALSE,    // inherit flag
                        CHECK_EXCLUSIVE_MODE_MUTEX_NAME          // pointer to mutex-object name
                        );
                }

	        if( hCheckExclusiveModeMutex == 0 )
	        {
		    DPF_ERR("Could not create exclusive mode check mutex. exiting" );
                    CloseHandle( hExclusiveModeMutex );
		    #ifdef WIN16_SEPARATE
		        LEAVE_DDRAW();
		    #else
		        LEAVE_CSINIT();
		    #endif
		    return FALSE;
	        }
            }
        #endif


	#ifdef WIN95
	{
	    DWORD	hpid;

	    /*
	     * get the helper process started
	     */
	    didhelp = CreateHelperProcess( &hpid );
	    if( hpid == 0 )
	    {
		DPF( 0, "Could not start helper; exiting" );
		#ifdef WIN16_SEPARATE
		    LEAVE_DDRAW();
		#else
		    LEAVE_CSINIT();
		#endif
		return FALSE;
	    }


	    /*
	     * You get three kinds of threads coming through
	     * process attach:
	     *
	     * 1) A thread belonging to the first process to
	     *    connect to DDRAW.DLL. This is distinguished as
	     *    it performs lots of one time initialization
	     *    including starting DDHELP and getting DDHELP
	     *    to load its own copy of DDRAW.DLL. Threads
	     *    of this type are identified by didhelp being
	     *    TRUE in their context
	     * 2) A thread belonging to DDHELP when it loads
	     *    its own copy of DDHELP in response to a
	     *    request from a thread of type 1. Threads of
	     *    this type are identified by having a pid
	     *    which is equal to hpid (DDHELP's pid)
	     * 3) Any other threads belonging to subsequent
	     *    processes connecting to DDRAW.DLL
	     *
	     * As a thread of type 1 causes a thread of type 2
	     * to enter process attach before it itself has finished
	     * executing process attach itself we open our selves up
	     * to lots of deadlock problems if we let threads of
	     * type 3 through process attach before the other threads
	     * have completed their work.
	     *
	     * Therefore, the rule is that subsequent process
	     * attachement can only be allowed to execute the
	     * remainder of process attach if both the type 1
	     * and type 2 thread have completed their execution
	     * of process attach. We assure this with a combination
	     * of the critical section and an event which is signaled
	     * once DDHELP has initialized. Threads of type 3 MUST
	     * wait on this event before continuing through the
	     * process attach code. This is what the following
	     * code fragment does.
	     */
            /*
             * These events have been replaced with spinlocks, since
             * the old way leaked events, and it's just too hard to make them work.
             */
	    if( !didhelp && ( pid != hpid ) )
	    {
		{
		    /*
		     * NOTE: If we hold the DirectDraw critical
		     * section when we wait on this event we WILL
		     * DEADLOCK. Don't do it! Release the critical
		     * section before and take it again after. This
		     * guarantees that we won't complete process
		     * attach before the initial thread and the
		     * DDHELP thread have exited process attach.
		     */
		    #ifdef WIN16_SEPARATE
			LEAVE_DDRAW();
		    #else
			LEAVE_CSINIT();
		    #endif
                    /*
                     * This strange construction works around a compiler bug.
                     * while (dwHelperSpinStartup==1); generates an infinite loop.
                     */
                    while (1)
                    {
                        if ( dwHelperSpinStartup == 1)
                            break;
                    }
		    #ifdef WIN16_SEPARATE
			ENTER_DDRAW_INDLLMAIN();
		    #else
			ENTER_CSINIT();
		    #endif
		}
	    }
	}

	/*
	 * Win95 thunk connection...
	 */
	    DPF( 4, "Thunk connects" );
	    if (!(thk3216_ThunkConnect32(DDHAL_DRIVER_DLLNAME,
				    DDHAL_APP_DLLNAME,
				    hmod,
				    dwReason)))
	    {
		#ifdef WIN16_SEPARATE
		    LEAVE_DDRAW();
		#else
		    LEAVE_CSINIT();
		#endif
		DPF( 0, "LEAVING, COULD NOT thk3216_THUNKCONNECT32" );
		return FALSE;
	    }
	    if (!(thk1632_ThunkConnect32(DDHAL_DRIVER_DLLNAME,
				    DDHAL_APP_DLLNAME,
				    hmod,
				    dwReason)))
	    {
		#ifdef WIN16_SEPARATE
		    LEAVE_DDRAW();
		#else
		    LEAVE_CSINIT();
		#endif
		DPF( 0, "LEAVING, COULD NOT thk1632_THUNKCONNECT32" );
		return FALSE;
	    }

	/*
	 * initialize memory used to be done here. Jeffno 960609
	 */


	    /*
	     * signal the new process being added
	     */
	    if( didhelp )
	    {
		DPF( 4, "Waiting for DDHELP startup" );
		#ifdef WIN16_SEPARATE
		    LEAVE_DDRAW();
		#else
		    LEAVE_CSINIT();
		#endif
		if( !WaitForHelperStartup() )
		{
                    /*
                     * NT Setup loads DDRAW.DLL and sometimes this fails, so we don't 
                     * actually want fail loading the DLL or else setup might fail.
                     * Instead, we will suceed the load but then fail any other ddraw
                     * calls.
                     */
		    DPF( 0, "WaitForHelperStartup FAILED - disabling DDRAW" );
                    dwHelperPid = 0;
		    return TRUE;
		}
		HelperLoadDLL( DDHAL_APP_DLLNAME, NULL, 0 );

		/*
		 * For now, only call this on a multi-monitor system because
		 * it does cause a behavior change and we aren't able to
		 * provide adequate test covereage in the DX5 timeframe.
		 */
		if( IsMultiMonitor() )
		{
		   HelperSetOnDisplayChangeNotify( (void *)&UpdateAllDeviceRects);
		}

		#ifdef WIN16_SEPARATE
		    ENTER_DDRAW_INDLLMAIN();
		#else
		    ENTER_CSINIT();
		#endif

		/*
		 * As we were the first process through we now signal
		 * the completion of DDHELP initialization. This will
		 * release any subsequent threads waiting to complete
		 * process attach.
		 *
		 * NOTE: Threads waiting on this event will not immediately
		 * run process attach to completion as they will immediately
		 * try to take the DirectDraw critical section which we hold.
		 * Thus, they will not be allowed to continue until we have
		 * released the critical section just prior to existing
		 * below.
		 */
                InterlockedExchange( & dwHelperSpinStartup , 1);
	    }
	    SignalNewProcess( pid, DDNotify );
  	#endif //w95

        /*
         * We call MemInit here in order to guarantee that MemInit is called for
         * the first time on ddhelp's process. Why? Glad you asked. On wx86
         * (NT's 486 emulator) controlled instances of ddraw apps, we get a fault
         * whenever the ddraw app exits. This is because the app creates the RTL
         * heap inside a view of a file mapping which gets uncomitted (rightly)
         * when the app calls MemFini on exit. In this scenario, imagehlp.dll has
         * also created a heap, and calls a ntdll function which attempts to walk
         * the list of heaps, which requires a peek at the ddraw app's heap which
         * has been mapped out. Krunch.
         * We can't destroy the heap on MemFini because of the following scenario:
         * App A starts, creates heap. App b starts, maps a view of heap. App A
         * terminates, destroys heap. App b tries to use destroyed heap. Krunch
         * Jeffno 960609
         */
	if( dwRefCnt == 0 )
        {
            if ( !MemInit() )
            {
                #ifdef WINNT
                    CloseHandle( hExclusiveModeMutex );
                    CloseHandle( hCheckExclusiveModeMutex );
                #endif

		#ifdef WIN16_SEPARATE
		    LEAVE_DDRAW();
		#else
		    LEAVE_CSINIT();
		#endif
                DPF( 0,"LEAVING, COULD NOT MemInit");
                return FALSE;
            }

            #ifdef WIN95
	    /*
	     * The Memphis version of GDI calls into DirectDraw, but GDI
	     * needs to be notified that DirectDraw has actually loaded.
	     * (While GDI could check for itself to see whether ddraw.dll
	     * has loaded, this would be sloooooow if it hasn't yet.)
	     * The code below executes when ddraw.dll first starts up.
	     */
	    {
		HANDLE h;
		VOID (WINAPI *p)();

		h = LoadLibrary("msimg32.dll");    // GDI DLL
		if (h)
		{
		    p = (VOID(WINAPI *)())GetProcAddress(h, "vSetDdrawflag");
		    if (p)
		    {		   // vSetDdrawflag is a private call to
			(*p)();    // signal GDI that DDraw has loaded
		    }
		    FreeLibrary(h);
		}
	    }
	    #endif //WIN95
	}
        dwRefCnt++;


	/*
	 * remember this process (moved this below MemInit when it moved -Jeffno 960609
	 */
	lpap = MemAlloc( sizeof( ATTACHED_PROCESSES ) );
	if( lpap != NULL )
	{
	    lpap->lpLink = lpAttachedProcesses;
	    lpap->dwPid = pid;
            #ifdef WINNT
                lpap->dwNTToldYet=0;
            #endif
	    lpAttachedProcesses = lpap;
	}

	/*
	 * Initialize callback tables for this process.
	 */

	InitCallbackTables();

	#ifdef WIN16_SEPARATE
	    LEAVE_DDRAW();
	#else
	    LEAVE_CSINIT();
	#endif

	DPF( 4, "====> EXIT: DLLMAIN(%08lx): Process Attach: %08lx", DllMain,
			pid );
        break;

    case DLL_PROCESS_DETACH:
	DPF( 4, "====> ENTER: DLLMAIN(%08lx): Process Detach %08lx, tid=%08lx",
		DllMain, pid, GetCurrentThreadId() );
	    /*
	     * disconnect from thunk, even if other cleanup code commented out...
	     */
	    #ifdef WIN95
	        thk3216_ThunkConnect32(DDHAL_DRIVER_DLLNAME,
				        DDHAL_APP_DLLNAME,
				        hmod,
				        dwReason);
	        thk1632_ThunkConnect32(DDHAL_DRIVER_DLLNAME,
				        DDHAL_APP_DLLNAME,
				        hmod,
				        dwReason);
	    #endif

            #ifdef WINNT        //win NT needs to close file mapping handle for each process
                FreeAppHackData();
                RemoveProcessFromDLL(pid);
		FINI_DDRAW_CSECT(); //Cheap mutexes need to close semaphore handle for each process
                MemFini();

                DDASSERT(0 != hExclusiveModeMutex);
                CloseHandle( hCheckExclusiveModeMutex );
                CloseHandle( hExclusiveModeMutex );
                FINIWINDLIST();
                FINICSDRIVEROBJECTLIST();
            #endif

	DPF( 4, "====> EXIT: DLLMAIN(%08lx): Process Detach %08lx",
		DllMain, pid );
        break;

    /*
     * we don't ever want to see thread attach/detach
     */
    #ifdef DEBUG
	case DLL_THREAD_ATTACH:
	    DPF( 4, "THREAD_ATTACH");
	    break;

	case DLL_THREAD_DETACH:
	    DPF( 4,"THREAD_DETACH");
	    break;
    #endif
    default:
        break;
    }

    return TRUE;

} /* DllMain */


/*
 * RemoveProcessFromDLL
 *
 * Find & remove a pid from the list.
 * Assumes ddlock taken
 */
BOOL RemoveProcessFromDLL( DWORD pid )
{
    LPATTACHED_PROCESSES	lpap;
    LPATTACHED_PROCESSES	prev;

    lpap = lpAttachedProcesses;
    prev = NULL;
    while( lpap != NULL )
    {
	if( lpap->dwPid == pid )
	{
	    if( prev == NULL )
	    {
		lpAttachedProcesses = lpap->lpLink;
	    }
	    else
	    {
		prev->lpLink = lpap->lpLink;
	    }
	    MemFree( lpap );
	    DPF( 5, "Removing process %08lx from list", pid );
	    return TRUE;
	}
	prev = lpap;
	lpap = lpap->lpLink;
    }
    DPF( 5, "Process %08lx not in DLL list", pid );
    return FALSE;

} /* RemoveProcessFromDLL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\mmdd.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mmdd.c
 *  Content:	DDRAW.DLL initialization for MMOSA/Native platforms
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   15-may-95  scottle created it
 *
 ***************************************************************************/

#ifdef MMOSA
#include <ddrawpr.h>
#include "mmdd.h"

BOOL bGraphicsInit = FALSE;
PIFILE pDisplay = NULL;

///////////////////////////////////////////////////////////////////////
//
// MMOSA_Driver_Attach() - Called during DDraw.DLL load on
//		a MMOSA/Native platform.
//		Performs MMOSA/Native device driver specific initialization
//
///////////////////////////////////////////////////////////////////////
BOOL MMOSA_Driver_Attach(void)
{
	// During the DLL attach...
	PINAMESPACE pIName;
	PIUNKNOWN pUnk;
	SCODE Sc;
	
	// Create/Register/Bind the "display" namespace object to this process
	pIName = CurrentNameSpace();
	Sc = pIName->v->Bind( pIName, TEXT("display"), F_READ|F_WRITE, &pUnk);
	if (FAILED(Sc))
	{
		DPF(1, "Could not open display device (%x)\n", Sc);
		return FALSE;
	}
	
	// Get a pointer to the IFile driver interface object, we'll use it
	//	for our display device interface.
	Sc = pUnk->v->QueryInterface(pUnk,&IID_IFile,(void **)&pDisplay);
	pUnk->v->Release(pUnk);
	
	if (FAILED(Sc))
	{
	    DPF(2, "Bogus display device (%x)\n", Sc);
		return FALSE;
	}
	
 	bGraphicsInit = TRUE;
	return TRUE;
} // End MMOSA_Driver_Attach
	
///////////////////////////////////////////////////////////////////////
//
// MMOSA_Driver_Detach() - Called during DDraw.DLL unload on
//		a MMOSA/Native platform.
//		Performs MMOSA/Native device driver specific deinitialization
//
///////////////////////////////////////////////////////////////////////
BOOL MMOSA_Driver_Detach(void)
{
	///////////////////////
	// During the detach...
	///////////////////////
	// Shutdown the graphics 
	if (bGraphicsInit)
	{
	    (void) pDisplay->v->SetSize( pDisplay, (UINT64) 3);
	    pDisplay->v->Release(pDisplay);
		pDisplay = NULL;
		bGraphicsInit = FALSE;
	}
	return TRUE;
} // End MMOSA_Driver_Attach


int MMOSA_DDHal_Escape( HDC  hdc, int  nEscape, int  cbInput, LPCTSTR  lpszInData, int  cbOutput, LPTSTR  lpszOutData)
{
	return 0;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\mmdd.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       mmdd.H
 *  Content:	DDRAW.DLL initialization for MMOSA/Native platforms
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   15-may-95  scottle created it
 *
 ***************************************************************************/
#ifdef MMOSA
#pragma message("Including MMDD.H")
#include <mmosa.h>
#include <mmhal.h>
#include <drivers.h>
BOOL MMOSA_Driver_Attach(void);
BOOL MMOSA_Driver_Detach(void);
int MMOSA_DDHal_Escape( HDC  hdc, int  nEscape, int  cbInput, LPCTSTR  lpszInData, int  cbOutput, LPTSTR  lpszOutData);

extern BOOL bGraphicsInit;
extern PIFILE pDisplay;

// Function Replacements
#define lstrncmpi(a,b) StrCmp(a,b)
#define lstrcmpi(a,b)  StrCmp(a,b)
#define strcpy(a,b)	   StrCpy(a,b)
#define ExtEscape(hdc, ccmd, szcmd, pcmd, szdata, pdata) MMOSA_DDHal_Escape(hdc, ccmd, szcmd, pcmd, szdata, pdata)

// Important typedefs not supported in Win32e
#define QUERYESCSUPPORT 8

#define MMOSA_DISPLAY_DRIVER_NAME TEXT("display")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\getri.c ===
//========================================================================
//
// GetRegistryInfo.CPP
//
// DirectDraw/Direct3D driver information grabber
// (c) Copyright 1998 Microsoft Corp.
// Written by Michael Lyons (mlyons@microsoft.com)
//
// Registry access functions, for querying device stuff from the
// registry
//
// Function names that begin with an underscore are internal only!
//
//========================================================================


#include "ddrawpr.h"

//#include "GetDriverInfo.h"
//#include "GetDriverInfoInt.h"

//========================================================================
// local functions
//========================================================================
BOOL _FindDevice(int    iDevice, LPCSTR szDeviceClass, LPCSTR szDeviceClassNot, LPSTR szHardwareKey, BOOL bIgnoreProblems);
static BOOL _GetDeviceValue(LPCSTR szHardwareKey, LPCSTR szKey,	LPCSTR szValue,	BYTE* buf, DWORD cbbuf);
extern char *_strstr(char *s1, char *s2);

//========================================================================
//
// GetDeviceValue
//
// read	a value	from the HW	or SW of a PnP device
//
// in:
//	szHardwareKey	the hardware key
//	szKey			the sub-key
//	szValue			the value to query
//	cbbuf			the size of the output buffer
//
// out:
//	buf				the destination buffer
//	
// returns:
//	success status
//
//========================================================================
static BOOL _GetDeviceValue(LPCSTR szHardwareKey, LPCSTR szKey,	LPCSTR szValue,	BYTE* buf, DWORD cbbuf)
{
	HKEY	hkeyHW;
	HKEY	hkeySW;
	BOOL	f =	FALSE;
	DWORD	cb;
	char	szSoftwareKey[MAX_DDDEVICEID_STRING];

	//
	// open	the	HW key
	//
	if (RegOpenKey(HKEY_LOCAL_MACHINE, szHardwareKey, &hkeyHW) == ERROR_SUCCESS)
	{
		//
		// try to read the value from the HW key
		//
		*buf = 0;
		cb = cbbuf;
		if (RegQueryValueEx(hkeyHW,	szValue, NULL, NULL, buf, &cb) == ERROR_SUCCESS)
		{
			f =	TRUE;
		}
		else
		{
			//
			// now try the SW key
			//
			static char	szSW[] = "System\\CurrentControlSet\\Services\\Class\\";

			lstrcpy(szSoftwareKey, szSW);
			cb = sizeof(szSoftwareKey) - sizeof(szSW);
			RegQueryValueEx(hkeyHW,	"Driver", NULL,	NULL, (BYTE	*)&szSoftwareKey[sizeof(szSW) -	1],	&cb);

			if (szKey)
			{
				lstrcat(szSoftwareKey, "\\");
				lstrcat(szSoftwareKey, szKey);
			}

			if (RegOpenKey(HKEY_LOCAL_MACHINE, szSoftwareKey, &hkeySW) == ERROR_SUCCESS)
			{
				*buf = 0;
				cb = cbbuf;
				if (RegQueryValueEx(hkeySW,	szValue, NULL, NULL, buf, &cb) == ERROR_SUCCESS)
				{
					f =	TRUE;
				}

				RegCloseKey(hkeySW);
			}
		}

		RegCloseKey(hkeyHW);
	}

	return f;
}



//========================================================================
//
// FindDevice
//
// enum	the	started	PnP	devices	looking	for	a device of	a particular class
//
//	iDevice			what device	to return (0= first	device,	1=second et)
//	szDeviceClass	what class device (ie "Display") NULL will match all
//	szDeviceID		buffer to return the hardware ID (MAX_DDDEVICEID_STRING bytes)
//
// return TRUE if a	device was found.
//
// example:
//
//		for	(int i=0; FindDevice(i,	"Display", DeviceID); i++)
//		{
//		}
//
//========================================================================
BOOL _FindDevice(int iDevice, LPCSTR szDeviceClass, LPCSTR szDeviceClassNot, LPSTR szHardwareKey, BOOL bIgnoreProblems)
{
	HKEY	hkeyPnP;
	HKEY	hkey;
	DWORD	n;
	DWORD	cb;
	DWORD	dw;
	char	ach[MAX_DDDEVICEID_STRING];

	if (RegOpenKey(HKEY_DYN_DATA, "Config Manager\\Enum", &hkeyPnP)	!= ERROR_SUCCESS)
		return FALSE;

	for	(n=0; RegEnumKey(hkeyPnP, n, ach, sizeof(ach)) == 0; n++)
	{
		static char	szHW[] = "Enum\\";

		if (RegOpenKey(hkeyPnP,	ach, &hkey)	!= ERROR_SUCCESS)
			continue;

		lstrcpy(szHardwareKey, szHW);
		cb = MAX_DDDEVICEID_STRING -	sizeof(szHW);
		RegQueryValueEx(hkey, "HardwareKey", NULL, NULL, (BYTE*)szHardwareKey +	sizeof(szHW) - 1, &cb);

		dw = 0;
		cb = sizeof(dw);
		RegQueryValueEx(hkey, "Problem", NULL, NULL, (BYTE*)&dw, &cb);
		RegCloseKey(hkey);

		if ((!bIgnoreProblems) && (dw != 0))		// if this device has a	problem	skip it
			continue;

		if (szDeviceClass || szDeviceClassNot)
		{
			_GetDeviceValue(szHardwareKey, NULL,	"Class", (BYTE *)ach, sizeof(ach));

			if (szDeviceClass && lstrcmpi(szDeviceClass, ach) != 0)
				continue;

			if (szDeviceClassNot && lstrcmpi(szDeviceClassNot, ach) == 0)
				continue;
		}

		//
		// we found	a device, make sure	it is the one the caller wants
		//
		if (iDevice-- == 0)
		{
			RegCloseKey(hkeyPnP);
			return TRUE;
		}
	}

	RegCloseKey(hkeyPnP);
	return FALSE;
}


//========================================================================
//
// _GetDriverInfoFromRegistry
//
// This function goes through the registry and tries to fill in
// information about a driver given a class and maybe a vendor ID
//
// in:
//	szClass		the class name (i.e., "Display")
//	szVendor	the vendor name (i.e., "VEN_121A" for 3Dfx" or NULL
//				if any vendor of the class will do
//
// out:
//	pDI			pointer to a DDDRIVERINFOEX structure to be filled in
//
// returns:
//	success status
//
//========================================================================
HRESULT _GetDriverInfoFromRegistry(char *szClass, char *szClassNot, char *szVendor, LPDDDRIVERINFOEX pDI)
{
	char szDevice[MAX_DDDEVICEID_STRING];
        int i;

	pDI->szDeviceID[0]=0;
	pDI->di.szDescription[0]=0;


	for (i=0 ; ; i++)
	{
		if (!_FindDevice(i, szClass, szClassNot, szDevice, FALSE))
			break;

		if ((szVendor == NULL) || (_strstr(szDevice, szVendor)))
		{
			//
			// skip the first 5 characters "Enum\"
			//
			strcpy(pDI->szDeviceID, &szDevice[5]);
			_GetDeviceValue((LPCSTR)szDevice, NULL,		"DeviceDesc",	(BYTE *)pDI->di.szDescription, sizeof(pDI->di.szDescription));
			//_GetDeviceValue((LPCSTR)szDevice, NULL,		"Mfg",			(BYTE *)pDI->szManufacturer, sizeof(pDI->szManufacturer));
			//_GetDeviceValue((LPCSTR)szDevice, "DEFAULT","drv",			(BYTE *)pDI->szGDIDriver, sizeof(pDI->szGDIDriver));

			return S_OK;
		}
	}

	return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\factory.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	factory.c
 *  Content:	DirectDrawFactory implementation
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   22-oct-97	jeffno  initial implementation
 *
 ***************************************************************************/

#include "ddrawpr.h"

HRESULT InternalCreateDDFactory2(void ** ppvObj, IUnknown * pUnkOuter)
{
    LPDDFACTORY2 lpFac = NULL;

    DDASSERT(ppvObj);

    if (pUnkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }

    /*
     * If any allocations are added to this function, make sure to update the
     * cleanup code in classfac.c
     */
    lpFac = MemAlloc(sizeof(DDFACTORY2));

    if (!lpFac)
    {
        return DDERR_OUTOFMEMORY;
    }

    lpFac->lpVtbl = &ddFactory2Callbacks;
    lpFac->dwRefCnt = 0;

    *ppvObj = (IUnknown*) lpFac;

    return DD_OK;
}


/*
 * DDFac2_QueryInterface
 */
HRESULT DDAPI DDFac2_QueryInterface(
		LPDIRECTDRAWFACTORY2 lpDDFac,
		REFIID riid,
		LPVOID FAR * ppvObj )
{
    LPDDFACTORY2   this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DDFac2_QueryInterface");

    /*
     * validate parms
     */
    TRY
    {
	this = (LPDDFACTORY2) lpDDFac;
	if( !VALID_DIRECTDRAWFACTORY2_PTR( this ) )
	{
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	if( !VALID_PTR_PTR( ppvObj ) )
	{
	    DPF( 1, "Invalid clipper pointer" );
	    LEAVE_DDRAW();
	    return (DWORD) DDERR_INVALIDPARAMS;
	}
	if( !VALIDEX_IID_PTR( riid ) )
	{
	    DPF_ERR( "Invalid IID pointer" );
	    LEAVE_DDRAW();
	    return (DWORD) DDERR_INVALIDPARAMS;
	}
	*ppvObj = NULL;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }

    /*
     * check guids
     */
    if( IsEqualIID(riid, &IID_IUnknown) ||
	IsEqualIID(riid, &IID_IDirectDrawFactory2) )
    {
        ((IUnknown*)this)->lpVtbl->AddRef((IUnknown*)this);
	*ppvObj = (LPVOID) this;
	LEAVE_DDRAW();
	return DD_OK;
    }
    LEAVE_DDRAW();
    return E_NOINTERFACE;

} /* DDFac2_QueryInterface */

#undef DPF_MODNAME
#define DPF_MODNAME "DDFactory2::AddRef"

/*
 * DDFac2_AddRef
 */
DWORD DDAPI DDFac2_AddRef( LPDIRECTDRAWFACTORY2 lpDDFac )
{
    LPDDFACTORY2   this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DDFac2_AddRef");

    /*
     * validate parms
     */
    TRY
    {
	this = (LPDDFACTORY2) lpDDFac;
	if( !VALID_DIRECTDRAWFACTORY2_PTR( this ) )
	{
	    LEAVE_DDRAW();
	    return 0;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    /*
     * update reference count
     */
    this->dwRefCnt++;

    DPF( 5, "DDFactory %08lx addrefed, refcnt = %ld", this, this->dwRefCnt );

    LEAVE_DDRAW();
    return this->dwRefCnt;

} /* DDFac2_AddRef */

#undef DPF_MODNAME
#define DPF_MODNAME "DDFactory2::Release"

ULONG DDAPI DDFac2_Release( LPDIRECTDRAWFACTORY2 lpDDFac )
{
    LPDDFACTORY2   this;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DDFac2_Release");

    /*
     * validate parms
     */
    TRY
    {
	this = (LPDDFACTORY2) lpDDFac;
	if( !VALID_DIRECTDRAWFACTORY2_PTR( this ) )
	{
	    LEAVE_DDRAW();
	    return 0;
	}
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return 0;
    }

    /*
     * update reference count
     */
    this->dwRefCnt--;

    DPF( 5, "DDFactory %08lx releaseed, refcnt = %ld", this, this->dwRefCnt );

    if (this->dwRefCnt == 0)
    {
        this->lpVtbl = 0;
        MemFree(this);
        LEAVE_DDRAW();
        return 0;
    }                 

    LEAVE_DDRAW();
    return this->dwRefCnt;

} /* DDFac2_Release */


HRESULT DDAPI DDFac2_CreateDirectDraw(
        LPDIRECTDRAWFACTORY2 lpDDFac, 
        GUID FAR*rDeviceGuid, 
        HWND hWnd, 
        DWORD dwCoopLevelFlags, 
        DWORD dwFlags, 
        IUnknown FAR *pUnkOuter, 
        IDirectDraw4 FAR **ppDDraw)
{
    LPDIRECTDRAW lpDD;

    HRESULT hr = DirectDrawCreate( rDeviceGuid, &lpDD, pUnkOuter );

    lpDDFac;

    DPF(2,A,"ENTERAPI: DDFac2_CreateDirectDraw");

    if( SUCCEEDED(hr) )
    {
	hr = lpDD->lpVtbl->QueryInterface(lpDD,&IID_IDirectDraw4,(void**) ppDDraw);
        lpDD->lpVtbl->Release(lpDD);

        if( SUCCEEDED(hr) )
        {
    	    hr = (*ppDDraw)->lpVtbl->SetCooperativeLevel(*ppDDraw, hWnd, dwCoopLevelFlags);
        }
    }
    return hr;
} /* DDFac2_CreateDirectDraw */

HRESULT DDAPI DDFac2_DirectDrawEnumerate(LPDIRECTDRAWFACTORY2 lpDDFac, LPDDENUMCALLBACKEX lpCallback, LPVOID lpContext , DWORD dwFlags)
{
    DPF(2,A,"ENTERAPI: DDFac2_DirectDrawEnumerate");

    return DirectDrawEnumerateExA(lpCallback, lpContext, dwFlags);
} /* DDFac2_DirectDrawEnumerate */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\misc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	misc.c
 *  Content:	DirectDraw misc. routines
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   13-mar-95	craige	initial implementation
 *   19-mar-95	craige	use HRESULTs, added DeleteFromActiveProcessList
 *   23-mar-95	craige	added DeleteFromFlippableList
 *   29-mar-95	craige	DeleteFromActiveProcessList return codes
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	split out process list stuff
 *   13-jun-95	kylej	moved in FindAttachedFlip, added CanBeFlippable
 *   16-jun-95	craige	new surface structure
 *   26-jun-95	craige	reorganized surface structure
 *   05-dec-95  colinmc changed DDSCAPS_TEXTUREMAP => DDSCAPS_TEXTURE for
 *                      consistency with Direct3D
 *   07-dec-95  colinmc support for mip-maps (flippable mip-maps can get
 *                      pretty complex)
 *   08-jan-96	kylej	added interface structures
 *   17-mar-96  colinmc Bug 13124: flippable mip-maps.
 *   24-mar-96  colinmc Bug 14321: not possible to specify back buffer and
 *                      mip-map count in a single call
 *   08-dec-96  colinmc Initial AGP support
 *   24-mar-97  jeffno  Optimized Surfaces
 *   07-may-97  colinmc Move AGP detection stuff to ddagp.c
 *
 ***************************************************************************/
#include "ddrawpr.h"

#define DIRECTXVXDNAME "\\\\.\\DDRAW.VXD"

#if 0
/*
 * DeleteFromFlippableList
 */
BOOL DeleteFromFlippableList(
		LPDDRAWI_DIRECTDRAW pdrv,
		LPDDRAWI_DDRAWSURFACE_GBL psurf )
{
    LPDDRAWI_DDRAWSURFACE_GBL	curr;
    LPDDRAWI_DDRAWSURFACE_GBL	last;

    curr = pdrv->dsFlipList;
    if( curr == NULL )
    {
	return FALSE;
    }
    last = NULL;
    while( curr != psurf )
    {
	last = curr;
	curr = curr->lpFlipLink;
	if( curr == NULL )
	{
	    return FALSE;
	}
    }
    if( last == NULL )
    {
	pdrv->dsFlipList = pdrv->dsFlipList->lpFlipLink;
    }
    else
    {
	last->lpFlipLink = curr->lpFlipLink;
    }
    return TRUE;

} /* DeleteFromFlippableList */
#endif

#define DDSCAPS_FLIPPABLETYPES \
	    (DDSCAPS_OVERLAY | \
	     DDSCAPS_TEXTURE | \
	     DDSCAPS_ALPHA   | \
	     DDSCAPS_ZBUFFER)

/*
 * CanBeFlippable
 *
 * Check to see if these two surfaces can be part of a flippable chain
 */
BOOL CanBeFlippable( LPDDRAWI_DDRAWSURFACE_LCL this_lcl,
		     LPDDRAWI_DDRAWSURFACE_LCL this_attach_lcl)
{
    if( ( this_lcl->ddsCaps.dwCaps & DDSCAPS_FLIPPABLETYPES ) ==
	( this_attach_lcl->ddsCaps.dwCaps & DDSCAPS_FLIPPABLETYPES ) )
    {
        /*
         * Flipping chains of optimized mipmaps have DDSCAPS_MIPMAP on every
         * surface in the list (since each surface represents an entire mipmap
         * chain. So, if both surfaces are optimized mipmaps, then they can
         * be flipped
         */
        if (this_lcl->ddsCaps.dwCaps & DDSCAPS_OPTIMIZED)
        {
            /*
             * We are definitely dealing with an optimized surface, so we're safe to
             * make the decision any way we like without fear of regressing other
             * flipping behaviour
             */
            if ( (this_lcl->ddsCaps.dwCaps & (DDSCAPS_OPTIMIZED|DDSCAPS_MIPMAP)) ==
                (DDSCAPS_OPTIMIZED|DDSCAPS_MIPMAP) )
            {
                if ( (this_attach_lcl->ddsCaps.dwCaps & (DDSCAPS_OPTIMIZED|DDSCAPS_MIPMAP)) ==
                    (DDSCAPS_OPTIMIZED|DDSCAPS_MIPMAP) )
                {
                    return TRUE;
                }
            }
            DPF(1,"Optimized mip-maps not flippable");
            return FALSE;
        }
        /*
         * No longer enough to see if both surfaces are exactly the same
         * type of flippable surface. A mip-map can have both a mip-map and
         * a non-mip-map texture attached both of which are marked as
         * flippable. A mip-map also flips with the non-mip-map texture (not
         * the other mip-map. Therefore, if both surfaces are textures we need
         * to check to also check that they are not both mip-maps before declaring
         * them flippable.
         */
        if( ( ( this_lcl->ddsCaps.dwCaps & this_attach_lcl->ddsCaps.dwCaps ) &
              ( DDSCAPS_TEXTURE | DDSCAPS_MIPMAP ) ) == ( DDSCAPS_TEXTURE | DDSCAPS_MIPMAP ) )
            return FALSE;
        else
            return TRUE;
    }
    else
    {
        return FALSE;
    }
} /* CanBeFlippable */

/*
 * FindAttachedFlip
 *
 * find an attached flipping surface of the same type
 */
LPDDRAWI_DDRAWSURFACE_INT FindAttachedFlip(
		LPDDRAWI_DDRAWSURFACE_INT this_int )
{
    LPATTACHLIST		ptr;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;

    if( this_int == NULL)
    {
	return NULL;
    }
    this_lcl = this_int->lpLcl;
    for( ptr = this_lcl->lpAttachList; ptr != NULL; ptr = ptr->lpLink )
    {
	psurf_int = ptr->lpIAttached;
	psurf_lcl = psurf_int->lpLcl;
	if( (psurf_lcl->ddsCaps.dwCaps & DDSCAPS_FLIP) &&
	    CanBeFlippable( this_lcl, psurf_lcl ) )
	{
	    return psurf_int;
	}
    }
    return NULL;

} /* FindAttachedFlip */

/*
 * FindAttachedSurfaceLeft
 *
 * find an attached left surface
 */
LPDDRAWI_DDRAWSURFACE_INT FindAttachedSurfaceLeft(
		LPDDRAWI_DDRAWSURFACE_INT this_int )
{
    LPATTACHLIST		ptr;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;

    if( this_int == NULL)
    {
	return NULL;
    }
    this_lcl = this_int->lpLcl;
    for( ptr = this_lcl->lpAttachList; ptr != NULL; ptr = ptr->lpLink )
    {
	psurf_int = ptr->lpIAttached;
	psurf_lcl = psurf_int->lpLcl;
    if (psurf_lcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_STEREOSURFACELEFT)
	    return psurf_int;
    }
    return NULL;

} /* FindAttachedSurfaceLeft */


/*
 * FindAttachedMipMap
 *
 * find an attached mip-map surface
 */
LPDDRAWI_DDRAWSURFACE_INT FindAttachedMipMap(
		LPDDRAWI_DDRAWSURFACE_INT this_int )
{
    LPATTACHLIST		ptr;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;

    if( this_int == NULL)
	return NULL;
    this_lcl = this_int->lpLcl;
    for( ptr = this_lcl->lpAttachList; ptr != NULL; ptr = ptr->lpLink )
    {
	psurf_int = ptr->lpIAttached;
	psurf_lcl = psurf_int->lpLcl;
	if( psurf_lcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP )
	    return psurf_int;
    }
    return NULL;

} /* FindAttachedMipMap */

/*
 * FindParentMipMap
 *
 * find the parent mip-map level of the given level
 */
LPDDRAWI_DDRAWSURFACE_INT FindParentMipMap(
		LPDDRAWI_DDRAWSURFACE_INT this_int )
{
    LPATTACHLIST		ptr;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    LPDDRAWI_DDRAWSURFACE_INT	psurf_int;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;

    if( this_int == NULL)
	return NULL;
    this_lcl = this_int->lpLcl;
    DDASSERT( this_lcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP );
    for( ptr = this_lcl->lpAttachListFrom; ptr != NULL; ptr = ptr->lpLink )
    {
	psurf_int = ptr->lpIAttached;
	psurf_lcl = psurf_int->lpLcl;
	if( psurf_lcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP )
	    return psurf_int;
    }
    return NULL;

} /* FindParentMipMap */

#ifdef WINNT

/*
 * IsDifferentPixelFormat
 *
 * determine if two pixel formats are the same or not
 *
 * (CMcC) 12/14/95 Really useful - so no longer static
 *
 * This is the WINNT copy, since the video memory management files
 * it normally resides in (ddheap.c) is no longer part of the 
 * user-mode ddraw.dll
 */
BOOL IsDifferentPixelFormat( LPDDPIXELFORMAT pdpf1, LPDDPIXELFORMAT pdpf2 )
{
    /*
     * same flags?
     */
    if( pdpf1->dwFlags != pdpf2->dwFlags )
    {
	VDPF(( 5, S, "Flags differ!" ));
	return TRUE;
    }

    /*
     * same bitcount for non-YUV surfaces?
     */
    if( !(pdpf1->dwFlags & (DDPF_YUV | DDPF_FOURCC)) )
    {
	if( pdpf1->dwRGBBitCount != pdpf2->dwRGBBitCount )
	{
	    VDPF(( 5, S, "RGB Bitcount differs!" ));
	    return TRUE;
	}
    }

    /*
     * same RGB properties?
     */
    if( pdpf1->dwFlags & DDPF_RGB )
    {
	if( pdpf1->dwRBitMask != pdpf2->dwRBitMask )
	{
	    VDPF(( 5, S, "RBitMask differs!" ));
	    return TRUE;
	}
	if( pdpf1->dwGBitMask != pdpf2->dwGBitMask )
	{
	    VDPF(( 5, S, "GBitMask differs!" ));
	    return TRUE;
	}
	if( pdpf1->dwBBitMask != pdpf2->dwBBitMask )
	{
	    VDPF(( 5, S, "BBitMask differs!" ));
	    return TRUE;
	}
	if( pdpf1->dwRGBAlphaBitMask != pdpf2->dwRGBAlphaBitMask )
	{
	    VDPF(( 5, S, "RGBAlphaBitMask differs!" ));
	    return TRUE;
	}
    }

    /*
     * same YUV properties?
     */
    if( pdpf1->dwFlags & DDPF_YUV )
    {
	VDPF(( 5, S, "YUV???" ));
	if( pdpf1->dwFourCC != pdpf2->dwFourCC )
	{
	    return TRUE;
	}
	if( pdpf1->dwYUVBitCount != pdpf2->dwYUVBitCount )
	{
	    return TRUE;
	}
	if( pdpf1->dwYBitMask != pdpf2->dwYBitMask )
	{
	    return TRUE;
	}
	if( pdpf1->dwUBitMask != pdpf2->dwUBitMask )
	{
	    return TRUE;
	}
	if( pdpf1->dwVBitMask != pdpf2->dwVBitMask )
	{
	    return TRUE;
	}
	if( pdpf1->dwYUVAlphaBitMask != pdpf2->dwYUVAlphaBitMask )
	{
	    return TRUE;
	}
    }

    /*
     * Possible to use FOURCCs w/o setting the DDPF_YUV flag
     * ScottM 7/11/96
     */
    else if( pdpf1->dwFlags & DDPF_FOURCC )
    {
	VDPF(( 5, S, "FOURCC???" ));
	if( pdpf1->dwFourCC != pdpf2->dwFourCC )
	{
	    return TRUE;
	}
    }

    /*
     *	If Interleaved Z then check Z bit masks are the same
     */
    if( pdpf1->dwFlags & DDPF_ZPIXELS )
    {
	VDPF(( 5, S, "ZPIXELS???" ));
	if( pdpf1->dwRGBZBitMask != pdpf2->dwRGBZBitMask )
	    return TRUE;
    }

    return FALSE;

} /* IsDifferentPixelFormat */

#endif //WINNT

/*
 * Get a handle for communicating with the DirectX VXD (DDRAW.VXD).
 */
#ifdef WIN95
    HANDLE GetDXVxdHandle( void )
    {
	HANDLE hvxd;

	hvxd = CreateFile( DIRECTXVXDNAME,
			   GENERIC_WRITE,
			   FILE_SHARE_WRITE,
			   NULL,
			   OPEN_EXISTING,
			   FILE_ATTRIBUTE_NORMAL | FILE_FLAG_GLOBAL_HANDLE,
			   NULL);
	#ifdef DEBUG
	    if( INVALID_HANDLE_VALUE == hvxd )
		DPF_ERR( "Could not connect to the DirectX VXD" );
	#endif /* DEBUG */

	return hvxd;
    } /* GetDXVxdHandle */
#endif /* WIN95 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\private.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       private.c
 *  Content:	DirectDraw Private Client Data support
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *  10/08/97    jeffno  Initial Implementation
 *  24/11/97    t-craigs Added support for palettes, flags, et al
 *
 ***************************************************************************/
#include "ddrawpr.h"

void FreePrivateDataNode(LPPRIVATEDATANODE pData)
{
    /*
     * Check to see whether we should release the
     * memory our data pointer might be pointing to.
     */
    if (pData->dwFlags & DDSPD_IUNKNOWNPOINTER)
    {
        IUnknown *pUnk = (IUnknown *) pData->pData;
        /*
         * Better try-except, or Gershon will get on my back
         */
        TRY
        {
            pUnk->lpVtbl->Release(pUnk);
        }
        EXCEPT( EXCEPTION_EXECUTE_HANDLER )
        {
	    DPF_ERR( "Exception encountered releasing private IUnknown pointer" );
        }
    }
    else
    {
        MemFree(pData->pData);
    }
    MemFree(pData);
}

void FreeAllPrivateData(LPPRIVATEDATANODE * ppListHead)
{
    LPPRIVATEDATANODE pData = (*ppListHead);

    while(pData)
    {
        LPPRIVATEDATANODE pPrevious = pData;
        pData=pData->pNext;
        FreePrivateDataNode(pPrevious);
    }
    (*ppListHead) = NULL;
}

/*
 * Helpers called from API entry points
 */
HRESULT InternalFreePrivateData(LPPRIVATEDATANODE * ppListHead, REFGUID rGuid)
{
    LPPRIVATEDATANODE pData = * ppListHead;
    LPPRIVATEDATANODE pPrevious = NULL;

    while (pData)
    {
        if ( IsEqualGUID(&pData->guid, rGuid))
        {
            /*
             * Check to see whether we should release the
             * memory our data pointer might be pointing to.
             */
            if (pPrevious)
                pPrevious->pNext = pData->pNext;
            else
                *ppListHead = pData->pNext;

            FreePrivateDataNode(pData);

            return DD_OK;
        }
        pPrevious = pData;
        pData=pData->pNext;
    }

    return DDERR_NOTFOUND;
}

HRESULT InternalSetPrivateData(
		LPPRIVATEDATANODE       *ppListHead,
                REFGUID                 rGuid,
                LPVOID                  pData,
                DWORD                   cbData,
                DWORD                   dwFlags,
                DWORD                   dwContentsStamp)
{
    HRESULT                     hr = DD_OK;
    LPPRIVATEDATANODE           pDataNode = NULL;
    BOOL                        bPtr;

    if( 0UL == cbData )
    {
	DPF_ERR( "Zero is invalid size of private data");
	return DDERR_INVALIDPARAMS;
    }

    if( !VALID_IID_PTR( rGuid ) )
    {
	DPF_ERR( "GUID reference is invalid" );
	return DDERR_INVALIDPARAMS;
    }

    if( !VALID_PTR( pData, cbData ) )
    {
	DPF_ERR( "Private data pointer is invalid" );
	return DDERR_INVALIDPARAMS;
    }

    if( dwFlags & ~DDSPD_VALID )
    {
	DPF_ERR( "Invalid flags" );
	return DDERR_INVALIDPARAMS;
    }

    bPtr = dwFlags & DDSPD_IUNKNOWNPOINTER;
    
    /*
     * First check if GUID already exists, squish it if so.
     * Don't care about return value.
     */
    InternalFreePrivateData(ppListHead, rGuid);

    /*
     * Now we can add the guid and know it's unique
     */
    pDataNode = MemAlloc(sizeof(PRIVATEDATANODE));

    if (!pDataNode)
        return DDERR_OUTOFMEMORY;

    /*
     * If we have a "special" pointer, as indicated by one of the flags,
     * then we copy that pointer.
     * Otherwise we copy a certain number of bytes from
     * the location pointed to.
     */
    if (bPtr)
    {
        IUnknown * pUnk;

        if (sizeof(IUnknown*) != cbData)
        {
            MemFree(pDataNode);
            DPF_ERR("cbData must be set to sizeof(IUnknown *) when DDSPD_IUNKNOWNPOINTER is used");
            return DDERR_INVALIDPARAMS;
        }
        pDataNode->pData = pData;

        /*
         * Now addref the pointer. We'll release it again when the data are freed
         */
        pUnk = (IUnknown*) pData;

        TRY
        {
            pUnk->lpVtbl->AddRef(pUnk);
        }
        EXCEPT( EXCEPTION_EXECUTE_HANDLER )
        {
            MemFree(pDataNode);
	    DPF_ERR( "Exception encountered releasing private IUnknown pointer" );
            return DDERR_INVALIDPARAMS;
        }
    }
    else
    {
        pDataNode->pData = MemAlloc(cbData);

        if (!pDataNode->pData)
        {
            MemFree(pDataNode);
            return DDERR_OUTOFMEMORY;
        }

        memcpy(pDataNode->pData,pData,cbData);
    }
    
    memcpy(&pDataNode->guid,rGuid,sizeof(*rGuid));
    pDataNode->cbData = cbData;
    pDataNode->dwFlags = dwFlags;
    pDataNode->dwContentsStamp = dwContentsStamp;

    /*
     * Insert the node at the head of the list
     */
    pDataNode->pNext = *ppListHead;
    *ppListHead = pDataNode;

    return DD_OK;
}

HRESULT InternalGetPrivateData(
		LPPRIVATEDATANODE       *ppListHead,
                REFGUID                 rGuid,
                LPVOID                  pData,
                LPDWORD                 pcbData,
                DWORD                   dwCurrentStamp)
{
    HRESULT                     hr = DD_OK; 
    LPPRIVATEDATANODE           pDataNode = *ppListHead;

    if( !VALID_PTR( pcbData, sizeof(DWORD) ) )
    {
	DPF_ERR( "Private data count pointer is invalid" );
	return DDERR_INVALIDPARAMS;
    }

    if( !VALID_IID_PTR( rGuid ) )
    {
        *pcbData = 0;
	DPF_ERR( "GUID reference is invalid" );
	return DDERR_INVALIDPARAMS;
    }

    if (*pcbData)
    {
	if( !VALID_PTR( pData, *pcbData ) )
	{
            *pcbData = 0;
	    DPF_ERR( "Private data pointer is invalid" );
	    return DDERR_INVALIDPARAMS;
        }
    }

    while (pDataNode)
    {
        if ( IsEqualGUID(&pDataNode->guid, rGuid))
        {
            /*
             * Check if possibly volatile contents are still valid.
             */
            if (pDataNode->dwFlags & DDSPD_VOLATILE)
            {
                if ((dwCurrentStamp == 0) || (pDataNode->dwContentsStamp != dwCurrentStamp))
                {
                    DPF_ERR("Private data is volatile and state has changed");
                    *pcbData = 0;
                    return DDERR_EXPIRED;
                }
            }

            if (*pcbData < pDataNode->cbData)
            {
                *pcbData = pDataNode->cbData;
                return DDERR_MOREDATA;
            }

            if (pDataNode->dwFlags & DDSPD_IUNKNOWNPOINTER)
            {
                memcpy(pData,&(pDataNode->pData),pDataNode->cbData);
            }
            else
            {
                memcpy(pData,pDataNode->pData,pDataNode->cbData);
            }
            *pcbData = pDataNode->cbData;
            return DD_OK;
        }
        pDataNode=pDataNode->pNext;
    }

    return DDERR_NOTFOUND;
}

/* 
 * API entry points
 */


/*
 * SetPrivateData - Surface
 */
HRESULT DDAPI DD_Surface_SetPrivateData(
		LPDIRECTDRAWSURFACE     lpDDSurface,
                REFGUID                 rGuid,
                LPVOID                  pData,
                DWORD                   cbData,
                DWORD                   dwFlags)
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    HRESULT                     hr = DD_OK;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_SetPrivateData");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid surface description passed" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}

      	this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );

        hr = InternalSetPrivateData(
            &this_lcl->lpSurfMore->pPrivateDataHead,
            rGuid,
            pData, 
            cbData, 
            dwFlags,
            GET_LPDDRAWSURFACE_GBL_MORE( this_lcl->lpGbl )->dwContentsStamp );

        LEAVE_DDRAW();
        return hr;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	LEAVE_DDRAW();
	DPF_ERR( "Exception encountered validating parameters" );
	return DDERR_INVALIDPARAMS;
    }

}


/*
 * GetPrivateData - Surface
 */
HRESULT DDAPI DD_Surface_GetPrivateData(
		LPDIRECTDRAWSURFACE     lpDDSurface,
                REFGUID                 rGuid,
                LPVOID                  pData,
                LPDWORD                 pcbData)
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    HRESULT                     hr = DD_OK; 

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetPrivateData");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
            *pcbData = 0;
	    DPF_ERR( "Invalid surface description passed" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );

        hr = InternalGetPrivateData(
            &this_lcl->lpSurfMore->pPrivateDataHead,
            rGuid,
            pData, 
            pcbData, 
            GET_LPDDRAWSURFACE_GBL_MORE( this_lcl->lpGbl )->dwContentsStamp );

        LEAVE_DDRAW();
        return hr;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
}


/*
 * FreePrivateData - Surface
 */
HRESULT DDAPI DD_Surface_FreePrivateData(
		LPDIRECTDRAWSURFACE     lpDDSurface,
                REFGUID                 rGuid)
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    HRESULT                     hr = DD_OK; 

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_FreePrivateData");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid surface description passed" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );

	if( !VALID_IID_PTR( rGuid ) )
	{
	    DPF_ERR( "GUID reference is invalid" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
        hr = InternalFreePrivateData( &this_lcl->lpSurfMore->pPrivateDataHead, rGuid);

        LEAVE_DDRAW();
        return hr;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
}


/*
 * SetPrivateData - Palette
 */
HRESULT DDAPI DD_Palette_SetPrivateData(
		LPDIRECTDRAWPALETTE     lpDDPalette,
                REFGUID                 rGuid,
                LPVOID                  pData,
                DWORD                   cbData,
                DWORD                   dwFlags)
{
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    HRESULT                     hr = DD_OK;

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_SetPrivateData");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
            DPF_ERR( "Invalid palette pointer passed" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}

      	this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );

        hr =  InternalSetPrivateData(
            &this_lcl->pPrivateDataHead,
            rGuid,
            pData, 
            cbData, 
            dwFlags, 
            this_lcl->lpGbl->dwContentsStamp );

        LEAVE_DDRAW();
        return hr;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	LEAVE_DDRAW();
	DPF_ERR( "Exception encountered validating parameters" );
	return DDERR_INVALIDPARAMS;
    }

}


/*
 * GetPrivateData - Palette
 */
HRESULT DDAPI DD_Palette_GetPrivateData(
		LPDIRECTDRAWPALETTE     lpDDPalette,
                REFGUID                 rGuid,
                LPVOID                  pData,
                LPDWORD                 pcbData)
{
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    HRESULT                     hr = DD_OK; 

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_GetPrivateData");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
            *pcbData = 0;
	    DPF_ERR( "Invalid palette pointer passed" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );

        hr = InternalGetPrivateData(
            &this_lcl->pPrivateDataHead, 
            rGuid,
            pData,
            pcbData,
            this_lcl->lpGbl->dwContentsStamp );

        LEAVE_DDRAW();
        return hr;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
}


/*
 * FreePrivateData - Palette
 */
HRESULT DDAPI DD_Palette_FreePrivateData(
                LPDIRECTDRAWPALETTE     lpDDPalette,
                REFGUID                 rGuid)
{
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    HRESULT                     hr = DD_OK; 

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_FreePrivateData");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid palette pointer passed");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
	this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );

	if( !VALID_IID_PTR( rGuid ) )
	{
	    DPF_ERR( "GUID reference is invalid" );
	    LEAVE_DDRAW();
	    return DDERR_INVALIDPARAMS;
	}
        hr = InternalFreePrivateData( & this_lcl->pPrivateDataHead, rGuid);

        LEAVE_DDRAW();
        return hr;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
}

/*
 * GetUniquenessValue - Surface
 */
HRESULT EXTERN_DDAPI DD_Surface_GetUniquenessValue(
                LPDIRECTDRAWSURFACE lpDDSurface,
                LPDWORD lpValue )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    HRESULT                     hr = DD_OK; 

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_GetUniquenessValue");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid surface pointer passed");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
        this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );
	
        if (!VALID_PTR(lpValue, sizeof(LPVOID)))
        {
            DPF_ERR("lpValue may not be NULL");
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        
        (*lpValue) = GET_LPDDRAWSURFACE_GBL_MORE( this_lcl->lpGbl )->dwContentsStamp;
        
        LEAVE_DDRAW();
        return hr;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
}

/*
 * GetUniquenessValue - Palette
 */
HRESULT EXTERN_DDAPI DD_Palette_GetUniquenessValue(
                LPDIRECTDRAWPALETTE lpDDPalette,
                LPDWORD lpValue )
{
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    HRESULT                     hr = DD_OK; 

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_GetUniquenessValue");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid palette pointer passed");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
        this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );
	
        if (!VALID_PTR(lpValue, sizeof(LPVOID)))
        {
            DPF_ERR("lpValue may not be NULL");
            LEAVE_DDRAW();
            return DDERR_INVALIDPARAMS;
        }
        
        (*lpValue) = this_lcl->lpGbl->dwContentsStamp;
        
        LEAVE_DDRAW();
        return hr;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
}

/*
 * ChangeUniquenessValue -  Surface
 */
HRESULT EXTERN_DDAPI DD_Surface_ChangeUniquenessValue(
                LPDIRECTDRAWSURFACE lpDDSurface )
{
    LPDDRAWI_DDRAWSURFACE_INT	this_int;
    LPDDRAWI_DDRAWSURFACE_LCL	this_lcl;
    HRESULT                     hr = DD_OK; 

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Surface_ChangeUniquenessValue");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWSURFACE_INT) lpDDSurface;
	if( !VALID_DIRECTDRAWSURFACE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid surface pointer passed");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
        this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );
	
        BUMP_SURFACE_STAMP(this_lcl->lpGbl);
        
        LEAVE_DDRAW();
        return hr;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
}


/*
 * ChangeUniquenessValue -  Palette
 */
HRESULT EXTERN_DDAPI DD_Palette_ChangeUniquenessValue(
                LPDIRECTDRAWPALETTE lpDDPalette )
{
    LPDDRAWI_DDRAWPALETTE_INT	this_int;
    LPDDRAWI_DDRAWPALETTE_LCL	this_lcl;
    HRESULT                     hr = DD_OK; 

    ENTER_DDRAW();

    DPF(2,A,"ENTERAPI: DD_Palette_ChangeUniquenessValue");

    TRY
    {
	this_int = (LPDDRAWI_DDRAWPALETTE_INT) lpDDPalette;
	if( !VALID_DIRECTDRAWPALETTE_PTR( this_int ) )
	{
	    DPF_ERR( "Invalid palette pointer passed");
	    LEAVE_DDRAW();
	    return DDERR_INVALIDOBJECT;
	}
        this_lcl = this_int->lpLcl;
	DDASSERT( NULL != this_lcl );
	
        BUMP_PALETTE_STAMP(this_lcl->lpGbl);
        
        LEAVE_DDRAW();
        return hr;
    }
    EXCEPT( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF_ERR( "Exception encountered validating parameters" );
	LEAVE_DDRAW();
	return DDERR_INVALIDPARAMS;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\_dpf.c ===
#include "ddrawpr.h"

#include "..\..\misc\dpf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\sources.inc ===
TARGETNAME = main
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = \
    $(INCLUDES);          \
    ..\..\ddhelp;         \
    ..\..\ddhel;          \
    $(DXROOT)\dxg\inc

USE_ATL=1

C_DEFINES = $(C_DEFINES) /DNEW_DPF /DDIRECT3D_VERSION=0x0800

SOURCES = \
    ..\_dpf.c       \
    ..\_memallo.c   \
    ..\apphack.c    \
    ..\classfac.c   \
    ..\cliprgn.c    \
    ..\ddcallbk.c   \
    ..\ddclip.c     \
    ..\ddcolor.c    \
    ..\ddcreate.c   \
    ..\ddcsurf.c    \
    ..\dddefwp.c    \
    ..\ddesurf.c    \
    ..\ddfake.c     \
    ..\ddgamma.c    \
    ..\ddiunk.c     \
    ..\ddpal.c      \
    ..\ddraw.c      \
    ..\ddsacc.c     \
    ..\ddsatch.c    \
    ..\ddsblt.c     \
    ..\ddsckey.c    \
    ..\ddsiunk.c    \
    ..\ddsover.c    \
    ..\ddsurf.c     \
    ..\ddvp.c       \
    ..\ddmc.c       \
    ..\dllmain.c    \
    ..\drvinfo.c    \
    ..\misc.c       \
    ..\ddkernel.c   \
    ..\ddrestor.c   \
    ..\private.c    \
    ..\init.cpp     \
    ..\ddrefrsh.c

#    ..\alphablt.c   \
#    ..\ddstream.cpp \
#    ..\factory.c    \
#    ..\ddsprite.c   \
#    ..\ddoptsur.c   \
#    ..\decoder.cpp  \
#    ..\ddagpnt.c    \

#
# 04/11/2000 - allows for addition of BoundsChecker, etc 
#  libs specified in the OS environment
#
TARGETLIBS=$(TARGETLIBS)

PRECOMPILED_INCLUDE = ..\ddrawpr.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\_memallo.c ===
#include "ddrawpr.h"
#ifndef WIN95
#define __DXGUSEALLOC
#endif
#include "..\..\..\misc\memalloc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\w95csect.c ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95csect.c
 *  Content:	code for managing critical sections on Win95
 *		We trade a performance hit when 2 threads try to use a surface
 *		for only using 4 bytes (pointer) instead of 24 bytes for a
 *		critical section object PER SURFACE.
 *
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   22-feb-95	craige	initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#include "ddrawpr.h"

#if 0
#ifdef USE_CRITSECTS

/*
 * MyReinitializeCriticalSection
 */
BOOL MyReinitializeCriticalSection( LPVOID *lplpCriticalSection )
{
    *lplpCriticalSection = NULL;
    return TRUE;

} /* MyReinitializeCriticalSection */

/*
 * MyEnterCriticalSection
 */
BOOL MyEnterCriticalSection( LPVOID *lplpCriticalSection )
{
    LPCRITICAL_SECTION	pcs;

    if( *lplpCriticalSection != hDLLMutex )
    {
	EnterCriticalSection( hDLLMutex );
    }
    if( *lplpCriticalSection == NULL )
    {
	OutputDebugString( "DOING MALLOC" );
	pcs = MemAlloc( sizeof( CRITICAL_SECTION ) );
	if( pcs == NULL )
	{
	    DPF( 0, "OUT OF MEMORY CREATING CRITICAL SECTION" );
	    LeaveCriticalSection( hDLLMutex );
	    return FALSE;
	}
	ReinitializeCriticalSection( pcs );
	*lplpCriticalSection = pcs;
    }
    // ACKACK: ALWAYS WANT TO SEE THIS MESSAGE
    if( *lplpCriticalSection != hDLLMutex )
    {
//	OutputDebugString( "DCIENG32: EnterCriticalSection\r\n" );
    }
    EnterCriticalSection( *lplpCriticalSection );
    if( *lplpCriticalSection != hDLLMutex )
    {
	LeaveCriticalSection( hDLLMutex );
    }
    return TRUE;

} /* MyEnterCriticalSection */

/*
 * MyLeaveCriticalSection
 */
void MyLeaveCriticalSection( LPVOID *lplpCriticalSection )
{
    if( *lplpCriticalSection == NULL )
    {
	DPF( 0, "TRYING TO LEAVE NULL CRITICAL SECTION" );
	LeaveCriticalSection( hDLLMutex );
	return;
    }
    // ALWAYS WANT TO SEE THIS MESSAGE
    if( *lplpCriticalSection != hDLLMutex )
    {
//	OutputDebugString( "DCIENG32: LeaveCriticalSection\r\n" );
    }
    LeaveCriticalSection( *lplpCriticalSection );

} /* MyLeaveCriticalSection */

/*
 * MyDeleteCriticalSection
 */
void MyDeleteCriticalSection( LPVOID *lplpCriticalSection )
{
    EnterCriticalSection( hDLLMutex );
    if( *lplpCriticalSection == NULL )
    {
	LeaveCriticalSection( hDLLMutex );
	return;
    }
    DeleteCriticalSection( *lplpCriticalSection );
    MemFree( *lplpCriticalSection );
    *lplpCriticalSection = NULL;
    LeaveCriticalSection( hDLLMutex );

} /* MyDeleteCriticalSection */
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\swddi.c ===
#include "ddrawpr.h"
#include "..\..\..\d3d8\inc\d3d8ddi.h"
#include "d3d8sddi.h"
#include "ddithunk.h"


HRESULT
SwDDICreateSurface( PD3D8_CREATESURFACEDATA pCreateSurface, DDSURFACEDESC2* pSurfDesc)
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv =
        ((PDDDEVICEHANDLE)pCreateSurface->hDD)->pSwDD->lpLcl;
    DDHAL_CREATESURFACEDATA CreateSurfaceData;
    PD3D8_SWCALLBACKS pCallbacks =
        (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    DWORD dwRet = DDHAL_DRIVER_NOTHANDLED;
    DWORD i;


    if( pCallbacks->CreateSurface )
    {
        memset(&CreateSurfaceData, 0, sizeof(CreateSurfaceData));
        CreateSurfaceData.lpDD = pDrv->lpGbl;
        CreateSurfaceData.lpDDSurfaceDesc = (DDSURFACEDESC*)pSurfDesc;
        CreateSurfaceData.lplpSList = NULL;
        CreateSurfaceData.dwSCnt = pCreateSurface->dwSCnt;
        CreateSurfaceData.lplpSList = (LPDDRAWI_DDRAWSURFACE_LCL*)
            MemAlloc(sizeof(LPDDRAWI_DDRAWSURFACE_LCL) * CreateSurfaceData.dwSCnt);
        if (CreateSurfaceData.lplpSList == NULL)
        {
            return DDERR_OUTOFMEMORY;
        }

        for (i = 0; i < CreateSurfaceData.dwSCnt; i++)
        {
            CreateSurfaceData.lplpSList[i] =
                ((PDDSURFACE)pCreateSurface->pSList[i].hKernelHandle)->pTempHeavy->lpLcl;
        }

        dwRet = pCallbacks->CreateSurface( &CreateSurfaceData );

        // Now copy the fpVidMem and the pitch that the driver setup
        // back to the permanent structures

        for (i = 0; i < CreateSurfaceData.dwSCnt; i++)
        {
            pCreateSurface->pSList[i].pbPixels = (BYTE*)
                CreateSurfaceData.lplpSList[i]->lpGbl->fpVidMem;
            pCreateSurface->pSList[i].iPitch =
                CreateSurfaceData.lplpSList[i]->lpGbl->lPitch;
        }

        // Now clean everything up

        MemFree(CreateSurfaceData.lplpSList);

        if( dwRet == DDHAL_DRIVER_NOTHANDLED )
        {
            return DDERR_UNSUPPORTED;
        }
        return CreateSurfaceData.ddRVal;
    }
    else
    {
        return DDERR_UNSUPPORTED;
    }
}

void
SwDDIAttachSurfaces( LPDDRAWI_DDRAWSURFACE_LCL psurf_from_lcl,
                     LPDDRAWI_DDRAWSURFACE_LCL psurf_to_lcl )
{
    LPATTACHLIST    pal_from = NULL;
    LPATTACHLIST    pal_to = NULL;

    /*
     * allocate attachment structures
     */
    pal_from = MemAlloc(sizeof(ATTACHLIST));
    pal_to   = MemAlloc(sizeof(ATTACHLIST));
    if (pal_to == NULL || pal_from == NULL)
    {
        if( pal_from ) MemFree( pal_from );
        if( pal_to ) MemFree( pal_to );

        DPF_ERR("Failed memalloc, not attaching");
        return;
    }

    /*
     * connect the surfaces
     */
    pal_from->lpAttached = psurf_to_lcl;
    pal_from->dwFlags = DDAL_IMPLICIT;
    pal_from->lpLink = psurf_from_lcl->lpAttachList;
    psurf_from_lcl->lpAttachList = pal_from;
    psurf_from_lcl->dwFlags |= DDRAWISURF_ATTACHED;

    pal_to->lpAttached = psurf_from_lcl;
    pal_to->dwFlags = DDAL_IMPLICIT;
    pal_to->lpLink = psurf_to_lcl->lpAttachListFrom;
    psurf_to_lcl->lpAttachListFrom = pal_to;
    psurf_to_lcl->dwFlags |= DDRAWISURF_ATTACHED_FROM;
}

void
SwDDICreateSurfaceEx(LPDDRAWI_DIRECTDRAW_LCL pDrv,
                     LPDDRAWI_DDRAWSURFACE_LCL pLcl)
{
    PD3D8_SWCALLBACKS           pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    DDHAL_CREATESURFACEEXDATA   CreateExData;

    if ((pLcl != NULL) &&
        (pCallbacks->CreateSurfaceEx != NULL))
    {
        CreateExData.dwFlags = 0;
        CreateExData.lpDDLcl = pDrv;
        CreateExData.lpDDSLcl = pLcl;

        pCallbacks->CreateSurfaceEx(&CreateExData);
    }
}

void BreakOutstandingLocks(PDDSURFACE pSurf, LPDDRAWI_DDRAWSURFACE_LCL pLcl)
{
    D3D8_UNLOCKDATA   UnlockData;

    while (pLcl->lpGbl->dwUsageCount > 0)
    {
        SwDDIUnlock(pSurf->pDevice, pSurf, &UnlockData, pLcl);
    }
}

DWORD
SwDDIDestroySurface( HANDLE hDD, PDDSURFACE pSurf, LPDDRAWI_DDRAWSURFACE_LCL pLcl)
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv = ((PDDDEVICEHANDLE)hDD)->pSwDD->lpLcl;
    PD3D8_SWCALLBACKS       pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    DDHAL_DESTROYSURFACEDATA DestroyData;

    DestroyData.lpDD = pDrv->lpGbl;
    DestroyData.lpDDSurface = pLcl;
    DestroyData.ddRVal = DD_OK;

    BreakOutstandingLocks(pSurf, pLcl);

    if (pCallbacks->DestroySurface != NULL)
    {
        pCallbacks->DestroySurface(&DestroyData);
    }

    return DestroyData.ddRVal;
}

DWORD WINAPI
SwContextCreate(PD3D8_CONTEXTCREATEDATA pCreateContext)
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv = ((PDDDEVICEHANDLE)pCreateContext->hDD)->pSwDD->lpLcl;
    PD3D8_SWCALLBACKS   pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    D3DHAL_CONTEXTCREATEDATA    ContextData;
    DWORD                       dwRet = DDHAL_DRIVER_NOTHANDLED;

    if (pCallbacks->CreateContext != NULL)
    {
        ContextData.lpDDLcl = pDrv;
        DDASSERT(((PDDSURFACE)pCreateContext->hSurface)->dwFlags & DDSURFACE_HEAVYWEIGHT);
        ContextData.lpDDSLcl = ((PDDSURFACE)pCreateContext->hSurface)->Surface.pHeavy->lpLcl;
        if (pCreateContext->hDDSZ == NULL)
        {
            ContextData.lpDDSZLcl = NULL;
        }
        else
        {
            DDASSERT(((PDDSURFACE)pCreateContext->hDDSZ)->dwFlags & DDSURFACE_HEAVYWEIGHT);
            ContextData.lpDDSZLcl = ((PDDSURFACE)pCreateContext->hDDSZ)->Surface.pHeavy->lpLcl;
        }
        ContextData.dwPID = pCreateContext->dwPID;
        ContextData.dwhContext = pCreateContext->dwhContext;

        dwRet = pCallbacks->CreateContext(&ContextData);

        pCreateContext->dwhContext = ContextData.dwhContext;
        pCreateContext->ddrval = MapLegacyResult(ContextData.ddrval);
    }

    return dwRet;
}

DWORD WINAPI
SwDrawPrimitives2(PD3D8_DRAWPRIMITIVES2DATA pdp2data)
{
    LPDDRAWI_DIRECTDRAW_LCL     pDrv = ((PDDSURFACE)pdp2data->hDDCommands)->pDevice->pSwDD->lpLcl;
    PD3D8_SWCALLBACKS           pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    D3DHAL_DRAWPRIMITIVES2DATA  DP2Data;
    HRESULT                     hr;
    DWORD                       dwRet;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavyCommand;
    LPDDRAWI_DDRAWSURFACE_INT   pHeavyVertex = NULL;
    DDSURFACE*                  pSurfCommand;
    DDSURFACE*                  pSurfVertex = NULL;

    dwRet = DDHAL_DRIVER_NOTHANDLED;
    if (pCallbacks->DrawPrimitives2 != NULL)
    {
        memcpy(&DP2Data, pdp2data, sizeof(DP2Data));

        ENTER_DDRAW();
        pSurfCommand = pdp2data->hDDCommands;
        if (pSurfCommand->dwFlags & DDSURFACE_LIGHTWEIGHT)
        {
            pHeavyCommand = MapLightweightSurface(pSurfCommand);
        }
        else
        {
            pHeavyCommand = pSurfCommand->Surface.pHeavy;
        }
        if (pHeavyCommand != NULL)
        {
            DP2Data.ddrval = DD_OK;
            DP2Data.lpDDCommands    = pHeavyCommand->lpLcl;
            if (!(DP2Data.dwFlags & D3DHALDP2_USERMEMVERTICES))
            {
                pSurfVertex = pdp2data->hDDCommands;
                if (pSurfVertex->dwFlags & DDSURFACE_LIGHTWEIGHT)
                {
                    pHeavyVertex = MapLightweightSurface(pSurfVertex);
                }
                else
                {
                    pHeavyVertex = pSurfVertex->Surface.pHeavy;
                }
                if (pHeavyVertex != NULL)
                {
                    DP2Data.lpDDVertex  = pHeavyVertex->lpLcl;
                }
                else
                {
                    DP2Data.ddrval = DDERR_OUTOFMEMORY;
                }
            }
            if (DP2Data.ddrval == DD_OK)
            {
                dwRet = pCallbacks->DrawPrimitives2(&DP2Data);

                pdp2data->ddrval        = DP2Data.ddrval;
                pdp2data->dwErrorOffset = DP2Data.dwErrorOffset;
            }
        }
        if ((pHeavyCommand != NULL) &&
            (pSurfCommand->dwFlags & DDSURFACE_LIGHTWEIGHT ))
        {
            UnmapLightweightSurface(pSurfCommand);
        }
        if ((pHeavyVertex != NULL) &&
            (pSurfVertex->dwFlags & DDSURFACE_LIGHTWEIGHT ))
        {
            UnmapLightweightSurface(pSurfVertex);
        }
        LEAVE_DDRAW();
    }

    return dwRet;
}

HRESULT
SwDDILock( HANDLE hDD, PDDSURFACE pSurf, PD3D8_LOCKDATA pLockData, LPDDRAWI_DDRAWSURFACE_LCL pLcl )
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv = ((PDDDEVICEHANDLE)hDD)->pSwDD->lpLcl;
    PD3D8_SWCALLBACKS       pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    DDHAL_LOCKDATA          LockData;
    DWORD                   dwRet = DDHAL_DRIVER_HANDLED;

    LockData.lpDD = pDrv->lpGbl;
    LockData.lpDDSurface = pLcl;
    LockData.bHasRect = pLockData->bHasRect;
    LockData.rArea = pLockData->rArea;
    LockData.dwFlags = pLockData->dwFlags;
    LockData.ddRVal = DDERR_WASSTILLDRAWING;

    if (pLockData->bHasBox)
    {
        LockData.bHasRect = TRUE;
        LockData.rArea.left = pLockData->box.Left;
        LockData.rArea.right = pLockData->box.Right;
        LockData.rArea.top = pLockData->box.Top;
        LockData.rArea.bottom = pLockData->box.Bottom;
        LockData.rArea.left |= (pLockData->box.Front << 16);
        LockData.rArea.right |= (pLockData->box.Back << 16);
    }

    pLcl->lpGbl->dwUsageCount++;
    while (LockData.ddRVal == DDERR_WASSTILLDRAWING)
    {
        if (pCallbacks->Lock != NULL)
        {
            dwRet = pCallbacks->Lock(&LockData);
        }
        else
        {
            LockData.ddRVal = DD_OK;
        }
    }

    if (LockData.ddRVal != DD_OK)
    {
        pLcl->lpGbl->dwUsageCount--;
    }

    pLockData->lpSurfData = LockData.lpSurfData;

    return LockData.ddRVal;
}

HRESULT
SwDDIUnlock( HANDLE hDD, PDDSURFACE pSurf, D3D8_UNLOCKDATA* pUnlockData, LPDDRAWI_DDRAWSURFACE_LCL pLcl )
{
    LPDDRAWI_DIRECTDRAW_LCL pDrv = ((PDDDEVICEHANDLE)hDD)->pSwDD->lpLcl;
    PD3D8_SWCALLBACKS       pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;
    DDHAL_UNLOCKDATA        UnlockData;
    DWORD                   dwRet = DDHAL_DRIVER_HANDLED;;

    UnlockData.lpDD = pDrv->lpGbl;
    UnlockData.lpDDSurface = pLcl;
    UnlockData.ddRVal = DD_OK;

    pLcl->lpGbl->dwUsageCount--;
    if (pCallbacks->Unlock != NULL)
    {
        pCallbacks->Unlock(&UnlockData);
    }

    return UnlockData.ddRVal;
}

DWORD APIENTRY SwDdSetColorkey( PD3D8_SETCOLORKEYDATA pSetColorkey)
{
#if 0
    LPDDRAWI_DIRECTDRAW_LCL pDrv = ((PDDDEVICEHANDLE)pSetColorkey->hDD)->pSwDD->lpLcl;
//    LPDDRAWI_DDRAWSURFACE_LCL surf_lcl = ((PDDSURFACE)pSetColorkey->hSurface)->Surface.pLight->lpLcl;
    PD3D8_SWCALLBACKS       pCallbacks = (PD3D8_SWCALLBACKS)pDrv->lpGbl->lpDDCBtmp;

    surf_lcl->ddckCKSrcBlt.dwColorSpaceLowValue = pSetColorkey->ColorValue;
    surf_lcl->dwFlags |= DDRAWISURF_HASCKEYSRCBLT;
    pSetColorkey->ddRVal = DD_OK;

    if (pCallbacks->SetColorkey != NULL)
    {
        DDHAL_SETCOLORKEYDATA   data;

        data.lpDD                       = pDrv->lpGbl;
        data.lpDDSurface                = surf_lcl;
        data.dwFlags                    = DDCKEY_SRCBLT;
        data.ckNew.dwColorSpaceLowValue = pSetColorkey->ColorValue;
        data.ddRVal                     = DD_OK;

        pCallbacks->SetColorkey(&data);
        pSetColorkey->ddRVal = data.ddRVal;
    }
#endif
    return DDHAL_DRIVER_HANDLED;
}

LPDDRAWI_DIRECTDRAW_INT
SwDDICreateDirectDraw( void)
{
    LPDDRAWI_DIRECTDRAW_INT pInt;
    LPDDRAWI_DIRECTDRAW_LCL pLcl;
    LPDDRAWI_DIRECTDRAW_GBL pGbl;
    BYTE*                   pTemp;

    pInt = (LPDDRAWI_DIRECTDRAW_INT)MemAlloc(sizeof(DDRAWI_DIRECTDRAW_LCL) +
        sizeof(DDRAWI_DIRECTDRAW_GBL) +
        sizeof(DDRAWI_DIRECTDRAW_INT));
    if (pInt == NULL)
    {
        return NULL;
    }

    pTemp = (BYTE*)pInt;
    pTemp += sizeof(DDRAWI_DIRECTDRAW_INT);
    pLcl = (LPDDRAWI_DIRECTDRAW_LCL) pTemp;
    pInt->lpLcl = pLcl;
    pTemp += sizeof(DDRAWI_DIRECTDRAW_LCL);
    pGbl = (LPDDRAWI_DIRECTDRAW_GBL) pTemp;
    pLcl->lpGbl = pGbl;

    pLcl->dwLocalRefCnt = 1;
    pGbl->dwRefCnt = 1;

    return pInt;
}


void
SwDDIMungeCaps( HINSTANCE           hLibrary,
                HANDLE              hDD,
                PD3D8_DRIVERCAPS    pDriverCaps,
                PD3D8_CALLBACKS     pCallbacks,
                LPDDSURFACEDESC     pTextureFormats,
                UINT*               pcTextureFormats,
                VOID*               pInitFunction
                )
{
    PD3D8GetSWInfo          pfnGetSWInfo;
    D3DCAPS8                swCaps;
    D3D8_SWCALLBACKS        swCallbacks;
    LPDDRAWI_DIRECTDRAW_LCL pLcl;
    LPDDRAWI_DIRECTDRAW_GBL pGbl;
    PDDDEVICEHANDLE         pDevice = (PDDDEVICEHANDLE) hDD;
    DWORD                   i;
    DWORD                   NumTex = 0;
    DDSURFACEDESC*          pTexList = NULL;

    // Get the info from the software driver
    memset (&swCaps, 0, sizeof(swCaps));
    memset (&swCallbacks, 0, sizeof(swCallbacks));
    if (hLibrary != NULL)
    {
        pfnGetSWInfo = (PD3D8GetSWInfo)GetProcAddress (hLibrary, D3D8HOOK_GETSWINFOPROCNAME);
    }
    else if ((hLibrary == NULL) && (pDevice->DeviceType == D3DDEVTYPE_REF))
    {
        HINSTANCE hLibraryD3D8 = NULL;

        // No hLibrary or an init function...it means time to fall
        // back on crippled ref.
        DPF(0,"Could not find d3dref8.dll, loading internal crippled ReferenceDevice, no rendering will take place\n");
        
        hLibraryD3D8 = LoadLibrary("d3d8.dll");
        if (hLibraryD3D8 != NULL)
        {
            pfnGetSWInfo = (PD3D8GetSWInfo)GetProcAddress (hLibraryD3D8, D3D8HOOK_GETSWINFOPROCNAME);
            FreeLibrary( hLibraryD3D8 );
        }
        else
        {
            DPF(0,"Could not find d3d8.dll to get the crippled reference device, a really bad problem indeed!!!\n");
            return;
        }
    }
    else
    {
        pfnGetSWInfo = (PD3D8GetSWInfo)pInitFunction;
    }

    if (pfnGetSWInfo != NULL )
    {
        (*pfnGetSWInfo)(&swCaps, &swCallbacks, &NumTex, &pTexList);
    }
    
    // Fill in out DDraw structure with the info that we have

    pLcl = pDevice->pSwDD->lpLcl;
    pGbl = pLcl->lpGbl;
    strcpy (pGbl->cDriverName, pDevice->szDeviceName);
    pGbl->vmiData.dwDisplayWidth = pDriverCaps->DisplayWidth;
    pGbl->vmiData.dwDisplayHeight = pDriverCaps->DisplayHeight;
    ConvertToOldFormat( &pGbl->vmiData.ddpfDisplay, pDriverCaps->DisplayFormatWithAlpha);

    // Overwite the hardware caps w/ the software caps
    memcpy (&pDriverCaps->D3DCaps, &swCaps, sizeof(swCaps));
    pDriverCaps->dwFlags |= DDIFLAG_D3DCAPS8;

    // Copy over our texture format list if required.
    *pcTextureFormats = NumTex;
    if (pTextureFormats && pTexList)
    {
        memcpy(
            pTextureFormats,
            pTexList,
            sizeof (*pTexList) * NumTex);
    }


    // Now change the callback table to point to the ones for the SW drivers

    if (swCallbacks.CreateContext == NULL)
    {
        pCallbacks->CreateContext           = NULL;
    }
    else
    {
        pCallbacks->CreateContext           = SwContextCreate;
    }
    pCallbacks->ContextDestroy              = (PD3D8DDI_CONTEXTDESTROY) swCallbacks.ContextDestroy;
    pCallbacks->ContextDestroyAll           = (PD3D8DDI_CONTEXTDESTROYALL) swCallbacks.ContextDestroyAll;
    pCallbacks->RenderState                 = (PD3D8DDI_RENDERSTATE) swCallbacks.RenderState;
    pCallbacks->RenderPrimitive             = (PD3D8DDI_RENDERPRIMITIVE) swCallbacks.RenderPrimitive;
    if (swCallbacks.DrawPrimitives2 == NULL)
    {
        pCallbacks->DrawPrimitives2         = NULL;
    }
    else
    {
        pCallbacks->DrawPrimitives2         = SwDrawPrimitives2;
    }
    pCallbacks->GetDriverState              = (PD3D8DDI_GETDRIVERSTATE) swCallbacks.GetDriverState;
    pCallbacks->ValidateTextureStageState   = (PD3D8DDI_VALIDATETEXTURESTAGESTATE) swCallbacks.ValidateTextureStageState;
    pCallbacks->SceneCapture                = (PD3D8DDI_SCENECAPTURE) swCallbacks.SceneCapture;
    pCallbacks->Clear2                      = (PD3D8DDI_CLEAR2) swCallbacks.Clear2;
    pCallbacks->SetColorkey                 = (PD3D8DDI_SETCOLORKEY) SwDdSetColorkey;

    // Save the original software callbacks so we can call the software driver later

    if (pGbl->lpDDCBtmp == NULL)
    {
        pGbl->lpDDCBtmp = (LPDDHAL_CALLBACKS) MemAlloc(sizeof(D3D8_SWCALLBACKS));
    }
    if (pGbl->lpDDCBtmp != NULL)
    {
        memcpy(pGbl->lpDDCBtmp, &swCallbacks, sizeof(swCallbacks));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\w95dci.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95dci.c
 *  Content:	DCI thunk helper code
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   19-jun-95	craige	initial implementation
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "dpf.h"
#include "memalloc.h"
#include "dciman.h"

extern int WINAPI DCICreatePrimary32( HDC hdc, LPDCISURFACEINFO lpSurface );
extern void WINAPI DCIDestroy32( LPDCISURFACEINFO pdci );

/*
 * DCICreatePrimary
 */
int WINAPI DCICreatePrimary( HDC hdc, LPDCISURFACEINFO *lplpSurface )
{
    int                     rc;
    LPDCISURFACEINFO        lpSurface;

    *lplpSurface = NULL;

    lpSurface = MemAlloc( sizeof( *lpSurface ) );
    if( lpSurface == NULL )
    {
	return DCI_ERR_OUTOFMEMORY;
    }
    lpSurface->dwSize = sizeof( DCIPRIMARY );
    rc = DCICreatePrimary32( hdc, lpSurface );
    if( rc < 0 )
    {
	DPF( 2, "DCICreatePrimary32: rc = %ld", rc );
	MemFree( lpSurface );
	return rc;
    }
    *lplpSurface = lpSurface;
    return rc;

} /* DCICreatePrimary */

/*
 * DCIDestroy
 */
void WINAPI DCIDestroy( LPDCISURFACEINFO pdci )
{
    DCIDestroy32( pdci );
    MemFree( pdci );

} /* DCIDestroy */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\_w95help.c ===
#include "ddrawpr.h"

#include "..\..\misc\w95help.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\w95hack.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95hack.c
 *  Content:	Win95 hack-o-rama code
 *		This is a HACK to handle the fact that Win95 doesn't notify
 *		a DLL when a process is destroyed.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   28-mar-95	craige	initial implementation
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	reworked for new ddhelp
 *   11-apr-95	craige	bug where dwFakeCurrPid was getting set and
 *			other processes were ending up using it!
 *   24-jun-95	craige	call RemoveProcessFromDLL; use that to fiddle
 *			with DLL refcnt
 *   25-jun-95	craige	one ddraw mutex
 *   19-jul-95	craige	notify DDHELP to clean up DC list on last object detach
 *   20-jul-95	craige	internal reorg to prevent thunking during modeset
 *   12-oct-96  colinmc Improvements to Win16 locking code to reduce virtual
 *                      memory usage
 *   18-jan-97  colinmc ddhelp vxd handling is no longer win16 lock specific
 *                      we now need it for agp support
 *
 ***************************************************************************/
#include "ddrawpr.h"
#include "dx8priv.h"

/*
 * HackGetCurrentProcessId
 *
 * This call is used in place of GetCurrentProcessId on Win95.
 * This allows us to substitute the pid of the terminated task passed to
 * us from DDHELP as the "current" process.
 */
DWORD HackGetCurrentProcessId( void )
{
    DWORD	pid;

    pid = GetCurrentProcessId();
    if( pid == dwGrimReaperPid )
    {
	return dwFakeCurrPid;
    }
    else
    {
	return pid;
    }

} /* HackGetCurrentProcessId */

/*
 * DDNotify
 *
 * called by DDHELP to notify us when a pid is dead
 */
BOOL DDAPI DDNotify( LPDDHELPDATA phd )
{
    BOOL		rc;
    //extern DWORD	dwRefCnt;

#ifdef USE_CHEAP_MUTEX
    DestroyPIDsLock (&CheapMutexCrossProcess,phd->pid,DDRAW_FAST_CS_NAME);
#endif

    ENTER_DDRAW();

    dwGrimReaperPid = GetCurrentProcessId();
    dwFakeCurrPid = phd->pid;
    DPF( 4, "************* DDNotify: dwPid=%08lx has died, calling CurrentProcessCleanup", phd->pid );
    rc = FALSE;

    CurrentProcessCleanup( TRUE );

    if( RemoveProcessFromDLL( phd->pid ) )
    {
	/*
	 * update refcnt if RemoveProcessFromDLL is successful.
	 * It is only successful if we had a process get blown away...
	 */
	DPF( 5, "DDNotify: DLL RefCnt = %lu", dwRefCnt );
       	if( dwRefCnt == 2 )
	{
	    DPF( 5, "DDNotify: On last refcnt, safe to kill DDHELP.EXE" );
            dwRefCnt = 1;
	    rc = TRUE;	// free the DC list
            FreeAppHackData();
	    #if defined( DEBUG ) && defined (WIN95)
                DPF( 6, "Memory state after automatic cleanup: (one allocation expected)" );
		MemState();
	    #endif
        }
	else if( dwRefCnt == 1 )
	{
	    DPF( 0, "ERROR! DLL REFCNT DOWN TO 1" );
	    #if 0
		MemFini();
		dwRefCnt = 0;
		strcpy( phd->fname, DDHAL_APP_DLLNAME );
	    #endif
	}
	else if( dwRefCnt > 0 )
	{
	    dwRefCnt--;
	}
    }
    /* order is important, clear dwGrimReaperPid first */
    dwGrimReaperPid = 0;
    dwFakeCurrPid = 0;
    DPF( 4, "************* DDNotify: *** DONE ***" );

    LEAVE_DDRAW();
    return rc;

} /* DDNotify */

/*
 * DDNotifyModeSet
 *
 * called by ddhelp when an extern modeset is done...
 *
 * NOTE: We can explicitly use the cached DDHELP
 * VXD handle as we know this code can only ever get
 * executed on a DDHELP thread.
 */
void DDAPI DDNotifyModeSet( LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;
    BOOL bRestoreGamma;

    ENTER_DDRAW();

    /* DPF( 2, "DDNotifyModeSet, object %08lx", pdrv ); */

    /*
     * make sure the driver isn't trying to lie to us about the old object
     * This check should always be made at the top of this routine, since it's
     * possible in stress scenarios for ddhelp's modeset thread to wake up
     * just before it's killed at the end of DD_Release (since the code to kill
     * the mode set thread is executed AFTER the last LEAVE_DDRAW in DD_Release).
     */
    if( pdrv != NULL )
    {
	pdrv_lcl = lpDriverLocalList;
	while( pdrv_lcl != NULL )
	{
	    if( pdrv_lcl->lpGbl == pdrv )
	    {
		break;
	    }
	    pdrv_lcl = pdrv_lcl->lpLink;
	}
	if( pdrv_lcl == NULL )
	{
	    LEAVE_DDRAW();
	    return;
	}
    }

    bRestoreGamma = ( pdrv_lcl->lpPrimary != NULL ) &&
        ( pdrv_lcl->lpPrimary->lpLcl->lpSurfMore->lpGammaRamp != NULL ) &&
        ( pdrv_lcl->lpPrimary->lpLcl->dwFlags & DDRAWISURF_SETGAMMA );

    #ifdef WIN95
        DDASSERT( INVALID_HANDLE_VALUE != hHelperDDVxd );
        FetchDirectDrawData( pdrv, TRUE, 0, hHelperDDVxd, NULL, 0 , NULL );
    #else /* WIN95 */
        FetchDirectDrawData( pdrv, TRUE, 0, NULL, NULL, 0 , NULL );
    #endif /* WIN95 */

    /*
     * Some drivers reset the gamma after a mode change, so we need to
     * force it back.
     */
    if( bRestoreGamma )
    {
        SetGamma( pdrv_lcl->lpPrimary->lpLcl, pdrv_lcl );
    }

    LEAVE_DDRAW();
    DPF( 4, "DDNotifyModeSet DONE" );

} /* DDNotifyModeSet */

/*
 * DDNotifyDOSBox
 *
 * called by ddhelp when exiting from a DOS box...
 *
 * NOTE: We can explicitly use the cached DDHELP
 * VXD handle as we know this code can only ever get
 * executed on a DDHELP thread.
 */
void DDAPI DDNotifyDOSBox( LPDDRAWI_DIRECTDRAW_GBL pdrv )
{
    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;
    BOOL bRestoreGamma;

    ENTER_DDRAW();

    /* DPF( 2, "DDNotifyDOSBox, object %08lx", pdrv ); */

    /*
     * make sure the driver isn't trying to lie to us about the old object
     * This check should always be made at the top of this routine, since it's
     * possible in stress scenarios for ddhelp's modeset thread to wake up
     * just before it's killed at the end of DD_Release (since the code to kill
     * the mode set thread is executed AFTER the last LEAVE_DDRAW in DD_Release).
     */
    if( pdrv != NULL )
    {
	pdrv_lcl = lpDriverLocalList;
	while( pdrv_lcl != NULL )
	{
	    if( pdrv_lcl->lpGbl == pdrv )
	    {
		break;
	    }
	    pdrv_lcl = pdrv_lcl->lpLink;
	}
	if( pdrv_lcl == NULL )
	{
	    LEAVE_DDRAW();
	    return;
	}
    }

    bRestoreGamma = ( pdrv_lcl->lpPrimary != NULL ) &&
        ( pdrv_lcl->lpPrimary->lpLcl->lpSurfMore->lpGammaRamp != NULL ) &&
        ( pdrv_lcl->lpPrimary->lpLcl->dwFlags & DDRAWISURF_SETGAMMA );

    #ifdef WIN95
        InvalidateAllSurfaces( pdrv, hHelperDDVxd, TRUE );
    #else
        InvalidateAllSurfaces( pdrv, NULL, TRUE );
    #endif

    /*
     * Invalidating the surfaces will mess up the gamma so we need to
     * restore it.
     */
    if( bRestoreGamma )
    {
        SetGamma( pdrv_lcl->lpPrimary->lpLcl, pdrv_lcl );
    }

    LEAVE_DDRAW();
    DPF( 4, "DDNotifyDOSBox DONE" );

} /* DDNotifyDOSBox */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\w95priv.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95priv.c
 *  Content:	Private interface between DDRAW and the display driver
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   23-jan-95	craige	initial implementation
 *   27-feb-95	craige 	new sync. macros
 *   01-apr-95	craige	happy fun joy updated header file
 *   14-may-95	craige	cleaned out obsolete junk
 *   16-jun-95	craige	new surface structure
 *   19-jun-95	craige	added DD32_StreamingNotify
 *   22-jun-95	craige	added DD32_ClippingNotify
 *   24-jun-95	craige	trap faults in ClippinyNotify
 *   25-jun-95	craige	one ddraw mutex
 *   02-jul-95	craige	commented out streaming, clipper notification
 *   18-jan-97  colinmc AGP support
 *   31-oct-97 johnstep Added DD32_HandleExternalModeChange
 *
 ***************************************************************************/
#include "ddrawpr.h"

#ifdef STREAMING
/*
 * DD32_StreamingNotify
 */
void EXTERN_DDAPI DD32_StreamingNotify( DWORD ptr )
{

} /* DD32_StreamingNotify */
#endif

#ifdef CLIPPER_NOTIFY
/*
 * DD32_ClippingNotify
 */
void EXTERN_DDAPI DD32_ClippingNotify( LPWINWATCH pww, DWORD code )
{
    LPDDRAWI_DDRAWCLIPPER_LCL	this_lcl;
    LPDDRAWI_DDRAWCLIPPER_GBL	this;

    try
    {
	this_lcl = pww->lpDDClipper;
	this = this_lcl->lpGbl;
	if( pww->lpCallback != NULL )
	{
	    pww->lpCallback( (LPDIRECTDRAWCLIPPER) this_lcl, (HWND) pww->hWnd,
				code, pww->lpContext );
	}
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
	DPF( 1, "Trapped Exception in ClippingNotify" );
    }

} /* DD32_ClippingNotify */

/*
 * DD32_WWClose
 */
void EXTERN_DDAPI DD32_WWClose( LPWINWATCH pww )
{
    WWClose( pww );

} /* DD32_WWClose */
#endif

/*
 * DDHAL32_VidMemAlloc
 */
FLATPTR EXTERN_DDAPI DDHAL32_VidMemAlloc(
		LPDDRAWI_DIRECTDRAW_GBL this,
		int heap,
		DWORD dwWidth,
		DWORD dwHeight )
{
    FLATPTR	ptr;

    ENTER_DDRAW();

    if( heap >= (int) this->vmiData.dwNumHeaps )
    {
	ptr = (FLATPTR) NULL;
    }
    else
    {
	HANDLE hdev;
        #ifdef    WIN95
            BOOLEAN close;
        #endif /* WIN95 */

	#ifdef    WIN95
            /* See if the global VXD handle contains a valid value. If not,
             * then just get a valid VXD handle from GetDXVxdHandle().
             * (snene 2/23/98)
             */
            if( INVALID_HANDLE_VALUE == (HANDLE)this->hDDVxd )
            {
	        /*
	         * As we may need to commit AGP memory we need a VXD handle
	         * to communicate with the DirectX VXD. Rather than hunting
	         * through the driver object list hoping we will find a
	         * local object for this process we just create a handle
	         * and discard it after the allocation. This should not be
	         * performance critical code to start with.
	         */
	        hdev = GetDXVxdHandle();
                if ( INVALID_HANDLE_VALUE == hdev )
                {
                    LEAVE_DDRAW()
                    return (FLATPTR) NULL;
                }
                close = TRUE;
            }
            /* If the global handle is valid, then we are being called as a
             * result of CreateSurface being called and so we just use the
             * global handle to speed things up.
             * (snene 2/23/98)
             */
            else
            {
                hdev = (HANDLE)this->hDDVxd;
                close = FALSE;
            }
	#else  /* WIN95 */
	    hdev = INVALID_HANDLE_VALUE;
	#endif /* WIN95 */

        /* Pass NULL Alignment and new pitch pointer */
	ptr = HeapVidMemAlloc( &(this->vmiData.pvmList[ heap ]),
			       dwWidth, dwHeight, hdev , NULL , NULL, NULL );

	#ifdef WIN95
            if( close )
	        CloseHandle( hdev );
	#endif /* WIN95 */
    }
    LEAVE_DDRAW()
    return ptr;

} /* DDHAL32_VidMemAlloc */

/*
 * DDHAL32_VidMemFree
 */
void EXTERN_DDAPI DDHAL32_VidMemFree(
		LPDDRAWI_DIRECTDRAW_GBL this,
		int heap,
		FLATPTR ptr )
{
    ENTER_DDRAW()

    if( this && heap < (int) this->vmiData.dwNumHeaps )
    {
	VidMemFree( this->vmiData.pvmList[ heap ].lpHeap, ptr );
    }
    LEAVE_DDRAW()

} /* DDHAL32_VidMemFree */

#ifdef POSTPONED
//=============================================================================
//
//  Function: DD32_HandleExternalModeChange
//
//  This function is ONLY called by DDRAw16 on an external mode change.
//
//  Parameters:
//
//      LPDEVMODE pdm [IN] - includes the name of the display device
//
//  Return:
//
//      FALSE if display settings should not be changed
//
//=============================================================================

static char szDisplay[] = "display";
static char szDisplay1[] = "\\\\.\\Display1";

BOOL EXTERN_DDAPI DD32_HandleExternalModeChange(LPDEVMODE pdm)
{
    LPDDRAWI_DIRECTDRAW_LCL pdrv_lcl;
    BOOL                    primary;

    //
    // This is ONLY called from DDRAW16 once we already have the Win16
    // lock. We have to give it up before enterint DDraw because some other
    // process may be inside DDraw.
    //

    INCW16CNT();
    LEAVE_WIN16LOCK();
    ENTER_DDRAW();
    ENTER_WIN16LOCK();

    //
    // We'll get szDisplay for the primary display, rather than szDisplay1,
    // but a multimon-aware app may have explicitly created a device object
    // for szDisplay1, so we need to handle this case.
    //

    primary = !lstrcmpi(pdm->dmDeviceName, szDisplay);

    for (pdrv_lcl = lpDriverLocalList; pdrv_lcl; pdrv_lcl = pdrv_lcl->lpLink)
    {
        if (!lstrcmpi(pdrv_lcl->lpGbl->cDriverName, pdm->dmDeviceName) ||
            (primary && !lstrcmpi(pdrv_lcl->lpGbl->cDriverName, szDisplay1)))
        {
            DPF(4, "Mode change on device: %s", pdrv_lcl->lpGbl->cDriverName);
            InvalidateAllSurfaces(pdrv_lcl->lpGbl, NULL, FALSE);
        }
    }

    LEAVE_DDRAW();
    DECW16CNT();

    return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\w95hal.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95hal.c
 *  Content:	routines to invoke HAL on Win95
 *		These routines redirect the callbacks from the 32-bit
 *		side to the driver
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   20-jan-95	craige	initial implementation
 *   03-feb-95	craige	performance tuning, ongoing work
 *   11-mar-95	craige	palette stuff
 *   01-apr-95	craige	happy fun joy updated header file
 *   07-apr-95	craige	check src surface ptrs for NULL in blt
 *   13-apr-95	craige	thunk pointer for WaitForVerticalBlank flip test
 *   15-apr-95	craige	more flags for pointer thunking in WaitForVerticalBlank
 *   14-may-95	craige	cleaned out obsolete junk
 *   22-may-95	craige	16:16 ptrs always avail. for surfaces/palettes
 *   28-may-95	craige	cleaned up HAL: added GetBltStatus; GetFlipStatus;
 *			GetScanLine
 *   19-jun-95	craige	removed _DDHAL_EnumAllSurfacesCallback
 *   26-jun-95	craige	reorganized surface structure
 *   27-jun-95	craige	duplicate surfaces caused crash
 *   29-jun-95	craige	fully alias CreateSurface
 *   10-jul-95	craige	support SetOverlayPosition
 *   10-aug-95  toddla  Blt, Lock, Flip need to not trash the driver data
 *                      because it might get reused if the DDXXX_WAIT flag
 *                      is used, or if a clipper is attached.
 *   10-dec-95  colinmc added dummy _DDHAL_ entry points for the execute
 *                      buffer HAL.
 *   13-apr-95  colinmc Bug 17736: No driver notfication of flip to GDI
 *   01-oct-96	ketand	added GetAvailDriverMemory
 *   20-jan-97  colinmc AGP support
 *
 ***************************************************************************/
#include "ddrawpr.h"

#ifdef WIN95

#define GETSURFALIAS( psurf_lcl ) \
		GetPtr16( psurf_lcl )

#define GETDATAALIAS( psx, sv ) \
		if( !(psx->dwFlags & DDRAWISURF_DATAISALIASED) ) \
		{ \
		    sv = psx->lpGbl; \
		    psx->lpGbl = GetPtr16( psx->lpGbl ); \
		    psx->dwFlags |= DDRAWISURF_DATAISALIASED; \
		}  \
		else \
		{ \
		    sv = (LPVOID) 0xffffffff; \
		}

#define RESTOREDATAALIAS( psx, sv ) \
		if( sv != (LPVOID) 0xffffffff ) \
		{ \
		    psx->lpGbl = sv; \
		    psx->dwFlags &= ~DDRAWISURF_DATAISALIASED; \
		}

/****************************************************************************
 *
 * DRIVER CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * _DDHAL_CreatePalette
 */
DWORD DDAPI _DDHAL_CreatePalette( LPDDHAL_CREATEPALETTEDATA pcpd )
{
    DWORD	rc;

    /*
     * get 16:16 ptrs
     */
    pcpd->lpDD = pcpd->lpDD->lp16DD;

    /*
     * make the CreatePalette call in the driver
     */
    rc = DDThunk16_CreatePalette( pcpd );

    /*
     * clean up any 16:16 ptrs
     */
    return rc;

} /* _DDHAL_CreatePalette */

/*
 * _DDHAL_CreateSurface
 */
DWORD DDAPI _DDHAL_CreateSurface( LPDDHAL_CREATESURFACEDATA pcsd )
{
    DWORD			rc;
    int				i;
    LPVOID			FAR *ppslist;
    LPVOID			FAR *psave;
    LPDDRAWI_DDRAWSURFACE_LCL	FAR *slistx;
    DWORD			lplp16slist;

    /*
     * alias pointers to surfaces in new array...
     */
    pcsd->lpDDSurfaceDesc = (LPVOID) MapLS( pcsd->lpDDSurfaceDesc );
    if( pcsd->lpDDSurfaceDesc == NULL )
    {
	pcsd->ddRVal = DDERR_OUTOFMEMORY;
	return DDHAL_DRIVER_HANDLED;
    }
    ppslist = MemAlloc( pcsd->dwSCnt * sizeof( DWORD ) );
    if( ppslist == NULL )
    {
	UnMapLS( (DWORD) pcsd->lpDDSurfaceDesc );
	pcsd->ddRVal = DDERR_OUTOFMEMORY;
	return DDHAL_DRIVER_HANDLED;
    }
    psave = MemAlloc( pcsd->dwSCnt * sizeof( DWORD ) );
    if( psave == NULL )
    {
	MemFree( ppslist );
	UnMapLS( (DWORD) pcsd->lpDDSurfaceDesc );
	pcsd->ddRVal = DDERR_OUTOFMEMORY;
	return DDHAL_DRIVER_HANDLED;
    }
    lplp16slist = MapLS( ppslist );
    if( lplp16slist == 0 )
    {
	MemFree( ppslist );
	MemFree( psave );
	UnMapLS( (DWORD) pcsd->lpDDSurfaceDesc );
	pcsd->ddRVal = DDERR_OUTOFMEMORY;
	return DDHAL_DRIVER_HANDLED;
    }

    slistx = pcsd->lplpSList;
    for( i=0;i<(int)pcsd->dwSCnt;i++ )
    {
	ppslist[i] = GETSURFALIAS( slistx[i] );
	GETDATAALIAS( slistx[i], psave[i] );
    }

    /*
     * fix up structure with aliased ptrs
     */
    pcsd->lplpSList = (LPDDRAWI_DDRAWSURFACE_LCL FAR *)lplp16slist;
    pcsd->lpDD = (LPDDRAWI_DIRECTDRAW_GBL) pcsd->lpDD->lp16DD;

    /*
     * make the CreateSurface call in the driver
     */
    rc = DDThunk16_CreateSurface( pcsd );

    /*
     * clean up any 16:16 ptrs
     */
    UnMapLS( lplp16slist );
    UnMapLS( (DWORD) pcsd->lpDDSurfaceDesc );
    for( i=0;i<(int)pcsd->dwSCnt;i++ )
    {
	RESTOREDATAALIAS( slistx[i], psave[i] );
    }
    MemFree( psave );
    MemFree( ppslist );

    return rc;

} /* _DDHAL_CreateSurface */

/*
 * _DDHAL_CanCreateSurface
 */
DWORD DDAPI _DDHAL_CanCreateSurface( LPDDHAL_CANCREATESURFACEDATA pccsd )
{
    DWORD		rc;

    pccsd->lpDD = (LPDDRAWI_DIRECTDRAW_GBL) pccsd->lpDD->lp16DD;
    pccsd->lpDDSurfaceDesc = (LPVOID) MapLS( pccsd->lpDDSurfaceDesc );
    if( pccsd->lpDDSurfaceDesc == NULL )
    {
	pccsd->ddRVal = DDERR_OUTOFMEMORY;
	return DDHAL_DRIVER_HANDLED;
    }

    /*
     * make the CanCreateSurface call in the driver
     */
    rc = DDThunk16_CanCreateSurface( pccsd );
    UnMapLS( (DWORD) pccsd->lpDDSurfaceDesc );

    return rc;

} /* _DDHAL_CanCreateSurface */

/*
 * _DDHAL_WaitForVerticalBlank
 */
DWORD DDAPI _DDHAL_WaitForVerticalBlank( LPDDHAL_WAITFORVERTICALBLANKDATA pwfvbd )
{
    DWORD			rc;

    pwfvbd->lpDD = (LPDDRAWI_DIRECTDRAW_GBL) pwfvbd->lpDD->lp16DD;

    /*
     * make the WaitForVerticalBlank call in the driver
     */
    rc = DDThunk16_WaitForVerticalBlank( pwfvbd );

    return rc;

} /* _DDHAL_WaitForVerticalBlank */

/*
 * _DDHAL_DestroyDriver
 */
DWORD DDAPI _DDHAL_DestroyDriver( LPDDHAL_DESTROYDRIVERDATA pddd )
{
    DWORD	rc;

    pddd->lpDD = (LPDDRAWI_DIRECTDRAW_GBL) pddd->lpDD->lp16DD;

    /*
     * make the DestroyDriver call in the driver
     */
    rc = DDThunk16_DestroyDriver( pddd );
    return rc;

} /* _DDHAL_DestroyDriver */

/*
 * _DDHAL_SetMode
 */
DWORD DDAPI _DDHAL_SetMode( LPDDHAL_SETMODEDATA psmd )
{
    DWORD		rc;

    psmd->lpDD = (LPDDRAWI_DIRECTDRAW_GBL) psmd->lpDD->lp16DD;

    /*
     * make the SetMode call in the driver
     */
    rc = DDThunk16_SetMode( psmd );

    return rc;

} /* _DDHAL_SetMode */

/*
 * _DDHAL_GetScanLine
 */
DWORD DDAPI _DDHAL_GetScanLine( LPDDHAL_GETSCANLINEDATA pgsld )
{
    DWORD	rc;

    pgsld->lpDD = (LPDDRAWI_DIRECTDRAW_GBL) pgsld->lpDD->lp16DD;

    /*
     * make the GetScanLine call in the driver
     */
    rc = DDThunk16_GetScanLine( pgsld );
    return rc;

} /* _DDHAL_GetScanLine */

/*
 * _DDHAL_SetExclusiveMode
 */
DWORD DDAPI _DDHAL_SetExclusiveMode( LPDDHAL_SETEXCLUSIVEMODEDATA psemd )
{
    DWORD       rc;

    psemd->lpDD = (LPDDRAWI_DIRECTDRAW_GBL) psemd->lpDD->lp16DD;

    /*
     * make the SetExclusiveMode call in the driver
     */
    rc = DDThunk16_SetExclusiveMode( psemd );
    return rc;

} /* _DDHAL_SetExclusiveMode */

/*
 * _DDHAL_FlipToGDISurface
 */
DWORD DDAPI _DDHAL_FlipToGDISurface( LPDDHAL_FLIPTOGDISURFACEDATA pftgsd )
{
    DWORD       rc;

    pftgsd->lpDD = (LPDDRAWI_DIRECTDRAW_GBL) pftgsd->lpDD->lp16DD;

    /*
     * make the SetExclusiveMode call in the driver
     */
    rc = DDThunk16_FlipToGDISurface( pftgsd );
    return rc;

} /* _DDHAL_FlipToGDISurface */

/*
 * _DDHAL_GetAvailDriverMemory
 */
DWORD DDAPI _DDHAL_GetAvailDriverMemory( LPDDHAL_GETAVAILDRIVERMEMORYDATA pgadmd )
{
    DWORD rc;
    pgadmd->lpDD = (LPDDRAWI_DIRECTDRAW_GBL) pgadmd->lpDD->lp16DD;
    rc = DDThunk16_GetAvailDriverMemory( pgadmd );
    return rc;
}

/*
 * _DDHAL_UpdateNonLocalHeap
 */
DWORD DDAPI _DDHAL_UpdateNonLocalHeap( LPDDHAL_UPDATENONLOCALHEAPDATA unlhd )
{
    DWORD rc;
    unlhd->lpDD = (LPDDRAWI_DIRECTDRAW_GBL) unlhd->lpDD->lp16DD;
    rc = DDThunk16_UpdateNonLocalHeap( unlhd );
    return rc;
}

/*
 * unmapSurfaceDescArray
 *
 * free an array of 16:16 ptrs
 */
static void unmapSurfaceDescArray( DWORD cnt, DWORD FAR *lp16sdlist )
{
    int	i;

    if( cnt == 0 )
    {
	return;
    }

    for( i=0;i<(int)cnt;i++ )
    {
	UnMapLS( lp16sdlist[i] );
    }
    MemFree( lp16sdlist );

} /* unmapSurfaceDescArray */

/*
 * mapSurfaceDescArray
 *
 * make 16:16 pointers for an array of surface descriptions
 */
static DWORD FAR *mapSurfaceDescArray( DWORD cnt, LPDDSURFACEDESC FAR *sdlist )
{
    DWORD	FAR *lp16sdlist;
    int		i;

    if( cnt == 0 || sdlist == NULL )
    {
	return NULL;
    }

    lp16sdlist = MemAlloc( cnt * sizeof( DWORD ) );
    if( lp16sdlist == NULL )
    {
	return NULL;
    }
    for( i=0;i<(int)cnt;i++ )
    {
	lp16sdlist[i] = MapLS( sdlist[i] );
	if( lp16sdlist[i] == 0 )
	{
	    unmapSurfaceDescArray( i, lp16sdlist );
	    return NULL;
	}
    }
    return lp16sdlist;

} /* mapSurfaceDescArray */

/****************************************************************************
 *
 * SURFACE CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * _DDHAL_DestroySurface
 */
DWORD DDAPI _DDHAL_DestroySurface( LPDDHAL_DESTROYSURFACEDATA pdsd )
{
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    DWORD			rc;
    LPVOID			save;

    pdsd->lpDD = pdsd->lpDD->lp16DD;
    psurf_lcl = pdsd->lpDDSurface;
    pdsd->lpDDSurface = GETSURFALIAS( psurf_lcl );

    GETDATAALIAS( psurf_lcl, save );

    rc = DDThunk16_DestroySurface( pdsd );

    RESTOREDATAALIAS( psurf_lcl, save );
    return rc;

} /* _DDHAL_DestroySurface */

/*
 * _DDHAL_Flip
 */
DWORD DDAPI _DDHAL_Flip( LPDDHAL_FLIPDATA pfd )
{
    LPDDRAWI_DIRECTDRAW_GBL     lp32DD;
    LPDDRAWI_DDRAWSURFACE_LCL	psurfcurrx;
    LPDDRAWI_DDRAWSURFACE_LCL	psurftargx;
    DWORD			rc;
    LPVOID			save1;
    LPVOID                      save2;

    /*
     * get 16:16 ptrs to original and target surface
     */
    lp32DD = pfd->lpDD;
    pfd->lpDD = pfd->lpDD->lp16DD;
    psurfcurrx = pfd->lpSurfCurr;
    pfd->lpSurfCurr = GETSURFALIAS( psurfcurrx );
    GETDATAALIAS( psurfcurrx, save1 );
    if( pfd->lpSurfTarg != NULL )
    {
	psurftargx = pfd->lpSurfTarg;
	pfd->lpSurfTarg = GETSURFALIAS( psurftargx );
	GETDATAALIAS( psurftargx, save2 );
    }
    else
    {
	psurftargx = NULL;
    }

    /*
     * make the Flip call in the driver
     */
    rc = DDThunk16_Flip( pfd );

    /*
     * restore original ptrs
     */
    RESTOREDATAALIAS( psurfcurrx, save1 );
    if( psurftargx != NULL )
    {
	RESTOREDATAALIAS( psurftargx, save2 );
    }

    pfd->lpDD = lp32DD;
    pfd->lpSurfCurr = psurfcurrx;
    pfd->lpSurfTarg = psurftargx;

    return rc;

} /* _DDHAL_Flip */

/*
 * _DDHAL_Blt
 */
DWORD DDAPI _DDHAL_Blt( LPDDHAL_BLTDATA pbd )
{
    DWORD			flags;
    DWORD			rc;
    LPDDRAWI_DIRECTDRAW_GBL     lp32DD;
    LPDDRAWI_DDRAWSURFACE_LCL	psurfsrcx;
    LPDDRAWI_DDRAWSURFACE_LCL	psurfdestx;
    LPDDRAWI_DDRAWSURFACE_LCL	ppatternsurf_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL	pzsrcsurf_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL	pzdestsurf_lcl;
    #ifdef USE_ALPHA
	LPDDRAWI_DDRAWSURFACE_LCL pasrcsurf_lcl;
	LPDDRAWI_DDRAWSURFACE_LCL padestsurf_lcl;
	LPVOID			saveasrc;
	LPVOID			saveadest;
    #endif
    LPVOID			savesrc;
    LPVOID			savedest;
    LPVOID			savepattern;
    LPVOID			savezsrc;
    LPVOID			savezdest;

    /*
     * get 16:16 ptrs to source and destination surfaces
     */
    lp32DD = pbd->lpDD;
    pbd->lpDD = pbd->lpDD->lp16DD;
    psurfsrcx = pbd->lpDDSrcSurface;
    if( psurfsrcx != NULL )
    {
	pbd->lpDDSrcSurface = GETSURFALIAS( psurfsrcx );
	GETDATAALIAS( psurfsrcx, savesrc );
    }
    psurfdestx = pbd->lpDDDestSurface;
    pbd->lpDDDestSurface = GETSURFALIAS( psurfdestx );
    GETDATAALIAS( psurfdestx, savedest );

    /*
     * see if we need to do any other surface aliases
     */
    flags = pbd->dwFlags;
    if( flags & (DDBLT_ALPHASRCSURFACEOVERRIDE|
    		 DDBLT_ALPHADESTSURFACEOVERRIDE|
		 DDBLT_PRIVATE_ALIASPATTERN |
		 DDBLT_ZBUFFERDESTOVERRIDE |
		 DDBLT_ZBUFFERSRCOVERRIDE ) )
    {

   	#ifdef USE_ALPHA
	    /*
	     * set up 16:16 ptr for alpha src
	     */
	    if( flags & DDBLT_ALPHASRCSURFACEOVERRIDE )
	    {
		pasrcsurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) pbd->bltFX.lpDDSAlphaSrc;
		pbd->bltFX.lpDDSAlphaSrc = GETSURFALIAS( pasrcsurf_lcl );
		GETDATAALIAS( pasrcsurf_lcl, saveasrc );
	    }

	    /*
	     * set up 16:16 ptr for alpha dest
	     */
	    if( flags & DDBLT_ALPHADESTSURFACEOVERRIDE )
	    {
		padestsurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) pbd->bltFX.lpDDSAlphaDest;
		pbd->bltFX.lpDDSAlphaDest = GETSURFALIAS( padestsurf_lcl );
		GETDATAALIAS( padestsurf_lcl, saveadest );
	    }
	#endif

	/*
	 * set up 16:16 ptr for pattern
	 */
	if( flags & DDBLT_PRIVATE_ALIASPATTERN )
	{
	    ppatternsurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) pbd->bltFX.lpDDSPattern;
	    pbd->bltFX.lpDDSPattern = GETSURFALIAS( ppatternsurf_lcl );
	    GETDATAALIAS( ppatternsurf_lcl, savepattern );
	}

	/*
	 * set up 16:16 ptr for Z Buffer src
	 */
	if( flags & DDBLT_ZBUFFERSRCOVERRIDE )
	{
	    pzsrcsurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) pbd->bltFX.lpDDSZBufferSrc;
	    pbd->bltFX.lpDDSZBufferSrc = GETSURFALIAS( pzsrcsurf_lcl );
	    GETDATAALIAS( pzsrcsurf_lcl, savezsrc );
	}

	/*
	 * set up 16:16 ptr for Z Buffer dest
	 */
	if( flags & DDBLT_ZBUFFERDESTOVERRIDE )
	{
	    pzdestsurf_lcl = (LPDDRAWI_DDRAWSURFACE_LCL) pbd->bltFX.lpDDSZBufferDest;
	    pbd->bltFX.lpDDSZBufferDest = GETSURFALIAS( pzdestsurf_lcl );
	    GETDATAALIAS( pzdestsurf_lcl, savezdest );
	}
    }

    /*
     * make the Blt call in the driver
     */
    rc = DDThunk16_Blt( pbd );

    /*
     * see if we need to restore any surface ptrs
     */
    if( flags & (DDBLT_ALPHASRCSURFACEOVERRIDE|
    		 DDBLT_ALPHADESTSURFACEOVERRIDE|
		 DDBLT_PRIVATE_ALIASPATTERN |
		 DDBLT_ZBUFFERDESTOVERRIDE |
		 DDBLT_ZBUFFERSRCOVERRIDE ) )
    {
	#ifdef USE_ALPHA
	    if( flags & DDBLT_ALPHASRCSURFACEOVERRIDE )
	    {
		pbd->bltFX.lpDDSAlphaSrc = (LPDIRECTDRAWSURFACE) pasrcsurf_lcl;
		RESTOREDATAALIAS( pasrcsurf_lcl, saveasrc );
	    }
	    if( flags & DDBLT_ALPHADESTSURFACEOVERRIDE )
	    {
		pbd->bltFX.lpDDSAlphaDest = (LPDIRECTDRAWSURFACE) padestsurf_lcl;
		RESTOREDATAALIAS( padestsurf_lcl, saveadest );
	    }
	#endif
	if( flags & DDBLT_PRIVATE_ALIASPATTERN )
	{
	    pbd->bltFX.lpDDSPattern = (LPDIRECTDRAWSURFACE) ppatternsurf_lcl;
	    RESTOREDATAALIAS( ppatternsurf_lcl, savepattern );
	}
	if( flags & DDBLT_ZBUFFERSRCOVERRIDE )
	{
	    pbd->bltFX.lpDDSZBufferSrc = (LPDIRECTDRAWSURFACE) pzsrcsurf_lcl;
	    RESTOREDATAALIAS( pzsrcsurf_lcl, savezsrc );
	}
	if( flags & DDBLT_ZBUFFERDESTOVERRIDE )
	{
	    pbd->bltFX.lpDDSZBufferDest = (LPDIRECTDRAWSURFACE) pzdestsurf_lcl;
	    RESTOREDATAALIAS( pzdestsurf_lcl, savezdest );
	}
    }

    if( psurfsrcx != NULL )
    {
	RESTOREDATAALIAS( psurfsrcx, savesrc );
    }
    RESTOREDATAALIAS( psurfdestx, savedest );

    pbd->lpDD = lp32DD;
    pbd->lpDDSrcSurface = psurfsrcx;
    pbd->lpDDDestSurface = psurfdestx;

    return rc;

} /* _DDHAL_Blt */

/*
 * _DDHAL_Lock
 */
DWORD DDAPI _DDHAL_Lock( LPDDHAL_LOCKDATA pld )
{
    LPDDRAWI_DIRECTDRAW_GBL     lp32DD;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    DWORD			rc;
    LPVOID			save;

    lp32DD = pld->lpDD;
    pld->lpDD = pld->lpDD->lp16DD;
    psurf_lcl = pld->lpDDSurface;
    pld->lpDDSurface = GETSURFALIAS( psurf_lcl );

    GETDATAALIAS( psurf_lcl, save );

    rc = DDThunk16_Lock( pld );

    RESTOREDATAALIAS( psurf_lcl, save );

    pld->lpDD = lp32DD;
    pld->lpDDSurface = psurf_lcl;

    return rc;

} /* _DDHAL_Lock */

/*
 * _DDHAL_Unlock
 */
DWORD DDAPI _DDHAL_Unlock( LPDDHAL_UNLOCKDATA puld )
{
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    DWORD			rc;
    LPVOID			save;

    puld->lpDD = puld->lpDD->lp16DD;
    psurf_lcl = puld->lpDDSurface;
    puld->lpDDSurface = GETSURFALIAS( psurf_lcl );

    GETDATAALIAS( psurf_lcl, save );

    rc = DDThunk16_Unlock( puld );

    RESTOREDATAALIAS( psurf_lcl, save );

    return rc;

} /* _DDHAL_UnLock */

/*
 * _DDHAL_AddAttachedSurface
 */
DWORD DDAPI _DDHAL_AddAttachedSurface( LPDDHAL_ADDATTACHEDSURFACEDATA paasd )
{
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    LPDDRAWI_DDRAWSURFACE_LCL	psurfattachedx;
    DWORD			rc;
    LPVOID			save;
    LPVOID			saveattached;

    /*
     * get 16:16 ptrs to surface and surface to become attached
     */
    paasd->lpDD = paasd->lpDD->lp16DD;
    psurf_lcl = paasd->lpDDSurface;
    paasd->lpDDSurface = GETSURFALIAS( psurf_lcl );
    GETDATAALIAS( psurf_lcl, save );

    psurfattachedx = paasd->lpSurfAttached;
    paasd->lpSurfAttached = GETSURFALIAS( psurfattachedx );
    GETDATAALIAS( psurfattachedx, saveattached );

    /*
     * make the AddAttachedSurface call in the driver
     */
    rc = DDThunk16_AddAttachedSurface( paasd );

    /*
     * restore any ptrs
     */
    RESTOREDATAALIAS( psurf_lcl, save );
    RESTOREDATAALIAS( psurfattachedx, saveattached );

    return rc;

} /* _DDHAL_AddAttachedSurface */

/*
 * _DDHAL_SetColorKey
 */
DWORD DDAPI _DDHAL_SetColorKey( LPDDHAL_SETCOLORKEYDATA psckd )
{
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    DWORD			rc;
    LPVOID			save;

    psckd->lpDD = psckd->lpDD->lp16DD;
    psurf_lcl = psckd->lpDDSurface;
    psckd->lpDDSurface = GETSURFALIAS( psurf_lcl );

    GETDATAALIAS( psurf_lcl, save );

    rc = DDThunk16_SetColorKey( psckd );

    RESTOREDATAALIAS( psurf_lcl, save );

    return rc;

} /* _DDHAL_SetColorKey */

/*
 * _DDHAL_SetClipList
 */
DWORD DDAPI _DDHAL_SetClipList( LPDDHAL_SETCLIPLISTDATA pscld )
{
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    DWORD			rc;
    LPVOID			save;

    pscld->lpDD = pscld->lpDD->lp16DD;
    psurf_lcl = pscld->lpDDSurface;
    pscld->lpDDSurface = GETSURFALIAS( psurf_lcl );

    GETDATAALIAS( psurf_lcl, save );

    rc = DDThunk16_SetClipList( pscld );

    RESTOREDATAALIAS( psurf_lcl, save );

    return rc;

} /* _DDHAL_SetClipList */

/*
 * _DDHAL_UpdateOverlay
 */
DWORD DDAPI _DDHAL_UpdateOverlay( LPDDHAL_UPDATEOVERLAYDATA puod )
{
    DWORD			rc;
    LPDDRAWI_DDRAWSURFACE_LCL	psurfdestx;
    LPDDRAWI_DDRAWSURFACE_LCL	psurfsrcx;
    #ifdef USE_ALPHA
	LPDDRAWI_DDRAWSURFACE_LCL psurfalphadestx;
	LPDDRAWI_DDRAWSURFACE_LCL psurfalphasrcx;
	LPVOID			savealphadest;
	LPVOID			savealphasrc;
    #endif
    LPVOID			savedest;
    LPVOID			savesrc;

    /*
     * get 16:16 ptrs to the dest surface and the overlay surface
     */
    puod->lpDD = puod->lpDD->lp16DD;
    psurfsrcx = puod->lpDDSrcSurface;
    puod->lpDDSrcSurface = GETSURFALIAS( psurfsrcx );
    psurfdestx = puod->lpDDDestSurface;
    puod->lpDDDestSurface = GETSURFALIAS( psurfdestx );
    GETDATAALIAS( psurfsrcx, savesrc );
    GETDATAALIAS( psurfdestx, savedest );

    #ifdef USE_ALPHA
	/*
	 * set up 16:16 ptr for alpha
	 */
	if( puod->dwFlags & DDOVER_ALPHASRCSURFACEOVERRIDE )
	{
	    psurfalphasrcx = (LPDDRAWI_DDRAWSURFACE_LCL) puod->overlayFX.lpDDSAlphaSrc;
	    puod->overlayFX.lpDDSAlphaSrc = GETSURFALIAS( psurfalphasrcx );
	    GETDATAALIAS( psurfalphasrcx, savealphasrc );
	}

	if( puod->dwFlags & DDOVER_ALPHADESTSURFACEOVERRIDE )
	{
	    psurfalphadestx = (LPDDRAWI_DDRAWSURFACE_LCL) puod->overlayFX.lpDDSAlphaDest;
	    puod->overlayFX.lpDDSAlphaDest = GETSURFALIAS( psurfalphadestx );
	    GETDATAALIAS( psurfalphadestx, savealphadest );
	}
    #endif

    /*
     * make the UpdateOverlay call in the driver
     */
    rc = DDThunk16_UpdateOverlay( puod );

    /*
     * restore any surfaces
     */
    #ifdef USE_ALPHA
	if( puod->dwFlags & DDOVER_ALPHASRCSURFACEOVERRIDE )
	{
	    puod->overlayFX.lpDDSAlphaSrc = (LPDIRECTDRAWSURFACE) psurfalphasrcx;
	    RESTOREDATAALIAS( psurfalphasrcx, savealphasrc );
	}
	if( puod->dwFlags & DDOVER_ALPHADESTSURFACEOVERRIDE )
	{
	    puod->overlayFX.lpDDSAlphaDest = (LPDIRECTDRAWSURFACE) psurfalphadestx;
	    RESTOREDATAALIAS( psurfalphadestx, savealphadest );
	}
    #endif
    RESTOREDATAALIAS( psurfsrcx, savesrc );
    RESTOREDATAALIAS( psurfdestx, savedest );
    return rc;

} /* _DDHAL_UpdateOverlay */

/*
 * _DDHAL_SetOverlayPosition
 */
DWORD DDAPI _DDHAL_SetOverlayPosition( LPDDHAL_SETOVERLAYPOSITIONDATA psopd )
{
    LPDDRAWI_DDRAWSURFACE_LCL	psurfdestx;
    LPDDRAWI_DDRAWSURFACE_LCL	psurfsrcx;
    DWORD			rc;
    LPVOID			savedest;
    LPVOID			savesrc;

    /*
     * get 16:16 ptrs to the dest surface and the overlay surface
     */
    psopd->lpDD = psopd->lpDD->lp16DD;
    psurfsrcx = psopd->lpDDSrcSurface;
    psopd->lpDDSrcSurface = GETSURFALIAS( psurfsrcx );
    psurfdestx = psopd->lpDDDestSurface;
    psopd->lpDDDestSurface = GETSURFALIAS( psurfdestx );
    GETDATAALIAS( psurfsrcx, savesrc );
    GETDATAALIAS( psurfdestx, savedest );

    /*
     * make the SetOverlayPosition call in the driver
     */
    rc = DDThunk16_SetOverlayPosition( psopd );

    /*
     * restore any surfaces
     */
    RESTOREDATAALIAS( psurfsrcx, savesrc );
    RESTOREDATAALIAS( psurfdestx, savedest );
    return rc;

} /* _DDHAL_SetOverlayPosition */

/*
 * _DDHAL_SetPalette
 */
DWORD DDAPI _DDHAL_SetPalette( LPDDHAL_SETPALETTEDATA pspd )
{
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    DWORD			rc;
    LPVOID			save;

    /*
     * get 16:16 ptrs
     */
    pspd->lpDD = pspd->lpDD->lp16DD;
    psurf_lcl = pspd->lpDDSurface;
    pspd->lpDDSurface = GETSURFALIAS( psurf_lcl );
    pspd->lpDDPalette = (LPDDRAWI_DDRAWPALETTE_GBL) MapLS( pspd->lpDDPalette );
    if( pspd->lpDDPalette == NULL )
    {
	pspd->ddRVal = DDERR_OUTOFMEMORY;
	return DDHAL_DRIVER_HANDLED;
    }
    GETDATAALIAS( psurf_lcl, save );

    /*
     * make the SetPalette call in the driver
     */
    rc = DDThunk16_SetPalette( pspd );

    /*
     * clean up any 16:16 ptrs
     */
    UnMapLS( (DWORD) pspd->lpDDPalette );
    RESTOREDATAALIAS( psurf_lcl, save );
    return rc;

} /* _DDHAL_SetPalette */

/*
 * _DDHAL_GetBltStatus
 */
DWORD DDAPI _DDHAL_GetBltStatus( LPDDHAL_GETBLTSTATUSDATA pgbsd )
{
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    DWORD			rc;
    LPVOID			save;

    pgbsd->lpDD = pgbsd->lpDD->lp16DD;
    psurf_lcl = pgbsd->lpDDSurface;
    pgbsd->lpDDSurface = GETSURFALIAS( psurf_lcl );

    GETDATAALIAS( psurf_lcl, save );

    rc = DDThunk16_GetBltStatus( pgbsd );

    RESTOREDATAALIAS( psurf_lcl, save );
    return rc;

} /* _DDHAL_GetBltStatus */

/*
 * _DDHAL_GetFlipStatus
 */
DWORD DDAPI _DDHAL_GetFlipStatus( LPDDHAL_GETFLIPSTATUSDATA pgfsd )
{
    LPDDRAWI_DDRAWSURFACE_LCL	psurf_lcl;
    DWORD			rc;
    LPVOID			save;

    pgfsd->lpDD = pgfsd->lpDD->lp16DD;
    psurf_lcl = pgfsd->lpDDSurface;
    pgfsd->lpDDSurface = GETSURFALIAS( psurf_lcl );

    GETDATAALIAS( psurf_lcl, save );

    rc = DDThunk16_GetFlipStatus( pgfsd );

    RESTOREDATAALIAS( psurf_lcl, save );

    return rc;

} /* _DDHAL_GetFlipStatus */

/****************************************************************************
 *
 * EXECUTE BUFFER CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * _DDHAL_CanCreateExecuteBuffer
 *
 * NOTE: Dummy entry point just to keep DOHALCALL happy. Execute buffer
 * entry points must be 32-bit, no thunking support is provided.
 */
DWORD DDAPI _DDHAL_CanCreateExecuteBuffer( LPDDHAL_CANCREATESURFACEDATA pccsd )
{
    pccsd->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_CanCreateExecuteBuffer */

/*
 * _DDHAL_CreateExecuteBuffer
 *
 * NOTE: Dummy entry point just to keep DOHALCALL happy. Execute buffer
 * entry points must be 32-bit, no thunking support is provided.
 */
DWORD DDAPI _DDHAL_CreateExecuteBuffer( LPDDHAL_CREATESURFACEDATA pcsd )
{
    pcsd->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_CreateExecuteBuffer */

/*
 * NOTE: All these babies are dummy entry points. They are only here to keep
 * DOHALCALL happy. Execute buffer HAL functions must be true 32-bit code.
 * No thunking support is offered.
 */

/*
 * _DDHAL_DestroyExecuteBuffer
 */
DWORD DDAPI _DDHAL_DestroyExecuteBuffer( LPDDHAL_DESTROYSURFACEDATA pdsd )
{
    pdsd->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_DestroySurface */

/*
 * _DDHAL_LockExecuteBuffer
 */
DWORD DDAPI _DDHAL_LockExecuteBuffer( LPDDHAL_LOCKDATA pld )
{
    pld->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_Lock */

/*
 * _DDHAL_UnlockExecuteBuffer
 */
DWORD DDAPI _DDHAL_UnlockExecuteBuffer( LPDDHAL_UNLOCKDATA puld )
{
    puld->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_UnlockExecuteBuffer */

/****************************************************************************
 *
 * VIDEO PORT CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * _DDHAL_GetVideoPortConnectionGUID
 *
 * NOTE: Dummy entry point just to keep DOHALCALL happy. Video Port
 * entry points must be 32-bit, no thunking support is provided.
 */
DWORD DDAPI _DDHAL_GetVideoPortConnectInfo( LPDDHAL_GETVPORTCONNECTDATA lpGetTypeData )
{
    lpGetTypeData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetVideoPortTypeGUID */

/*
 * _DDHAL_CanCreateVideoPort
 */
DWORD DDAPI _DDHAL_CanCreateVideoPort( LPDDHAL_CANCREATEVPORTDATA lpCanCreateData )
{
    lpCanCreateData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_CanCreateVideoPort */

/*
 * _DDHAL_CreateVideoPort
 */
DWORD DDAPI _DDHAL_CreateVideoPort( LPDDHAL_CREATEVPORTDATA lpCreateData )
{
    lpCreateData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_CreateVideoPort */

/*
 * _DDHAL_DestroyVideoPort
 */
DWORD DDAPI _DDHAL_DestroyVideoPort( LPDDHAL_DESTROYVPORTDATA lpDestroyData )
{
    lpDestroyData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_DestroyVideoPort */

/*
 * _DDHAL_GetVideoPortInputFormats
 */
DWORD DDAPI _DDHAL_GetVideoPortInputFormats( LPDDHAL_GETVPORTINPUTFORMATDATA lpGetFormatData )
{
    lpGetFormatData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetVideoPortInputFormats */

/*
 * _DDHAL_GetVideoPortOutputFormats
 */
DWORD DDAPI _DDHAL_GetVideoPortOutputFormats( LPDDHAL_GETVPORTOUTPUTFORMATDATA lpGetFormatData )
{
    lpGetFormatData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetVideoPortOutputFormats */

/*
 * _DDHAL_GetVideoPortBandwidthInfo
 */
DWORD DDAPI _DDHAL_GetVideoPortBandwidthInfo( LPDDHAL_GETVPORTBANDWIDTHDATA lpGetBandwidthData )
{
    lpGetBandwidthData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetVideoPortBandwidthInfo */

/*
 * _DDHAL_UpdateVideoPort
 */
DWORD DDAPI _DDHAL_UpdateVideoPort( LPDDHAL_UPDATEVPORTDATA lpUpdateData )
{
    lpUpdateData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_UpdateVideoPort */

/*
 * _DDHAL_GetVideoPortField
 */
DWORD DDAPI _DDHAL_GetVideoPortField( LPDDHAL_GETVPORTFIELDDATA lpGetFieldData )
{
    lpGetFieldData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetVideoPortField */

/*
 * _DDHAL_GetVideoPortLine
 */
DWORD DDAPI _DDHAL_GetVideoPortLine( LPDDHAL_GETVPORTLINEDATA lpGetLineData )
{
    lpGetLineData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetVideoPortLine */

/*
 * _DDHAL_WaitForVideoPortSync
 */
DWORD DDAPI _DDHAL_WaitForVideoPortSync( LPDDHAL_WAITFORVPORTSYNCDATA lpWaitSyncData )
{
    lpWaitSyncData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_WaitForVideoPortSync */

/*
 * _DDHAL_FlipVideoPort
 */
DWORD DDAPI _DDHAL_FlipVideoPort( LPDDHAL_FLIPVPORTDATA lpFlipData )
{
    lpFlipData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_FlipVideoPort */

/*
 * _DDHAL_GetVideoPortFlipStatus
 */
DWORD DDAPI _DDHAL_GetVideoPortFlipStatus( LPDDHAL_GETVPORTFLIPSTATUSDATA lpFlipData )
{
    lpFlipData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetVideoPortFlipStatus */

/*
 * _DDHAL_GetVideoSignalStatus
 */
DWORD DDAPI _DDHAL_GetVideoSignalStatus( LPDDHAL_GETVPORTSIGNALDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetVideoSignalStatus */

/*
 * _DDHAL_VideoColorControl
 */
DWORD DDAPI _DDHAL_VideoColorControl( LPDDHAL_VPORTCOLORDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_VideoColorControl */

/****************************************************************************
 *
 * COLORCONTROL CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * _DDHAL_ColorControl
 */
DWORD DDAPI _DDHAL_ColorControl( LPDDHAL_COLORCONTROLDATA pccd )
{
    LPDDRAWI_DIRECTDRAW_GBL     lp32DD;
    LPDDRAWI_DDRAWSURFACE_LCL	psurf;
    LPVOID			save1;
    DWORD			rc;

    /*
     * get 16:16 ptr to surface
     */
    lp32DD = pccd->lpDD;
    pccd->lpDD = pccd->lpDD->lp16DD;
    psurf = pccd->lpDDSurface;
    pccd->lpDDSurface = GETSURFALIAS( psurf );
    GETDATAALIAS( psurf, save1 );

    /*
     * make the ColorControl call in the driver
     */
    rc = DDThunk16_ColorControl( pccd );

    /*
     * restore original ptrs
     */
    RESTOREDATAALIAS( psurf, save1 );

    pccd->lpDD = lp32DD;
    pccd->lpDDSurface = psurf;

    return rc;

} /* _DDHAL_ColorControl */

/****************************************************************************
 *
 * KERNEL CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * _DDHAL_SyncSurfaceData
 */
DWORD DDAPI _DDHAL_SyncSurfaceData( LPDDHAL_SYNCSURFACEDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_SyncSurfaceData */

/*
 * _DDHAL_SyncVideoPortData
 */
DWORD DDAPI _DDHAL_SyncVideoPortData( LPDDHAL_SYNCVIDEOPORTDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_SyncVideoPortData */

/****************************************************************************
 *
 * MOTION COMP CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * _DDHAL_GetMoCompGuids
 */
DWORD DDAPI _DDHAL_GetMoCompGuids( LPDDHAL_GETMOCOMPGUIDSDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetVideoGuids */

/*
 * _DDHAL_GetMoCompFormats
 */
DWORD DDAPI _DDHAL_GetMoCompFormats( LPDDHAL_GETMOCOMPFORMATSDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetMoCompFormats */

/*
 * _DDHAL_CreateMoComp
 */
DWORD DDAPI _DDHAL_CreateMoComp( LPDDHAL_CREATEMOCOMPDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_CreateMoComp */

/*
 * _DDHAL_GetMoCompBuffInfo
 */
DWORD DDAPI _DDHAL_GetMoCompBuffInfo( LPDDHAL_GETMOCOMPCOMPBUFFDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetMoCompBuffInfo */

/*
 * _DDHAL_GetInternalMoCompInfo
 */
DWORD DDAPI _DDHAL_GetInternalMoCompInfo( LPDDHAL_GETINTERNALMOCOMPDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_GetInternalMoCompInfo */

/*
 * _DDHAL_DestroyMoComp
 */
DWORD DDAPI _DDHAL_DestroyMoComp( LPDDHAL_DESTROYMOCOMPDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_DestroyMoComp */

/*
 * _DDHAL_BeginMoCompFrame
 */
DWORD DDAPI _DDHAL_BeginMoCompFrame( LPDDHAL_BEGINMOCOMPFRAMEDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_BeginMoCompFrame */

/*
 * _DDHAL_EndMoCompFrame
 */
DWORD DDAPI _DDHAL_EndMoCompFrame( LPDDHAL_ENDMOCOMPFRAMEDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_EndMoCompFrame */

/*
 * _DDHAL_RenderMoComp
 */
DWORD DDAPI _DDHAL_RenderMoComp( LPDDHAL_RENDERMOCOMPDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_RenderMoComp */

/*
 * _DDHAL_QueryMoCompStatus
 */
DWORD DDAPI _DDHAL_QueryMoCompStatus( LPDDHAL_QUERYMOCOMPSTATUSDATA lpData )
{
    lpData->ddRVal = DDERR_UNSUPPORTED;
    return DDHAL_DRIVER_NOTHANDLED;
} /* _DDHAL_QueryMoCompStatus */

/****************************************************************************
 *
 * PALETTE CALLBACK HELPER FNS
 *
 ***************************************************************************/

/*
 * _DDHAL_DestroyPalette
 */
DWORD DDAPI _DDHAL_DestroyPalette( LPDDHAL_DESTROYPALETTEDATA pdpd )
{
    DWORD	rc;

    /*
     * get 16:16 ptrs
     */
    pdpd->lpDD = pdpd->lpDD->lp16DD;
    pdpd->lpDDPalette = (LPDDRAWI_DDRAWPALETTE_GBL) MapLS( pdpd->lpDDPalette );
    if( pdpd->lpDDPalette == NULL )
    {
	pdpd->ddRVal = DDERR_OUTOFMEMORY;
	return DDHAL_DRIVER_HANDLED;
    }

    /*
     * make the DestroyPalette call in the driver
     */
    rc = DDThunk16_DestroyPalette( pdpd );

    /*
     * clean up any 16:16 ptrs
     */
    UnMapLS( (DWORD) pdpd->lpDDPalette );
    return rc;

} /* _DDHAL_DestroyPalette */

/*
 * _DDHAL_SetEntries
 */
DWORD DDAPI _DDHAL_SetEntries( LPDDHAL_SETENTRIESDATA psed )
{
    DWORD	rc;

    /*
     * get 16:16 ptrs
     */
    psed->lpDD = psed->lpDD->lp16DD;
    psed->lpDDPalette = (LPDDRAWI_DDRAWPALETTE_GBL) MapLS( psed->lpDDPalette );
    if( psed->lpDDPalette == NULL )
    {
	psed->ddRVal = DDERR_OUTOFMEMORY;
	return DDHAL_DRIVER_HANDLED;
    }

    /*
     * make the DestroyPalette call in the driver
     */
    rc = DDThunk16_SetEntries( psed );

    /*
     * clean up any 16:16 ptrs
     */
    UnMapLS( (DWORD) psed->lpDDPalette );
    return rc;

} /* _DDHAL_SetEntries */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\win9x\i386\16to32.inc ===
APILOGSL  macro   argName
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\win9x\makefile.inc ===
thunks:
  thunk -P2 -NC ddraw -t thk3216 32to16.thk -o $(O)\32to16.asm
  thunk -P2 -NC ddraw -t thk1632 16to32.thk -o $(O)\16to32.asm

headers:
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\inc\dwininfo.h ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	wndinfo.h
 *  Content:	Direct Draw window information structure
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   08-jul-95	craige	initial implementation
 *   18-jul-95	craige	keep track of dsound/ddraw hooks with flags
 *   13-aug-95  toddla  added WININFO_ACTIVELIE
 *   09-sep-95  toddla  added WININFO_INACTIVATEAPP
 *   17-may-96  colinmc Bug 23029: Removed WININFO_WASICONIC
 *
 ***************************************************************************/

#ifndef __WNDINFO_INCLUDED__
#define __WNDINFO_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _DDWINDOWINFO
{
    DWORD                       dwSmag;
    struct _DDWINDOWINFO	*lpLink;
    WNDPROC			lpDSoundCallback;
    HWND			hWnd;
    WNDPROC			lpWndProc;
    DWORD			dwPid;
    DWORD			dwFlags;
    struct
    {
	LPDDRAWI_DIRECTDRAW_LCL	lpDD_lcl;
	DWORD			dwDDFlags;
    } DDInfo;
} DDWINDOWINFO, *LPDDWINDOWINFO;

#define WININFO_MAGIC                   0x42954295l
#define WININFO_DDRAWHOOKED		0x00000001l
#define WININFO_DSOUNDHOOKED		0x00000002l
#define WININFO_ZOMBIE                  0x00000008l
#define WININFO_UNHOOK                  0x00000010l
#define WININFO_IGNORENEXTALTTAB	0x00000020l
#define WININFO_SELFSIZE                0x00000040l
#define WININFO_INACTIVATEAPP           0x00000080l

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\inc\ddreg.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1996-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddreg.h
 *  Content:	DirectDraw registry entries
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   16-aug-96	craige	initial implementation
 *   06-jan-97  colinmc Initial AGP work
 *   01-feb-97  colinmc Bug 5457: Fixed Win16 lock problem causing hang
 *                      with mutliple AMovie instances on old cards
 *
 ***************************************************************************/

#ifndef __DDRAWREG_INCLUDED__
#define __DDRAWREG_INCLUDED__

#define REGSTR_PATH_DDRAW 		   "Software\\Microsoft\\DirectDraw"

#define	REGSTR_VAL_DDRAW_MODEXONLY	   "ModeXOnly"
#define	REGSTR_VAL_DDRAW_EMULATIONONLY	   "EmulationOnly"
#define REGSTR_VAL_DDRAW_SHOWFRAMERATE	   "ShowFrameRate"
#define REGSTR_VAL_DDRAW_ENABLEPRINTSCRN   "EnablePrintScreen"
#define REGSTR_VAL_DDRAW_DISABLEWIDERSURFACES "DisableWiderSurfaces"
// this regkey is added purely for performance testing purposes to
// eliminate the refreshrate influence on framerate
#define REGSTR_VAL_D3D_FLIPNOVSYNC          "FlipNoVsync"
/*
 * This one is checked in DirectDrawMsg
 */
#define REGSTR_VAL_DDRAW_DISABLEDIALOGS    "DisableDialogs"
#define REGSTR_VAL_DDRAW_NODDSCAPSINDDSD   "DisableDDSCAPSInDDSD"

#define REGSTR_VAL_DDRAW_FORCEAGPSUPPORT   "ForceAGPSupport"
#define REGSTR_VAL_DDRAW_AGPPOLICYMAXPAGES "AGPPolicyMaxPages"
#define REGSTR_VAL_DDRAW_AGPPOLICYMAXBYTES "AGPPolicyMaxBytes"
#define REGSTR_VAL_DDRAW_AGPPOLICYCOMMITDELTA "AGPPolicyCommitDelta"
#define REGSTR_VAL_DDRAW_DISABLEAGPSUPPORT "DisableAGPSupport"

#define REGSTR_VAL_DDRAW_DISABLEMMX	   "DisableMMX"

#define REGSTR_VAL_DDRAW_FORCEREFRESHRATE  "ForceRefreshRate"

#define REGSTR_VAL_DDRAW_LOADDEBUGRUNTIME  "LoadDebugRuntime"

#ifdef WIN95
#define REGSTR_KEY_RECENTMONITORS          "MostRecentMonitors"
#define REGSTR_VAL_DDRAW_MONITORSORDER     "Order"
#endif

#ifdef DEBUG
    #define REGSTR_VAL_DDRAW_DISABLENOSYSLOCK  "DisableNoSysLock"
    #define REGSTR_VAL_DDRAW_FORCENOSYSLOCK    "ForceNoSysLock"
#endif /* DEBUG */
#define REGSTR_VAL_DDRAW_DISABLEINACTIVATE "DisableInactivate"

#define REGSTR_KEY_GAMMA_CALIBRATOR        "GammaCalibrator"
#define REGSTR_VAL_GAMMA_CALIBRATOR        "Path"

#define REGSTR_KEY_APPCOMPAT		   "Compatibility"

#define REGSTR_KEY_LASTAPP		   "MostRecentApplication"

#define REGSTR_VAL_DDRAW_NAME		   "Name"
#define REGSTR_VAL_DDRAW_APPID		   "ID"
#define REGSTR_VAL_DDRAW_FLAGS		   "Flags"

#define REGSTR_VAL_D3D_USENONLOCALVIDMEM   "UseNonLocalVidMem"

#define REGSTR_VAL_DDRAW_ENUMSECONDARY     "EnumerateAttachedSecondaries"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\inc\ddheap.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddheap.h
 *  Content:	Heap manager header file
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   03-Feb-98	DrewB   Split from ddrawpr.h for user/kernel portability.
 *
 ***************************************************************************/

#ifndef __DDHEAP_INCLUDED__
#define __DDHEAP_INCLUDED__

#include "dmemmgr.h"

#ifndef VIDMEMONLY

BOOL linVidMemInit( LPVMEMHEAP pvmh, FLATPTR start, FLATPTR end );
void linVidMemFini( LPVMEMHEAP pvmh );
void linVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );
FLATPTR linVidMemAlloc( LPVMEMHEAP pvmh, DWORD xsize, DWORD ysize,
                        LPDWORD lpdwSize, LPSURFACEALIGNMENT lpAlignment,
                        LPLONG lpNewPitch );
DWORD linVidMemAmountAllocated( LPVMEMHEAP pvmh );
DWORD linVidMemAmountFree( LPVMEMHEAP pvmh );
DWORD linVidMemLargestFree( LPVMEMHEAP pvmh );
    
BOOL rectVidMemInit( LPVMEMHEAP pvmh, FLATPTR start, DWORD width, DWORD height,
                     DWORD stride );
void rectVidMemFini( LPVMEMHEAP pvmh );
FLATPTR rectVidMemAlloc( LPVMEMHEAP pvmh, DWORD cxThis, DWORD cyThis,
                         LPDWORD lpdwSize, LPSURFACEALIGNMENT lpAlignment );
void rectVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );
DWORD rectVidMemAmountAllocated( LPVMEMHEAP pvmh );
DWORD rectVidMemAmountFree( LPVMEMHEAP pvmh );

BOOL IsDifferentPixelFormat( LPDDPIXELFORMAT pdpf1, LPDDPIXELFORMAT pdpf2 );

#define DDHA_SKIPRECTANGULARHEAPS       0x0001
#define DDHA_ALLOWNONLOCALMEMORY        0x0002
#define DDHA_ALLOWNONLOCALTEXTURES      0x0004
#define DDHA_USEALTCAPS                 0x0008

FLATPTR DdHeapAlloc( DWORD dwNumHeaps,
                     LPVIDMEM pvmHeaps,
                     HANDLE hdev,
                     LPVIDMEMINFO lpVidMemInfo,
                     DWORD dwWidth,
                     DWORD dwHeight,
                     LPDDRAWI_DDRAWSURFACE_LCL lpSurfaceLcl,
                     DWORD dwFlags,
                     LPVIDMEM *ppvmHeap,
                     LPLONG plNewPitch,
                     LPDWORD pdwNewCaps,
                     LPDWORD pdwSize);

LPVMEMHEAP WINAPI HeapVidMemInit( LPVIDMEM lpVidMem, DWORD pitch, HANDLE hdev,
                                  LPHEAPALIGNMENT phad);
void WINAPI HeapVidMemFini( LPVIDMEM lpVidMem, HANDLE hdev );
FLATPTR WINAPI HeapVidMemAlloc( LPVIDMEM lpVidMem, DWORD x, DWORD y,
                                HANDLE hdev, LPSURFACEALIGNMENT lpAlignment,
                                LPLONG lpNewPitch, LPDWORD pdwSize );

#endif // VIDMEMONLY

LPVMEMHEAP WINAPI VidMemInit( DWORD flags, FLATPTR start, FLATPTR end_or_width,
                              DWORD height, DWORD pitch );
void WINAPI VidMemFini( LPVMEMHEAP pvmh );
DWORD WINAPI VidMemAmountFree( LPVMEMHEAP pvmh );
DWORD WINAPI VidMemAmountAllocated( LPVMEMHEAP pvmh );
DWORD WINAPI VidMemLargestFree( LPVMEMHEAP pvmh );

#endif // __DDHEAP_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\win9x\thktypes.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       thktypes.h
 *  Content:	base types used by thunk compiler
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   26-feb-95	craige	split out of ddraw\types.h
 *   22-jun-95	craige	added RECT
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
typedef unsigned short USHORT;
typedef          short  SHORT;
typedef unsigned long  ULONG;
typedef          long   LONG;
typedef unsigned int   UINT;
typedef          int    INT;
typedef unsigned char  UCHAR;
typedef hinstance HINSTANCE;
typedef		int	BOOL;

typedef void    VOID;
typedef void   *PVOID;
typedef void   *LPVOID;
typedef UCHAR   BYTE;
typedef USHORT  WORD;
typedef ULONG   DWORD;
typedef UINT    HANDLE;
typedef char   *LPSTR;
typedef BYTE   *PBYTE;
typedef BYTE   *LPBYTE;
typedef USHORT  SEL;
typedef INT    *LPINT;
typedef UINT   *LPUINT;
typedef DWORD  *LPDWORD;
typedef LONG   *LPLONG;
typedef WORD   *LPWORD;

typedef HANDLE  HWND;
typedef HANDLE  HDC;
typedef HANDLE  HBRUSH;
typedef HANDLE  HBITMAP;
typedef HANDLE  HRGN;
typedef HANDLE  HFONT;
typedef HANDLE  HCURSOR;
typedef HANDLE  HMENU;
typedef HANDLE  HPEN;
typedef HANDLE  HICON;
typedef HANDLE  HUSER;      /* vanilla user handle */
typedef HANDLE  HPALETTE;
typedef HANDLE  HMF;
typedef HANDLE  HEMF;
typedef HANDLE	HCOLORSPACE;
typedef HANDLE  HMEM;
typedef HANDLE  HGDI;       /* vanilla gdi handle */
typedef HANDLE  HGLOBAL;
typedef HANDLE  HRSRC;
typedef HANDLE  HACCEL;

typedef WORD    ATOM;

typedef struct tagRECTL {
    LONG         left;
    LONG         top;
    LONG         right;
    LONG         bottom;
} RECTL;
typedef RECTL *LPRECTL;

typedef struct tagRECT {
    UINT         left;
    UINT         top;
    UINT         right;
    UINT         bottom;
} RECT;
typedef RECT *LPRECT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\win9x\types.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       types.h
 *  Content:	types used by thunk compiler
 *		** REMEMBER TO KEEP UP TO DATE WITH DDRAWI.H AND DDRAW.H **
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   20-jan-95	craige	initial implementation
 *   26-feb-95	craige	split out base types
 *   03-mar-95	craige	WaitForVerticalBlank stuff
 *   11-mar-95	craige	palette stuff
 *   28-mar-95	craige	added dwBase to DDHAL_SETENTRIESDATA
 *   01-apr-95	craige	happy fun joy updated header file
 *   06-apr-95	craige	added dwVidMemTotal, dwVidMemFree to DDCAPS
 *   14-may-95	craige	cleaned out obsolete junk
 *   24-may-95  kylej   removed obsolete ZOrder variables
 *   28-may-95	craige	cleaned up HAL: added GetBltStatus; GetFlipStatus;
 *			GetScanLine
 *   30-jun-95	craige	new fields in DDCAPS; cleanup
 *   02-jul-95	craige	added DEVMODE
 *   10-jul-95	craige	support SetOverlayPosition
 *   13-jul-95	craige	Get/SetOverlayPosition take LONGs
 *   14-jul-95	craige	added dwFlags to DDOVERLAYFX
 *   20-jul-95	craige	internal reorg to prevent thunking during modeset
 *   02-aug-95	craige	added dwMinOverlayStretch/dwMaxOverlayStretch to DDCAPS
 *   13-aug-95	craige	added dwCaps2 and reserved fields to DDCAPS
 *   09-dec-95  colinmc execute buffer support
 *   13-apr-96  colinmc Bug 17736: No driver notification of flip to GDI
 *   01-oct-96	ketand	added GetAvailDriverMemory
 *   20-jan-97  colinmc update non-local heap data
 *   08-mar-97  colinmc DDCAPS is now an API visible structure only.
 *                      DDCORECAPS is now passed in its place.
 *
 ***************************************************************************/
#include "thktypes.h"

typedef long	HRESULT;		// return values

/*
 * DDRAW.H STRUCTS FOLLOW
 */
typedef struct _DDSCAPS
{
    DWORD	dwCaps; 	// capabilities of surface wanted
} DDSCAPS;

typedef DDSCAPS * LPDDSCAPS;

typedef struct
{
    DWORD	dwSize; 	// size of structure
    DWORD	dwFlags;	// pixel format flags
    DWORD	dwFourCC;	// (FOURCC code)
    DWORD	dwBitCount;	// how many bits for alpha/z surfaces
    DWORD	dwRBitMask;	// mask for red bits
    DWORD	dwGBitMask;	// mask for green bits
    DWORD	dwBBitMask;	// mask for blue bits
    DWORD	dwRGBAlphaBitMask;// mask for alpha channel
} DDPIXELFORMAT;

typedef DDPIXELFORMAT * LPDDPIXELFORMAT;

typedef struct
{
    DWORD	dwColorSpaceLowValue;	// low boundary of color space that is to
    					// be treated as Color Key, inclusive
    DWORD	dwColorSpaceHighValue;	// high boundary of color space that is
    					// to be treated as Color Key, inclusive
} DDCOLORKEY;

typedef DDCOLORKEY * LPDDCOLORKEY;

typedef struct _DDSURFACEDESC
{
    DWORD		dwSize;			// size of the DDSURFACEDESC structure
    DWORD		dwFlags;		// determines what fields are valid
    DWORD		dwHeight;		// height of surface to be created
    DWORD		dwWidth;		// width of input surface
    LONG		lPitch;			// distance to start of next line (return value)
    DWORD		dwBackBufferCount;	// number of back buffers requested
    DWORD		dwZBufferBitDepth;	// depth of Z buffer requested
    DWORD		dwAlphaBitDepth;	// depth of alpha buffer requested
    DWORD		dwCompositionOrder;	// blt order for the surface, 0 is background
    DWORD		hWnd;			// window handle associated with surface
    DWORD		lpSurface;		// pointer to an associated surface memory
    DDCOLORKEY		ddckCKDestOverlay;	// color key for destination overlay use
    DDCOLORKEY		ddckCKDestBlt;		// color key for destination blt use
    DDCOLORKEY		ddckCKSrcOverlay;	// color key for source overlay use
    DDCOLORKEY		ddckCKSrcBlt;		// color key for source blt use
    DWORD		lpClipList;		// clip list (return value)
    DWORD		lpDDSurface;		// pointer to DirectDraw Surface struct (return value)
    DDPIXELFORMAT	ddpfPixelFormat; 	// pixel format description of the surface
    DDSCAPS		ddsCaps;		// direct draw surface capabilities
} DDSURFACEDESC;
typedef DDSURFACEDESC *LPDDSURFACEDESC;

typedef struct _DDCORECAPS
{
    DWORD	dwSize;			// size of the DDDRIVERCAPS structure
    DWORD	dwCaps;			// driver specific capabilities
    DWORD	dwCaps2;		// more driver specific capabilites
    DWORD	dwCKeyCaps;		// color key capabilities of the surface
    DWORD	dwFXCaps;		// driver specific stretching and effects capabilites
    DWORD	dwFXAlphaCaps;		// alpha driver specific capabilities
    DWORD	dwPalCaps;		// palette capabilities
    DWORD	dwSVCaps;		// stereo vision capabilities
    DWORD	dwAlphaBltConstBitDepths;	// DDBD_2,4,8
    DWORD	dwAlphaBltPixelBitDepths;	// DDBD_1,2,4,8
    DWORD	dwAlphaBltSurfaceBitDepths;	// DDBD_1,2,4,8
    DWORD	dwAlphaOverlayConstBitDepths;	// DDBD_2,4,8
    DWORD	dwAlphaOverlayPixelBitDepths;	// DDBD_1,2,4,8
    DWORD	dwAlphaOverlaySurfaceBitDepths; // DDBD_1,2,4,8
    DWORD	dwZBufferBitDepths;		// DDBD_8,16,24,32
    DWORD	dwVidMemTotal;		// total amount of video memory
    DWORD	dwVidMemFree;		// amount of free video memory
    DWORD	dwMaxVisibleOverlays;	// maximum number of visible overlays
    DWORD	dwCurrVisibleOverlays;	// current number of visible overlays
    DWORD	dwNumFourCCCodes;	// number of four cc codes
    DWORD	dwAlignBoundarySrc;	// source rectangle alignment
    DWORD	dwAlignSizeSrc;		// source rectangle byte size
    DWORD	dwAlignBoundaryDest;	// dest rectangle alignment
    DWORD	dwAlignSizeDest;	// dest rectangle byte size
    DWORD	dwAlignStrideAlign;	// stride alignment
    DWORD	dwRops[8];		// ROPS supported
    DDSCAPS	ddsCaps;		// DDSCAPS structure has all the general capabilities
    DWORD	dwMinOverlayStretch;	// minimum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMaxOverlayStretch;	// maximum overlay stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMinLiveVideoStretch;	// minimum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMaxLiveVideoStretch;	// maximum live video stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMinHwCodecStretch;	// minimum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwMaxHwCodecStretch;	// maximum hardware codec stretch factor multiplied by 1000, eg 1000 == 1.0, 1300 == 1.3
    DWORD	dwReserved1;		// reserved
    DWORD	dwReserved2;		// reserved
    DWORD	dwReserved3;		// reserved
} DDCORECAPS;

typedef struct _DDBLTFX
{
    DWORD	dwSize;				// size of structure
    DWORD	dwDDFX;				// FX operations
    DWORD	dwROP;				// Win32 raster operations
    DWORD	dwDDROP;			// Raster operations new for DirectDraw
    DWORD	dwRotationAngle;		// Rotation angle for blt
    DWORD	dwZBufferOpCode;		// ZBuffer compares
    DWORD	dwZBufferLow;			// Low limit of Z buffer
    DWORD	dwZBufferHigh;			// High limit of Z buffer
    DWORD	dwZBufferBaseDest;		// Destination base value
    DWORD	dwConstZDestBitDepth;		// Bit depth used to specify Z constant for destination
    DWORD	dwConstZDest;			// Constant to use as Z buffer for dest
    DWORD	dwConstZSrcBitDepth;		// Bit depth used to specify Z constant for source
    DWORD	dwConstZSrc;			// Constant to use as Z buffer for src
    DWORD	dwAlphaEdgeBlendBitDepth;	// Bit depth used to specify constant for alpha edge blend
    DWORD	dwAlphaEdgeBlend;		// Alpha for edge blending
    DWORD	dwReserved;
    DWORD	dwConstAlphaDestBitDepth;	// Bit depth used to specify alpha constant for destination
    DWORD	dwConstAlphaDest;		// Constant to use as Alpha Channel
    DWORD	dwConstAlphaSrcBitDepth;	// Bit depth used to specify alpha constant for source
    DWORD	dwConstAlphaSrc;		// Constant to use as Alpha Channel
    DWORD	dwFillColor;			// color in RGB or Palettized
    DDCOLORKEY	ddckDestColorkey;		// DestColorkey override
    DDCOLORKEY	ddckSrcColorkey;		// SrcColorkey override
} DDBLTFX;
typedef DDBLTFX *LPDDBLTFX;

typedef struct _DDOVERLAYFX
{
    DWORD	dwSize; 			// size of structure
    DWORD	dwAlphaEdgeBlendBitDepth;	// Bit depth used to specify constant for alpha edge blend
    DWORD	dwAlphaEdgeBlend;		// Constant to use as alpha for edge blend
    DWORD	dwReserved;
    DWORD	dwConstAlphaDestBitDepth;	// Bit depth used to specify alpha constant for destination
    DWORD	alphaDest; 			// alpha src (const or surface)
    DWORD	dwConstAlphaSrcBitDepth;	// Bit depth used to specify alpha constant for source
    DWORD	alphaSrc; 			// alpha src (const or surface)
    DDCOLORKEY	dckDestColorkey;		// DestColorkey override
    DDCOLORKEY	dckSrcColorkey;			// DestColorkey override
    DWORD       dwDDFX;                         // Overlay FX
    DWORD	dwFlags;			// flags
} DDOVERLAYFX;
typedef DDOVERLAYFX *LPDDOVERLAYFX;

/*
 * DDBLTBATCH: BltBatch entry structure
 */
typedef struct _DDBLTBATCH
{
    DWORD		lprDest;
    DWORD		lpDDSSrc;
    DWORD		lprSrc;
    DWORD		dwFlags;
    DWORD		lpDDBltFx;
} DDBLTBATCH;
typedef DDBLTBATCH * LPDDBLTBATCH;


/*
 * Note this is intentionally different from but equivalent to the defn in dmemmgr.h
 * The thunk compiler barfs on nameless unions.
 */
typedef struct _SURFACEALIGNMENT
{
    DWORD       dwStartOrXAlignment;
    DWORD       dwPitchOrYAlignment;
    DWORD       dwReserved1;
    DWORD       dwReserved2;
} SURFACEALIGNMENT;
typedef SURFACEALIGNMENT * LPSURFACEALIGNMENT;

/*
 * DDRAWI.H STRUCTS FOLLOW
 */
typedef unsigned long	FLATPTR;

typedef struct _VIDMEM
{
    DWORD		dwFlags;	//flags
    FLATPTR		fpStart;	// start of memory chunk
    FLATPTR		fpEnd;		// end of memory chunk
    DDSCAPS		ddCaps;		// what this memory CANNOT be used for
    DDSCAPS		ddCapsAlt;	// what this memory CANNOT be used for if it must
    DWORD		lpHeap;		// heap pointer, used by DDRAW
} VIDMEM;
typedef VIDMEM *LPVIDMEM;

typedef struct _VIDMEMINFO
{
    FLATPTR		fpPrimary;		// pointer to primary surface
    DWORD		dwFlags;		// flags
    DWORD		dwDisplayWidth;		// current display width
    DWORD		dwDisplayHeight;	// current display height
    LONG		lDisplayPitch;		// current display pitch
    DDPIXELFORMAT	ddpfDisplay;		// pixel format of display
    DWORD		dwOffscreenAlign;	// byte alignment for offscreen surfaces
    DWORD		dwOverlayAlign;		// byte alignment for overlays
    DWORD		dwTextureAlign;		// byte alignment for textures
    DWORD		dwZBufferAlign;		// byte alignment for z buffers
    DWORD		dwAlphaAlign;		// byte alignment for alpha
    DWORD		dwNumHeaps;		// number of memory heaps in vmList
    LPVIDMEM		pvmList;		// array of heaps
} VIDMEMINFO;
typedef VIDMEMINFO *LPVIDMEMINFO;

typedef struct _DDHAL_DDCALLBACKS
{
    DWORD	dwSize;
    DWORD	dwFlags;
    DWORD	DestroyDriver;
    DWORD	CreateSurface;
    DWORD	SetColorKey;
    DWORD	SetMode;
    DWORD	WaitForVerticalBlank;
    DWORD	CanCreateSurface;
    DWORD	CreatePalette;
    DWORD	GetScanLine;
    DWORD       SetExclusiveMode;
    DWORD       FlipToGDISurface;
} DDHAL_DDCALLBACKS;

typedef DDHAL_DDCALLBACKS *LPDDHAL_DDCALLBACKS;

typedef struct _DDHAL_DDSURFACECALLBACKS
{
    DWORD	dwSize;
    DWORD	dwFlags;
    DWORD	DestroySurface;
    DWORD	Flip;
    DWORD	SetClipList;
    DWORD	Lock;
    DWORD	Unlock;
    DWORD	Blt;
    DWORD	SetColorKey;
    DWORD	AddAttachedSurface;
    DWORD	GetBltStatus;
    DWORD	GetFlipStatus;
    DWORD	UpdateOverlay;
    DWORD	reserved3;
    DWORD	reserved4;
    DWORD	SetPalette;
} DDHAL_DDSURFACECALLBACKS;
typedef DDHAL_DDSURFACECALLBACKS *LPDDHAL_DDSURFACECALLBACKS;

typedef struct _DDHAL_DDPALETTECALLBACKS
{
    DWORD	dwSize;
    DWORD	dwFlags;
    DWORD	DestroyPalette;
    DWORD	SetEntries;
} DDHAL_DDPALETTECALLBACKS;

typedef DDHAL_DDPALETTECALLBACKS *LPDDHAL_DDPALETTECALLBACKS;

typedef struct _DDHAL_DDEXEBUFCALLBACKS
{
    DWORD	dwSize;
    DWORD	dwFlags;
    DWORD       CanCreateExecuteBuffer;
    DWORD       CreateExecuteBuffer;
    DWORD       DestroyExecuteBuffer;
    DWORD       LockExecuteBuffer;
    DWORD       UnlockExecuteBuffer;
} DDHAL_DDEXEBUFCALLBACKS;

typedef DDHAL_DDEXEBUFCALLBACKS *LPDDHAL_DDEXEBUFCALLBACKS;

typedef struct _DDHALMODEINFO
{
    DWORD	dwWidth;		// width (in pixels) of mode
    DWORD	dwHeight;		// height (in pixels) of mode
    LONG	lPitch;			// pitch (in bytes) of mode
    DWORD	dwBPP;			// bits per pixel
    DWORD	dwFlags;		// flags
    DWORD	dwRBitMask;		// red bit mask
    DWORD	dwGBitMask;		// green bit mask
    DWORD	dwBBitMask;		// blue bit mask
    DWORD	dwAlphaBitMask;		// alpha bit mask
} DDHALMODEINFO;
typedef DDHALMODEINFO *LPDDHALMODEINFO;

typedef struct _DDHALINFO
{
    DWORD			dwSize;
    LPDDHAL_DDCALLBACKS		lpDDCallbacks;		// direct draw object callbacks
    LPDDHAL_DDSURFACECALLBACKS	lpDDSurfaceCallbacks;	// surface object callbacks
    LPDDHAL_DDPALETTECALLBACKS	lpDDPaletteCallbacks;	// palette object callbacks
    VIDMEMINFO			vmiData;		// video memory info
    DDCORECAPS			ddCaps;			// hw specific caps
    DWORD			dwMonitorFrequency;	// monitor frequency in current mode
    DWORD			hWndListBox;		// list box for debug output
    DWORD			dwModeIndex;		// current mode: index into array
    DWORD			*lpdwFourCC;		// fourcc codes supported
    DWORD			dwNumModes;		// number of modes supported
    LPDDHALMODEINFO		lpModeInfo;		// mode information
    DWORD			dwFlags;		// create flags
    DWORD			lpPDevice;		// physical device
} DDHALINFO;
typedef DDHALINFO *LPDDHALINFO;

typedef struct
{
    DWORD	lpDD;			// driver struct
    DWORD	lpDDDestSurface;	// dest surface
    RECTL	rDest;			// dest rect
    DWORD	lpDDSrcSurface;		// src surface
    RECTL	rSrc;			// src rect
    DWORD	dwFlags;		// blt flags
    DWORD	dwROPFlags;		// ROP flags (valid for ROPS only)
    DDBLTFX	bltFX;			// blt FX
    HRESULT	ddRVal;			// return value
    DWORD	Blt;			// PRIVATE: ptr to callback
} DDHAL_BLTDATA;
typedef DDHAL_BLTDATA *LPDDHAL_BLTDATA;

typedef struct _DDHAL_LOCKDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDSurface;	// surface struct
    DWORD	bHasRect;	// rArea is valid
    RECTL	rArea;		// area being locked
    DWORD	lpSurfData;	// pointer to screen memory (return value)
    HRESULT	ddRVal;		// return value
    DWORD	Lock;		// PRIVATE: ptr to callback
} DDHAL_LOCKDATA;
typedef DDHAL_LOCKDATA *LPDDHAL_LOCKDATA;

typedef struct _DDHAL_UNLOCKDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDSurface;	// surface struct
    HRESULT	ddRVal;		// return value
    DWORD	Unlock;		// PRIVATE: ptr to callback
} DDHAL_UNLOCKDATA;
typedef DDHAL_UNLOCKDATA *LPDDHAL_UNLOCKDATA;

typedef struct _DDHAL_UPDATEOVERLAYDATA
{
    DWORD		lpDD;			// driver struct
    DWORD		lpDDDestSurface;	// dest surface
    RECTL		rDest;			// dest rect
    DWORD		lpDDSrcSurface;		// src surface
    RECTL		rSrc;			// src rect
    DWORD		dwFlags;		// flags
    DDOVERLAYFX		overlayFX;		// overlay FX
    HRESULT		ddRVal;			// return value
    DWORD 		UpdateOverlay;		// PRIVATE: ptr to callback
} DDHAL_UPDATEOVERLAYDATA;
typedef DDHAL_UPDATEOVERLAYDATA *LPDDHAL_UPDATEOVERLAYDATA;

typedef struct _DDHAL_SETOVERLAYPOSITIONDATA
{
    DWORD		lpDD;			// driver struct
    DWORD		lpDDSrcSurface;		// src surface
    DWORD		lpDDDestSurface;	// dest surface
    LONG		lXPos;			// x position
    LONG		lYPos;			// y position
    HRESULT		ddRVal;			// return value
    DWORD		SetOverlayPosition; 	// PRIVATE: ptr to callback
} DDHAL_SETOVERLAYPOSITIONDATA;
typedef DDHAL_SETOVERLAYPOSITIONDATA *LPDDHAL_SETOVERLAYPOSITIONDATA;

typedef struct _DDHAL_SETPALETTEDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDSurface;	// surface struct
    DWORD	lpDDPalette;	// palette to set to surface
    HRESULT	ddRVal;		// return value
    DWORD	SetPalette;	// PRIVATE: ptr to callback
} DDHAL_SETPALETTEDATA;
typedef DDHAL_SETPALETTEDATA *LPDDHAL_SETPALETTEDATA;

typedef struct _DDHAL_FLIPDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpSurfCurr;	// current surface
    DWORD	lpSurfTarg;	// target surface (to flip to)
    DWORD	dwFlags;	// flags
    HRESULT	ddRVal;		// return value
    DWORD	Flip;		// PRIVATE: ptr to callback
} DDHAL_FLIPDATA;
typedef DDHAL_FLIPDATA *LPDDHAL_FLIPDATA;

typedef struct _DDHAL_DESTROYSURFACEDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDSurface;	// surface struct
    HRESULT	ddRVal;		// return value
    DWORD 	DestroySurface;	// PRIVATE: ptr to callback
} DDHAL_DESTROYSURFACEDATA;
typedef DDHAL_DESTROYSURFACEDATA *LPDDHAL_DESTROYSURFACEDATA;

typedef struct _DDHAL_SETCLIPLISTDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDSurface;	// surface struct
    HRESULT	ddRVal;		// return value
    DWORD	SetClipList;	// PRIVATE: ptr to callback
} DDHAL_SETCLIPLISTDATA;
typedef DDHAL_SETCLIPLISTDATA *LPDDHAL_SETCLIPLISTDATA;

typedef struct _DDHAL_ADDATTACHEDSURFACEDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDSurface;	// surface struct
    DWORD	lpSurfAttached;	// surface to attach
    HRESULT	ddRVal;		// return value
    DWORD	AddAttachedSurface; // PRIVATE: ptr to callback
} DDHAL_ADDATTACHEDSURFACEDATA;
typedef DDHAL_ADDATTACHEDSURFACEDATA *LPDDHAL_ADDATTACHEDSURFACEDATA;

typedef struct _DDHAL_SETCOLORKEYDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDSurface;	// surface struct
    DWORD 	dwFlags;	// flags
    DDCOLORKEY ckNew;		// new color key
    HRESULT	ddRVal;		// return value
    DWORD	SetColorKey;	// PRIVATE: ptr to callback
} DDHAL_SETCOLORKEYDATA;
typedef DDHAL_SETCOLORKEYDATA *LPDDHAL_SETCOLORKEYDATA;

typedef struct _DDHAL_GETBLTSTATUSDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDSurface;	// surface struct
    DWORD	dwFlags;	// flags
    HRESULT	ddRVal;		// return value
    DWORD 	GetBltStatus;	// PRIVATE: ptr to callback
} DDHAL_GETBLTSTATUSDATA;
typedef DDHAL_GETBLTSTATUSDATA *LPDDHAL_GETBLTSTATUSDATA;

typedef struct _DDHAL_GETFLIPSTATUSDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDSurface;	// surface struct
    DWORD	dwFlags;	// flags
    HRESULT	ddRVal;		// return value
    DWORD 	GetFlipStatus;	// PRIVATE: ptr to callback
} DDHAL_GETFLIPSTATUSDATA;
typedef DDHAL_GETFLIPSTATUSDATA *LPDDHAL_GETFLIPSTATUSDATA;

typedef struct _DDHAL_CREATEPALETTEDATA
{
    DWORD	lpDD;		// driver struct
    HRESULT	ddRVal;		// return value
    DWORD	CreatePalette;	// PRIVATE: ptr to callback
} DDHAL_CREATEPALETTEDATA;
typedef DDHAL_CREATEPALETTEDATA *LPDDHAL_CREATEPALETTEDATA;

typedef struct _DDHAL_CREATESURFACEDATA
{
    DWORD		lpDD;		// driver struct
    DWORD		lpDDSurfaceDesc;// description of surface being created
    DWORD		lplpSList;	// list of created surface objects
    DWORD		dwSCnt;		// number of surfaces in SList
    HRESULT		ddRVal;		// return value
    DWORD		CreateSurface;	// PRIVATE: ptr to callback
} DDHAL_CREATESURFACEDATA;
typedef DDHAL_CREATESURFACEDATA *LPDDHAL_CREATESURFACEDATA;

typedef struct _DDHAL_CANCREATESURFACEDATA
{
    DWORD		lpDD;			// driver struct
    DWORD		lpDDSurfaceDesc;	// description of surface being created
    DWORD		bIsDifferentPixelFormat;// pixel format differs from primary surface
    HRESULT		ddRVal;			// return value
    DWORD	 	CanCreateSurface;	// PRIVATE: ptr to callback
} DDHAL_CANCREATESURFACEDATA;
typedef DDHAL_CANCREATESURFACEDATA *LPDDHAL_CANCREATESURFACEDATA;

typedef struct _DDHAL_WAITFORVERTICALBLANKDATA
{
    DWORD		lpDD;			// driver struct
    DWORD		dwFlags;		// flags
    DWORD		bIsInVB;		// curr scan line
    DWORD		hEvent;			// event
    HRESULT		ddRVal;			// return value
    DWORD	 	WaitForVerticalBlank;	// PRIVATE: ptr to callback
} DDHAL_WAITFORVERTICALBLANKDATA;
typedef DDHAL_WAITFORVERTICALBLANKDATA *LPDDHAL_WAITFORVERTICALBLANKDATA;

typedef struct _DDHAL_DESTROYDRIVERDATA
{
    DWORD	lpDD;		// driver struct
    HRESULT	ddRVal;		// return value
    DWORD	DestroyDriver;	// PRIVATE: ptr to callback
} DDHAL_DESTROYDRIVERDATA;
typedef DDHAL_DESTROYDRIVERDATA *LPDDHAL_DESTROYDRIVERDATA;

typedef struct _DDHAL_SETMODEDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	dwModeIndex;	// new mode index
    HRESULT	ddRVal;		// return value
    DWORD	SetMode;	// PRIVATE: ptr to callback
} DDHAL_SETMODEDATA;
typedef DDHAL_SETMODEDATA *LPDDHAL_SETMODEDATA;

typedef struct _DDHAL_SETEXCLUSIVEMODEDATA
{
    DWORD	lpDD;		  // driver struct
    DWORD       dwEnterExcl;      // TRUE if entering exclusive mode, FALSE if leaving
    DWORD       dwReserved;       // reserved for future use
    HRESULT	ddRVal;		  // return value
    DWORD	SetExclusiveMode; // PRIVATE: ptr to callback
} DDHAL_SETEXCLUSIVEMODEDATA;
typedef DDHAL_SETEXCLUSIVEMODEDATA *LPDDHAL_SETEXCLUSIVEMODEDATA;

typedef struct _DDHAL_FLIPTOGDISURFACEDATA
{
    DWORD	lpDD;		  // driver struct
    DWORD       dwToGDI;          // TRUE if flipping to the GDI surface, FALSE if flipping away
    DWORD       dwReserved;       // resereved for future use
    HRESULT	ddRVal;		  // return value
    DWORD	FlipToGDISurface; // PRIVATE: ptr to callback
} DDHAL_FLIPTOGDISURFACEDATA;
typedef DDHAL_FLIPTOGDISURFACEDATA *LPDDHAL_FLIPTOGDISURFACEDATA;

typedef struct _DDHAL_GETAVAILDRIVERMEMORYDATA
{
    DWORD	lpDD;		 // [in] driver struct
    DDSCAPS	DDSCaps;	 // [in] caps for type of surface memory
    DWORD	dwTotal;	 // [out] total memory for this kind of surface
    DWORD	dwFree;		 // [out] free memory for this kind of surfcae
    HRESULT	ddRVal;		 // [out] return value
    DWORD	GetAvailDriverMemory; // PRIVATE: ptr to callback
} DDHAL_GETAVAILDRIVERMEMORYDATA;
typedef DDHAL_GETAVAILDRIVERMEMORYDATA *LPDDHAL_GETAVAILDRIVERMEMORYDATA;

typedef struct _DDHAL_UPDATENONLOCALHEAPDATA
{
    DWORD	lpDD;		 // [in] driver struct
    DWORD	dwHeap;		 // [in] index of heap being updated
    DWORD	fpGARTLin;	 // [in] linear GART address of heap start
    DWORD	fpGARTDev;       // [in] high physical GART address of heap start
    HRESULT	ddRVal;		 // [out] return value
    DWORD	UpdateNonLocalHeap; // PRIVATE: ptr to callback
} DDHAL_UPDATENONLOCALHEAPDATA;
typedef DDHAL_UPDATENONLOCALHEAPDATA *LPDDHAL_UPDATENONLOCALHEAPDATA;

typedef struct _DDHAL_GETSCANLINEDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	dwScanLine;	// returned scan line
    HRESULT	ddRVal;		// return value
    DWORD	GetScanLine;	// PRIVATE: ptr to callback
} DDHAL_GETSCANLINEDATA;
typedef DDHAL_GETSCANLINEDATA *LPDDHAL_GETSCANLINEDATA;

typedef struct _DDHAL_DESTROYPALETTEDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDPalette;	// palette struct
    HRESULT	ddRVal;		// return value
    DWORD	DestroyPalette;	// PRIVATE: ptr to callback
} DDHAL_DESTROYPALETTEDATA;
typedef DDHAL_DESTROYPALETTEDATA *LPDDHAL_DESTROYPALETTEDATA;

typedef struct _DDHAL_SETENTRIESDATA
{
    DWORD	lpDD;		// driver struct
    DWORD	lpDDPalette;	// palette struct
    DWORD	dwBase;		// base palette index
    DWORD	dwNumEntries;	// number of palette entries
    LPVOID	lpEntries;	// color table
    HRESULT	ddRVal;		// return value
    DWORD	SetEntries;	// PRIVATE: ptr to callback
} DDHAL_SETENTRIESDATA;
typedef DDHAL_SETENTRIESDATA *LPDDHAL_SETENTRIESDATA;

typedef struct _devicemodeA {
    BYTE   dmDeviceName[32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    short dmOrientation;
    short dmPaperSize;
    short dmPaperLength;
    short dmPaperWidth;
    short dmScale;
    short dmCopies;
    short dmDefaultSource;
    short dmPrintQuality;
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    BYTE   dmFormName[32];
    WORD   dmLogPixels;
    DWORD  dmBitsPerPel;
    DWORD  dmPelsWidth;
    DWORD  dmPelsHeight;
    DWORD  dmDisplayFlags;
    DWORD  dmDisplayFrequency;
    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmReserved1;
    DWORD  dmReserved2;
} DEVMODE;

typedef DEVMODE *LPDEVMODE;

typedef struct _DDCOLORCONTROL
{
    DWORD 		dwSize;
    DWORD		dwFlags;
    DWORD		lBrightness;
    DWORD		lContrast;
    DWORD		lHue;
    DWORD 		lSaturation;
    DWORD		lSharpness;
    DWORD		lGamma;
    DWORD		lEnable;
} DDCOLORCONTROL;

typedef struct _DDHAL_COLORCONTROLDATA
{
    DWORD		lpDD;			// driver struct
    DWORD		lpDDSurface;		// surface
    DDCOLORCONTROL 	ColorData;		// color control information
    DWORD		dwFlags;		// DDRAWI_GETCOLOR/DDRAWI_SETCOLOR
    HRESULT		ddRVal;			// return value
    DWORD		ColorControl;		// PRIVATE: ptr to callback
} DDHAL_COLORCONTROLDATA;
typedef DDHAL_COLORCONTROLDATA *LPDDHAL_COLORCONTROLDATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\dd\ddraw\main\win9x\i386\thk.inc ===
f16ptr  typedef ptr far16
f32ptr  typedef ptr far32

;==============================================================================
; save all 16-bit registers, except dx:ax
;
;==============================================================================
SAVEALL     macro
    push    cx      ; save all 16-bit registers, except dx:ax
    push    bx
    push    bp
    push    si
    push    di
    push    ds
    push    es
endm


;==============================================================================
; restore all 16-bit registers, except dx:ax
;
;==============================================================================
RESTOREALL  macro  StackType:=<Stack16>
    POPW    es      ; restore all 16-bit registers, except dx:ax

    CHECKW  ds, StackType
    POPW    ds
    CHECKW  di, StackType
    pop     di

    CHECKW  si, StackType
    pop     si
    CHECKW  bp, StackType
    pop     bp

    pop     bx
    pop     cx
endm


;==============================================================================
; test two text macros for equality
;
;
;==============================================================================
TextEqual? macro   Text_1, Text_2
    ifidni <Text_1>, <Text_2>
        exitm <not 0>
    endif
    exitm <0>
endm


;==============================================================================
; test two text macros for difference
;
;
;==============================================================================
TextDiff? macro   Text_1, Text_2
    ifidni <Text_1>, <Text_2>
        exitm <0>
    endif
    exitm <not 0>
endm


;==============================================================================
; check a word on top of the stack
; if not equal, break
;
;==============================================================================
CHECKW    macro   CurrentReg, StackType:=<Stack16>

    if (@WordSize eq 4) and TextDiff? (&StackType&,Stack16)
    push    eax
    mov     ax,&CurrentReg&
    cmp     ax,word ptr [esp+4]
    pop     eax
    je      @F
    int     3
@@:
    else


    push    bp
    push    ax
    mov     ax,&CurrentReg&
    mov     bp,sp
    and     ebp,0ffffh
    cmp     ax,word ptr [ebp+4]
    pop     ax
    pop     bp
    je      @F
    int     3
@@:
    endif

endm


;==============================================================================
; pop word
;
;==============================================================================
POPW    macro   SegReg
    if @WordSize eq 4
        db      66h
    endif
    pop     SegReg
endm


;==============================================================================
; pop dword
;
;==============================================================================
POPD    macro   SegReg
    if @WordSize eq 2
        db      66h
    endif
    pop     SegReg
endm


;==============================================================================
; operand-size override
;
;==============================================================================
OTHER_OPERAND_SIZE  macro   arg
    db  66h
    arg
endm


;==============================================================================
; address-size override
;
;==============================================================================
OTHER_ADDRESS_SIZE  macro   arg
    db  67h
    arg
endm


;==============================================================================
; allocate and public a byte flag
;
;==============================================================================
PubByte  macro   name, value
    public  name
    name    db      value
endm


;==============================================================================
; log an api call, 16-bit
;
;==============================================================================
APILOG16  macro   argName, argFlag, argComment
        local   do_it,done,szApiName

ifdef DEBUG
externDef PCodeDebug16:far16
externDef OutputDebugString:far16

        push    ds
        push    ax
        mov     ax,seg &argFlag
        mov     ds,ax
        cmp     &argFlag,0
        je      done
        jmp     do_it

szApiName db 'Api 16=>32: &argName& &argComment&',0Ah,0Dh,0

do_it:
        push    seg    szApiName
        push    offset szApiName
        call    OutputDebugString
done:
        pop     ax
        pop     ds

        call    PCodeDebug16
endif
endm


;==============================================================================
; log an api call, 32-bit
;
;==============================================================================
APILOG  macro   argName, argFlag
        local   do_it,done,szApiName
ifdef DEBUG
;externDef _DbgPrint:near32

        ;;If argFlag is nonzero, print out the message.
        cmp     argFlag&,0
        jnz     do_it
        jmp     short done
;;Define the name here so we can pass it to _DbgPrint.
szApiName db '&argName&',0
do_it:
        push    offset FLAT:szApiName
        push    offset FLAT:szApiFmt
        ;call    _DbgPrint
        add     esp,2*4
done:
endif
endm


;==============================================================================
; log 16-bit api return, in 32-bit code
;
;==============================================================================
RETLOG  macro   argFlag
        local   do_it, done, szRetFmt
ifdef DEBUG
externDef argFlag&:byte
;externDef _DbgPrint:near32
        cmp     argFlag&,0
        je      done
        jmp     do_it

szRetFmt db "Ret 16=>32: %4x:%4x",0dh,0ah,0
do_it:
        push    eax             ;;save return code value
        push    edx

        push    word ptr 0      ;;parameters to _DbgPrint
        push    ax
        push    word ptr 0
        push    dx
        push    offset szRetFmt
        ;call    _DbgPrint
        add     esp,3*4

        pop     edx             ;;restore return code
        pop     eax
done:
endif
endm



;==============================================================================
; conditionally break
;
;==============================================================================
SWITCHABLE_INT3 macro argLabel, argFlag
externDef   argLabel :far16

        push    ds
        push    ax
        mov     ax,seg &argFlag
        mov     ds,ax
        cmp     &argFlag,0
        je      @F
argLabel& label far16
        int     3
@@:
        pop     ax
        pop     ds
endm


;==============================================================================
;
;
;==============================================================================
STUB0   macro   module, argLabel, nBytes, argComment:=<stub0>
externDef   argLabel&16 :far16
argLabel&16 label far16

ifdef FSAVEALL
        SAVEALL
endif
        APILOG16 argLabel&16, f&module&ApiLog, argComment
ifdef INT3
        SWITCHABLE_INT3 argLabel&_stub, f&module&Int3
endif
        xor     ax,ax
        cwd
ifdef FSAVEALL
        RESTOREALL
endif
        retf    &nBytes&
endm


;==============================================================================
;
;
;==============================================================================
STUB    macro   module, argLabel, nBytes, nRetAX, argComment:=<stub>
externDef   argLabel&16 :far16
externDef   PCodeDebug16 :far16
argLabel&16 label far16

ifdef FSAVEALL
        SAVEALL
endif
        APILOG16 argLabel&16, f&module&ApiLog, argComment nRetAX
ifdef INT3
        SWITCHABLE_INT3 argLabel&_stub, f&module&Int3
endif
        mov     ax,&nRetAX
ifdef FSAVEALL
        RESTOREALL
endif
        retf    nBytes
endm


;==============================================================================
; repack TEXTMETRIC from 32-bit to 16-bit
;
;==============================================================================
PACK_TEXTMETRIC_32_16   macro

        lodsd                           ; first 8 int widened
        stosw

        lodsd
        stosw

        lodsd
        stosw

        lodsd
        stosw

        lodsd
        stosw

        lodsd
        stosw

        lodsd
        stosw

        lodsd
        stosw

        add     esi,12                  ; 9 bytes moved to end

        movsd
        movsd
        movsb

        sub     esi,21                  ; final 3 int

        lodsd
        stosw

        lodsd
        stosw

        lodsd
        stosw
endm


;==============================================================================
; repack TEXTMETRIC from 16-bit to 32-bit
;
;==============================================================================
PACK_TEXTMETRIC_16_32   macro

        lodsw                           ; first 8 int widened
        cwde
        stosd

        lodsw
        cwde
        stosd

        lodsw
        cwde
        stosd

        lodsw
        cwde
        stosd

        lodsw
        cwde
        stosd

        lodsw
        cwde
        stosd

        lodsw
        cwde
        stosd

        lodsw
        cwde
        stosd

        add     esi,9                   ; 3 ints after nine bytes

        lodsw
        cwde
        stosd

        lodsw
        cwde
        stosd

        lodsw
        cwde
        stosd

        sub     esi,21                  ; now do the nine bytes

        movsd
        movsd
        movsb
endm


;==============================================================================
; repack BITMAP from 32-bit to 16-bit
;
;==============================================================================
PACK_BITMAP_32_16   macro

        lodsd                           ; first 4 int widened
        stosw

        lodsd
        stosw

        lodsd
        stosw

        lodsd
        stosw

        add     esi,4                   ; 2 bytes moved to end
        movsw

        sub     esi,6
        movsd                           ; bmBits
endm


;==============================================================================
; entry code for flat common callback
;
;==============================================================================
CALLBACK_PROLOGUE   macro

        pop     eax                     ; 16:16 callback
        pop     edx                     ; eip, API32

        push    cs                      ; flat cs
        push    edx                     ; eip, API32
        push    eax                     ; 16:16 callback

        push    ebp
        mov     ebp,esp

        push    ds                      ; save registers
        push    es
        push    ebx
        push    edi
        push    esi
endm


;==============================================================================
; exit code for flat common callback
;
;==============================================================================
CALLBACK_EPILOGUE   macro   size

        LOCAL   bad_esp

;--------------------------------------------------
; switch stacks and jump to 16:16 callback

; when the 16:16 callback does a retf, we will hit our cleanup routine

        push    dword ptr ADDR_THK_CLEANUP_&size

; prepare to transfer to the 16-bit callback function

        push    pCallback16

; get the ss16 we had when we entered the callback API16
; make the 16-bit ss:sp point to the same linear address as the flat ss:esp

        call    UsrQuerySS16
        mov     esi,eax                 ; save ss16
        push    eax
        call    GetSelectorBase32       ; LATER: LDT lookup
        xchg    eax,esp
        sub     eax,esp
        jb      bad_esp
        cmp     eax,65535
        ja      bad_esp

        mov     ss,si
        mov     sp,ax

; effectively, jmp to 16:16 callback
        retw

bad_esp:
        int     3

endm


;==============================================================================
; 16-bit callback cleanup code
;
;==============================================================================
CALLBACK_CLEANUP    macro   size

        pop     si                      ; get hMem
        pop     di
        mov     cx,si
        or      cx,di
        jz      @F

        push    di                      ; hMem !NULL, so dealloc
        push    si
        call    LocalFree
@@:
        call    UnmapLS                 ; thunk id already on stack
        add     sp,2                    ; flat setup pushed dword

        movzx   ecx,sp                  ; restore flat stack
        lss     esp,ss:[ecx]

        pop     esi                     ; restore registers
        pop     edi
        pop     ebx
        POPD    es
        POPD    ds
        pop     ebp

        pop     ecx                     ; discard 16:16 callback

        retd    size                    ; return to the 32-bit API
endm


;==============================================================================
; save flat stack and thunkID
;
;==============================================================================
SAVE_STACK_AND_THUNKID  macro

        lea     eax,[addr_registers]    ; save flat stack
        push    ss
        push    eax

        call    GetThunkID32
        push    eax                     ; save 16:16 thunkID
endm

;==============================================================================
; entry code for 16-bit common callback to 32-bit function
;
;==============================================================================
CALLBACK_BODY_16   macro     name, size, aliases
        local   callback_ret

CB16_&name label far16
for     x,<aliases>
        CB16_&x label far16
endm

        push    bp
        push    si
        push    di
        push    ds

        mov     ax,sp
        push    ss
        push    ax

        mov     ax,sp
        push    ss
        push    ax
        call    SelectorOffsetToLinear16
        mov     ebx,eax
        and     eax,not 3
        mov     cx,cs:FlatData
        mov     ss,cx
        mov     esp,eax
        mov     ds,cx
        mov     es,cx

        push    cs
        push    offset callback_ret
        jmp     f32ptr ptr pfn&name&Callback
callback_ret:

        lss     sp,ss:[ebx]
        pop     ds
        pop     di
        pop     si
        pop     bp

        retf    size                    ; return to the 16-bit API
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\misc\dxvalid.h ===
//--------------------------------------------------------------------------;
//
//  File: dxvalid.h
//
//  Copyright (c) 1996 Microsoft Corporation.  All Rights Reserved.
//
//  Abstract:
//      This header contains common parameter validate macros for DirectX.
//
//  History:
//      02/14/96    angusm    Initial version
//      03/05/96    angusm    added VALIDEX_GUID_PTR
//
//--------------------------------------------------------------------------;


// _________________________________________________________________________
// VALIDEX_xxx 
//     macros are the same for debug and retail


#define VALIDEX_PTR( ptr, size ) \
	(!IsBadReadPtr( ptr, size) )

#define VALIDEX_GUID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( GUID ) ) )

#define VALIDEX_IID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( IID )) )

#define VALIDEX_PTR_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( LPVOID )) )

#define VALIDEX_CODE_PTR( ptr ) \
	(!IsBadCodePtr( (LPVOID) ptr ) )


// _________________________________________________________________________
// VALID_xxx 
//     macros that check memory allocated and sent as API parameters


#ifndef DEBUG
#define FAST_CHECKING
#endif

#ifndef FAST_CHECKING

#define VALID_BOOL_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( BOOL ) ))
#define VALID_DDCOLORKEY_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( DDCOLORKEY ) ) )
#define VALID_RGNDATA_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( RGNDATA ) ) )
#define VALID_RECT_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( RECT ) ) )
#define VALID_PTR_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( LPVOID )) )
#define VALID_IID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( IID )) )
#define VALID_HWND_PTR( ptr ) \
	(!IsBadWritePtr( (LPVOID) ptr, sizeof( HWND )) )
#define VALID_VMEM_PTR( ptr ) \
	(!IsBadWritePtr( (LPVOID) ptr, sizeof( VMEM )) )
#define VALID_POINTER_ARRAY( ptr, cnt ) \
	(!IsBadWritePtr( ptr, sizeof( LPVOID ) * cnt ) )
#define VALID_HANDLE_PTR( ptr ) \
	(!IsBadWritePtr( ptr, sizeof( HANDLE )) )
#define VALID_DWORD_ARRAY( ptr, cnt ) \
	(!IsBadWritePtr( ptr, sizeof( DWORD ) * cnt ) )
#define VALID_GUID_PTR( ptr ) \
	(!IsBadReadPtr( ptr, sizeof( GUID ) ) )
#define VALID_BYTE_ARRAY( ptr, cnt ) \
        (!IsBadWritePtr( ptr, sizeof( BYTE ) * cnt ) )
#define VALID_PTR( ptr, size ) \
	(!IsBadReadPtr( ptr, size) )

#else
#define VALID_PTR( ptr, size ) 		1
#define VALID_DIRECTDRAW_PTR( ptr )	1
#define VALID_DIRECTDRAWSURFACE_PTR( ptr )	1
#define VALID_DIRECTDRAWPALETTE_PTR( ptr )	1
#define VALID_DIRECTDRAWCLIPPER_PTR( ptr )	1
#define VALID_DDSURFACEDESC_PTR( ptr ) (ptr->dwSize == sizeof( DDSURFACEDESC ))
#define VALID_BOOL_PTR( ptr )	1
#define VALID_HDC_PTR( ptr )	1
#define VALID_DDPIXELFORMAT_PTR( ptr ) (ptr->dwSize == sizeof( DDPIXELFORMAT ))
#define VALID_DDCOLORKEY_PTR( ptr )	1
#define VALID_RGNDATA_PTR( ptr )	1
#define VALID_RECT_PTR( ptr )	1
#define VALID_DDOVERLAYFX_PTR( ptr ) (ptr->dwSize == sizeof( DDOVERLAYFX ))
#define VALID_DDBLTFX_PTR( ptr ) (ptr->dwSize == sizeof( DDBLTFX ))
#define VALID_DDBLTBATCH_PTR( ptr )	1
#define VALID_DDMASK_PTR( ptr )	1
#define VALID_DDSCAPS_PTR( ptr )	1
#define VALID_PTR_PTR( ptr )	1
#define VALID_IID_PTR( ptr )	1
#define VALID_HWND_PTR( ptr )	1
#define VALID_VMEM_PTR( ptr )	1
#define VALID_POINTER_ARRAY( ptr, cnt ) 1
#define VALID_PALETTEENTRY_ARRAY( ptr, cnt )	1
#define VALID_HANDLE_PTR( ptr )	1
#define VALID_DDCAPS_PTR( ptr ) (ptr->dwSize == sizeof( DDCAPS ))
#define VALID_READ_DDSURFACEDESC_ARRAY( ptr, cnt )	1
#define VALID_DWORD_ARRAY( ptr, cnt )	1
#define VALID_GUID_PTR( ptr )	1
#define VALID_BYTE_ARRAY( ptr, cnt ) 1

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\inc\ddagp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddagp.h
 *  Content:	AGP memory header file
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   03-Feb-98	DrewB   Split from ddrawpr.h for user/kernel portability.
 *
 ***************************************************************************/

#ifndef __DDAGP_INCLUDED__
#define __DDAGP_INCLUDED__

// This value controls how big a chunk of GART memory to commit each time
// we need to (rather than commiting just what we need to satisfy a surface
// request). This value is in bytes.  Currently 256KB.
#define DEFAULT_AGP_COMMIT_DELTA (256 * 1024)

extern DWORD dwAGPPolicyMaxBytes;
extern DWORD dwAGPPolicyCommitDelta;

//
// OS-specific functions for AGP manipulation.
//

#ifdef WIN95
#define OsGetAGPDeviceHandle(pHeap) GetDXVxdHandle()
#define OsCloseAGPDeviceHandle(h) CloseHandle(h)
#else
#define OsGetAGPDeviceHandle(pHeap) ((pHeap)->hdevAGP)
#define OsCloseAGPDeviceHandle(h)
#endif

BOOL OsAGPReserve( HANDLE hdev, DWORD dwNumPages, BOOL fIsUC, BOOL fIsWC,
                   FLATPTR *pfpLinStart, LARGE_INTEGER *pliDevStart,
                   LPVOID *ppvReservation );
BOOL OsAGPCommit( HANDLE hdev, LPVOID pvReservation,
                  DWORD dwPageOffset, DWORD dwNumPages );
BOOL OsAGPDecommitAll( HANDLE hdev, LPVOID pvReservation, DWORD dwNumPages );
BOOL OsAGPFree( HANDLE hdev, LPVOID pvReservation );

//
// Generic functions that use the OS-specific functions.
//

DWORD AGPReserve( HANDLE hdev, DWORD dwSize, BOOL fIsUC, BOOL fIsWC,
                  FLATPTR *pfpLinStart, LARGE_INTEGER *pliDevStart,
                  LPVOID *ppvReservation );
BOOL AGPCommit( HANDLE hdev, LPVOID pvReservation,
                DWORD dwOffset, DWORD dwSize );
BOOL AGPDecommitAll( HANDLE hdev, LPVOID pvReservation, DWORD dwSize );
BOOL AGPFree( HANDLE hdev, LPVOID pvReservation );

#ifndef __NTDDKCOMP__

#ifdef WIN95
BOOL vxdIsVMMAGPAware ( HANDLE hvxd );
#endif

BOOL OSIsAGPAware( HANDLE hdev );
#endif

#endif // __DDAGP_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\misc\dpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.c
 *  Content:    debugging printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-jan-95  craige  initial implementation
 *   03-mar-95  craige  added dprintf2
 *   31-mar-95  craige  add DPFInit to read WIN.INI for [DirectDraw] section;
 *                      added dprintf3
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   18-jun-95  craige  use negative dpf level to display ONLY that level
 *   06-dec-95  jeffno  Changed DXdprintf to use c-standard variable argument
 *                      list techniques. Also added abs for NT
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96  kipo    added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
    #include "newdpf.c"
#else   //use old debug:

    #undef WIN32_LEAN_AND_MEAN
    #define WIN32_LEAN_AND_MEAN
    #include <windows.h>
    #include "dpf.h"
    #include <stdarg.h>

    //#ifdef WINNT
    //int abs(int x)
    //{
    //    return x>=0?x:-x;
    //}
    //#endif

    #ifdef DEBUG

    #define USE_DDASSERT

    #ifndef START_STR
        #define START_STR       "DDRAW: "
    #endif
    #ifndef PROF_SECT
        #define PROF_SECT       "DirectDraw"
    #endif

    #define END_STR             "\r\n"

    HWND                hWndListBox;
    LONG                lDebugLevel = 0;

    /*
     * dumpStr
     */
    static void dumpStr( LPSTR str )
    {
        OutputDebugString( str );

        #ifdef DPF_HWND
            if( hWndListBox != NULL )
            {
                if( !IsWindow( hWndListBox ) )
                {
                    hWndListBox = NULL;
                }
            }
            if( hWndListBox != NULL )
            {
                UINT    sel;
                int     len;
                len = strlen( str );
                if( len > 0 )
                {
                    if( str[len-1] == '\r' || str[len-1] == '\n' )
                    {
                        str[len-1] = 0;
                    }
                    if( len > 1 )
                    {
                        if( str[len-2] == '\r' || str[len-2] == '\n' )
                        {
                            str[len-2] = 0;
                        }
                    }
                }
                SendMessage( hWndListBox, LB_ADDSTRING, 0, (LONG) (LPSTR) str );
                sel = (UINT) SendMessage( hWndListBox, LB_GETCOUNT, 0, 0L );
                if( sel != LB_ERR )
                {
                    SendMessage( hWndListBox, LB_SETCURSEL, sel-1, 0L );
                }
            }
        #endif

    } /* dumpStr */

    /*
     * DXdprintf
     */
    void cdecl DXdprintf( UINT lvl, LPSTR szFormat, ...)
    {
        char    str[256];
        //char  str2[256];

        BOOL    allow = FALSE;
        va_list ap;
        va_start(ap,szFormat);


        if( lDebugLevel < 0 )
        {
            if(  (UINT) -lDebugLevel == lvl )
            {
                allow = TRUE;
            }
        }
        else if( (UINT) lDebugLevel >= lvl )
        {
            allow = TRUE;
        }

        if( allow )
        {
            wsprintf( (LPSTR) str, START_STR );
            //GetModuleFileName(NULL,str2,256);
            //if (strrchr(str2,'\\'))
            //    wsprintf(str+strlen(str),"%12s",strrchr(str2,'\\')+1);
            //strcat(str,":");
#ifdef WIN95
            char szTmp[512];
            char *psz = szTmp;
            strncpy(szTmp, szFormat, 512);

            // %p does not work on Windows95.
            // We look for each "%p" and substitute 'x' for 'p'
            // WARNING:  This code does not handle escape sequences using %p.  
            //           Extra code must be added to deal with that case 
            //          if necessary
            while (psz = strstr(psz, "%p"))  
                *(psz+1) = 'x';

            wvsprintf( str+lstrlen( str ), szTmp, ap);   //(LPVOID)(&szFormat+1) );
#else
            wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );
#endif //WIN95

            lstrcat( (LPSTR) str, END_STR );
            dumpStr( str );
        }

        va_end(ap);
    } /* DXdprintf */


    static void cdecl D3Dprintf( UINT lvl, LPSTR msgType, LPSTR szFormat, va_list ap)
    {
        char    str[256];
        //char  str2[256];

        BOOL    allow = FALSE;

        if( lDebugLevel < 0 )
        {
            if(  (UINT) -lDebugLevel == lvl )
            {
                allow = TRUE;
            }
        }
        else if( (UINT) lDebugLevel >= lvl )
        {
            allow = TRUE;
        }

        if( allow )
        {
            wsprintf( (LPSTR) str, START_STR );
            wsprintf( (LPSTR) str+lstrlen( str ), msgType );
#ifdef WIN95
            char szTmp[512];
            char *psz = szTmp;
            strncpy(szTmp, szFormat, 512);

            // %p does not work on Windows95.
            // We look for each "%p" and substitute 'x' for 'p'
            // WARNING:  This code does not handle escape sequences using %p.  
            //           Extra code must be added to deal with that case 
            //          if necessary
            while (psz = strstr(psz, "%p"))  
                *(psz+1) = 'x';

            wvsprintf( str+lstrlen( str ), szTmp, ap);
#else
            wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );
#endif // WIN95
            lstrcat( (LPSTR) str, END_STR );
            dumpStr( str );
        }

    } /* D3Dprintf */

    void cdecl D3DInfoPrintf( UINT lvl, LPSTR szFormat, ...)
    {
        va_list ap;
        va_start(ap, szFormat);

        D3Dprintf(lvl, "(INFO) :", szFormat, ap);

        va_end(ap);
    }

    void cdecl D3DWarnPrintf( UINT lvl, LPSTR szFormat, ...)
    {
        va_list ap;
        va_start(ap,szFormat);

        D3Dprintf(lvl, "(WARN) :", szFormat, ap);
        va_end(ap);
    }

    void cdecl D3DErrorPrintf( LPSTR szFormat, ...)
    {
        va_list ap;
        va_start(ap,szFormat);

        D3Dprintf(0, "(ERROR) :", szFormat, ap);
        va_end(ap);
    }

    /*
     * DPFInit
     */
    void DPFInit( void )
    {
        lDebugLevel = GetProfileInt( PROF_SECT, "debug", 0 );

    } /* DPFInit */

    #ifdef USE_DDASSERT

    /*
     * NOTE: I don't want to get into error checking for buffer overflows when
     * trying to issue an assertion failure message. So instead I just allocate
     * a buffer that is "bug enough" (I know, I know...)
     */
    #define ASSERT_BUFFER_SIZE   512
    #define ASSERT_BANNER_STRING "************************************************************"
    #define ASSERT_BREAK_SECTION "BreakOnAssert"
    #define ASSERT_BREAK_DEFAULT FALSE
    #define ASSERT_MESSAGE_LEVEL 0

    void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
    {
        char buffer[ASSERT_BUFFER_SIZE];

        /*
         * Build the debug stream message.
         */
        wsprintf( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

        /*
         * Actually issue the message. These messages are considered error level
         * so they all go out at error level priority.
         */
        DXdprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
        DXdprintf( ASSERT_MESSAGE_LEVEL, buffer );
        DXdprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

        /*
         * Should we drop into the debugger?
         */
        if( GetProfileInt( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
        {
            /*
             * Into the debugger we go...
             */
            DEBUG_BREAK();
        }
    }

    #endif /* USE_DDASSERT */

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\misc\dpfa.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.c
 *  Content:    debugging printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-jan-95  craige  initial implementation
 *   03-mar-95  craige  added dprintf2
 *   31-mar-95  craige  add DPFInit to read WIN.INI for [DirectDraw] section;
 *                      added dprintf3
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   18-jun-95  craige  use negative dpf level to display ONLY that level
 *   06-dec-95  jeffno  Changed dprintf to use c-standard variable argument
 *                      list techniques. Also added abs for NT
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96  kipo    added msinternal
 *       20-may-96      andyco  forced ansi entry points on all functions
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "dpf.h"
#include <stdarg.h>


#ifdef DEBUG

#define USE_DDASSERT

#ifndef START_STR
    #define START_STR   "DDRAW: "
#endif
#ifndef PROF_SECT
    #define PROF_SECT   "DirectDraw"
#endif

#define END_STR         "\r\n"

HWND            hWndListBox;
LONG            lDebugLevel = 0;

/*
 * dumpStr
 */
static void dumpStr( LPSTR str )
{
    OutputDebugStringA( str );

    #ifdef DPF_HWND
        if( hWndListBox != NULL )
        {
            if( !IsWindow( hWndListBox ) )
            {
                hWndListBox = NULL;
            }
        }
        if( hWndListBox != NULL )
        {
            UINT        sel;
            int len;
            len = strlen( str );
            if( len > 0 )
            {
                if( str[len-1] == '\r' || str[len-1] == '\n' )
                {
                    str[len-1] = 0;
                }
                if( len > 1 )
                {
                    if( str[len-2] == '\r' || str[len-2] == '\n' )
                    {
                        str[len-2] = 0;
                    }
                }
            }
            SendMessage( hWndListBox, LB_ADDSTRING, 0, (LONG) (LPSTR) str );
            sel = (UINT) SendMessage( hWndListBox, LB_GETCOUNT, 0, 0L );
            if( sel != LB_ERR )
            {
                SendMessage( hWndListBox, LB_SETCURSEL, sel-1, 0L );
            }
        }
    #endif

} /* dumpStr */

/*
 * dprintf
 */
void cdecl dprintf( UINT lvl, LPSTR szFormat, ...)
{
    char        str[256];
    BOOL        allow = FALSE;
    va_list ap;
    va_start(ap,szFormat);


    if( lDebugLevel < 0 )
    {
#ifndef WIN95
        if( (UINT) abs( lDebugLevel ) == lvl )
#else
        if( (UINT) labs( lDebugLevel ) == lvl )
#endif
        {
            allow = TRUE;
        }
    }
    else if( (UINT) lDebugLevel >= lvl )
    {
        allow = TRUE;
    }

    if( allow )
    {
        wsprintfA( (LPSTR) str, START_STR );
        wvsprintfA( str+lstrlenA( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );

        lstrcatA( (LPSTR) str, END_STR );
        dumpStr( str );
    }

    va_end(ap);
} /* dprintf */

/*
 * DPFInit
 */
void DPFInit( void )
{
    lDebugLevel = GetProfileIntA( PROF_SECT, "debug", 0 );

} /* DPFInit */

#ifdef USE_DDASSERT

/*
 * NOTE: I don't want to get into error checking for buffer overflows when
 * trying to issue an assertion failure message. So instead I just allocate
 * a buffer that is "bug enough" (I know, I know...)
 */
#define ASSERT_BUFFER_SIZE   512
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_BREAK_SECTION "BreakOnAssert"
#define ASSERT_BREAK_DEFAULT FALSE
#define ASSERT_MESSAGE_LEVEL 0

void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
{
    char buffer[ASSERT_BUFFER_SIZE];

    /*
     * Build the debug stream message.
     */
    wsprintfA( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

    /*
     * Actually issue the message. These messages are considered error level
     * so they all go out at error level priority.
     */
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
    dprintf( ASSERT_MESSAGE_LEVEL, buffer );
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

    /*
     * Should we drop into the debugger?
     */
    if( GetProfileIntA( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
    {
        /*
         * Into the debugger we go...
         */
        DEBUG_BREAK();
    }
}

#endif /* USE_DDASSERT */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\misc\dpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       dpf.h
 *  Content:    header file for debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-apr-95  craige  initial implementation
 *   06-feb-96  colinmc added simple assertion mechanism for DirectDraw
 *   15-apr-96  kipo    added msinternal
 *@@END_MSINTERNAL
 *
 ***************************************************************************/
#ifdef NEW_DPF
#include "newdpf.h"
#else

    #ifndef __DPF_INCLUDED__
    #define __DPF_INCLUDED__

    #ifdef __cplusplus
    extern "C" {
    #endif

    #ifdef DBG
        #define DEBUG
    #endif

    extern void cdecl DXdprintf( UINT lvl, LPSTR szFormat, ...);
    extern void cdecl D3DInfoPrintf( UINT lvl, LPSTR szFormat, ...);
    extern void cdecl D3DWarnPrintf( UINT lvl, LPSTR szFormat, ...);
    extern void cdecl D3DErrorPrintf( LPSTR szFormat, ...);

    extern void DPFInit( void );
    #ifdef DEBUG
        #define DPF_DECLARE(szName) char * __pszDpfName=#szName":"
        #define DPFINIT()   DPFInit()
        #define DPF         DXdprintf
        #define DPF_ERR(a)  DXdprintf( 0, DPF_MODNAME ": " a );
        extern HWND hWndListBox;
        #if defined( _WIN32 ) && defined(WIN95)
            #define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
        #else
            #define DEBUG_BREAK()       DebugBreak()
        #endif
        #define USE_DDASSERT

        // New for D3D
        #define D3D_ERR       D3DErrorPrintf
        #define D3D_WARN      D3DWarnPrintf
        #define D3D_INFO      D3DInfoPrintf
    #else
        #pragma warning(disable:4002)
        #define DPF_DECLARE(szName)
        #define DPFINIT()
        #define DPF()
        #define DPF_ERR(a)
        #define DEBUG_BREAK()

        #define D3D_ERR(a)
        #define D3D_WARN()
        #define D3D_INFO()
    #endif

    #if defined(DEBUG) && defined(USE_DDASSERT)

    extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);

    #define DDASSERT(condition) if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)

    #else  /* DEBUG && USE_DDASSERT */

    #define DDASSERT(condition)

    #endif /* DEBUG && USE_DDASSERT */

    #ifdef _WIN32

    #ifdef DEBUG
        __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
        __inline DWORD perf_clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

        #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
        #define TIMEZERO(t)   t ## T = 0, t ## N = 0
        #define TIMESTART(t)  t ## T -= perf_clock(), t ## N ++
        #define TIMESTOP(t)   t ## T += perf_clock()
        #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
        #define TIMEOUT(t)    if (t ## N) DPF(1, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
    #else
        #define TIMEVAR(t)
        #define TIMEZERO(t)
        #define TIMESTART(t)
        #define TIMESTOP(t)
        #define TIMEFMT(t)
        #define TIMEOUT(t)
    #endif

    #endif
    #ifdef __cplusplus
    }
    #endif

    #endif
#endif //use new dpf
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\misc\memalloc.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.h
 *  Content:	header file for memory allocation
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   22-may-95	craige	added MemAlloc16
 *   12-jun-95	craige	added MemReAlloc
 *   26-jun-95  craige  added GetPtr16
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *
 ***************************************************************************/
#ifndef __MEMALLOC_INCLUDED__
#define __MEMALLOC_INCLUDED__

#ifdef __cplusplus
extern "C" {
#endif
extern void MemFini( void );
extern void MemState( void );
extern BOOL MemInit( void );
extern void MemFree( LPVOID lptr );
extern UINT __cdecl MemSize( LPVOID lptr );
extern LPVOID __cdecl MemAlloc( UINT size );
extern LPVOID __cdecl MemReAlloc( LPVOID ptr, UINT size );
extern LPVOID __cdecl MemAlloc16( UINT size, DWORD FAR *p16 );
extern LPVOID GetPtr16( LPVOID ptr );

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\misc\newdpf.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.c
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#if defined(DEBUG) || defined(DBG)

#ifdef IS_16
    #define OUTPUTDEBUGSTRING OutputDebugString
    #define GETPROFILESTRING GetProfileString
    #define GETPROFILEINT GetProfileInt
    #define WSPRINTF wsprintf
    #define WVSPRINTF wvsprintf
    #define LSTRLEN lstrlen
#else
    #define OUTPUTDEBUGSTRING OutputDebugStringA
    #define GETPROFILESTRING GetProfileStringA
    #define GETPROFILEINT GetProfileIntA
    #define WSPRINTF wsprintfA
    #define WVSPRINTF wvsprintfA
    #define LSTRLEN lstrlenA
#endif

#include "dpf.h"

#undef DEBUG_TOPIC
#define DEBUG_TOPIC(flag,name) {#flag,name,TRUE},

static
    struct {
        char cFlag[4];
        char cName[64];
        BOOL bOn;
} DebugTopics[] = {
    {"","Filler",FALSE},
    {"A","API Usage",TRUE},
#include "DBGTOPIC.H"
    {"","End",FALSE}
};

#ifndef PROF_SECT
#define PROF_SECT	"Direct3D"
#endif
#ifndef PROF_SECT_D3D
    #define PROF_SECT_D3D	"Direct3D"
#endif
#ifndef START_STR_D3D
#define START_STR_D3D       "Direct3D8: "
#endif
#define END_STR             "\r\n"


#undef DPF_MODULE_NAME
#define DPF_MODULE_NAME "Direct3D8: "

static DWORD bDetailOn = 1;

static BOOL bInited=FALSE;
static BOOL bAllowMisc=TRUE;
static bBreakOnAsserts=FALSE;
static bPrintLineNumbers=FALSE;
static bPrintFileNames=FALSE;
static bPrintExecutableName=FALSE;
static bPrintTID=FALSE;
static bPrintPID=FALSE;
static bIndentOnMessageLevel=FALSE;
static bPrintTopicsAndLevels=FALSE;
static bPrintModuleName=TRUE;
static bPrintFunctionName=FALSE;
static bRespectColumns=FALSE;
static bPrintAPIStats=FALSE;
static bPrintAllTopics=TRUE;
static bAdvancedDPFs=FALSE;

static DWORD dwFileLineTID=0;
static char cFile[100];
static char cFnName[100];
static DWORD dwLineNo;
static bMute=FALSE;

// Debug level for D3D
LONG                lD3dDebugLevel = 0;

DPF_PROC_STATS ProcStats[MAX_PROC_ORDINAL];
#ifdef cplusplus
	extern "C" {
#endif

void mystrncpy(char * to,char * from,int n)
{
    for(;n;n--)
        *(to++)=*(from++);
}

char * mystrrchr(char * in,char c)
{
    char * last=0;
    while (*in)
    {
        if (*in == c)
            last = in;
        in++;
    }
    return last;
}

char Junk[]="DPF_MODNAME undef'd";
char * DPF_MODNAME = Junk;

int DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber, LPSTR szFnName)
{
    if (!(bPrintFileNames||bPrintLineNumbers||bPrintFunctionName))
    {
        return 1;
    }
#ifdef WIN32
    dwFileLineTID = GetCurrentThreadId();
#endif
    mystrncpy (cFile,szFile,sizeof(cFile));
    mystrncpy (cFnName,szFnName,sizeof(cFnName));
    dwLineNo = dwLineNumber;
    return 1;
}

static void dumpStr( LPSTR str )
{
    /*
     * Have to warm the string, since OutputDebugString is buried
     * deep enough that it won't page the string in before reading it.
     */
    int i=0;
    if (str)
        while(str[i])
            i++;
    OUTPUTDEBUGSTRING( str );
    OUTPUTDEBUGSTRING("\n");
}

void DebugPrintfInit(void)
{
    signed int lDebugLevel;
    int i;
    char cTopics[100];

    lD3dDebugLevel = GetProfileInt( PROF_SECT_D3D, "debug", 0 );

    bDetailOn=1;

    for (i=0;i<LAST_TOPIC;i++)
        DebugTopics[i].bOn=FALSE;

    //ZeroMemory(ProcStats,sizeof(ProcStats));

    GETPROFILESTRING( "DirectX", DPF_CONTROL_LINE, "DefaultTopics", cTopics, sizeof(cTopics) );
    if (!strcmp(cTopics,"DefaultTopics"))
    {
        DebugSetTopicsAndLevels("");
        bAllowMisc=TRUE;
        bPrintAllTopics=TRUE;
        lDebugLevel = (signed int) GETPROFILEINT( PROF_SECT, "debug", 0 );
        if (lDebugLevel <0)
        {
            if (lDebugLevel < -9)
                lDebugLevel=-9;

            bDetailOn |= (1<<(-lDebugLevel));
        }
        else
        {
            for (i=0;i<= (lDebugLevel<10?lDebugLevel:10);i++)
                bDetailOn |= 1<<i;
        }
    }
    else
    {
        bAdvancedDPFs=TRUE;
        DebugSetTopicsAndLevels(cTopics);
        if (!strcmp(cTopics,"?") && !bInited)
        {
            dumpStr("--------------" DPF_MODULE_NAME " Debug Output Control -------------");
            dumpStr("Each character on the control line controls a topic, a detail");
            dumpStr("level or an extra info. E.g. 0-36A@ means print detail levels 0");
            dumpStr("through 3 and 6 for topic A with source file name and line numbers.");
            dumpStr("The extra info control characters are:");
            dumpStr("   !: Break on asserts");
            dumpStr("   ^: Print TID of calling thread");
            dumpStr("   #: Print PID of calling process");
            dumpStr("   >: Indent on message detail levels");
            dumpStr("   &: Print the topic and detail level of each message");
            dumpStr("   =: Print function name");
            dumpStr("   +: Print all topics, including topic-less");
            dumpStr("   / or -: do not allow topic-less messages");
            dumpStr("   @ or $: Print source filename and line number of DPF");
            dumpStr("Topics for this module are:");
            for(i=0;strcmp(DebugTopics[i].cName,"End");i++)
            {
                OUTPUTDEBUGSTRING("   ");
                OUTPUTDEBUGSTRING(DebugTopics[i].cFlag);
                OUTPUTDEBUGSTRING(": ");
                dumpStr(DebugTopics[i].cName);
            }
            dumpStr("Tip: Use 0-3A to get debug info about API calls");
        }
    }
    bInited=TRUE;
}


/*
 *
 * The full output can be:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn) Messagemessagemessage
 * or, if indentation turned on:
 * Module:(Executable,TxNNNN,PxNN):FunctionName:"file.c",#nnn(AAnn)        Messagemessagemessage
 */
int DebugPrintf(DWORD dwDetail, ...)
{
#define MSGBUFFERSIZE  1000
    BOOL        bAllowed=FALSE;
    BOOL        bMiscMessage=TRUE;
    char        cMsg[MSGBUFFERSIZE];
    char        cTopics[20];
    DWORD_PTR   arg;
    LPSTR       szFormat;
    int         i;
#ifdef WIN95
    char        szTemp[MSGBUFFERSIZE];    
    char       *psz = NULL;
#endif

    va_list ap;


    if (!bInited)
        DebugPrintfInit();

    //error checking:
    if (dwDetail >= 10)
        return 1;

    if ( (bDetailOn & (1<<dwDetail)) == 0 )
        return 1;

    if (bMute)
        return 1;
    va_start(ap,dwDetail);
    WSPRINTF(cTopics,"%d",dwDetail);

    //Pull out which topics this DPF refers to
    while ( (arg = va_arg(ap,DWORD_PTR)) <256 )
    {
        if (arg>0 && arg < LAST_TOPIC)
        {
            bMiscMessage=FALSE;
            if (DebugTopics[arg].bOn)
                bAllowed = TRUE;
        }
    }

    //if this message has no topics, then it's a misc message.
    //we turn them on only if allowed (i.e. "-" is not in the enable string).
    //And level zero messages are always allowed
    if (bMiscMessage)
    {
        if (bAllowMisc || dwDetail == 0)
            bAllowed=TRUE;
    }
    else
    {
        //topic-ed message is only allowed if the advanced DPF line is set in [DirectX]
        if (!bAdvancedDPFs)
            bAllowed=FALSE;
    }

    //Advanced DPFs have the option ("+") to print every topic
    if (bAdvancedDPFs)
    {
        if ( bPrintAllTopics )
            bAllowed=TRUE;
    }

    if (!bAllowed)
        return FALSE;

    szFormat = (LPSTR) arg;

    cMsg[0]=0;

    /*
     * Add the module name first
     */

    if (bPrintModuleName)
    {
        WSPRINTF( cMsg+strlen(cMsg),DPF_MODULE_NAME);
    }

    if (dwDetail==0)
    {
        WSPRINTF( cMsg+strlen(cMsg),"(ERROR) :" );
    }
    if (dwDetail==1)
    {
        WSPRINTF( cMsg+strlen(cMsg),"(WARN) :" );
    }
    if (dwDetail==2)
    {
        WSPRINTF( cMsg+strlen(cMsg),"(INFO) :" );
    }


    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"(");

#ifdef WIN32
#if 0
    /*
     * deleted due to RIP in GetModuleFilename on debug windows when win16 lock held
     */
    if (bPrintExecutableName)
    {
        GetModuleFileName(NULL,str,256);
        if (mystrrchr(str,'\\'))
            WSPRINTF(cMsg+strlen(cMsg),"%12s",mystrrchr(str,'\\')+1);
    }
#endif
    if (bPrintPID)
    {
        if (bPrintExecutableName)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Px%02x",GetCurrentProcessId());
    }

    if (bPrintTID)
    {
        if (bPrintExecutableName || bPrintPID)
            strcat(cMsg,",");
        WSPRINTF( cMsg+strlen(cMsg),"Tx%04x",GetCurrentThreadId());
    }

    if (bPrintExecutableName || bPrintTID || bPrintPID)
        WSPRINTF( cMsg+strlen(cMsg),"):");
#endif

    if (bPrintFunctionName)
    {
        WSPRINTF( cMsg+strlen(cMsg),cFnName);
    }

    if (bPrintFileNames || bPrintLineNumbers)
    {
        if (mystrrchr(cFile,'\\'))
            WSPRINTF( cMsg+strlen(cMsg),":%12s",mystrrchr(cFile,'\\')+1 );
        else
            WSPRINTF( cMsg+strlen(cMsg),":%12s",cFile);
        WSPRINTF( cMsg+strlen(cMsg),"@%d",dwLineNo);
    }

    if (bPrintTopicsAndLevels)
    {
        WSPRINTF( cMsg+strlen(cMsg),"(%3s)",cTopics);
    }

    if (cMsg[strlen(cMsg)-1] != ':')
        WSPRINTF( cMsg+strlen(cMsg),":");

    if (bIndentOnMessageLevel)
    {
        for(i=0;(DWORD)i<dwDetail;i++)
            strcat(cMsg," ");
    }

    //  7/07/2000(RichGr) - IA64:  The %p format specifier that can handle either a 32-bit
    //     or a 64-bit pointer doesn't work on Win95 or Win98 - it's not recognized.  So it
    //     needs to be replaced in Win9x builds.
#ifdef WIN95
    strcpy(szTemp, szFormat);           // Copy to a local string that we can modify.

    //////////////////////////////////////////////////////////////////////////////////////////////
    //WARNING:  This code does not handle escape sequences using %p.  Extra code must be added to 
    //          deal with that case if necessary
    //////////////////////////////////////////////////////////////////////////////////////////////

    while (psz = strstr(szTemp, "%p"))  // Look for each "%p".
        *(psz+1) = 'x';                 // Substitute 'x' for 'p'.  Don't try to expand the string.

    WVSPRINTF( cMsg+LSTRLEN( cMsg ), szTemp, ap);       // Use the local, modified string.
#else
    WVSPRINTF( cMsg+LSTRLEN( cMsg ), szFormat, ap);     // Standard code for Win2K/Whistler/IA64.
#endif

    if (bAllowed)
        dumpStr( cMsg );

    va_end(ap);
    return 1;

}

void DebugSetMute(BOOL bMuteFlag)
{
    bMute=bMuteFlag;
}

void DebugEnterAPI(char *pFunctionName , LPDWORD pIface)
{
    DebugPrintf(2,A,"%08x->%s",pIface,pFunctionName);
}

void DebugSetTopicsAndLevels(char * cTopics)
{
    int i;
    int j;
    bAllowMisc=TRUE;
    bBreakOnAsserts=FALSE;
    bPrintLineNumbers=FALSE;
    bPrintFileNames=FALSE;
    bPrintExecutableName=FALSE;
    bPrintTID=FALSE;
    bPrintPID=FALSE;
    bIndentOnMessageLevel=FALSE;
    bPrintTopicsAndLevels=FALSE;
    bPrintFunctionName=FALSE;
    bPrintAPIStats=FALSE;
    bPrintAllTopics=FALSE;
    bDetailOn=1;    /* always print detail level 0*/


    for (i=0;(DWORD)i<strlen(cTopics);i++)
    {
        switch (cTopics[i])
        {
        case '/':
        case '-':
            bAllowMisc=FALSE;
            break;
        case '!':
            bBreakOnAsserts=TRUE;
            break;
        case '@':
            bPrintLineNumbers=TRUE;
            break;
        case '$':
            bPrintFileNames=TRUE;
            break;
#if 0
            /*
             * Currently deleted because GetModuleFilename causes a RIP on debug windows when the win16
             * lock is held.
             */
        case '?':
            bPrintExecutableName=TRUE;
            break;
#endif
        case '^':
            bPrintTID=TRUE;
            break;
        case '#':
            bPrintPID=TRUE;
            break;
        case '>':
            bIndentOnMessageLevel=TRUE;
            break;
        case '&':
            bPrintTopicsAndLevels=TRUE;
            break;
        case '=':
            bPrintFunctionName=TRUE;
            break;
        case '%':
            bPrintAPIStats=TRUE;
            break;
        case '+':
            bPrintAllTopics=TRUE;
            break;
        default:
            if (cTopics[i]>='0' && cTopics[i]<='9')
            {
                if (cTopics[i+1]=='-')
                {
                    if (cTopics[i+2]>='0' && cTopics[i+2]<='9')
                    {
                        for(j=cTopics[i]-'0';j<=cTopics[i+2]-'0';j++)
                            bDetailOn |= 1<<j;
                        i+=2;
                    }
                }
                else
                    bDetailOn |= 1<<(cTopics[i]-'0');
            }
            else
            {
                for(j=0;j<LAST_TOPIC;j++)
                    if (cTopics[i]==DebugTopics[j].cFlag[0])
                        DebugTopics[j].bOn=TRUE;
            }
        } //end switch
    }
}


/*
 * NOTE: I don't want to get into error checking for buffer overflows when
 * trying to issue an assertion failure message. So instead I just allocate
 * a buffer that is "bug enough" (I know, I know...)
 */
#define ASSERT_BUFFER_SIZE   512
#define ASSERT_BANNER_STRING "************************************************************"
#define ASSERT_BREAK_SECTION "BreakOnAssert"
#define ASSERT_BREAK_DEFAULT FALSE
#define ASSERT_MESSAGE_LEVEL 0

void _DDAssert( LPCSTR szFile, int nLine, LPCSTR szCondition )
{
    char buffer[ASSERT_BUFFER_SIZE];

    /*
     * Build the debug stream message.
     */
    WSPRINTF( buffer, "ASSERTION FAILED! File %s Line %d: %s", szFile, nLine, szCondition );

    /*
     * Actually issue the message. These messages are considered error level
     * so they all go out at error level priority.
     */
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );
    dprintf( ASSERT_MESSAGE_LEVEL, buffer );
    dprintf( ASSERT_MESSAGE_LEVEL, ASSERT_BANNER_STRING );

    /*
     * Should we drop into the debugger?
     */
    if( bBreakOnAsserts || GETPROFILEINT( PROF_SECT, ASSERT_BREAK_SECTION, ASSERT_BREAK_DEFAULT ) )
    {
	/*
	 * Into the debugger we go...
	 */
	DEBUG_BREAK();
    }
}

static void cdecl 
D3Dprintf( UINT lvl, LPSTR msgType, LPSTR szFormat, va_list ap)
{
    char    str[256];
    //char  str2[256];

    BOOL    allow = FALSE;

    if (bMute)
        return;

    if( lD3dDebugLevel < 0 )
    {
        if(  (UINT) -lD3dDebugLevel == lvl )
        {
            allow = TRUE;
        }
    }
    else if( (UINT) lD3dDebugLevel >= lvl )
    {
        allow = TRUE;
    }

    if( allow )
    {
        wsprintf( (LPSTR) str, START_STR_D3D );
        wsprintf( (LPSTR) str+lstrlen( str ), msgType );

#ifdef WIN95
        {
            char szTmp[512];
            char *psz = szTmp;
            strncpy(szTmp, szFormat, 512);

            // %p does not work on Windows95.
            // We look for each "%p" and substitute 'x' for 'p'
            // WARNING:  This code does not handle escape sequences using %p.  
            //           Extra code must be added to deal with that case 
            //          if necessary
            while (psz = strstr(psz, "%p"))  
                *(psz+1) = 'x';

            wvsprintf( str+lstrlen( str ), szTmp, ap); 
        }
#else
        wvsprintf( str+lstrlen( str ), szFormat, ap);   //(LPVOID)(&szFormat+1) );
#endif // WIN95

        lstrcat( (LPSTR) str, END_STR );
        dumpStr( str );
    }

} /* D3Dprintf */

void cdecl 
D3DInfoPrintf( UINT lvl, LPSTR szFormat, ...)
{
    va_list ap;
    va_start(ap, szFormat);

    D3Dprintf(lvl, "(INFO) :", szFormat, ap);

    va_end(ap);
}

void cdecl 
D3DWarnPrintf( UINT lvl, LPSTR szFormat, ...)
{
    va_list ap;
    va_start(ap,szFormat);

    D3Dprintf(lvl, "(WARN) :", szFormat, ap);
    va_end(ap);
}

void cdecl 
D3DErrorPrintf( LPSTR szFormat, ...)
{
    va_list ap;
    va_start(ap,szFormat);

    D3Dprintf(0, "(ERROR) :", szFormat, ap);
    va_end(ap);
}

#ifdef cplusplus
}
#endif

#else // !debug

void DebugSetMute(BOOL bMuteFlag)
{
}

#endif //defined debug
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\misc\memalloc.c ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       memalloc.c
 *  Content:    allocates memory
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   20-jan-95  craige  initial implementation
 *   27-feb-95  craige  don't call HeapFree with NULL, it is a huge time sink
 *   29-mar-95  craige  memory tracker
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  made stand-alone
 *   22-may-95  craige  added MemAlloc16
 *   12-jun-95  craige  added MemReAlloc
 *   18-jun-95  craige  deadlock joy: don't take DLL csect here
 *   26-jul-95  toddla  added MemSize and fixed MemReAlloc
 *   29-feb-96  colinmc added optional debugging code to blat a a specific
 *                      bit pattern over freed memory
 *   08-oct-96	ketand	change debug message to give a total for the terminating
 *			process
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include "memalloc.h"
#include "dpf.h"

#define FREE_MEMORY_PATTERN 0xDEADBEEFUL
#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

#ifdef WIN95
    #ifdef NOSHARED
	#define HEAP_SHARED     0
    #else
	#define HEAP_SHARED     0x04000000      // put heap in shared memory
    #endif
#else
    #define HEAP_SHARED         0
#endif

static HANDLE   hHeap = NULL;           // handle to shared heap for this DLL

/*
 * memory track struct and list
 */
#ifdef DEBUG
#define MCOOKIE 0xbaaabaaa
#define MCOOKIE_FREE    0xbabababa
typedef struct _MEMTRACK
{
    DWORD               dwCookie;
    struct _MEMTRACK    FAR *lpNext;
    struct _MEMTRACK    FAR *lpPrev;
    DWORD               dwSize;
    LPVOID              lpAddr;
    DWORD               dwPid;
    LONG                lAllocID;
} MEMTRACK, FAR *LPMEMTRACK;

static LPMEMTRACK       lpHead;
static LPMEMTRACK       lpTail;
static LONG             lAllocCount;
static LONG             lAllocID;
static LONG             lBreakOnAllocID;
static LONG             lBreakOnMemLeak;

#if defined(_X86_)
	#define MyGetReturnAddress(first) (LPVOID) *(DWORD *)(((LPBYTE)&first)-4)
#else
	#define MyGetReturnAddress(first) _ReturnAddress()
#endif

#define DEBUG_TRACK( lptr, first ) \
    if( lptr == NULL ) \
    { \
	DPF( 1, "Alloc of size %u FAILED!", size ); \
    } \
    else \
    { \
	LPMEMTRACK      pmt; \
	pmt = (LPMEMTRACK) lptr; \
	pmt->dwSize = size - sizeof( MEMTRACK ); \
	pmt->dwCookie = MCOOKIE; \
	pmt->lpAddr = MyGetReturnAddress(first); \
	pmt->dwPid = GetCurrentProcessId(); \
    pmt->lAllocID = lAllocID; \
	if( lpHead == NULL ) \
	{ \
	    lpHead = lpTail = pmt; \
	} \
	else \
	{ \
	    lpTail->lpNext = pmt; \
	    pmt->lpPrev = lpTail; \
	    lpTail = pmt; \
	} \
	lptr = (LPVOID) (((LPBYTE) lptr) + sizeof( MEMTRACK )); \
	lAllocCount++; \
    if( lAllocID == lBreakOnAllocID ) \
    { \
	DebugBreak(); \
    } \
	lAllocID++; \
    }

#define DEBUG_TRACK_UPDATE_SIZE( s ) s += sizeof( MEMTRACK );

#else

#define DEBUG_TRACK( lptr, first )
#define DEBUG_TRACK_UPDATE_SIZE( size )

#endif

#ifndef  __DXGUSEALLOC
#if defined( WIN95 ) && defined( WANT_MEM16 )

extern DWORD _stdcall MapLS( LPVOID ); // flat -> 16:16
extern void _stdcall UnMapLS( DWORD ); // unmap 16:16

typedef struct SELLIST {
    struct SELLIST      *link;
    LPBYTE              base;
    WORD                sel;
} SELLIST, *LPSELLIST;

static LPSELLIST        lpSelList;

/*
 * MemAlloc16
 *
 * Allocate some memory, and return a 16:16 pointer to that memory
 *
 * NOTE: ASSUMES WE ARE IN THE DLL CRITICAL SECTION!
 */
LPVOID __cdecl MemAlloc16( UINT size, LPDWORD p16 )
{
    LPBYTE              lptr;
    LPSELLIST           psel;
    DWORD               diff;

    DEBUG_TRACK_UPDATE_SIZE( size );
    lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    DEBUG_TRACK( lptr, size );
    if( lptr == NULL )
    {
	return NULL;
    }

    /*
     * try to find an existing selector that maps this area
     */
    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff+size < 0xf000 )
	    {
		*p16 = ((DWORD)psel->sel << 16l) + diff;
		return lptr;
	    }
	}
	psel = psel->link;
    }

    /*
     * no selector found, create a new one
     */
    psel = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, sizeof( SELLIST ));
    if( psel == NULL )
    {
	return NULL;
    }
    psel->sel = HIWORD( MapLS( lptr ) );
    DPF( 2, "$$$$$$ New selector allocated: %04x", psel->sel );
    psel->base = lptr;
    psel->link = lpSelList;
    lpSelList = psel;
    *p16 = ((DWORD) psel->sel) << 16l;

    return lptr;

} /* MemAlloc16 */

/*
 * GetPtr16
 */
LPVOID GetPtr16( LPVOID ptr )
{
    DWORD       diff;
    DWORD       p16;
    LPSELLIST   psel;
    LPBYTE      lptr;

    lptr = ptr;

    psel = lpSelList;
    while( psel != NULL )
    {
	if( psel->base <= lptr )
	{
	    diff = lptr - psel->base;
	    if( diff <= 0xf000 )
	    {
		p16 = ((DWORD)psel->sel << 16l) + diff;
		return (LPVOID) p16;
	    }
	}
	psel = psel->link;
    }
    DPF( 1, "ERROR: NO 16:16 PTR for %08lx", lptr );
    return NULL;

} /* GetPtr16 */

/*
 * freeSelectors
 */
static void freeSelectors( void )
{
    LPSELLIST           psel;
    LPSELLIST           link;

    psel = lpSelList;
    while( psel != NULL )
    {
	link = psel->link;
	DPF( 2, "$$$$$$ Freeing selector %04x", psel->sel );
	UnMapLS( ((DWORD)psel->sel) << 16l );
	HeapFree( hHeap, 0, psel );
	psel = link;
    }
    lpSelList = NULL;

} /* freeSelectors */
#endif
#endif  //!__DXGUSEALLOC

/*
 * MemAlloc - allocate memory from our global pool
 */
LPVOID __cdecl MemAlloc( UINT size )
{
#ifdef __USECRTMALLOC
    return calloc( size, 1 );
#else /*__USECRTMALLOC */
    LPBYTE lptr;

    DEBUG_TRACK_UPDATE_SIZE( size );
    #ifdef  __DXGUSEALLOC
        #if DBG
            lptr = calloc( size, 1 );
        #else
            lptr = LocalAlloc( LPTR, size );
        #endif  //DBG
    #else 
        lptr = HeapAlloc( hHeap, HEAP_ZERO_MEMORY, size );
    #endif  //__DXGUSEALLOC
    DEBUG_TRACK( lptr, size );

    return lptr;
#endif //__USECRTMALLOC

} /* MemAlloc */

#ifndef  __DXGUSEALLOC
/*
 * MemSize - return size of object
 */
UINT __cdecl MemSize( LPVOID lptr )
{
#ifdef DEBUG
    if (lptr)
    {
	LPMEMTRACK  pmt;
	lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	pmt = lptr;
	return pmt->dwSize;
    }
#endif
    return (UINT)HeapSize(hHeap, 0, lptr);
} /* MemSize */
#endif  //!__DXGUSEALLOC

/*
 * MemFree - free memory from our global pool
 */
void MemFree( LPVOID lptr )
{
#ifdef __USECRTMALLOC
    free( lptr );
#else /*__USECRTMALLOC */
    if( lptr != NULL )
    {
	#ifdef DEBUG
	{
	    /*
	     * get real pointer and unlink from chain
	     */
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;

	    if( pmt->dwCookie == MCOOKIE_FREE )
	    {
		DPF( 1, "FREE OF FREED MEMORY! ptr=%08lx", pmt );
		DPF( 1, "%08lx: lAllocID=%ld dwSize=%08lx, lpAddr=%08lx", 
            pmt, pmt->lAllocID, pmt->dwSize, pmt->lpAddr );
	    }
	    else if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID FREE! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: lAllocID=%ld dwSize=%08lx, lpAddr=%08lx", 
            pmt, pmt->lAllocID, pmt->dwSize, pmt->lpAddr );
	    }
	    else
	    {
		pmt->dwCookie = MCOOKIE_FREE;
		if( pmt == lpHead && pmt == lpTail )
		{
		    lpHead = NULL;
		    lpTail = NULL;
		}
		else if( pmt == lpHead )
		{
		    lpHead = pmt->lpNext;
		    lpHead->lpPrev = NULL;
		}
		else if( pmt == lpTail )
		{
		    lpTail = pmt->lpPrev;
		    lpTail->lpNext = NULL;
		}
		else
		{
		    pmt->lpPrev->lpNext = pmt->lpNext;
		    pmt->lpNext->lpPrev = pmt->lpPrev;
		}

		#ifndef NO_FILL_ON_MEMFREE
		{
		    LPDWORD lpMem;
		    DWORD   dwPat;
		    DWORD   dwSize;

		    dwSize = pmt->dwSize;
		    lpMem = (LPDWORD)( (LPBYTE)lptr + sizeof( MEMTRACK ) );
		    while (dwSize >= sizeof(DWORD))
		    {
			*lpMem++ = FREE_MEMORY_PATTERN;
			dwSize -= sizeof(DWORD);
		    }
		    if (dwSize != 0UL)
		    {
			dwPat = FREE_MEMORY_PATTERN;
			memcpy(lpMem, &dwPat, dwSize);
		    }
		}
		#endif /* !NO_FILL_ON_MEMFREE */
	    }
	    lAllocCount--;
	    if( lAllocCount < 0 )
	    {
		DPF( 1, "Too Many Frees!\n" );
	    }
	}
	#endif

    #ifdef  __DXGUSEALLOC
        #if DBG
            free( lptr );
        #else
            LocalFree( lptr );
        #endif  //DBG
    #else 
	HeapFree( hHeap, 0, lptr );
    #endif  // __DXGUSEALLOC

    }
#endif /*__USECRTMALLOC */
} /* MemFree */

/*
 * MemReAlloc
 */
LPVOID __cdecl MemReAlloc( LPVOID lptr, UINT size )
{
#ifdef __USECRTMALLOC
    return realloc( lptr, size );
#else /* __USECRTMALLOC */
    LPVOID new;

    DEBUG_TRACK_UPDATE_SIZE( size );
    #ifdef DEBUG
	if( lptr != NULL )
	{
	    LPMEMTRACK  pmt;
	    lptr = (LPVOID) (((LPBYTE)lptr) - sizeof( MEMTRACK ));
	    pmt = lptr;
	    if( pmt->dwCookie != MCOOKIE )
	    {
		DPF( 1, "INVALID REALLOC! cookie=%08lx, ptr = %08lx", pmt->dwCookie, lptr );
		DPF( 1, "%08lx: lAllocID=%ld dwSize=%08lx, lpAddr=%08lx", 
            pmt, pmt->lAllocID, pmt->dwSize, pmt->lpAddr );
	    }
	}
    #endif

    #ifdef  __DXGUSEALLOC
        #if DBG
            new = realloc( lptr, size );
        #else //DBG
            new = LocalReAlloc( lptr, size, LMEM_MOVEABLE|LMEM_ZEROINIT );
        #endif  //DBG
    #else //__DXGUSEALLOC
    new = HeapReAlloc( hHeap, HEAP_ZERO_MEMORY, lptr, size );
    #endif  //__DXGUSEALLOC

    #ifdef DEBUG
    if (new != NULL)
    {
	LPMEMTRACK pmt = new;

	pmt->dwSize = size - sizeof( MEMTRACK );

	if( lptr == (LPVOID)lpHead )
	    lpHead = pmt;
	else
	    pmt->lpPrev->lpNext = pmt;

	if( lptr == (LPVOID)lpTail )
	    lpTail = pmt;
	else
	    pmt->lpNext->lpPrev = pmt;

	new = (LPVOID) (((LPBYTE)new) + sizeof(MEMTRACK));
    }
    #endif
    return new;
#endif /* __USECRTMALLOC */
} /* MemReAlloc */

/*
 * MemInit - initialize the heap manager
 */
BOOL MemInit( void )
{
    HKEY hKey = (HKEY) NULL;
#ifdef __USECRTMALLOC
    #include <crtdbg.h>
    int tmp = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);
    tmp |= _CRTDBG_LEAK_CHECK_DF | _CRTDBG_ALLOC_MEM_DF;
    _CrtSetDbgFlag(tmp);
#else /* __USECRTMALLOC */
#ifndef  __DXGUSEALLOC
    if( hHeap == NULL )
    {
	hHeap = HeapCreate( HEAP_SHARED, 0x2000, 0 );
	if( hHeap == NULL )
	{
	    return FALSE;
	}
    }
#endif  //!__DXGUSEALLOC
    #ifdef DEBUG
	lAllocCount = 0;
	lAllocID = 1;
    lBreakOnAllocID = 0;
    lBreakOnMemLeak = 0;
	lpHead = NULL;
	lpTail = NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
    {
        LONG result;
        DWORD dwType = REG_DWORD;
        DWORD dwSize = 4;
        DWORD value = 0;
        result =  RegQueryValueEx(hKey, "BreakOnAllocID", NULL, &dwType,
                                  (LPBYTE)(&value), &dwSize);
        if (result == ERROR_SUCCESS && dwType == REG_DWORD)
        {
            lBreakOnAllocID = value;
        }
        result =  RegQueryValueEx(hKey, "BreakOnMemLeak", NULL, &dwType,
                                  (LPBYTE)(&value), &dwSize);
        RegCloseKey(hKey);
        if (result == ERROR_SUCCESS && dwType == REG_DWORD)
        {
            lBreakOnMemLeak = value;
        }
    }
    #endif
#endif /* __USECRTMALLOC */
    return TRUE;
} /* MemInit */

#ifdef DEBUG
/*
 * MemState - finished with our heap manager
 */
void MemState( void )
{
    DPF( 6, "MemState" );
    #ifdef WIN95
    // Note: There is a well known leak of 8 bytes in Win9x, this is to discount it.
    if( lAllocCount > 1 )
    #else
    if( lAllocCount != 0 )
    #endif
    {
	DPF( 0, "Memory still allocated!  Alloc count = %ld", lAllocCount );
	DPF( 0, "Current Process (pid) = %08lx", GetCurrentProcessId() );
    if( lBreakOnMemLeak != 0 )
    {
        DebugBreak();
    }
    }
    if( lpHead != NULL )
    {
	LPMEMTRACK      pmt;
	DWORD		dwTotal = 0;
	DWORD		pidCurrent = GetCurrentProcessId();
	pmt = lpHead;
	while( pmt != NULL )
	{
	    if( pidCurrent == pmt->dwPid )
		dwTotal += pmt->dwSize;
	    DPF( 0, "Memory Address: %08lx lAllocID=%ld dwSize=%08lx, ReturnAddr=%08lx (pid=%08lx)", 
                (BYTE*)pmt + sizeof(MEMTRACK), // give the address that is returned 
                pmt->lAllocID, 
                pmt->dwSize, 
                pmt->lpAddr, 
                pmt->dwPid );
	    pmt = pmt->lpNext;
	}
	DPF ( 0, "Total Memory Unfreed From Current Process = %ld bytes", dwTotal );
    }
} /* MemState */
#endif

/*
 * MemFini - finished with our heap manager
 */
void MemFini( void )
{
#ifdef __USECRTMALLOC
#else /* __USECRTMALLOC */
    DPF( 2, "MemFini!" );
    #ifdef DEBUG
	MemState();
    #endif
#ifndef  __DXGUSEALLOC
    #if defined( WIN95 ) && defined( WANT_MEM16 )
	freeSelectors();
    #endif
    if( hHeap )
    {
	HeapDestroy( hHeap );
	hHeap = NULL;
    }
#endif  //!__DXGUSEALLOC
#endif /* __USECRTMALLOC */
} /* MemFini */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\misc\lists.h ===
/* Copyright (c) 1997  Microsoft Corporation */
/* See the .C test code at the end of this file for examples of how to use
   this stuff.
*/
#ifndef	_LISTS_H
#define	_LISTS_H

#if __cplusplus
extern "C" {
#endif

#define LIST_ROOT(name, type) struct name {struct type *Root;}

#define LIST_MEMBER(type) struct { struct type **Prev; struct type *Next;}
/* Note!  Prev is the ADDRESS of the previous next element ptr */

#define LIST_INSERT_ROOT(root,element,field)\
{   if(((element)->field.Next = (root)->Root) != 0)\
	(root)->Root->field.Prev = &(element)->field.Next;\
    (root)->Root = (element);\
    (element)->field.Prev = &(root)->Root;\
}

#define LIST_DELETE(element,field)\
{\
    if((element)->field.Next)\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define	LIST_INITIALIZE(root)\
{\
    (root)->Root = 0;\
}

#define LIST_INITIALIZE_MEMBER(element,field)\
{   (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define LIST_ORPHAN_MEMBER(element,field) (!((element)->field.Prev))

#define LIST_FIRST(root) (root)->Root
#define LIST_NEXT(element,field) (element)->field.Next



#define	TAIL_QUEUE_INITIALIZE(root)\
{\
    (root)->First = NULL;\
    (root)->Last = &(root)->First;\
}

#define TAIL_QUEUE_ROOT(name,type)\
struct name\
{   struct type *First;\
    struct type **Last;\
}/* NOTE!  This is the address of the last Next pointer. */


#define TAIL_QUEUE_MEMBER(type)\
struct\
{   struct type *Next;\
    struct type **Prev;	/* NOTE!  Address of previous Next element ptr */\
}

#define TAIL_QUEUE_INSERT_END(root,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = 0;\
    *(root)->Last = (element);\
    (root)->Last = &(element)->field.Next;\
}

#define TAIL_QUEUE_DELETE(root,element,field)\
{\
    if (((element)->field.Next) != NULL)\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
	(root)->Last = (element)->field.Prev;\
    *(element)->field.Prev = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define TAIL_QUEUE_FIRST(root) (root)->First
#define TAIL_QUEUE_NEXT(element,field) (element)->field.Next



#define CIRCLE_QUEUE_ROOT(name,type)\
struct name\
{   struct type *Last;\
    struct type *First;\
}

#define CIRCLE_QUEUE_MEMBER(type)\
struct\
{   struct type *Prev;\
    struct type *Next;\
}

#define	CIRCLE_QUEUE_INITIALIZE(root,type)\
{   (root)->Last = (type *)(root);\
    (root)->First = (type *)(root);\
}

#define CIRCLE_QUEUE_INITIALIZE_MEMBER(element,field)\
{ (element)->field.Next = (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_INSERT_END(root,type,element,field)\
{   (element)->field.Prev = (root)->Last;\
    (element)->field.Next = (type *)(root);\
    if((root)->First != (type *)(root))\
	(root)->Last->field.Next = (element);\
    else\
	(root)->First = (element);\
    (root)->Last = (element);\
}

#define CIRCLE_QUEUE_INSERT_ROOT(root,type,element,field)\
{   (element)->field.Prev = (type *)(root);\
    (element)->field.Next = (root)->First;\
    if ((root)->Last != (void *)(root))\
	(root)->First->field.Prev = (element);\
    else\
	(root)->Last = (element);\
    (root)->First = (element);\
}

#define CIRCLE_QUEUE_INSERT_PREVIOUS(root,current_element,element,field)\
{   (element)->field.Prev = (current_element)->field.Prev;\
    (element)->field.Next = (current_element);\
    if ((current_element)->field.Prev != (void *)(root))\
	(current_element)->field.Prev->field.Next = (element);\
    else\
	(root)->First = (element);\
    (current_element)->field.Prev = (element);\
}

#define	CIRCLE_QUEUE_DELETE(root,element,field)\
{   if((element)->field.Next != (void *)(root))\
	(element)->field.Next->field.Prev = (element)->field.Prev;\
    else\
	(root)->Last = (element)->field.Prev;\
    if((element)->field.Prev != (void *)(root))\
	(element)->field.Prev->field.Next = (element)->field.Next;\
    else\
	(root)->First = (element)->field.Next;\
    (element)->field.Next = 0;\
    (element)->field.Prev = 0;\
}

#define CIRCLE_QUEUE_FIRST(root)\
((root)->First == (void *) (root)? 0: (root)->First)

#define CIRCLE_QUEUE_LAST(root)\
((root)->Last == (void *) (root)? 0: (root)->Last)

#define CIRCLE_QUEUE_NEXT(root,element,field)\
((void *) (element)->field.Next == (void *) (root)? 0: (element)->field.Next)

#define CIRCLE_QUEUE_PREVIOUS(root,element,field)\
((element)->field.Prev == (void *) (root)? 0: (element)->field.Prev)

#if 0
/*
Test code.  Strip it out, put it in a .C (or .CPP) file and compile it as a
console app to test this stuff. It should run without any assertion failures.

Also, use this as example code.
*/

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "lists.h"

void TestList(void)
{
    struct Foo
    {
	int a;
	LIST_MEMBER(Foo) ListStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    LIST_ROOT(sRoot, Foo) MyListRoot;

    fputs("Testing LIST.\n",stdout);

    LIST_INITIALIZE(&MyListRoot);

    LIST_INITIALIZE_MEMBER(&MyFoo1,ListStuff);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;

    LIST_INITIALIZE_MEMBER(&MyFoo2,ListStuff);
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;

    LIST_INITIALIZE_MEMBER(&MyFoo3,ListStuff);
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    assert(LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo3,ListStuff);
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);

    assert(!LIST_ORPHAN_MEMBER(&MyFoo1,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo2,ListStuff));
    assert(!LIST_ORPHAN_MEMBER(&MyFoo3,ListStuff));

    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = LIST_FIRST(&MyListRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 3. */
    pFoo = LIST_FIRST(&MyListRoot);
    pFoo = LIST_NEXT(pFoo,ListStuff);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);

    /* Delete member 1. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == 0);

    LIST_INSERT_ROOT(&MyListRoot,&MyFoo2,ListStuff);
    LIST_INSERT_ROOT(&MyListRoot,&MyFoo1,ListStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = LIST_FIRST(&MyListRoot);
    LIST_DELETE(pFoo,ListStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(LIST_NEXT(pFoo,ListStuff) == 0);
    assert(LIST_FIRST(&MyListRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("List passed.\n", stdout);
}

void TestTailQueue(void)
{
    struct Foo
    {
	int a;
	TAIL_QUEUE_MEMBER(Foo) TQStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    TAIL_QUEUE_ROOT(sRoot, Foo) MyTQRoot;

    fputs("Testing TAIL_QUEUE.\n",stdout);

    TAIL_QUEUE_INITIALIZE(&MyTQRoot);
    MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
    MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
    MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo3,TQStuff);

    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x2A);
    assert(pFoo->b == 0x2B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);

    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo == 0);

    /* Delete member 2. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x2B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Make sure that there are only members 1 and 3 in the list now. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    assert(pFoo);
    assert(pFoo->a == 0x1A);
    assert(pFoo->b == 0x1B);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    assert(pFoo);
    assert(pFoo->a == 0x3A);
    assert(pFoo->b == 0x3B);
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 3. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    pFoo = TAIL_QUEUE_NEXT(pFoo,TQStuff);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x3B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);

    /* Delete member 1. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == 0);

    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo1,TQStuff);
    TAIL_QUEUE_INSERT_END(&MyTQRoot,&MyFoo2,TQStuff);
    
    /* Delete member 1 while there are other members in the list. */
    pFoo = TAIL_QUEUE_FIRST(&MyTQRoot);
    TAIL_QUEUE_DELETE(&MyTQRoot,pFoo,TQStuff);
    assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
    assert(pFoo->b == 0x1B);/* And the data is intact. */
    assert(TAIL_QUEUE_NEXT(pFoo,TQStuff) == 0);
    assert(TAIL_QUEUE_FIRST(&MyTQRoot) == &MyFoo2);

    assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
    assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
    assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);

    fputs("Tail Queue passed.\n", stdout);
}
void TestCircleQueue(void)
{
    enum {END,ROOT,PREVIOUS,DONE} WhichInsert = END;
    int i;
    struct Foo
    {
	int a;
	CIRCLE_QUEUE_MEMBER(Foo) CQStuff;
	int b;
    };
    struct Foo MyFoo1, MyFoo2, MyFoo3, *pFoo = 0;
    CIRCLE_QUEUE_ROOT(sRoot, Foo) MyCQRoot;

    fputs("Testing CIRCLE_QUEUE.\n",stdout);

    while(WhichInsert != DONE)
    {
	CIRCLE_QUEUE_INITIALIZE(&MyCQRoot,Foo);
	MyFoo1.a = 0x1A; MyFoo1.b = 0x1B;
	MyFoo2.a = 0x2A; MyFoo2.b = 0x2B;
	MyFoo3.a = 0x3A; MyFoo3.b = 0x3B;
    
	switch(WhichInsert)
	{
	case END:
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    WhichInsert = ROOT;
	    break;
	case ROOT:
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo1,CQStuff);
	    WhichInsert = PREVIOUS;
	    break;
	case PREVIOUS:
	    CIRCLE_QUEUE_INSERT_ROOT(&MyCQRoot,Foo,&MyFoo3,CQStuff);
	    CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo3,&MyFoo2,CQStuff);
	    CIRCLE_QUEUE_INSERT_PREVIOUS(&MyCQRoot,&MyFoo2,&MyFoo1,CQStuff);
	    WhichInsert = DONE;
	    break;
	default:
	    assert(0);
	}

        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x2A);
        assert(pFoo->b == 0x2B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
    
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo == 0);

	pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == 0);
	pFoo = CIRCLE_QUEUE_LAST(&MyCQRoot);
	assert(pFoo == &MyFoo3);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,pFoo,CQStuff) == &MyFoo2);
	assert(CIRCLE_QUEUE_PREVIOUS(&MyCQRoot,&MyFoo2,CQStuff) == &MyFoo1);
    
        /* Delete member 2. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x2A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x2B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Make sure that there are only members 1 and 3 in the list now. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        assert(pFoo);
        assert(pFoo->a == 0x1A);
        assert(pFoo->b == 0x1B);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo);
        assert(pFoo->a == 0x3A);
        assert(pFoo->b == 0x3B);
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 3. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        pFoo = CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x3A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x3B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
    
        /* Delete member 1. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == 0);
    
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo1,CQStuff);
        CIRCLE_QUEUE_INSERT_END(&MyCQRoot,Foo,&MyFoo2,CQStuff);
        
        /* Delete member 1 while there are other members in the list. */
        pFoo = CIRCLE_QUEUE_FIRST(&MyCQRoot);
        CIRCLE_QUEUE_DELETE(&MyCQRoot,pFoo,CQStuff);
        assert(pFoo->a == 0x1A);/* Make sure we have the right member. */
        assert(pFoo->b == 0x1B);/* And the data is intact. */
        assert(CIRCLE_QUEUE_NEXT(&MyCQRoot,pFoo,CQStuff) == 0);
        assert(CIRCLE_QUEUE_FIRST(&MyCQRoot) == &MyFoo2);
    
        assert(MyFoo1.a == 0x1A); assert(MyFoo1.b == 0x1B);
        assert(MyFoo2.a == 0x2A); assert(MyFoo2.b == 0x2B);
        assert(MyFoo3.a == 0x3A); assert(MyFoo3.b == 0x3B);
    }

    fputs("Circle Queue passed.\n", stdout);
}

int main()
{
    TestList();
    TestTailQueue();
    TestCircleQueue();
    fputs("All tests passed.", stdout);
    return EXIT_SUCCESS;
}
#endif /* End of test code. */

#if __cplusplus
}
#endif

#endif // !_LISTS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\misc\logger.h ===
/*
	logger.h

	Use to write log info to a file.

	Multiple-instance aware. If one instance already owns the output
        file, another will sleep (up to 20s) until the first is done.
	Nicely outputs a header containing user, computer, and driver names,
	date/time and starting display resolution.


        You use it like this:

                CLogfile Log("test.log","your comment here");

                // or CLogfile Log("test.log");
                // for no comment, and overwriting the file.

                // or CLogfile Log("test.log","your comment here",TRUE);
                // to make it append to the file. Default is overwrite.
                
                Log << "\n\n42 decimal is " << 42ul <<" in hex\n";
                Log << "Hi"<<'!'<<'\n' ;
                Log << "The value of 0x2a is " << 0x2al << " in decimal\n";

				CLogfile Faults("faults.log","my test's faults",TRUE);	//append new faults
				Faults << "Encountered a booboo, here's what i did:\n";
				Faults << Log;		//copies contents of test.log to Fault
				Faults << "so now you can diagnose\n";

        The class will then write stuff like this to test.log:


                ----------------------------------------------------------
                EnumSurface test
                Beginning test at 10:38 on 1995/8/14
                User Name:jeffno
                Computer Name:JEFFNO2
                Display driver:S3 Vision864 PCI
                Starting resolution: 640x480x8
                - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
                42 decimal is 0000002a in hex
                Hi!
                The value of 0x2a is 42 in decimal
                ----------- Test ends at 10:38 on 1995/8/14 -------------
                
		And faults.log will get:
				< a header like above>
				Encountered a booboo, here's what i did:
				< a copy of the test.log contents surrounded by
					notes that say this is a snapshot of test.log >
				so now you can diagnose
				< a trailer like above (test ends at etc...)>



        The class can output DWORDS, which it does as an 8-digit hex number,
        LONGs which are output as decimal, chars and strings. As shown
		above you can output one log object to another, which copies 
		everything in the source file from the pos at which the source
		file was opened (if appending to a pre-existing file) up to
		the end.


        But wait! you also get...
                A routine called char * ErrorName(HRESULT) which takes
                a ddraw return value and returns a string describing it.
                Very handy.
                BTW: this header file includes a statically declared array
                full of names, at file level scope. This means you get a 2k
                array in your source wether you want ErrorName or not.
                Go ahead and edit this file if you don't want this array.

        NOTE: this uses WNetGetUser API, so you'll need to add mpr.lib
        to you LIBS line in your makefile.
*/

//#include <stdio.h>
#include <windows.h>
#include <windowsx.h> 


struct {
	char name[100];
	HRESULT errcode;
} ErrorLookup[] = {
				{"DD_OK",DD_OK},
				{"DDERR_ALREADYINITIALIZED",DDERR_ALREADYINITIALIZED},
				{"DDERR_CANNOTATTACHSURFACE",DDERR_CANNOTATTACHSURFACE},
				{"DDERR_CANNOTDETACHSURFACE",DDERR_CANNOTDETACHSURFACE},
				{"DDERR_CURRENTLYNOTAVAIL",DDERR_CURRENTLYNOTAVAIL},
				{"DDERR_EXCEPTION",DDERR_EXCEPTION},
				{"DDERR_GENERIC",DDERR_GENERIC},
				{"DDERR_HEIGHTALIGN",DDERR_HEIGHTALIGN},
				{"DDERR_INCOMPATIBLEPRIMARY",DDERR_INCOMPATIBLEPRIMARY},
				{"DDERR_INVALIDCAPS",DDERR_INVALIDCAPS},
				{"DDERR_INVALIDCLIPLIST",DDERR_INVALIDCLIPLIST},
				{"DDERR_INVALIDMODE",DDERR_INVALIDMODE},
				{"DDERR_INVALIDOBJECT",DDERR_INVALIDOBJECT},
				{"DDERR_INVALIDPARAMS",DDERR_INVALIDPARAMS},
				{"DDERR_INVALIDPIXELFORMAT",DDERR_INVALIDPIXELFORMAT},
				{"DDERR_INVALIDRECT",DDERR_INVALIDRECT},
				{"DDERR_LOCKEDSURFACES",DDERR_LOCKEDSURFACES},
				{"DDERR_NO3D",DDERR_NO3D},
				{"DDERR_NOALPHAHW",DDERR_NOALPHAHW},
				{"DDERR_NOANTITEARHW",DDERR_NOANTITEARHW},
				{"DDERR_NOBLTQUEUEHW",DDERR_NOBLTQUEUEHW},
				{"DDERR_NOCLIPLIST",DDERR_NOCLIPLIST},
				{"DDERR_NOCOLORCONVHW",DDERR_NOCOLORCONVHW},
				{"DDERR_NOCOOPERATIVELEVELSET",DDERR_NOCOOPERATIVELEVELSET},
				{"DDERR_NOCOLORKEY",DDERR_NOCOLORKEY},
				{"DDERR_NOCOLORKEYHW",DDERR_NOCOLORKEYHW},
				{"DDERR_NOEXCLUSIVEMODE",DDERR_NOEXCLUSIVEMODE},
				{"DDERR_NOFLIPHW",DDERR_NOFLIPHW},
				{"DDERR_NOGDI",DDERR_NOGDI},
				{"DDERR_NOMIRRORHW",DDERR_NOMIRRORHW},
				{"DDERR_NOTFOUND",DDERR_NOTFOUND},
				{"DDERR_NOOVERLAYHW",DDERR_NOOVERLAYHW},
				{"DDERR_NORASTEROPHW",DDERR_NORASTEROPHW},
				{"DDERR_NOROTATIONHW",DDERR_NOROTATIONHW},
				{"DDERR_NOSTRETCHHW",DDERR_NOSTRETCHHW},
				{"DDERR_NOT4BITCOLOR",DDERR_NOT4BITCOLOR},
				{"DDERR_NOT4BITCOLORINDEX",DDERR_NOT4BITCOLORINDEX},
				{"DDERR_NOT8BITCOLOR",DDERR_NOT8BITCOLOR},
				{"DDERR_NOTEXTUREHW",DDERR_NOTEXTUREHW},
				{"DDERR_NOVSYNCHW",DDERR_NOVSYNCHW},
				{"DDERR_NOZBUFFERHW",DDERR_NOZBUFFERHW},
				{"DDERR_NOZOVERLAYHW",DDERR_NOZOVERLAYHW},
				{"DDERR_OUTOFCAPS",DDERR_OUTOFCAPS},
				{"DDERR_OUTOFMEMORY",DDERR_OUTOFMEMORY},
				{"DDERR_OUTOFVIDEOMEMORY",DDERR_OUTOFVIDEOMEMORY},
				{"DDERR_OVERLAYCANTCLIP",DDERR_OVERLAYCANTCLIP},
				{"DDERR_OVERLAYCOLORKEYONLYONEACTIVE",DDERR_OVERLAYCOLORKEYONLYONEACTIVE},
				{"DDERR_PALETTEBUSY",DDERR_PALETTEBUSY},
				{"DDERR_COLORKEYNOTSET",DDERR_COLORKEYNOTSET},
				{"DDERR_SURFACEALREADYATTACHED",DDERR_SURFACEALREADYATTACHED},
				{"DDERR_SURFACEALREADYDEPENDENT",DDERR_SURFACEALREADYDEPENDENT},
				{"DDERR_SURFACEBUSY",DDERR_SURFACEBUSY},
				{"DDERR_SURFACEISOBSCURED",DDERR_SURFACEISOBSCURED},
				{"DDERR_SURFACELOST",DDERR_SURFACELOST},
				{"DDERR_SURFACENOTATTACHED",DDERR_SURFACENOTATTACHED},
				{"DDERR_TOOBIGHEIGHT",DDERR_TOOBIGHEIGHT},
				{"DDERR_TOOBIGSIZE",DDERR_TOOBIGSIZE},
				{"DDERR_TOOBIGWIDTH",DDERR_TOOBIGWIDTH},
				{"DDERR_UNSUPPORTED",DDERR_UNSUPPORTED},
				{"DDERR_UNSUPPORTEDFORMAT",DDERR_UNSUPPORTEDFORMAT},
				{"DDERR_UNSUPPORTEDMASK",DDERR_UNSUPPORTEDMASK},
				{"DDERR_VERTICALBLANKINPROGRESS",DDERR_VERTICALBLANKINPROGRESS},
				{"DDERR_WASSTILLDRAWING",DDERR_WASSTILLDRAWING},
				{"DDERR_XALIGN",DDERR_XALIGN},
				{"DDERR_INVALIDDIRECTDRAWGUID",DDERR_INVALIDDIRECTDRAWGUID},
				{"DDERR_DIRECTDRAWALREADYCREATED",DDERR_DIRECTDRAWALREADYCREATED},
				{"DDERR_NODIRECTDRAWHW",DDERR_NODIRECTDRAWHW},
				{"DDERR_PRIMARYSURFACEALREADYEXISTS",DDERR_PRIMARYSURFACEALREADYEXISTS},
				{"DDERR_NOEMULATION",DDERR_NOEMULATION},
				{"DDERR_REGIONTOOSMALL",DDERR_REGIONTOOSMALL},
				{"DDERR_CLIPPERISUSINGHWND",DDERR_CLIPPERISUSINGHWND},
				{"DDERR_NOCLIPPERATTACHED",DDERR_NOCLIPPERATTACHED},
				{"DDERR_NOHWND",DDERR_NOHWND},
				{"DDERR_HWNDSUBCLASSED",DDERR_HWNDSUBCLASSED},
				{"DDERR_HWNDALREADYSET",DDERR_HWNDALREADYSET},
				{"DDERR_NOPALETTEATTACHED",DDERR_NOPALETTEATTACHED},
				{"DDERR_NOPALETTEHW",DDERR_NOPALETTEHW},
				{"DDERR_BLTFASTCANTCLIP",DDERR_BLTFASTCANTCLIP},
				{"DDERR_NOBLTHW",DDERR_NOBLTHW},
				{"DDERR_NODDROPSHW",DDERR_NODDROPSHW},
				{"DDERR_OVERLAYNOTVISIBLE",DDERR_OVERLAYNOTVISIBLE},
				{"DDERR_NOOVERLAYDEST",DDERR_NOOVERLAYDEST},
				{"DDERR_INVALIDPOSITION",DDERR_INVALIDPOSITION},
				{"DDERR_NOTAOVERLAYSURFACE",DDERR_NOTAOVERLAYSURFACE},
				{"DDERR_EXCLUSIVEMODEALREADYSET",DDERR_EXCLUSIVEMODEALREADYSET},
				{"DDERR_NOTFLIPPABLE",DDERR_NOTFLIPPABLE},
				{"DDERR_CANTDUPLICATE",DDERR_CANTDUPLICATE},
				{"DDERR_NOTLOCKED",DDERR_NOTLOCKED},
				{"DDERR_CANTCREATEDC",DDERR_CANTCREATEDC},
				{"DDERR_NODC",DDERR_NODC},
				{"DDERR_WRONGMODE",DDERR_WRONGMODE},
				{"DDERR_IMPLICITLYCREATED",DDERR_IMPLICITLYCREATED},
				{"DDERR_NOTPALETTIZED",DDERR_NOTPALETTIZED},
				{"DDERR_UNSUPPORTEDMODE",DDERR_UNSUPPORTEDMODE},
				{"END",0}
};

inline char * ErrorName(HRESULT err)
{
	int e=0;
	while (strcmp(ErrorLookup[e].name,"END"))
	{
		if (err == ErrorLookup[e].errcode)
			return ErrorLookup[e].name;
		e++;
	};
	return "Unknown Error code";
}	


class CLogfile
{	
	private:
		char smalltemp[10];
		HFILE 	fh;
		OFSTRUCT of;
		BOOL bHeaderWritten;
		char *cComment;
		char line[1000];
		LONG lStartPos;
		char Path[200];
	public:
		CLogfile(char * path, char * comment = 0,BOOL bAppend=FALSE)
		{
			if (path)
				strncpy(Path,path,199);

			fh = HFILE_ERROR;
			bHeaderWritten = FALSE;
			lStartPos = 0;

			//if the file does not exist, create it:
			if (GetFileAttributes(path) == 0xffffffff)
				fh = OpenFile(path,&of,OF_CREATE|OF_READWRITE|OF_SHARE_DENY_WRITE);
			else
				//first attempt to get a lock on the file...
				for (int i=0;i<20 && fh==HFILE_ERROR;i++)
				{
					if (bAppend)
						fh = OpenFile(path,&of, OF_READWRITE|OF_SHARE_DENY_WRITE);
					else
						fh = OpenFile(path,&of, OF_CREATE|OF_READWRITE|OF_SHARE_DENY_WRITE);
					if (fh==HFILE_ERROR)
						Sleep(1000);
				}

			if (fh==HFILE_ERROR)
				return;

			lStartPos = _llseek(fh,0,SEEK_END);

			cComment = comment;
		}

		void OutputHeader(void)
		{
			//now we have the file, write user/computer info:

			//write separator, comment if necessary and date and time:
			SYSTEMTIME st;
			GetLocalTime(&st);
			wsprintf(line,"----------------------------------------------------------\r\n");
			_lwrite(fh,line,strlen(line));
			if (cComment && strlen(cComment))
			{
				wsprintf(line,"%s\r\n",cComment);
				_lwrite(fh,line,strlen(line));
			}
			wsprintf(line,"Beginning test at %d:%02d on %d/%d/%d\r\n",st.wHour,st.wMinute,st.wYear,st.wMonth,st.wDay);
			_lwrite(fh,line,strlen(line));


			//write user's name:
			DWORD length = 100;
			wsprintf(line,"User Name:");

			WNetGetUser(NULL,line+strlen(line),&length);
			_lwrite(fh,line,strlen(line));

			//write computer's name:
			wsprintf(line,"\r\nComputer Name:");
			GetComputerName(line+strlen(line),&length);
			_lwrite(fh,line,strlen(line));

			//write display driver's name:
			wsprintf(line,"\r\nDisplay driver:");
			GetPrivateProfileString("boot.description","display.drv","(Unknown)",line+strlen(line),100,"system.ini");
			_lwrite(fh,line,strlen(line));

			_lwrite(fh,"\r\n",2);

			HDC hdc = GetDC(NULL);
			if (hdc)
			{
				wsprintf(line,"Starting resolution: %dx%dx%d\r\n",
							GetDeviceCaps(hdc,HORZRES)
							,GetDeviceCaps(hdc,VERTRES)
							,GetDeviceCaps(hdc,BITSPIXEL) );
				_lwrite(fh,line,strlen(line));
				ReleaseDC(NULL,hdc);
			}
			wsprintf(line,"- - - - - - - - - - - - - - - - - - - - - - - - - - - - - \r\n");
			_lwrite(fh,line,strlen(line));

			bHeaderWritten = TRUE;
		}
		~CLogfile()
		{
			SYSTEMTIME st;
			if(fh != HFILE_ERROR)
			{
				if (bHeaderWritten)
				{
					GetLocalTime(&st);
					wsprintf(line,"----------- Test ends at %d:%02d on %d/%d/%d -------------\r\n",st.wHour,st.wMinute,st.wYear,st.wMonth,st.wDay);
					_lwrite(fh,line,strlen(line));
				}
				_lclose(fh);
			}
		}
		CLogfile & operator << (DWORD dw)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			wsprintf(smalltemp,"%08x",dw);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
		CLogfile & operator << (LONG dw)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			wsprintf(smalltemp,"%d",dw);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
                CLogfile & operator << (void * p)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
            wsprintf(smalltemp,"%08x",p);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
		CLogfile & operator << (char * cp)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			while( *cp)
				*this << *cp++;
			return *this;
		}
		CLogfile & operator << (char  c)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();
			if (c=='\n')
			{
				wsprintf(smalltemp,"\r");
				_lwrite(fh,smalltemp,strlen(smalltemp));
			}
			wsprintf(smalltemp,"%c",c);
			_lwrite(fh,smalltemp,strlen(smalltemp));
			return *this;
		}
		CLogfile & operator << (CLogfile & log)
		{
			if(fh == HFILE_ERROR)
				return *this;
			if(!bHeaderWritten)
				OutputHeader();

			LONG pos = _llseek(log.fh,0,FILE_CURRENT);
			LONG from = _llseek(log.fh,log.lStartPos,FILE_BEGIN);

			char ch;
			*this << "= = = = = = = Snapshot of ";
			if (log.Path)
				*this << log.Path;
			else
				*this << "Unknown file";
			*this << " = = = = = = =\n";

			for (LONG j=0;j<pos-from;j++)
			{
				_lread(log.fh,&ch,1);
				*this << ch;
			}

			*this << "= = = = = = = = = Snapshot ends = = = = = = = = = = =\n";
			return *this;
		}
			
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\misc\newdpf.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       newdpf.h
 *  Content:    new debug printf
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   10-oct-95  jeffno  initial implementation
 *   15-jun-98  linstev added DPF2
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DEBUGPF_H
#define __DEBUGPF_H

#include <stdarg.h>
#include <windows.h>

#ifndef DPF_MODNAME
    extern char * DPF_MODNAME;
#endif

#if defined(DEBUG) || defined(DBG)

    #undef DEBUG_TOPIC
    #define DEBUG_TOPIC(flag,name) flag,
    typedef enum DEBUG_TOPICS {
        A=1,    /* For API Usage */
    #include "DBGTOPIC.H"
        LAST_TOPIC
    };

    #line 21
/*
    #undef DBG
    #define DBG 1
    */
    #undef DEBUG
    #define DEBUG
    #if defined( _WIN32 ) && defined(WIN95)
        #define DEBUG_BREAK()       _try { _asm { int 3 } } _except (EXCEPTION_EXECUTE_HANDLER) {;}
    #else
        #define DEBUG_BREAK()       DebugBreak()
    #endif


    /*
     * DEBUG_TOPIC
     * This structure describes a debugging topic and associates a single-letter key to it.
     */

    #define DEBUG_TOPIC_NAME_LENGTH 59
    typedef struct
    {
        DWORD   dwSize; //for versioning
        char    cKey;
        char    cName[DEBUG_TOPIC_NAME_LENGTH];
    } DPF_DEBUG_TOPIC;

    /*
     * PROC_STATS
     * This struct saves statistics about each proc as maintained by DebugEnterProc
     */
    typedef struct
    {
        char            cName[DEBUG_TOPIC_NAME_LENGTH];
        DWORD           dwCalls;
#ifdef WIN32
        LARGE_INTEGER   liTotalTime;
        LARGE_INTEGER   liLastEnteredAt;
#else
        DWORD           dwFiller[8];
#endif
    } DPF_PROC_STATS;

    #define MAX_PROC_ORDINAL 100

#ifdef __cplusplus
        extern "C" {
#endif
    /*
     * Debugging output/flow-control calls
     */
   extern void DebugSetTopicsAndLevels(char * pcTopicsAndLevelsToDisplay);
   extern void DebugHalt(void);       //Break if control level allows
   extern int  DebugSetFileLineEtc(LPSTR szFile, DWORD dwLineNumber,LPSTR szFnName);
   extern int  DebugPrintf(DWORD dwDetail, ...);
   extern void DebugSetMute(BOOL bMuteFlag);
   extern void DebugPrintfInit(void);
   extern void DebugEnterAPI(char *,LPDWORD);
   extern void _DDAssert(LPCSTR szFile, int nLine, LPCSTR szCondition);
   extern int  DebugPrintf2(LPSTR cFilter, ...);
   extern void cdecl D3DInfoPrintf( UINT lvl, LPSTR szFormat, ...);
   extern void cdecl D3DWarnPrintf( UINT lvl, LPSTR szFormat, ...);
   extern void cdecl D3DErrorPrintf( LPSTR szFormat, ...);
#ifdef __cplusplus
    }
#endif

    #define dprintf(a,b)                            DebugPrintf(a,b);
    #define DPFINIT()                               DebugPrintfInit();
    #define DPF                                     DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf
    #define DPF_ERR(a)                              DebugSetFileLineEtc(__FILE__,__LINE__,DPF_MODNAME),DebugPrintf( 0, a )
    #define DPF_ENTERAPI(pIface)                    DebugEnterAPI(DPF_MODNAME,(LPDWORD)pIface)
    #define DPF_APIRETURNS(hr)                      DPF(3,"   %s returns %08x (%d)",DPF_MODNAME,hr,hr&0xfff)
    #define DDASSERT(condition)                     if (!(condition)) _DDAssert(__FILE__, __LINE__, #condition)
    #define DPF_MUTEWHEN(c)                         {DebugSetMute((BOOL) (c) );}
    #define DPF_SPEWWHEN(c)                         {DebugSetMute((BOOL) (!(c)) );}
    #define DPF_MUTE()                              DPF_MUTEWHEN(TRUE)
    #define DPF_UNMUTE()                            DPF_MUTEWHEN(FALSE)

    #define DPF_SETTOPICS(t)
    #define DPF_STRUCT(level,topic,struct_identifier,struct_ptr)    {extern void DUMP_##struct_identifier(DWORD,DWORD,LP##struct_identifier);\
                                                    DUMP_##struct_identifier(level,topic,struct_ptr);}

    #define D3D_ERR       D3DErrorPrintf
    #define D3D_WARN      D3DWarnPrintf
    #define D3D_INFO      D3DInfoPrintf
#else
    #pragma warning(disable:4002)
    #define dprintf()
    #define DPFINIT()
    #define DPFFINI()
    #define DPF()
    #define DPF_ENTERAPI()
    #define DPF_APIRETURNS()
    #define DPF_DUMP()
    #define DPF_DUMPHEX()
    #define DPF_DUMPGUID()
    #define DDASSERT()
    #define DPF_ERR()
    #define DEBUG_BREAK()
    #define DPF_MUTEWHEN()
    #define DPF_SPEWWHEN()
    #define DPF_MUTE()
    #define DPF_UNMUTE()

    #define DPF_SETTOPICS()
    #define DPF_DUMPGUID()
    #define DPF_STRUCT()
    #define D3D_ERR(a)
    #define D3D_WARN()
    #define D3D_INFO()
#endif


#ifdef _WIN32

#ifdef DEBUG
    __inline DWORD clockrate() {LARGE_INTEGER li; QueryPerformanceFrequency(&li); return li.LowPart;}
    __inline DWORD clock()     {LARGE_INTEGER li; QueryPerformanceCounter(&li);   return li.LowPart;}

    #define TIMEVAR(t)    DWORD t ## T; DWORD t ## N
    #define TIMEZERO(t)   t ## T = 0, t ## N = 0
    #define TIMESTART(t)  t ## T -= clock(), t ## N ++
    #define TIMESTOP(t)   t ## T += clock()
    #define TIMEFMT(t)    ((DWORD)(t) / clockrate()), (((DWORD)(t) * 1000 / clockrate())%1000)
    #define TIMEOUT(t)    if (t ## N) DPF(4, #t ": %ld calls, %ld.%03ld sec (%ld.%03ld)", t ## N, TIMEFMT(t ## T), TIMEFMT(t ## T / t ## N))
#else
    #define TIMEVAR(t)
    #define TIMEZERO(t)
    #define TIMESTART(t)
    #define TIMESTOP(t)
    #define TIMEFMT(t)
    #define TIMEOUT(t)
#endif

#endif


#endif //__DEBUG_PF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\misc\w95help.h ===
/*==========================================================================
 *
 *  Copyright (C) 1995-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95help.h
 *  Content:	header file for Win95 helper interface
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   06-apr-95	craige	initial implementation
 *   29-nov-95  angusm  added HelperCreateDSFocusThread
 *   18-jul-96	andyco	added Helper(Add/)DeleteDPlayServer
 *   12-oct-96  colinmc added new service to get DDHELP to get its own handle
 *                      for communicating with the DirectSound VXD
 *   22-jan-97  kipo	return an HRESULT from HelperAddDPlayServer()
 *
 ***************************************************************************/
#ifndef __W95HELP_INCLUDED__
#define __W95HELP_INCLUDED__
#include "ddhelp.h"

#ifdef __cplusplus
extern "C" {
#endif

extern void SignalNewProcess( DWORD pid, LPHELPNOTIFYPROC proc );

extern void StopWatchProcess( DWORD pid, LPHELPNOTIFYPROC proc );

extern void SignalNewDriver( LPSTR fname, BOOL isdisp );

extern BOOL CreateHelperProcess( LPDWORD ppid );

extern void DoneWithHelperProcess( void );

extern BOOL WaitForHelperStartup( void );

extern DWORD HelperLoadDLL( LPSTR dllname, LPSTR fnname, DWORD context );

extern void HelperCreateThread( void );

extern DWORD HelperWaveOpen( LPVOID lphwo, DWORD dwDeviceID, LPVOID pwfx );

extern DWORD HelperWaveClose( DWORD hwo );

extern DWORD HelperCreateTimer( DWORD dwResolution,LPVOID pTimerProc,DWORD dwInstanceData );

extern DWORD HelperKillTimer( DWORD dwTimerID );

#ifdef _WIN32
extern HANDLE HelperCreateDSMixerThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
					 LPVOID pThreadParam,
					 DWORD dwFlags,
					 LPDWORD pThreadId );

extern HANDLE HelperCreateDSFocusThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
					 LPVOID pThreadParam,
					 DWORD dwFlags,
					 LPDWORD pThreadId );

extern void HelperCallDSEmulatorCleanup( LPVOID pCleanupFunc,
                                         LPVOID pDirectSound );

#endif

extern BOOL HelperCreateModeSetThread( LPVOID callback, HANDLE *ph, LPVOID lpdd, DWORD hInstance );

extern BOOL HelperCreateDOSBoxThread( LPVOID callback, HANDLE *ph, LPVOID lpdd, DWORD hInstance );

extern void HelperKillModeSetThread( DWORD hInstance );

extern void HelperKillDOSBoxThread( DWORD hInstance );

extern DWORD HelperAddDPlayServer(DWORD port);
extern BOOL HelperDeleteDPlayServer();

#ifdef WIN95
extern HANDLE HelperGetDSVxd( void );

extern HANDLE HelperGetDDVxd( void );

#endif

extern void HelperSetOnDisplayChangeNotify( void *pfn );
extern HINSTANCE HelperLoadLibrary(LPCSTR pszLibraryName);
extern BOOL HelperFreeLibrary(HINSTANCE hInst);
extern void HelperAddDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC);
extern void HelperDelDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC);

#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\misc\w95help.c ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       w95hack.c
 *  Content:    Win95 hack-o-rama code
 *              This is a HACK to handle the fact that Win95 doesn't notify
 *              a DLL when a process is destroyed.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   28-mar-95  craige  initial implementation
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  reworked for new ddhelp
 *   09-may-95  craige  loading any DLL
 *   16-sep-95  craige  bug 1117: must UnmapViewOfFile before closing handle
 *   29-nov-95  angusm  added HelperCreateDSFocusThread
 *   18-jul-96  andyco  added Helper(Add/)DeleteDPlayServer
 *   12-oct-96  colinmc added new service to get DDHELP to get its own handle
 *                      for communicating with the DirectSound VXD
 *   22-jan-97  kipo    return an HRESULT from HelperAddDPlayServer()
 *   29-jan-97  colinmc vxd handling stuff is no longer win16 lock specific
 *
 ***************************************************************************/
#undef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <mmsystem.h>
#include <mmreg.h>

#include "w95help.h"
#include "dpf.h"

#undef E_FAIL
#define E_FAIL  0x80004005L

//extern DWORD  * pdwHelperPid;
//extern HANDLE * phModule;     // must be defined
extern DWORD    dwHelperPid;
extern HINSTANCE hModule;       // must be defined


/*
 * sendRequest
 *
 * communicate a request to DDHELP
 */
static BOOL sendRequest( LPDDHELPDATA req_phd )
{
    LPDDHELPDATA        phd;
    HANDLE              hmem;
    HANDLE              hmutex;
    HANDLE              hackevent;
    HANDLE              hstartevent;
    BOOL                rc;

    /*
     * get events start/ack events
     */
    hstartevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_EVENT_NAME );
    if( hstartevent == NULL )
    {
        return FALSE;
    }
    hackevent = CreateEvent( NULL, FALSE, FALSE, DDHELP_ACK_EVENT_NAME );
    if( hackevent == NULL )
    {
        CloseHandle( hstartevent );
        return FALSE;
    }

    /*
     * create shared memory area
     */
    hmem = CreateFileMapping( (HANDLE) 0xffffffff, NULL,
                PAGE_READWRITE, 0, sizeof( DDHELPDATA ),
                DDHELP_SHARED_NAME );
    if( hmem == NULL )
    {
        DPF( 1, "Could not create file mapping!" );
        CloseHandle( hstartevent );
        CloseHandle( hackevent );
        return FALSE;
    }
    phd = (LPDDHELPDATA) MapViewOfFile( hmem, FILE_MAP_ALL_ACCESS, 0, 0, 0 );
    if( phd == NULL )
    {
        DPF( 1, "Could not create view of file!" );
        CloseHandle( hmem );
        CloseHandle( hstartevent );
        CloseHandle( hackevent );
        return FALSE;
    }

    /*
     * wait for access to the shared memory
     */
    hmutex = OpenMutex( SYNCHRONIZE, FALSE, DDHELP_MUTEX_NAME );
    if( hmutex == NULL )
    {
        DPF( 1, "Could not create mutex!" );
        UnmapViewOfFile( phd );
        CloseHandle( hmem );
        CloseHandle( hstartevent );
        CloseHandle( hackevent );
        return FALSE;
    }
    WaitForSingleObject( hmutex, INFINITE );

    /*
     * wake up DDHELP with our request
     */
    memcpy( phd, req_phd, sizeof( DDHELPDATA ) );
    phd->req_id = hModule;
    if( SetEvent( hstartevent ) )
    {
        WaitForSingleObject( hackevent, INFINITE );
        memcpy( req_phd, phd, sizeof( DDHELPDATA ) );
        rc = TRUE;
    }
    else
    {
        DPF( 1, "Could not signal event to notify DDHELP" );
        rc = FALSE;
    }

    /*
     * done with things
     */
    ReleaseMutex( hmutex );
    CloseHandle( hmutex );
    CloseHandle( hstartevent );
    CloseHandle( hackevent );
    UnmapViewOfFile( phd );
    CloseHandle( hmem );
    return rc;

} /* sendRequest */

/*
 * DoneWithHelperProcess
 */
void DoneWithHelperProcess( void )
{
    DDHELPDATA  hd;

    if( dwHelperPid == 0 )
    {
        return;
    }

    hd.req = DDHELPREQ_FREEDCLIST;
    sendRequest( &hd );

} /* DoneWithHelperProcess */

/*
 * WaitForHelperStartup
 */
BOOL WaitForHelperStartup( void )
{
    HANDLE      hevent;
    DWORD       rc;

    hevent = CreateEvent( NULL, TRUE, FALSE, DDHELP_STARTUP_EVENT_NAME );
    if( hevent == NULL )
    {
        return FALSE;
    }
    DPF( 3, "Wait DDHELP startup event to be triggered" );
    rc = WaitForSingleObject( hevent, 100000 );  // fail if this doesn't work within 100 seconds
    CloseHandle( hevent );
    if( rc == WAIT_TIMEOUT )
    {
        return FALSE;
    }
    return TRUE;

} /* WaitForHelperStartup */

/*
 * HelperLoadDLL
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperLoadDLL( LPSTR dllname, LPSTR fnname, DWORD context )
{
    DDHELPDATA  hd;
    DWORD       rc = 0;

    if( dllname != NULL )
    {
        hd.req = DDHELPREQ_LOADDLL;
        lstrcpy( hd.fname, dllname );
        if( fnname != NULL )
        {
            strcpy( hd.func, fnname );
            hd.context = context;
            DPF( 3, "Context=%08lx", context );
        }
        else
        {
            hd.func[0] = 0;
        }
        DPF( 3, "Asking DDHELP to load DLL %s", dllname );
        sendRequest( &hd );
        rc = (DWORD)hd.dwReturn;
    }

    return rc;

} /* HelperLoadDLL */


/*
 * HelperCreateThread
 */
void HelperCreateThread( void )
{
    DDHELPDATA  hd;

    hd.req = DDHELPREQ_CREATEHELPERTHREAD;
    sendRequest( &hd );

} /* HelperCreateThread */

/*
 * SignalNewProcess
 *
 * Signal DDHELP that a new process has arrived.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void SignalNewProcess( DWORD pid, LPHELPNOTIFYPROC proc )
{
    DDHELPDATA  hd;

    if( pid == dwHelperPid )
    {
        DPF( 3, "Helper connected to DLL - no signal required" );
        return;
    }

    DPF( 3, "Signalling DDHELP that a new process has connected" );
    hd.req = DDHELPREQ_NEWPID;
    hd.pid = pid;
    hd.lpNotify = proc;
    sendRequest( &hd );

} /* SignalNewProcess */


/*
 * StopWatchProcess
 *
 * Signal DDHELP to stop watching a process.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void StopWatchProcess( DWORD pid, LPHELPNOTIFYPROC proc )
{
    DDHELPDATA  hd;

    if( pid == dwHelperPid )
    {
        DPF( 3, "Helper connected to DLL - no signal required" );
        return;
    }

    DPF( 3, "Signalling DDHELP to stop watching a process" );
    hd.req = DDHELPREQ_STOPWATCHPID;
    hd.pid = pid;
    hd.lpNotify = proc;
    sendRequest( &hd );

} /* SignalNewProcess */

/*
 * SignalNewDriver
 *
 * Signal DDHELP that a new driver has been loaded.  This is called with the
 * DLL lock taken, so global vars are safe
 */
void SignalNewDriver( LPSTR fname, BOOL isdisp )
{
    DDHELPDATA  hd;

    DPF( 3, "Signalling DDHELP to create a new DC" );
    hd.req = DDHELPREQ_NEWDC;
    hd.isdisp = isdisp;
    lstrcpy( hd.fname, fname );
    sendRequest( &hd );

} /* SignalNewDriver */

/*
 * CreateHelperProcess
 */
BOOL CreateHelperProcess( LPDWORD ppid )
{
    if( dwHelperPid == 0 )
    {
        STARTUPINFO             si;
        PROCESS_INFORMATION     pi;
        HANDLE                  h;

        h = OpenEvent( SYNCHRONIZE, FALSE, DDHELP_STARTUP_EVENT_NAME );
        if( h == NULL )
        {
            si.cb = sizeof(STARTUPINFO);
            si.lpReserved = NULL;
            si.lpDesktop = NULL;
            si.lpTitle = NULL;
            si.dwFlags = 0;
            si.cbReserved2 = 0;
            si.lpReserved2 = NULL;

            DPF( 3, "Creating helper process now" );
            if( !CreateProcess(NULL, "ddhelp.exe",  NULL, NULL, FALSE,
                               NORMAL_PRIORITY_CLASS,
                               NULL, NULL, &si, &pi) )
            {
                DPF( 2, "Could not create DDHELP.EXE" );
                return FALSE;
            }
            dwHelperPid = pi.dwProcessId;
            DPF( 3, "Helper rocess created" );
        }
        else
        {
            DDHELPDATA  hd;
            DPF( 3, "DDHELP already exists, waiting for DDHELP event" );
            WaitForSingleObject( h, INFINITE );
            CloseHandle( h );
            DPF( 3, "Asking for DDHELP pid" );
            hd.req = DDHELPREQ_RETURNHELPERPID;
            sendRequest( &hd );
            dwHelperPid = hd.pid;
            DPF( 3, "DDHELP pid = %08lx", dwHelperPid );
        }
        *ppid = dwHelperPid;
        return TRUE;
    }
    *ppid = dwHelperPid;
    return FALSE;

} /* CreateHelperProcess */

#ifdef WIN95   //this is Just For Now... dsound will get the help it needs..jeffno 951206
/*
 * HelperWaveOpen
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperWaveOpen( LPVOID lphwo, DWORD dwDeviceID, LPVOID pwfx )
{
    DDHELPDATA  hd;

    if( (lphwo != NULL) && (pwfx != NULL) )
    {
        hd.req = DDHELPREQ_WAVEOPEN;
        hd.pData1 = lphwo;
        hd.dwData1 = dwDeviceID;
        hd.dwData2 = (DWORD)pwfx;
        DPF( 3, "Asking DDHELP to Open Wave Device %d", dwDeviceID );
        sendRequest( &hd );
        return hd.dwReturn;
    }
    else
    {
        DPF( 3, "Helper Wave Open param error");
        return MMSYSERR_ERROR;
    }

} /* HelperWaveOpen */

/*
 * HelperWaveClose
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperWaveClose( DWORD hwo )
{
    DDHELPDATA  hd;

    if( (hwo != 0) )
    {
        hd.req = DDHELPREQ_WAVECLOSE;
        hd.dwData1 = hwo;
        DPF( 3, "Asking DDHELP to Close Wave Device ");
        sendRequest( &hd );
        return hd.dwReturn;
    }
    else
    {
        DPF( 3, "Helper Wave Close param error");
        return MMSYSERR_ERROR;
    }

} /* HelperWaveClose */

/*
 * HelperCreateTimer
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperCreateTimer( DWORD dwResolution,
                         LPVOID pTimerProc,
                         DWORD dwInstanceData )
{
    DDHELPDATA  hd;

    if( (dwResolution != 0) && (pTimerProc != NULL)  )
    {
        hd.req = DDHELPREQ_CREATETIMER;
        hd.pData1 = pTimerProc;
        hd.dwData1 = dwResolution;
        hd.dwData2 = dwInstanceData;
        DPF( 3, "Asking DDHELP to Create Timer" );
        sendRequest( &hd );
        return hd.dwReturn;
    }
    else
    {
        DPF( 3, "Helper Wave Close param error");
        return MMSYSERR_ERROR;
    }

} /* HelperCreateTimer */

/*
 * HelperKillTimer
 *
 * get the helper to load a DLL for us.
 */
DWORD HelperKillTimer( DWORD dwTimerID )
{
    DDHELPDATA  hd;

    if( (dwTimerID != 0) )
    {
        hd.req = DDHELPREQ_KILLTIMER;
        hd.dwData1 = dwTimerID;
        DPF( 3, "Asking DDHELP to KILL Timer %X", dwTimerID );
        sendRequest( &hd );
        return hd.dwReturn;
    }
    else
    {
        DPF( 3, "Helper Wave Close param error");
        return MMSYSERR_ERROR;
    }

} /* HelperKillTimer */

/*
 * HelperCreateDSMixerThread
 *
 * get the helper to create a mixer thread.
 */
HANDLE HelperCreateDSMixerThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
                                  LPDWORD pdwThreadParam,
                                  DWORD dwFlags,
                                  LPDWORD pThreadId )
{
    DDHELPDATA  hd;

    hd.req = DDHELPREQ_CREATEDSMIXERTHREAD;
    hd.pData1 = pfnThreadFunc;
    hd.dwData1 = (DWORD)pdwThreadParam;
    hd.dwData2 = dwFlags;
    hd.pData2 = pThreadId;

    sendRequest( &hd );
    return (HANDLE)hd.dwReturn;
} /* HelperCreateDSMixerThread

/*
 * HelperCreateDSFocusThread
 *
 * get the helper to create a sound focus thread.
 */
HANDLE HelperCreateDSFocusThread( LPTHREAD_START_ROUTINE pfnThreadFunc,
                                  LPDWORD pdwThreadParam,
                                  DWORD dwFlags,
                                  LPDWORD pThreadId )
{
    DDHELPDATA  hd;

    hd.req = DDHELPREQ_CREATEDSFOCUSTHREAD;
    hd.pData1 = pfnThreadFunc;
    hd.dwData1 = (DWORD)pdwThreadParam;
    hd.dwData2 = dwFlags;
    hd.pData2 = pThreadId;

    sendRequest( &hd );
    return (HANDLE)hd.dwReturn;
} /* HelperCreateDSFocusThread

/*
 * HelperCallDSEmulatorCleanup
 *
 * Call the DirectSound function which cleans up MMSYSTEM handles
 */
void HelperCallDSEmulatorCleanup( LPVOID callback,
                                  LPVOID pDirectSound )
{
    DDHELPDATA  hd;

    hd.req = DDHELPREQ_CALLDSCLEANUP;
    hd.pData1 = callback;
    hd.pData2 = pDirectSound;

    sendRequest( &hd );
}

#endif //not winnt -just for now-jeffno

/*
 * HelperCreateModeSetThread
 *
 * get the helper to load a DLL for us.
 */
BOOL HelperCreateModeSetThread(
                LPVOID callback,
                HANDLE *ph,
                LPVOID lpdd,
                DWORD hInstance )
{
    DDHELPDATA  hd;
    HANDLE      h;
    char        str[64];

    hd.req = DDHELPREQ_CREATEMODESETTHREAD;
    hd.lpModeSetNotify = callback;
    hd.pData1 = lpdd;
    hd.dwData1 = hInstance;
    sendRequest( &hd );
    wsprintf( str, DDHELP_MODESET_EVENT_NAME, hInstance );
    DPF( 3, "Trying to open event \"%s\"", str );
    h = OpenEvent( SYNCHRONIZE, FALSE, str );
    if( h == NULL )
    {
        DPF( 3, "Could not open modeset event!" );
        *ph = NULL;
        return FALSE;
    }
    *ph = h;
    DPF( 1, "HelperCreateModeSetThread GotEvent: %08lx", h );
    return TRUE;

} /* HelperCreateModeSetThread */

/*
 * HelperKillModeSetThread
 *
 * get the helper to load a DLL for us.
 */
void HelperKillModeSetThread( DWORD hInstance )
{
    DDHELPDATA  hd;

    hd.req = DDHELPREQ_KILLMODESETTHREAD;
    hd.dwData1 = hInstance;
    sendRequest( &hd );

} /* HelperKillModeSetThread */

#ifdef WIN95
/*
 * HelperCreateDOSBoxThread
 *
 * get the helper to create a thread so kernel mode can notify us of DOS box
 * changes.
 */
BOOL HelperCreateDOSBoxThread(
                LPVOID callback,
                HANDLE *ph,
                LPVOID lpdd,
                DWORD hInstance )
{
    DDHELPDATA  hd;
    HANDLE      h;
    char        str[64];

    hd.req = DDHELPREQ_CREATEDOSBOXTHREAD;
    hd.lpModeSetNotify = callback;
    hd.pData1 = lpdd;
    hd.dwData1 = hInstance;
    sendRequest( &hd );
    wsprintf( str, DDHELP_DOSBOX_EVENT_NAME, hInstance );
    DPF( 3, "Trying to open event \"%s\"", str );
    h = OpenEvent( SYNCHRONIZE, FALSE, str );
    if( h == NULL )
    {
        DPF( 3, "Could not open DOS box event!" );
        *ph = NULL;
        return FALSE;
    }
    *ph = h;
    DPF( 1, "HelperCreateDOSBoxThread GotEvent: %08lx", h );
    return TRUE;

} /* HelperCreateDOSBoxThread */

/*
 * HelperKillDOSBoxThread
 *
 * get the helper to load a DLL for us.
 */
void HelperKillDOSBoxThread( DWORD hInstance )
{
    DDHELPDATA  hd;

    hd.req = DDHELPREQ_KILLDOSBOXTHREAD;
    hd.dwData1 = hInstance;
    sendRequest( &hd );

} /* HelperKillDOSBoxThread */

#endif //!winnt

// notify dphelp.c that we have a new server on this system
DWORD HelperAddDPlayServer(DWORD port)
{
    DDHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

        memset(&hd, 0, sizeof(DDHELPDATA));
    hd.req = DDHELPREQ_DPLAYADDSERVER;
    hd.pid = pid;
    hd. dwData1 = port;
    if (sendRequest(&hd))
                return (DWORD)hd.dwReturn;
        else
                return ((DWORD) E_FAIL);
} // HelperAddDPlayServer

// server is going away
BOOL HelperDeleteDPlayServer(void)
{
    DDHELPDATA hd;
    DWORD pid = GetCurrentProcessId();

    hd.req = DDHELPREQ_DPLAYDELETESERVER;
    hd.pid = pid;
    return sendRequest(&hd);

} // HelperDeleteDPlayServer

#ifdef WIN95
    /*
     * Get DDHELP to load the DirectSound VXD (if it has not
     * already done so) and return a handle to the VXD)
     */
    HANDLE HelperGetDSVxd( void )
    {
        DDHELPDATA hd;
        hd.req = DDHELPREQ_GETDSVXDHANDLE;
        sendRequest( &hd );
        return (HANDLE) hd.dwReturn;
    } /* HelperGetDSVxd */

    /*
     * Get DDHELP to load the DirectDraw VXD (if it has not
     * already done so) and return a handle to the VXD)
     */
    HANDLE HelperGetDDVxd( void )
    {
        DDHELPDATA hd;
        hd.req = DDHELPREQ_GETDDVXDHANDLE;
        sendRequest( &hd );
        return (HANDLE) hd.dwReturn;
    } /* HelperGetDDVxd */

#endif /* WIN95 */

/*
 * HelperSetOnDisplayChangeNotify
 *
 * get the helper to call us back if there is DisplayChange
 * message. (This is for multi-mon topology changes.)
 */
void HelperSetOnDisplayChangeNotify( void *pfn )
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_NOTIFYONDISPLAYCHANGE;
    hd.dwData1 = (DWORD_PTR)pfn;
    sendRequest( &hd );
    return;
}

HINSTANCE HelperLoadLibrary(LPCSTR pszLibraryName)
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_LOADLIBRARY;
    hd.dwData1 = (DWORD_PTR)pszLibraryName;
    sendRequest(&hd);
    return (HINSTANCE)hd.dwReturn;
}

BOOL HelperFreeLibrary(HINSTANCE hInst)
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_FREELIBRARY;
    hd.dwData1 = (DWORD_PTR)hInst;
    sendRequest(&hd);
    return (BOOL)hd.dwReturn;
}

void HelperAddDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC lpNotify)
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_ADDDEVICECHANGENOTIFY;
    hd.pData1 = lpNotify;
    sendRequest(&hd);
}

void HelperDelDeviceChangeNotify(LPDEVICECHANGENOTIFYPROC lpNotify)
{
    DDHELPDATA hd;
    hd.req = DDHELPREQ_DELDEVICECHANGENOTIFY;
    hd.pData1 = lpNotify;
    sendRequest(&hd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\common\pch.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// pch.cpp
//
// Precompiled header file.
//
///////////////////////////////////////////////////////////////////////////////
#include "refdev.hpp"
///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\common\dxtn.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// dxtn.cpp
//
// Direct3D Reference Rasterizer - DXTn texture compression functions
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"

// Primary color components (use DirextX byte ordering)
#undef RED
#define RED   0
#undef GRN
#define GRN   1
#undef BLU
#define BLU   2
#undef ALFA
#define ALFA 3

typedef struct
{
    float       rgba[4];
} FCOLOR;       // internal color format

//
// Processing all primaries is such a common idiom
// that we define a macro for this action.
// Any self-respecting C compiler should easily optimize
// this by unrolling the loop!
//
#define ForAllPrimaries     for( primary = 0; primary < NUM_PRIMARIES; ++primary)

// Similarly, processing all pixels in a block is a common idiom.
#define ForAllPixels        for(pixel=0; pixel < DXT_BLOCK_PIXELS; ++pixel)

#define NUM_PRIMARIES   3
#define NUM_COMPONENTS  4
//
// Quantization constants for RGB565
//
#define PRIMARY_BITS    8

#define RED_BITS    5
#define GRN_BITS    6
#define BLU_BITS    5

#define RED_SHIFT       (PRIMARY_BITS-RED_BITS)
#define GRN_SHIFT       (PRIMARY_BITS-GRN_BITS)
#define BLU_SHIFT       (PRIMARY_BITS-BLU_BITS)

#if 0
#define RED_MASK    0xf8
#define GRN_MASK    0xfc
#define BLU_MASK    0xf8
#endif

// Weighting for each primary based on NTSC luminance
static  float   wtPrimary[NUM_PRIMARIES] =
{
    0.0820f,    // blue
    0.6094f,    // green
    0.3086f     // red
};

//-----------------------------------------------------------------------------
//
// unpack a fixed point color
//
//-----------------------------------------------------------------------------
static  void    RGBToColor (RGB565 *prgb, DXT_COLOR *pcolor)
{
    WORD    rgb;
    DXT_COLOR      color;

    rgb = *((WORD *)prgb);

    // pick off bits in groups of 5, 6, and 5
    color.rgba[BLU] = (unsigned char) rgb;
    rgb >>= BLU_BITS;
    color.rgba[GRN] = (unsigned char) rgb;
    rgb >>= GRN_BITS;
    color.rgba[RED] = (unsigned char) rgb;

    // shift primaries into the appropriate LSBs
    color.rgba[BLU] <<= BLU_SHIFT;
    color.rgba[GRN] <<= GRN_SHIFT;
    color.rgba[RED] <<= RED_SHIFT;

    // replicate primaries MSBs into LSBs
    color.rgba[BLU] |= color.rgba[BLU] >> BLU_BITS;
    color.rgba[GRN] |= color.rgba[GRN] >> GRN_BITS;
    color.rgba[RED] |= color.rgba[RED] >> RED_BITS;

    *pcolor = color;
}

//-----------------------------------------------------------------------------
//
// DecodeBlockRGB - decompress a color block
//
//-----------------------------------------------------------------------------
void DecodeBlockRGB (DXTBlockRGB *pblockSrc, DXT_COLOR colorDst[DXT_BLOCK_PIXELS])
{
    int     lev;
    DXT_COLOR      clut[4];
    PIXBM   pixbm;
    int     pixel;
    int     primary;

    // if source block is invalid, ...
    if (pblockSrc == NULL)
        return;

    // determine the number of color levels in the block
    lev = (pblockSrc->rgb0 <= pblockSrc->rgb1) ? 2 : 3;

    // Fill extrema values into pixel code lookup table.
    RGBToColor(&pblockSrc->rgb0, &clut[0]);
    RGBToColor(&pblockSrc->rgb1, &clut[1]);

    clut[0].rgba[ALFA] =
    clut[1].rgba[ALFA] =
    clut[2].rgba[ALFA] = 255;

    if (lev == 3)
    {   // No transparency info present, all color info.
        ForAllPrimaries
        {
            WORD temp0 = clut[0].rgba[primary];   // jvanaken fixed overflow bug
            WORD temp1 = clut[1].rgba[primary];
            clut[2].rgba[primary] = (BYTE)((2*temp0 + temp1 + 1)/3);
            clut[3].rgba[primary] = (BYTE)((temp0 + 2*temp1 + 1)/3);
        }
        clut[3].rgba[ALFA] = 255;
    }
    else
    {   // transparency info.
        ForAllPrimaries
        {
            WORD temp0 = clut[0].rgba[primary];   // jvanaken fixed overflow bug
            WORD temp1 = clut[1].rgba[primary];
            clut[2].rgba[primary] = (BYTE)((temp0 + temp1)/2);
            clut[3].rgba[primary] = 0;     // jvanaken added this
        }
        clut[3].rgba[ALFA] = 0;
    }

    // munge a local copy
    pixbm = pblockSrc->pixbm;

    // Look up the actual pixel color in the table.
    ForAllPixels
    {
        // lookup color from pixel bitmap
        ForAllPrimaries
            colorDst[pixel].rgba[primary] = clut[pixbm & 3].rgba[primary];

        colorDst[pixel].rgba[ALFA] = clut[pixbm & 3].rgba[ALFA];

        // prepare to extract next index
        pixbm >>= 2;
    }
}

//-----------------------------------------------------------------------------
// DecodeBlockAlpha4 - decompress a block with alpha at 4 BPP
//-----------------------------------------------------------------------------
void DecodeBlockAlpha4(DXTBlockAlpha4 *pblockSrc, DXT_COLOR colorDst[DXT_BLOCK_PIXELS])
{
    int     row, col;
    WORD    alpha;

    DecodeBlockRGB(&pblockSrc->rgb, colorDst);

    for (row = 0; row < 4; ++row)
    {
        alpha = pblockSrc->alphabm[row];

        for (col = 0; col < 4; ++col)
        {
            colorDst[4 * row + col].rgba[ALFA] =
                 ((alpha & 0xf) << 4)
                | (alpha & 0xf);
            alpha >>= 4;
        }
    }
}

//-----------------------------------------------------------------------------
//
// DecodeBlockAlpha3 - decompress a block with alpha at 3 BPP
//
//-----------------------------------------------------------------------------
void DecodeBlockAlpha3(DXTBlockAlpha3 *pblockSrc, DXT_COLOR colorDst[DXT_BLOCK_PIXELS])
{
    int     pixel;
    int     alpha[8];       // alpha lookup table
    DWORD   dwBM = 0;       // alpha bitmap in DWORD cache

    DecodeBlockRGB(&pblockSrc->rgb, colorDst);

    alpha[0] = pblockSrc->alpha0;
    alpha[1] = pblockSrc->alpha1;

    if (alpha[0] > alpha[1]) // 8 alpha ramp
    {   // interpolate intermediate colors
        alpha[2] = (6 * alpha[0] + 1 * alpha[1]) / 7;
        alpha[3] = (5 * alpha[0] + 2 * alpha[1]) / 7;
        alpha[4] = (4 * alpha[0] + 3 * alpha[1]) / 7;
        alpha[5] = (3 * alpha[0] + 4 * alpha[1]) / 7;
        alpha[6] = (2 * alpha[0] + 5 * alpha[1]) / 7;
        alpha[7] = (1 * alpha[0] + 6 * alpha[1]) / 7;
    }
    else // else 6 alpha ramp with 0 and 255
    {   // interpolate intermediate colors
        alpha[2] = (4 * alpha[0] + 1 * alpha[1]) / 5;
        alpha[3] = (3 * alpha[0] + 2 * alpha[1]) / 5;
        alpha[4] = (2 * alpha[0] + 3 * alpha[1]) / 5;
        alpha[5] = (1 * alpha[0] + 4 * alpha[1]) / 5;
        alpha[6] = 0;
        alpha[7] = 255;
    }

    ForAllPixels
    {   // reload bitmap dword cache every 8 pixels
        if ((pixel & 7) == 0)
        {
            if (pixel == 0)
            {   // pack 3 bytes into dword
                dwBM  = pblockSrc->alphabm[2];
                dwBM <<= 8;
                dwBM |= pblockSrc->alphabm[1];
                dwBM <<= 8;
                dwBM |= pblockSrc->alphabm[0];
            }
            else // pixel == 8
            {   // pack 3 bytes into dword
                dwBM  = pblockSrc->alphabm[5];
                dwBM <<= 8;
                dwBM |= pblockSrc->alphabm[4];
                dwBM <<= 8;
                dwBM |= pblockSrc->alphabm[3];
            }
        }

        // unpack bitmap dword 3 bits at a time
        colorDst[pixel].rgba[ALFA] = (BYTE)alpha[(dwBM & 7)];
        dwBM >>= 3;
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\common\maplegcy.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// MapLegcy.cpp
//
// Direct3D Reference Rasterizer - Mapping Legacy Modes to Current Functionality
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// MapLegacyTextureFilter - Map filter state from renderstate to per-stage state.
// This is invoked when a texture is bound via the TEXTUREHANDLE renderstate,
// indicating that we are in 'legacy' texture mode.  The rasterizer always
// refers to per-stage filtering control state, so in legacy mode the filtering
// controls in the renderstate are mapped into the filtering controls associated
// with the texture object bound to D3DRS_TEXTUREHANDLE.
//
//-----------------------------------------------------------------------------
void
RefDev::MapLegacyTextureFilter( void )
{
    // first check if anisotropic filtering is enabled (indicated by the
    // limit value being set to > 1) - if so then aniso filter will be used
    // for linear mag filter or 'linear within map' min filter
    BOOL bAnisoEnabled = ( m_dwRenderState[D3DRENDERSTATE_ANISOTROPY] > 1 );

    // D3D legacy filter specifications are (XXXMIP)YYY where XXX is the
    // mip filter and YYY is the filter used within an LOD

    // map MAG filter - legacy support is point or linear (and maybe aniso)
    switch ( m_dwRenderState[D3DRENDERSTATE_TEXTUREMAG] )
    {
    default:
    case D3DFILTER_NEAREST:
        m_TextureStageState[0].m_dwVal[D3DTSS_MAGFILTER] = D3DTEXF_POINT;
        break;
    case D3DFILTER_LINEAR:
        // select based on aniso enable
        m_TextureStageState[0].m_dwVal[D3DTSS_MAGFILTER] =
            bAnisoEnabled ? D3DTEXF_ANISOTROPIC : D3DTEXF_LINEAR;
        break;
    }
    // map MIN and MIP filter at the same time - legacy support
    // has them intermingled...
    switch ( m_dwRenderState[D3DRENDERSTATE_TEXTUREMIN] )
    {
    case D3DFILTER_NEAREST:
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] = D3DTEXF_POINT;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTEXF_NONE;
        break;
    case D3DFILTER_MIPNEAREST:
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] = D3DTEXF_POINT;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTEXF_POINT;
        break;
    case D3DFILTER_LINEARMIPNEAREST:
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] = D3DTEXF_POINT;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTEXF_LINEAR;
        break;
    case D3DFILTER_LINEAR:
        // select min filter based on aniso enable
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] =
            bAnisoEnabled ? D3DTEXF_ANISOTROPIC : D3DTEXF_LINEAR;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTEXF_NONE;
        break;
    case D3DFILTER_MIPLINEAR:
        // select min filter based on aniso enable
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] =
            bAnisoEnabled ? D3DTEXF_ANISOTROPIC : D3DTEXF_LINEAR;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTEXF_POINT;
        break;
    case D3DFILTER_LINEARMIPLINEAR:
        // select based on aniso enable
        m_TextureStageState[0].m_dwVal[D3DTSS_MINFILTER] =
            bAnisoEnabled ? D3DTEXF_ANISOTROPIC : D3DTEXF_LINEAR;
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPFILTER] = D3DTEXF_LINEAR;
        break;
    }
}


//-----------------------------------------------------------------------------
//
// MapLegacyTextureBlend - Maps legacy (pre-DX6) texture blend modes to DX6
// texture blending controls.  Uses per-stage program mode (first stage only).
// This mapping is done whenever the legacy TBLEND renderstate is set, and
// does overwrite any previously set DX6 texture blending controls.
//
//-----------------------------------------------------------------------------
void
RefDev::MapLegacyTextureBlend( void )
{
    // disable texture blend processing stage 1 (this also disables subsequent stages)
    m_TextureStageState[1].m_dwVal[D3DTSS_COLOROP] = D3DTOP_DISABLE;

    // set texture blend processing stage 0 to match legacy mode
    switch ( m_dwRenderState[D3DRENDERSTATE_TEXTUREMAPBLEND] )
    {
    default:
    case D3DTBLEND_DECALMASK: // unsupported - do decal
    case D3DTBLEND_DECAL:
    case D3DTBLEND_COPY:
        m_TextureStageState[0].m_dwVal[D3DTSS_COLOROP]   = D3DTOP_SELECTARG1;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG1;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        break;

    case D3DTBLEND_MODULATEMASK: // unsupported - do modulate
    case D3DTBLEND_MODULATE:
        m_TextureStageState[0].m_dwVal[D3DTSS_COLOROP]   = D3DTOP_MODULATE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        // a special legacy alpha operation is called for that depends
        // on the format of the texture
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAOP]   = D3DTOP_LEGACY_ALPHAOVR;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_MODULATEALPHA:
        m_TextureStageState[0].m_dwVal[D3DTSS_COLOROP]   = D3DTOP_MODULATE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAOP]   = D3DTOP_MODULATE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_DECALALPHA:
        m_TextureStageState[0].m_dwVal[D3DTSS_COLOROP]   = D3DTOP_BLENDTEXTUREALPHA;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG2;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;

    case D3DTBLEND_ADD:
        m_TextureStageState[0].m_dwVal[D3DTSS_COLOROP]   = D3DTOP_ADD;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_COLORARG2] = D3DTA_DIFFUSE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAOP]   = D3DTOP_SELECTARG2;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG1] = D3DTA_TEXTURE;
        m_TextureStageState[0].m_dwVal[D3DTSS_ALPHAARG2] = D3DTA_DIFFUSE;
        break;
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\common\rdsurf.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// texmap.cpp
//
// Direct3D Reference Rasterizer - Texture Map Access Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// FindOutSurfFormat
//
// Converts a DDPIXELFORMAT to RDSurfaceFormat.
//
//----------------------------------------------------------------------------
HRESULT FASTCALL
FindOutSurfFormat(LPDDPIXELFORMAT  pDdPixFmt,
                  RDSurfaceFormat* pFmt,
                  BOOL*   pbIsDepth)
{
    if( pbIsDepth ) *pbIsDepth = FALSE;

    if (pDdPixFmt->dwFourCC == D3DFMT_Q8W8V8U8 )
    {
        *pFmt = RD_SF_U8V8W8Q8;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_W11V11U10 )
    {
        *pFmt = RD_SF_U10V11W11;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_V16U16 )
    {
        *pFmt = RD_SF_U16V16;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_R8G8B8 )
    {
        *pFmt = RD_SF_B8G8R8;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_A8 )
    {
        *pFmt = RD_SF_A8;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_A8P8 )
    {
        *pFmt = RD_SF_P8A8;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_X4R4G4B4 )
    {
        *pFmt = RD_SF_B4G4R4X4;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_A2B10G10R10)
    {
        *pFmt = RD_SF_R10G10B10A2;
    }
#if 0
    else if (pDdPixFmt->dwFourCC == D3DFMT_A8B8G8R8)
    {
        *pFmt = RD_SF_R8G8B8A8;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_X8B8G8R8)
    {
        *pFmt = RD_SF_R8G8B8X8;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_W10V11U11)
    {
        *pFmt = RD_SF_U11V11W10;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_A8X8V8U8)
    {
        *pFmt = RD_SF_U8V8X8A8;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_L8X8V8U8)
    {
        *pFmt = RD_SF_U8V8X8L8;
    }
#endif
    else if (pDdPixFmt->dwFourCC == D3DFMT_G16R16)
    {
        *pFmt = RD_SF_R16G16;
    }
    else if (pDdPixFmt->dwFourCC == D3DFMT_A2W10V10U10)
    {
        *pFmt = RD_SF_U10V10W10A2;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('U', 'Y', 'V', 'Y'))
    {
        *pFmt = RD_SF_UYVY;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('Y', 'U', 'Y', '2'))
    {
        *pFmt = RD_SF_YUY2;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '1'))
    {
        *pFmt = RD_SF_DXT1;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '2'))
    {
        *pFmt = RD_SF_DXT2;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '3'))
    {
        *pFmt = RD_SF_DXT3;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '4'))
    {
        *pFmt = RD_SF_DXT4;
    }
    else if (pDdPixFmt->dwFourCC == MAKEFOURCC('D', 'X', 'T', '5'))
    {
        *pFmt = RD_SF_DXT5;
    }
    else if (pDdPixFmt->dwFourCC == 0xFF000004)
    {
        // This is an example of a IHV-specific format
        // The HIWORD must be the PCI-ID of the IHV
        // and the third byte must be zero.
        // In this case, we're using a sample PCI-ID of
        // FF00, and we're denoting the 4th format
        // by that PCI-ID
        *pFmt = RD_SF_Z32S0;
    }
    else if (pDdPixFmt->dwFlags & DDPF_ZBUFFER)
    {
        if( pbIsDepth ) *pbIsDepth = TRUE;
        switch(pDdPixFmt->dwZBitMask)
        {
        default:
        case 0x0000FFFF: *pFmt = RD_SF_Z16S0; break;
        case 0xFFFFFF00:
            switch(pDdPixFmt->dwStencilBitMask)
            {
            default:
            case 0x00000000: *pFmt = RD_SF_Z24X8; break;
            case 0x000000FF: *pFmt = RD_SF_Z24S8; break;
            case 0x0000000F: *pFmt = RD_SF_Z24X4S4; break;
            }
            break;
        case 0x00FFFFFF:
            switch(pDdPixFmt->dwStencilBitMask)
            {
            default:
            case 0x00000000: *pFmt = RD_SF_X8Z24; break;
            case 0xFF000000: *pFmt = RD_SF_S8Z24; break;
            case 0x0F000000: *pFmt = RD_SF_X4S4Z24; break;
            }
            break;
        case 0x0000FFFE: *pFmt = RD_SF_Z15S1; break;
        case 0x00007FFF: *pFmt = RD_SF_S1Z15; break;
        case 0xFFFFFFFF: *pFmt = RD_SF_Z32S0; break;
        }
    }
    else if (pDdPixFmt->dwFlags & DDPF_BUMPDUDV)
    {
        UINT uFmt = pDdPixFmt->dwBumpDvBitMask;
        switch (uFmt)
        {
        case 0x0000ff00:
            switch (pDdPixFmt->dwRGBBitCount)
            {
            case 32:
                *pFmt = RD_SF_U8V8L8X8;
                break;
            case 16:
                *pFmt = RD_SF_U8V8;
                break;
            }
            break;

        case 0x000003e0:
            *pFmt = RD_SF_U5V5L6;
            break;
        }
    }
    else if (pDdPixFmt->dwFlags & DDPF_PALETTEINDEXED8)
    {
        if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
        {
            *pFmt = RD_SF_P8A8;
        }
        else
        {
            *pFmt = RD_SF_PALETTE8;
        }
    }
    else if (pDdPixFmt->dwFlags & DDPF_PALETTEINDEXED4)
    {
        *pFmt = RD_SF_PALETTE4;
    }
    else if (pDdPixFmt->dwFlags & DDPF_ALPHA)
    {
        if (pDdPixFmt->dwAlphaBitDepth == 8)
        {
            *pFmt = RD_SF_A8;
        }
        else
        {
            *pFmt = RD_SF_NULL;
        }
    }
    else
    {
        UINT uFmt = pDdPixFmt->dwGBitMask | pDdPixFmt->dwRBitMask;

        if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
        {
            uFmt |= pDdPixFmt->dwRGBAlphaBitMask;
        }

        switch (uFmt)
        {
        case 0x00ffff00:
            switch (pDdPixFmt->dwRGBBitCount)
            {
            case 32:
                *pFmt = RD_SF_B8G8R8X8;
                break;
            case 24:
                *pFmt = RD_SF_B8G8R8;
                break;
            }
            break;
        case 0xffffff00:
            *pFmt = RD_SF_B8G8R8A8;
            break;
        case 0xffe0:
            if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
            {
                *pFmt = RD_SF_B5G5R5A1;
            }
            else
            {
                *pFmt = RD_SF_B5G6R5;
            }
            break;
        case 0x07fe0:
            *pFmt = RD_SF_B5G5R5X1;
            break;
        case 0xff0:
            *pFmt = RD_SF_B4G4R4X4;
            break;
        case 0xfff0:
            *pFmt = RD_SF_B4G4R4A4;
            break;
        case 0xff:
            if (pDdPixFmt->dwFlags & DDPF_ALPHAPIXELS)
            {
                *pFmt = RD_SF_L4A4;
            }
            else
            {
                *pFmt = RD_SF_L8;
            }
            break;
        case 0xffff:
            *pFmt = RD_SF_L8A8;
            break;
        case 0xfc:
            *pFmt = RD_SF_B2G3R3;
            break;
        case 0xfffc:
            *pFmt = RD_SF_B2G3R3A8;
            break;
        default:
            *pFmt = RD_SF_NULL;
            break;
        }
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// ValidMipmapSize
//
// Computes size of next smallest mipmap level, clamping at 1
//
//----------------------------------------------------------------------------
BOOL FASTCALL
ValidMipmapSize(INT16 iPreSize, INT16 iSize)
{
    if (iPreSize == 1)
    {
        if (iSize == 1)
        {
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
    else
    {
        return ((iPreSize >> 1) == iSize);
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// RDPalette
//
//////////////////////////////////////////////////////////////////////////////
const DWORD RDPalette::RDPAL_ALPHAINPALETTE = (1 << 0);
const DWORD RDPalette::m_dwNumEntries = 256;

HRESULT
RDPalette::Update( WORD StartIndex, WORD wNumEntries, PALETTEENTRY* pEntries )
{
    _ASSERT( StartIndex < m_dwNumEntries, "Bad StartIndex\n" );
    _ASSERT( StartIndex+wNumEntries <= m_dwNumEntries, "Too many entries\n" );

    for( WORD i = 0; i < wNumEntries; i++ )
    {
        m_Entries[StartIndex+i] = D3DCOLOR_ARGB( pEntries[i].peFlags,
                                                 pEntries[i].peRed,
                                                 pEntries[i].peGreen,
                                                 pEntries[i].peBlue );
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
//
// Constructor/Destructor
//
//-----------------------------------------------------------------------------
RDSurface2D::RDSurface2D( void )
{
    m_pRefDev = NULL;
    m_uFlags = 0;
    m_iWidth = 0;
    m_iHeight = 0;
    m_iDepth = 0;
    m_cLOD = 0;
    m_SurfFormat = RD_SF_NULL;
    m_dwColorKey = 0;
    m_dwEmptyFaceColor = 0;
    m_pPalette = 0;
    m_pPalObj = NULL;
    m_cLODDDS = 0;
    m_hTex = 0;
    m_bHasAlpha = 0;

    memset(m_pBits, 0, sizeof(m_pBits));
    memset(m_iPitch, 0, sizeof(m_iPitch));
    memset(m_iSlicePitch, 0, sizeof(m_iSlicePitch));
    memset(m_pDDSLcl, 0, sizeof(m_pDDSLcl));

    m_cDimension = 0;
    memset(m_fTexels, 0, sizeof(m_fTexels));
    memset(m_cTexels, 0, sizeof(m_cTexels));
}
//-----------------------------------------------------------------------------
RDSurface2D::~RDSurface2D( void )
{
}

DWORD
RDSurface2D::ComputePitch( LPDDRAWI_DDRAWSURFACE_LCL pLcl,
                           RDSurfaceFormat SurfFormat,
                           DWORD width, DWORD height ) const
{
    if ((SurfFormat == RD_SF_DXT1) ||
        (SurfFormat == RD_SF_DXT2) ||
        (SurfFormat == RD_SF_DXT3) ||
        (SurfFormat == RD_SF_DXT4) ||
        (SurfFormat == RD_SF_DXT5))
    {
        // Note, here is the assumption that:
        // 1) width and height are reported correctly by the runtime.
        // 2) The allocation of the memory is contiguous (as done by hel)
        return (((width+3)>>2) *
                g_DXTBlkSize[(int)SurfFormat - (int)RD_SF_DXT1]);
    }
#if 0
    else if( (SurfFormat == RD_SF_YUY2) ||
             (SurfFormat == RD_SF_UYVY) )
    {
        // Same assumptions as for DXTn.
        return (DDSurf_Pitch(pLcl)/height);
    }
#endif
    else
    {
        return DDSurf_Pitch(pLcl);
    }
}

DWORD
RDSurface2D::ComputePitch( LPDDRAWI_DDRAWSURFACE_LCL pLcl ) const
{
    return ComputePitch( pLcl, m_SurfFormat, m_iWidth, m_iHeight );
}

//-----------------------------------------------------------------------------
//
// RDSurface2D::Initialize()
//
//-----------------------------------------------------------------------------
HRESULT
RDSurface2D::Initialize( LPDDRAWI_DDRAWSURFACE_LCL pLcl )
{
    HRESULT hr = D3D_OK;
    RDSurfaceFormat SurfFormat;
    DDSCAPS2 ddscaps;
    LPDDRAWI_DDRAWSURFACE_GBL  pGbl = pLcl->lpGbl;
    LPDDRAWI_DDRAWSURFACE_MORE pMore = pLcl->lpSurfMore;
    memset(&ddscaps, 0, sizeof(ddscaps));

    UINT wMultiSampleCount = 0xfL & pMore->ddsCapsEx.dwCaps3;
    //Older than DX8 runtimes place a zero in this field
    if (wMultiSampleCount == 0)
        wMultiSampleCount = 1;

    if( pLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE )
        m_SurfType |= RR_ST_TEXTURE;

    if( pLcl->ddsCaps.dwCaps & DDSCAPS_ZBUFFER )
    {
        m_iSamples = wMultiSampleCount;
        m_SurfType |= RR_ST_RENDERTARGETDEPTH;
    }

    if( pLcl->ddsCaps.dwCaps & DDSCAPS_3DDEVICE )
    {
        m_iSamples = wMultiSampleCount;
        m_SurfType |= RR_ST_RENDERTARGETCOLOR;
    }

    m_iWidth = DDSurf_Width(pLcl);
    m_iHeight = DDSurf_Height(pLcl);
    HR_RET(FindOutSurfFormat(&(DDSurf_PixFmt(pLcl)), &SurfFormat, NULL));
    m_SurfFormat = SurfFormat;

    if (pMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
    {
        // low word of ddsCaps.ddsCapsEx.dwCaps4 has depth
        // (volume texture only).
        m_iDepth = LOWORD(pMore->ddsCapsEx.dwCaps4);
    }
    else
    {
        m_iDepth = 0;
    }
    m_cTexels[0][0] = m_iWidth;
    m_cTexels[0][1] = m_iHeight;
    m_cTexels[0][2] = m_iDepth;
    m_fTexels[0][0] = (float)m_cTexels[0][0];
    m_fTexels[0][1] = (float)m_cTexels[0][1];
    m_fTexels[0][2] = (float)m_cTexels[0][2];

    m_cLOD = 0;

    if( wMultiSampleCount > 1 )
    {
        RDCREATESURFPRIVATE* pPriv = (RDCREATESURFPRIVATE*)pGbl->dwReserved1;
        m_pBits[0]  = pPriv->pMultiSampleBits;
        m_iPitch[0] = pPriv->dwMultiSamplePitch;
    }
    else
    {
        m_pBits[0] = (BYTE *)SURFACE_MEMORY(pLcl);
        m_iPitch[0] = ComputePitch( pLcl );
    }

    if (pMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
    {
        // set slice pitch (volume texture only).
        m_iSlicePitch[0] = pGbl->lSlicePitch;
    }
    else
    {
        m_iSlicePitch[0] = 0;
    }

    // If the surface is not a texture early out.
    if( (pLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE) == 0 )
    {
        SetInitialized();
        return S_OK;
    }

    // Set the transparent bit and the transparent color with pDDS[0]
    if ((pLcl->dwFlags & DDRAWISURF_HASCKEYSRCBLT) != 0)
    {
        m_uFlags |= RR_TEXTURE_HAS_CK;
        m_dwColorKey = pLcl->ddckCKSrcBlt.dwColorSpaceLowValue;
    }
    else
    {
        m_uFlags &= ~RR_TEXTURE_HAS_CK;
    }

    // set the empty face color with pDDS[0]
    // note that ddckCKDestOverlay is unioned with dwEmptyFaceColor,
    // but not in the internal structure
    m_dwEmptyFaceColor = pLcl->ddckCKDestOverlay.dwColorSpaceLowValue;

    if (pMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
    {
        m_uFlags |= RR_TEXTURE_VOLUME;
        m_cDimension = 3;
    }
    else
    {
        m_cDimension = 2;
    }

    // Compute sizes and pitches

    // We need to gather info on all surfaces under the top-level
    // mipmap face (This test is DX7+ runtime dependent)
    if ((0 == (pMore->ddsCapsEx.dwCaps2 & DDSCAPS2_MIPMAPSUBLEVEL)) &&
        (pMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_POSITIVEX) )
    {
        m_uFlags |= RR_TEXTURE_CUBEMAP;

        LPDDRAWI_DDRAWSURFACE_LCL pDDSNextLcl;
        ddscaps.dwCaps = DDSCAPS_TEXTURE;

        m_pDDSLcl[0]     = pLcl;
        m_pBits[0]       = (BYTE *)SURFACE_MEMORY(m_pDDSLcl[0]);
        m_iPitch[0]      = ComputePitch( m_pDDSLcl[0] );
        m_iSlicePitch[0] = 0;

        // get rest of top level surfaces, in order
        for (INT i = 1; i < 6; i++)
        {
            switch(i)
            {
            case 1: ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP_NEGATIVEX; break;
            case 2: ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP_POSITIVEY; break;
            case 3: ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP_NEGATIVEY; break;
            case 4: ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP_POSITIVEZ; break;
            case 5: ddscaps.dwCaps2 = DDSCAPS2_CUBEMAP_NEGATIVEZ; break;
            }
            ddscaps.dwCaps2 |= DDSCAPS2_CUBEMAP;
            pDDSNextLcl = NULL;
            hr = DDGetAttachedSurfaceLcl( pLcl, &ddscaps, &pDDSNextLcl);
            if ((hr != D3D_OK) && (hr != DDERR_NOTFOUND))
            {
                return hr;
            }
            if (hr == DDERR_NOTFOUND)
            {
                m_pDDSLcl[i] = NULL;
                return hr;
            }
            else
            {
                m_pDDSLcl[i] = pDDSNextLcl;
            }

            m_pBits[i]       = (BYTE *)SURFACE_MEMORY(m_pDDSLcl[i]);
            m_iPitch[i]      = ComputePitch( m_pDDSLcl[i] );
            m_iSlicePitch[i] = 0;

            m_cTexels[i][0] = DDSurf_Width(m_pDDSLcl[i]);
            m_cTexels[i][1] = DDSurf_Height(m_pDDSLcl[i]);
            m_fTexels[i][0] = (float)m_cTexels[i][0];
            m_fTexels[i][1] = (float)m_cTexels[i][1];
        }

        for (i = 0; i < 6; i++)
        {
            pLcl = m_pDDSLcl[i];
            m_cLOD = 0;

            if (pLcl)
            {
                // Check for mipmap if any.
                LPDDRAWI_DDRAWSURFACE_LCL  pTmpSLcl;

                // iPreSizeU and iPreSizeV store the size(u and v) of the
                // previous level mipmap. They are init'ed with the first
                // texture size.
                INT16 iPreSizeU = (INT16)m_iWidth;
                INT16 iPreSizeV = (INT16)m_iHeight;
                for (;;)
                {
                    ddscaps.dwCaps = DDSCAPS_TEXTURE;
                    ddscaps.dwCaps2 = DDSCAPS2_MIPMAPSUBLEVEL;
                    pTmpSLcl = NULL;
                    hr = DDGetAttachedSurfaceLcl( pLcl, &ddscaps, &pTmpSLcl);
                    if (hr != D3D_OK && hr != DDERR_NOTFOUND)
                    {
                        return hr;
                    }
                    if (hr == DDERR_NOTFOUND)
                    {
                        break;
                    }
                    pLcl = pTmpSLcl;
                    pGbl  = pLcl->lpGbl;
                    pMore = pLcl->lpSurfMore;
                    m_cLOD ++;
                    INT iMap = m_cLOD*6+i;
                    m_pDDSLcl[iMap] = pLcl;
                    m_pBits[iMap]   = (BYTE *)SURFACE_MEMORY(pLcl);
                    m_iPitch[iMap]  = ComputePitch( pLcl, m_SurfFormat,
                                                    m_iWidth>>m_cLOD,
                                                    m_iHeight>>m_cLOD );
                    if (pMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
                    {
                        // set slice pitch
                        // (volume texture only).
                        m_iSlicePitch[iMap] = pGbl->lSlicePitch;
                    }
                    else
                    {
                        m_iSlicePitch[iMap] = 0;
                    }
                    m_cTexels[iMap][0] = DDSurf_Width(pLcl);
                    m_cTexels[iMap][1] = DDSurf_Height(pLcl);
                    m_fTexels[iMap][0] = (float)m_cTexels[iMap][0];
                    m_fTexels[iMap][1] = (float)m_cTexels[iMap][1];

                    // Check for invalid mipmap texture size
                    if (!ValidMipmapSize(iPreSizeU,
                                         (INT16)DDSurf_Width(pLcl)) ||
                        !ValidMipmapSize(iPreSizeV,
                                         (INT16)DDSurf_Height(pLcl)))
                    {
                        return DDERR_INVALIDPARAMS;
                    }
                    iPreSizeU = (INT16)DDSurf_Width(pLcl);
                    iPreSizeV = (INT16)DDSurf_Height(pLcl);
                }
            }
        }
    }
    else if ((0 == (pMore->ddsCapsEx.dwCaps2 & DDSCAPS2_MIPMAPSUBLEVEL) &&
             (0 == (pMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP))) )

    {
        //This surface is not a top-level cubemap.
        //Maybe it's a top-level mipmap. Go find its sublevels.

        m_pDDSLcl[0] = pLcl;
        // Check for mipmap if any.
        LPDDRAWI_DDRAWSURFACE_LCL pTmpSLcl;
        // iPreSizeU and iPreSizeV store the size(u and v) of the previous
        // level mipmap. They are init'ed with the first texture size.
        INT16 iPreSizeU = (INT16)m_iWidth;
        INT16 iPreSizeV = (INT16)m_iHeight;
        for (;;)
        {
            ddscaps.dwCaps = DDSCAPS_TEXTURE;
            ddscaps.dwCaps2 = DDSCAPS2_MIPMAPSUBLEVEL;
            pTmpSLcl = NULL;
            hr = DDGetAttachedSurfaceLcl( pLcl, &ddscaps, &pTmpSLcl);
            if (hr != D3D_OK && hr != DDERR_NOTFOUND)
            {
                return hr;
            }
            if (hr == DDERR_NOTFOUND)
            {
                break;
            }
            pLcl  = pTmpSLcl;
            pGbl  = pLcl->lpGbl;
            pMore = pLcl->lpSurfMore;
            m_cLOD ++;
            m_pDDSLcl[m_cLOD] = pLcl;

            // Save the pointer to the real bits and the pitch.
            m_pBits[m_cLOD] = (BYTE *)SURFACE_MEMORY(pLcl);
            m_iPitch[m_cLOD] = ComputePitch( pLcl, m_SurfFormat,
                                             m_iWidth>>m_cLOD,
                                             m_iHeight>>m_cLOD );
            if (pMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
            {
                // set slice pitch (volume texture only).
                m_iSlicePitch[m_cLOD] = pGbl->lSlicePitch;
            }
            else
            {
                m_iSlicePitch[m_cLOD] = 0;
            }

            // Check for invalid mipmap texture size
            if (!ValidMipmapSize(iPreSizeU, (INT16)DDSurf_Width(pLcl)) ||
                !ValidMipmapSize(iPreSizeV, (INT16)DDSurf_Height(pLcl)))
            {
                return DDERR_INVALIDPARAMS;
            }
            iPreSizeU = (INT16)DDSurf_Width(pLcl);
            iPreSizeV = (INT16)DDSurf_Height(pLcl);

            m_cTexels[m_cLOD][0] = DDSurf_Width(pLcl);
            m_cTexels[m_cLOD][1] = DDSurf_Height(pLcl);
            if (pMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
                m_cTexels[m_cLOD][2] = LOWORD(pMore->ddsCapsEx.dwCaps4);
            else
                m_cTexels[m_cLOD][2] = 0;
            m_fTexels[m_cLOD][0] = (float)m_cTexels[m_cLOD][0];
            m_fTexels[m_cLOD][1] = (float)m_cTexels[m_cLOD][1];
            m_fTexels[m_cLOD][2] = (float)m_cTexels[m_cLOD][2];
        }
    }

    // Copy the palette
    // UpdatePalette();

    m_cLODDDS = m_cLOD;

    if ( !(Validate()) )
    {
        return DDERR_GENERIC;
    }

    SetInitialized();
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// UpdatePalette
//
//----------------------------------------------------------------------------
void
RDSurface2D::UpdatePalette()
{
    // Update palette
    if (m_SurfFormat == RD_SF_PALETTE8 || m_SurfFormat == RD_SF_PALETTE4 || m_SurfFormat == RD_SF_P8A8 )
    {
#if 0
        // This code needs to be revived in case the DX6 DDI
        //  emulation is ever implemented in RefDev.
        if (m_pDDSLcl[0]->lpDDPalette)
        {
            LPDDRAWI_DDRAWPALETTE_GBL pPal =
                m_pDDSLcl[0]->lpDDPalette->lpLcl->lpGbl;
            m_pPalette = (DWORD*)pPal->lpColorTable;
            if (pPal->dwFlags & DDRAWIPAL_ALPHA)
            {
                m_uFlags |= RR_TEXTURE_ALPHAINPALETTE;
            }
            else
            {
                m_uFlags &= ~RR_TEXTURE_ALPHAINPALETTE;
            }
        }
#endif
        _ASSERT( m_pPalObj, "No Palette set for this paletted texture\n" );
        m_pPalette = m_pPalObj->GetEntries();
        if( m_SurfFormat == RD_SF_PALETTE8 || m_SurfFormat == RD_SF_PALETTE4 )
        {
            if( m_pPalObj->HasAlpha() )
            {
                m_uFlags |= RR_TEXTURE_ALPHAINPALETTE;
            }
            else
            {
                m_uFlags &= ~RR_TEXTURE_ALPHAINPALETTE;
            }
        }
    }
}

//-----------------------------------------------------------------------------
//
// Validate - Updates private data.  Must be called anytime public data is
// altered.
//
//-----------------------------------------------------------------------------
BOOL
RDSurface2D::Validate( void )
{
    // validate inputs
    if ( m_cLOD >= RD_MAX_CLOD ) // too many LODs
    {
        DPFRR(1,"RDSurface2D::Validate failed. Too many LODs");
        return FALSE;
    }

    // compute the 'has alpha' flag
    m_bHasAlpha = FALSE;
    switch ( m_SurfFormat )
    {
    case RD_SF_A8:
    case RD_SF_P8A8:
    case RD_SF_B8G8R8A8:
    case RD_SF_B5G5R5A1:
    case RD_SF_B4G4R4A4:
    case RD_SF_L8A8:
    case RD_SF_L4A4:
    case RD_SF_B2G3R3A8:
    case RD_SF_DXT1:
    case RD_SF_DXT2:
    case RD_SF_DXT3:
    case RD_SF_DXT4:
    case RD_SF_DXT5:
        m_bHasAlpha = TRUE;
        break;
    case RD_SF_PALETTE4:
    case RD_SF_PALETTE8:
        m_bHasAlpha = ( m_uFlags & RR_TEXTURE_ALPHAINPALETTE ) ? TRUE : FALSE;
        break;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------

inline UINT8 CLAMP_BYTE(double f)
{
    if (f > 255.0) return 255;
    if (f < 0.0) return 0;
    return (BYTE) f;
}

//-----------------------------------------------------------------------------
// TexelFromBlock - decompress a color block and obtain texel color
//-----------------------------------------------------------------------------
UINT32 TexelFromBlock(RDSurfaceFormat surfType, char *pblockSrc,
                      int x, int y)
{
    UINT32 index = ((y & 0x3)<<2) + (x & 0x3);
    DDRGBA colorDst[DXT_BLOCK_PIXELS];

    switch(surfType)
    {
    case RD_SF_DXT1:
        DecodeBlockRGB((DXTBlockRGB *)pblockSrc, (DXT_COLOR *)colorDst);
        break;
    case RD_SF_DXT2:
    case RD_SF_DXT3:
        DecodeBlockAlpha4((DXTBlockAlpha4 *)pblockSrc,
                          (DXT_COLOR *)colorDst);
        break;
    case RD_SF_DXT4:
    case RD_SF_DXT5:
        DecodeBlockAlpha3((DXTBlockAlpha3 *)pblockSrc,
                          (DXT_COLOR *)colorDst);
        break;
    }

    return RGBA_MAKE(colorDst[index].red,
                     colorDst[index].green,
                     colorDst[index].blue,
                     colorDst[index].alpha);
}

//-----------------------------------------------------------------------------
//
// ReadTexelColor - Reads texel from texture map at given LOD; converts to
// RDColor format, applying palette if necessary; also performs colorkey by
// returning match information
//
//-----------------------------------------------------------------------------
void
RDSurface2D::ReadColor(
    INT32 iX, INT32 iY, INT32 iZ, INT32 iLOD,
    RDColor& Texel, BOOL &bColorKeyKill )
{
    if ( (iLOD > m_cLOD) && !(m_uFlags & RR_TEXTURE_CUBEMAP) )
    {
        return;
    }
    if ( NULL == m_pBits[iLOD] ) { return; }

    char* pSurfaceBits =
        PixelAddress( iX, iY, iZ, m_pBits[iLOD],
                      m_iPitch[iLOD], m_iSlicePitch[iLOD], m_SurfFormat );

    switch ( m_SurfFormat )
    {
    default:
        Texel.ConvertFrom( m_SurfFormat, pSurfaceBits );
        break;

    case RD_SF_P8A8:
        {
            UINT8 uIndex = *((UINT8*)pSurfaceBits);
            Texel.ConvertFrom( RD_SF_B8G8R8A8, (char*)((UINT32*)m_pPalette + uIndex) );
            Texel.A = *((UINT8*)pSurfaceBits+1)/255.f;
        }
        break;

    case RD_SF_PALETTE8:
        {
            UINT8 uIndex = *((UINT8*)pSurfaceBits);
            Texel.ConvertFrom( RD_SF_B8G8R8A8, (char*)((UINT32*)m_pPalette + uIndex) );
            if ( !( m_uFlags & RR_TEXTURE_ALPHAINPALETTE ) )  Texel.A = 1.f;
        }
        break;

    case RD_SF_PALETTE4:
        {
            UINT8 uIndex = *((INT8*)pSurfaceBits);
            if ((iX & 1) == 0) { uIndex &= 0xf; }
            else               { uIndex >>= 4;  }
            Texel.ConvertFrom( RD_SF_B8G8R8A8, (char*)((UINT32*)m_pPalette + uIndex) );
            if ( !( m_uFlags & RR_TEXTURE_ALPHAINPALETTE ) )  Texel.A = 1.f;
        }
        break;

    case RD_SF_UYVY:
    case RD_SF_YUY2:
        // Converts a given YUV (8bits each) to RGB scaled between 0 and 255
        // These are using the YCrCb to RGB algorithms given on page 30
        // in "VIDEO DEMYSTIFIED" by Keith Jack
        // ISBN#: 1-878707-09-4
        // IN PC graphics, even though they call it YUV, it is really YCrCb
        // formats that are used by most framegrabbers etc. Hence the pixel
        // data we will obtain in these YUV surfaces will most likely be this
        // and not the original YUV which is actually used in PAL broadcast
        // only (NTSC uses YIQ). So really, U should be called Cb (Blue color
        // difference) and V should be called Cr (Red color difference)
        //
        // These equations are meant to handle the following ranges
        // (from the same book):
        // Y (16 to 235), U and V (16 to 240, 128 = zero)
        //          -----------
        //           Y   U   V
        //          -----------
        // White  : 180 128 128
        // Black  : 16  128 128
        // Red    : 65  100 212
        // Green  : 112 72  58
        // Blue   : 35  212 114
        // Yellow : 162 44  142
        // Cyan   : 131 156 44
        // Magenta: 84  184 198
        //          -----------
        // It is assumed that the gamma corrected RGB range is (0 - 255)
        //
        // UYVY: U0Y0 V0Y1 U2Y2 V2Y3 (low byte always has current Y)
        // If iX is even, hight-byte has current U (Cb)
        // If iX is odd, hight-byte has previous V (Cr)
        //
        // YUY2: Y0U0 Y1V0 Y2U2 Y3V2 (high byte always has current Y)
        //       (UYVY bytes flipped)
        //
        // In this algorithm, we use U and V values from two neighboring
        // pixels
        {
            UINT8 Y, U, V;
            UINT16 u16Curr = *((UINT16*)pSurfaceBits);
            UINT16 u16ForU = 0; // Extract U from this
            UINT16 u16ForV = 0; // Extract V from this

            // By default we assume YUY2. Change it later if it is UYVY
            int uvShift = 8;
            int yShift  = 0;

            if (m_SurfFormat == RD_SF_UYVY)
            {
                uvShift = 0;
                yShift  = 8;
            }

            if ((iX & 1) == 0)
            {
                // For even numbered pixels:
                // Current U is available.
                // Current V is available in the next pixel.
                u16ForU = u16Curr;

                // Obtain V from the next pixel
                u16ForV = *((UINT16*)PixelAddress( iX+1, iY, iZ,
                                                   m_pBits[iLOD],
                                                   m_iPitch[iLOD],
                                                   m_iSlicePitch[iLOD],
                                                   m_SurfFormat ));

                U = (u16ForU >> uvShift) & 0xff;
                V = (u16ForV >> uvShift) & 0xff;
            }
            else
            {
                UINT16 u16ForU1 = 0, u16ForU2 = 0;
                UINT16 u16ForV1 = 0, u16ForV2 = 0;

                // For odd numbered pixels. Neither current U nor V are
                // available.

                // Obtain U by interpolating U from i-1 and i+1 pixels.
                _ASSERT( iX > 0, "iX is negative" );
                u16ForU1 = *((UINT16*)PixelAddress( iX-1, iY, iZ,
                                                    m_pBits[iLOD],
                                                    m_iPitch[iLOD],
                                                    m_iSlicePitch[iLOD],
                                                    m_SurfFormat ));

                if( (iX+1) < (m_iWidth >> iLOD) )
                {
                    u16ForU2 = *((UINT16*)PixelAddress( iX+1, iY, iZ,
                                                        m_pBits[iLOD],
                                                        m_iPitch[iLOD],
                                                        m_iSlicePitch[iLOD],
                                                        m_SurfFormat ));
                    U = (((u16ForU1 >> uvShift) & 0xff) +
                         ((u16ForU2 >> uvShift) & 0xff)) >> 1;

                }
                else
                {
                    U = (u16ForU1 >> uvShift) & 0xff;
                }

                // Obtain V by interpolating V from i and i+2 pixels.
                u16ForV1 = u16Curr;
                if( (iX+2) < (m_iWidth >> iLOD) )
                {
                    u16ForV2 = *((UINT16*)PixelAddress( iX+2, iY, iZ,
                                                        m_pBits[iLOD],
                                                        m_iPitch[iLOD],
                                                        m_iSlicePitch[iLOD],
                                                        m_SurfFormat ));
                    V = (((u16ForV1 >> uvShift) & 0xff) +
                         ((u16ForV2 >> uvShift) & 0xff)) >> 1;

                }
                else
                {
                    V = (u16ForV1 >> uvShift) & 0xff;
                }

            }

            Y = (u16Curr >> yShift) & 0xff;

            Texel = RGB_MAKE(
                CLAMP_BYTE(1.164*(Y-16) + 1.596*(V-128)),
                CLAMP_BYTE(1.164*(Y-16) - 0.813*(V-128) - 0.391*(U-128)),
                CLAMP_BYTE(1.164*(Y-16) + 2.018*(U-128))
                );
            Texel.A = 1.f;
        }
        break;

    // DXTn compressed formats:
    // We have the address to the block, now extract the actual color
    case RD_SF_DXT1:
    case RD_SF_DXT2:
    case RD_SF_DXT3:
    case RD_SF_DXT4:
    case RD_SF_DXT5:
        Texel = TexelFromBlock(m_SurfFormat, pSurfaceBits, iX, iY);
        break;
    }

    // colorkey
    if ( m_pRefDev->ColorKeyEnabled() )
    {
        DWORD dwBits;
        switch ( m_SurfFormat )
        {
        default:
        case RD_SF_NULL:
            return;     // don't colorkey unknown or null surfaces

        case RD_SF_PALETTE4:
            {
                UINT8 uIndex = *((INT8*)pSurfaceBits);
                if ((iX & 1) == 0) { uIndex &= 0xf; }
                else               { uIndex >>= 4;  }
                dwBits = (DWORD)uIndex;
                }
            break;

        case RD_SF_L8:
        case RD_SF_A8:
        case RD_SF_PALETTE8:
        case RD_SF_B2G3R3:
        case RD_SF_L4A4:
            {
                UINT8 uBits = *((UINT8*)pSurfaceBits);
                dwBits = (DWORD)uBits;
                }
            break;

        case RD_SF_B5G6R5:
        case RD_SF_B5G5R5X1:
        case RD_SF_B5G5R5A1:
        case RD_SF_B4G4R4A4:
        case RD_SF_B4G4R4X4:
        case RD_SF_L8A8:
        case RD_SF_P8A8:
        case RD_SF_B2G3R3A8:
            {
                UINT16 uBits = *((UINT16*)pSurfaceBits);
                dwBits = (DWORD)uBits;
            }
            break;

        case RD_SF_B8G8R8:
            {
                UINT32 uBits = 0;
                uBits |= ( *((UINT8*)pSurfaceBits+0) ) <<  0;
                uBits |= ( *((UINT8*)pSurfaceBits+1) ) <<  8;
                uBits |= ( *((UINT8*)pSurfaceBits+2) ) << 16;
                dwBits = (DWORD)uBits;
            }
            break;

        case RD_SF_B8G8R8A8:
        case RD_SF_B8G8R8X8:
            {
                UINT32 uBits = *((UINT32*)pSurfaceBits);
                dwBits = (DWORD)uBits;
            }
            break;
        }

        DWORD ColorKey = m_dwColorKey;
        if ( dwBits == ColorKey )
        {
            if (m_pRefDev->GetRS()[D3DRENDERSTATE_COLORKEYENABLE])
            {
                bColorKeyKill = TRUE;
            }
            if (m_pRefDev->GetRS()[D3DRENDERSTATE_COLORKEYBLENDENABLE])
            {
                Texel.R = 0.F;
                Texel.G = 0.F;
                Texel.B = 0.F;
                Texel.A = 0.F;
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\common\pixref.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// PixRef.cpp
//
// Direct3D Reference Device - Pixel Buffer Referencing
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

extern int g_DXTBlkSize[];

//-----------------------------------------------------------------------------
//
// PixelAddress - Form character address of locations within buffers using base
// pointer, pitch and type.
//
//-----------------------------------------------------------------------------

//
// common internal version
//
char*
PixelAddress(
    int iX, int iY, int iZ, int iSample,
    BYTE* pBits, int iYPitch, int iZPitch, int cSamples, RDSurfaceFormat SType )
{
    // initialize return value to start of scan line (pitch is always in bytes)
    BYTE* pPixAddr = pBits + iY*iYPitch + iZ*iZPitch;

    // bump along scan line depending on surface type to point to pixel data
    switch ( SType )
    {
    default:
        _ASSERTf(0, ("Unknown RDSurfaceFormat value %08x", SType));
        return NULL;
    case RD_SF_NULL:
        break;

    case RD_SF_B8G8R8A8:
    case RD_SF_B8G8R8X8:
    case RD_SF_U8V8L8X8:
    case RD_SF_Z24S8:
    case RD_SF_Z24X8:
    case RD_SF_S8Z24:
    case RD_SF_X8Z24:
    case RD_SF_Z24X4S4:
    case RD_SF_X4S4Z24:
    case RD_SF_Z32S0:
    case RD_SF_U8V8W8Q8:
    case RD_SF_U10V11W11:
    case RD_SF_U16V16:
    case RD_SF_R10G10B10A2:
    case RD_SF_R8G8B8A8:
    case RD_SF_R8G8B8X8:
    case RD_SF_R16G16:
    case RD_SF_U11V11W10:
    case RD_SF_U10V10W10A2:
    case RD_SF_U8V8X8A8:
    case RD_SF_U8V8X8L8:
        pPixAddr += (iX*cSamples*4 + iSample*4);
        break;

    case RD_SF_B5G6R5:
    case RD_SF_B5G5R5X1:
    case RD_SF_B5G5R5A1:
    case RD_SF_P8A8:
    case RD_SF_L8A8:
    case RD_SF_U8V8:
    case RD_SF_U5V5L6:
    case RD_SF_Z16S0:
    case RD_SF_Z15S1:
    case RD_SF_S1Z15:
    case RD_SF_B4G4R4A4:
    case RD_SF_B4G4R4X4:
    case RD_SF_YUY2:
    case RD_SF_UYVY:
    case RD_SF_B2G3R3A8:
        pPixAddr += (iX*cSamples*2 + iSample*2);
        break;

    case RD_SF_B8G8R8:
        pPixAddr += (iX*cSamples*3 + iSample*3);
        break;

    case RD_SF_PALETTE8:
    case RD_SF_L8:
    case RD_SF_A8:
    case RD_SF_B2G3R3:
    case RD_SF_L4A4:
        pPixAddr += (iX*cSamples*1 + iSample*1);
        break;

    case RD_SF_PALETTE4:
        pPixAddr += (iX>>1);
        break;

    // For the DXT texture formats, obtain the address of the
    // block from whih to decompress the texel from
    case RD_SF_DXT1:
    case RD_SF_DXT2:
    case RD_SF_DXT3:
    case RD_SF_DXT4:
    case RD_SF_DXT5:
        pPixAddr = pBits + iZ*iZPitch + (iY >> 2)*iYPitch + (iX>>2) *
            g_DXTBlkSize[(int)SType - (int)RD_SF_DXT1];
        break;
    }
    return (char *)pPixAddr;
}

//
// external versions
//
char*
PixelAddress(
    int iX, int iY, int iZ,
    BYTE* pBits, int iYPitch, int iZPitch, RDSurfaceFormat SType )
{
    return PixelAddress( iX, iY, iZ, 0, pBits, iYPitch, iZPitch, 1, SType );
}

char*
PixelAddress(
    int iX, int iY, int iZ, int iSample, RDSurface2D* pRT )
{
    return PixelAddress( iX, iY, iZ, iSample,
        pRT->GetBits(), pRT->GetPitch(), 0 /* pRT->GetSlicePitch() */,
        pRT->GetSamples(), pRT->GetSurfaceFormat() );
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\drv\init.c ===
#define INITGUID

#include <objbase.h>
#ifdef BUILD_MSREF
#include <d3dp.h>
#else   
#include <d3d.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\common\sources.inc ===
TARGETNAME = refcomm
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);..\..\drv

SOURCES = \
    ..\refdev.cpp    \
    ..\refdevi.cpp   \
    ..\dxtn.cpp      \
    ..\maplegcy.cpp  \
    ..\pixref.cpp    \
    ..\rdutil.cpp    \
    ..\rtarget.cpp   \
    ..\rdsurf.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\drv\pch.cpp ===
//----------------------------------------------------------------------------
//
// pch.cpp
//
// Precompiled header file.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#include "refdev.hpp"

#include "refif.hpp"
///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\common\refdev.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// refdev.cpp
//
// Direct3D Reference Device - public interfaces
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

// This is a global static array of the block sizes in bytes for the
// various DXTn compression formats
int g_DXTBlkSize[NUM_DXT_FORMATS] =
{
    sizeof(DXTBlockRGB),
    sizeof(DXTBlockAlpha4),
    sizeof(DXTBlockAlpha4),
    sizeof(DXTBlockAlpha3),
    sizeof(DXTBlockAlpha3),
};

//-----------------------------------------------------------------------------
//
// Memory management function installation
//
//-----------------------------------------------------------------------------

//  global pointers to memory allocation functions (used through MEM* macros)
LPVOID (__cdecl *g_pfnMemAlloc)( size_t size ) = NULL;
void   (__cdecl *g_pfnMemFree)( LPVOID lptr ) = NULL;
LPVOID (__cdecl *g_pfnMemReAlloc)( LPVOID ptr, size_t size ) = NULL;

// install memory management functions - must be called before instancing
// rasterizer object
void RefRastSetMemif(
    LPVOID(__cdecl *pfnMemAlloc)(size_t),
    void(__cdecl *pfnMemFree)(LPVOID),
    LPVOID(__cdecl *pfnMemReAlloc)(LPVOID,size_t))
{
    DPFRR(1, "RefRastSetMemif %08x %08x %08x\n",
        pfnMemAlloc,pfnMemFree,pfnMemReAlloc);
    g_pfnMemAlloc = pfnMemAlloc;
    g_pfnMemFree = pfnMemFree;
    g_pfnMemReAlloc = pfnMemReAlloc;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Interface Methods                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// SetRenderTarget -
//
//-----------------------------------------------------------------------------
void
RefDev::SetRenderTarget( RDRenderTarget* pRenderTarget )
{
    m_pRenderTarget = pRenderTarget;

    // update the W scaling values for mapping interpolated W's into buffer range
    m_fWBufferNorm[0] = pRenderTarget->m_fWRange[0];
    FLOAT fWRange = pRenderTarget->m_fWRange[1] - pRenderTarget->m_fWRange[0];
    m_fWBufferNorm[1] = ( 0. != fWRange ) ? ( 1./fWRange ) : ( 1. );

}

//-----------------------------------------------------------------------------
//
// SetTextureStageState -
//
//-----------------------------------------------------------------------------

// map DX6(&7) texture filtering enums to DX8 enums
static DWORD
MapDX6toDX8TexFilter( DWORD dwStageState, DWORD dwValue )
{
    switch (dwStageState)
    {
    case D3DTSS_MAGFILTER:
        switch (dwValue)
        {
        case D3DTFG_POINT           : return D3DTEXF_POINT;
        case D3DTFG_LINEAR          : return D3DTEXF_LINEAR;
        case D3DTFG_FLATCUBIC       : return D3DTEXF_FLATCUBIC;
        case D3DTFG_GAUSSIANCUBIC   : return D3DTEXF_GAUSSIANCUBIC;
        case D3DTFG_ANISOTROPIC     : return D3DTEXF_ANISOTROPIC;
        }
        break;
    case D3DTSS_MINFILTER:
        switch (dwValue)
        {
        case D3DTFN_POINT           : return D3DTEXF_POINT;
        case D3DTFN_LINEAR          : return D3DTEXF_LINEAR;
        case D3DTFN_ANISOTROPIC     : return D3DTEXF_ANISOTROPIC;
        }
        break;
    case D3DTSS_MIPFILTER:
        switch (dwValue)
        {
        case D3DTFP_NONE            : return D3DTEXF_NONE;
        case D3DTFP_POINT           : return D3DTEXF_POINT;
        case D3DTFP_LINEAR          : return D3DTEXF_LINEAR;
        }
        break;
    }
    return 0x0;
}

void
RefDev::SetTextureStageState(
    DWORD dwStage, DWORD dwStageState, DWORD dwValue )
{
    // check for range before continuing
    if ( dwStage >= D3DHAL_TSS_MAXSTAGES)
    {
        return;
    }
    if (dwStageState > D3DTSS_MAX)
    {
        return;
    }

    // set in internal per-stage state
    m_TextureStageState[dwStage].m_dwVal[dwStageState] = dwValue;

    m_dwRastFlags |= RDRF_TEXTURESTAGESTATE_CHANGED;

    switch ( dwStageState )
    {

    case D3DTSS_TEXTUREMAP:

        // bind texture indicated by handle to m_pTexture array
        if (IsDriverDX6AndBefore() || IsInterfaceDX6AndBefore())
        {
            // This is the legacy behavior (prev. to DX7)
            MapTextureHandleToDevice( dwStage );
        }
        else
        {
            // This is the new behavior (DX7 and beyond)
            SetTextureHandle( dwStage, dwValue );
        }
        m_dwRastFlags |= RDRF_LEGACYPIXELSHADER_CHANGED;
        break;

    case D3DTSS_COLOROP:
        m_dwRastFlags |= RDRF_LEGACYPIXELSHADER_CHANGED;
        break;

// not including legacy headers, so don't have D3DTSS_ADDRESS
//    case D3DTSS_ADDRESS:
//        // map single set ADDRESS to U, V controls (pre-DX8 interfaces only)
//        m_TextureStageState[dwStage].m_dwVal[D3DTSS_ADDRESSU] = dwValue;
//        m_TextureStageState[dwStage].m_dwVal[D3DTSS_ADDRESSV] = dwValue;
//        break;

    case D3DTSS_MAGFILTER:
    case D3DTSS_MINFILTER:
    case D3DTSS_MIPFILTER:
        if ( IsDriverDX7AndBefore() )
        {
            m_TextureStageState[dwStage].m_dwVal[dwStageState]
                = MapDX6toDX8TexFilter( dwStageState, dwValue );
        }
        break;
    }
}

//-----------------------------------------------------------------------------
//
// TextureCreate - Instantiates new RDSurface2D object, computes texture handle
// to associate with it, and returns both to caller.  Note that texture handle
// is a pointer and can be used to get at the corresponding texture object.
//
//-----------------------------------------------------------------------------
BOOL
RefDev::TextureCreate(
    LPD3DTEXTUREHANDLE phTex, RDSurface2D** ppTex )
{
    // allocate internal texture structure
    *ppTex = new RDSurface2D();
    _ASSERTa( NULL != *ppTex, "new failure on texture create", return FALSE; );

    // use separately allocated pointer for handle
    RDSurface2D** ppTexForHandle = (RDSurface2D**)MEMALLOC( sizeof(RDSurface2D*) );
    _ASSERTa( NULL != ppTexForHandle, "malloc failure on texture create", return FALSE; );
    *ppTexForHandle = *ppTex;

    // return texture handle
    (*ppTex)->m_hTex = (ULONG_PTR)ppTexForHandle;
    *phTex = (*ppTex)->m_hTex;

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// TextureDestroy -
//
//-----------------------------------------------------------------------------
BOOL
RefDev::TextureDestroy( D3DTEXTUREHANDLE hTex )
{
    // first check if texture about to be destroyed is mapped - if so then
    // unmap it
    for ( int iStage=0; iStage<D3DHAL_TSS_MAXSTAGES; iStage++ )
    {
        if ( hTex == m_TextureStageState[iStage].m_dwVal[D3DTSS_TEXTUREMAP] )
        {
            SetTextureStageState( iStage, D3DTSS_TEXTUREMAP, 0x0 );
        }
    }

    // resolve handle to RDSurface2D pointer
    RDSurface2D* pTex = MapHandleToTexture( hTex );
    if ( NULL == pTex ) { return FALSE; }

    // free the handle pointer
#ifdef _IA64_
    _ASSERTa(FALSE, "This will not work on IA64", return FALSE;);
#endif
    RDSurface2D** ppTex = (RDSurface2D**)ULongToPtr(hTex);
    if ( NULL != ppTex) { MEMFREE( ppTex ); }

    // free the RDSurface2D
    delete pTex;

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// TextureGetSurf -
//
//-----------------------------------------------------------------------------
DWORD
RefDev::TextureGetSurf( D3DTEXTUREHANDLE hTex )
{
    RDSurface2D* pTex = MapHandleToTexture(hTex);
    if ( NULL == pTex ) { return 0x0; }
    return PtrToUlong( pTex->m_pDDSLcl[0] );
}

//-----------------------------------------------------------------------------
//
// GetCurrentTextureMaps - This function fills in a passed array texture handles
// and pointers.  The array should be sized by D3DHAL_TSS_MAXSTAGES.
//
// This is used to facilitate external locking/unlocking of surfaces used for
// textures.
//
//-----------------------------------------------------------------------------
int
RefDev::GetCurrentTextureMaps(
    D3DTEXTUREHANDLE *phTex, RDSurface2D** pTex)
{
    UpdateActiveTexStageCount();

    for ( int i=0; i<m_cActiveTextureStages; i++ )
    {
        if ( NULL == m_pTexture[i] )
        {
            phTex[i] = 0x0;
            pTex[i] = NULL;
        }
        else
        {
            phTex[i] = m_pTexture[i]->m_hTex;
            pTex[i] = m_pTexture[i];
        }
    }
    return m_cActiveTextureStages;
}


//-----------------------------------------------------------------------------
//
// SceneCapture - Used to trigger fragment buffer resolve.
//
//-----------------------------------------------------------------------------
//#define DO_SCENE_RENDER_TIME

#ifdef DO_SCENE_RENDER_TIME
#include <mmsystem.h>
#endif
void
RefDev::SceneCapture( DWORD dwFlags )
{
static INT32 iScene = 0;
static INT32 iLastSceneEnd = 0;
#ifdef DO_SCENE_RENDER_TIME
static DWORD timeBS = 0;
#endif

    switch (dwFlags)
    {
    case D3DHAL_SCENE_CAPTURE_START:
        iScene++;
#ifdef DO_SCENE_RENDER_TIME
        timeBS = timeGetTime();
#endif
        break;
    case D3DHAL_SCENE_CAPTURE_END:
        if (iScene == iLastSceneEnd) break; // getting multiple END per BEGIN
        iLastSceneEnd = iScene;
#ifdef DO_SCENE_RENDER_TIME
        {

            DWORD timeES = timeGetTime();
            FLOAT dt = (FLOAT)(timeES - timeBS)/1000.f;
            timeBS = 0;
            RDDebugPrintf("SceneRenderTime: %f", dt );
        }
#endif
        break;
    }
}

//-----------------------------------------------------------------------------
//
// Query functions to get pointer to current render target and render state.
//
//-----------------------------------------------------------------------------
RDRenderTarget*
RefDev::GetRenderTarget(void)
{
    return m_pRenderTarget;
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
HRESULT
RefDev::UpdateRastState( void )
{
    // check 'dirty' flags
    if (m_dwRastFlags & RDRF_MULTISAMPLE_CHANGED)
    {
        // update multi-sample RS related state
        m_Rast.SetSampleMode(
            m_pRenderTarget->m_pColor->m_iSamples,
            m_dwRenderState[D3DRS_MULTISAMPLEANTIALIAS] );
        m_Rast.SetSampleMask(
            m_dwRenderState[D3DRS_MULTISAMPLEMASK] );
        m_dwRastFlags &= ~(RDRF_MULTISAMPLE_CHANGED);
    }
    if (m_dwRastFlags & RDRF_PIXELSHADER_CHANGED)
    {
        if (m_CurrentPShaderHandle)
        {
            m_Rast.m_pCurrentPixelShader =
                GetPShader(m_CurrentPShaderHandle);
            m_Rast.m_bLegacyPixelShade = FALSE;
        }
        else
        {
            // legacy pixel shader
            m_Rast.UpdateLegacyPixelShader();
            m_Rast.m_pCurrentPixelShader = m_Rast.m_pLegacyPixelShader;
            m_Rast.m_bLegacyPixelShade = TRUE;
        }
        UpdateActiveTexStageCount();

        m_dwRastFlags &= ~(RDRF_PIXELSHADER_CHANGED);
    }
    if (m_dwRastFlags & RDRF_LEGACYPIXELSHADER_CHANGED)
    {
        if (m_Rast.m_bLegacyPixelShade)
        {
            m_Rast.UpdateLegacyPixelShader();
            m_Rast.m_pCurrentPixelShader = m_Rast.m_pLegacyPixelShader;
            UpdateActiveTexStageCount();
        }
        m_dwRastFlags &= ~(RDRF_LEGACYPIXELSHADER_CHANGED);

    }
    if (m_dwRastFlags & RDRF_TEXTURESTAGESTATE_CHANGED)
    {
        m_Rast.UpdateTextureControls();
        m_dwRastFlags &= ~(RDRF_TEXTURESTAGESTATE_CHANGED);
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
//
// Begin/End bracket functions - Called before/after a list of primitives are
// rendered.
//
//-----------------------------------------------------------------------------
HRESULT
RefDev::BeginRendering( void )
{
    // If already in Begin, do nothing
    if( m_bInBegin ) return S_OK;
    
#ifdef _X86_
    // save floating point mode and set to extended precision mode
    {
        WORD wTemp, wSave;
        __asm
        {
            fstcw   wSave
            mov ax, wSave
            or ax, 300h    ;; extended precision mode
//            and ax, 00FFh    ;; single precision mode + round nearest or even
            mov wTemp, ax
            fldcw   wTemp
        }
        m_wSaveFP = wSave;
    }
#endif
    m_bInBegin = TRUE;
    return S_OK;
}
//-----------------------------------------------------------------------------
HRESULT
RefDev::EndRendering( void )
{
    if ( m_bInBegin )
    {
#ifdef _X86_
        // restore floating point mode
        {
            WORD wSave = m_wSaveFP;
            __asm {fldcw   wSave}
        }
#endif
        m_bInBegin = FALSE;
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
//
// Clear specified rectangles in the render target
// Directly handles the command from the DP2 stream
//
//-----------------------------------------------------------------------------
HRESULT RefDev::Clear(LPD3DHAL_DP2COMMAND pCmd)
{
    D3DHAL_DP2CLEAR *pData = (D3DHAL_DP2CLEAR*)(pCmd + 1);
    WORD i;
    INT32 x,y;
    RDColor fillColor(pData->dwFillColor);
    RDDepth fillDepth;
    if (m_pRenderTarget->m_pDepth)
    {
        fillDepth.SetSType(m_pRenderTarget->m_pDepth->GetSurfaceFormat());
    }

    fillDepth = pData->dvFillDepth;

    struct
    {
        D3DHAL_DP2COMMAND   cmd;
        D3DHAL_DP2CLEAR     data;
    } WholeViewport;

    if (!(pData->dwFlags & D3DCLEAR_COMPUTERECTS))
    {
        // Do nothing for non-pure device
    }
    else
    if (pCmd->wStateCount == 0)
    {
        // When wStateCount is zero we need to clear whole viewport
        WholeViewport.cmd = *pCmd;
        WholeViewport.cmd.wStateCount = 1;
        WholeViewport.data.dwFlags = pData->dwFlags;
        WholeViewport.data.dwFillColor = pData->dwFillColor;
        WholeViewport.data.dvFillDepth = pData->dvFillDepth;
        WholeViewport.data.dwFillStencil = pData->dwFillStencil;
        WholeViewport.data.Rects[0].left = m_Clipper.m_Viewport.dwX;
        WholeViewport.data.Rects[0].top = m_Clipper.m_Viewport.dwY;
        WholeViewport.data.Rects[0].right = m_Clipper.m_Viewport.dwX +
                                            m_Clipper.m_Viewport.dwWidth;
        WholeViewport.data.Rects[0].bottom = m_Clipper.m_Viewport.dwY +
                                             m_Clipper.m_Viewport.dwHeight;
        // Replace pointers and continue as usual
        pCmd = (LPD3DHAL_DP2COMMAND)&WholeViewport;
        pData = &WholeViewport.data;
    }
    else
    {
        // We need to cull all rects against the current viewport
        UINT nRects = pCmd->wStateCount;
        // Compute how much memory we need to process rects
        UINT NeededSize = sizeof(D3DHAL_DP2COMMAND) +
                          sizeof(D3DHAL_DP2CLEAR) +
                          (nRects-1) * sizeof(RECT); // One rect is in DP2CLEAR
        HRESULT hr = S_OK;
        HR_RET(m_ClearRectBuffer.Grow(NeededSize));

        RECT vwport;    // Viewport rectangle to cull against
        vwport.left   = m_Clipper.m_Viewport.dwX;
        vwport.top    = m_Clipper.m_Viewport.dwY;
        vwport.right  = m_Clipper.m_Viewport.dwX + m_Clipper.m_Viewport.dwWidth;
        vwport.bottom = m_Clipper.m_Viewport.dwY + m_Clipper.m_Viewport.dwHeight;

        // Go through input rects and build output rect array
        LPRECT pInputRects = pData->Rects;
        LPRECT pOutputRects = (LPRECT)(&m_ClearRectBuffer[0] +
                              sizeof(D3DHAL_DP2COMMAND) +
                              sizeof(D3DHAL_DP2CLEAR) -
                              sizeof(RECT));
        UINT nOutputRects = 0;
        for (UINT i = 0; i < nRects; i++)
        {
            if (IntersectRect(&pOutputRects[nOutputRects], &vwport,
                              &pInputRects[i]))
            {
                nOutputRects++;
            }
        }

        if (nOutputRects == 0)
            return S_OK;

        // Now replace pCmd and pData pointers and continue as usual
        LPD3DHAL_DP2CLEAR pOldData = pData;
        LPD3DHAL_DP2COMMAND pOldCmd = pCmd;

        pCmd = (LPD3DHAL_DP2COMMAND)&m_ClearRectBuffer[0];
        pData = (D3DHAL_DP2CLEAR*)(pCmd + 1);
        *pCmd = *pOldCmd;
        pCmd->wStateCount = (WORD)nOutputRects;
        pData->dwFlags       = pOldData->dwFlags;
        pData->dwFillColor   = pOldData->dwFillColor;
        pData->dvFillDepth   = pOldData->dvFillDepth;
        pData->dwFillStencil = pOldData->dwFillStencil;
    }

#ifdef _X86_
    // Float to integer conversion routines for 24+ bit buffers work
    // only with extended FPU mode.
    //
    WORD wSaveFP;
    // save floating point mode and set to extended precision mode
    {
        WORD wTemp, wSave;
        __asm
        {
            fstcw   wSaveFP
            mov ax, wSaveFP
            or ax, 300h    ;; extended precision mode
            mov wTemp, ax
            fldcw   wTemp
        }
    }
#endif

    if(pData->dwFlags & D3DCLEAR_TARGET)
    {
        if (m_dwRenderState[D3DRENDERSTATE_DITHERENABLE] == FALSE)
        {
            m_pRenderTarget->Clear(fillColor, pCmd);
        }
        else
        {
            for (i = 0; i < pCmd->wStateCount; i++)
            {
                for (y = pData->Rects[i].top; y < pData->Rects[i].bottom; ++y)
                {
                    for (x = pData->Rects[i].left; x < pData->Rects[i].right; ++x)
                    {
                        m_pRenderTarget->WritePixelColor(x, y, fillColor, TRUE);
                    }
                }
            }
        }
    }


    switch (pData->dwFlags & (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL))
    {
    case (D3DCLEAR_ZBUFFER):
        m_pRenderTarget->ClearDepth(fillDepth, pCmd);
        break;
    case (D3DCLEAR_STENCIL):
        m_pRenderTarget->ClearStencil(pData->dwFillStencil, pCmd);
        break;
    case (D3DCLEAR_ZBUFFER | D3DCLEAR_STENCIL):
        m_pRenderTarget->ClearDepthStencil(fillDepth, pData->dwFillStencil, pCmd);
        break;
    }

#ifdef _X86_
    // restore floating point mode
    {
        __asm {fldcw   wSaveFP}
    }
#endif
    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// Clear specified rectangles in the render target
// Directly handles the command from the DP2 stream
//
//-----------------------------------------------------------------------------
void RDRenderTarget::Clear(RDColor fillColor, LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(pCmd + 1);
    UINT32 dwColor = 0;
    fillColor.ConvertTo( m_pColor->GetSurfaceFormat(), 0.5f, (char*)&dwColor);

    for (DWORD i = 0; i < pCmd->wStateCount; i++)
    {
        DWORD x0 = pData->Rects[i].left;
        DWORD y0 = pData->Rects[i].top;
        DWORD dwWidth  = ( pData->Rects[i].right - x0 ) * m_pColor->GetSamples();
        DWORD dwHeight = pData->Rects[i].bottom - y0;
        char* pSurface = PixelAddress( x0, y0, 0, 0, m_pColor );
        switch ( m_pColor->GetSurfaceFormat() )
        {
        case RD_SF_B8G8R8A8:
        case RD_SF_B8G8R8X8:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = dwColor;
                    }
                    pSurface += m_pColor->GetPitch();
                }
            }
            break;

        case RD_SF_B8G8R8:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT8 *p = (UINT8*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = ((UINT8*)&dwColor)[0];
                        *p++ = ((UINT8*)&dwColor)[1];
                        *p++ = ((UINT8*)&dwColor)[2];
                    }
                    pSurface += m_pColor->GetPitch();
                }
            }
            break;

        case RD_SF_B4G4R4A4:
        case RD_SF_B5G6R5:
        case RD_SF_B5G5R5A1:
        case RD_SF_B5G5R5X1:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = (UINT16)dwColor;
                    }
                    pSurface += m_pColor->GetPitch();
                }
            }
            break;

        case RD_SF_B2G3R3:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT8 *p = (UINT8*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = (UINT8)dwColor;
                    }
                    pSurface += m_pColor->GetPitch();
                }
            }
            break;
        default:
            {
                for (int y = y0; y < pData->Rects[i].bottom; ++y)
                {
                    for (int x = x0; x < pData->Rects[i].right; ++x)
                    {
                        this->WritePixelColor(x, y, fillColor, TRUE);
                    }
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//
// Clear specified rectangles in the depth buffer
// Directly handles the command from the DP2 stream
//
//-----------------------------------------------------------------------------
void RDRenderTarget::ClearDepth(RDDepth fillDepth, LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(pCmd + 1);

    if (!m_pDepth) return;
    for (DWORD i = 0; i < pCmd->wStateCount; i++)
    {
        DWORD x0 = pData->Rects[i].left;
        DWORD y0 = pData->Rects[i].top;
        DWORD dwWidth  = ( pData->Rects[i].right - x0 ) * m_pDepth->GetSamples();
        DWORD dwHeight = pData->Rects[i].bottom - y0;
        char* pSurface = PixelAddress( x0, y0, 0, 0, m_pDepth );
        switch ( m_pDepth->GetSurfaceFormat() )
        {
        case RD_SF_Z16S0:
            {
                UINT16 Depth = UINT16(fillDepth);
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = Depth;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_Z24S8:
        case RD_SF_Z24X8:
        case RD_SF_Z24X4S4:
            {
                UINT32 Depth = UINT32(fillDepth) << 8;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on stencil
                        *p++ = (*p & ~(0xffffff00)) | Depth;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_S8Z24:
        case RD_SF_X8Z24:
        case RD_SF_X4S4Z24:
            {
                UINT32 Depth = UINT32(fillDepth) & 0x00ffffff;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on stencil
                        *p++ = (*p & ~(0x00ffffff)) | Depth;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_Z15S1:
            {
                UINT16 Depth = UINT16(fillDepth) << 1;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on stencil
                        *p++ = (*p & ~(0xfffe)) | Depth;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_S1Z15:
            {
                UINT16 Depth = UINT16(fillDepth) & 0x7fff;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on stencil
                        *p++ = (*p & ~(0x7fff)) | Depth;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_Z32S0:
            {
                UINT32 Depth = UINT32(fillDepth);
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = Depth;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        default:
            {
                for (int y = y0; y < pData->Rects[i].bottom; ++y)
                {
                    for (int x = x0; x < pData->Rects[i].right; ++x)
                    {
                        this->WritePixelDepth(x, y, fillDepth);
                    }
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//
// Clear specified rectangles in the stencil buffer
// Directly handles the command from the DP2 stream
//
//-----------------------------------------------------------------------------
void RDRenderTarget::ClearStencil(UINT8 uStencil, LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(pCmd + 1);

    for (DWORD i = 0; i < pCmd->wStateCount; i++)
    {
        DWORD x0 = pData->Rects[i].left;
        DWORD y0 = pData->Rects[i].top;
        DWORD dwWidth  = (pData->Rects[i].right - x0 ) * m_pDepth->GetSamples();
        DWORD dwHeight = pData->Rects[i].bottom - y0;
        char* pSurface = PixelAddress( x0, y0, 0, 0, m_pDepth );
        switch ( m_pDepth->GetSurfaceFormat() )
        {
        case RD_SF_Z24S8:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT8 *p = (UINT8*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p = uStencil;
                        p += 4;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_S8Z24:
            {
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT8 *p = (UINT8*)&pSurface[3];
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p = uStencil;
                        p += 4;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_Z24X4S4:
            {
                UINT32 stencil = uStencil & 0xf;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on depth
                        *p++ = (*p & ~(0x000000ff)) | stencil;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_X4S4Z24:
            {
                UINT32 stencil = (uStencil & 0xf) << 24;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on depth
                        *p++ = (*p & ~(0xff000000)) | stencil;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_Z15S1:
            {
                UINT16 stencil = uStencil & 0x1;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on depth
                        *p++ = (*p & ~(0x0001)) | stencil;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_S1Z15:
            {
                UINT16 stencil = uStencil << 15;
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        // need to do read-modify-write to not step on depth
                        *p++ = (*p & ~(0x8000)) | stencil;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_Z16S0:
        case RD_SF_Z32S0:
            break;
        default:
            {
                for (int y = y0; y < pData->Rects[i].bottom; ++y)
                {
                    for (int x = x0; x < pData->Rects[i].right; ++x)
                    {
                        this->WritePixelStencil(x, y, uStencil);
                    }
                }
            }
        }
    }
}

//-----------------------------------------------------------------------------
//
// Clear specified rectangles in the depth and stencil buffers
// Directly handles the command from the DP2 stream
//
//-----------------------------------------------------------------------------
void RDRenderTarget::ClearDepthStencil(RDDepth fillDepth, UINT8 uStencil, LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2CLEAR pData = (LPD3DHAL_DP2CLEAR)(pCmd + 1);

    for (DWORD i = 0; i < pCmd->wStateCount; i++)
    {
        DWORD x0 = pData->Rects[i].left;
        DWORD y0 = pData->Rects[i].top;
        DWORD dwWidth  = ( pData->Rects[i].right - x0 ) * m_pDepth->GetSamples();
        DWORD dwHeight = pData->Rects[i].bottom - y0;
        char* pSurface = PixelAddress( x0, y0, 0, 0, m_pDepth );
        switch (m_pDepth->GetSurfaceFormat())
        {
        case RD_SF_Z16S0:
        case RD_SF_Z32S0:
            break;
        case RD_SF_Z24S8:
        case RD_SF_Z24X8:
        case RD_SF_S8Z24:
        case RD_SF_X8Z24:
        case RD_SF_Z24X4S4:
        case RD_SF_X4S4Z24:
            {
                UINT32 v;
                switch (m_pDepth->GetSurfaceFormat())
                {
                case RD_SF_Z24S8: v = (UINT32(fillDepth) << 8) + uStencil;    break;
                case RD_SF_Z24X8: v = (UINT32(fillDepth) << 8);    break;
                case RD_SF_S8Z24: v = (UINT32(fillDepth)  & 0x00ffffff) + (uStencil << 24); break;
                case RD_SF_X8Z24: v = (UINT32(fillDepth)  & 0x00ffffff); break;
                case RD_SF_Z24X4S4: v = (UINT32(fillDepth) << 8) + (uStencil & 0xf);  break;
                case RD_SF_X4S4Z24: v = (UINT32(fillDepth) & 0x00ffffff) + ((uStencil & 0xf) << 24); break;
                }
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT32 *p = (UINT32*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = v;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        case RD_SF_Z15S1:
        case RD_SF_S1Z15:
            {
                UINT16 v;
                switch (m_pDepth->GetSurfaceFormat())
                {
                case RD_SF_Z15S1:    v = (UINT16(fillDepth) << 1) + (uStencil & 0x1); break;
                case RD_SF_S1Z15:    v = (UINT16(fillDepth) & 0x7fff) + (uStencil << 15); break;
                }
                for (DWORD y = dwHeight; y > 0; y--)
                {
                    UINT16 *p = (UINT16*)pSurface;
                    for (DWORD x = dwWidth; x > 0; x--)
                    {
                        *p++ = v;
                    }
                    pSurface += m_pDepth->GetPitch();
                }
            }
            break;
        default:
            {
                for (int y = y0; y < pData->Rects[i].bottom; ++y)
                {
                    for (int x = x0; x < pData->Rects[i].right; ++x)
                    {
                        this->WritePixelDepth(x, y, fillDepth);
                        this->WritePixelStencil(x, y, uStencil);
                    }
                }
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\drv\dprim2.cpp ===
//----------------------------------------------------------------------------
//
// dprim2.cpp
//
// Implements DrawPrimitives2.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

//---------------------------------------------------------------------
// Entry is texture count. Clears all texture format bits in the FVF DWORD,
// that correspond to the texture count
// for this count
//---------------------------------------------------------------------
const DWORD g_TextureFormatMask[9] = {
    ~0x0000FFFF,
    ~0x0003FFFF,
    ~0x000FFFFF,
    ~0x003FFFFF,
    ~0x00FFFFFF,
    ~0x03FFFFFF,
    ~0x0FFFFFFF,
    ~0x3FFFFFFF,
    ~0xFFFFFFFF
};

HRESULT
RDFVFCheckAndStride( DWORD dwFVF, DWORD* pdwStride )
{
    // If the runtime is DX8+, the dwFVF might be 0
    // in which case the stride is obtained from the streams
    if( dwFVF == 0 ) return S_OK;

    DWORD dwTexCoord = FVF_TEXCOORD_NUMBER(dwFVF);
    DWORD vertexType = dwFVF & D3DFVF_POSITION_MASK;
    // Texture format bits above texture count should be zero
    // Reserved field 0 and 2 should be 0
    // Reserved 1 should be set only for LVERTEX
    // Only two vertex position types allowed
    if( dwFVF & g_TextureFormatMask[dwTexCoord] )
    {
        DPFERR( "FVF has incorrect texture format" );
        return DDERR_INVALIDPARAMS;
    }

    if( dwFVF & (D3DFVF_RESERVED2 | D3DFVF_RESERVED0) )
    {
        DPFERR( "FVF has reserved bit(s) set" );
        return DDERR_INVALIDPARAMS;
    }

    if( !(vertexType == D3DFVF_XYZRHW ||
          vertexType == D3DFVF_XYZ ||
          vertexType == D3DFVF_XYZB1 ||
          vertexType == D3DFVF_XYZB2 ||
          vertexType == D3DFVF_XYZB3 ||
          vertexType == D3DFVF_XYZB4 ||
          vertexType == D3DFVF_XYZB5) )
    {
        DPFERR( "FVF has incorrect position type" );
        return DDERR_INVALIDPARAMS;
    }

    if( (vertexType == D3DFVF_XYZRHW) && (dwFVF & D3DFVF_NORMAL) )
    {
        DPFERR( "Normal should not be used with XYZRHW position type" );
        return DDERR_INVALIDPARAMS;
    }

    *pdwStride = GetFVFVertexSize( dwFVF );
    return D3D_OK;
}


inline D3DPRIMITIVETYPE ConvertDP2OPToPrimType(D3DHAL_DP2OPERATION Dp2Op)
{
    switch (Dp2Op)
    {
    case D3DDP2OP_POINTS              :
        return D3DPT_POINTLIST;
    case D3DDP2OP_INDEXEDLINELIST     :
    case D3DDP2OP_INDEXEDLINELIST2    :
    case D3DDP2OP_LINELIST_IMM        :
    case D3DDP2OP_LINELIST            :
        return D3DPT_LINELIST;
    case D3DDP2OP_TRIANGLELIST        :
    case D3DDP2OP_INDEXEDTRIANGLELIST :
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
        return D3DPT_TRIANGLELIST;
    case D3DDP2OP_LINESTRIP           :
    case D3DDP2OP_INDEXEDLINESTRIP    :
        return D3DPT_LINESTRIP;
    case D3DDP2OP_TRIANGLESTRIP       :
    case D3DDP2OP_INDEXEDTRIANGLESTRIP:
        return D3DPT_TRIANGLESTRIP;
    case D3DDP2OP_TRIANGLEFAN         :
    case D3DDP2OP_INDEXEDTRIANGLEFAN  :
    case D3DDP2OP_TRIANGLEFAN_IMM     :
        return D3DPT_TRIANGLEFAN;
    case D3DDP2OP_RENDERSTATE         :
    case D3DDP2OP_TEXTURESTAGESTATE   :
    case D3DDP2OP_VIEWPORTINFO        :
    case D3DDP2OP_WINFO               :
    default:
        DPFM(4, DRV, ("(RefRast)Non primitive operation operation in DrawPrimitives2"));
        return (D3DPRIMITIVETYPE)0;
    }
}

//----------------------------------------------------------------------------
//
// FvfToRDVertex
//
// Converts a series of FVF vertices to RDVertices, which are the internal
// currency of the RefDev.
//
//----------------------------------------------------------------------------
void 
RefDev::FvfToRDVertex( PUINT8 pVtx, GArrayT<RDVertex>& dstArray, DWORD dwFvf, 
                       DWORD dwStride, UINT cVertices )
{
    for (DWORD i = 0; i < cVertices; i++)
    {
        dstArray[i].SetFvfData( (LPDWORD)pVtx, dwFvf );
        pVtx += dwStride;
    }
}

//----------------------------------------------------------------------------
//
// RefRastDrawPrimitives2
//
// This is called by D3DIM for API DrawPrimitives2 to draw a set of primitives
// using a vertex buffer.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA pDPrim2Data)
{
    HRESULT hr = D3D_OK;

    RefDev *pRefDev;
    DWORD dwStride = 0;
    DWORD dwFVF = pDPrim2Data->dwVertexType;
    PUINT8 pVtData = NULL;
    PUINT8 pUMVtx = NULL;
    DWORD dwNumVertices = pDPrim2Data->dwVertexLength;

    VALIDATE_REFRAST_CONTEXT("RefRastDrawPrimitives", pDPrim2Data);

    if( pDPrim2Data->lpVertices )
    {
        if (pDPrim2Data->dwFlags & D3DHALDP2_USERMEMVERTICES)
        {
            pUMVtx = (PUINT8)pDPrim2Data->lpVertices;
            pVtData = pUMVtx + pDPrim2Data->dwVertexOffset;
        }
        else
        {
            pVtData = (PUINT8)pDPrim2Data->lpDDVertex->lpGbl->fpVidMem +
                pDPrim2Data->dwVertexOffset;
        }
    }

    LPD3DHAL_DP2COMMAND pCmd = (LPD3DHAL_DP2COMMAND)
                                ((PUINT8)pDPrim2Data->lpDDCommands->lpGbl->fpVidMem +
                                 pDPrim2Data->dwCommandOffset);
    UINT_PTR CmdBoundary = (UINT_PTR)pCmd +
                               pDPrim2Data->dwCommandLength;


    // Unconditionally get the vertex stride, since it can not change
    if ((pDPrim2Data->ddrval = RDFVFCheckAndStride(
                        (DWORD)pDPrim2Data->dwVertexType, &dwStride)) != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    //
    // If this is a pre-DX8 DDI, then the FVF shader needs to be set as
    // the current shader. ONLY IF it requires vertex processing.
    // Else, convert its data into the RDVertex array.
    //
    if( pRefDev->GetDDIType() < RDDDI_DX8HAL )
    {
        if( !FVF_TRANSFORMED( dwFVF ) )
        {
            BYTE CmdBytes[ sizeof( D3DHAL_DP2COMMAND ) +
                         sizeof( D3DHAL_DP2VERTEXSHADER ) ];

            D3DHAL_DP2COMMAND& cmd = *(LPD3DHAL_DP2COMMAND)CmdBytes;
            D3DHAL_DP2VERTEXSHADER& vs =
                *(LPD3DHAL_DP2VERTEXSHADER)((LPD3DHAL_DP2COMMAND)CmdBytes + 1);
            cmd.bCommand    = D3DDP2OP_SETVERTEXSHADER;
            cmd.wStateCount = 1;
            vs.dwHandle = dwFVF;
            pRefDev->Dp2SetVertexShader( (LPD3DHAL_DP2COMMAND)CmdBytes );

            // Set the 0th stream here as well.
            pRefDev->GetVStream( 0 ).m_pData = pVtData;
            pRefDev->GetVStream( 0 ).m_dwStride = dwStride;
        }
        else
        {
            // Ask the RefDev to grow its TLVBuf Array and copy the
            // FVF data into it.
            HR_RET( pRefDev->GrowTLVArray( dwNumVertices ) );
            pRefDev->FvfToRDVertex( pVtData, pRefDev->GetTLVArray(), dwFVF, 
                                    dwStride, dwNumVertices );
        }
    }

    // Skip state check and texture lock if the first thing is state change
    //
    // WINFO is excluded here because it currently does not affect RGB/MMX
    // and refrast does not care if it changes between begin/endrendering.
    //
    // VIEWPORTINFO is excluded here because it is OK to change the viewport
    // between begin/endrendering on both RGB/MMX and Ref.
    //

#ifndef __D3D_NULL_REF
    // Loop through the data, update render states
    // and then draw the primitive
    for (;;)
    {
        LPDWORD lpdwRStates;
        if (pDPrim2Data->dwFlags & D3DHALDP2_EXECUTEBUFFER)
            lpdwRStates = pDPrim2Data->lpdwRStates;
        else
            lpdwRStates = NULL;

        pDPrim2Data->ddrval = pRefDev->DrawPrimitives2( pUMVtx,
                                                         (UINT16)dwStride,
                                                         dwFVF,
                                                         dwNumVertices,
                                                         &pCmd,
                                                         lpdwRStates );
        if (pDPrim2Data->ddrval != D3D_OK)
        {
            if (pDPrim2Data->ddrval == D3DERR_COMMAND_UNPARSED)
            {
                pDPrim2Data->dwErrorOffset = (UINT32)((ULONG_PTR)pCmd -
                          (UINT_PTR)(pDPrim2Data->lpDDCommands->lpGbl->fpVidMem));
            }
            goto EH_Exit;
        }
        if ((UINT_PTR)pCmd >= CmdBoundary)
            break;
    }
 EH_Exit:
#else //__D3D_NULL_REF
    pDPrim2Data->ddrval = S_OK;
#endif //__D3D_NULL_REF


	hr = pRefDev->EndRendering();
    
    if (pDPrim2Data->ddrval == D3D_OK)
    {
        pDPrim2Data->ddrval = hr;
    }

    return DDHAL_DRIVER_HANDLED;
}

#ifndef __D3D_NULL_REF
HRESULT FASTCALL
DoDrawIndexedTriList2( RefDev *pCtx,
                       WORD cPrims,
                       D3DHAL_DP2INDEXEDTRIANGLELIST *pTriList)
{
    INT i;
    D3DHAL_DP2INDEXEDTRIANGLELIST *pTri = pTriList;
    GArrayT<RDVertex>& VtxArray = pCtx->GetTLVArray();

    for (i = 0; i < cPrims; i ++)
    {
        HRESULT hr;

        PUINT8 pVtx0, pVtx1, pVtx2;
        RDVertex& Vtx0 = VtxArray[pTri->wV1];
        RDVertex& Vtx1 = VtxArray[pTri->wV2];
        RDVertex& Vtx2 = VtxArray[pTri->wV3];
        pCtx->DrawTriangle( &Vtx0, &Vtx1, &Vtx2, pTri->wFlags);
        pTri ++;
    }

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// DoDrawPrimitives2
//
// It's called by RefRastDrawPrimitives2. .
//
//----------------------------------------------------------------------------
HRESULT 
RefDev::DrawPrimitives2( PUINT8 pUMVtx,
                         UINT16 dwStride,
                         DWORD dwFvf,
                         DWORD dwNumVertices,
                         LPD3DHAL_DP2COMMAND *ppCmd,
                         LPDWORD lpdwRStates )
{
    LPD3DHAL_DP2COMMAND pCmd = *ppCmd;
    HRESULT hr = S_OK;
    
    DPFM(7, DRV, ("(RefRast)Read Ins: %08lx", *(LPDWORD)pCmd));

    BOOL bWireframe = 
        (GetRS()[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME);

    //
    // Lock textures and setup the floating point state if the
    // command is a drawing command, only if it has not been locked before
    //
    switch(pCmd->bCommand)
    {
    case D3DDP2OP_POINTS:
    case D3DDP2OP_LINELIST:
    case D3DDP2OP_LINESTRIP:
    case D3DDP2OP_TRIANGLELIST:
    case D3DDP2OP_TRIANGLESTRIP:
    case D3DDP2OP_TRIANGLEFAN:
    case D3DDP2OP_INDEXEDLINELIST:
    case D3DDP2OP_INDEXEDLINELIST2:
    case D3DDP2OP_INDEXEDLINESTRIP:
    case D3DDP2OP_INDEXEDTRIANGLELIST:
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
    case D3DDP2OP_INDEXEDTRIANGLESTRIP:
    case D3DDP2OP_INDEXEDTRIANGLEFAN:
    case D3DDP2OP_TRIANGLEFAN_IMM:
    case D3DDP2OP_LINELIST_IMM:
        _ASSERT( GetDDIType() < RDDDI_DX8HAL, "Older drawing tokens"
                 " received for DX8+ DDI" );
        // Fall through
    case D3DDP2OP_DRAWPRIMITIVE:
    case D3DDP2OP_DRAWINDEXEDPRIMITIVE:
    case D3DDP2OP_CLIPPEDTRIANGLEFAN:
    case D3DDP2OP_DRAWPRIMITIVE2:
    case D3DDP2OP_DRAWINDEXEDPRIMITIVE2:
    case D3DDP2OP_DRAWRECTPATCH:
    case D3DDP2OP_DRAWTRIPATCH:
        // Turn off the TCI override, this will be set if needed later
        // on during vertex processing by the fixed function pipeline.
        m_bOverrideTCI = FALSE;
        // This stuff needs to be updated only on pre DX7 drivers.
        HR_RET(RefRastUpdatePalettes( this ));
        HR_RET(BeginRendering());
    }

    switch(pCmd->bCommand)
    {
    case D3DDP2OP_STATESET:
        {
            LPD3DHAL_DP2STATESET pStateSetOp = 
                (LPD3DHAL_DP2STATESET)(pCmd + 1);

            switch (pStateSetOp->dwOperation)
            {
            case D3DHAL_STATESETBEGIN  :
                HR_RET(BeginStateSet(pStateSetOp->dwParam));
                break;
            case D3DHAL_STATESETEND    :
                HR_RET(EndStateSet());
                break;
            case D3DHAL_STATESETDELETE :
                HR_RET(DeleteStateSet(pStateSetOp->dwParam));
                break;
            case D3DHAL_STATESETEXECUTE:
                HR_RET(ExecuteStateSet(pStateSetOp->dwParam));
                break;
            case D3DHAL_STATESETCAPTURE:
                HR_RET(CaptureStateSet(pStateSetOp->dwParam));
                break;
            case D3DHAL_STATESETCREATE:
                HR_RET(CreateStateSet(pStateSetOp->dwParam, 
                                    pStateSetOp->sbType));
                break;
            default :
                return DDERR_INVALIDPARAMS;
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pStateSetOp + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_VIEWPORTINFO:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2SetViewport(this, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                     ((D3DHAL_DP2VIEWPORTINFO *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_WINFO:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2SetWRange(this, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                     ((D3DHAL_DP2WINFO *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_RENDERSTATE:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2SetRenderStates(this, dwFvf, pCmd, 
                                                           lpdwRStates));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                     ((D3DHAL_DP2RENDERSTATE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_TEXTURESTAGESTATE:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2TextureStageState(this, dwFvf, 
                                                             pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
               ((LPD3DHAL_DP2TEXTURESTAGESTATE)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    // This is a special case because it has edge flags. Other D3DDP2OP
    // can actually make use of DrawOneIndexedPrimitive/DrawOnePrimitive.
    case D3DDP2OP_INDEXEDTRIANGLELIST:
        {
            // This command is used in execute buffers. So untransformed
            // vertices are not expected by this refrast.
            _ASSERT( FVF_TRANSFORMED(dwFvf), "Untransformed vertices in "
                     "D3DDP2OP_INDEXEDTRIANGLELIST" );

            WORD cPrims = pCmd->wPrimitiveCount;
            HR_RET(DoDrawIndexedTriList2(
                this, cPrims, (D3DHAL_DP2INDEXEDTRIANGLELIST *)(pCmd + 1)));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(pCmd + 1) +
                            sizeof(D3DHAL_DP2INDEXEDTRIANGLELIST) * cPrims);
        }
        break;
    case D3DDP2OP_INDEXEDLINELIST:
        {
            // This command is used in execute buffers. So untransformed
            // vertices are not expected by this refrast.
            _ASSERT( FVF_TRANSFORMED(dwFvf),
                     "Untransformed vertices in D3DDP2OP_INDEXEDLINELIST" );

            HR_RET(DrawOneIndexedPrimitive( GetTLVArray(),
                                            0,
                                            (LPWORD)(pCmd + 1),
                                            0,
                                            pCmd->wPrimitiveCount * 2,
                                            D3DPT_LINELIST));

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(pCmd + 1) +
                    pCmd->wPrimitiveCount * sizeof(D3DHAL_DP2INDEXEDLINELIST));
        }
        break;
    // Following ops All use DrawOneIndexedPrimitive/DrawOnePrimitive.
    // There are some extra overheads introduced because those two functions
    // need to switch over the PrimTypes while we already know it here.
    // Striping out the code to add inline functions for each PrimType means
    // adding about twenty functions(considering the types of prim times types
    // of vertex). So I have used DrawOneIndexedPrimitive/DrawOnePrimitive
    // here anyway. We can later change it if necessary.
    case D3DDP2OP_POINTS:
        {
            WORD cPrims = pCmd->wPrimitiveCount;
            D3DHAL_DP2POINTS *pPt = (D3DHAL_DP2POINTS *)(pCmd + 1);
            WORD i;

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                for (i = 0; i < cPrims; i++)
                {
                    HR_RET(ProcessPrimitive( D3DPT_POINTLIST,
                                             pPt->wVStart,
                                             pPt->wCount,
                                             0, 0 ));
                    pPt ++;
                }
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    for (i = 0; i < cPrims; i++)
                    {
                        HR_RET(m_Clipper.DrawOnePrimitive( GetTLVArray(),
                                                           pPt->wVStart,
                                                           D3DPT_POINTLIST,
                                                           pPt->wCount));
                        
                        // Clean up the FVFP_CLIP bit for the 
                        // copied vertices.
                        pPt ++;
                    }
                }
                else
                {
                    for (i = 0; i < cPrims; i++)
                    {
                        HR_RET(DrawOnePrimitive( GetTLVArray(),
                                                 pPt->wVStart,
                                                 D3DPT_POINTLIST,
                                                 pPt->wCount));
                        pPt ++;
                    }
                }
            }
            
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)pPt;
        }
        break;
    case D3DDP2OP_LINELIST:
        {
            D3DHAL_DP2LINELIST *pLine = (D3DHAL_DP2LINELIST *)(pCmd + 1);

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(ProcessPrimitive( D3DPT_LINELIST, pLine->wVStart,
                                         pCmd->wPrimitiveCount * 2, 0, 0 ));
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    HR_RET(m_Clipper.DrawOnePrimitive( 
                        GetTLVArray(),
                        pLine->wVStart,
                        D3DPT_LINELIST,
                        pCmd->wPrimitiveCount * 2));                
                    // Clean up the FVFP_CLIP bit for the 
                    // copied vertices.
                }
                else
                {
                    HR_RET(DrawOnePrimitive( 
                        GetTLVArray(),
                        pLine->wVStart,
                        D3DPT_LINELIST,
                        pCmd->wPrimitiveCount * 2));
                }
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pLine + 1);
        }
        break;
    case D3DDP2OP_INDEXEDLINELIST2:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount*2;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            // Set the Index Stream
            m_IndexStream.m_pData = (LPBYTE)(lpStartVertex + 1);
            m_IndexStream.m_dwStride = 2;

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(ProcessPrimitive(
                    D3DPT_LINELIST,
                    lpStartVertex->wVStart,
                    dwNumVertices-lpStartVertex->wVStart,
                    0,
                    dwNumIndices ));
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    HR_RET(m_Clipper.DrawOneIndexedPrimitive( 
                        GetTLVArray(),
                        lpStartVertex->wVStart,
                        (LPWORD)(lpStartVertex + 1),
                        0,
                        dwNumIndices,
                        D3DPT_LINELIST));                
                    // Clean up the FVFP_CLIP bit for the 
                    // copied vertices.
                }
                else
                {
                    HR_RET(DrawOneIndexedPrimitive( 
                        GetTLVArray(),
                        lpStartVertex->wVStart,
                        (LPWORD)(lpStartVertex + 1),
                        0,
                        dwNumIndices,
                        D3DPT_LINELIST));
                }
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                    pCmd->wPrimitiveCount * sizeof(D3DHAL_DP2INDEXEDLINELIST));
        }
        break;
    case D3DDP2OP_LINESTRIP:
        {
            D3DHAL_DP2LINESTRIP *pLine = (D3DHAL_DP2LINESTRIP *)(pCmd + 1);

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(ProcessPrimitive( D3DPT_LINESTRIP,
                                         pLine->wVStart,
                                         pCmd->wPrimitiveCount + 1,
                                         0, 0 ));
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    HR_RET(m_Clipper.DrawOnePrimitive( 
                        GetTLVArray(),
                        pLine->wVStart,
                        D3DPT_LINESTRIP,
                        pCmd->wPrimitiveCount + 1));                
                    // Clean up the FVFP_CLIP bit for the 
                    // copied vertices.
                }
                else
                {
                    HR_RET(DrawOnePrimitive( 
                        GetTLVArray(),
                        pLine->wVStart,
                        D3DPT_LINESTRIP,
                        pCmd->wPrimitiveCount + 1));
                }
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pLine + 1);
        }
        break;
    case D3DDP2OP_INDEXEDLINESTRIP:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount + 1;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            // Set the Index Stream
            m_IndexStream.m_pData = (LPBYTE)(lpStartVertex + 1);
            m_IndexStream.m_dwStride = 2;

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(ProcessPrimitive(
                    D3DPT_LINESTRIP,
                    lpStartVertex->wVStart,
                    dwNumVertices-lpStartVertex->wVStart,
                    0,
                    dwNumIndices ));
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    HR_RET(m_Clipper.DrawOneIndexedPrimitive( 
                        GetTLVArray(),
                        lpStartVertex->wVStart,
                        (LPWORD)(lpStartVertex + 1),
                        0,
                        dwNumIndices,
                        D3DPT_LINESTRIP));                
                    // Clean up the FVFP_CLIP bit for the 
                    // copied vertices.
                }
                else
                {
                    HR_RET(DrawOneIndexedPrimitive( 
                        GetTLVArray(),
                        lpStartVertex->wVStart,
                        (LPWORD)(lpStartVertex + 1),
                        0,
                        dwNumIndices,
                        D3DPT_LINESTRIP));
                }
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLELIST:
        {
            D3DHAL_DP2TRIANGLELIST *pTri = (D3DHAL_DP2TRIANGLELIST *)(pCmd + 1);

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(ProcessPrimitive( D3DPT_TRIANGLELIST,
                                         pTri->wVStart,
                                         pCmd->wPrimitiveCount * 3,
                                         0, 0 ));
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    HR_RET(m_Clipper.DrawOnePrimitive( 
                        GetTLVArray(),
                        pTri->wVStart,
                        D3DPT_TRIANGLELIST,
                        pCmd->wPrimitiveCount * 3));                
                    // Clean up the FVFP_CLIP bit for the 
                    // copied vertices.
                }
                else
                {
                    HR_RET(DrawOnePrimitive( GetTLVArray(),
                                             pTri->wVStart,
                                             D3DPT_TRIANGLELIST,
                                             pCmd->wPrimitiveCount * 3));

                }
            }
            
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pTri + 1);
        }
        break;
    case D3DDP2OP_INDEXEDTRIANGLELIST2:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount*3;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            // Set the Index Stream
            m_IndexStream.m_pData = (LPBYTE)(lpStartVertex + 1);
            m_IndexStream.m_dwStride = 2;

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(ProcessPrimitive(
                    D3DPT_TRIANGLELIST,
                    lpStartVertex->wVStart,
                    dwNumVertices-lpStartVertex->wVStart,
                    0,
                    dwNumIndices));
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    HR_RET(m_Clipper.DrawOneIndexedPrimitive( 
                        GetTLVArray(),
                        lpStartVertex->wVStart,
                        (LPWORD)(lpStartVertex + 1),
                        0,
                        dwNumIndices,
                        D3DPT_TRIANGLELIST));                
                    // Clean up the FVFP_CLIP bit for the 
                    // copied vertices.
                }
                else
                {
                    HR_RET(DrawOneIndexedPrimitive( 
                        GetTLVArray(),
                        lpStartVertex->wVStart,
                        (LPWORD)(lpStartVertex + 1),
                        0,
                        dwNumIndices,
                        D3DPT_TRIANGLELIST));
                }
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLESTRIP:
        {
            D3DHAL_DP2TRIANGLESTRIP *pTri = (D3DHAL_DP2TRIANGLESTRIP *)(pCmd + 1);
            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(ProcessPrimitive( D3DPT_TRIANGLESTRIP,
                                               pTri->wVStart,
                                               pCmd->wPrimitiveCount + 2,
                                               0, 0 ));
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    HR_RET(m_Clipper.DrawOnePrimitive( 
                        GetTLVArray(),
                        pTri->wVStart,
                        D3DPT_TRIANGLESTRIP,
                        pCmd->wPrimitiveCount + 2));                
                    // Clean up the FVFP_CLIP bit for the 
                    // copied vertices.
                }
                else
                {
                    HR_RET(DrawOnePrimitive( 
                        GetTLVArray(),
                        pTri->wVStart,
                        D3DPT_TRIANGLESTRIP,
                        pCmd->wPrimitiveCount + 2));
                }
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pTri + 1);
        }
        break;
    case D3DDP2OP_INDEXEDTRIANGLESTRIP:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount+2;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            // Set the Index Stream
            m_IndexStream.m_pData = (LPBYTE)(lpStartVertex + 1);
            m_IndexStream.m_dwStride = 2;

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(ProcessPrimitive(
                    D3DPT_TRIANGLESTRIP,
                    lpStartVertex->wVStart,
                    dwNumVertices-lpStartVertex->wVStart,
                    0,
                    dwNumIndices ));
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    HR_RET(m_Clipper.DrawOneIndexedPrimitive( 
                        GetTLVArray(),
                        lpStartVertex->wVStart,
                        (LPWORD)(lpStartVertex + 1),
                        0,
                        dwNumIndices,
                        D3DPT_TRIANGLESTRIP));                
                    // Clean up the FVFP_CLIP bit for the 
                    // copied vertices.
                }
                else
                {
                    HR_RET(DrawOneIndexedPrimitive( 
                        GetTLVArray(),
                        lpStartVertex->wVStart,
                        (LPWORD)(lpStartVertex + 1),
                        0,
                        dwNumIndices,
                        D3DPT_TRIANGLESTRIP));
                }
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLEFAN:
        {
            D3DHAL_DP2TRIANGLEFAN *pTri = (D3DHAL_DP2TRIANGLEFAN *)(pCmd + 1);

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(ProcessPrimitive( D3DPT_TRIANGLEFAN,
                                               pTri->wVStart,
                                               pCmd->wPrimitiveCount + 2,
                                               0, 0 ));
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    HR_RET(m_Clipper.DrawOnePrimitive( 
                        GetTLVArray(),
                        pTri->wVStart,
                        D3DPT_TRIANGLEFAN,
                        pCmd->wPrimitiveCount + 2));                
                    // Clean up the FVFP_CLIP bit for the 
                    // copied vertices.
                }
                else
                {
                    HR_RET(DrawOnePrimitive( 
                        GetTLVArray(),
                        pTri->wVStart,
                        D3DPT_TRIANGLEFAN,
                        pCmd->wPrimitiveCount + 2));
                }
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)(pTri + 1);
        }
        break;
    case D3DDP2OP_INDEXEDTRIANGLEFAN:
        {
            DWORD dwNumIndices = pCmd->wPrimitiveCount + 2;
            LPD3DHAL_DP2STARTVERTEX lpStartVertex =
                (LPD3DHAL_DP2STARTVERTEX)(pCmd + 1);

            // Set the Index Stream
            m_IndexStream.m_pData = (LPBYTE)(lpStartVertex + 1);
            m_IndexStream.m_dwStride = 2;

            // Check if the primitive is transformed or not
            if (!FVF_TRANSFORMED(dwFvf))
            {
                HR_RET(ProcessPrimitive(
                    D3DPT_TRIANGLEFAN,
                    lpStartVertex->wVStart,
                    dwNumVertices-lpStartVertex->wVStart,
                    0,
                    dwNumIndices ));
            }
            else
            {
                if( GetRS()[D3DRENDERSTATE_CLIPPING] )
                {
                    HR_RET( UpdateClipper() );
                    HR_RET(m_Clipper.DrawOneIndexedPrimitive( 
                        GetTLVArray(),
                        lpStartVertex->wVStart,
                        (LPWORD)(lpStartVertex + 1),
                        0,
                        dwNumIndices,
                        D3DPT_TRIANGLEFAN));                
                    // Clean up the FVFP_CLIP bit for the 
                    // copied vertices.
                }
                else
                {
                    HR_RET(DrawOneIndexedPrimitive( 
                        GetTLVArray(),
                        lpStartVertex->wVStart,
                        (LPWORD)(lpStartVertex + 1),
                        0,
                        dwNumIndices,
                        D3DPT_TRIANGLEFAN));
                }
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)(lpStartVertex + 1) +
                                           dwNumIndices * sizeof(WORD));
        }
        break;
    case D3DDP2OP_TRIANGLEFAN_IMM:
        {
            DWORD vertexCount = pCmd->wPrimitiveCount + 2;
            // Make sure the pFanVtx pointer is DWORD aligned: (pFanVtx +3) % 4
            PUINT8 pFanVtx = (PUINT8)
                (((ULONG_PTR)(pCmd + 1) + 
                  sizeof(D3DHAL_DP2TRIANGLEFAN_IMM) + 3) & ~3);

            // Assert here. This case should never be reached.
            // This command is used by front end to give clipped
            // primitives inside the command itself. Since TL Hals
            // do their own clipping untransformed vertices but yet
            // clipped are not expected here.
            // Assert that only transformed vertices can reach here
            _ASSERT( FVF_TRANSFORMED(dwFvf),
                     "Untransformed vertices in D3DDP2OP_TRIANGLEFAN_IMM" );

            GArrayT<RDVertex> ClipVtxArray;
            HR_RET(ClipVtxArray.Grow( vertexCount ) );
            FvfToRDVertex( pFanVtx, ClipVtxArray, dwFvf, dwStride,
                           vertexCount );
            if (bWireframe)
            {
                // Read edge flags
                UINT32 dwEdgeFlags =
                    ((LPD3DHAL_DP2TRIANGLEFAN_IMM)(pCmd + 1))->dwEdgeFlags;
                HR_RET(DrawOneEdgeFlagTriangleFan( ClipVtxArray,
                                                   vertexCount,
                                                   dwEdgeFlags));
            }
            else
            {
                HR_RET(DrawOnePrimitive( ClipVtxArray,
                                          0,
                                          D3DPT_TRIANGLEFAN,
                                          vertexCount));
            }

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)pFanVtx +
                                           vertexCount * dwStride);
        }
        break;
    case D3DDP2OP_LINELIST_IMM:
        {
            DWORD vertexCount = pCmd->wPrimitiveCount * 2;
            // Make sure the pLineVtx pointer is DWORD aligned:
            // (pLineVtx +3) % 4
            PUINT8 pLineVtx = (PUINT8)(((ULONG_PTR)(pCmd + 1) + 3) & ~3);

            // Assert here. This case should never be reached.
            // This command is used by front end to give clipped
            // primitives inside the command itself. Since TL Hals
            // do their own clipping untransformed vertices but yet
            // clipped are not expected here.
            // Assert that only transformed vertices can reach here
            _ASSERT( FVF_TRANSFORMED(dwFvf),
                     "Untransformed vertices in D3DDP2OP_LINELIST_IMM" );

            GArrayT<RDVertex> ClipVtxArray;
            HR_RET(ClipVtxArray.Grow( vertexCount ) );
            FvfToRDVertex( pLineVtx, ClipVtxArray, dwFvf, dwStride,
                           vertexCount );
            HR_RET(DrawOnePrimitive( ClipVtxArray,
                                     0,
                                     D3DPT_LINELIST,
                                     vertexCount));

            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((PUINT8)pLineVtx +
                                           vertexCount * dwStride);
        }
        break;
    case D3DDP2OP_DRAWPRIMITIVE:
        {
            HR_RET(Dp2DrawPrimitive(pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2DRAWPRIMITIVE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_DRAWPRIMITIVE2:
        {
            HR_RET(Dp2DrawPrimitive2(pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2DRAWPRIMITIVE2 *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_DRAWRECTPATCH:
        {
            LPD3DHAL_DP2DRAWRECTPATCH pDP = 
                (LPD3DHAL_DP2DRAWRECTPATCH)(pCmd + 1);
            for( int i = 0; i < pCmd->wStateCount; i++ )
            {
                HR_RET(DrawRectPatch(pDP));
                bool hassegs = (pDP->Flags & RTPATCHFLAG_HASSEGS) != 0;
                bool hasinfo = (pDP->Flags & RTPATCHFLAG_HASINFO) != 0;
                if(hassegs)
                {
                    pDP = (LPD3DHAL_DP2DRAWRECTPATCH)((BYTE*)(pDP + 1) + 
                                                      sizeof(FLOAT) * 4);
                }
                else
                {
                    ++pDP;
                }
                if(hasinfo)
                {
                    pDP = (LPD3DHAL_DP2DRAWRECTPATCH)((BYTE*)pDP + sizeof(D3DRECTPATCH_INFO));
                }
            }
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)pDP;
        }
        break;
    case D3DDP2OP_DRAWTRIPATCH:
        {
            LPD3DHAL_DP2DRAWTRIPATCH pDP = 
                (LPD3DHAL_DP2DRAWTRIPATCH)(pCmd + 1);
            for( int i = 0; i < pCmd->wStateCount; i++ )
            {
                HR_RET(DrawTriPatch(pDP));
                bool hassegs = (pDP->Flags & RTPATCHFLAG_HASSEGS) != 0;
                bool hasinfo = (pDP->Flags & RTPATCHFLAG_HASINFO) != 0;
                if(hassegs)
                {
                    pDP = (LPD3DHAL_DP2DRAWTRIPATCH)((BYTE*)(pDP + 1) + 
                                                      sizeof(FLOAT) * 3);
                }
                else
                {
                    ++pDP;
                }
                if(hasinfo)
                {
                    pDP = (LPD3DHAL_DP2DRAWTRIPATCH)((BYTE*)pDP + sizeof(D3DTRIPATCH_INFO));
                }
            }
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)pDP;
        }
        break;
    case D3DDP2OP_DRAWINDEXEDPRIMITIVE:
        {
            HR_RET(Dp2DrawIndexedPrimitive(pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2DRAWINDEXEDPRIMITIVE *)(pCmd + 1) +
                 pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_DRAWINDEXEDPRIMITIVE2:
        {
            HR_RET(Dp2DrawIndexedPrimitive2(pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2DRAWINDEXEDPRIMITIVE2 *)(pCmd + 1) +
                 pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_CLIPPEDTRIANGLEFAN:
        {
            HR_RET(Dp2DrawClippedTriFan(pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_CLIPPEDTRIANGLEFAN*)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_ZRANGE:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2SetZRange(this, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2ZRANGE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETMATERIAL:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2SetMaterial(this, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2SETMATERIAL *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETLIGHT:
        {
            DWORD dwSLStride = 0;
            HR_RET(pStateSetFuncTbl->pfnDp2SetLight(this, pCmd, &dwSLStride));
            *ppCmd = (LPD3DHAL_DP2COMMAND)((LPBYTE)pCmd  + dwSLStride);
        }
        break;
    case D3DDP2OP_CREATELIGHT:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2CreateLight(this, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2CREATELIGHT *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETTRANSFORM:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2SetTransform(this, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2SETTRANSFORM *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_MULTIPLYTRANSFORM:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2MultiplyTransform(this, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2MULTIPLYTRANSFORM *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_EXT:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2SetExtention(this, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2EXT *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_SETRENDERTARGET:
        {
            HR_RET(Dp2SetRenderTarget(pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                ((D3DHAL_DP2SETRENDERTARGET*)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DDP2OP_CLEAR:
        {
            HR_RET(Clear(pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)((LPBYTE)(pCmd + 1) +
                sizeof(D3DHAL_DP2CLEAR) + (pCmd->wStateCount - 1) * sizeof(RECT));
        }
        break;
    case D3DDP2OP_SETCLIPPLANE:
        {
            HR_RET(pStateSetFuncTbl->pfnDp2SetClipPlane(this, pCmd));
            // Update the command buffer pointer
            *ppCmd = (LPD3DHAL_DP2COMMAND)
                     ((D3DHAL_DP2SETCLIPPLANE *)(pCmd + 1) + pCmd->wStateCount);
        }
        break;
    case D3DOP_SPAN:
        // Skip over
        *ppCmd = (LPD3DHAL_DP2COMMAND)((LPBYTE)(pCmd + 1) +
                  pCmd->wPrimitiveCount * pCmd->bReserved );
        break;
    case D3DDP2OP_CREATEVERTEXSHADER:
    {
        LPD3DHAL_DP2CREATEVERTEXSHADER pCVS =
            (LPD3DHAL_DP2CREATEVERTEXSHADER)(pCmd + 1);
        WORD i;

        for( i = 0; i < pCmd->wStateCount ; i++ )
        {
            LPDWORD pDecl = (LPDWORD)(pCVS + 1);
            LPDWORD pCode = (LPDWORD)((LPBYTE)pDecl + pCVS->dwDeclSize);
            hr = Dp2CreateVertexShader( pCVS->dwHandle,
                                        pCVS->dwDeclSize, pDecl,
                                        pCVS->dwCodeSize, pCode );
            if( FAILED( hr ) ) break;
            // Update the pointer
            pCVS = (LPD3DHAL_DP2CREATEVERTEXSHADER)((LPBYTE)pCode +
                                                    pCVS->dwCodeSize);
        }
        // Successful termination of the loop:
        // Update the command buffer pointer
        if( i == pCmd->wStateCount )
            *ppCmd = (LPD3DHAL_DP2COMMAND)pCVS;
        else
            return hr;
        break;
    }
    case D3DDP2OP_DELETEVERTEXSHADER:
        HR_RET(Dp2DeleteVertexShader(pCmd));
        // Update the command buffer pointer
        *ppCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2VERTEXSHADER *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETVERTEXSHADER:
        HR_RET(pStateSetFuncTbl->pfnDp2SetVertexShader(this, pCmd));
        // Update the command buffer pointer
        *ppCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2VERTEXSHADER *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETVERTEXSHADERCONST:
    {
        LPD3DHAL_DP2SETVERTEXSHADERCONST pSVC =
            (LPD3DHAL_DP2SETVERTEXSHADERCONST)(pCmd + 1);
        WORD i;
        for( i = 0; i < pCmd->wStateCount ; i++ )
        {
            LPDWORD pData = (LPDWORD)(pSVC + 1);
            hr = pStateSetFuncTbl->pfnDp2SetVertexShaderConsts(
                this, pSVC->dwRegister, pSVC->dwCount, pData );
            if( FAILED( hr ) ) break;
            // Update the pointer
            pSVC = (LPD3DHAL_DP2SETVERTEXSHADERCONST)((LPBYTE)pData +
                                                      pSVC->dwCount * 4 *
                                                      sizeof( float ) );
        }

        // Successful termination of the loop:
        // Update the command buffer pointer
        if( i == pCmd->wStateCount )
            *ppCmd = (LPD3DHAL_DP2COMMAND)pSVC;
        else
            return hr;
        break;
    }
    case D3DDP2OP_SETSTREAMSOURCE:
        // This function also updates the ppCmd pointer
        HR_RET(pStateSetFuncTbl->pfnDp2SetStreamSource(this, pCmd));
        // Update the command buffer pointer
        *ppCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETSTREAMSOURCE *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETSTREAMSOURCEUM:
        // This function also updates the ppCmd pointer
        HR_RET(Dp2SetStreamSourceUM( pCmd, pUMVtx ));
        // Update the command buffer pointer
        *ppCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETSTREAMSOURCEUM *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETINDICES:
        // This function also updates the ppCmd pointer
        HR_RET(pStateSetFuncTbl->pfnDp2SetIndices(this, pCmd));
        // Update the command buffer pointer
        *ppCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETINDICES *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_CREATEPIXELSHADER:
    {
        LPD3DHAL_DP2CREATEPIXELSHADER pCPS =
            (LPD3DHAL_DP2CREATEPIXELSHADER)(pCmd + 1);
        WORD i;

        for( i = 0; i < pCmd->wStateCount ; i++ )
        {
            LPDWORD pCode = (LPDWORD)(pCPS + 1);
            hr = Dp2CreatePixelShader( pCPS->dwHandle,
                                             pCPS->dwCodeSize, pCode );
            if( FAILED( hr ) ) break;
            // Update the pointer
            pCPS = (LPD3DHAL_DP2CREATEPIXELSHADER)((LPBYTE)pCode +
                                                    pCPS->dwCodeSize);
        }
        // Successful termination of the loop:
        // Update the command buffer pointer
        if( i == pCmd->wStateCount )
            *ppCmd = (LPD3DHAL_DP2COMMAND)pCPS;
        else
            return hr;
        break;
    }
    case D3DDP2OP_DELETEPIXELSHADER:
        HR_RET(Dp2DeletePixelShader(pCmd));
        // Update the command buffer pointer
        *ppCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2PIXELSHADER *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETPIXELSHADER:
        HR_RET(pStateSetFuncTbl->pfnDp2SetPixelShader(this, pCmd));
        // Update the command buffer pointer
        *ppCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2PIXELSHADER *)(pCmd + 1) + pCmd->wStateCount);
        break;
    case D3DDP2OP_SETPIXELSHADERCONST:
    {
        LPD3DHAL_DP2SETPIXELSHADERCONST pSVC =
            (LPD3DHAL_DP2SETPIXELSHADERCONST)(pCmd + 1);
        WORD i;
        for( i = 0; i < pCmd->wStateCount ; i++ )
        {
            LPDWORD pData = (LPDWORD)(pSVC + 1);
            hr = pStateSetFuncTbl->pfnDp2SetPixelShaderConsts(
                this, pSVC->dwRegister, pSVC->dwCount, pData );
            if( FAILED( hr ) ) break;
            // Update the pointer
            pSVC = (LPD3DHAL_DP2SETPIXELSHADERCONST)((LPBYTE)pData +
                                                      pSVC->dwCount * 4 *
                                                      sizeof( float ) );
        }

        // Successful termination of the loop:
        // Update the command buffer pointer
        if( i == pCmd->wStateCount )
            *ppCmd = (LPD3DHAL_DP2COMMAND)pSVC;
        else
            return hr;
        break;
    }
    case D3DDP2OP_SETPALETTE:
    {
        HR_RET(Dp2SetPalette(pCmd));
        *ppCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETPALETTE *)(pCmd + 1) + pCmd->wStateCount);
        break;
    }
    case D3DDP2OP_UPDATEPALETTE:
    {
        LPD3DHAL_DP2UPDATEPALETTE pUP = (LPD3DHAL_DP2UPDATEPALETTE)(pCmd + 1);
        WORD i;
        for( i = 0; i < pCmd->wStateCount ; i++ )
        {
            PALETTEENTRY* pEntries = (PALETTEENTRY *)(pUP + 1);
            HR_RET(Dp2UpdatePalette(pUP, pEntries));
            pUP = (LPD3DHAL_DP2UPDATEPALETTE)(pEntries + pUP->wNumEntries);
        }
        if( i == pCmd->wStateCount )
            *ppCmd = (LPD3DHAL_DP2COMMAND)pUP;
        else
            return hr;
        break;
    }
    case D3DDP2OP_SETTEXLOD:
    {
        HR_RET(Dp2SetTexLod(pCmd));
        *ppCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETTEXLOD *)(pCmd + 1) + pCmd->wStateCount);
        break;
    }
    case D3DDP2OP_SETPRIORITY:
    {
        // Skip these tokens. RefDev doesnt need to handle SetPriority
        *ppCmd = (LPD3DHAL_DP2COMMAND)
            ((D3DHAL_DP2SETPRIORITY *)(pCmd + 1) + pCmd->wStateCount);
        break;
    }
    case D3DDP2OP_TEXBLT:
    {
        LPD3DHAL_DP2TEXBLT pTB = (LPD3DHAL_DP2TEXBLT)(pCmd + 1);
        for( WORD i = 0; i < pCmd->wStateCount ; i++ )
        {
            if( pTB->dwDDDestSurface == 0 )
            {
                // This is a PreLoad command, ignore it since 
                // RefDev just fakes driver management.
            }
            else
            {
                DPFERR( "TEXBLT not supported by RefDev\n" );
            }
            pTB++;
        }
        *ppCmd = (LPD3DHAL_DP2COMMAND)pTB;
        break;
    }
    case D3DDP2OP_BUFFERBLT:
    {
        LPD3DHAL_DP2BUFFERBLT pBB = (LPD3DHAL_DP2BUFFERBLT)(pCmd + 1);
        for( WORD i = 0; i < pCmd->wStateCount ; i++ )
        {
            if( pBB->dwDDDestSurface == 0 )
            {
                // This is a PreLoad command, ignore it since 
                // RefDev just fakes driver management.
            }
            else
            {
                DPFERR( "BUFFERBLT not supported by RefDev\n" );
            }
            pBB++;
        }
        *ppCmd = (LPD3DHAL_DP2COMMAND)pBB;
        break;
    }
    case D3DDP2OP_VOLUMEBLT:
    {
        LPD3DHAL_DP2VOLUMEBLT pVB = (LPD3DHAL_DP2VOLUMEBLT)(pCmd + 1);
        for( WORD i = 0; i < pCmd->wStateCount ; i++ )
        {
            if( pVB->dwDDDestSurface == 0 )
            {
                // This is a PreLoad command, ignore it since 
                // RefDev just fakes driver management.
            }
            else
            {
                DPFERR( "VOLUMEBLT not supported by RefDev\n" );
            }
            pVB++;
        }
        *ppCmd = (LPD3DHAL_DP2COMMAND)pVB;
        break;
    }
    case D3DOP_MATRIXLOAD:
    {
        DPFERR( "MATRIXLOAD not supported by RefDev\n" );
        hr = D3DERR_COMMAND_UNPARSED;
        break;
    }
    case D3DOP_MATRIXMULTIPLY:
    {
        DPFERR( "MATRIXMULTIPLY not supported by RefDev\n" );
        hr = D3DERR_COMMAND_UNPARSED;
        break;
    }
    case D3DOP_STATETRANSFORM:
    {
        DPFERR( "STATETRANSFORM not supported by RefDev\n" );
        hr = D3DERR_COMMAND_UNPARSED;
        break;
    }
    case D3DOP_STATELIGHT:
    {
        DPFERR( "STATELIGHT not supported by RefDev\n" );
        hr = D3DERR_COMMAND_UNPARSED;
        break;
    }
    case D3DOP_TEXTURELOAD:
    {
        DPFERR( "TEXTURELOAD not supported by RefDev\n" );
        hr = D3DERR_COMMAND_UNPARSED;
        break;
    }
    case D3DOP_BRANCHFORWARD:
    {
        DPFERR( "BRANCHFORWARD not supported by RefDev\n" );
        hr = D3DERR_COMMAND_UNPARSED;
        break;
    }
    case D3DOP_SETSTATUS:
    {
        DPFERR( "SETSTATUS not supported by RefDev\n" );
        hr = D3DERR_COMMAND_UNPARSED;
        break;
    }
    case D3DOP_EXIT:
    {
        DPFERR( "EXIT not supported by RefDev\n" );
        hr = D3DERR_COMMAND_UNPARSED;
        break;
    }
    case D3DOP_PROCESSVERTICES:
    {
        DPFERR( "PROCESSVERTICES not supported by RefDev\n" );
        hr = D3DERR_COMMAND_UNPARSED;
        break;
    }
    default:
        DPFERR( "Unknown command encountered" );
        return E_FAIL;
    }
    return hr;
}
#endif //__D3D_NULL_REF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\common\rdutil.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// rdutil.cpp
//
// Direct3D Reference Device - Utilities
//
//
//
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// DPF support                                                                  //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////

// control globals
int g_iDPFLevel = 0;
unsigned long g_uDPFMask = 0x0;

//-----------------------------------------------------------------------------
//
// RDDebugPrintf(L) - Utilities to print varargs-formatted strings of debugging
// info.  The 'L' version takes a level into account in deciding to print or
// not.
//
//-----------------------------------------------------------------------------
void
RDErrorPrintf( const char* pszFormat, ... )
{
    char tmp[1024] = "D3DRefDev:ERROR: ";
    va_list marker;
    va_start(marker, pszFormat);
    _vsnprintf(tmp+lstrlen(tmp), 1023-lstrlen(tmp), pszFormat, marker);
    strcat( tmp, "\n" );
    OutputDebugString(tmp);
    printf(tmp);
}

void
RDDebugPrintf( const char* pszFormat, ... )
{
    char tmp[1024] = "D3DRefDev: ";
    va_list marker;
    va_start(marker, pszFormat);
    _vsnprintf(tmp+lstrlen(tmp), 1023-lstrlen(tmp), pszFormat, marker);
    strcat( tmp, "\n" );
    OutputDebugString(tmp);
    printf(tmp);
}

void
RDDebugPrintfL( int iLevel, const char* pszFormat, ... )
{
    if ( (iLevel <= g_iDPFLevel) )
    {
        char tmp[1024] = "D3DRefDev: ";
        va_list marker;
        va_start(marker, pszFormat);
        _vsnprintf(tmp+lstrlen(tmp), 1023-lstrlen(tmp), pszFormat, marker);
        strcat( tmp, "\n" );
        OutputDebugString(tmp);
        printf(tmp);
    }
}


///////////////////////////////////////////////////////////////////////////////
//
// Assert Reporting
//
///////////////////////////////////////////////////////////////////////////////

// little-bit-o-state to track file and line number reporting - this is makes
// this code non-reentrant and non-threadsafe...  oh well...
static const char* _pszLastReportFile = NULL;
static int _iLastReportLine = -1;

//-----------------------------------------------------------------------------
void
RDAssertReport( const char* pszString, const char* pszFile, int iLine )
{
    char szNum[33];
    _itoa( iLine, szNum, 10 );

    char szTmp[ 1024 ] = "D3DRR ASSERT: <";
    strcat( szTmp, szNum );

    char* pCur = szTmp + strlen( szTmp );
    char* const pEnd = szTmp + sizeof( szTmp ) / sizeof( szTmp[ 0 ] ) - 1;

    if( pCur < pEnd )
    {
        const char szNext[] = ",";
        strncpy( pCur, szNext, pEnd - pCur );
        pCur += sizeof( szNext ) / sizeof( szNext[ 0 ] ) - 1;
        pCur = min( pCur, pEnd );
    }

    if( pCur < pEnd )
    {
        const size_t uiFileLen = strlen( pszFile );
        strncpy( pCur, pszFile, pEnd - pCur );
        pCur += uiFileLen;
        pCur = min( pCur, pEnd );
    }

    if( pCur < pEnd )
    {
        const char szNext[] = "> ";
        strncpy( pCur, szNext, pEnd - pCur );
        pCur += sizeof( szNext ) / sizeof( szNext[ 0 ] ) - 1;
        pCur = min( pCur, pEnd );
    }

    if( pCur < pEnd )
    {
        const size_t uiStringLen = strlen( pszString );
        strncpy( pCur, pszString, pEnd - pCur );
        pCur += uiStringLen;
        pCur = min( pCur, pEnd );
    }

    if( pCur < pEnd )
    {
        const char szNext[] = "\n";
        strncpy( pCur, szNext, pEnd - pCur );
        pCur += sizeof( szNext ) / sizeof( szNext[ 0 ] ) - 1;
        pCur = min( pCur, pEnd );
    }

    *pEnd = '\0';

    OutputDebugString( szTmp );
#if DBG
    DebugBreak();
#endif
}
//-----------------------------------------------------------------------------
void
RDAssertReportPrefix( const char* pszFile, int iLine )
{
    _pszLastReportFile = pszFile;
    _iLastReportLine = iLine;
}
//-----------------------------------------------------------------------------
void
RDAssertReportMessage( const char* pszFormat, ... )
{
    char szTmp[1024];
    va_list marker;
    va_start( marker, pszFormat );
    _vsnprintf( szTmp, 1024, pszFormat, marker );
    RDAssertReport( szTmp, _pszLastReportFile, _iLastReportLine );
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Generic bit twiddling utilities                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// CountSetBits - Returns number of set bits in a multibit value (up to
// 32 bits).
//
//-----------------------------------------------------------------------------
INT32
CountSetBits( UINT32 uVal, INT32 nBits )
{
    INT32 iRet = 0;
    for (INT32 i=0; i<nBits; i++) {
        if (uVal & (0x1<<i)) { iRet++; }
    }
    return iRet;
}

//-----------------------------------------------------------------------------
//
// FindFirstSetBit - Returns index of first set bit in a multibit value
// (up to 32 bits) or -1 if no bits are set.
//
//-----------------------------------------------------------------------------
INT32
FindFirstSetBit( UINT32 uVal, INT32 nBits )
{
    for (INT32 i=0; i<nBits; i++) {
        if (uVal & (0x1<<i)) { return i; }
    }
    return -1;
}

//-----------------------------------------------------------------------------
//
// FindMostSignificantSetBit - Returns index of first set bit in a
// multibit value (up to 32 bits) or 0 if no bits are set.
//
//-----------------------------------------------------------------------------
INT32
FindMostSignificantSetBit( UINT32 uVal, INT32 nBits )
{
    for (INT32 i=nBits; i>=0; i--) {
        if (uVal & (0x1<<i)) { return i+1; }
    }
    return 0;
}

//-----------------------------------------------------------------------------
//
// FindLastSetBit - Returns index of last set bit in a multibit value
// (up to 32 bits) or -1 if no bits are set.
//
//-----------------------------------------------------------------------------
INT32
FindLastSetBit( UINT32 uVal, INT32 nBits )
{
    for (INT32 i=0; i<nBits; i++) {
        if (uVal & (0x1<<(nBits-i-1))) { return (nBits-i-1); }
    }
    return -1;
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Arithmetic utilities                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// LerpColor - Performs a linear interpolation between two RDColors
//
// uT is in 1.5 format (1<<5 represents a unit value)
//
//-----------------------------------------------------------------------------
void
LerpColor(
    RDColor& Color,
    const RDColor& Color0, const RDColor& Color1, UINT8 uT )
{
    FLOAT fT = (1./(FLOAT)(1<<5))*(FLOAT)uT;
    Color.A = Color0.A + (Color1.A - Color0.A)*fT;
    Color.R = Color0.R + (Color1.R - Color0.R)*fT;
    Color.G = Color0.G + (Color1.G - Color0.G)*fT;
    Color.B = Color0.B + (Color1.B - Color0.B)*fT;
}

//-----------------------------------------------------------------------------
//
// Bilerp - Performs bilinear interpolation of 4 RDColors returning one RDColor.
//
//-----------------------------------------------------------------------------
void
BiLerpColor(
    RDColor& OutColor,
    const RDColor& Color00, const RDColor& Color01,
    const RDColor& Color10, const RDColor& Color11,
    UINT8 uA, UINT8 uB )
{
    RDColor Color0, Color1;
    LerpColor( Color0, Color00, Color01, uA);
    LerpColor( Color1, Color10, Color11, uA);
    LerpColor( OutColor, Color0, Color1, uB);
}

void
BiLerpColor3D(
    RDColor& OutColor,
    const RDColor& Color000, const RDColor& Color010,
    const RDColor& Color100, const RDColor& Color110,
    const RDColor& Color001, const RDColor& Color011,
    const RDColor& Color101, const RDColor& Color111,
    UINT8 uA, UINT8 uB, UINT8 uC)
{
    RDColor Color0, Color1, OutColor0, OutColor1;
    LerpColor( Color0, Color000, Color010, uA);
    LerpColor( Color1, Color100, Color110, uA);
    LerpColor( OutColor0, Color0, Color1, uB);
    LerpColor( Color0, Color001, Color011, uA);
    LerpColor( Color1, Color101, Color111, uA);
    LerpColor( OutColor1, Color0, Color1, uB);
    LerpColor( OutColor, OutColor0, OutColor1, uC);
}

///////////////////////////////////////////////////////////////////////////////
//
// DDGetAttachedSurfaceLcl implementation
//
///////////////////////////////////////////////////////////////////////////////
HRESULT
DDGetAttachedSurfaceLcl(
    LPDDRAWI_DDRAWSURFACE_LCL this_lcl,
    LPDDSCAPS2 lpDDSCaps,
    LPDDRAWI_DDRAWSURFACE_LCL *lplpDDAttachedSurfaceLcl)
{
    LPDDRAWI_DIRECTDRAW_GBL pdrv;
    LPDDRAWI_DDRAWSURFACE_GBL   pgbl;

    LPATTACHLIST        pal;
    DWORD           caps;
    DWORD           testcaps;
    DWORD           ucaps;
    DWORD           caps2;
    DWORD           testcaps2;
    DWORD           ucaps2;
    DWORD           caps3;
    DWORD           testcaps3;
    DWORD           ucaps3;
    DWORD           caps4;
    DWORD           testcaps4;
    DWORD           ucaps4;
    BOOL            ok;

    pgbl = this_lcl->lpGbl;
    *lplpDDAttachedSurfaceLcl = NULL;
    pdrv = pgbl->lpDD;

    /*
     * look for the surface
     */
    pal = this_lcl->lpAttachList;
    testcaps = lpDDSCaps->dwCaps;
    testcaps2 = lpDDSCaps->dwCaps2;
    testcaps3 = lpDDSCaps->dwCaps3;
    testcaps4 = lpDDSCaps->dwCaps4;
    while( pal != NULL )
    {
        ok = TRUE;
        caps = pal->lpAttached->ddsCaps.dwCaps;
        caps2 = pal->lpAttached->lpSurfMore->ddsCapsEx.dwCaps2;
        caps3 = pal->lpAttached->lpSurfMore->ddsCapsEx.dwCaps3;
        caps4 = pal->lpAttached->lpSurfMore->ddsCapsEx.dwCaps4;
        ucaps = caps & testcaps;
        ucaps2 = caps2 & testcaps2;
        ucaps3 = caps3 & testcaps3;
        ucaps4 = caps4 & testcaps4;
        if( ucaps | ucaps2 | ucaps3 | ucaps4 )
        {
            /*
             * there are caps in common, make sure that the caps to test
             * were all there
             */
            if( (ucaps & testcaps) == testcaps &&
                (ucaps2 & testcaps2) == testcaps2 &&
                (ucaps3 & testcaps3) == testcaps3 &&
                (ucaps4 & testcaps4) == testcaps4   )
            {
            }
            else
            {
                ok = FALSE;
            }
        }
        else
        {
            ok = FALSE;
        }


        if( ok )
        {
            *lplpDDAttachedSurfaceLcl = pal->lpAttached;
            return DD_OK;
        }
        pal = pal->lpLink;
    }
    return DDERR_NOTFOUND;

}

//---------------------------------------------------------------------
// Gets the value from DIRECT3D registry key
// Returns TRUE if success
// If fails value is not changed
//---------------------------------------------------------------------
BOOL
GetD3DRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize)
{

    HKEY hKey = (HKEY) NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey))
    {
        DWORD dwType;
        LONG result;
        result =  RegQueryValueEx(hKey, valueName, NULL, &dwType,
                                  (LPBYTE)value, &dwSize);
        RegCloseKey(hKey);

        return result == ERROR_SUCCESS && dwType == type;
    }
    else
        return FALSE;
}

//---------------------------------------------------------------------
// Gets the value from DIRECT3D Reference device registry key
// Returns TRUE if success
// If fails value is not changed
//---------------------------------------------------------------------
BOOL
GetD3DRefRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize)
{

    HKEY hKey = (HKEY) NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3DREF, &hKey))
    {
        DWORD dwType;
        LONG result;
        result =  RegQueryValueEx(hKey, valueName, NULL, &dwType,
                                  (LPBYTE)value, &dwSize);
        RegCloseKey(hKey);

        return result == ERROR_SUCCESS && dwType == type;
    }
    else
        return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// RefAlignedBuffer32
///////////////////////////////////////////////////////////////////////////////
HRESULT
RefAlignedBuffer32::Grow(DWORD growSize)
{
    if (m_allocatedBuf)
        free(m_allocatedBuf);
    m_size = growSize;
    if ((m_allocatedBuf = malloc(m_size + 31)) == NULL)
    {
        m_allocatedBuf = 0;
        m_alignedBuf = 0;
        m_size = 0;
        return DDERR_OUTOFMEMORY;
    }
    m_alignedBuf = (LPVOID)(((ULONG_PTR)m_allocatedBuf + 31 ) & ~31);
    return S_OK;
}
//////////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\drv\refprov.hpp ===
//----------------------------------------------------------------------------
//
// refprov.hpp
//
// Base software HAL provider class.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _REFPROV_HPP_
#define _REFPROV_HPP_

//----------------------------------------------------------------------------
//
// RefHalProvider
//
// Implements the base HAL provider for the software rasterizers.
//
//----------------------------------------------------------------------------

class RefHalProvider : public IHalProvider
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID* ppvObj);
    STDMETHOD_(ULONG, AddRef)(THIS);
    STDMETHOD_(ULONG, Release)(THIS);
};

//----------------------------------------------------------------------------
//
// RefRastHalProvider
//
// Specific provider for the reference rasterizer.
//
//----------------------------------------------------------------------------

class RefRastHalProvider : public RefHalProvider
{
public:
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC7 pHwDesc,
                       LPD3DDEVICEDESC7 pHelDesc,
                       DWORD dwVersion);
};

//----------------------------------------------------------------------------
//
// NullDeviceHalProvider
//
// Specific provider for the null device.
//
//----------------------------------------------------------------------------

class NullDeviceHalProvider : public RefHalProvider
{
public:
    STDMETHOD(GetInterface)(THIS_
                            LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                            LPD3DHALPROVIDER_INTERFACEDATA pInterfaceData,
                            DWORD dwVersion);
    STDMETHOD(GetCaps)(THIS_
                       LPDDRAWI_DIRECTDRAW_GBL pDdGbl,
                       LPD3DDEVICEDESC7 pHwDesc,
                       LPD3DDEVICEDESC7 pHelDesc,
                       DWORD dwVersion);
};

#endif // #ifndef _REFPROV_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\common\rtarget.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// rtarget.hpp
//
// Direct3D Reference Device - Render Target Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// Constructor/Destructor
//
//-----------------------------------------------------------------------------
RDRenderTarget::RDRenderTarget( void )
{
    memset( this, 0, sizeof(*this) );
}
//-----------------------------------------------------------------------------
RDRenderTarget::~RDRenderTarget( void )
{
    if( m_bPreDX7DDI )
    {
        if( m_pColor ) delete m_pColor;
        if( m_pDepth ) delete m_pDepth;
    }
    return;
}

//-----------------------------------------------------------------------------
//
// ReadPixelColor - Reads color buffer bits and expands out into an RDColor
// value.  Buffer types without alpha return a 1.0 value for alpha.  Low
// bits of <8 bit colors are returned as zero.
//
//-----------------------------------------------------------------------------
void
RDRenderTarget::ReadPixelColor(
    INT32 iX, INT32 iY, UINT Sample,
    RDColor& Color)
{
    if ( NULL == m_pColor->GetBits() ) return;

    char* pSurfaceBits = PixelAddress( iX, iY, 0, Sample, m_pColor );
    Color.ConvertFrom( m_pColor->GetSurfaceFormat(), pSurfaceBits );
}

//-----------------------------------------------------------------------------
//
// WritePixelColor - Takes an RDColor value, formats it for the color buffer
// format, and writes the value into buffer.
//
// Dithering is applied here, when enabled, for <8 bits/channel surfaces.
//
//-----------------------------------------------------------------------------
void
RDRenderTarget::WritePixelColor(
    INT32 iX, INT32 iY, UINT Sample,
    const RDColor& Color, BOOL bDither)
{
    if ( NULL == m_pColor->GetBits() ) return;

    // default to round to nearest
    FLOAT fRoundOffset = .5F;
    if ( bDither )
    {
        static  FLOAT fDitherTable[16] =
        {
            .03125f,  .53125f,  .15625f,  .65625f,
            .78125f,  .28125f,  .90625f,  .40625f,
            .21875f,  .71875f,  .09375f,  .59375f,
            .96875f,  .46875f,  .84375f,  .34375f
        };

        // form 4 bit offset into dither table (2 LSB's of x and y) and get offset
        unsigned uDitherOffset = ( ( iX << 2) & 0xc ) | (iY & 0x3 );
        fRoundOffset = fDitherTable[uDitherOffset];
    }

    char* pSurfaceBits = PixelAddress( iX, iY, 0, Sample, m_pColor );
    Color.ConvertTo( m_pColor->GetSurfaceFormat(), fRoundOffset, pSurfaceBits );
}

void
RDRenderTarget::WritePixelColor(
    INT32 iX, INT32 iY,
    const RDColor& Color, BOOL bDither)
{
    for (int i=0; i<m_pColor->GetSamples(); i++)
    {
        WritePixelColor( iX, iY, i, Color, bDither );
    }
}

//-----------------------------------------------------------------------------
//
// Read/WritePixelDepth - Read/write depth buffer
//
//-----------------------------------------------------------------------------
void
RDRenderTarget::WritePixelDepth(
    INT32 iX, INT32 iY, UINT Sample,
    const RDDepth& Depth )
{
    // don't write if no Z buffer
    if ( NULL == m_pDepth ) { return; }

    char* pSurfaceBits = PixelAddress( iX, iY, 0, Sample, m_pDepth );

    switch (m_pDepth->GetSurfaceFormat())
    {
    case RD_SF_Z16S0:
        *((UINT16*)pSurfaceBits) = UINT16(Depth);
        break;
    case RD_SF_Z24S8:
    case RD_SF_Z24X8:
    case RD_SF_Z24X4S4:
        {
            // need to do read-modify-write to not step on stencil
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0xffffff00);
            uBufferBits |= (UINT32(Depth) << 8);
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RD_SF_S8Z24:
    case RD_SF_X8Z24:
    case RD_SF_X4S4Z24:
        {
            // need to do read-modify-write to not step on stencil
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0x00ffffff);
            uBufferBits |= (UINT32(Depth) & 0x00ffffff);
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RD_SF_Z15S1:
        {
            // need to do read-modify-write to not step on stencil
            UINT16 uBufferBits = *((UINT16*)pSurfaceBits);
            uBufferBits &= ~(0xfffe);
            uBufferBits |= (UINT16(Depth) << 1);
            *((UINT16*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RD_SF_S1Z15:
        {
            // need to do read-modify-write to not step on stencil
            UINT16 uBufferBits = *((UINT16*)pSurfaceBits);
            uBufferBits &= ~(0x7fff);
            uBufferBits |= (UINT16(Depth) & 0x7fff);
            *((UINT16*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RD_SF_Z32S0:
        *((UINT32*)pSurfaceBits) = UINT32(Depth);
        break;
    }
}

void
RDRenderTarget::WritePixelDepth(
    INT32 iX, INT32 iY,
    const RDDepth& Depth )
{
    if ( NULL == m_pDepth ) { return; }
    for (int i=0; i<m_pDepth->GetSamples(); i++)
    {
        WritePixelDepth( iX, iY, i, Depth );
    }
}

//-----------------------------------------------------------------------------
void
RDRenderTarget::ReadPixelDepth(
    INT32 iX, INT32 iY, UINT Sample,
    RDDepth& Depth )
{
    // don't read if no Z buffer
    if ( NULL == m_pDepth ) { return; }

    char* pSurfaceBits = PixelAddress( iX, iY, 0, Sample, m_pDepth );

    switch (m_pDepth->GetSurfaceFormat())
    {
    case RD_SF_Z16S0:
        Depth = *((UINT16*)pSurfaceBits);
        break;
    case RD_SF_Z24S8:
    case RD_SF_Z24X8:
    case RD_SF_Z24X4S4:
        // take upper 24 bits aligned to LSB
        Depth = ( *((UINT32*)pSurfaceBits) ) >> 8;
        break;
    case RD_SF_S8Z24:
    case RD_SF_X8Z24:
    case RD_SF_X4S4Z24:
        // take lower 24 bits
        Depth = ( *((UINT32*)pSurfaceBits) ) & 0x00ffffff;
        break;
    case RD_SF_Z15S1:
        // take upper 15 bits aligned to LSB
        Depth = (UINT16)(( *((UINT16*)pSurfaceBits) ) >> 1);
        break;
    case RD_SF_S1Z15:
        // take lower 15 bits
        Depth = (UINT16)(( *((UINT16*)pSurfaceBits) ) & 0x7fff);
        break;
    case RD_SF_Z32S0:
        Depth = *((UINT32*)pSurfaceBits);
        break;
    }
}

//-----------------------------------------------------------------------------
//
// Read/WritePixelStencil - Read/Write of stencil bits within depth buffer
// surface; write is done with read-modify-write so depth bits are not disturbed;
// stencil mask is applied outside
//
//-----------------------------------------------------------------------------
void
RDRenderTarget::WritePixelStencil(
    INT32 iX, INT32 iY, UINT Sample,
    UINT8 uStencil)
{
    // don't write if no Z/Stencil buffer or no stencil in Z buffer
    if ( (NULL == m_pDepth ) ||
        ((RD_SF_Z24S8 != m_pDepth->GetSurfaceFormat()) &&
         (RD_SF_S8Z24 != m_pDepth->GetSurfaceFormat()) &&
         (RD_SF_S1Z15 != m_pDepth->GetSurfaceFormat()) &&
         (RD_SF_Z15S1 != m_pDepth->GetSurfaceFormat()) &&
         (RD_SF_Z24X4S4 != m_pDepth->GetSurfaceFormat()) &&
         (RD_SF_X4S4Z24 != m_pDepth->GetSurfaceFormat())) ) { return; }

    char* pSurfaceBits = PixelAddress( iX, iY, 0, Sample, m_pDepth );

    // need to do read-modify-write to not step on Z
    switch(m_pDepth->GetSurfaceFormat())
    {
    case RD_SF_Z24S8:
        {
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0x000000ff);
            uBufferBits |= uStencil;
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RD_SF_S8Z24:
        {
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0xff000000);
            uBufferBits |= (uStencil << 24);
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RD_SF_Z24X4S4:
        {
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0x000000ff);
            uBufferBits |= (uStencil & 0xf);
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RD_SF_X4S4Z24:
        {
            UINT32 uBufferBits = *((UINT32*)pSurfaceBits);
            uBufferBits &= ~(0xff000000);
            uBufferBits |= ((uStencil & 0xf) << 24);
            *((UINT32*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RD_SF_Z15S1:
        {
            UINT16 uBufferBits = *((UINT16*)pSurfaceBits);
            uBufferBits &= ~(0x0001);
            uBufferBits |= uStencil & 0x1;
            *((UINT16*)pSurfaceBits) = uBufferBits;
        }
        break;
    case RD_SF_S1Z15:
        {
            UINT16 uBufferBits = *((UINT16*)pSurfaceBits);
            uBufferBits &= ~(0x8000);
            uBufferBits |= uStencil << 15;
            *((UINT16*)pSurfaceBits) = uBufferBits;
        }
        break;
    }

}

void
RDRenderTarget::WritePixelStencil(
    INT32 iX, INT32 iY,
    UINT8 uStencil)
{
    if ( NULL == m_pDepth ) { return; }
    for (int i=0; i<m_pDepth->GetSamples(); i++)
    {
        WritePixelStencil( iX, iY, i, uStencil );
    }
}

//-----------------------------------------------------------------------------
void
RDRenderTarget::ReadPixelStencil(
    INT32 iX, INT32 iY, UINT Sample,
    UINT8& uStencil)
{
    // don't read if no Z/Stencil buffer or no stencil in Z buffer
    if ( ( NULL == m_pDepth ) ||
        ((RD_SF_Z24S8 != m_pDepth->GetSurfaceFormat()) &&
         (RD_SF_S8Z24 != m_pDepth->GetSurfaceFormat()) &&
         (RD_SF_S1Z15 != m_pDepth->GetSurfaceFormat()) &&
         (RD_SF_Z15S1 != m_pDepth->GetSurfaceFormat()) &&
         (RD_SF_Z24X4S4 != m_pDepth->GetSurfaceFormat()) &&
         (RD_SF_X4S4Z24 != m_pDepth->GetSurfaceFormat()) ) ) { return; }

    char* pSurfaceBits = PixelAddress( iX, iY, 0, Sample, m_pDepth );

    switch(m_pDepth->GetSurfaceFormat())
    {
    case RD_SF_Z24S8:
        uStencil = (UINT8)( ( *((UINT32*)pSurfaceBits) ) & 0xff );
        break;
    case RD_SF_S8Z24:
        uStencil = (UINT8)( ( *((UINT32*)pSurfaceBits) ) >> 24 );
        break;
    case RD_SF_Z15S1:
        uStencil = (UINT8)( ( *((UINT16*)pSurfaceBits) ) & 0x1 );
        break;
    case RD_SF_S1Z15:
        uStencil = (UINT8)( ( *((UINT16*)pSurfaceBits) ) >> 15 );
        break;
    case RD_SF_Z24X4S4:
        uStencil = (UINT8)( ( *((UINT32*)pSurfaceBits) ) & 0xf );
        break;
    case RD_SF_X4S4Z24:
        uStencil = (UINT8)( ( ( *((UINT32*)pSurfaceBits) ) >> 24 ) & 0xf);
        break;
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\common\refdevi.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// refdevi.cpp
//
// Direct3D Reference Device - Main Internal Object Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// global controls                                                              //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////
float g_GammaTable[256];
UINT  g_iGamma = 150;

//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// RefDev Methods                                                               //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Constructor/Destructor for renderer core object.
//
//-----------------------------------------------------------------------------
RefDev::RefDev( LPDDRAWI_DIRECTDRAW_LCL pDDLcl, DWORD dwInterfaceType,
                RDDDITYPE dwDDIType, D3DCAPS8* pCaps8 )
    : m_RefVP(), m_RefVM(), m_Clipper(),
      m_FVFShader()

{
    m_Caps8 = *pCaps8;
    m_pDDLcl = NULL;
    m_wSaveFP = 0;
    m_bInBegin = FALSE;
    m_bPointSprite = 0;
    m_pRenderTarget = NULL;
    memset( m_fWBufferNorm, 0, sizeof( float)*2 );
    memset( m_dwRenderState, 0, sizeof( DWORD ) * D3DHAL_MAX_RSTATES );
    memset( &m_renderstate_override, 0, sizeof(m_renderstate_override) );
    m_cActiveTextureStages = 0;
    m_ReferencedTexCoordMask = 0;
    memset( m_pTexture, 0, sizeof(RDSurface2D*)*D3DHAL_TSS_MAXSTAGES );
    memset( m_dwTextureStageState, 0, sizeof(m_dwTextureStageState) );
    for (int i=0; i<D3DHAL_TSS_MAXSTAGES; i++) m_pTextureStageState[i] = m_dwTextureStageState[i];
    m_dwTexArrayLength = 0;
    m_LastState = 0;

    m_primType = (D3DPRIMITIVETYPE)0;
    m_dwNumVertices = 0;
    m_dwStartVertex = 0;
    m_dwNumIndices  = 0;
    m_dwStartIndex  = 0;

    m_RefVP.m_pDev = m_RefVM.m_pDev = m_Clipper.m_pDev = this;

    m_CurrentVShaderHandle = 0;
    m_pCurrentVShader      = NULL;
    m_qwFVFOut = 0;

    m_CurrentPShaderHandle = 0x0;

    m_Rast.Init( this );

    // All render and texture stage state is initialized by
    // DIRECT3DDEVICEI::stateInitialize

    m_dwInterfaceType = dwInterfaceType;
    m_dwDDIType = dwDDIType;
    m_pDDLcl = pDDLcl;

    // StateOverride initialize
    STATESET_INIT( m_renderstate_override );

    m_bOverrideTCI = FALSE;

    SetSetStateFunctions();

    // Set this renderstate so that the pre-DX8 emulations continue to work
    GetRS()[D3DRS_COLORWRITEENABLE] = 0xf;

    // set 'changed' flags
    m_dwRastFlags =
        RDRF_MULTISAMPLE_CHANGED|
        RDRF_PIXELSHADER_CHANGED|
        RDRF_LEGACYPIXELSHADER_CHANGED|
        RDRF_TEXTURESTAGESTATE_CHANGED;

    // make the gamma table
    {
        FLOAT   fGamma = (float)(log10(0.5f)/log10((float)g_iGamma/255));
        FLOAT   fOOGamma = 1/fGamma;
        FLOAT   fA = 0.018f;
        FLOAT   fS = (float)(((1-fOOGamma)*pow(fA,fOOGamma))/(1-(1-fOOGamma)*pow(fA,fOOGamma)));
        FLOAT   fGain = (float)((fOOGamma*pow(fA,(fOOGamma-1)))/(1-(1-fOOGamma)*pow(fA,fOOGamma)));
        FLOAT   fX;
        int     i;
        for (i = 0; i < 4; i++)
            g_GammaTable[i] = (float)(fGain*(((float)i)/255));
        for (i = 4; i < 256; i++)
            g_GammaTable[i] = (float)((1+fS)*pow((((float)i)/255),fOOGamma)-fS);
    }
}
//-----------------------------------------------------------------------------
RefDev::~RefDev( void )
{
    UINT i;

    // Clean up statesets
    for ( i = 0; i < m_pStateSets.ArraySize(); i++ )
    {
        if (m_pStateSets[i] != NULL)
            delete m_pStateSets[i];
    }

    // Clean up vertex shaders
    for( i=0; i<m_VShaderHandleArray.GetSize(); i++ )
    {
        delete m_VShaderHandleArray[i].m_pShader;
    }

    // Clean up pixel shaders
    for( i=0; i<m_PShaderHandleArray.GetSize(); i++ )
    {
        delete m_PShaderHandleArray[i].m_pShader;
    }

    // Clean up palette handles
    for( i=0; i<m_PaletteHandleArray.GetSize(); i++ )
    {
        delete m_PaletteHandleArray[i].m_pPal;
    }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// State Management Utilities                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// MapTextureHandleToDevice - This is called when texture handles change or
// when leaving legacy texture mode.  This maps the texture handle embedded
// in the per-stage state to texture object pointers.
//
//-----------------------------------------------------------------------------
void
RefDev::MapTextureHandleToDevice( int iStage )
{
    // map one
    m_pTexture[iStage] =
        MapHandleToTexture( m_TextureStageState[iStage].m_dwVal[D3DTSS_TEXTUREMAP] );
    m_pTexture[iStage]->SetRefDev(this);

    // update num active stages
    UpdateActiveTexStageCount();
}


//-----------------------------------------------------------------------------
//
// SetTextureHandle - On DX7, this is called when a texture handle is set.
// This maps the texture handle embedded in the per-stage state to texture
// object pointers.
//
//-----------------------------------------------------------------------------
HRESULT
RefDev::SetTextureHandle( int iStage, DWORD dwTexHandle )
{
    HRESULT hr = D3D_OK;

    // Special case, if texture handle == 0, then unmap the texture from the TSS
    if (dwTexHandle == 0)
    {
        m_pTexture[iStage] = NULL;

        // update num active stages
        UpdateActiveTexStageCount();
        return D3D_OK;
    }

    // Ask DDraw to decipher what this particular handle meant wrt. to the
    // the DDraw_Local associated with this instance of the Refrast
    RDSurface2D* pTex = (RDSurface2D *)g_SurfMgr.GetSurfFromList(m_pDDLcl,
                                                             dwTexHandle);
    if( pTex == NULL )
    {
        DPFERR( "Unable to obtain Texture from the list"  );
        return DDERR_INVALIDOBJECT;
    }

    // map one
    m_pTexture[iStage] = pTex;
    m_pTexture[iStage]->SetRefDev(this);

    // update num active stages
    UpdateActiveTexStageCount();
    return D3D_OK;
}

//-----------------------------------------------------------------------------
//
// UpdateActiveTexStageCount - Updates number of texture coordinate/lookup
// stages that are active.
//
//-----------------------------------------------------------------------------
void
RefDev::UpdateActiveTexStageCount( void )
{
    m_dwRastFlags |= RDRF_TEXTURESTAGESTATE_CHANGED;

    // DX3/5 - always one active texture stage
    if ( NULL != m_dwRenderState[D3DRENDERSTATE_TEXTUREHANDLE] )
    {
        m_cActiveTextureStages = 1;
        m_ReferencedTexCoordMask = 0x1;
        return;
    }

    // DX8+ pixel shading model - count derived from shader code
    if (m_CurrentPShaderHandle)
    {
        RDPShader* pShader = GetPShader(m_CurrentPShaderHandle);

        if( pShader )
        {
            m_cActiveTextureStages = pShader->m_cActiveTextureStages;
            m_ReferencedTexCoordMask = pShader->m_ReferencedTexCoordMask;
        }
        else
        {
            m_cActiveTextureStages = 0;
            m_ReferencedTexCoordMask = 0;
        }
        return;
    }

    // DX6/7 pixel shading model
    m_cActiveTextureStages = 0;
    for ( int iStage=0; iStage<D3DHAL_TSS_MAXSTAGES; iStage++ )
    {
        // check for disabled stage (subsequent are thus inactive)
        if ( m_TextureStageState[iStage].m_dwVal[D3DTSS_COLOROP] == D3DTOP_DISABLE )
        {
            break;
        }

        // check for incorrectly enabled stage (may be legacy)
        if ( ( m_pTexture[iStage] == NULL ) &&
             ( m_TextureStageState[iStage].m_dwVal[D3DTSS_COLORARG1] == D3DTA_TEXTURE ) )
        {
            break;
        }

        // stage is active
        m_cActiveTextureStages++;
    }
    m_ReferencedTexCoordMask = (1<<m_cActiveTextureStages)-1;
}

//-----------------------------------------------------------------------------
//
// MapHandleToTexture - Map handle to RDSurface2D pointer.  Handle is a ppTex,
// so test it and reference it.
//
//-----------------------------------------------------------------------------
RDSurface2D*
RefDev::MapHandleToTexture( D3DTEXTUREHANDLE hTex )
{
    if ( 0x0 == hTex ) { return NULL; }
#ifdef _IA64_
    _ASSERTa(FALSE, "This will not work on IA64", return NULL;);
#endif
    return ( *(RDSurface2D**)ULongToPtr(hTex) );
}


#ifndef __D3D_NULL_REF
//------------------------------------------------------------------------
//
// Called upon loading/unloading DLL
//
//------------------------------------------------------------------------
BOOL WINAPI
DllMain(HINSTANCE hmod, DWORD dwReason, LPVOID lpvReserved)
{
    switch( dwReason )
    {
    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        break;

    default:
        break;
    }

    return TRUE;
}
#endif //__D3D_NULL_REF

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\drv\drawprim.cpp ===
//----------------------------------------------------------------------------
//
// drawprim.cpp
//
// Implements DrawOnePrimitive, DrawOneIndexedPrimitive and
// DrawPrimitives.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "pch.cpp"
#pragma hdrstop

HRESULT
RefDev::DrawOnePrimitive( GArrayT<RDVertex>& VtxArray,
                          DWORD dwStartVertex,
                          D3DPRIMITIVETYPE PrimType,
                          UINT cVertices )
{
    INT i;
    RDVertex* pV0;
    RDVertex* pV1;
    RDVertex* pV2;
    HRESULT hr;
    DWORD dwCurrVtx = dwStartVertex;

    switch( PrimType )
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cVertices; i > 0; i--)
        {
            DrawPoint(&VtxArray[dwCurrVtx++]);
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cVertices / 2; i > 0; i--)
        {
            pV0 = &VtxArray[dwCurrVtx++];
            pV1 = &VtxArray[dwCurrVtx++];
            DrawLine(pV0, pV1);
        }
        break;
    case D3DPT_LINESTRIP:
        {
            pV1 = &VtxArray[dwCurrVtx];

            // Disable last-pixel setting for shared verties and store prestate.
            StoreLastPixelState(TRUE);

            // Initial pV0.
            for (i = (INT)cVertices - 1; i > 1; i--)
            {
                pV0 = pV1;
                dwCurrVtx++;
                pV1 = &VtxArray[dwCurrVtx];
                DrawLine(pV0, pV1);
            }

            // Restore last-pixel setting.
            StoreLastPixelState(FALSE);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                pV0 = &VtxArray[++dwCurrVtx];
                DrawLine(pV1, pV0);
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cVertices; i > 0; i -= 3)
        {
            pV0 = &VtxArray[dwCurrVtx++];
            pV1 = &VtxArray[dwCurrVtx++];
            pV2 = &VtxArray[dwCurrVtx++];
            DrawTriangle(pV0, pV1, pV2);
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = &VtxArray[dwCurrVtx++];
            pV2 = &VtxArray[dwCurrVtx++];

            for (i = (INT)cVertices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[dwCurrVtx++];
                DrawTriangle(pV0, pV1, pV2);

                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[dwCurrVtx++];
                DrawTriangle(pV0, pV2, pV1);
            }

            if (i > 0)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[dwCurrVtx];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = &VtxArray[dwCurrVtx++];
            // Preload initial pV0.
            pV1 = &VtxArray[dwCurrVtx++];
            for (i = (INT)cVertices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = &VtxArray[dwCurrVtx++];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;

    default:
        DPFERR( "Refrast Error: Unknown or unsupported primitive type "
                "requested of DrawOnePrimitive" );
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}


HRESULT 
RefDev::DrawOneIndexedPrimitive( GArrayT<RDVertex>& VtxArray,
                                 int  StartVertexIndex,
                                 LPWORD puIndices,
                                 DWORD StartIndex,
                                 UINT cIndices,
                                 D3DPRIMITIVETYPE PrimType )
{
    INT i;
    RDVertex* pV0;
    RDVertex* pV1;
    RDVertex* pV2;
    HRESULT hr;
    
    LPWORD pIndices = puIndices + StartIndex;
    
    switch( PrimType )
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cIndices; i > 0; i--)
        {
            pV0 = &VtxArray[StartVertexIndex + (*pIndices++)];
            DrawPoint(pV0);
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cIndices / 2; i > 0; i--)
        {
            pV0 = &VtxArray[StartVertexIndex + (*pIndices++)];
            pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
            DrawLine(pV0, pV1);
        }
        break;
    case D3DPT_LINESTRIP:
        {
            // Disable last-pixel setting for shared verties and store prestate.
            StoreLastPixelState(TRUE);
            // Initial pV1.
            pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
            for (i = (INT)cIndices - 1; i > 1; i--)
            {
                pV0 = pV1;
                pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
                DrawLine(pV0, pV1);
            }
            // Restore last-pixel setting.
            StoreLastPixelState(FALSE);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                pV0 = &VtxArray[StartVertexIndex + (*pIndices)];
                DrawLine(pV1, pV0);
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cIndices; i > 0; i -= 3)
        {
            pV0 = &VtxArray[StartVertexIndex + (*pIndices++)];
            pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
            pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];
            DrawTriangle(pV0, pV1, pV2);
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
            pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];

            for (i = (INT)cIndices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];
                DrawTriangle(pV0, pV1, pV2);

                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];
                DrawTriangle(pV0, pV2, pV1);
            }

            if (i > 0)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];
            // Preload initial pV0.
            pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
            for (i = (INT)cIndices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;

    default:
        DPFERR( "Refrast Error: Unknown or unsupported primitive type "
                "requested of DrawOneIndexedPrimitive" );
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

// DWORD index version
HRESULT 
RefDev::DrawOneIndexedPrimitive( GArrayT<RDVertex>& VtxArray,
                                 int   StartVertexIndex,
                                 LPDWORD puIndices,
                                 DWORD StartIndex,
                                 UINT cIndices,
                                 D3DPRIMITIVETYPE PrimType )
{
    INT i;
    RDVertex* pV0;
    RDVertex* pV1;
    RDVertex* pV2;
    HRESULT hr;

    LPDWORD pIndices = puIndices + StartIndex;

    switch( PrimType )
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cIndices; i > 0; i--)
        {
            pV0 = &VtxArray[StartVertexIndex + (*pIndices++)];
            DrawPoint(pV0);
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cIndices / 2; i > 0; i--)
        {
            pV0 = &VtxArray[StartVertexIndex + (*pIndices++)];
            pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
            DrawLine(pV0, pV1);
        }
        break;
    case D3DPT_LINESTRIP:
        {
            // Disable last-pixel setting for shared verties and store prestate.
            StoreLastPixelState(TRUE);
            // Initial pV1.
            pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
            for (i = (INT)cIndices - 1; i > 1; i--)
            {
                pV0 = pV1;
                pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
                DrawLine(pV0, pV1);
            }
            // Restore last-pixel setting.
            StoreLastPixelState(FALSE);

            // Draw last line with last-pixel setting from state.
            if (i == 1)
            {
                pV0 = &VtxArray[StartVertexIndex + (*pIndices)];
                DrawLine(pV1, pV0);
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cIndices; i > 0; i -= 3)
        {
            pV0 = &VtxArray[StartVertexIndex + (*pIndices++)];
            pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
            pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];
            DrawTriangle(pV0, pV1, pV2);
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
            pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];

            for (i = (INT)cIndices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];
                DrawTriangle(pV0, pV1, pV2);

                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];
                DrawTriangle(pV0, pV2, pV1);
            }

            if (i > 0)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = &VtxArray[StartVertexIndex + (*pIndices++)];
            // Preload initial pV0.
            pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
            for (i = (INT)cIndices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = &VtxArray[StartVertexIndex + (*pIndices++)];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;

    default:
        DPFERR( "Refrast Error: Unknown or unsupported primitive type "
                "requested of DrawOneIndexedPrimitive" );
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// DoDrawOneEdgeFlagTriangleFan
//
// Draw one list of triangle fans. It's called by both RastDrawOnePrimitive and
// RastDrawPrimitives.
//
//----------------------------------------------------------------------------
HRESULT
RefDev::DrawOneEdgeFlagTriangleFan( GArrayT<RDVertex>& VtxArray,
                                    UINT cVertices,
                                    UINT32 dwEdgeFlags )
{
    INT i;
    RDVertex* pV0;
    RDVertex* pV1;
    RDVertex* pV2;
    HRESULT hr;
    DWORD dwCurrVtx = 0;

    pV2 = &VtxArray[dwCurrVtx++];
    pV0 = &VtxArray[dwCurrVtx++];
    pV1 = &VtxArray[dwCurrVtx++];
    WORD wFlags = 0;
    if(dwEdgeFlags & 0x2)
        wFlags |= D3DTRIFLAG_EDGEENABLE1;
    if(dwEdgeFlags & 0x1)
        wFlags |= D3DTRIFLAG_EDGEENABLE3;
    if(cVertices == 3) {
        if(dwEdgeFlags & 0x4)
            wFlags |= D3DTRIFLAG_EDGEENABLE2;
        DrawTriangle(pV0, pV1, pV2, wFlags);
        return D3D_OK;
    }
    DrawTriangle(pV0, pV1, pV2, wFlags);
    UINT32 dwMask = 0x4;
    for (i = (INT)cVertices - 4; i > 0; i--)
    {
        pV0 = pV1;
        pV1 = &VtxArray[dwCurrVtx++];
        if(dwEdgeFlags & dwMask)
        {
            DrawTriangle(pV0, pV1, pV2, D3DTRIFLAG_EDGEENABLE1);
        }
        else
        {
            DrawTriangle(pV0, pV1, pV2, 0);
        }
        dwMask <<= 1;
    }
    pV0 = pV1;
    pV1 = &VtxArray[dwCurrVtx++];
    wFlags = 0;
    if(dwEdgeFlags & dwMask)
        wFlags |= D3DTRIFLAG_EDGEENABLE1;
    dwMask <<= 1;
    if(dwEdgeFlags & dwMask)
        wFlags |= D3DTRIFLAG_EDGEENABLE2;
    DrawTriangle(pV0, pV1, pV2, wFlags);

    return D3D_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\drv\refif.hpp ===
//----------------------------------------------------------------------------
//
// refif.hpp
//
// Refrast front-end/rasterizer interface header.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _REFIF_HPP_
#define _REFIF_HPP_

// Vertex data is aligned on 32-byte boundaries.
#define DP_VTX_ALIGN 32


// Macros to check if a pointer is valid
#if DBG
// Validate context. pCtx should be declared before this macro
// Type can be D3DContext or RefRast
#define VALIDATE_CONTEXT(caller_name, data_ptr, pCtx, type)  \
{   \
    if ((data_ptr) == NULL)   \
    {   \
        DPFM(0, DRV, ("in %s, data pointer = NULL", (caller_name)));  \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
    pCtx = (type)((data_ptr)->dwhContext); \
    if (!pCtx) \
    {   \
        DPFM(0, DRV, ("in %s, dwhContext = NULL", (caller_name)));    \
        (data_ptr)->ddrval = D3DHAL_CONTEXT_BAD;  \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
}
#else // !DBG
// Validate context. pCtx should be declared before this macro
// Type can be D3DContext or RefRast
#define VALIDATE_CONTEXT(caller_name, data_ptr, pCtx, type)  \
{   \
    pCtx = (type)((data_ptr)->dwhContext); \
}
#endif // !DBG

// Validate RefDev. pRefRast should be declared before this macro
#define VALIDATE_REFRAST_CONTEXT(caller_name, data_ptr)  \
{   \
    VALIDATE_CONTEXT(caller_name, data_ptr, pRefDev, RefDev*);\
}

#define CHECK_FVF(ret, pDCtx, dwFlags)  \
{   \
    if ((ret = pDCtx->CheckFVF(dwFlags)) != DD_OK)  \
    {   \
        return DDHAL_DRIVER_HANDLED;    \
    }   \
}

DWORD __stdcall
RefRastDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA pDPrim2Data);

HRESULT
RefRastLockTarget(RefDev *pRefRast);
void
RefRastUnlockTarget(RefDev *pRefRast);
HRESULT
RefRastUpdatePalettes(RefDev *pRefRast);

#endif // #ifndef _REFIF_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\drv\refif.cpp ===
//----------------------------------------------------------------------------
//
// refrastfn.cpp
//
// Reference rasterizer callback functions for D3DIM.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

// The DDI refrast is emulating
RDDDITYPE g_RefDDI;

// All the supported texture formats
DDSURFACEDESC g_ddsdTex[RD_MAX_NUM_TEXTURE_FORMATS];

// The current caps8 for newly created devices
static D3DCAPS8 g_RefCaps8;

// Maps D3DMULTISAMPLE_TYPE into the bit to use for the flags.
// Maps each of the multisampling values (2 to 16) to the bits[1] to bits[15]
// of wBltMSTypes and wFlipMSTypes
#define DDI_MULTISAMPLE_TYPE(x) (1 << ((x)-1))

//----------------------------------------------------------------------------
//
// RefRastUpdatePalettes
//
//----------------------------------------------------------------------------
HRESULT
RefRastUpdatePalettes(RefDev *pRefDev)
{
    INT i, j, k;
    RDSurface2D* pRDTex[D3DHAL_TSS_MAXSTAGES];
    D3DTEXTUREHANDLE phTex[D3DHAL_TSS_MAXSTAGES];
    HRESULT hr;
    int cActTex;

    if ((cActTex = pRefDev->GetCurrentTextureMaps(phTex, pRDTex)) == 0)
    {
        return D3D_OK;
    }

    for (j = 0; j < cActTex; j++)
    {
        // stages may not have texture bound
        if ( NULL == pRDTex[j] ) continue;
        pRDTex[j]->UpdatePalette();
    }

    return D3D_OK;

}

//----------------------------------------------------------------------------
//
// RDRenderTarget::Initialize
//
// Converts color and Z surface information into refrast form.
//
//----------------------------------------------------------------------------

HRESULT
RDRenderTarget::Initialize( LPDDRAWI_DDRAWSURFACE_LCL pLclColor,
                            LPDDRAWI_DDRAWSURFACE_LCL pLclZ )
{
    HRESULT hr;
    RDSurfaceFormat ColorFmt;
    RDSurfaceFormat ZFmt;
    RDSurface2D* pOldColor = m_pColor;
    RDSurface2D* pOldDepth = m_pDepth;

    if( m_pColor )
    {
        m_pColor = NULL;
    }
    if( m_pDepth )
    {
        m_pDepth = NULL;
    }

    // Find the surfaces from the global surface manager
    // We are assuming that CreateSurfaceEx has been called on these
    // surfaces before this.
    RDSurface2D* pColor = m_pColor = new RDSurface2D;
    if( pColor == NULL )
    {
        DPFERR( "Color surface could not be allocated" );
        m_pColor = pOldColor;
        m_pDepth = pOldDepth;
        return DDERR_OUTOFMEMORY;
    }
    if( FAILED( hr = pColor->Initialize( pLclColor ) ) )
    {
        DPFERR( "Unable to initialize the color buffer" );
        delete pColor;
        m_pColor = pOldColor;
        m_pDepth = pOldDepth;
        return hr;
    }

    if (NULL != pLclZ)
    {
        RDSurface2D* pDepth = m_pDepth = new RDSurface2D;
        if( pDepth == NULL )
        {
            DPFERR( "Depth surface could not be allocated" );
            delete pColor;
            m_pColor = pOldColor;
            m_pDepth = pOldDepth;
            return DDERR_OUTOFMEMORY;
        }
        if( FAILED( hr = pDepth->Initialize( pLclZ ) ) )
        {
            DPFERR("Unable to initialize the Depth buffer");
            delete pColor;
            delete pDepth;
            m_pColor = pOldColor;
            m_pDepth = pOldDepth;
            return hr;
        }
    }

    m_Clip.left = 0;
    m_Clip.top = 0;
    m_Clip.bottom = pColor->GetHeight() - 1;
    m_Clip.right = pColor->GetWidth() - 1;

    m_bPreDX7DDI = TRUE;
    delete pOldColor;
    delete pOldDepth;
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RDRenderTarget::Initialize
//
// Converts color and Z surface information into refrast form.
//
//----------------------------------------------------------------------------

HRESULT
RDRenderTarget::Initialize( LPDDRAWI_DIRECTDRAW_LCL pDDLcl,
                            LPDDRAWI_DDRAWSURFACE_LCL pLclColor,
                            LPDDRAWI_DDRAWSURFACE_LCL pLclZ )
{
    HRESULT hr;
    RDSurfaceFormat ColorFmt;
    RDSurfaceFormat ZFmt;
    RDSurface2D* pOldColor = m_pColor;
    RDSurface2D* pOldDepth = m_pDepth;

    if( m_pColor )
    {
        m_pColor = NULL;
    }
    if( m_pDepth )
    {
        m_pDepth = NULL;
    }

    // Find the surfaces from the global surface manager
    // We are assuming that CreateSurfaceEx has been called on these
    // surfaces before this.
    DWORD dwColorHandle = pLclColor->lpSurfMore->dwSurfaceHandle;
    RDSurface2D* pColor = m_pColor =
        (RDSurface2D *)g_SurfMgr.GetSurfFromList( pDDLcl,
                                                       dwColorHandle);
    if( pColor == NULL )
    {
        DPFERR("Color surface not found");
        m_pColor = pOldColor;
        m_pDepth = pOldDepth;
        return DDERR_INVALIDPARAMS;
    }

    if (NULL != pLclZ)
    {
        DWORD dwDepthHandle = pLclZ->lpSurfMore->dwSurfaceHandle;
        RDSurface2D* pDepth = m_pDepth =
            (RDSurface2D *)g_SurfMgr.GetSurfFromList( pDDLcl,
                                                           dwDepthHandle);
        if( pDepth == NULL )
        {
            DPFERR("Depth surface not found");
            m_pColor = pOldColor;
            m_pDepth = pOldDepth;
            return DDERR_INVALIDPARAMS;
        }
    }

    m_Clip.left = 0;
    m_Clip.top = 0;
    m_Clip.bottom = pColor->GetHeight() - 1;
    m_Clip.right = pColor->GetWidth() - 1;

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RDRenderTarget::Initialize
//
// Converts color and Z surface information into refrast form.
//
//----------------------------------------------------------------------------

HRESULT
RDRenderTarget::Initialize( LPDDRAWI_DIRECTDRAW_LCL pDDLcl,
                            DWORD dwColorHandle,
                            DWORD dwDepthHandle )
{
    HRESULT hr;
    RDSurfaceFormat ColorFmt;
    RDSurfaceFormat ZFmt;
    RDSurface2D* pOldColor = m_pColor;
    RDSurface2D* pOldDepth = m_pDepth;

    // Release objects we hold pointers to
    if( m_pColor )
    {
        m_pColor = NULL;
    }
    if( m_pDepth )
    {
        m_pDepth = NULL;
    }

    // Find the surfaces from the global surface manager
    // We are assuming that CreateSurfaceEx has been called on these
    // surfaces before this.
    RDSurface2D* pColor = m_pColor =
        (RDSurface2D *)g_SurfMgr.GetSurfFromList( pDDLcl,
                                                       dwColorHandle);
    if( pColor == NULL )
    {
        DPFERR("Color surface not found");
        m_pColor = pOldColor;
        m_pDepth = pOldDepth;
        return DDERR_INVALIDPARAMS;
    }

    if (0 != dwDepthHandle)
    {
        RDSurface2D* pDepth = m_pDepth =
            (RDSurface2D *)g_SurfMgr.GetSurfFromList( pDDLcl,
                                                           dwDepthHandle);
        if( pDepth == NULL )
        {
            DPFERR("Depth surface not found");
            m_pColor = pOldColor;
            m_pDepth = pOldDepth;
            return DDERR_INVALIDPARAMS;
        }
    }

    m_Clip.left = 0;
    m_Clip.top = 0;
    m_Clip.bottom = pColor->GetHeight() - 1;
    m_Clip.right = pColor->GetWidth() - 1;

    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// RefRastContextCreate
//
// Creates a RefDev and initializes it with the info passed in.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastContextCreate(LPD3DHAL_CONTEXTCREATEDATA pCtxData)
{
    RefDev *pRefDev;
    RDRenderTarget *pRendTgt;
    INT i;

    // Surface7 pointers for QI
    LPDDRAWI_DDRAWSURFACE_LCL pZLcl = NULL;
    LPDDRAWI_DDRAWSURFACE_LCL pColorLcl = NULL;
    HRESULT ret;

    DPFM(0, DRV, ("In the new RefRast Dll\n"));

    // this only needs to be called once, but once per context won't hurt
    RefRastSetMemif(&malloc, &free, &realloc);

    if ((pRendTgt = new RDRenderTarget()) == NULL)
    {
        pCtxData->ddrval = DDERR_OUTOFMEMORY;
        return DDHAL_DRIVER_HANDLED;
    }

    // If it is expected to be a DX7+ driver
    if (g_RefDDI < RDDDI_DX7HAL)
    {
        if (pCtxData->lpDDS)
            pColorLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(pCtxData->lpDDS))->lpLcl;
        if (pCtxData->lpDDSZ)
            pZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(pCtxData->lpDDSZ))->lpLcl;

        // Collect surface information where the failures are easy to handle.
        pCtxData->ddrval = pRendTgt->Initialize( pColorLcl, pZLcl );
    }
    else
    {
        pColorLcl = pCtxData->lpDDSLcl;
        pZLcl     = pCtxData->lpDDSZLcl;

        // Collect surface information where the failures are easy to handle.
        pCtxData->ddrval = pRendTgt->Initialize( pCtxData->lpDDLcl, pColorLcl,
                                                 pZLcl );
    }

    if (pCtxData->ddrval != D3D_OK)
    {
        delete pRendTgt;
        return DDHAL_DRIVER_HANDLED;
    }


    // Note:
    // dwhContext is used by the runtime to inform the driver, which
    // d3d interface is calling the driver.
    if ( ( pRefDev = new RefDev( pCtxData->lpDDLcl,
                                               (DWORD)(pCtxData->dwhContext),
                                               g_RefDDI, &g_RefCaps8 ) ) == NULL )
    {
        pCtxData->ddrval = DDERR_OUTOFMEMORY;
        return DDHAL_DRIVER_HANDLED;
    }

    pRefDev->SetRenderTarget( pRendTgt );

    //  return RR object pointer as context handle
    pCtxData->dwhContext = (ULONG_PTR)pRefDev;

    pCtxData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastContextDestroy
//
// Destroy a RefDev.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastContextDestroy(LPD3DHAL_CONTEXTDESTROYDATA pCtxDestroyData)
{
    RefDev *pRefDev;

    // Check RefDev
    VALIDATE_REFRAST_CONTEXT("RefRastContextDestroy", pCtxDestroyData);

    // Clean up override bits

    RDRenderTarget *pRendTgt = pRefDev->GetRenderTarget();
    if ( NULL != pRendTgt ) { delete pRendTgt; }

    delete pRefDev;

    pCtxDestroyData->ddrval = D3D_OK;
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastSceneCapture
//
// Pass scene capture callback to ref rast.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastSceneCapture(LPD3DHAL_SCENECAPTUREDATA pData)
{
    RefDev *pRefDev;

    // Check RefDev
    VALIDATE_REFRAST_CONTEXT("RefRastSceneCapture", pData);

    pRefDev->SceneCapture( pData->dwFlag );

    pData->ddrval = D3D_OK;        // Should this be changed to a QI ?

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastSetRenderTarget
//
// Update a RefRast context with the info from a new render target.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastSetRenderTarget(LPD3DHAL_SETRENDERTARGETDATA pTgtData)
{
    RefDev *pRefDev;
    LPDDRAWI_DDRAWSURFACE_LCL pZLcl = NULL;
    LPDDRAWI_DDRAWSURFACE_LCL pColorLcl = NULL;
    HRESULT ret;

    // Check RefDev
    VALIDATE_REFRAST_CONTEXT("RefRastSetRenderTarget", pTgtData);

    _ASSERT( pRefDev->IsDriverDX6AndBefore(), "This callback should"
        "never be called on DDIs DX7 and beyond" )

    _ASSERT( pRefDev->IsInterfaceDX6AndBefore(), "An older interface should"
             "never call this DLL" )

    RDRenderTarget *pRendTgt = pRefDev->GetRenderTarget();
    if ( NULL == pRendTgt ) { return DDHAL_DRIVER_HANDLED; }

    if( pTgtData->lpDDS )
        pColorLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(pTgtData->lpDDS))->lpLcl;
    if( pTgtData->lpDDSZ )
        pZLcl = ((LPDDRAWI_DDRAWSURFACE_INT)(pTgtData->lpDDSZ))->lpLcl;

    // Collect surface information.
    pTgtData->ddrval = pRendTgt->Initialize( pColorLcl, pZLcl);
    if (pTgtData->ddrval != D3D_OK)
    {
        return DDHAL_DRIVER_HANDLED;
    }

    pRefDev->SetRenderTarget(pRendTgt);

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastValidateTextureStageState
//
// Validate current blend operations.  RefRast does everything.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastValidateTextureStageState(LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pData)
{
    RefDev *pRefDev;

    // Check RefDev
    VALIDATE_REFRAST_CONTEXT("RefRastValidateTextureStageState", pData);

    pData->dwNumPasses = 1;
    pData->ddrval = D3D_OK;

    return DDHAL_DRIVER_HANDLED;
}


//----------------------------------------------------------------------------
//
// RefRastTextureCreate
//
// Creates a RefRast texture and initializes it with the info passed in.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastTextureCreate(LPD3DHAL_TEXTURECREATEDATA pTexData)
{
    RefDev *pRefDev;
    RDSurface2D* pRDTex;
    HRESULT hr;
    LPDDRAWI_DDRAWSURFACE_LCL pLcl;

    if (pTexData->lpDDS)
    {
        pLcl = ((LPDDRAWI_DDRAWSURFACE_INT)pTexData->lpDDS)->lpLcl;
    }

    // Check RefDev
    VALIDATE_REFRAST_CONTEXT("RefRastTextureCreate", pTexData);

    // Runtime shouldnt be calling TextureCreate for DX7 and newer
    // driver models
    _ASSERT( pRefDev->IsDriverDX6AndBefore(), "This DDI should not"
             "be called from DDIs previous to DX7" );

    // assume OKness
    pTexData->ddrval = D3D_OK;

    // Allocate RDSurface2D
    if ( !(pRefDev->TextureCreate(
        (LPD3DTEXTUREHANDLE)&(pTexData->dwHandle), &pRDTex ) ) )
    {
        pTexData->ddrval = DDERR_GENERIC;
        return DDHAL_DRIVER_HANDLED;
    }

    // Init texturemap.
    hr = pRDTex->Initialize( pLcl );
    if (hr != D3D_OK)
    {
        pTexData->ddrval = hr;
        return DDHAL_DRIVER_HANDLED;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastTextureDestroy
//
// Destroy a RefRast texture.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastTextureDestroy(LPD3DHAL_TEXTUREDESTROYDATA pTexDestroyData)
{
    RefDev *pRefDev;

    // Check RefDev
    VALIDATE_REFRAST_CONTEXT("RefRastTextureDestroy", pTexDestroyData);

    // Runtime shouldnt be Calling TextureCreate for DX7 and newer
    // driver models
    _ASSERT( pRefDev->IsDriverDX6AndBefore(), "This DDI should not"
             "be called from DDIs previous to DX7" );

    if (!(pRefDev->TextureDestroy(pTexDestroyData->dwHandle)))
    {
        pTexDestroyData->ddrval = DDERR_GENERIC;
    }
    else
    {
        pTexDestroyData->ddrval = D3D_OK;
    }

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastTextureGetSurf
//
// Returns the surface pointer associate with a texture handle.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastTextureGetSurf(LPD3DHAL_TEXTUREGETSURFDATA pTexGetSurf)
{
    RefDev *pRefDev;

    // Check RefDev
    VALIDATE_REFRAST_CONTEXT("RefRastTextureGetSurf", pTexGetSurf);

    pTexGetSurf->lpDDS = pRefDev->TextureGetSurf(pTexGetSurf->dwHandle);
    pTexGetSurf->ddrval = D3D_OK;

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastGetDriverState
//
// Called by the runtime to get any kind of driver information
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastGetDriverState(LPDDHAL_GETDRIVERSTATEDATA pGDSData)
{
    RefDev *pRefDev;

    // Check RefDev
#if DBG
    if ((pGDSData) == NULL)
    {
        DPFERR("in %s, data pointer = NULL", "RefRastGetDriverState");
        return DDHAL_DRIVER_HANDLED;
    }
    pRefDev = (RefDev *)ULongToPtr((pGDSData)->dwhContext);
    if (!pRefDev)
    {
        DPFERR("in %s, dwhContext = NULL", "RefRastGetDriverState");
        pGDSData->ddRVal = D3DHAL_CONTEXT_BAD;
        return DDHAL_DRIVER_HANDLED;
    }
#else // !DBG
    pRefDev = (RefDev *)ULongToPtr((pGDSData)->dwhContext);
#endif // !DBG

    //
    // No implementation yet, so nothing is understood yet
    //
    pGDSData->ddRVal = S_FALSE;

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// FindAttachedSurfaceCaps2
//
// Walks the attachment list for the surface, looking for an attachment
// that has any of the dwCaps2 bits (or ignores if zero) and none of the
// FindAttachedSurfaceCaps2NotPresent bits.
//
//----------------------------------------------------------------------------
LPDDRAWI_DDRAWSURFACE_LCL
FindAttachedSurfaceCaps2(
    LPDDRAWI_DDRAWSURFACE_LCL pLcl,
    DWORD dwCaps2)
{
    LPATTACHLIST lpAttachStruct = pLcl->lpAttachList;
    while(lpAttachStruct)
    {
        if ((dwCaps2 == 0) || (lpAttachStruct->lpAttached->lpSurfMore->ddsCapsEx.dwCaps2 & dwCaps2))
            return lpAttachStruct->lpAttached;
        lpAttachStruct = lpAttachStruct->lpLink;
    }

    return 0;
}


//----------------------------------------------------------------------------
//
// ProcessPossibleMipMap
//
// Record private data structure for this surface and all attached mip
// sublevels.
//
//----------------------------------------------------------------------------
void
ProcessPossibleMipMap(
    LPDDHAL_CREATESURFACEEXDATA p,
    LPDDRAWI_DDRAWSURFACE_LCL lpDDSMipLcl
    )
{
    do
    {
        // This function should not deal with deletions. Assert this.
        _ASSERT( SURFACE_MEMORY(lpDDSMipLcl),
                 "Delete should have already taken place" );

        p->ddRVal = g_SurfMgr.AddSurfToList( p->lpDDLcl, lpDDSMipLcl, NULL );
        if (FAILED(p->ddRVal))
            return;

        // Now search down the 2nd+ order attachment: the chain
        // of mip sublevels.
        lpDDSMipLcl = FindAttachedSurfaceCaps2(lpDDSMipLcl,
                                               DDSCAPS2_MIPMAPSUBLEVEL);
    }
    while (lpDDSMipLcl);
}

//----------------------------------------------------------------------------
//
// RefRastCreateSurfaceEx
//
// Refrast implementation of CreateSurfaceEx. g_SurfMgr is the object
// that does the real job.
//
// CreateSurfaceEx is also used to inform the driver to create and destroy
// surface representations for a given handle. The way the driver can tell
// the difference between create and destroy is by looking at the fpVidmem
// pointer of the passed local. If it is null, it is a destroy.
//
// Create: This call is atomic. i.e. the attachments are all done by the
//         runtime. The driver is expected to walk through the attachment and
//         form its internal picture as described below.
// For complex surfaces (mipped textures, cubemaps), we need to record an
// internal representation for the top-level surface that includes all
// sub-surfaces. This is because the handle associated with the top-level
// surface is what's passed to SetTextureStage.
// However, we also need entries in our list that allow us to set any
// of the sublevels as render targets. Thus this top-level routine iterates
// across the entire attachment graph (to accomodate SRT on any subsurface)
// and the lower-level routine (RDSurface2D::Initialize) also iterates across
// the whole graph (to accomodate SetTexture on the top-level).
// A flipping chain is another structure that needs SRT to work on all
// contained surfaces.
//
// Destroy: The destruction unfortunately is not atomic. The driver gets
//          the call to destroy per sub-level. The attachment has no meaning
//          at this time, so the driver should only delete the level being
//          referred to.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastCreateSurfaceEx(LPDDHAL_CREATESURFACEEXDATA p)
{
#if DBG
    if( p == NULL )
    {
        DPFERR("CreateSurfaceExData ptr is NULL");
        return DDHAL_DRIVER_HANDLED;
    }
    if( p->lpDDLcl == NULL || p->lpDDSLcl == NULL )
    {
        DPFERR("DDLcl or the DDSLcl ptr is NULL");
        return DDHAL_DRIVER_HANDLED;
    }
#endif
    LPDDRAWI_DDRAWSURFACE_LCL lpDDSLcl = p->lpDDSLcl;
    p->ddRVal = DD_OK;

    //
    // Is it a Delete call ? If so simply delete the surface-rep associated
    // with this local and dont walk the local chain.
    //

    if( 0 == SURFACE_MEMORY(lpDDSLcl) )
    {
        g_SurfMgr.RemoveSurfFromList( p->lpDDLcl, lpDDSLcl );
        return DDHAL_DRIVER_HANDLED;
    }

    ProcessPossibleMipMap(p, lpDDSLcl);

    //Now we have two possibilities: cubemap or flipping chain.
    // Check cube map first:

    //+ve X is always the first face
    // (Note a DX7 driver would have to handle cubes w/o the +X face (since DX7
    // cubes may have any set of faces missing).)
    if (lpDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_CUBEMAP_POSITIVEX)
    {
        //Go find each attached cubemap face and process it as a mipmap
        for (int i=1;i<6;i++)
        {
            DWORD dwCaps2=0;
            switch(i)
            {
            case 1: dwCaps2 = DDSCAPS2_CUBEMAP_NEGATIVEX; break;
            case 2: dwCaps2 = DDSCAPS2_CUBEMAP_POSITIVEY; break;
            case 3: dwCaps2 = DDSCAPS2_CUBEMAP_NEGATIVEY; break;
            case 4: dwCaps2 = DDSCAPS2_CUBEMAP_POSITIVEZ; break;
            case 5: dwCaps2 = DDSCAPS2_CUBEMAP_NEGATIVEZ; break;
            }

            //Find the top-level faces attached to the root
            //(there will be no mip sublevel of any of these five types
            //attached to the root).
            lpDDSLcl = FindAttachedSurfaceCaps2(p->lpDDSLcl, dwCaps2);
            if (lpDDSLcl) ProcessPossibleMipMap(p, lpDDSLcl);
        }
    }
    else if (
        0==(lpDDSLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP) &&
        0 != lpDDSLcl->lpAttachList)
    {
        //just assert that we're not handling some of the other types
        //we know are passed to CSEx.
        _ASSERT(0==(lpDDSLcl->ddsCaps.dwCaps & DDSCAPS_TEXTURE), "CSEx for an attached texture?");
        _ASSERT(0==(lpDDSLcl->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER), "CSEx for an attached execute buffer?");

        // We processed mipmaps above, so either there will be no
        // more attachments (aside from the mipsublevels), or it's
        // a flipping chain.

        // The first member of the chain was processed above.
        // Npw we look around the ring, terminating when we hit the first surface
        // again.
        //
        // NOTE: DX8 software drivers will only ever see a chain, not a ring.
        // This code terminates at the end of the chain.
        //
        // A real driver may have to check for attached Z surfaces
        // here, as well as stereo left surfaces.

        lpDDSLcl = lpDDSLcl->lpAttachList->lpAttached;
        _ASSERT(lpDDSLcl, "Bad attachment List");

        while (lpDDSLcl && lpDDSLcl != p->lpDDSLcl) //i.e. not the first surface again
        {
            //We just reuse the "ProcessPossibleMipmap" function, and
            //assert that it will not have to traverse a mipmap here.
            _ASSERT(0==(lpDDSLcl->ddsCaps.dwCaps & DDSCAPS_MIPMAP),
                "Flipping chains should not be mipmaps");

            ProcessPossibleMipMap(p, lpDDSLcl);

            //This is the termination condition we expect for DX8 software
            //drivers.
            if (0 == lpDDSLcl->lpAttachList)
            {
                lpDDSLcl = 0;
                break;
            }

            lpDDSLcl = lpDDSLcl->lpAttachList->lpAttached;

            _ASSERT(lpDDSLcl, "Bad attachment List");
        }
    }
    // else we drop through and do no further attachment list processing
    // (typically on mipmaps or execute buffers).

    return DDHAL_DRIVER_HANDLED;
}


extern HRESULT FASTCALL
FindOutSurfFormat(LPDDPIXELFORMAT  pDdPixFmt, RDSurfaceFormat* pFmt,
                  BOOL*   pbIsDepth);

//----------------------------------------------------------------------------
//
// RefRastCreateSurface
//
// Create a requested surface. Fake VIDMEM allocation.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastCreateSurface(LPDDHAL_CREATESURFACEDATA pData)
{
    LPDDRAWI_DDRAWSURFACE_LCL  pSLcl  = NULL;
    LPDDRAWI_DDRAWSURFACE_GBL  pSGbl  = NULL;
    LPDDRAWI_DDRAWSURFACE_MORE pSMore = NULL;
    DWORD dwBytesPerPixel = 0;
    DWORD dwBytesInVB = 0;
    DWORD dwNumBytes = 0;
    DWORD dwPitch = 0;
    DWORD dwSlicePitch = 0;
    DWORD i = 0, j = 0;
    BYTE* pBits = NULL;
    BOOL  isDXT = FALSE;
    UINT  MultiSampleCount;
    DWORD dwMultiSamplePitch = 0;
    BYTE* pMultiSampleBits = NULL;
    DWORD dwNumMultiSampleBytes = 0;
    HRESULT hr = S_OK;

    pData->ddRVal = DD_OK;

    //
    // Validation
    //

    // The surface count
    if( pData->dwSCnt < 1 )
    {
        DPFERR("At least one surface should be created");
        pData->ddRVal = E_FAIL;
        return DDHAL_DRIVER_HANDLED;
    }

    // Primary surface cannot be handled here
    if( pData->lpDDSurfaceDesc->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE )
    {
        DPFERR("Refrast cannot allocate Primary surface");
        pData->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_HANDLED;
    }

    // Only Vidmem or Driver Managed allocations are handled here
    if(((pData->lpDDSurfaceDesc->ddsCaps.dwCaps &
          (DDSCAPS_VIDEOMEMORY | DDSCAPS_LOCALVIDMEM)) == 0)
        &&
        ((pData->lplpSList[0]->lpSurfMore->ddsCapsEx.dwCaps2 &
          DDSCAPS2_TEXTUREMANAGE) == 0))
    {
        DPFERR("Refrast can only allocate Vidmem or DriverManaged surfaces");
        pData->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_HANDLED;
    }

    // Dont allocate if the width or the height is not provided
    if( (pData->lpDDSurfaceDesc->dwFlags & (DDSD_WIDTH | DDSD_HEIGHT )) !=
        (DDSD_WIDTH | DDSD_HEIGHT ) )
    {
        DPFERR("No size provided for the surface");
        pData->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_HANDLED;
    }

    // Currently, allocation takes place only if a pixel format is provided
    if( pData->lpDDSurfaceDesc->dwFlags & DDSD_PIXELFORMAT )
    {
        dwBytesPerPixel =
            (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwRGBBitCount >> 3);

        // For FourCCs, we need to explicitly indicate the bytes per pixel

        if ((dwBytesPerPixel == 0) &&
            (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFlags & DDPF_FOURCC))
        {
            if( IsYUV( pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC ) )
            {
                dwBytesPerPixel = 2;
            }
            else if( IsDXTn( pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC ) )
            {
                dwBytesPerPixel = 1;
                isDXT = TRUE;
            }
            // All the new surface formats (introduced after DX7) are marked as
            // 4CC. Technically they are not 4CC, that field is overloaded to
            // mean the new DX8 style format ID.
            else if( (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC ==
                      0xFF000004)    ||
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC ==
                      (DWORD) D3DFMT_Q8W8V8U8) ||
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC ==
                      (DWORD) D3DFMT_V16U16) ||
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC ==
                      (DWORD) D3DFMT_W11V11U10) ||
                     // Formats introduced in DX8.1
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC == 
                      (DWORD)D3DFMT_A2B10G10R10) ||
#if 0
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC == 
                      (DWORD)D3DFMT_A8B8G8R8) ||
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC == 
                      (DWORD)D3DFMT_X8B8G8R8) ||
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC == 
                      (DWORD)D3DFMT_W10V11U11) ||
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC == 
                      (DWORD)D3DFMT_A8X8V8U8) ||
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC == 
                      (DWORD)D3DFMT_L8X8V8U8) ||
#endif
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC == 
                      (DWORD)D3DFMT_G16R16) ||
                     (pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC == 
                      (DWORD)D3DFMT_A2W10V10U10)
                    )
            {
                // Private new format
                dwBytesPerPixel = 4;
            }
        }
    }
    else if( pData->lpDDSurfaceDesc->ddsCaps.dwCaps  & DDSCAPS_EXECUTEBUFFER )
    {
        dwBytesInVB = ((LPDDSURFACEDESC2)(pData->lpDDSurfaceDesc))->dwWidth;
    }
    else
    {
        // Note: for DX8 drivers, this case should never be encountered.
        // In the future, if RefDev is revamped to work with legacy interfaces
        // then this case needs to something real instead of failing:
        // If the pixel-formats are not provided, then the current primary
        // format should be assumed.
        DPFERR( "Refrast can only allocate if PixelFormat is provided" );
        pData->ddRVal = DDERR_UNSUPPORTED;
        return DDHAL_DRIVER_HANDLED;
    }

    //
    // Allocate the memory and compute the Pitch for every surface on the
    // list.
    //

    // We should be guaranteed that this is the same for all surfaces in the
    // list
    MultiSampleCount = 0xf & (pData->lplpSList[0]->lpSurfMore->ddsCapsEx.dwCaps3);

    //This will be the case on older than DX8 runtimes
    if (MultiSampleCount == 0)
    {
        MultiSampleCount = 1;
    }


    for( i = 0; i < pData->dwSCnt; i++ )
    {
        RDCREATESURFPRIVATE* pPriv = NULL;

        pSLcl  = pData->lplpSList[i];
        pSGbl  = pSLcl->lpGbl;
        pSMore = pSLcl->lpSurfMore;
        DWORD dwHeight = pSGbl->wHeight;

        // If already allocated, just return
        if( pSGbl->fpVidMem || pSGbl->dwReserved1 )
        {
            DPFERR("Surface has already been allocated");
            pData->ddRVal = E_FAIL;
            break;
        }

        // Figure out if it is a vertex buffer
        if( dwBytesInVB )
        {
            dwNumBytes = dwBytesInVB;
            dwPitch = dwBytesInVB;
        }
        else
        {
            // Figure out the pitch and allocate
            switch( pData->lpDDSurfaceDesc->ddpfPixelFormat.dwFourCC )
            {
            case MAKEFOURCC('D', 'X', 'T', '1'):
                dwMultiSamplePitch = (MultiSampleCount *
                                      ((pSGbl->wWidth+3)>>2) *
                                      g_DXTBlkSize[0] + 7) & ~7;
                dwPitch = (((pSGbl->wWidth+3)>>2) * g_DXTBlkSize[0] + 7) & ~7;
                dwHeight = ((pSGbl->wHeight+3)>>2);
                break;
            case MAKEFOURCC('D', 'X', 'T', '2'):
                dwMultiSamplePitch = (MultiSampleCount *
                                      ((pSGbl->wWidth+3)>>2) *
                                      g_DXTBlkSize[1] + 7) & ~7;
                dwPitch = (((pSGbl->wWidth+3)>>2) * g_DXTBlkSize[1] + 7) & ~7;
                dwHeight = ((pSGbl->wHeight+3)>>2);
                break;
            case MAKEFOURCC('D', 'X', 'T', '3'):
                dwMultiSamplePitch = (MultiSampleCount *
                                      ((pSGbl->wWidth+3)>>2) *
                                      g_DXTBlkSize[2] + 7) & ~7;
                dwPitch = (((pSGbl->wWidth+3)>>2) *
                           g_DXTBlkSize[2] + 7) & ~7;
                dwHeight = ((pSGbl->wHeight+3)>>2);
                break;
            case MAKEFOURCC('D', 'X', 'T', '4'):
                dwMultiSamplePitch = (MultiSampleCount *
                                      ((pSGbl->wWidth+3)>>2) *
                                      g_DXTBlkSize[3] + 7) & ~7;
                dwPitch = (((pSGbl->wWidth+3)>>2) *
                           g_DXTBlkSize[3] + 7) & ~7;
                dwHeight = ((pSGbl->wHeight+3)>>2);
                break;
            case MAKEFOURCC('D', 'X', 'T', '5'):
                dwMultiSamplePitch = (MultiSampleCount *
                                      ((pSGbl->wWidth+3)>>2) *
                                      g_DXTBlkSize[4] + 7) & ~7;
                dwPitch = (((pSGbl->wWidth+3)>>2) *
                           g_DXTBlkSize[4] + 7) & ~7;
                dwHeight = ((pSGbl->wHeight+3)>>2);
                break;
            default:
                dwMultiSamplePitch = (MultiSampleCount
                                      * dwBytesPerPixel *
                                      pSGbl->wWidth + 7) & ~7;
                dwPitch = (dwBytesPerPixel *
                           pSGbl->wWidth + 7) & ~7;
                break;
            }

            if (!(pSMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME))
            {
                dwNumBytes = dwPitch * dwHeight;
                if( MultiSampleCount > 1 )
                    dwNumMultiSampleBytes = dwMultiSamplePitch *
                        pSGbl->wHeight;
            }
            else
            {
                _ASSERT( dwMultiSamplePitch == dwPitch,
                         "Cant have multisample for volume textures\n" );
                dwSlicePitch = dwPitch * dwHeight;

                // low word of ddsCaps.ddsCapsEx.dwCaps4 has depth
                // (volume texture only).
                dwNumBytes  = dwSlicePitch *
                    LOWORD(pSMore->ddsCapsEx.dwCaps4);
            }
        }

        pPriv = new RDCREATESURFPRIVATE;
        if( pPriv == NULL )
        {
            DPFERR("Allocation failed");
            pData->ddRVal = DDERR_OUTOFMEMORY;
            break;
        }

        pPriv->pBits = new BYTE[dwNumBytes];
        if( pPriv->pBits == NULL)
        {
            DPFERR("Allocation failed");
            delete pPriv;
            pData->ddRVal = DDERR_OUTOFMEMORY;
            break;
        }
        pPriv->dwPitch                 = dwPitch;

        // Allocate the private MultiSample buffer
        if( dwNumMultiSampleBytes )
        {
            pPriv->pMultiSampleBits = new BYTE[dwNumMultiSampleBytes];
            if( pPriv->pMultiSampleBits == NULL)
            {
                DPFERR("Multisample allocation failed");
                delete pPriv;
                pData->ddRVal = DDERR_OUTOFMEMORY;
                break;
            }
            pPriv->dwMultiSamplePitch = dwMultiSamplePitch;
            pPriv->wSamples = (WORD)MultiSampleCount;
            HR_RET(FindOutSurfFormat(&(DDSurf_PixFmt(pSLcl)),
                                     &pPriv->SurfaceFormat, NULL));
        }

        // Save the stuff on the surface
        pSGbl->fpVidMem = (FLATPTR)pPriv->pBits;
        if ( isDXT )
        {
            pSGbl->lPitch = dwNumBytes;
            if (pSMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
            {
                // set slice pitch (volume texture only).
                pSGbl->lSlicePitch = dwSlicePitch;
            }
        }
        else
        {
            pSGbl->lPitch = pPriv->dwPitch;
            if (pSMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
            {
                // set slice pitch (volume texture only).
                pSGbl->lSlicePitch = dwSlicePitch;
            }
        }
        pSGbl->dwReserved1 = (ULONG_PTR)pPriv;
    }

    // The loop completed successfully
    if( i == pData->dwSCnt )
        return DDHAL_DRIVER_HANDLED;

    // Else the loop terminated abnormally,
    // Free up allocated memory and quit with the error
    for( j = 0; j < i; j++ )
    {
        pData->lplpSList[j]->lpGbl->lPitch = 0;
        if (pSMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME)
        {
            pData->lplpSList[j]->lpGbl->lSlicePitch = 0;
        }
        delete (RDCREATESURFPRIVATE *)pData->lplpSList[j]->lpGbl->dwReserved1;
        pData->lplpSList[j]->lpGbl->dwReserved1 = 0;
    }
    return DDHAL_DRIVER_HANDLED;
}


//----------------------------------------------------------------------------
//
// RefRastDestroySurface
//
// Destroy a requested surface.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastDestroySurface(LPDDHAL_DESTROYSURFACEDATA pData)
{
    pData->ddRVal = DD_OK;

    //
    // Validation
    //
    if( pData->lpDDSurface->lpGbl->dwReserved1 == NULL )
    {
        DPFERR("This surface was not created by refrast");
        pData->ddRVal = E_FAIL;
        return DDHAL_DRIVER_HANDLED;
    }

    delete (RDCREATESURFPRIVATE *)pData->lpDDSurface->lpGbl->dwReserved1;
    pData->lpDDSurface->lpGbl->dwReserved1 = 0;

    // For vid-mem surfaces, runtime calls this DDI once per entire mip-chain
    // so this needs to be removed.
    // Now free the handle if it has been allocated for this surface
    pData->ddRVal = g_SurfMgr.RemoveSurfFromList(
        pData->lpDDSurface->lpSurfMore->lpDD_lcl,
        pData->lpDDSurface );

    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastLock
//
// Locks the given surface.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastLock(LPDDHAL_LOCKDATA pData)
{
    DWORD dwBytesPerPixel = 0;
    LPDDRAWI_DDRAWSURFACE_LCL pSLcl = pData->lpDDSurface;
    LPDDRAWI_DDRAWSURFACE_GBL  pSGbl = pSLcl->lpGbl;
    pData->ddRVal = DD_OK;

    //
    // Validation
    //
    if( pSGbl->dwReserved1 == NULL )
    {
        DPFERR("This surface was not created by refrast");
        pData->ddRVal = E_FAIL;
        return DDHAL_DRIVER_HANDLED;
    }

    //
    // Obtain the private data
    //
    RDCREATESURFPRIVATE* pPriv =
        (RDCREATESURFPRIVATE *)pSGbl->dwReserved1;

    if (g_RefDDI > RDDDI_DX7HAL)
    {
        // Figure out the device it is being used with.

        // If this is a Multisampled Rendertarget, need to filter down for
        // the runtime.
        if( pPriv->pMultiSampleBits )
        {
            BYTE* pBits   = pPriv->pBits;
            DWORD dwPitch = pPriv->dwPitch;

            BYTE* pMSBits   = pPriv->pMultiSampleBits;
            DWORD dwMSPitch = pPriv->dwMultiSamplePitch;

            RDSurfaceFormat sf = pPriv->SurfaceFormat;
            FLOAT fSampleScale = 1.F/((FLOAT)pPriv->wSamples);

            int width  = (int)DDSurf_Width(pSLcl);
            int height = (int)DDSurf_Height(pSLcl);
            for (int iY = 0; iY < height; iY++)
            {
                for (int iX = 0; iX < width; iX++)
                {
                    RDColor Color((UINT32)0);
                    for (UINT iS=0; iS<pPriv->wSamples; iS++)
                    {
                        RDColor SampleColor;
                        SampleColor.ConvertFrom(
                            sf, PixelAddress( iX, iY, 0, iS,
                                              pMSBits,
                                              dwMSPitch,
                                              0,
                                              pPriv->wSamples,
                                              sf ) );
                        Color.R += (SampleColor.R * fSampleScale);
                        Color.G += (SampleColor.G * fSampleScale);
                        Color.B += (SampleColor.B * fSampleScale);
                        Color.A += (SampleColor.A * fSampleScale);
                    }
                    Color.ConvertTo( sf, 0., PixelAddress( iX, iY, 0, pBits,
                                                           dwPitch, 0, sf ) );
                }
            }
        }
    }

    if( pData->bHasRect )
    {
        // If it is either a 1) VB, 2) IB or 3) CB then the
        // rect has a special meaning. rect.top - rect.bottom
        // gives the range of memory desired.
        // Note: it rect.bottom is the higher address and it is exclusive.
        if( pSLcl->ddsCaps.dwCaps  & DDSCAPS_EXECUTEBUFFER )
        {
            pData->lpSurfData = (LPVOID)(pPriv->pBits + pData->rArea.top);
        }
        else if( pSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME )
        {
            // If it is a volume texture, then the front and back are
            // or'd into the high word of rect->left and rect->right
            // respectively.
            DWORD front  = (pData->rArea.left >> 16);
            DWORD left   = pData->rArea.left & 0x0000ffff;
            DWORD top    = pData->rArea.top;
            DWORD slicePitch = pSGbl->lSlicePitch;
            if( IsDXTn( pSGbl->ddpfSurface.dwFourCC ) )
            {
                _ASSERT( FALSE, "Should not be reached without driver "
                         "managed support" );

            }
            else
            {
                dwBytesPerPixel = pSGbl->ddpfSurface.dwRGBBitCount >> 3;
                pData->lpSurfData = (LPVOID)(pPriv->pBits +
                                             front  * slicePitch +
                                             top    * pPriv->dwPitch +
                                             left   * dwBytesPerPixel);
            }
        }
        else
        {
            if( IsDXTn( pSGbl->ddpfSurface.dwFourCC ) )
            {
                _ASSERT( FALSE, "Should not be reached without driver "
                         "managed support" );

            }
            else
            {
                dwBytesPerPixel = pSGbl->ddpfSurface.dwRGBBitCount >> 3;
                pData->lpSurfData = (LPVOID)(pPriv->pBits +
                                             pData->rArea.top*pPriv->dwPitch +
                                             pData->rArea.left*dwBytesPerPixel);
            }
        }
    }
    else
    {
        pData->lpSurfData = (LPVOID)pPriv->pBits;
    }

    pPriv->Lock();
    return DDHAL_DRIVER_HANDLED;
}

//----------------------------------------------------------------------------
//
// RefRastUnlock
//
// Unlocks the given surface.
//
//----------------------------------------------------------------------------
DWORD __stdcall
RefRastUnlock(LPDDHAL_UNLOCKDATA pData)
{
    pData->ddRVal = DD_OK;

    //
    // Validation
    //
    if( pData->lpDDSurface->lpGbl->dwReserved1 == NULL )
    {
        DPFERR("This surface was not created by refrast");
        pData->ddRVal = E_FAIL;
        return DDHAL_DRIVER_HANDLED;
    }

    //
    // Obtain the private data
    //
    RDCREATESURFPRIVATE* pPriv =
        (RDCREATESURFPRIVATE *)pData->lpDDSurface->lpGbl->dwReserved1;

    pPriv->Unlock();
    return DDHAL_DRIVER_HANDLED;
}


//////////////////////////////////////////////////////////////////////////////
//
// Software DDI interface implementation
//
//////////////////////////////////////////////////////////////////////////////

//
// DX8 DDI caps
//

#define RESPATH_D3DREF  RESPATH_D3D "\\ReferenceDevice"
static void
ModifyDeviceCaps8( void )
{
    HKEY hKey = (HKEY) NULL;
    if( ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3DREF, &hKey) )
    {
        DWORD dwType;
        DWORD dwValue;
        char  dwString[128];
        DWORD dwSize;

        dwSize = sizeof(dwValue);
        if ( (ERROR_SUCCESS == RegQueryValueEx( hKey, "PixelShaderVersion", NULL,
                &dwType, (LPBYTE)&dwValue, &dwSize )) &&
             (dwType == REG_DWORD) )
        {
            g_RefCaps8.PixelShaderVersion = dwValue;
        }
        dwSize = sizeof(dwString);
        if ( (ERROR_SUCCESS == RegQueryValueEx( hKey, "MaxPixelShaderValue", NULL,
                &dwType, (LPBYTE)dwString, &dwSize )) &&
             (dwType == REG_SZ) )
        {
            sscanf( dwString, "%f", &g_RefCaps8.MaxPixelShaderValue );
        }

        RegCloseKey(hKey);
    }


}

static void
FillOutDeviceCaps8( RDDDITYPE ddi )
{
    g_RefCaps8.DevCaps=
        D3DDEVCAPS_EXECUTESYSTEMMEMORY  |
        D3DDEVCAPS_TLVERTEXSYSTEMMEMORY |
        D3DDEVCAPS_TEXTURESYSTEMMEMORY  |
        D3DDEVCAPS_DRAWPRIMTLVERTEX     |
        D3DDEVCAPS_PUREDEVICE           |
        D3DDEVCAPS_DRAWPRIMITIVES2EX    |
        D3DDEVCAPS_HWVERTEXBUFFER       |
        D3DDEVCAPS_HWINDEXBUFFER        |
        0;

    g_RefCaps8.PrimitiveMiscCaps =
        D3DPMISCCAPS_MASKZ                 |
        D3DPMISCCAPS_LINEPATTERNREP        |
        D3DPMISCCAPS_CULLNONE              |
        D3DPMISCCAPS_CULLCW                |
        D3DPMISCCAPS_CULLCCW               |
        D3DPMISCCAPS_COLORWRITEENABLE      |
        D3DPMISCCAPS_CLIPTLVERTS           |
        D3DPMISCCAPS_TSSARGTEMP            |
        D3DPMISCCAPS_FOGINFVF              |
        D3DPMISCCAPS_BLENDOP               ;

#ifdef __D3D_NULL_REF
    g_RefCaps8.PrimitiveMiscCaps |= D3DPMISCCAPS_NULLREFERENCE;
#endif //__D3D_NULL_REF

    g_RefCaps8.RasterCaps =
        D3DPRASTERCAPS_DITHER              |
        D3DPRASTERCAPS_ZTEST               |
        D3DPRASTERCAPS_FOGVERTEX           |
        D3DPRASTERCAPS_FOGTABLE            |
        D3DPRASTERCAPS_MIPMAPLODBIAS       |
        D3DPRASTERCAPS_PAT                 |
//        D3DPRASTERCAPS_ZBIAS               |
        D3DPRASTERCAPS_FOGRANGE            |
        D3DPRASTERCAPS_ANISOTROPY          |
        D3DPRASTERCAPS_WBUFFER             |
        D3DPRASTERCAPS_WFOG                |
        D3DPRASTERCAPS_ZFOG                |
        D3DPRASTERCAPS_COLORPERSPECTIVE    ;

    g_RefCaps8.ZCmpCaps =
        D3DPCMPCAPS_NEVER        |
        D3DPCMPCAPS_LESS         |
        D3DPCMPCAPS_EQUAL        |
        D3DPCMPCAPS_LESSEQUAL    |
        D3DPCMPCAPS_GREATER      |
        D3DPCMPCAPS_NOTEQUAL     |
        D3DPCMPCAPS_GREATEREQUAL |
        D3DPCMPCAPS_ALWAYS       ;

    g_RefCaps8.SrcBlendCaps =
        D3DPBLENDCAPS_ZERO             |
        D3DPBLENDCAPS_ONE              |
        D3DPBLENDCAPS_SRCCOLOR         |
        D3DPBLENDCAPS_INVSRCCOLOR      |
        D3DPBLENDCAPS_SRCALPHA         |
        D3DPBLENDCAPS_INVSRCALPHA      |
        D3DPBLENDCAPS_DESTALPHA        |
        D3DPBLENDCAPS_INVDESTALPHA     |
        D3DPBLENDCAPS_DESTCOLOR        |
        D3DPBLENDCAPS_INVDESTCOLOR     |
        D3DPBLENDCAPS_SRCALPHASAT      |
        D3DPBLENDCAPS_BOTHSRCALPHA     |
        D3DPBLENDCAPS_BOTHINVSRCALPHA  ;

    g_RefCaps8.DestBlendCaps =
        D3DPBLENDCAPS_ZERO             |
        D3DPBLENDCAPS_ONE              |
        D3DPBLENDCAPS_SRCCOLOR         |
        D3DPBLENDCAPS_INVSRCCOLOR      |
        D3DPBLENDCAPS_SRCALPHA         |
        D3DPBLENDCAPS_INVSRCALPHA      |
        D3DPBLENDCAPS_DESTALPHA        |
        D3DPBLENDCAPS_INVDESTALPHA     |
        D3DPBLENDCAPS_DESTCOLOR        |
        D3DPBLENDCAPS_INVDESTCOLOR     |
        D3DPBLENDCAPS_SRCALPHASAT      ;

    g_RefCaps8.AlphaCmpCaps =
        D3DPCMPCAPS_NEVER        |
        D3DPCMPCAPS_LESS         |
        D3DPCMPCAPS_EQUAL        |
        D3DPCMPCAPS_LESSEQUAL    |
        D3DPCMPCAPS_GREATER      |
        D3DPCMPCAPS_NOTEQUAL     |
        D3DPCMPCAPS_GREATEREQUAL |
        D3DPCMPCAPS_ALWAYS       ;

    g_RefCaps8.ShadeCaps =
        D3DPSHADECAPS_COLORGOURAUDRGB       |
        D3DPSHADECAPS_SPECULARGOURAUDRGB    |
        D3DPSHADECAPS_ALPHAGOURAUDBLEND     |
        D3DPSHADECAPS_FOGGOURAUD            ;

    g_RefCaps8.TextureCaps =
        D3DPTEXTURECAPS_PERSPECTIVE              |
//        D3DPTEXTURECAPS_POW2                     |
        D3DPTEXTURECAPS_ALPHA                    |
        D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE |
        D3DPTEXTURECAPS_ALPHAPALETTE             |
        D3DPTEXTURECAPS_PROJECTED                |
        D3DPTEXTURECAPS_CUBEMAP                  |
        D3DPTEXTURECAPS_VOLUMEMAP                |
        D3DPTEXTURECAPS_MIPMAP                   |
        D3DPTEXTURECAPS_MIPVOLUMEMAP             |
        D3DPTEXTURECAPS_MIPCUBEMAP               |
        D3DPTEXTURECAPS_CUBEMAP_POW2             |
        D3DPTEXTURECAPS_VOLUMEMAP_POW2           ;

    g_RefCaps8.TextureFilterCaps =
        D3DPTFILTERCAPS_MINFPOINT           |
        D3DPTFILTERCAPS_MINFLINEAR          |
        D3DPTFILTERCAPS_MINFANISOTROPIC     |
        D3DPTFILTERCAPS_MIPFPOINT           |
        D3DPTFILTERCAPS_MIPFLINEAR          |
        D3DPTFILTERCAPS_MAGFPOINT           |
        D3DPTFILTERCAPS_MAGFLINEAR          |
        D3DPTFILTERCAPS_MAGFANISOTROPIC     ;

    g_RefCaps8.CubeTextureFilterCaps =
        D3DPTFILTERCAPS_MINFPOINT           |
        D3DPTFILTERCAPS_MINFLINEAR          |
        D3DPTFILTERCAPS_MIPFPOINT           |
        D3DPTFILTERCAPS_MIPFLINEAR          |
        D3DPTFILTERCAPS_MAGFPOINT           |
        D3DPTFILTERCAPS_MAGFLINEAR          ;

    g_RefCaps8.VolumeTextureFilterCaps =
        D3DPTFILTERCAPS_MINFPOINT           |
        D3DPTFILTERCAPS_MINFLINEAR          |
        D3DPTFILTERCAPS_MIPFPOINT           |
        D3DPTFILTERCAPS_MIPFLINEAR          |
        D3DPTFILTERCAPS_MAGFPOINT           |
        D3DPTFILTERCAPS_MAGFLINEAR          ;

    g_RefCaps8.TextureAddressCaps =
        D3DPTADDRESSCAPS_WRAP          |
        D3DPTADDRESSCAPS_MIRROR        |
        D3DPTADDRESSCAPS_CLAMP         |
        D3DPTADDRESSCAPS_BORDER        |
        D3DPTADDRESSCAPS_INDEPENDENTUV |
        D3DPTADDRESSCAPS_MIRRORONCE    ;

    g_RefCaps8.VolumeTextureAddressCaps =
        D3DPTADDRESSCAPS_WRAP          |
        D3DPTADDRESSCAPS_MIRROR        |
        D3DPTADDRESSCAPS_CLAMP         |
        D3DPTADDRESSCAPS_BORDER        |
        D3DPTADDRESSCAPS_INDEPENDENTUV |
        D3DPTADDRESSCAPS_MIRRORONCE    ;

    g_RefCaps8.LineCaps =
        D3DLINECAPS_TEXTURE     |
        D3DLINECAPS_ZTEST       |
        D3DLINECAPS_BLEND       |
        D3DLINECAPS_ALPHACMP    |
        D3DLINECAPS_FOG         ;

    g_RefCaps8.MaxTextureWidth  = 4096;
    g_RefCaps8.MaxTextureHeight = 4096;
    g_RefCaps8.MaxVolumeExtent  = 4096;

    g_RefCaps8.MaxTextureRepeat = 32768;
    g_RefCaps8.MaxTextureAspectRatio = 0;
    g_RefCaps8.MaxAnisotropy = 16;
    g_RefCaps8.MaxVertexW = 1.0e10;

    g_RefCaps8.GuardBandLeft   = -32768.f;
    g_RefCaps8.GuardBandTop    = -32768.f;
    g_RefCaps8.GuardBandRight  =  32767.f;
    g_RefCaps8.GuardBandBottom =  32767.f;

    g_RefCaps8.ExtentsAdjust = 0.;
    g_RefCaps8.StencilCaps =
        D3DSTENCILCAPS_KEEP   |
        D3DSTENCILCAPS_ZERO   |
        D3DSTENCILCAPS_REPLACE|
        D3DSTENCILCAPS_INCRSAT|
        D3DSTENCILCAPS_DECRSAT|
        D3DSTENCILCAPS_INVERT |
        D3DSTENCILCAPS_INCR   |
        D3DSTENCILCAPS_DECR;

    g_RefCaps8.FVFCaps = 8 | D3DFVFCAPS_PSIZE;

    g_RefCaps8.TextureOpCaps =
        D3DTEXOPCAPS_DISABLE                   |
        D3DTEXOPCAPS_SELECTARG1                |
        D3DTEXOPCAPS_SELECTARG2                |
        D3DTEXOPCAPS_MODULATE                  |
        D3DTEXOPCAPS_MODULATE2X                |
        D3DTEXOPCAPS_MODULATE4X                |
        D3DTEXOPCAPS_ADD                       |
        D3DTEXOPCAPS_ADDSIGNED                 |
        D3DTEXOPCAPS_ADDSIGNED2X               |
        D3DTEXOPCAPS_SUBTRACT                  |
        D3DTEXOPCAPS_ADDSMOOTH                 |
        D3DTEXOPCAPS_BLENDDIFFUSEALPHA         |
        D3DTEXOPCAPS_BLENDTEXTUREALPHA         |
        D3DTEXOPCAPS_BLENDFACTORALPHA          |
        D3DTEXOPCAPS_BLENDTEXTUREALPHAPM       |
        D3DTEXOPCAPS_BLENDCURRENTALPHA         |
        D3DTEXOPCAPS_PREMODULATE               |
        D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR    |
        D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA    |
        D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR |
        D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA |
        D3DTEXOPCAPS_BUMPENVMAP                |
        D3DTEXOPCAPS_BUMPENVMAPLUMINANCE       |
        D3DTEXOPCAPS_DOTPRODUCT3               |
        D3DTEXOPCAPS_MULTIPLYADD               |
        D3DTEXOPCAPS_LERP                      ;

    g_RefCaps8.MaxTextureBlendStages = 8;
    g_RefCaps8.MaxSimultaneousTextures = 8;

    g_RefCaps8.VertexProcessingCaps      = 0;
    g_RefCaps8.MaxActiveLights           = 0;
    g_RefCaps8.MaxUserClipPlanes         = 0;
    g_RefCaps8.MaxVertexBlendMatrices    = 0;
    g_RefCaps8.MaxVertexBlendMatrixIndex = 0;

    g_RefCaps8.MaxPointSize = RD_MAX_POINT_SIZE;

    g_RefCaps8.MaxPrimitiveCount = 0x001fffff;
    g_RefCaps8.MaxVertexIndex = 0x00ffffff;
    g_RefCaps8.MaxStreams = 1;
    g_RefCaps8.MaxStreamStride = 256;

    g_RefCaps8.VertexShaderVersion  = D3DVS_VERSION(0,0);
    g_RefCaps8.MaxVertexShaderConst = 0;

    g_RefCaps8.PixelShaderVersion   = D3DPS_VERSION(1,4);
    g_RefCaps8.MaxPixelShaderValue  = FLT_MAX;

    // Non 3D Caps
    g_RefCaps8.Caps  = 0;
    g_RefCaps8.Caps2 = DDCAPS2_CANMANAGERESOURCE | DDCAPS2_CANRENDERWINDOWED | DDCAPS2_DYNAMICTEXTURES;

    switch( ddi )
    {
    case RDDDI_DX8TLHAL:
    g_RefCaps8.DevCaps |=
        D3DDEVCAPS_HWTRANSFORMANDLIGHT  |
        D3DDEVCAPS_RTPATCHES            |
        D3DDEVCAPS_RTPATCHHANDLEZERO    |
        D3DDEVCAPS_NPATCHES             |
        D3DDEVCAPS_QUINTICRTPATCHES     |
        0;
        g_RefCaps8.VertexProcessingCaps =
            D3DVTXPCAPS_TEXGEN            |
            D3DVTXPCAPS_MATERIALSOURCE7   |
            D3DVTXPCAPS_DIRECTIONALLIGHTS |
            D3DVTXPCAPS_POSITIONALLIGHTS  |
            D3DVTXPCAPS_TWEENING          |
            D3DVTXPCAPS_LOCALVIEWER       ;
        g_RefCaps8.MaxActiveLights = 0xffffffff;
        g_RefCaps8.MaxUserClipPlanes = RD_MAX_USER_CLIPPLANES;
        g_RefCaps8.MaxVertexBlendMatrices = RD_MAX_BLEND_WEIGHTS;
        g_RefCaps8.MaxVertexBlendMatrixIndex = RD_MAX_WORLD_MATRICES - 1;
        g_RefCaps8.MaxStreams = RD_MAX_NUMSTREAMS;
        g_RefCaps8.VertexShaderVersion  = D3DVS_VERSION(1,1);
        g_RefCaps8.MaxVertexShaderConst = RD_MAX_NUMCONSTREG;
        break;
    }
}


//
// pre-DX8 DDI caps
//

static D3DHAL_GLOBALDRIVERDATA RefGDD = { 0 };
static D3DHAL_D3DEXTENDEDCAPS RefExtCaps = { 0 };

static void
FillOutDeviceCaps( BOOL bIsNullDevice, RDDDITYPE ddi )
{
    //
    //  set device description
    //
    RefGDD.dwSize = sizeof(RefGDD);
    RefGDD.hwCaps.dwDevCaps =
        D3DDEVCAPS_FLOATTLVERTEX        |
        D3DDEVCAPS_EXECUTESYSTEMMEMORY  |
        D3DDEVCAPS_TLVERTEXSYSTEMMEMORY |
        D3DDEVCAPS_TEXTURESYSTEMMEMORY  |
        D3DDEVCAPS_DRAWPRIMTLVERTEX;

    RefGDD.dwNumVertices = (RD_MAX_VERTEX_COUNT - RD_MAX_CLIP_VERTICES);
    RefGDD.dwNumClipVertices = RD_MAX_CLIP_VERTICES;

    RefGDD.hwCaps.dpcTriCaps.dwSize = sizeof(D3DPRIMCAPS);
    RefGDD.hwCaps.dpcTriCaps.dwMiscCaps =
    D3DPMISCCAPS_MASKZ    |
    D3DPMISCCAPS_CULLNONE |
    D3DPMISCCAPS_CULLCW   |
    D3DPMISCCAPS_CULLCCW  ;
    RefGDD.hwCaps.dpcTriCaps.dwRasterCaps =
        D3DPRASTERCAPS_DITHER                   |
//        D3DPRASTERCAPS_ROP2                     |
//        D3DPRASTERCAPS_XOR                      |
//        D3DPRASTERCAPS_PAT                      |
        D3DPRASTERCAPS_ZTEST                    |
        D3DPRASTERCAPS_SUBPIXEL                 |
        D3DPRASTERCAPS_SUBPIXELX                |
        D3DPRASTERCAPS_FOGVERTEX                |
        D3DPRASTERCAPS_FOGTABLE                 |
//        D3DPRASTERCAPS_STIPPLE                  |
//        D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT   |
        D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |
//        D3DPRASTERCAPS_ANTIALIASEDGES           |
        D3DPRASTERCAPS_MIPMAPLODBIAS            |
//        D3DPRASTERCAPS_ZBIAS                    |
//        D3DPRASTERCAPS_ZBUFFERLESSHSR           |
        D3DPRASTERCAPS_FOGRANGE                 |
        D3DPRASTERCAPS_ANISOTROPY               |
        D3DPRASTERCAPS_WBUFFER                  |
        D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT |
        D3DPRASTERCAPS_WFOG |
        D3DPRASTERCAPS_ZFOG;
    RefGDD.hwCaps.dpcTriCaps.dwZCmpCaps =
        D3DPCMPCAPS_NEVER        |
        D3DPCMPCAPS_LESS         |
        D3DPCMPCAPS_EQUAL        |
        D3DPCMPCAPS_LESSEQUAL    |
        D3DPCMPCAPS_GREATER      |
        D3DPCMPCAPS_NOTEQUAL     |
        D3DPCMPCAPS_GREATEREQUAL |
        D3DPCMPCAPS_ALWAYS       ;
    RefGDD.hwCaps.dpcTriCaps.dwSrcBlendCaps =
        D3DPBLENDCAPS_ZERO             |
        D3DPBLENDCAPS_ONE              |
        D3DPBLENDCAPS_SRCCOLOR         |
        D3DPBLENDCAPS_INVSRCCOLOR      |
        D3DPBLENDCAPS_SRCALPHA         |
        D3DPBLENDCAPS_INVSRCALPHA      |
        D3DPBLENDCAPS_DESTALPHA        |
        D3DPBLENDCAPS_INVDESTALPHA     |
        D3DPBLENDCAPS_DESTCOLOR        |
        D3DPBLENDCAPS_INVDESTCOLOR     |
        D3DPBLENDCAPS_SRCALPHASAT      |
        D3DPBLENDCAPS_BOTHSRCALPHA     |
        D3DPBLENDCAPS_BOTHINVSRCALPHA  ;
    RefGDD.hwCaps.dpcTriCaps.dwDestBlendCaps =
        D3DPBLENDCAPS_ZERO             |
        D3DPBLENDCAPS_ONE              |
        D3DPBLENDCAPS_SRCCOLOR         |
        D3DPBLENDCAPS_INVSRCCOLOR      |
        D3DPBLENDCAPS_SRCALPHA         |
        D3DPBLENDCAPS_INVSRCALPHA      |
        D3DPBLENDCAPS_DESTALPHA        |
        D3DPBLENDCAPS_INVDESTALPHA     |
        D3DPBLENDCAPS_DESTCOLOR        |
        D3DPBLENDCAPS_INVDESTCOLOR     |
        D3DPBLENDCAPS_SRCALPHASAT      ;
    RefGDD.hwCaps.dpcTriCaps.dwAlphaCmpCaps =
    RefGDD.hwCaps.dpcTriCaps.dwZCmpCaps;
    RefGDD.hwCaps.dpcTriCaps.dwShadeCaps =
        D3DPSHADECAPS_COLORFLATRGB       |
        D3DPSHADECAPS_COLORGOURAUDRGB    |
        D3DPSHADECAPS_SPECULARFLATRGB    |
        D3DPSHADECAPS_SPECULARGOURAUDRGB |
        D3DPSHADECAPS_ALPHAFLATBLEND     |
        D3DPSHADECAPS_ALPHAGOURAUDBLEND  |
        D3DPSHADECAPS_FOGFLAT            |
        D3DPSHADECAPS_FOGGOURAUD         ;
    RefGDD.hwCaps.dpcTriCaps.dwTextureCaps =
        D3DPTEXTURECAPS_PERSPECTIVE              |
        D3DPTEXTURECAPS_POW2                     |
        D3DPTEXTURECAPS_ALPHA                    |
        D3DPTEXTURECAPS_TRANSPARENCY             |
        D3DPTEXTURECAPS_ALPHAPALETTE             |
        D3DPTEXTURECAPS_BORDER                   |
        D3DPTEXTURECAPS_TEXREPEATNOTSCALEDBYSIZE |
        D3DPTEXTURECAPS_ALPHAPALETTE             |
        D3DPTEXTURECAPS_PROJECTED                |
        D3DPTEXTURECAPS_CUBEMAP                  |
        D3DPTEXTURECAPS_COLORKEYBLEND;
    RefGDD.hwCaps.dpcTriCaps.dwTextureFilterCaps =
        D3DPTFILTERCAPS_NEAREST          |
        D3DPTFILTERCAPS_LINEAR           |
        D3DPTFILTERCAPS_MIPNEAREST       |
        D3DPTFILTERCAPS_MIPLINEAR        |
        D3DPTFILTERCAPS_LINEARMIPNEAREST |
        D3DPTFILTERCAPS_LINEARMIPLINEAR  |
        D3DPTFILTERCAPS_MINFPOINT        |
        D3DPTFILTERCAPS_MINFLINEAR       |
        D3DPTFILTERCAPS_MINFANISOTROPIC  |
        D3DPTFILTERCAPS_MIPFPOINT        |
        D3DPTFILTERCAPS_MIPFLINEAR       |
        D3DPTFILTERCAPS_MAGFPOINT        |
        D3DPTFILTERCAPS_MAGFLINEAR       |
        D3DPTFILTERCAPS_MAGFANISOTROPIC  ;
    RefGDD.hwCaps.dpcTriCaps.dwTextureBlendCaps =
        D3DPTBLENDCAPS_DECAL         |
        D3DPTBLENDCAPS_MODULATE      |
        D3DPTBLENDCAPS_DECALALPHA    |
        D3DPTBLENDCAPS_MODULATEALPHA |
        // D3DPTBLENDCAPS_DECALMASK     |
        // D3DPTBLENDCAPS_MODULATEMASK  |
        D3DPTBLENDCAPS_COPY          |
        D3DPTBLENDCAPS_ADD           ;
    RefGDD.hwCaps.dpcTriCaps.dwTextureAddressCaps =
        D3DPTADDRESSCAPS_WRAP          |
        D3DPTADDRESSCAPS_MIRROR        |
        D3DPTADDRESSCAPS_CLAMP         |
        D3DPTADDRESSCAPS_BORDER        |
        D3DPTADDRESSCAPS_INDEPENDENTUV ;
    RefGDD.hwCaps.dpcTriCaps.dwStippleWidth = 0;
    RefGDD.hwCaps.dpcTriCaps.dwStippleHeight = 0;

    //  line caps - copy tricaps and modify
    memcpy( &RefGDD.hwCaps.dpcLineCaps, &RefGDD.hwCaps.dpcTriCaps,
            sizeof(D3DPRIMCAPS) );

    //  disable antialias cap
    RefGDD.hwCaps.dpcLineCaps.dwRasterCaps =
        D3DPRASTERCAPS_DITHER                   |
//        D3DPRASTERCAPS_ROP2                     |
//        D3DPRASTERCAPS_XOR                      |
//        D3DPRASTERCAPS_PAT                      |
        D3DPRASTERCAPS_ZTEST                    |
        D3DPRASTERCAPS_SUBPIXEL                 |
        D3DPRASTERCAPS_SUBPIXELX                |
        D3DPRASTERCAPS_FOGVERTEX                |
        D3DPRASTERCAPS_FOGTABLE                 |
//        D3DPRASTERCAPS_STIPPLE                  |
//        D3DPRASTERCAPS_ANTIALIASSORTDEPENDENT   |
//        D3DPRASTERCAPS_ANTIALIASSORTINDEPENDENT |
//        D3DPRASTERCAPS_ANTIALIASEDGES           |
        D3DPRASTERCAPS_MIPMAPLODBIAS            |
//        D3DPRASTERCAPS_ZBIAS                    |
//        D3DPRASTERCAPS_ZBUFFERLESSHSR           |
        D3DPRASTERCAPS_FOGRANGE                 |
        D3DPRASTERCAPS_ANISOTROPY               |
        D3DPRASTERCAPS_WBUFFER                  |
//        D3DPRASTERCAPS_TRANSLUCENTSORTINDEPENDENT |
        D3DPRASTERCAPS_WFOG;

    RefGDD.hwCaps.dwDeviceRenderBitDepth = DDBD_16 | DDBD_24 | DDBD_32;
    RefGDD.hwCaps.dwDeviceZBufferBitDepth = DDBD_16 | DDBD_32;

    //
    //  set extended caps
    //
    RefExtCaps.dwSize = sizeof(RefExtCaps);

    RefExtCaps.dwMinTextureWidth = 1;
    RefExtCaps.dwMaxTextureWidth = 4096;
    RefExtCaps.dwMinTextureHeight = 1;
    RefExtCaps.dwMaxTextureHeight = 4096;
    RefExtCaps.dwMinStippleWidth = 0;   //  stipple unsupported
    RefExtCaps.dwMaxStippleWidth = 0;
    RefExtCaps.dwMinStippleHeight = 0;
    RefExtCaps.dwMaxStippleHeight = 0;

    RefExtCaps.dwMaxTextureRepeat = 32768;
    RefExtCaps.dwMaxTextureAspectRatio = 0; // no limit
    RefExtCaps.dwMaxAnisotropy = 16;

    RefExtCaps.dvGuardBandLeft   = (bIsNullDevice) ? (-2048.f) : (-32768.f);
    RefExtCaps.dvGuardBandTop    = (bIsNullDevice) ? (-2048.f) : (-32768.f);
    RefExtCaps.dvGuardBandRight  = (bIsNullDevice) ? ( 2047.f) : ( 32767.f);
    RefExtCaps.dvGuardBandBottom = (bIsNullDevice) ? ( 2047.f) : ( 32767.f);
    RefExtCaps.dvExtentsAdjust = 0.;    //  AA kernel is 1.0 x 1.0
    RefExtCaps.dwStencilCaps =
        D3DSTENCILCAPS_KEEP   |
        D3DSTENCILCAPS_ZERO   |
        D3DSTENCILCAPS_REPLACE|
        D3DSTENCILCAPS_INCRSAT|
        D3DSTENCILCAPS_DECRSAT|
        D3DSTENCILCAPS_INVERT |
        D3DSTENCILCAPS_INCR   |
        D3DSTENCILCAPS_DECR;
    RefExtCaps.dwFVFCaps = 8;   // max number of tex coord sets
    RefExtCaps.dwTextureOpCaps =
        D3DTEXOPCAPS_DISABLE                   |
        D3DTEXOPCAPS_SELECTARG1                |
        D3DTEXOPCAPS_SELECTARG2                |
        D3DTEXOPCAPS_MODULATE                  |
        D3DTEXOPCAPS_MODULATE2X                |
        D3DTEXOPCAPS_MODULATE4X                |
        D3DTEXOPCAPS_ADD                       |
        D3DTEXOPCAPS_ADDSIGNED                 |
        D3DTEXOPCAPS_ADDSIGNED2X               |
        D3DTEXOPCAPS_SUBTRACT                  |
        D3DTEXOPCAPS_ADDSMOOTH                 |
        D3DTEXOPCAPS_BLENDDIFFUSEALPHA         |
        D3DTEXOPCAPS_BLENDTEXTUREALPHA         |
        D3DTEXOPCAPS_BLENDFACTORALPHA          |
        D3DTEXOPCAPS_BLENDTEXTUREALPHAPM       |
        D3DTEXOPCAPS_BLENDCURRENTALPHA         |
        D3DTEXOPCAPS_PREMODULATE               |
        D3DTEXOPCAPS_MODULATEALPHA_ADDCOLOR    |
        D3DTEXOPCAPS_MODULATECOLOR_ADDALPHA    |
        D3DTEXOPCAPS_MODULATEINVALPHA_ADDCOLOR |
        D3DTEXOPCAPS_MODULATEINVCOLOR_ADDALPHA |
        D3DTEXOPCAPS_BUMPENVMAP                |
        D3DTEXOPCAPS_BUMPENVMAPLUMINANCE       |
        D3DTEXOPCAPS_DOTPRODUCT3               ;
    RefExtCaps.wMaxTextureBlendStages = 8;
    RefExtCaps.wMaxSimultaneousTextures = 8;
    RefExtCaps.dwMaxActiveLights = 0xffffffff;
    RefExtCaps.dvMaxVertexW = 1.0e10;

    switch( ddi )
    {
    case RDDDI_DX7TLHAL:
        RefGDD.hwCaps.dwDevCaps |= D3DDEVCAPS_HWTRANSFORMANDLIGHT;
        RefExtCaps.dwVertexProcessingCaps = (D3DVTXPCAPS_TEXGEN            |
                                             D3DVTXPCAPS_MATERIALSOURCE7   |
                                             D3DVTXPCAPS_VERTEXFOG         |
                                             D3DVTXPCAPS_DIRECTIONALLIGHTS |
                                             D3DVTXPCAPS_POSITIONALLIGHTS  |
                                             D3DVTXPCAPS_LOCALVIEWER);
        RefExtCaps.wMaxUserClipPlanes = RD_MAX_USER_CLIPPLANES;
        RefExtCaps.wMaxVertexBlendMatrices = RD_MAX_BLEND_WEIGHTS;
        // Fall throug
    case RDDDI_DX7HAL:
        RefGDD.hwCaps.dwDevCaps |= D3DDEVCAPS_DRAWPRIMITIVES2EX;
    }
}

//----------------------------------------------------------------------------
//
// Pixel formats
//
// Returns all the pixel formats supported by our rasterizer, and what we
// can do with them.
// Called at device creation time.
//
//----------------------------------------------------------------------------

DWORD
GetRefFormatOperations( LPDDSURFACEDESC* lplpddsd )
{
    int i = 0;

    DDSURFACEDESC* ddsd = g_ddsdTex;

    // Here we list our DX8 texture formats.
    // A driver wishing to run against DX7 or earlier runtimes would duplicate
    // entries, placing a list of DDSURFACEDESCs before this list that contain
    // old-style DDPIXELFORMAT structures. Example of old style:
    //    /* 888 */
    //    ddsd[i].dwSize = sizeof(ddsd[0]);
    //    ddsd[i].dwFlags = DDSD_PIXELFORMAT | DDSD_CAPS;
    //    ddsd[i].ddsCaps.dwCaps = DDSCAPS_TEXTURE;
    //    ddsd[i].ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);
    //    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_RGB;
    //    ddsd[i].ddpfPixelFormat.dwRGBBitCount = 32;
    //    ddsd[i].ddpfPixelFormat.dwRBitMask = 0xff0000;
    //    ddsd[i].ddpfPixelFormat.dwGBitMask = 0x00ff00;
    //    ddsd[i].ddpfPixelFormat.dwBBitMask = 0x0000ff;


    //-------------------------- (A)RGB Formats -----------------------------------------

    /* 888 */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_R8G8B8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_3DACCELERATION |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    /* x888 */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_X8R8G8B8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_3DACCELERATION |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    /* 8888 */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A8R8G8B8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    /* 565 */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_R5G6B5;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_3DACCELERATION |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    /* x555 */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_X1R5G5B5;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_3DACCELERATION |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    /* 1555 */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A1R5G5B5;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    // A formats for PC98 consistency
    // 4444 ARGB (it is already supported by S3 Virge)
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A4R4G4B4;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    // 4444 XRGB
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_X4R4G4B4;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    // 332 8-bit RGB
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_R3G3B2;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    // 8332 16-bit ARGB
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A8R3G3B2;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    //---------------------------- Palettized formats ------------------------------------
#if 0
    /* pal4 */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD)
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES);
    i++;
#endif

    /* A8P8 */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A8P8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    /* pal8 */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_P8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    //-------------------------- alpha/luminance formats -----------------------------------

    /* 8 bit luminance-only */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_L8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    /* 16 bit alpha-luminance */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A8L8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    /* 8 bit alpha-luminance */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A4L4;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    /* A8 */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    //-------------------------- YUV formats -----------------------------------

    // UYVY
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_UYVY;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // YUY2
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_YUY2;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    //-------------------------- DXT formats -----------------------------------

    // DXT compressed texture format 1
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_DXT1;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // DXT compressed texture format 2
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_DXT2;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;


    // DXT compressed texture format 3
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_DXT3;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;


    // DXT compressed texture format 4
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_DXT4;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;


    // DXT compressed texture format 5
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_DXT5;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    //-------------------------- Bump/luminance formats / Signed formats -----------------

    // V8U8
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_V8U8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // L6V5U5
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_L6V5U5;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // X8L8V8U8
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_X8L8V8U8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // V16U16
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_V16U16;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // Q8W8V8U8
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_Q8W8V8U8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // W11V11U10
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_W11V11U10;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    //-------------- Formats introduced in DX8.1 -------------------------
#if 0
    // A8B8G8R8
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A8B8G8R8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // W10V11U11
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_W10V11U11;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // A8X8V8U8
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A8X8V8U8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // L8X8V8U8
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_L8X8V8U8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // X8B8G8R8
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_X8B8G8R8;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;
#endif

    // A2W10V10U10
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A2W10V10U10;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // A2B10G10R10
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_A2B10G10R10;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE |
        D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET |
        D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    // G16R16
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_G16R16;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_TEXTURE |
        D3DFORMAT_OP_VOLUMETEXTURE |
        D3DFORMAT_OP_CUBETEXTURE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    //-------------------------- Z/Stencil buffer formats -----------------------------------

    /* 8 bit stencil; 24 bit Z  */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_S8D24;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH |
        D3DFORMAT_OP_ZSTENCIL;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    /* 1 bit stencil; 15 bit Z */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_S1D15;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH |
        D3DFORMAT_OP_ZSTENCIL;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    /* 4 bit stencil; 24 bit Z  */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_D24X4S4;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH |
        D3DFORMAT_OP_ZSTENCIL;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    //-------------------------- Z/Stencil/texture + shadow buffer formats -----------------------------------

    // Z16S0
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_D16_LOCKABLE;
    ddsd[i].ddpfPixelFormat.dwOperations =
#if 0
// for Shadow Buffer prototype API
        D3DFORMAT_OP_TEXTURE |
#endif
        D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH |
        D3DFORMAT_OP_ZSTENCIL;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;


    // Z32S0
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_D32;
    ddsd[i].ddpfPixelFormat.dwOperations =
#if 0
// for Shadow Buffer prototype API
        D3DFORMAT_OP_TEXTURE |
#endif
        D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH |
        D3DFORMAT_OP_ZSTENCIL;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    /* 24 bit Z  */
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) D3DFMT_X8D24;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH |
        D3DFORMAT_OP_ZSTENCIL;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 0;    //not required for known formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes =
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_4_SAMPLES) |
        DDI_MULTISAMPLE_TYPE(D3DMULTISAMPLE_9_SAMPLES);
    i++;

    //
    // This is an example of a IHV-specific format
    // The HIWORD must be the PCI-ID of the IHV
    // and the third byte must be zero.
    // In this case, we're using a sample PCI-ID of
    // FF00, and we're denoting the 4th format
    // by that PCI-ID.
    //
    // In this case, we're exposing a non-standard Z-buffer format
    // that can be used as a texture and depth-stencil at
    // in the same format.(We are also choosing to
    // disallow it as valid for cubemaps and volumes.)
    //
    ddsd[i].ddpfPixelFormat.dwFlags = DDPF_D3DFORMAT;
    ddsd[i].ddpfPixelFormat.dwFourCC = (DWORD) 0xFF000004;
    ddsd[i].ddpfPixelFormat.dwOperations =
        D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH |
        D3DFORMAT_OP_ZSTENCIL |
        D3DFORMAT_OP_TEXTURE | 
        D3DFORMAT_OP_PIXELSIZE;
    ddsd[i].ddpfPixelFormat.dwPrivateFormatBitCount = 32;    // required for IHV formats
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes = 0;
    ddsd[i].ddpfPixelFormat.MultiSampleCaps.wBltMSTypes = 0;
    i++;

    *lplpddsd = ddsd;

    _ASSERT(i<=RD_MAX_NUM_TEXTURE_FORMATS, "Not enough space in static texture list");

    return i;
}

#include <d3d8sddi.h>

HRESULT WINAPI
D3D8GetSWInfo( D3DCAPS8* pCaps, PD3D8_SWCALLBACKS pCallbacks,
               DWORD* pNumTextures, DDSURFACEDESC** ppTexList )
{
#define RESPATH_D3D "Software\\Microsoft\\Direct3D"

    // First query the registry to check if we were asked to
    // emulate any particular DDI.
    g_RefDDI = RDDDI_DX8TLHAL;
    HKEY hKey = (HKEY) NULL;
    if( ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, RESPATH_D3D, &hKey) )
    {
        DWORD dwType;
        DWORD dwValue;
        DWORD dwSize = sizeof(dwValue);
        if ( ERROR_SUCCESS == RegQueryValueEx( hKey, "DriverStyle", NULL,
                                               &dwType, (LPBYTE) &dwValue,
                                               &dwSize ) &&
             dwType == REG_DWORD &&
             dwValue > 0
            )
        {
            g_RefDDI = (RDDDITYPE)dwValue;

            // NOTE: RefDev's DDI emulation is currently restricted to
            // DX8 TL and Non-TL HALs only.
            if(  g_RefDDI > RDDDI_DX8TLHAL )
            {
                DPFERR( "Bad Driver style set. Assuming DX8TLHAL" );
                g_RefDDI = RDDDI_DX8TLHAL;
            }
            if(  g_RefDDI < RDDDI_DX8HAL )
            {
                DPFERR( "Bad Driver style set. Assuming DX8HAL" );
                g_RefDDI = RDDDI_DX8HAL;
            }
        }
        RegCloseKey(hKey);
    }

    // NULL out all the callbacks first
    memset( pCallbacks, 0, sizeof(PD3D8_SWCALLBACKS) );

    // These callbacks are needed by everyone
    pCallbacks->CreateContext               = RefRastContextCreate;
    pCallbacks->ContextDestroy              = RefRastContextDestroy;
    pCallbacks->ContextDestroyAll           = NULL;
    pCallbacks->SceneCapture                = RefRastSceneCapture;
    pCallbacks->CreateSurface               = RefRastCreateSurface;
    pCallbacks->Lock                        = RefRastLock;
    pCallbacks->DestroySurface              = RefRastDestroySurface;
    pCallbacks->Unlock                      = RefRastUnlock;

    switch( g_RefDDI )
    {
    case RDDDI_DX8TLHAL:
    case RDDDI_DX8HAL:
    case RDDDI_DX7TLHAL:
    case RDDDI_DX7HAL:
        pCallbacks->GetDriverState              = RefRastGetDriverState;
        pCallbacks->CreateSurfaceEx             = RefRastCreateSurfaceEx;
        // Fall through
    case RDDDI_DP2HAL:
        pCallbacks->ValidateTextureStageState =
            RefRastValidateTextureStageState;
        pCallbacks->DrawPrimitives2           = RefRastDrawPrimitives2;
        pCallbacks->Clear2                    = NULL;
        // Fall through
    case RDDDI_DPHAL:
        pCallbacks->DrawOnePrimitive        = NULL;
        pCallbacks->DrawOneIndexedPrimitive = NULL;
        pCallbacks->DrawPrimitives          = NULL;
        pCallbacks->Clear                   = NULL;
        pCallbacks->SetRenderTarget         = RefRastSetRenderTarget;
        // Fall through
    case RDDDI_OLDHAL:
        pCallbacks->RenderState     = NULL;
        pCallbacks->RenderPrimitive = NULL;
        pCallbacks->TextureCreate   = RefRastTextureCreate;
        pCallbacks->TextureDestroy  = RefRastTextureDestroy;
        pCallbacks->TextureSwap     = NULL;
        pCallbacks->TextureGetSurf  = RefRastTextureGetSurf;
        break;
    default:
        DPFERR( "Unknown DDI style set" );
        return E_FAIL;
    }


    // Now deal with the caps
    FillOutDeviceCaps(FALSE, g_RefDDI);

    // Fill in the supported pixel format operations
    // In DX8 these operations are expressed through the texture
    // format list.
    *pNumTextures = GetRefFormatOperations( ppTexList );

    FillOutDeviceCaps8( g_RefDDI );
    ModifyDeviceCaps8();
    *pCaps = g_RefCaps8;

    return DD_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\drv\rralloc.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// rrmem.cpp
//
// Direct3D Reference Implementation - Memory functions
//
//
//
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

///////////////////////////////////////////////////////////////////////////////
//
// RDAlloc method implementation
//
///////////////////////////////////////////////////////////////////////////////
void *
RDAlloc::operator new(size_t s)
{
    void* pMem = MEMALLOC( s );
    if (pMem == NULL)
    {
        DPFERR( "Malloc failed\n" );
    }
    return pMem;
}

void 
RDAlloc::operator delete(void* p, size_t)
{
    MEMFREE( p );
}


//////////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\drv\sources.inc ===
TARGETNAME=refdrv
TARGETPATH=obj
TARGETTYPE=LIBRARY

INCLUDES = ..;$(INCLUDES)

SOURCES =             \
    ..\refif.cpp      \
    ..\dprim2.cpp     \
    ..\primfns.cpp    \
    ..\drawprim.cpp   \
    ..\surfman.cpp    \
    ..\rralloc.cpp


PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\drv\primfns.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
// primfns.cpp
//
// Copyright (C) Microsoft Corporation, 1998.
//
//////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//----------------------------------------------------------------------------
//
// Wrap functions
//
//----------------------------------------------------------------------------
HRESULT WrapDp2SetViewport( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetViewport(pCmd);
}

HRESULT WrapDp2SetWRange  ( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetWRange(pCmd);
}

HRESULT WrapDp2SetZRange  ( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetZRange(pCmd);
}

HRESULT WrapDp2SetRenderStates( RefDev *pRefDev,
                            DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd,
                            LPDWORD lpdwRuntimeRStates )
{
    return pRefDev->Dp2SetRenderStates(dwFvf, pCmd, lpdwRuntimeRStates);
}

HRESULT WrapDp2SetTextureStageState( RefDev *pRefDev, DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetTextureStageState(dwFvf, pCmd);
}

HRESULT WrapDp2SetMaterial ( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetMaterial(pCmd);
}

HRESULT WrapDp2SetLight( RefDev *pRefDev,
                         LPD3DHAL_DP2COMMAND pCmd,
                         LPDWORD pdwStride )
{
    return pRefDev->Dp2SetLight(pCmd, pdwStride);
}

HRESULT WrapDp2CreateLight ( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2CreateLight(pCmd);
}

HRESULT WrapDp2SetTransform( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetTransform(pCmd);
}

HRESULT WrapDp2MultiplyTransform( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2MultiplyTransform(pCmd);
}

HRESULT WrapDp2SetExtention( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetExtention(pCmd);
}

HRESULT WrapDp2SetClipPlane( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetClipPlane(pCmd);
}

HRESULT
WrapDp2SetVertexShader( RefDev *pRefDev,
                        LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetVertexShader( pCmd );
}

HRESULT
WrapDp2SetVertexShaderConsts( RefDev *pRefDev,
                              DWORD StartReg, DWORD dwCount, LPDWORD pData )
{
    return pRefDev->Dp2SetVertexShaderConsts( StartReg, dwCount, pData );
}

HRESULT
WrapDp2SetPixelShader( RefDev *pRefDev,
                        LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetPixelShader( pCmd );
}

HRESULT
WrapDp2SetPixelShaderConsts( RefDev *pRefDev,
                              DWORD StartReg, DWORD dwCount, LPDWORD pData )
{
    return pRefDev->Dp2SetPixelShaderConsts( StartReg, dwCount, pData );
}

HRESULT
WrapDp2SetStreamSource( RefDev *pRefDev,
                        LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetStreamSource( pCmd );
}

HRESULT
WrapDp2SetIndices( RefDev *pRefDev,
                   LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2SetIndices( pCmd );
}


HRESULT WrapDp2RecViewport( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecViewport(pCmd);
}

HRESULT WrapDp2RecWRange  ( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecWRange(pCmd);
}

HRESULT WrapDp2RecZRange  ( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecZRange(pCmd);
}

HRESULT WrapDp2RecRenderStates( RefDev *pRefDev,
                            DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd,
                            LPDWORD lpdwRuntimeRStates )
{
    return pRefDev->Dp2RecRenderStates(dwFvf, pCmd, lpdwRuntimeRStates);
}

HRESULT WrapDp2RecTextureStageState( RefDev *pRefDev, DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecTextureStageState(dwFvf, pCmd);
}

HRESULT WrapDp2RecMaterial ( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecMaterial(pCmd);
}

HRESULT WrapDp2RecSetLight ( RefDev *pRefDev,
                             LPD3DHAL_DP2COMMAND pCmd,
                             LPDWORD pdwStride)
{
    return pRefDev->Dp2RecSetLight(pCmd, pdwStride);
}

HRESULT WrapDp2RecCreateLight( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecCreateLight(pCmd);
}

HRESULT WrapDp2RecTransform( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecTransform(pCmd);
}

HRESULT WrapDp2RecExtention( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecExtention(pCmd);
}

HRESULT WrapDp2RecClipPlane( RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecClipPlane(pCmd);
}

HRESULT
WrapDp2RecSetVertexShader( RefDev* pRefDev,
                           LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecSetVertexShader( pCmd );
}

HRESULT
WrapDp2RecSetVertexShaderConsts( RefDev* pRefDev,
                                 DWORD StartReg, DWORD dwCount, LPDWORD pData )
{
    return pRefDev->Dp2RecSetVertexShaderConsts( StartReg, dwCount, pData );
}

HRESULT
WrapDp2RecSetPixelShader( RefDev* pRefDev,
                           LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecSetPixelShader( pCmd );
}

HRESULT
WrapDp2RecSetPixelShaderConsts( RefDev* pRefDev,
                                 DWORD StartReg, DWORD dwCount, LPDWORD pData )
{
    return pRefDev->Dp2RecSetPixelShaderConsts( StartReg, dwCount, pData );
}

HRESULT
WrapDp2RecSetStreamSource( RefDev* pRefDev,
                           LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecSetStreamSource( pCmd );
}

HRESULT
WrapDp2RecSetIndices( RefDev* pRefDev,
                      LPD3DHAL_DP2COMMAND pCmd )
{
    return pRefDev->Dp2RecSetIndices( pCmd );
}


static RD_STATESETFUNCTIONTBL StateRecFunctions =
{
    sizeof(RD_STATESETFUNCTIONTBL),
    WrapDp2RecRenderStates,
    WrapDp2RecTextureStageState,
    WrapDp2RecViewport,
    WrapDp2RecWRange,
    WrapDp2RecMaterial,
    WrapDp2RecZRange,
    WrapDp2RecSetLight,
    WrapDp2RecCreateLight,
    WrapDp2RecTransform,
    WrapDp2RecExtention,
    WrapDp2RecClipPlane,
    WrapDp2RecSetVertexShader,
    WrapDp2RecSetVertexShaderConsts,
    WrapDp2RecSetPixelShader,
    WrapDp2RecSetPixelShaderConsts,
    WrapDp2RecSetStreamSource,
    WrapDp2RecSetIndices
};

static RD_STATESETFUNCTIONTBL StateSetFunctions =
{
    sizeof(RD_STATESETFUNCTIONTBL),
    WrapDp2SetRenderStates,
    WrapDp2SetTextureStageState,
    WrapDp2SetViewport,
    WrapDp2SetWRange,
    WrapDp2SetMaterial,
    WrapDp2SetZRange,
    WrapDp2SetLight,
    WrapDp2CreateLight,
    WrapDp2SetTransform,
    WrapDp2SetExtention,
    WrapDp2SetClipPlane,
    WrapDp2SetVertexShader,
    WrapDp2SetVertexShaderConsts,
    WrapDp2SetPixelShader,
    WrapDp2SetPixelShaderConsts,
    WrapDp2SetStreamSource,
    WrapDp2SetIndices,
    WrapDp2MultiplyTransform
};

//----------------------------------------------------------------------------
//
// RefDev methods
//
//----------------------------------------------------------------------------
void
RefDev::StoreLastPixelState(BOOL bStore)
{
    if( bStore )
    {
        m_LastState = GetRS()[D3DRENDERSTATE_LASTPIXEL];
        SetRenderState(D3DRENDERSTATE_LASTPIXEL, 0);
    }
    else
    {
        SetRenderState(D3DRENDERSTATE_LASTPIXEL, m_LastState);
    }
}

void
RefDev::SetRecStateFunctions(void)
{
    pStateSetFuncTbl = &StateRecFunctions;
}

void
RefDev::SetSetStateFunctions(void)
{
    pStateSetFuncTbl = &StateSetFunctions;
}

HRESULT
RefDev::Dp2SetRenderStates(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd,
                           LPDWORD lpdwRuntimeRStates )
{
    WORD wStateCount = pCmd->wStateCount;
    INT i;
    HRESULT hr = D3D_OK;

    D3DHAL_DP2RENDERSTATE *pRenderState =
                                    (D3DHAL_DP2RENDERSTATE *)(pCmd + 1);

    for (i = 0; i < (INT)wStateCount; i++, pRenderState++)
    {
        UINT32 type = (UINT32) pRenderState->RenderState;

        // Check for overrides
        if( IS_OVERRIDE(type) )
        {
            UINT32 override = GET_OVERRIDE(type);

            if( pRenderState->dwState )
                STATESET_SET(m_renderstate_override, override);
            else
                STATESET_CLEAR(m_renderstate_override, override);
            continue;
        }

        if( STATESET_ISSET(m_renderstate_override, type) )
            continue;


        // Set the runtime copy (if necessary)
        if( NULL != lpdwRuntimeRStates )
        {
            lpdwRuntimeRStates[pRenderState->RenderState] = pRenderState->dwState;
        }

        // Set the state
        SetRenderState(pRenderState->RenderState, pRenderState->dwState);
    }

    return hr;
}

HRESULT
RefDev::Dp2SetTextureStageState( DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd )
{
    WORD wStateCount = pCmd->wStateCount;
    INT i;
    HRESULT hr = D3D_OK;

    D3DHAL_DP2TEXTURESTAGESTATE  *pTexStageState =
                                    (D3DHAL_DP2TEXTURESTAGESTATE  *)(pCmd + 1);

    for (i = 0; i < (INT)wStateCount; i++, pTexStageState++)
    {
        SetTextureStageState( pTexStageState->wStage, pTexStageState->TSState,
                              pTexStageState->dwValue );
    }

    return hr;
}

HRESULT
RefDev::Dp2SetViewport(LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2VIEWPORTINFO pVpt;

    // Keep only the last viewport notification
    pVpt = (D3DHAL_DP2VIEWPORTINFO *)(pCmd + 1) + (pCmd->wStateCount - 1);

    // Update T&L viewport state
    D3DVIEWPORT7& vp = m_Clipper.m_Viewport;

    vp.dwX = pVpt->dwX;
    vp.dwY = pVpt->dwY;
    vp.dwWidth = pVpt->dwWidth;
    vp.dwHeight = pVpt->dwHeight;
    m_Clipper.m_dwFlags |= RefClipper::RCLIP_DIRTY_VIEWRECT;

    // get render target; update it; put it back
    RDRenderTarget *pRendTgt = this->GetRenderTarget();
    pRendTgt->m_Clip.left   = pVpt->dwX;
    pRendTgt->m_Clip.top    = pVpt->dwY;
    pRendTgt->m_Clip.right  = pVpt->dwX + pVpt->dwWidth - 1;
    pRendTgt->m_Clip.bottom = pVpt->dwY + pVpt->dwHeight - 1;
    SetRenderTarget( pRendTgt );
    return D3D_OK;
}

HRESULT
RefDev::Dp2SetWRange(LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2WINFO pWInfo;

    // Keep only the last viewport notification
    pWInfo = (D3DHAL_DP2WINFO *)(pCmd + 1) + (pCmd->wStateCount - 1);

    // get render target; update it; put it back
    RDRenderTarget *pRendTgt = this->GetRenderTarget();
    pRendTgt->m_fWRange[0]  = pWInfo->dvWNear;
    pRendTgt->m_fWRange[1]  = pWInfo->dvWFar;
    this->SetRenderTarget( pRendTgt );
    return D3D_OK;
}

HRESULT
RefDev::Dp2SetZRange(LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2ZRANGE pZRange;

    // Keep only the last viewport notification
    pZRange = (D3DHAL_DP2ZRANGE *)(pCmd + 1) + (pCmd->wStateCount - 1);

    // Update T&L viewport state
    D3DVIEWPORT7& vp = m_Clipper.m_Viewport;

    vp.dvMinZ = pZRange->dvMinZ;
    vp.dvMaxZ = pZRange->dvMaxZ;
    m_Clipper.m_dwFlags |= RefClipper::RCLIP_DIRTY_ZRANGE;

    return D3D_OK;
}


HRESULT
RefDev::Dp2SetMaterial(LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2SETMATERIAL pSetMat;

    // Keep only the last material notification
    pSetMat = (D3DHAL_DP2SETMATERIAL *)(pCmd + 1) + (pCmd->wStateCount - 1);

    m_RefVP.m_Material = *(D3DMATERIAL7 *)pSetMat;
    m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_MATERIAL;

    return D3D_OK;
}


HRESULT
RefDev::Dp2CreateLight(LPD3DHAL_DP2COMMAND pCmd)
{
    WORD wNumCreateLight = pCmd->wStateCount;
    LPD3DHAL_DP2CREATELIGHT pCreateLight = (LPD3DHAL_DP2CREATELIGHT)(pCmd + 1);
    HRESULT hr = D3D_OK;

    for (int i = 0; i < wNumCreateLight; i++, pCreateLight++)
    {
        HR_RET(m_RefVP.GrowLightArray( pCreateLight->dwIndex ) );
    }

    return hr;
}

HRESULT
RefDev::Dp2SetLight(LPD3DHAL_DP2COMMAND pCmd,
                                 LPDWORD pdwStride)
{

    HRESULT hr = D3D_OK;
    WORD wNumSetLight = pCmd->wStateCount;
    _ASSERT( pdwStride != NULL, "pdwStride is Null" );
    *pdwStride = sizeof(D3DHAL_DP2COMMAND);
    LPD3DHAL_DP2SETLIGHT pSetLight = (LPD3DHAL_DP2SETLIGHT)(pCmd + 1);
    D3DLIGHT7 *pLightData = NULL;

    for (int i = 0; i < wNumSetLight; i++)
    {
        DWORD dwStride = sizeof(D3DHAL_DP2SETLIGHT);
        DWORD dwIndex = pSetLight->dwIndex;

        // Assert that create was not called here
        _ASSERTf( m_RefVP.m_LightArray.IsValidIndex( dwIndex ),
                ( "Create was not called prior to the SetLight for light %d",
                 dwIndex ));

        switch (pSetLight->dwDataType)
        {
        case D3DHAL_SETLIGHT_ENABLE:
            m_RefVP.LightEnable( dwIndex, TRUE );
            break;
        case D3DHAL_SETLIGHT_DISABLE:
            m_RefVP.LightEnable( dwIndex, FALSE );
            break;
        case D3DHAL_SETLIGHT_DATA:
            pLightData = (D3DLIGHT7 *)((LPBYTE)pSetLight + dwStride);
            dwStride += sizeof(D3DLIGHT7);
            HR_RET(m_RefVP.SetLightData( pSetLight->dwIndex, pLightData));
            break;
        default:
            DPFERR( "Unknown SetLight command" );
            hr = DDERR_INVALIDPARAMS;
        }

        *pdwStride += dwStride;
        // Update the command buffer pointer
        pSetLight = (D3DHAL_DP2SETLIGHT *)((LPBYTE)pSetLight +
                                           dwStride);
    }

    return hr;
}

static D3DMATRIX matIdent =
{
    1.0f, 0.0f, 0.0f, 0.0f,
    0.0f, 1.0f, 0.0f, 0.0f,
    0.0f, 0.0f, 1.0f, 0.0f,
    0.0f, 0.0f, 0.0f, 1.0f
};

HRESULT
RefDev::Dp2SetTransform(LPD3DHAL_DP2COMMAND pCmd)
{
    WORD wNumXfrms = pCmd->wStateCount;
    D3DHAL_DP2SETTRANSFORM *pSetXfrm = (D3DHAL_DP2SETTRANSFORM*)(pCmd + 1);

    for (int i = 0; i < (int) wNumXfrms; i++, pSetXfrm++)
    {
        D3DMATRIX* pMat = &pSetXfrm->matrix;
        DWORD xfrmType = (DWORD)pSetXfrm->xfrmType;
        if ((DWORD)xfrmType >= RD_WORLDMATRIXBASE &&
            (DWORD)xfrmType < (RD_WORLDMATRIXBASE + RD_MAX_WORLD_MATRICES))
        {
            // World matrix is set
            UINT index = (DWORD)xfrmType - RD_WORLDMATRIXBASE;
            memcpy(&(m_RefVP.m_xfmWorld[index]), pMat, sizeof(D3DMATRIX));
            switch (index)
            {
            case 0:
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLDXFM;
                break;
            case 1:
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD1XFM;
                break;
            case 2:
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD2XFM;
                break;
            case 3:
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD3XFM;
                break;
            default:
                // m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLDNXFM;
                break;
            }
        }
        else
        {
            switch( xfrmType )
            {
            case D3DTRANSFORMSTATE_WORLD_DX7:
                memcpy(&(m_RefVP.m_xfmWorld[0]), pMat, sizeof(D3DMATRIX));
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLDXFM;
                break;
            case D3DTRANSFORMSTATE_VIEW:
                memcpy(&m_RefVP.m_xfmView, pMat, sizeof(D3DMATRIX));
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_VIEWXFM;
                break;
            case D3DTRANSFORMSTATE_PROJECTION:
                memcpy(&m_RefVP.m_xfmProj, pMat, sizeof(D3DMATRIX));
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_PROJXFM;
                break;
            case D3DTRANSFORMSTATE_WORLD1_DX7:
                memcpy(&(m_RefVP.m_xfmWorld[1]), pMat, sizeof(D3DMATRIX));
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD1XFM;
                break;
            case D3DTRANSFORMSTATE_WORLD2_DX7:
                memcpy(&(m_RefVP.m_xfmWorld[2]), pMat, sizeof(D3DMATRIX));
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD2XFM;
                break;
            case D3DTRANSFORMSTATE_WORLD3_DX7:
                memcpy(&(m_RefVP.m_xfmWorld[3]), pMat, sizeof(D3DMATRIX));
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD3XFM;
                break;
            case D3DTRANSFORMSTATE_TEXTURE0:
            case D3DTRANSFORMSTATE_TEXTURE1:
            case D3DTRANSFORMSTATE_TEXTURE2:
            case D3DTRANSFORMSTATE_TEXTURE3:
            case D3DTRANSFORMSTATE_TEXTURE4:
            case D3DTRANSFORMSTATE_TEXTURE5:
            case D3DTRANSFORMSTATE_TEXTURE6:
            case D3DTRANSFORMSTATE_TEXTURE7:
                memcpy(
                    &(m_RefVP.m_xfmTex[xfrmType - D3DTRANSFORMSTATE_TEXTURE0]),
                    pMat, sizeof(D3DMATRIX)
                    );
                break;
            default:
                DPFERR( "Ignoring unknown transform type" );
            }
        }
    }

    return D3D_OK;
}

extern void MatrixProduct(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b);

HRESULT
RefDev::Dp2MultiplyTransform(LPD3DHAL_DP2COMMAND pCmd)
{
    WORD wNumXfrms = pCmd->wStateCount;
    D3DHAL_DP2MULTIPLYTRANSFORM *pSetXfrm = (D3DHAL_DP2MULTIPLYTRANSFORM*)(pCmd + 1);

    for (int i = 0; i < (int) wNumXfrms; i++, pSetXfrm++)
    {
        D3DMATRIX* pMat = &pSetXfrm->matrix;
        DWORD xfrmType = (DWORD)pSetXfrm->xfrmType;
        if ((DWORD)xfrmType >= RD_WORLDMATRIXBASE &&
            (DWORD)xfrmType < (RD_WORLDMATRIXBASE + RD_MAX_WORLD_MATRICES))
        {
            // World matrix is set
            UINT index = (DWORD)xfrmType - RD_WORLDMATRIXBASE;
            MatrixProduct(&(m_RefVP.m_xfmWorld[index]), pMat,
                          &(m_RefVP.m_xfmWorld[index]));
            switch (index)
            {
            case 0:
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLDXFM;
                break;
            case 1:
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD1XFM;
                break;
            case 2:
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD2XFM;
                break;
            case 3:
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD3XFM;
                break;
            default:
                // m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLDNXFM;
                break;
            }
        }
        else
        {
            switch( xfrmType )
            {
            case D3DTRANSFORMSTATE_WORLD_DX7:
                MatrixProduct(&(m_RefVP.m_xfmWorld[0]), pMat,
                              &(m_RefVP.m_xfmWorld[0]));
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLDXFM;
                break;
            case D3DTRANSFORMSTATE_VIEW:
                MatrixProduct(&m_RefVP.m_xfmView, pMat, &m_RefVP.m_xfmView);
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_VIEWXFM;
                break;
            case D3DTRANSFORMSTATE_PROJECTION:
                MatrixProduct(&m_RefVP.m_xfmProj, pMat, &m_RefVP.m_xfmProj);
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_PROJXFM;
                break;
            case D3DTRANSFORMSTATE_WORLD1_DX7:
                MatrixProduct(&(m_RefVP.m_xfmWorld[1]), pMat,
                              &(m_RefVP.m_xfmWorld[1]));
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD1XFM;
                break;
            case D3DTRANSFORMSTATE_WORLD2_DX7:
                MatrixProduct(&(m_RefVP.m_xfmWorld[2]), pMat,
                              &(m_RefVP.m_xfmWorld[2]));
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD2XFM;
                break;
            case D3DTRANSFORMSTATE_WORLD3_DX7:
                MatrixProduct(&(m_RefVP.m_xfmWorld[3]), pMat,
                              &(m_RefVP.m_xfmWorld[3]));
                m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_WORLD3XFM;
                break;
            case D3DTRANSFORMSTATE_TEXTURE0:
            case D3DTRANSFORMSTATE_TEXTURE1:
            case D3DTRANSFORMSTATE_TEXTURE2:
            case D3DTRANSFORMSTATE_TEXTURE3:
            case D3DTRANSFORMSTATE_TEXTURE4:
            case D3DTRANSFORMSTATE_TEXTURE5:
            case D3DTRANSFORMSTATE_TEXTURE6:
            case D3DTRANSFORMSTATE_TEXTURE7:
                MatrixProduct(
                    &(m_RefVP.m_xfmTex[xfrmType - D3DTRANSFORMSTATE_TEXTURE0]),
                    pMat,
                    &(m_RefVP.m_xfmTex[xfrmType - D3DTRANSFORMSTATE_TEXTURE0])
                    );
                break;
            default:
                DPFERR( "Ignoring unknown transform type" );
            }
        }
    }

    return D3D_OK;
}

HRESULT
RefDev::Dp2SetClipPlane(LPD3DHAL_DP2COMMAND pCmd)
{
    WORD wNumClipPlanes = pCmd->wStateCount;
    LPD3DHAL_DP2SETCLIPPLANE pSetClipPlane =
        (LPD3DHAL_DP2SETCLIPPLANE)(pCmd + 1);

    for (int i = 0; i < (int) wNumClipPlanes; i++, pSetClipPlane++)
    {
        _ASSERTf( pSetClipPlane->dwIndex < RD_MAX_USER_CLIPPLANES,
                 ("Refrast does not support %d clip planes",
                  pSetClipPlane->dwIndex ) );

        memcpy( &(m_Clipper.m_userClipPlanes[pSetClipPlane->dwIndex]),
                pSetClipPlane->plane, sizeof(RDVECTOR4) );
    }
    return D3D_OK;
}

HRESULT
RefDev::Dp2SetExtention(LPD3DHAL_DP2COMMAND pCmd)
{
    return D3D_OK;
}

HRESULT
RefDev::Dp2RecRenderStates(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd,
                           LPDWORD lpdwRuntimeRStates )
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2RENDERSTATE);

    return RecordStates((PUINT8)pCmd, dwSize);
}

HRESULT
RefDev::Dp2RecTextureStageState(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd )
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2TEXTURESTAGESTATE);

    return RecordStates((PUINT8)pCmd, dwSize);
}

HRESULT
RefDev::Dp2RecViewport(LPD3DHAL_DP2COMMAND pCmd)
{
    return RecordLastState(pCmd, sizeof(D3DHAL_DP2VIEWPORTINFO));
}

HRESULT
RefDev::Dp2RecWRange(LPD3DHAL_DP2COMMAND pCmd)
{
    return RecordLastState(pCmd, sizeof(D3DHAL_DP2WINFO));
}

HRESULT
RefDev::Dp2RecZRange(LPD3DHAL_DP2COMMAND pCmd)
{
    return RecordLastState(pCmd, sizeof(D3DHAL_DP2ZRANGE));
}


HRESULT
RefDev::Dp2RecMaterial(LPD3DHAL_DP2COMMAND pCmd)
{
    return RecordLastState(pCmd, sizeof(D3DHAL_DP2SETMATERIAL));
}


HRESULT
RefDev::Dp2RecCreateLight(LPD3DHAL_DP2COMMAND pCmd)
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2CREATELIGHT);

    return RecordStates((PUINT8)pCmd, dwSize);
}

HRESULT
RefDev::Dp2RecSetLight(LPD3DHAL_DP2COMMAND pCmd,
                                    LPDWORD pdwStride)
{
    WORD wNumSetLight = pCmd->wStateCount;
    _ASSERT(pdwStride != NULL, "pdwStride is NULL" );
    *pdwStride = sizeof(D3DHAL_DP2COMMAND);
    LPD3DHAL_DP2SETLIGHT pSetLight = (LPD3DHAL_DP2SETLIGHT)(pCmd + 1);

    for (int i = 0; i < wNumSetLight; i++)
    {
        DWORD dwStride = sizeof(D3DHAL_DP2SETLIGHT);

        switch (pSetLight->dwDataType)
        {
        case D3DHAL_SETLIGHT_ENABLE:
            break;
        case D3DHAL_SETLIGHT_DISABLE:
            break;
        case D3DHAL_SETLIGHT_DATA:
            dwStride += sizeof(D3DLIGHT7);
            break;
        }

        *pdwStride += dwStride;
        // Update the command buffer pointer
        pSetLight = (D3DHAL_DP2SETLIGHT *)((LPBYTE)pSetLight +
                                           dwStride);
    }

    return RecordStates((PUINT8)pCmd, *pdwStride);
}


HRESULT
RefDev::Dp2RecTransform(LPD3DHAL_DP2COMMAND pCmd)
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2SETTRANSFORM);

    return RecordStates((PUINT8)pCmd, dwSize);
}


HRESULT
RefDev::Dp2RecExtention(LPD3DHAL_DP2COMMAND pCmd)
{
    return D3D_OK;
}

HRESULT
RefDev::Dp2RecClipPlane(LPD3DHAL_DP2COMMAND pCmd)
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2SETCLIPPLANE);

    return RecordStates((PUINT8)pCmd, dwSize);
}

HRESULT
RefDev::Dp2RecSetVertexShader(LPD3DHAL_DP2COMMAND pCmd)
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2VERTEXSHADER);

    return RecordStates((PUINT8)pCmd, dwSize);
}

HRESULT
RefDev::Dp2RecSetVertexShaderConsts( DWORD StartReg,
                                                  DWORD dwCount,
                                                  LPDWORD pData )
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETVERTEXSHADERCONST) +
        dwCount*4*sizeof(float);

    LPBYTE pBytes = new BYTE[dwSize];
    if( pBytes == NULL ) return DDERR_OUTOFMEMORY;
    LPD3DHAL_DP2COMMAND pCmd = (LPD3DHAL_DP2COMMAND)pBytes;
    LPD3DHAL_DP2SETVERTEXSHADERCONST pSVC =
        (LPD3DHAL_DP2SETVERTEXSHADERCONST)(pCmd + 1);
    LPDWORD pStuff = (LPDWORD)(pSVC + 1);

    // Set up pCmd
    pCmd->bCommand = D3DDP2OP_SETVERTEXSHADERCONST;
    pCmd->wStateCount = 1;

    // Set up pSVC
    pSVC->dwRegister = StartReg;
    pSVC->dwCount = dwCount;

    // Copy the data
    memcpy( pStuff, pData, dwCount*4*sizeof(float));

    HRESULT hr = RecordStates(pBytes, dwSize);
    delete [] pBytes;
    return hr;
}

HRESULT
RefDev::Dp2RecSetPixelShader(LPD3DHAL_DP2COMMAND pCmd)
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2PIXELSHADER);

    return RecordStates((PUINT8)pCmd, dwSize);
}

HRESULT
RefDev::Dp2RecSetPixelShaderConsts( DWORD StartReg,
                                                  DWORD dwCount,
                                                  LPDWORD pData )
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETPIXELSHADERCONST) +
        dwCount*4*sizeof(float);

    LPBYTE pBytes = new BYTE[dwSize];
    if( pBytes == NULL ) return DDERR_OUTOFMEMORY;
    LPD3DHAL_DP2COMMAND pCmd = (LPD3DHAL_DP2COMMAND)pBytes;
    LPD3DHAL_DP2SETPIXELSHADERCONST pSVC =
        (LPD3DHAL_DP2SETPIXELSHADERCONST)(pCmd + 1);
    LPDWORD pStuff = (LPDWORD)(pSVC + 1);

    // Set up pCmd
    pCmd->bCommand = D3DDP2OP_SETPIXELSHADERCONST;
    pCmd->wStateCount = 1;

    // Set up pSVC
    pSVC->dwRegister = StartReg;
    pSVC->dwCount = dwCount;

    // Copy the data
    memcpy( pStuff, pData, dwCount*4*sizeof(float));

    HRESULT hr = RecordStates(pBytes, dwSize);
    delete [] pBytes;
    return hr;
}

HRESULT
RefDev::Dp2RecSetStreamSource(LPD3DHAL_DP2COMMAND pCmd)
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2SETSTREAMSOURCE);

    return RecordStates((PUINT8)pCmd, dwSize);
}


HRESULT
RefDev::Dp2RecSetIndices(LPD3DHAL_DP2COMMAND pCmd)
{
    DWORD dwSize = sizeof(D3DHAL_DP2COMMAND) +
                   pCmd->wStateCount * sizeof(D3DHAL_DP2SETINDICES);

    return RecordStates((PUINT8)pCmd, dwSize);
}


//-----------------------------------------------------------------------------
//
// RecordStates - This function copies the state data into the internal stateset
// buffer. It assumes that the current state set has already been properly set
// up in BeginStateSet().
//
//-----------------------------------------------------------------------------
HRESULT
RefDev::RecordStates(PUINT8 pData, DWORD dwSize)
{
    HRESULT ret;
    LPStateSetData pCurStateSets = m_pStateSets.CurrentItem();
    DWORD dwCurIdx = pCurStateSets->CurrentIndex();

    // Check if the buffer has enough space
    if( (ret = pCurStateSets->CheckAndGrow(dwCurIdx + dwSize,
                                            RD_STATESET_GROWDELTA)) != D3D_OK )
    {
        return ret;
    }
    // Copy the data and update the ptr.
    PUINT8 pDest = (PUINT8)&((*pCurStateSets)[dwCurIdx]);
    memcpy(pDest, pData, dwSize);
    pCurStateSets->SetCurrentIndex(dwCurIdx + dwSize);

    return D3D_OK;
}

HRESULT RefDev::RecordLastState(LPD3DHAL_DP2COMMAND pCmd,
                                             DWORD dwUnitSize)
{
    _ASSERT(pCmd->wStateCount != 0, "Number of states to record is zero" );
    if( pCmd->wStateCount == 1 )
    {
        return RecordStates((PUINT8)pCmd, sizeof(D3DHAL_DP2COMMAND) + dwUnitSize);
    }
    else
    {
        HRESULT ret;
        WORD wCount = pCmd->wStateCount;
        pCmd->wStateCount = 1;
        ret = RecordStates((PUINT8)pCmd, sizeof(D3DHAL_DP2COMMAND));
        if( ret != D3D_OK )
        {
            return ret;
        }
        ret = RecordStates((PUINT8)(pCmd + 1) + dwUnitSize * (wCount - 1),
                            dwUnitSize);
        if( ret != D3D_OK )
        {
            return ret;
        }
        pCmd->wStateCount = wCount;
        return D3D_OK;
    }
}

HRESULT
RefDev::BeginStateSet(DWORD dwHandle)
{
    HRESULT ret;

    // Grow the array if no more space left
    if( (ret = m_pStateSets.CheckAndGrow(dwHandle)) != D3D_OK )
    {
        return ret;
    }

    _ASSERT(m_pStateSets[dwHandle] == NULL, "pStateSets array is NULL" );

    // Create the new StateSet
    LPStateSetData pNewStateSet = new StateSetData;
    if( pNewStateSet == NULL )
    {
        return DDERR_OUTOFMEMORY;
    }

    m_pStateSets.SetCurrentIndex(dwHandle);
    m_pStateSets.SetCurrentItem(pNewStateSet);

    // Switch to record mode
    SetRecStateFunctions();

    return D3D_OK;
}

HRESULT
RefDev::EndStateSet(void)
{
    // Switch to execute mode
    SetSetStateFunctions();

    return D3D_OK;
}

HRESULT
RefDev::ExecuteStateSet(DWORD dwHandle)
{
    HRESULT ret;

    if( (ret = m_pStateSets.CheckRange(dwHandle)) != D3D_OK )
    {
        return ret;
    }

    LPStateSetData pStateSet = m_pStateSets[dwHandle];

    if( pStateSet == NULL )
    {
        return DDERR_INVALIDPARAMS;
    }

    LPD3DHAL_DP2COMMAND pCmd = (LPD3DHAL_DP2COMMAND)&((*pStateSet)[0]);
    UINT_PTR CmdBoundary = (UINT_PTR)pCmd + pStateSet->CurrentIndex();

    // Loop through the data, update render states
    for (;;)
    {
        ret = DrawPrimitives2( NULL,
                               (UINT16)0,
                               (DWORD)0,
                               0,
                               &pCmd,
                               NULL );
        if( ret != D3D_OK )
        {
            return ret;
        }
        if( (UINT_PTR)pCmd >= CmdBoundary )
            break;
    }

    return D3D_OK;
}

HRESULT
RefDev::DeleteStateSet(DWORD dwHandle)
{
    HRESULT ret;

    if( (ret = m_pStateSets.CheckRange(dwHandle)) != D3D_OK )
    {
        return ret;
    }

    if( m_pStateSets[dwHandle] != NULL )
    {
        delete m_pStateSets[dwHandle];
        m_pStateSets[dwHandle] = NULL;
    }

    return D3D_OK;
}

HRESULT
RefDev::CaptureStateSet(DWORD dwHandle)
{
    HRESULT ret;

    if( (ret = m_pStateSets.CheckRange(dwHandle)) != D3D_OK )
    {
        return ret;
    }

    LPStateSetData pStateSet = m_pStateSets[dwHandle];

    if( pStateSet == NULL )
    {
        return DDERR_INVALIDPARAMS;
    }

    BYTE *p = &((*pStateSet)[0]);
    UINT_PTR pEnd = (UINT_PTR)(p + pStateSet->CurrentIndex());

    while((UINT_PTR)p < pEnd)
    {
        LPD3DHAL_DP2COMMAND pCmd = (LPD3DHAL_DP2COMMAND)p;
        p += sizeof(D3DHAL_DP2COMMAND);
        switch(pCmd->bCommand)
        {
        case D3DDP2OP_RENDERSTATE:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2RENDERSTATE pData = (LPD3DHAL_DP2RENDERSTATE)p;
                pData->dwState = GetRS()[pData->RenderState];
                p += sizeof(D3DHAL_DP2RENDERSTATE);
            }
            break;
        }
        case D3DDP2OP_SETLIGHT:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETLIGHT pData = (LPD3DHAL_DP2SETLIGHT)p;
                p += sizeof(D3DHAL_DP2SETLIGHT);
                if( !m_RefVP.m_LightArray.IsValidIndex( pData->dwIndex ) )
                {
                    DPFERR( "The light index in capture is invalid\n" );
                    return D3DERR_INVALIDCALL;
                }
                switch (pData->dwDataType)
                {
                case D3DHAL_SETLIGHT_ENABLE:
                    if(!m_RefVP.m_LightArray[pData->dwIndex].IsEnabled())
                        pData->dwDataType = D3DHAL_SETLIGHT_DISABLE;
                    break;
                case D3DHAL_SETLIGHT_DISABLE:
                    if(m_RefVP.m_LightArray[pData->dwIndex].IsEnabled())
                        pData->dwDataType = D3DHAL_SETLIGHT_ENABLE;
                    break;
                case D3DHAL_SETLIGHT_DATA:
                    m_RefVP.m_LightArray[pData->dwIndex].GetLight((LPD3DLIGHT7)p);
                    p += sizeof(D3DLIGHT7);
                    break;
                }
            }
            break;
        }
        case D3DDP2OP_SETMATERIAL:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETMATERIAL pData = (LPD3DHAL_DP2SETMATERIAL)p;
                *pData = m_RefVP.m_Material;
                p += sizeof(D3DHAL_DP2SETMATERIAL);
            }
            break;
        }
        case D3DDP2OP_SETTRANSFORM:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETTRANSFORM pData = (LPD3DHAL_DP2SETTRANSFORM)p;
                switch(pData->xfrmType)
                {
                case D3DTRANSFORMSTATE_WORLD:
                    pData->matrix = m_RefVP.m_xfmWorld[0];
                    break;
                case D3DTRANSFORMSTATE_WORLD1:
                    pData->matrix = m_RefVP.m_xfmWorld[1];
                    break;
                case D3DTRANSFORMSTATE_WORLD2:
                    pData->matrix = m_RefVP.m_xfmWorld[2];
                    break;
                case D3DTRANSFORMSTATE_WORLD3:
                    pData->matrix = m_RefVP.m_xfmWorld[3];
                    break;
                case D3DTRANSFORMSTATE_VIEW:
                    pData->matrix = m_RefVP.m_xfmView;
                    break;
                case D3DTRANSFORMSTATE_PROJECTION:
                    pData->matrix = m_RefVP.m_xfmProj;
                    break;
                case D3DTRANSFORMSTATE_TEXTURE0:
                case D3DTRANSFORMSTATE_TEXTURE1:
                case D3DTRANSFORMSTATE_TEXTURE2:
                case D3DTRANSFORMSTATE_TEXTURE3:
                case D3DTRANSFORMSTATE_TEXTURE4:
                case D3DTRANSFORMSTATE_TEXTURE5:
                case D3DTRANSFORMSTATE_TEXTURE6:
                case D3DTRANSFORMSTATE_TEXTURE7:
                    pData->matrix = m_RefVP.m_xfmTex[pData->xfrmType - D3DTRANSFORMSTATE_TEXTURE0];
                    break;
                default:
                    if( ((DWORD)pData->xfrmType >= RD_WORLDMATRIXBASE) &&
                        ((DWORD)pData->xfrmType < (RD_WORLDMATRIXBASE +
                            RD_MAX_WORLD_MATRICES)) )
                    {
                        pData->matrix = m_RefVP.m_xfmWorld[
                            (DWORD)pData->xfrmType - RD_WORLDMATRIXBASE];
                    }
                    else
                    {
                        DPFERR( "Ignoring unknown transform type" );
                        return D3DERR_INVALIDCALL;
                    }
                    break;
                }
                p += sizeof(D3DHAL_DP2SETTRANSFORM);
            }
            break;
        }
        case D3DDP2OP_TEXTURESTAGESTATE:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2TEXTURESTAGESTATE pData = (LPD3DHAL_DP2TEXTURESTAGESTATE)p;
                pData->dwValue = m_TextureStageState[pData->wStage].m_dwVal[pData->TSState];
                p += sizeof(D3DHAL_DP2TEXTURESTAGESTATE);
            }
            break;
        }
        case D3DDP2OP_VIEWPORTINFO:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                D3DVIEWPORT7 viewport;
                LPD3DHAL_DP2VIEWPORTINFO lpVwpData = (LPD3DHAL_DP2VIEWPORTINFO)p;
                D3DVIEWPORT7& vp = m_Clipper.m_Viewport;

                lpVwpData->dwX      = vp.dwX;
                lpVwpData->dwY      = vp.dwY;
                lpVwpData->dwWidth  = vp.dwWidth;
                lpVwpData->dwHeight = vp.dwHeight;
                p += sizeof(D3DHAL_DP2VIEWPORTINFO);
            }
            break;
        }
        case D3DDP2OP_ZRANGE:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2ZRANGE pData = (LPD3DHAL_DP2ZRANGE)p;
                D3DVIEWPORT7& vp = m_Clipper.m_Viewport;
                pData->dvMinZ = vp.dvMinZ;
                pData->dvMaxZ = vp.dvMaxZ;
                p += sizeof(D3DHAL_DP2ZRANGE);
            }
            break;
        }
        case D3DDP2OP_SETCLIPPLANE:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETCLIPPLANE pData = (LPD3DHAL_DP2SETCLIPPLANE)p;
                *((RDVECTOR4 *)pData->plane) =
                    m_Clipper.m_userClipPlanes[pData->dwIndex];
                p += sizeof(D3DHAL_DP2SETCLIPPLANE);
            }
            break;
        }
        case D3DDP2OP_SETVERTEXSHADER:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2VERTEXSHADER pData = (LPD3DHAL_DP2VERTEXSHADER)p;
                pData->dwHandle = m_CurrentVShaderHandle;
                p += sizeof(D3DHAL_DP2VERTEXSHADER);
            }
            break;
        }
        case D3DDP2OP_SETVERTEXSHADERCONST:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETVERTEXSHADERCONST pData =
                    (LPD3DHAL_DP2SETVERTEXSHADERCONST)p;
                m_RefVM.GetData( D3DSPR_CONST, pData->dwRegister,
                                 pData->dwCount, (LPVOID)(pData+1) );
                p += (sizeof(D3DHAL_DP2SETVERTEXSHADERCONST) +
                      (pData->dwCount<<4));
            }
            break;
        }
        case D3DDP2OP_SETSTREAMSOURCE:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETSTREAMSOURCE pData =
                    (LPD3DHAL_DP2SETSTREAMSOURCE)p;
                pData->dwVBHandle = m_VStream[pData->dwStream].m_dwHandle;
                pData->dwStride = m_VStream[pData->dwStream].m_dwStride;
                p += sizeof(D3DHAL_DP2SETSTREAMSOURCE);
            }
            break;
        }
        case D3DDP2OP_SETINDICES:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETINDICES pData =
                    (LPD3DHAL_DP2SETINDICES)p;
                pData->dwVBHandle = m_IndexStream.m_dwHandle;
                pData->dwStride = m_IndexStream.m_dwStride;
                p += sizeof(D3DHAL_DP2SETINDICES);
            }
            break;
        }
        case D3DDP2OP_SETPIXELSHADER:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2PIXELSHADER pData = (LPD3DHAL_DP2PIXELSHADER)p;
                pData->dwHandle = m_CurrentPShaderHandle;
                p += sizeof(D3DHAL_DP2PIXELSHADER);
            }
            break;
        }
        case D3DDP2OP_SETPIXELSHADERCONST:
        {
            for(DWORD i = 0; i < (DWORD)pCmd->wStateCount; ++i)
            {
                LPD3DHAL_DP2SETPIXELSHADERCONST pData =
                    (LPD3DHAL_DP2SETPIXELSHADERCONST)p;
                FLOAT* pfData = (FLOAT*)(pData+1);
                for (UINT iR=pData->dwRegister; iR<pData->dwCount; iR++)
                {
                    *(pfData+0) = m_Rast.m_ConstReg[iR][0][0];
                    *(pfData+1) = m_Rast.m_ConstReg[iR][0][1];
                    *(pfData+2) = m_Rast.m_ConstReg[iR][0][2];
                    *(pfData+3) = m_Rast.m_ConstReg[iR][0][3];
                    pfData += 4;
                }
                p += (sizeof(D3DHAL_DP2SETPIXELSHADERCONST) +
                      (pData->dwCount<<4));
            }
            break;
        }
        default:
            _ASSERT(FALSE, "Ununderstood DP2 command in Capture");
        }
    }

    return D3D_OK;
}

HRESULT
RefDev::CreateStateSet(DWORD dwHandle, D3DSTATEBLOCKTYPE sbType)
{
    HRESULT hr = S_OK;

    // This DDI should be called only for drivers > DX7
    // and only for those which support TLHals.
    // It is called only when the device created is a pure-device
    // We need to add filtering code in DX9 to make the DDI emulation
    // work.
    _ASSERT( m_dwDDIType > RDDDI_DX8HAL, "This DDI should be called only"
        " for DX8TL\n" );

    // Begin a new stateset
    if( FAILED( hr = BeginStateSet( dwHandle ) ) )
    {
        DPFERR( "CreateStateSet: Begin failed\n" );
        return hr;
    }

    switch( sbType )
    {
    case D3DSBT_VERTEXSTATE:
        hr = RecordVertexState( dwHandle );
        if( FAILED( hr ) )
        {
            DPFERR( "RecordVertexState failed\n" );
        }
        break;
    case D3DSBT_PIXELSTATE:
        hr = RecordPixelState( dwHandle );
        if( FAILED( hr ) )
        {
            DPFERR( "RecordPixelState failed\n" );
        }
        break;
    case D3DSBT_ALL:
        hr = RecordAllState( dwHandle );
        if( FAILED( hr ) )
        {
            DPFERR( "RecordAllState failed\n" );
        }
        break;
    default:
        DPFERR( "Unknown StateBlock type for Creation\n" );
        hr = D3DERR_INVALIDCALL;
    }

    EndStateSet();
    return hr;
}


HRESULT
RefDev::RecordAllState( DWORD dwHandle )
{
    DWORD data_size = 0;
    DWORD i = 0;
    DWORD j = 0;
    GArrayT<BYTE> data;
    LPD3DHAL_DP2COMMAND pCmd = NULL;
    HRESULT hr = S_OK;
    
    static D3DRENDERSTATETYPE rstates[] =
    {
        D3DRENDERSTATE_SPECULARENABLE,
        D3DRENDERSTATE_ZENABLE,
        D3DRENDERSTATE_FILLMODE,
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_LINEPATTERN,
        D3DRENDERSTATE_ZWRITEENABLE,
        D3DRENDERSTATE_ALPHATESTENABLE,
        D3DRENDERSTATE_LASTPIXEL,
        D3DRENDERSTATE_SRCBLEND,
        D3DRENDERSTATE_DESTBLEND,
        D3DRENDERSTATE_CULLMODE,
        D3DRENDERSTATE_ZFUNC,
        D3DRENDERSTATE_ALPHAREF,
        D3DRENDERSTATE_ALPHAFUNC,
        D3DRENDERSTATE_DITHERENABLE,
        D3DRENDERSTATE_FOGENABLE,
        D3DRENDERSTATE_STIPPLEDALPHA,
        D3DRENDERSTATE_FOGCOLOR,
        D3DRENDERSTATE_FOGTABLEMODE,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_EDGEANTIALIAS,
        D3DRENDERSTATE_ALPHABLENDENABLE,
        D3DRENDERSTATE_ZBIAS,
        D3DRENDERSTATE_RANGEFOGENABLE,
        D3DRENDERSTATE_STENCILENABLE,
        D3DRENDERSTATE_STENCILFAIL,
        D3DRENDERSTATE_STENCILZFAIL,
        D3DRENDERSTATE_STENCILPASS,
        D3DRENDERSTATE_STENCILFUNC,
        D3DRENDERSTATE_STENCILREF,
        D3DRENDERSTATE_STENCILMASK,
        D3DRENDERSTATE_STENCILWRITEMASK,
        D3DRENDERSTATE_TEXTUREFACTOR,
        D3DRENDERSTATE_WRAP0,
        D3DRENDERSTATE_WRAP1,
        D3DRENDERSTATE_WRAP2,
        D3DRENDERSTATE_WRAP3,
        D3DRENDERSTATE_WRAP4,
        D3DRENDERSTATE_WRAP5,
        D3DRENDERSTATE_WRAP6,
        D3DRENDERSTATE_WRAP7,
        D3DRENDERSTATE_AMBIENT,
        D3DRENDERSTATE_COLORVERTEX,
        D3DRENDERSTATE_FOGVERTEXMODE,
        D3DRENDERSTATE_CLIPPING,
        D3DRENDERSTATE_LIGHTING,
        D3DRENDERSTATE_NORMALIZENORMALS,
        D3DRENDERSTATE_LOCALVIEWER,
        D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
        D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
        D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
        D3DRENDERSTATE_SPECULARMATERIALSOURCE,
        D3DRENDERSTATE_VERTEXBLEND,
        D3DRENDERSTATE_CLIPPLANEENABLE,
        D3DRS_SOFTWAREVERTEXPROCESSING,
        D3DRS_POINTSIZE,
        D3DRS_POINTSIZE_MIN,
        D3DRS_POINTSPRITEENABLE,
        D3DRS_POINTSCALEENABLE,
        D3DRS_POINTSCALE_A,
        D3DRS_POINTSCALE_B,
        D3DRS_POINTSCALE_C,
        D3DRS_MULTISAMPLEANTIALIAS,
        D3DRS_MULTISAMPLEMASK,
        D3DRS_PATCHEDGESTYLE,
        D3DRS_PATCHSEGMENTS,
        D3DRS_POINTSIZE_MAX,
        D3DRS_INDEXEDVERTEXBLENDENABLE,
        D3DRS_COLORWRITEENABLE,
        D3DRS_TWEENFACTOR,
        D3DRS_BLENDOP,
    };
    static D3DTEXTURESTAGESTATETYPE tsstates[] =
    {
        D3DTSS_COLOROP,
        D3DTSS_COLORARG1,
        D3DTSS_COLORARG2,
        D3DTSS_ALPHAOP,
        D3DTSS_ALPHAARG1,
        D3DTSS_ALPHAARG2,
        D3DTSS_BUMPENVMAT00,
        D3DTSS_BUMPENVMAT01,
        D3DTSS_BUMPENVMAT10,
        D3DTSS_BUMPENVMAT11,
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_ADDRESSU,
        D3DTSS_ADDRESSV,
        D3DTSS_BORDERCOLOR,
        D3DTSS_MAGFILTER,
        D3DTSS_MINFILTER,
        D3DTSS_MIPFILTER,
        D3DTSS_MIPMAPLODBIAS,
        D3DTSS_MAXMIPLEVEL,
        D3DTSS_MAXANISOTROPY,
        D3DTSS_BUMPENVLSCALE,
        D3DTSS_BUMPENVLOFFSET,
        D3DTSS_TEXTURETRANSFORMFLAGS,
        D3DTSS_ADDRESSW,
        D3DTSS_COLORARG0,
        D3DTSS_ALPHAARG0,
        D3DTSS_RESULTARG,
    };

    //
    // !!! Dont Capture vertex streams !!!
    // !!! Dont Capture index streams !!!
    // !!! Dont Capture textures !!!
    //

    //
    // Capture render-states
    //
    const UINT16 uiRStates = sizeof(rstates)/sizeof(D3DRENDERSTATETYPE);
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2RENDERSTATE) *
        uiRStates;
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = uiRStates;
    pCmd->bCommand        = D3DDP2OP_RENDERSTATE;
    D3DHAL_DP2RENDERSTATE* pRS = (D3DHAL_DP2RENDERSTATE*)(pCmd + 1);
    for( i = 0; i < uiRStates; ++i)
    {
        pRS->RenderState = rstates[i];
        pRS->dwState = GetRS()[rstates[i]];
        pRS++;
    }
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));


    //
    // Capture texture-stage-states
    //
    const UINT16 uiTSStates = sizeof(tsstates)/sizeof(D3DTEXTURESTAGESTATETYPE);
    data_size = sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2TEXTURESTAGESTATE) * uiTSStates * D3DHAL_TSS_MAXSTAGES;
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = uiTSStates * D3DHAL_TSS_MAXSTAGES;
    pCmd->bCommand        = D3DDP2OP_TEXTURESTAGESTATE;
    D3DHAL_DP2TEXTURESTAGESTATE* pTSS = (D3DHAL_DP2TEXTURESTAGESTATE*)(pCmd+1);
    for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i++ )
    {
        for( DWORD j = 0; j < uiTSStates; ++j)
        {
            pTSS->wStage = i;
            pTSS->TSState = tsstates[j];
            pTSS->dwValue = GetTSS( i )[tsstates[j]];
            pTSS++;
        }
    }
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture viewport
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2VIEWPORTINFO);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_VIEWPORTINFO;
    D3DHAL_DP2VIEWPORTINFO* pVP = (D3DHAL_DP2VIEWPORTINFO*)(pCmd+1);
    pVP->dwX = m_Clipper.m_Viewport.dwX;
    pVP->dwY = m_Clipper.m_Viewport.dwY;
    pVP->dwWidth  = m_Clipper.m_Viewport.dwWidth;
    pVP->dwHeight = m_Clipper.m_Viewport.dwHeight;
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2ZRANGE);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand       = D3DDP2OP_ZRANGE;
    D3DHAL_DP2ZRANGE* pZR = (D3DHAL_DP2ZRANGE*)(pCmd+1);
    D3DVIEWPORT7& vp = m_Clipper.m_Viewport;
    pZR->dvMinZ = m_Clipper.m_Viewport.dvMinZ; 
    pZR->dvMaxZ = m_Clipper.m_Viewport.dvMaxZ; 
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture transforms
    //
    // All the world-matrices, view, projection and the texture matrices
    // (one per stage)
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETTRANSFORM) *
        (RD_MAX_WORLD_MATRICES + D3DHAL_TSS_MAXSTAGES + 2);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = RD_MAX_WORLD_MATRICES + D3DHAL_TSS_MAXSTAGES + 2;
    pCmd->bCommand       = D3DDP2OP_SETTRANSFORM;
    D3DHAL_DP2SETTRANSFORM* pST = (D3DHAL_DP2SETTRANSFORM*)(pCmd+1);
    for( i = 0; i < RD_MAX_WORLD_MATRICES; i++ )
    {
        pST->xfrmType = (D3DTRANSFORMSTATETYPE)(RD_WORLDMATRIXBASE + i);
        pST->matrix = m_RefVP.m_xfmWorld[i];
        pST++;
    }
    // View Matrix
    pST->xfrmType = D3DTRANSFORMSTATE_VIEW;
    pST->matrix = m_RefVP.m_xfmView;
    pST++;
    // Projection Matrix
    pST->xfrmType = D3DTRANSFORMSTATE_PROJECTION;
    pST->matrix = m_RefVP.m_xfmProj;
    pST++;
    // Texture Matrices
    for( i = 0; i < D3DHAL_TSS_MAXSTAGES; i++ )
    {
        pST->xfrmType =
            (D3DTRANSFORMSTATETYPE)(D3DTRANSFORMSTATE_TEXTURE0 + i);
        pST->matrix = m_RefVP.m_xfmTex[i];
        pST++;
    }
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));


    //
    // Capture clip-planes
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETCLIPPLANE) * RD_MAX_USER_CLIPPLANES;
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = RD_MAX_USER_CLIPPLANES;
    pCmd->bCommand       = D3DDP2OP_SETCLIPPLANE;
    D3DHAL_DP2SETCLIPPLANE* pSCP = (D3DHAL_DP2SETCLIPPLANE*)(pCmd+1);
    for( i = 0; i < RD_MAX_USER_CLIPPLANES; i++ )
    {
        pSCP->dwIndex = i;
        for( j=0; j<4; j++ )
            pSCP->plane[j] = m_Clipper.m_userClipPlanes[i].v[j];
        pSCP++;
    }
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture material
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2SETMATERIAL);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETMATERIAL;
    D3DHAL_DP2SETMATERIAL* pSM = (D3DHAL_DP2SETMATERIAL*)(pCmd+1);
    *pSM = m_RefVP.m_Material;
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture lights
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DLIGHT7) +
        sizeof(D3DHAL_DP2SETLIGHT)*2;
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 2;
    pCmd->bCommand = D3DDP2OP_SETLIGHT;
    D3DHAL_DP2SETLIGHT* pSL = (D3DHAL_DP2SETLIGHT *)(pCmd + 1);
    D3DHAL_DP2SETLIGHT* pSL2 = pSL + 1;
    pSL2->dwDataType = D3DHAL_SETLIGHT_DATA;
    for( i = 0; i < m_RefVP.m_LightArray.GetSize(); i++ )
    {
        if( m_RefVP.m_LightArray[i].IsRefered() )
        {
            pSL2->dwIndex = pSL->dwIndex = i;
            if( m_RefVP.m_LightArray[i].IsEnabled() )
            {
                pSL->dwDataType = D3DHAL_SETLIGHT_ENABLE;
            }
            else
            {
                pSL->dwDataType = D3DHAL_SETLIGHT_DISABLE;
            }

            m_RefVP.m_LightArray[i].GetLight((D3DLIGHT7*)(pSL2 + 1));
            HR_RET(RecordStates( (PUINT8)pCmd, data_size ));
        }
    }


    //
    // Capture current vertex shader
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2VERTEXSHADER);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETVERTEXSHADER;
    D3DHAL_DP2VERTEXSHADER* pVS = (D3DHAL_DP2VERTEXSHADER*)(pCmd+1);
    pVS->dwHandle = m_CurrentVShaderHandle;
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture current pixel shader
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2PIXELSHADER);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETPIXELSHADER;
    D3DHAL_DP2PIXELSHADER* pPS = (D3DHAL_DP2PIXELSHADER*)(pCmd+1);
    pPS->dwHandle = m_CurrentPShaderHandle;
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture vertex shader constants
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETVERTEXSHADERCONST) + (RD_MAX_NUMCONSTREG << 4);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETVERTEXSHADERCONST;
    D3DHAL_DP2SETVERTEXSHADERCONST* pVSC =
        (D3DHAL_DP2SETVERTEXSHADERCONST*)(pCmd+1);
    pVSC->dwRegister = 0;
    pVSC->dwCount = RD_MAX_NUMCONSTREG;
    m_RefVM.GetData( D3DSPR_CONST, pVSC->dwRegister, pVSC->dwCount,
                     (LPVOID)(pVSC+1) );
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture pixel shader constants
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETPIXELSHADERCONST) + (RDPS_MAX_NUMCONSTREG << 4);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETPIXELSHADERCONST;
    D3DHAL_DP2SETPIXELSHADERCONST* pPSC =
        (D3DHAL_DP2SETPIXELSHADERCONST*)(pCmd+1);
    pPSC->dwRegister = 0;
    pPSC->dwCount = RDPS_MAX_NUMCONSTREG;
    FLOAT* pfData = (FLOAT*)(pPSC+1);
    for (UINT iR=pPSC->dwRegister; iR<pPSC->dwCount; iR++)
    {
        *(pfData+0) = m_Rast.m_ConstReg[iR][0][0];
        *(pfData+1) = m_Rast.m_ConstReg[iR][0][1];
        *(pfData+2) = m_Rast.m_ConstReg[iR][0][2];
        *(pfData+3) = m_Rast.m_ConstReg[iR][0][3];
        pfData += 4;
    }
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));
    return hr;
}

HRESULT
RefDev::RecordVertexState( DWORD dwHandle )
{
    DWORD data_size = 0;
    DWORD i = 0;
    DWORD j = 0;
    GArrayT<BYTE> data;
    LPD3DHAL_DP2COMMAND pCmd = NULL;
    HRESULT hr = S_OK;
    
    static D3DRENDERSTATETYPE rstates[] =
    {
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_SPECULARENABLE,
        D3DRENDERSTATE_CULLMODE,
        D3DRENDERSTATE_FOGENABLE,
        D3DRENDERSTATE_FOGCOLOR,
        D3DRENDERSTATE_FOGTABLEMODE,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_RANGEFOGENABLE,
        D3DRENDERSTATE_AMBIENT,
        D3DRENDERSTATE_COLORVERTEX,
        D3DRENDERSTATE_FOGVERTEXMODE,
        D3DRENDERSTATE_CLIPPING,
        D3DRENDERSTATE_LIGHTING,
        D3DRENDERSTATE_NORMALIZENORMALS,
        D3DRENDERSTATE_LOCALVIEWER,
        D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
        D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
        D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
        D3DRENDERSTATE_SPECULARMATERIALSOURCE,
        D3DRENDERSTATE_VERTEXBLEND,
        D3DRENDERSTATE_CLIPPLANEENABLE,
        D3DRS_SOFTWAREVERTEXPROCESSING,
        D3DRS_POINTSIZE,
        D3DRS_POINTSIZE_MIN,
        D3DRS_POINTSPRITEENABLE,
        D3DRS_POINTSCALEENABLE,
        D3DRS_POINTSCALE_A,
        D3DRS_POINTSCALE_B,
        D3DRS_POINTSCALE_C,
        D3DRS_MULTISAMPLEANTIALIAS,
        D3DRS_MULTISAMPLEMASK,
        D3DRS_PATCHEDGESTYLE,
        D3DRS_PATCHSEGMENTS,
        D3DRS_POINTSIZE_MAX,
        D3DRS_INDEXEDVERTEXBLENDENABLE,
        D3DRS_TWEENFACTOR,
    };
    static D3DTEXTURESTAGESTATETYPE tsstates[] =
    {
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_TEXTURETRANSFORMFLAGS
    };

    //
    // Capture render-states
    //
    const UINT16 uiRStates = sizeof(rstates)/sizeof(D3DRENDERSTATETYPE);
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2RENDERSTATE) *
        uiRStates;
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = uiRStates;
    pCmd->bCommand        = D3DDP2OP_RENDERSTATE;
    D3DHAL_DP2RENDERSTATE* pRS = (D3DHAL_DP2RENDERSTATE*)(pCmd + 1);
    for( i = 0; i < uiRStates; ++i)
    {
        pRS->RenderState = rstates[i];
        pRS->dwState = GetRS()[rstates[i]];
        pRS++;
    }
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));


    //
    // Capture texture-stage-states
    //
    const UINT16 uiTSStates = sizeof(tsstates)/sizeof(D3DTEXTURESTAGESTATETYPE);
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TEXTURESTAGESTATE)
        * uiTSStates * D3DHAL_TSS_MAXSTAGES;
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = uiTSStates * D3DHAL_TSS_MAXSTAGES;
    pCmd->bCommand        = D3DDP2OP_TEXTURESTAGESTATE;
    D3DHAL_DP2TEXTURESTAGESTATE* pTSS = (D3DHAL_DP2TEXTURESTAGESTATE*)(pCmd+1);
    for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i++ )
    {
        for( DWORD j = 0; j < uiTSStates; ++j)
        {
            pTSS->wStage = i;
            pTSS->TSState = tsstates[j];
            pTSS->dwValue = GetTSS( i )[tsstates[j]];
            pTSS++;
        }
    }
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture lights
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DLIGHT7) +
        sizeof(D3DHAL_DP2SETLIGHT)*2;
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 2;
    pCmd->bCommand = D3DDP2OP_SETLIGHT;
    D3DHAL_DP2SETLIGHT* pSL = (D3DHAL_DP2SETLIGHT *)(pCmd + 1);
    D3DHAL_DP2SETLIGHT* pSL2 = pSL + 1;
    pSL2->dwDataType = D3DHAL_SETLIGHT_DATA;
    for( i = 0; i < m_RefVP.m_LightArray.GetSize(); i++ )
    {
        if( m_RefVP.m_LightArray[i].IsRefered() )
        {
            pSL2->dwIndex = pSL->dwIndex = i;
            if( m_RefVP.m_LightArray[i].IsEnabled() )
            {
                pSL->dwDataType = D3DHAL_SETLIGHT_ENABLE;
            }
            else
            {
                pSL->dwDataType = D3DHAL_SETLIGHT_DISABLE;
            }

            m_RefVP.m_LightArray[i].GetLight((D3DLIGHT7*)(pSL2 + 1));
            HR_RET(RecordStates( (PUINT8)pCmd, data_size ));
        }
    }

    //
    // Capture vertex shader constants
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETVERTEXSHADERCONST) + (RD_MAX_NUMCONSTREG << 4);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETVERTEXSHADERCONST;
    D3DHAL_DP2SETVERTEXSHADERCONST* pVSC =
        (D3DHAL_DP2SETVERTEXSHADERCONST*)(pCmd+1);
    pVSC->dwRegister = 0;
    pVSC->dwCount = RD_MAX_NUMCONSTREG;
    m_RefVM.GetData( D3DSPR_CONST, pVSC->dwRegister, pVSC->dwCount,
                     (LPVOID)(pVSC+1) );
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture current vertex shader
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2VERTEXSHADER);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETVERTEXSHADER;
    D3DHAL_DP2VERTEXSHADER* pVS =
        (D3DHAL_DP2VERTEXSHADER*)(pCmd+1);
    pVS->dwHandle = m_CurrentVShaderHandle;
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    return hr;
}

HRESULT
RefDev::RecordPixelState( DWORD dwHandle )
{
    DWORD data_size = 0;
    DWORD i = 0;
    DWORD j = 0;
    GArrayT<BYTE> data;
    LPD3DHAL_DP2COMMAND pCmd = NULL;
    HRESULT hr = S_OK;

    static D3DRENDERSTATETYPE rstates[] =
    {
        D3DRENDERSTATE_ZENABLE,
        D3DRENDERSTATE_FILLMODE,
        D3DRENDERSTATE_SHADEMODE,
        D3DRENDERSTATE_LINEPATTERN,
        D3DRENDERSTATE_ZWRITEENABLE,
        D3DRENDERSTATE_ALPHATESTENABLE,
        D3DRENDERSTATE_LASTPIXEL,
        D3DRENDERSTATE_SRCBLEND,
        D3DRENDERSTATE_DESTBLEND,
        D3DRENDERSTATE_ZFUNC,
        D3DRENDERSTATE_ALPHAREF,
        D3DRENDERSTATE_ALPHAFUNC,
        D3DRENDERSTATE_DITHERENABLE,
        D3DRENDERSTATE_STIPPLEDALPHA,
        D3DRENDERSTATE_FOGSTART,
        D3DRENDERSTATE_FOGEND,
        D3DRENDERSTATE_FOGDENSITY,
        D3DRENDERSTATE_EDGEANTIALIAS,
        D3DRENDERSTATE_ALPHABLENDENABLE,
        D3DRENDERSTATE_ZBIAS,
        D3DRENDERSTATE_STENCILENABLE,
        D3DRENDERSTATE_STENCILFAIL,
        D3DRENDERSTATE_STENCILZFAIL,
        D3DRENDERSTATE_STENCILPASS,
        D3DRENDERSTATE_STENCILFUNC,
        D3DRENDERSTATE_STENCILREF,
        D3DRENDERSTATE_STENCILMASK,
        D3DRENDERSTATE_STENCILWRITEMASK,
        D3DRENDERSTATE_TEXTUREFACTOR,
        D3DRENDERSTATE_WRAP0,
        D3DRENDERSTATE_WRAP1,
        D3DRENDERSTATE_WRAP2,
        D3DRENDERSTATE_WRAP3,
        D3DRENDERSTATE_WRAP4,
        D3DRENDERSTATE_WRAP5,
        D3DRENDERSTATE_WRAP6,
        D3DRENDERSTATE_WRAP7,
        D3DRS_COLORWRITEENABLE,
        D3DRS_BLENDOP,
    };
    static D3DTEXTURESTAGESTATETYPE tsstates[] =
    {
        D3DTSS_COLOROP,
        D3DTSS_COLORARG1,
        D3DTSS_COLORARG2,
        D3DTSS_ALPHAOP,
        D3DTSS_ALPHAARG1,
        D3DTSS_ALPHAARG2,
        D3DTSS_BUMPENVMAT00,
        D3DTSS_BUMPENVMAT01,
        D3DTSS_BUMPENVMAT10,
        D3DTSS_BUMPENVMAT11,
        D3DTSS_TEXCOORDINDEX,
        D3DTSS_ADDRESSU,
        D3DTSS_ADDRESSV,
        D3DTSS_BORDERCOLOR,
        D3DTSS_MAGFILTER,
        D3DTSS_MINFILTER,
        D3DTSS_MIPFILTER,
        D3DTSS_MIPMAPLODBIAS,
        D3DTSS_MAXMIPLEVEL,
        D3DTSS_MAXANISOTROPY,
        D3DTSS_BUMPENVLSCALE,
        D3DTSS_BUMPENVLOFFSET,
        D3DTSS_TEXTURETRANSFORMFLAGS,
        D3DTSS_ADDRESSW,
        D3DTSS_COLORARG0,
        D3DTSS_ALPHAARG0,
        D3DTSS_RESULTARG,
    };

    //
    // Capture render-states
    //
    const UINT16 uiRStates = sizeof(rstates)/sizeof(D3DRENDERSTATETYPE);
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2RENDERSTATE) *
        uiRStates;
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = uiRStates;
    pCmd->bCommand        = D3DDP2OP_RENDERSTATE;
    D3DHAL_DP2RENDERSTATE* pRS = (D3DHAL_DP2RENDERSTATE*)(pCmd + 1);
    for( i = 0; i < uiRStates; ++i)
    {
        pRS->RenderState = rstates[i];
        pRS->dwState = GetRS()[rstates[i]];
        pRS++;
    }
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));


    //
    // Capture texture-stage-states
    //
    const UINT16 uiTSStates = sizeof(tsstates)/sizeof(D3DTEXTURESTAGESTATETYPE);
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2TEXTURESTAGESTATE)
        * uiTSStates * D3DHAL_TSS_MAXSTAGES;
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = uiTSStates * D3DHAL_TSS_MAXSTAGES;
    pCmd->bCommand        = D3DDP2OP_TEXTURESTAGESTATE;
    D3DHAL_DP2TEXTURESTAGESTATE* pTSS = (D3DHAL_DP2TEXTURESTAGESTATE*)(pCmd+1);
    for ( i = 0; i < D3DHAL_TSS_MAXSTAGES; i++ )
    {
        for( DWORD j = 0; j < uiTSStates; ++j)
        {
            pTSS->wStage = i;
            pTSS->TSState = tsstates[j];
            pTSS->dwValue = GetTSS( i )[tsstates[j]];
            pTSS++;
        }
    }
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture pixel shader constants
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) +
        sizeof(D3DHAL_DP2SETPIXELSHADERCONST) + (RDPS_MAX_NUMCONSTREG << 4);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETPIXELSHADERCONST;
    D3DHAL_DP2SETPIXELSHADERCONST* pPSC =
        (D3DHAL_DP2SETPIXELSHADERCONST*)(pCmd+1);
    pPSC->dwRegister = 0;
    pPSC->dwCount = RDPS_MAX_NUMCONSTREG;
    FLOAT* pfData = (FLOAT*)(pPSC+1);
    for (UINT iR=pPSC->dwRegister; iR<pPSC->dwCount; iR++)
    {
        *(pfData+0) = m_Rast.m_ConstReg[iR][0][0];
        *(pfData+1) = m_Rast.m_ConstReg[iR][0][1];
        *(pfData+2) = m_Rast.m_ConstReg[iR][0][2];
        *(pfData+3) = m_Rast.m_ConstReg[iR][0][3];
        pfData += 4;
    }
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    //
    // Capture current pixel shader
    //
    data_size = sizeof(D3DHAL_DP2COMMAND) + sizeof(D3DHAL_DP2PIXELSHADER);
    HR_RET(data.Grow( data_size ));
    pCmd = (LPD3DHAL_DP2COMMAND)&(data[0]);
    pCmd->wPrimitiveCount = 1;
    pCmd->bCommand        = D3DDP2OP_SETPIXELSHADER;
    D3DHAL_DP2PIXELSHADER* pPS = (D3DHAL_DP2PIXELSHADER*)(pCmd+1);
    pPS->dwHandle = m_CurrentPShaderHandle;
    HR_RET(RecordStates( (PUINT8)pCmd, data_size ));

    return hr;
}


//-----------------------------------------------------------------------------
//
// SetRenderState -
//
//-----------------------------------------------------------------------------
void
RefDev::SetRenderState( DWORD dwState, DWORD dwValue )
{
    // check for range before continuing
    if(  dwState >= D3DHAL_MAX_RSTATES  )
    {
        return;
    }

    // set value in internal object
    m_dwRenderState[dwState] = dwValue;

    // do special validation work for some render states
    switch ( dwState )
    {

    case D3DRENDERSTATE_ZENABLE:
        if( dwValue )
            m_Clipper.m_dwFlags |=  RefClipper::RCLIP_Z_ENABLE;
        else
            m_Clipper.m_dwFlags &=  ~RefClipper::RCLIP_Z_ENABLE;
        break;
    case D3DRENDERSTATE_LIGHTING:
        if( dwValue )
            m_RefVP.m_dwTLState |= RDPV_DOLIGHTING;
        else
            m_RefVP.m_dwTLState &= ~RDPV_DOLIGHTING;
        break;
    case D3DRS_INDEXEDVERTEXBLENDENABLE:
        if( dwValue )
            m_RefVP.m_dwTLState |= RDPV_DOINDEXEDVERTEXBLEND;
        else
            m_RefVP.m_dwTLState &= ~RDPV_DOINDEXEDVERTEXBLEND;
        break;
    case D3DRENDERSTATE_CLIPPING:
        if( dwValue )
            m_RefVP.m_dwTLState |=  RDPV_DOCLIPPING;
        else
            m_RefVP.m_dwTLState &=  ~RDPV_DOCLIPPING;
        break;
    case D3DRENDERSTATE_SHADEMODE:
        {
            if( dwValue == D3DSHADE_FLAT )
                m_Clipper.m_dwFlags |=  RefClipper::RCLIP_DO_FLATSHADING;
            else
                m_Clipper.m_dwFlags &=  ~RefClipper::RCLIP_DO_FLATSHADING;
        }
        break;
    case D3DRENDERSTATE_FILLMODE:
        {
            if( dwValue == D3DFILL_WIREFRAME )
                m_Clipper.m_dwFlags |=  RefClipper::RCLIP_DO_WIREFRAME;
            else
                m_Clipper.m_dwFlags &=  ~RefClipper::RCLIP_DO_WIREFRAME;
        }
        break;
    case D3DRENDERSTATE_NORMALIZENORMALS:
        {
            if( dwValue )
                m_RefVP.m_dwTLState |=  RDPV_NORMALIZENORMALS;
            else
                m_RefVP.m_dwTLState &=  ~RDPV_NORMALIZENORMALS;
        }
        break;
    case D3DRENDERSTATE_LOCALVIEWER:
        {
            if( dwValue )
                m_RefVP.m_dwTLState |=  RDPV_LOCALVIEWER;
            else
                m_RefVP.m_dwTLState &=  ~RDPV_LOCALVIEWER;
        }
        break;
    case D3DRENDERSTATE_SPECULARENABLE:
        {
            if( dwValue )
                m_RefVP.m_dwTLState |= RDPV_DOSPECULAR;
            else
                m_RefVP.m_dwTLState &= ~RDPV_DOSPECULAR;
        }
        break;
    case D3DRENDERSTATE_COLORVERTEX:
    case D3DRENDERSTATE_AMBIENTMATERIALSOURCE:
    case D3DRENDERSTATE_DIFFUSEMATERIALSOURCE:
    case D3DRENDERSTATE_SPECULARMATERIALSOURCE:
    case D3DRENDERSTATE_EMISSIVEMATERIALSOURCE:
            m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_COLORVTX;
        break;
    case D3DRENDERSTATE_FOGCOLOR:
        {
            m_RefVP.m_lighting.fog_color = (D3DCOLOR) dwValue;
            m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_FOG;
        }
        break;
    case D3DRENDERSTATE_FOGTABLESTART:
        {
            m_RefVP.m_lighting.fog_start = *(D3DVALUE*)&dwValue;
            m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_FOG;
        }
        break;
    case D3DRENDERSTATE_FOGTABLEEND:
        {
            m_RefVP.m_lighting.fog_end = *(D3DVALUE*)&dwValue;
            m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_FOG;
        }
        break;
    case D3DRENDERSTATE_FOGTABLEDENSITY:
        {
            m_RefVP.m_lighting.fog_density = *(D3DVALUE*)&dwValue;
            m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_FOG;
        }
        break;
    case D3DRENDERSTATE_FOGVERTEXMODE:
        {
            m_RefVP.m_lighting.fog_mode = (int) dwValue;
            m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_FOG;
        }
        break;
    case D3DRENDERSTATE_AMBIENT:
        {
            m_RefVP.m_lighting.ambient_red   =
                D3DVAL(RGBA_GETRED(dwValue))/D3DVALUE(255);
            m_RefVP.m_lighting.ambient_green =
                D3DVAL(RGBA_GETGREEN(dwValue))/D3DVALUE(255);
            m_RefVP.m_lighting.ambient_blue  =
                D3DVAL(RGBA_GETBLUE(dwValue))/D3DVALUE(255);
            m_RefVP.m_lighting.ambient_save  = dwValue;
            m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_MATERIAL;
        }
        break;
    //
    // map legacy texture to multi-texture stage 0
    //
    case D3DRENDERSTATE_TEXTUREMAPBLEND:
        // map legacy blending state to texture stage 0
        MapLegacyTextureBlend();
        break;

        // map legacy modes with one-to-one mappings to texture stage 0
    case D3DRENDERSTATE_TEXTUREADDRESS:
// not available in DX8 headers
//        m_TextureStageState[0].m_dwVal[D3DTSS_ADDRESS] =
        m_TextureStageState[0].m_dwVal[D3DTSS_ADDRESSU] =
        m_TextureStageState[0].m_dwVal[D3DTSS_ADDRESSV] = dwValue;
        break;
    case D3DRENDERSTATE_TEXTUREADDRESSU:
        m_TextureStageState[0].m_dwVal[D3DTSS_ADDRESSU] = dwValue;
        break;
    case D3DRENDERSTATE_TEXTUREADDRESSV:
        m_TextureStageState[0].m_dwVal[D3DTSS_ADDRESSV] = dwValue;
        break;
    case D3DRENDERSTATE_MIPMAPLODBIAS:
        m_TextureStageState[0].m_dwVal[D3DTSS_MIPMAPLODBIAS] = dwValue;
        break;
    case D3DRENDERSTATE_BORDERCOLOR:
        m_TextureStageState[0].m_dwVal[D3DTSS_BORDERCOLOR] = dwValue;
        break;
    case D3DRENDERSTATE_ANISOTROPY:
        m_TextureStageState[0].m_dwVal[D3DTSS_MAXANISOTROPY] = dwValue;
        // fall thru to update filter state
    case D3DRENDERSTATE_TEXTUREMAG:
    case D3DRENDERSTATE_TEXTUREMIN:
        // map legacy filtering/sampling state to texture stage 0
        MapLegacyTextureFilter();
        break;

    case D3DRENDERSTATE_TEXTUREHANDLE:
        // map thru to set handle for first stage
        SetTextureStageState( 0, D3DTSS_TEXTUREMAP, dwValue );
        break;

    //
    // map legacy WRAPU/V state through to controls for tex coord 0
    //
    case D3DRENDERSTATE_WRAPU:
        m_dwRenderState[D3DRENDERSTATE_WRAP0] &= ~D3DWRAP_U;
        m_dwRenderState[D3DRENDERSTATE_WRAP0] |= ((dwValue) ? D3DWRAP_U : 0);
        break;
    case D3DRENDERSTATE_WRAPV:
        m_dwRenderState[D3DRENDERSTATE_WRAP0] &= ~D3DWRAP_V;
        m_dwRenderState[D3DRENDERSTATE_WRAP0] |= ((dwValue) ? D3DWRAP_V : 0);
        break;


    case D3DRS_MULTISAMPLEANTIALIAS:
    case D3DRS_MULTISAMPLEMASK:
        m_dwRastFlags |= RDRF_MULTISAMPLE_CHANGED;
        break;

    //
    // Scene Capture
    //
    case D3DRENDERSTATE_SCENECAPTURE:
        if( dwValue )
            SceneCapture(D3DHAL_SCENE_CAPTURE_START);
        else
            SceneCapture(D3DHAL_SCENE_CAPTURE_END);
        break;

    case D3DRS_POINTSIZE:
        m_RefVP.m_fPointSize = m_fRenderState[dwState];
        break;

    case D3DRS_POINTSCALE_A:
        m_RefVP.m_fPointAttA = m_fRenderState[dwState];
        break;

    case D3DRS_POINTSCALE_B:
        m_RefVP.m_fPointAttB = m_fRenderState[dwState];
        break;

    case D3DRS_POINTSCALE_C:
        m_RefVP.m_fPointAttC = m_fRenderState[dwState];
        break;

    case D3DRS_POINTSIZE_MIN:
        m_RefVP.m_fPointSizeMin = m_fRenderState[dwState];
        break;

    case D3DRS_POINTSIZE_MAX:
        m_RefVP.m_fPointSizeMax = min(RD_MAX_POINT_SIZE,
                                      m_fRenderState[dwState]);
        break;

    case D3DRS_TWEENFACTOR:
        m_RefVP.m_fTweenFactor = m_fRenderState[dwState];
        break;

    //
    // HOSurface DDI only renderstate
    //
    case D3DRS_DELETERTPATCH:
        if(dwValue < m_HOSCoeffs.GetSize())
        {
            RDHOCoeffs &coeffs = m_HOSCoeffs[dwValue];
            delete[] coeffs.m_pNumSegs;
            coeffs.m_pNumSegs = 0;
            for(unsigned i = 0; i < RD_MAX_NUMSTREAMS; ++i)
            {
                delete[] coeffs.m_pData[i];
                coeffs.m_pData[i] = 0;
            }
        }
    }
}

HRESULT
RefDev::Dp2SetRenderTarget(LPD3DHAL_DP2COMMAND pCmd)
{
    LPD3DHAL_DP2SETRENDERTARGET pSRTData;
    HRESULT hr;

    // Get new data by ignoring all but the last structure
    pSRTData = (D3DHAL_DP2SETRENDERTARGET*)(pCmd + 1) + (pCmd->wStateCount - 1);

    // set 'changed' flags
    m_dwRastFlags =
        RDRF_MULTISAMPLE_CHANGED|
        RDRF_PIXELSHADER_CHANGED|
        RDRF_LEGACYPIXELSHADER_CHANGED|
        RDRF_TEXTURESTAGESTATE_CHANGED;

    return GetRenderTarget()->Initialize( m_pDDLcl,
                                          pSRTData->hRenderTarget,
                                          pSRTData->hZBuffer );
}

HRESULT
RefDev::Dp2CreateVertexShader( DWORD handle,
                                            DWORD dwDeclSize, LPDWORD pDecl,
                                            DWORD dwCodeSize, LPDWORD pCode )
{
    HRESULT hr = S_OK;

    HR_RET( m_VShaderHandleArray.Grow( handle ) );

    //
    // Validation sequence
    //
#if DBG
    _ASSERT( m_VShaderHandleArray[handle].m_tag == 0,
             "A shader exists with the given handle, tag is non-zero" );
#endif
    _ASSERT( pDecl, "A declaration should exist" );
    _ASSERT( dwDeclSize, "A declaration size should be non-zero" );
    _ASSERT( m_VShaderHandleArray[handle].m_pShader == NULL,
             "A shader exists with the given handle" );


    RDVShader* pShader = m_VShaderHandleArray[handle].m_pShader =
        new RDVShader;

    if( pShader == NULL )
        return E_OUTOFMEMORY;

    //
    // Parse the declaration
    //
    if( FAILED( hr = pShader->m_Declaration.Parse( pDecl,
                                                   !(BOOL)dwCodeSize ) ) )
    {
        DPFERR( "Vertex Shader declaration parsing failed" );
        goto error_ret;
    }

    //
    // Now compile the shader code if any of it is given
    //
    if( dwCodeSize )
    {
        pShader->m_pCode = m_RefVM.CompileCode( dwCodeSize, pCode );
        if( pShader->m_pCode == NULL )
        {
            DPFERR( "Vertex Shader Code compilation failed" );
            hr = E_FAIL;
            goto error_ret;
        }
    }

#if DBG
    // Everything successful, mark this handle as in use.
    m_VShaderHandleArray[handle].m_tag = 1;
#endif
    return S_OK;

error_ret:
    delete pShader;
    m_VShaderHandleArray[handle].m_pShader = NULL;
#if DBG
    m_VShaderHandleArray[handle].m_tag = 0;
#endif
    return hr;
}

HRESULT
RefDev::Dp2DeleteVertexShader(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;

    LPD3DHAL_DP2VERTEXSHADER pVS =
        (LPD3DHAL_DP2VERTEXSHADER)(pCmd + 1);
    for( int i = 0; i < pCmd->wStateCount; i++ )
    {
        DWORD handle = pVS[i].dwHandle;

        _ASSERT( m_VShaderHandleArray.IsValidIndex( handle ),
                 "Such a shader does not exist" );

        _ASSERT( m_VShaderHandleArray[handle].m_pShader,
                 "Such a shader does not exist" );

        delete m_VShaderHandleArray[handle].m_pShader;
        m_VShaderHandleArray[handle].m_pShader = NULL;
#if DBG
        m_VShaderHandleArray[handle].m_tag = 0;
#endif

        if( handle == m_CurrentVShaderHandle )
        {
            m_CurrentVShaderHandle = 0;
            m_pCurrentVShader = NULL;
        }
    }
    return hr;
}

HRESULT
RefDev::Dp2SetVertexShader(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;

    LPD3DHAL_DP2VERTEXSHADER pVS =
        (LPD3DHAL_DP2VERTEXSHADER)(pCmd + 1);

    // Just set the last Vertex Shader in this array
    DWORD handle = pVS[pCmd->wStateCount-1].dwHandle;

    //
    // Zero is a special handle that tells the driver to
    // invalidate the currently set shader.
    //

    if( handle == 0 )
    {
        m_pCurrentVShader = NULL;
        m_CurrentVShaderHandle = handle;
        return hr;
    }

    if( RDVSD_ISLEGACY(handle) )
    {
        // Make it parse the FVF and build the VertexElement array
        hr = m_FVFShader.m_Declaration.MakeVElementArray( handle );
        if( FAILED( hr ) )
        {
            DPFERR( "MakeVElementArray failed" );
            return hr;
        }

        m_pCurrentVShader = &m_FVFShader;
    }
    else
    {

        if( !m_VShaderHandleArray.IsValidIndex( handle ) || 
            (m_VShaderHandleArray[handle].m_pShader == NULL) )
        {
            DPFERR( "Such a Vertex Shader has not been created" );
            return E_INVALIDARG;
        }
        m_pCurrentVShader = m_VShaderHandleArray[handle].m_pShader;

        // Save the tesselator stride computed at parsing time.
        // This feature is only available when using a Declaration.
        m_VStream[RDVSD_STREAMTESS].m_dwStride =
            m_pCurrentVShader->m_Declaration.m_dwStreamTessStride;

    }

    if( m_pCurrentVShader->m_pCode )
    {
        hr = m_RefVM.SetActiveShaderCode( m_pCurrentVShader->m_pCode );
        if( FAILED( hr ) )
        {
            DPFERR( "SetActiveShaderCode failed" );
            return hr;
        }

        RDVConstantData* pConst =
            m_pCurrentVShader->m_Declaration.m_pConstants;
        while( pConst )
        {
            hr = m_RefVM.SetData( D3DSPR_CONST,
                                  pConst->m_dwAddress,
                                  pConst->m_dwCount,
                                  pConst->m_pData );
            if( FAILED( hr ) )
            {
                DPFERR( "SetVMData failed" );
                return hr;
            }
            pConst = static_cast<RDVConstantData *>(pConst->m_pNext);
        }
    }

    m_CurrentVShaderHandle = handle;
    if( m_pCurrentVShader->m_Declaration.m_qwInputFVF != m_RefVP.m_qwFVFIn )
    {
        m_RefVP.m_dwDirtyFlags |= RDPV_DIRTY_COLORVTX;
    }
    m_RefVP.m_qwFVFIn = m_pCurrentVShader->m_Declaration.m_qwInputFVF;

    return hr;
}

HRESULT
RefDev::Dp2SetVertexShaderConsts( DWORD StartReg, DWORD dwCount,
                                               LPDWORD pData )
{
    HRESULT hr = m_RefVM.SetData( D3DSPR_CONST, StartReg, dwCount, pData );
    return hr;
}

HRESULT
RefDev::Dp2SetStreamSource(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;

    LPD3DHAL_DP2SETSTREAMSOURCE pSSS =
        (LPD3DHAL_DP2SETSTREAMSOURCE)(pCmd + 1);
    for( int i = 0; i < pCmd->wStateCount; i++ )
    {
        RDVStream& Stream = m_VStream[pSSS[i].dwStream];

        // NULL handle means that the StreamSource should be unset.
        if( pSSS[i].dwVBHandle == 0 )
        {
            Stream.m_pData = NULL;
            Stream.m_dwStride = 0;
            Stream.m_dwHandle = 0;
        }
        else
        {

            // Check if the handle has a valid vertexbuffer
            RDSurface* pSurf =
                g_SurfMgr.GetSurfFromList(m_pDDLcl, pSSS[i].dwVBHandle);
            if( (pSurf == NULL) ||
                (pSurf->GetSurfaceType() != RR_ST_VERTEXBUFFER) )
            {
                DPFERR( "Invalid VB Handle passed in SetStreamSource" );
                return E_INVALIDARG;
            }

            RDVertexBuffer* pVB = static_cast<RDVertexBuffer *>(pSurf);
            Stream.m_pData = pVB->GetBits();
            Stream.m_dwStride = pSSS[i].dwStride;
            Stream.m_dwHandle = pSSS[i].dwVBHandle;
        }
    }
    return hr;
}

HRESULT
RefDev::Dp2SetStreamSourceUM( LPD3DHAL_DP2COMMAND pCmd,
                                           PUINT8 pUMVtx )
{
    HRESULT hr = S_OK;
    // Get new data by ignoring all but the last structure
    D3DHAL_DP2SETSTREAMSOURCEUM* pSSUM =
        (D3DHAL_DP2SETSTREAMSOURCEUM*)(pCmd + 1) + (pCmd->wStateCount - 1);

    // Access only the Zero'th stream
    m_VStream[pSSUM->dwStream].m_pData = pUMVtx;
    m_VStream[pSSUM->dwStream].m_dwStride = pSSUM->dwStride;
    m_VStream[pSSUM->dwStream].m_dwHandle = 0;

    return hr;
}

HRESULT
RefDev::Dp2SetIndices(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;
    // Get new data by ignoring all but the last structure
    D3DHAL_DP2SETINDICES* pSI =
        (D3DHAL_DP2SETINDICES*)(pCmd + 1) + (pCmd->wStateCount - 1);

    // NULL handle means that the StreamSource should be unset.
    if( pSI->dwVBHandle == 0 )
    {
        m_IndexStream.m_pData = NULL;
        m_IndexStream.m_dwStride = 0;
        m_IndexStream.m_dwHandle = 0;
    }
    else
    {
        // Check if the handle has a valid vertexbuffer
        RDSurface* pSurf = g_SurfMgr.GetSurfFromList(m_pDDLcl,
                                                     pSI->dwVBHandle);
        if( (pSurf == NULL) ||
            (pSurf->GetSurfaceType() != RR_ST_VERTEXBUFFER) )
        {
            DPFERR( "Invalid VB Handle passed in SetIndices" );
            return E_INVALIDARG;
        }
        RDVertexBuffer* pVB = static_cast<RDVertexBuffer *>(pSurf);
        m_IndexStream.m_pData = pVB->GetBits();
        m_IndexStream.m_dwStride = pSI->dwStride;
        m_IndexStream.m_dwHandle = pSI->dwVBHandle;
    }

    return hr;
}


HRESULT
RefDev::Dp2DrawPrimitive(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;

    //
    // Validation
    //
    _ASSERT( m_CurrentVShaderHandle, "No vertex shader currently bound" );

    LPD3DHAL_DP2DRAWPRIMITIVE pDP = (LPD3DHAL_DP2DRAWPRIMITIVE)(pCmd + 1);
    for( int i = 0; i < pCmd->wStateCount; i++ )
    {
        if( FAILED( hr = DrawDX8Prim( &(pDP[i]) ) ) )
            return hr;
    }
    return hr;
}

HRESULT
RefDev::Dp2DrawPrimitive2(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;

    //
    // Validation
    //
    _ASSERT( m_CurrentVShaderHandle, "No vertex shader currently bound" );

    LPD3DHAL_DP2DRAWPRIMITIVE2 pDP = (LPD3DHAL_DP2DRAWPRIMITIVE2)(pCmd + 1);
    for( int i = 0; i < pCmd->wStateCount; i++ )
    {
        if( FAILED( hr = DrawDX8Prim2( &(pDP[i]) ) ) )
            return hr;
    }
    return hr;
}

HRESULT
RefDev::Dp2DrawIndexedPrimitive(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;
    //
    // Validation
    //
    _ASSERT( m_CurrentVShaderHandle, "No vertex shader currently bound" );

    LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE pDIP =
        (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE)(pCmd + 1);
    for( int i = 0; i < pCmd->wStateCount; i++ )
    {
        if( FAILED( hr = DrawDX8IndexedPrim( &(pDIP[i]) ) ) )
            return hr;
    }
    return hr;
}

HRESULT
RefDev::Dp2DrawIndexedPrimitive2(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;
    //
    // Validation
    //
    _ASSERT( m_CurrentVShaderHandle, "No vertex shader currently bound" );

    LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2 pDIP =
        (LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2)(pCmd + 1);
    for( int i = 0; i < pCmd->wStateCount; i++ )
    {
        if( FAILED( hr = DrawDX8IndexedPrim2( &(pDIP[i]) ) ) )
            return hr;
    }
    return hr;
}

HRESULT
RefDev::Dp2DrawClippedTriFan(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;
    //
    // Validation
    //
    _ASSERT( m_CurrentVShaderHandle, "No vertex shader currently bound" );

    LPD3DHAL_CLIPPEDTRIANGLEFAN pDIP =
        (LPD3DHAL_CLIPPEDTRIANGLEFAN)(pCmd + 1);
    for( int i = 0; i < pCmd->wStateCount; i++ )
    {
        if( FAILED( hr = DrawDX8ClippedTriFan( &(pDIP[i]) ) ) )
            return hr;
    }
    return hr;
}


HRESULT
RefDev::Dp2SetPalette(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;
    LPD3DHAL_DP2SETPALETTE pSP = (LPD3DHAL_DP2SETPALETTE)(pCmd + 1);
    for( int i = 0; i < pCmd->wStateCount; i++ )
    {
        HR_RET( m_PaletteHandleArray.Grow( pSP->dwPaletteHandle ) );
        if( m_PaletteHandleArray[pSP->dwPaletteHandle].m_pPal == NULL )
        {
            m_PaletteHandleArray[pSP->dwPaletteHandle].m_pPal = new RDPalette;
        }
        RDPalette* pPal = m_PaletteHandleArray[pSP->dwPaletteHandle].m_pPal;
        pPal->m_dwFlags = (pSP->dwPaletteFlags & DDRAWIPAL_ALPHA) ?
            RDPalette::RDPAL_ALPHAINPALETTE : 0;
        RDSurface2D* pSurf = (RDSurface2D *)g_SurfMgr.GetSurfFromList(
            m_pDDLcl, pSP->dwSurfaceHandle );
        if( pSurf == NULL ) return E_FAIL;
        if( (pSurf->GetSurfaceType() & RR_ST_TEXTURE) == 0 )
        {
            DPFERR( "Setting palette to a non-texture\n" );
            return E_FAIL;
        }
        pSurf->SetPalette( pPal );
    }
    return hr;
}

HRESULT
RefDev::Dp2UpdatePalette(LPD3DHAL_DP2UPDATEPALETTE pUP, PALETTEENTRY* pPalData)
{
    HRESULT hr = S_OK;
    HR_RET( m_PaletteHandleArray.Grow( pUP->dwPaletteHandle ) );
    if( m_PaletteHandleArray[pUP->dwPaletteHandle].m_pPal == NULL )
    {
        m_PaletteHandleArray[pUP->dwPaletteHandle].m_pPal = new RDPalette;
    }
    RDPalette* pPal = m_PaletteHandleArray[pUP->dwPaletteHandle].m_pPal;
    HR_RET( pPal->Update( pUP->wStartIndex, pUP->wNumEntries, pPalData ) );
    return hr;
}

HRESULT
RefDev::Dp2SetTexLod(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;
    LPD3DHAL_DP2SETTEXLOD pSTL = (LPD3DHAL_DP2SETTEXLOD)(pCmd + 1);
    for( int i = 0; i < pCmd->wStateCount; i++ )
    {
        RDSurface2D* pSurf = (RDSurface2D *)g_SurfMgr.GetSurfFromList(
            m_pDDLcl, pSTL->dwDDSurface );
        if( pSurf == NULL ) return E_FAIL;
        if( (pSurf->GetSurfaceType() & RR_ST_TEXTURE) == 0 )
        {
            DPFERR( "Setting LOD  to a non-texture\n" );
            return E_FAIL;
        }
        HR_RET(pSurf->SetLod( pSTL->dwLOD ));
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\hop\bezier.cpp ===
/*============================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       bezier.cpp
 *  Content:    Implementation for Beziers
 *
 ****************************************************************************/

#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
// RefDev::ProcessBezier
//-----------------------------------------------------------------------------
HRESULT RefDev::ProcessBezier( DWORD dwOffW, DWORD dwOffH,
                               DWORD dwWidth, DWORD dwHeight,
                               DWORD dwStride, DWORD order,
                               FLOAT *pPrimSegments,
                               bool bDegenerate )
{
    if(order == 0)
    {
        order = 2;
    }
    else
    {
        ++order;
    }

    if(((dwWidth - 1) % (order - 1)) != 0 || ((dwHeight - 1) % (order - 1)) != 0)
    {
        DPFERR("Incorrect order specified for current width or height");
        return DDERR_INVALIDPARAMS;
    }

    RDBezier bz(order, order);

    static const unsigned M[4] = {0, 0, 0, 0}, N[4] = {0, 0, 0, 0};

    unsigned u_segs, v_segs, u_start, v_start;

    if(pPrimSegments != 0)
    {
        u_segs = unsigned(double(unsigned(pPrimSegments[0]) + unsigned(pPrimSegments[2])) / 2.0 + 0.5);
        v_segs = unsigned(double(unsigned(pPrimSegments[1]) + unsigned(pPrimSegments[3])) / 2.0 + 0.5);
        if(u_segs == 0)
        {
            u_segs = 1;
        }
        if(v_segs == 0)
        {
            v_segs = 1;
        }
        if(unsigned(pPrimSegments[0]) != unsigned(pPrimSegments[2]) || unsigned(pPrimSegments[1]) != unsigned(pPrimSegments[3]))
        {
            // First, gulp, the irregular outside
            // To make life easier, we don't want to deal with the case when u_segs or v_segs is one
            // This ensures that there is at least one inside point
            if(u_segs == 1)
            {
                u_segs = 2;
            }
            if(v_segs == 1)
            {
                v_segs = 2;
            }
            // Start with top edge
            unsigned segs = unsigned(pPrimSegments[0]);
            unsigned k_outer = 0;
            unsigned k_inner = 1;
            unsigned outer_inc = u_segs - 2;
            unsigned inner_inc = segs;
            unsigned outer = 0;
            unsigned inner = 0;
            double u0, v0, u1, v1, u2, v2;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer < segs))
            {
                bool D0, D1, D2;
                if(inner < outer)
                {
                    _ASSERT(k_inner < u_segs - 1, "Error in logic");
                    u0 = double(k_inner) / double(u_segs);    
                    v0 = 1.0 / double(v_segs);
                    D0 = false;
                    u1 = double(k_outer) / double(segs);    
                    v1 = 0.0;
                    D1 = bDegenerate;
                    u2 = double(k_inner + 1) / double(u_segs);    
                    v2 = v0;
                    D2 = false;
                    ++k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer < segs, "Error in logic");
                    u0 = double(k_inner) / double(u_segs);    
                    v0 = 1.0 / double(v_segs);
                    D0 = false;
                    u1 = double(k_outer) / double(segs);    
                    v1 = 0.0;
                    D1 = bDegenerate;
                    u2 = double(k_outer + 1) / double(segs);    
                    v2 = v1;
                    D2 = bDegenerate;
                    ++k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(bz, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2, 
                                         bDegenerate ? u0 * v0 : u0, v0, bDegenerate ? u1 * v1 : u1, v1, bDegenerate ? u2 * v2 : u2, v2, 
                                         D0, D1, D2);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // bottom edge
            segs = unsigned(pPrimSegments[2]);
            k_outer = segs;
            k_inner = u_segs - 1;
            inner_inc = segs;
            outer = 0;
            inner = 0;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer > 0))
            {
                if(inner < outer)
                {
                    _ASSERT(k_inner > 1, "Error in logic");
                    u0 = double(k_inner) / double(u_segs);    
                    v0 = double(v_segs - 1) / double(v_segs);
                    u1 = double(k_outer) / double(segs);    
                    v1 = 1.0;
                    u2 = double(k_inner - 1) / double(u_segs);    
                    v2 = v0;
                    --k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer > 0, "Error in logic");
                    u0 = double(k_inner) / double(u_segs);    
                    v0 = double(v_segs - 1) / double(v_segs);
                    u1 = double(k_outer) / double(segs);    
                    v1 = 1.0;
                    u2 = double(k_outer - 1) / double(segs);    
                    v2 = v1;
                    --k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(bz, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2, 
                                         bDegenerate ? u0 * v0 : u0, v0, bDegenerate ? u1 * v1 : u1, v1, bDegenerate ? u2 * v2 : u2, v2, 
                                         false, false, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // right edge
            segs = unsigned(pPrimSegments[1]);
            k_outer = 0;
            k_inner = 1;
            outer_inc = v_segs - 2;
            inner_inc = segs;
            outer = 0;
            inner = 0;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer < segs))
            {
                bool D1;
                if(inner < outer)
                {
                    _ASSERT(k_inner < v_segs - 1, "Error in logic");
                    u0 = double(u_segs - 1) / double(u_segs);
                    v0 = double(k_inner) / double(v_segs);
                    u1 = 1.0;
                    v1 = double(k_outer) / double(segs);
                    D1 = (k_outer == 0) ? bDegenerate : false;
                    u2 = u0;
                    v2 = double(k_inner + 1) / double(v_segs);    
                    ++k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer < segs, "Error in logic");
                    u0 = double(u_segs - 1) / double(u_segs);
                    v0 = double(k_inner) / double(v_segs);
                    u1 = 1.0;
                    v1 = double(k_outer) / double(segs);
                    D1 = (k_outer == 0) ? bDegenerate : false;
                    u2 = u1;
                    v2 = double(k_outer + 1) / double(segs);    
                    ++k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(bz, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2, 
                                         bDegenerate ? u0 * v0 : u0, v0, bDegenerate ? u1 * v1 : u1, v1, bDegenerate ? u2 * v2 : u2, v2, 
                                         false, D1, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // left edge
            segs = unsigned(pPrimSegments[3]);
            k_outer = segs;
            k_inner = v_segs - 1;
            inner_inc = segs;
            outer = 0;
            inner = 0;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer > 0))
            {
                bool D1, D2;
                if(inner < outer)
                {
                    _ASSERT(k_inner > 1, "Error in logic");
                    u0 = 1.0 / double(u_segs);
                    v0 = double(k_inner) / double(v_segs);
                    u1 = 0.0;
                    v1 = double(k_outer) / double(segs);
                    D1 = (k_outer == 0) ? bDegenerate : false;
                    u2 = u0;
                    v2 = double(k_inner - 1) / double(v_segs);    
                    D2 = false;
                    --k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer > 0, "Error in logic");
                    u0 = 1.0 / double(u_segs);
                    v0 = double(k_inner) / double(v_segs);
                    u1 = 0.0;
                    v1 = double(k_outer) / double(segs);
                    D1 = false; // since k_outer always > 0
                    u2 = u1;
                    v2 = double(k_outer - 1) / double(segs);    
                    D2 = (k_outer - 1 == 0) ? bDegenerate : false;
                    --k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(bz, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2, 
                                         bDegenerate ? u0 * v0 : u0, v0, bDegenerate ? u1 * v1 : u1, v1, bDegenerate ? u2 * v2 : u2, v2, 
                                         false, D1, D2);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // Now do the regular interior
            u_start = 1;
            v_start = 1;
        }
        else
        {
            // It can be done regularly
            u_start = 0;
            v_start = 0;
        }
    }
    else
    {
        unsigned segs = unsigned(GetRSf()[D3DRS_PATCHSEGMENTS]);
        if(segs == 0)
        {
            segs = 1;
        }
        u_start = 0;
        v_start = 0;
        u_segs = segs;
        v_segs = segs;
    }

    for(unsigned i = v_start; i < v_segs - v_start; ++i)
    {
        double v0 = double(i) / double(v_segs);
        double v1 = double(i + 1) / double(v_segs);
        for(unsigned j = u_start; j < u_segs - u_start; ++j)
        {
            double u0 = double(j) / double(u_segs);    
            double u1 = double(j + 1) / double(u_segs);    
            if(i == 0 && bDegenerate)
            {
                HRESULT hr = DrawTessTri(bz, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u0, v1, u0 * v0, v0, u1 * v1, v1, u0 * v1, v1, true, false, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            else
            {
                HRESULT hr = DrawTessQuad(bz, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u0, v0, u1, v1, bDegenerate);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
        }
    }
    
    return S_OK;
}

//-----------------------------------------------------------------------------
// RDBezier::RDBezier
//-----------------------------------------------------------------------------
RDBezier::RDBezier(DWORD dwOrderU, DWORD dwOrderV) 
                    : RDBSpline(dwOrderU, dwOrderV, dwOrderU - 1, dwOrderV - 1)
{
    for(unsigned n = 1; n <= 12; ++n)
    {
        for(unsigned i = 0; i <= n; ++i)
        {
            m_lut[n][i] = double(factorial(n)) / (double(factorial(i)) * double(factorial(n - i)));
        }
    }
}

//-----------------------------------------------------------------------------
// RDBSpline::TexCoordU
//-----------------------------------------------------------------------------
double RDBezier::TexCoordU(double u) const
{
    return u;
}

//-----------------------------------------------------------------------------
// RDBSpline::TexCoordV
//-----------------------------------------------------------------------------
double RDBezier::TexCoordV(double v) const
{
    return v;
}

//-----------------------------------------------------------------------------
// RDBezier::Basis
//-----------------------------------------------------------------------------
double RDBezier::Basis(unsigned i, unsigned n, double t) const
{
    _ASSERT(n < 13, "Order out of range");
    return m_lut[n][i] * pow(t, double(i)) * pow(1.0 - t, double(n - i));
}

//-----------------------------------------------------------------------------
// RDBezier::BasisPrime
//-----------------------------------------------------------------------------
double RDBezier::BasisPrime(unsigned i, unsigned n, double t) const
{
    _ASSERT(n < 13, "Order out of range");
    if(i == 0)
    {
        return m_lut[n][i] * -double(n) * pow(1 - t, n - 1);
    }
    else if(i == n)
    {
        return m_lut[n][i] * double(n) * pow(t, n - 1);
    }
    else
    {
        return (double(i) - double(n) * t) * (m_lut[n][i] * pow(t, double(i) - 1.0) * pow(1.0 - t, double(n - i) - 1.0));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\drv\surfman.cpp ===
//----------------------------------------------------------------------------
//
// surfman.cpp
//
// Reference rasterizer callback functions for D3DIM.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------
#include "pch.cpp"
#pragma hdrstop

// Global Surface Manager, one per process
RDSurfaceManager g_SurfMgr;


///////////////////////////////////////////////////////////////////////////////
//
// Helper functions
//
///////////////////////////////////////////////////////////////////////////////
HRESULT
CreateAppropriateSurface( LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl,
                          DWORD*                    pHandle,
                          RDSurface**               ppSurf )
{
    HRESULT hr = S_OK;

    *ppSurf = NULL;
    *pHandle = 0;

    // Obtain the Handle
    DWORD dwHandle = pDDSLcl->lpSurfMore->dwSurfaceHandle;
    *pHandle = dwHandle;

    // Figure out if we care for this surface. Currently,
    // we care only for:
    //     1) Textures (MipMaps and Cubemaps)
    //     2) RenderTargets & DepthBuffers

    if( pDDSLcl->ddsCaps.dwCaps  & 
        (DDSCAPS_TEXTURE | DDSCAPS_ZBUFFER | DDSCAPS_3DDEVICE) )
    {
        RDSurface2D* pSurf2D = new RDSurface2D();
        if( pSurf2D == NULL )
        {
            DPFERR("New RDSurface2D failed, out of memory" );
            return DDERR_OUTOFMEMORY;
        }
        *ppSurf = pSurf2D;
    }
    else if( pDDSLcl->ddsCaps.dwCaps  & DDSCAPS_EXECUTEBUFFER )
    {
        // Strictly speaking, RDVertexBuffer should be
        // called RDLinearBuffer (it could be vertex, index or command)
        // For the time being, there is no need to distinguish between
        // the three. There is not harm in recognizing it for the Index
        // and Command buffer case. In case in the future, we do need to
        // make a distinction between Vertex and Index buffers, we need
        // to make the following tests:
        // For VB:
        //     (pDDSLcl->pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & 
        //             DDSCAPS2_VERTEXBUFFER))
        // For IB:
        //     (pDDSLcl->pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2 & 
        //             DDSCAPS2_INDEXBUFFER))

        RDVertexBuffer* pVB = new RDVertexBuffer();
        if( pVB == NULL )
        {
            DPFERR("New RDVertexBuffer failed, out of memory" );
            return DDERR_OUTOFMEMORY;
        }
        *ppSurf = pVB;
    }
    else
    {
        DPFM(2, DRV, ("RefCreateSurfaceEx w/o "
                      "DDSCAPS_TEXTURE/3DDEVICE/ZBUFFER Ignored"
                      "dwCaps=%08lx dwSurfaceHandle=%08lx",
                      pDDSLcl->ddsCaps.dwCaps,
                      pDDSLcl->lpSurfMore->dwSurfaceHandle));
        return hr;
    }

    if( FAILED( hr = (*ppSurf)->Initialize( pDDSLcl ) ) )
    {
        DPFERR( "Initialize failed" );
        delete (*ppSurf);
        return hr;
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// RDVertexBuffer implementation
//
///////////////////////////////////////////////////////////////////////////////
//-----------------------------------------------------------------------------
// RDVertexBuffer::Initialize
//          Initializer.
//-----------------------------------------------------------------------------
HRESULT
RDVertexBuffer::Initialize( LPDDRAWI_DDRAWSURFACE_LCL pSLcl )
{
    HRESULT hr = S_OK;

    SetInitialized();

    m_SurfType =  RR_ST_VERTEXBUFFER;

    if( pSLcl->lpGbl->dwReserved1 )
    {
        RDCREATESURFPRIVATE* pPriv =
            (RDCREATESURFPRIVATE *)pSLcl->lpGbl->dwReserved1;
        m_pBits = pPriv->pBits;
        m_cbSize = (int)pPriv->dwVBSize;
        SetRefCreated();
    }
    else
    {
        m_pBits = (LPBYTE)SURFACE_MEMORY(pSLcl);
        m_cbSize = pSLcl->lpGbl->dwLinearSize;
    }
    
    return S_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
// RDSurfaceArrayNode implementation
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// RDSurfaceArrayNode::RDSurfaceArrayNode
//          Constructor.
//-----------------------------------------------------------------------------
RDSurfaceArrayNode::RDSurfaceArrayNode(LPDDRAWI_DIRECTDRAW_LCL pDDLcl)
    : RDListEntry(), m_SurfHandleArray()
{
    m_pDDLcl = pDDLcl;
}

//-----------------------------------------------------------------------------
// RDSurfaceArrayNode::~RDSurfaceArrayNode
//          Destructor.
//-----------------------------------------------------------------------------
RDSurfaceArrayNode::~RDSurfaceArrayNode()
{
    // Release all the allocated surfaces
    for( DWORD i=0; i<m_SurfHandleArray.GetSize(); i++ )
    {
        delete m_SurfHandleArray[i].m_pSurf;
    }
}

//-----------------------------------------------------------------------------
// RDSurfaceArrayNode::AddSurface
//          Adds a surface to its internal growable array if not already
//          present. ppSurf can be NULL.
//-----------------------------------------------------------------------------
HRESULT
RDSurfaceArrayNode::AddSurface( LPDDRAWI_DDRAWSURFACE_LCL   pDDSLcl,
                                RDSurface**                 ppSurf )
{
    DWORD dwHandle = 0;
    HRESULT hr = S_OK;
    RDSurface* pSurf = NULL;

    if( FAILED(hr = CreateAppropriateSurface( pDDSLcl, &dwHandle, &pSurf ) ) )
    {
        return hr;
    }


    // If it is zero, there was something wrong
    if( pSurf == NULL || dwHandle == 0 ) return E_FAIL;

    hr = m_SurfHandleArray.Grow( dwHandle );
    if (FAILED(hr))
    {
        return hr;
    }

    if( m_SurfHandleArray[dwHandle].m_pSurf )
    {
#if DBG
        _ASSERT( m_SurfHandleArray[dwHandle].m_tag,
                 "A surface is associated with this handle even though it was never initialized!" );
#endif
        delete m_SurfHandleArray[dwHandle].m_pSurf;
    }

    m_SurfHandleArray[dwHandle].m_pSurf = pSurf;
#if DBG
    m_SurfHandleArray[dwHandle].m_tag = 1;
#endif

    if( ppSurf ) *ppSurf = pSurf;
    return S_OK;
}

//-----------------------------------------------------------------------------
// RDSurfaceArrayNode::GetSurface
//          Gets a surface from its internal array if present.
//-----------------------------------------------------------------------------
RDSurface*
RDSurfaceArrayNode::GetSurface( DWORD dwHandle )
{
    if( m_SurfHandleArray.IsValidIndex( dwHandle ) )
        return m_SurfHandleArray[dwHandle].m_pSurf;
    return NULL;
}

//-----------------------------------------------------------------------------
// RDSurfaceArrayNode::RemoveSurface
//          Removed the surface with the given handle from the list.
//-----------------------------------------------------------------------------
HRESULT
RDSurfaceArrayNode::RemoveSurface( DWORD dwHandle )
{
    if( m_SurfHandleArray.IsValidIndex( dwHandle ) &&
        m_SurfHandleArray[dwHandle].m_pSurf )
    {
        delete m_SurfHandleArray[dwHandle].m_pSurf;
        m_SurfHandleArray[dwHandle].m_pSurf = NULL;
        return S_OK;
    }
    
    DPFERR( "Bad handle passed for delete" );
    return DDERR_INVALIDPARAMS;
}

///////////////////////////////////////////////////////////////////////////////
//
// RDSurfaceManager implementation
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// RDSurfaceManager::AddLclNode
//          Adds a node with the given DDLcl to the list if not already
//          present.
//-----------------------------------------------------------------------------
RDSurfaceArrayNode*
RDSurfaceManager::AddLclNode( LPDDRAWI_DIRECTDRAW_LCL pDDLcl )
{
    RDSurfaceArrayNode* pCurrNode = m_pFirstNode;

    while( pCurrNode )
    {
        if( pDDLcl == pCurrNode->m_pDDLcl ) return pCurrNode;
        pCurrNode = pCurrNode->m_pNext;
    }

    // This means that we didnt find an existing node, create a
    // new one.
    RDSurfaceArrayNode* pTmpNode = m_pFirstNode;
    m_pFirstNode = new RDSurfaceArrayNode( pDDLcl );
    if( m_pFirstNode == NULL )
    {
        DPFERR("New Failed allocating a new RDSurfaceArrayNode\n");
        m_pFirstNode = pTmpNode;
                return NULL;
    }
    m_pFirstNode->m_pNext = pTmpNode;

    return m_pFirstNode;
}

//-----------------------------------------------------------------------------
// RDSurfaceManager::GetLclNode
//          Gets a node with the given DDLcl from the list if present.
//-----------------------------------------------------------------------------
RDSurfaceArrayNode*
RDSurfaceManager::GetLclNode( LPDDRAWI_DIRECTDRAW_LCL pDDLcl )
{
    RDSurfaceArrayNode* pCurrNode = m_pFirstNode;

    while( pCurrNode )
    {
        if( pDDLcl == pCurrNode->m_pDDLcl ) break;
        pCurrNode = pCurrNode->m_pNext;
    }

    return pCurrNode;
}

//-----------------------------------------------------------------------------
// RDSurfaceManager::AddSurfToList
//          Adds a surface to the node with a matching DDLcl. If the node
//          is not present it is created. The ppSurf param can be NULL.
//-----------------------------------------------------------------------------
HRESULT
RDSurfaceManager::AddSurfToList( LPDDRAWI_DIRECTDRAW_LCL     pDDLcl,
                                 LPDDRAWI_DDRAWSURFACE_LCL   pDDSLcl,
                                 RDSurface**                 ppSurf )
{
    HRESULT hr = S_OK;
    RDSurface* pSurf = NULL;

    RDSurfaceArrayNode* pCurrNode = AddLclNode( pDDLcl );
    if( pCurrNode )
    {
        hr = pCurrNode->AddSurface( pDDSLcl, &pSurf );
        if( ppSurf ) *ppSurf = pSurf;
        return hr;
    }

    return DDERR_OUTOFMEMORY;
}

//-----------------------------------------------------------------------------
// RDSurfaceManager::GetSurfFromList
//          Gets a surface with the matching handle from the node with a
//          matching DDLcl, if the node and the surface is present.
//-----------------------------------------------------------------------------
RDSurface*
RDSurfaceManager::GetSurfFromList( LPDDRAWI_DIRECTDRAW_LCL   pDDLcl,
                                   DWORD                     dwHandle )
{
    RDSurfaceArrayNode* pCurrNode = GetLclNode( pDDLcl );
    if( pCurrNode ) return pCurrNode->GetSurface( dwHandle );
    return NULL;
}

//-----------------------------------------------------------------------------
// RDSurfaceManager::RemoveSurfFromList
//          Deletes the surface handle.
//-----------------------------------------------------------------------------
HRESULT
RDSurfaceManager::RemoveSurfFromList( LPDDRAWI_DIRECTDRAW_LCL   pDDLcl,
                                      DWORD                     dwHandle )
{
    RDSurfaceArrayNode* pCurrNode = GetLclNode( pDDLcl );
    if( pCurrNode ) return pCurrNode->RemoveSurface( dwHandle );
    DPFERR("The DrawLcl is unrecognized\n");
    return DDERR_INVALIDPARAMS;
}

HRESULT
RDSurfaceManager::RemoveSurfFromList( LPDDRAWI_DIRECTDRAW_LCL   pDDLcl,
                                      LPDDRAWI_DDRAWSURFACE_LCL   pDDSLcl )
{
    RDSurfaceArrayNode* pCurrNode = GetLclNode( pDDLcl );
    if( pCurrNode ) return pCurrNode->RemoveSurface( 
        pDDSLcl->lpSurfMore->dwSurfaceHandle );
    DPFERR("The DrawLcl is unrecognized\n");
    return DDERR_INVALIDPARAMS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\hop\bezier.hpp ===
/*============================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       bezier.hpp
 *  Content:    Declarations for Beziers
 *
 ****************************************************************************/

#ifndef _BEZIER_HPP
#define _BEZIER_HPP

#include "bspline.hpp"

class RDBezier : public RDBSpline
{
public:
    RDBezier(DWORD dwOrderU, DWORD dwOrderV);

    virtual double TexCoordU(double u) const;
    virtual double TexCoordV(double v) const;

private:
    double m_lut[13][13];

    virtual double Basis(unsigned i, unsigned n, double t) const;
    virtual double BasisPrime(unsigned i, unsigned n, double t) const;

    unsigned factorial(unsigned k) const
    {
        _ASSERT(k < 13, "Factorial out of range");
        for(unsigned i = 1, t = 1; i <= k; t *= i++);
        return t;
    }
};

#endif // _BEZIER_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\hop\bspline.cpp ===
/*============================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       bspline.cpp
 *  Content:    Implementation for B-Splines
 *
 ****************************************************************************/

#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
// RefDev::ProcessBSpline
//-----------------------------------------------------------------------------
HRESULT RefDev::ProcessBSpline( DWORD dwOffW, DWORD dwOffH,
                                DWORD dwWidth, DWORD dwHeight,
                                DWORD dwStride, DWORD order,
                                FLOAT *pPrimSegments )
{
    if(order == 0)
    {
        order = 2;
    }
    else
    {
        ++order;
    }

    int u_range = dwWidth - (order - 1);
    int v_range = dwHeight - (order - 1);

    if(u_range <= 0 || v_range <= 0)
    {
        DPFERR("Insufficient control vertices for current order");
        return DDERR_INVALIDPARAMS;
    }

    RDBSpline bsp(dwWidth, dwHeight, order, order);

    static const unsigned M[4] = {0, 0, 0, 0}, N[4] = {0, 0, 0, 0};

    unsigned u_segs, v_segs, u_start, v_start;

    if(pPrimSegments != 0)
    {
        u_segs = unsigned(double(unsigned(pPrimSegments[0]) + unsigned(pPrimSegments[2])) / 2.0 + 0.5);
        v_segs = unsigned(double(unsigned(pPrimSegments[1]) + unsigned(pPrimSegments[3])) / 2.0 + 0.5);
        if(u_segs == 0)
        {
            u_segs = 1;
        }
        if(v_segs == 0)
        {
            v_segs = 1;
        }
        if(unsigned(pPrimSegments[0]) != unsigned(pPrimSegments[2]) || unsigned(pPrimSegments[1]) != unsigned(pPrimSegments[3]))
        {
            // First, gulp, the irregular outside
            // To make life easier, we don't want to deal with the case when u_segs or v_segs is one
            // This ensures that there is at least one inside point
            if(u_segs == 1)
            {
                u_segs = 2;
            }
            if(v_segs == 1)
            {
                v_segs = 2;
            }
            // Start with top edge
            unsigned segs = unsigned(pPrimSegments[0]);
            unsigned k_outer = 0;
            unsigned k_inner = 1;
            unsigned outer_inc = u_segs - 2;
            unsigned inner_inc = segs;
            unsigned outer = 0;
            unsigned inner = 0;
            double u0, v0, u1, v1, u2, v2;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer < segs))
            {
                if(inner < outer)
                {
                    _ASSERT(k_inner < u_segs - 1, "Error in logic");
                    u0 = double(u_range * k_inner) / double(u_segs) + double(order - 1);    
                    v0 = double(v_range) / double(v_segs) + double(order - 1);
                    u1 = double(u_range * k_outer) / double(segs) + double(order - 1);    
                    v1 = double(order - 1);
                    u2 = double(u_range * (k_inner + 1)) / double(u_segs) + double(order - 1);    
                    v2 = v0;
                    ++k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer < segs, "Error in logic");
                    u0 = double(u_range * k_inner) / double(u_segs) + double(order - 1);    
                    v0 = double(v_range) / double(v_segs) + double(order - 1);
                    u1 = double(u_range * k_outer) / double(segs) + double(order - 1);    
                    v1 = double(order - 1);
                    u2 = double(u_range * (k_outer + 1)) / double(segs) + double(order - 1);    
                    v2 = v1;
                    ++k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(bsp, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2,
                                         bsp.TexCoordU(u0), bsp.TexCoordV(v0),
                                         bsp.TexCoordU(u1), bsp.TexCoordV(v1),
                                         bsp.TexCoordU(u2), bsp.TexCoordV(v2),
                                         false, false, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // bottom edge
            segs = unsigned(pPrimSegments[2]);
            k_outer = segs;
            k_inner = u_segs - 1;
            inner_inc = segs;
            outer = 0;
            inner = 0;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer > 0))
            {
                if(inner < outer)
                {
                    _ASSERT(k_inner > 1, "Error in logic");
                    u0 = double(u_range * k_inner) / double(u_segs) + double(order - 1);    
                    v0 = double(v_range * (v_segs - 1)) / double(v_segs) + double(order - 1);
                    u1 = double(u_range * k_outer) / double(segs) + double(order - 1);    
                    v1 = double(v_range + order - 1);
                    u2 = double(u_range * (k_inner - 1)) / double(u_segs) + double(order - 1);    
                    v2 = v0;
                    --k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer > 0, "Error in logic");
                    u0 = double(u_range * k_inner) / double(u_segs) + double(order - 1);    
                    v0 = double(v_range * (v_segs - 1)) / double(v_segs) + double(order - 1);
                    u1 = double(u_range * k_outer) / double(segs) + double(order - 1);    
                    v1 = double(v_range + order - 1);
                    u2 = double(u_range * (k_outer - 1)) / double(segs) + double(order - 1);    
                    v2 = v1;
                    --k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(bsp, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2,
                                         bsp.TexCoordU(u0), bsp.TexCoordV(v0),
                                         bsp.TexCoordU(u1), bsp.TexCoordV(v1),
                                         bsp.TexCoordU(u2), bsp.TexCoordV(v2),
                                         false, false, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // right edge
            segs = unsigned(pPrimSegments[1]);
            k_outer = 0;
            k_inner = 1;
            outer_inc = v_segs - 2;
            inner_inc = segs;
            outer = 0;
            inner = 0;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer < segs))
            {
                if(inner < outer)
                {
                    _ASSERT(k_inner < v_segs - 1, "Error in logic");
                    u0 = double(u_range * (u_segs - 1)) / double(u_segs) + double(order - 1);
                    v0 = double(v_range * k_inner) / double(v_segs) + double(order - 1);
                    u1 = double(u_range + order - 1);
                    v1 = double(v_range * k_outer) / double(segs) + double(order - 1);
                    u2 = u0;
                    v2 = double(v_range * (k_inner + 1)) / double(v_segs) + double(order - 1);    
                    ++k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer < segs, "Error in logic");
                    u0 = double(u_range * (u_segs - 1)) / double(u_segs) + double(order - 1);
                    v0 = double(v_range * k_inner) / double(v_segs) + double(order - 1);
                    u1 = double(u_range + order - 1);
                    v1 = double(v_range * k_outer) / double(segs) + double(order - 1);
                    u2 = u1;
                    v2 = double(v_range * (k_outer + 1)) / double(segs) + double(order - 1);    
                    ++k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(bsp, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2,
                                         bsp.TexCoordU(u0), bsp.TexCoordV(v0),
                                         bsp.TexCoordU(u1), bsp.TexCoordV(v1),
                                         bsp.TexCoordU(u2), bsp.TexCoordV(v2),
                                         false, false, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // left edge
            segs = unsigned(pPrimSegments[3]);
            k_outer = segs;
            k_inner = v_segs - 1;
            inner_inc = segs;
            outer = 0;
            inner = 0;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer > 0))
            {
                if(inner < outer)
                {
                    _ASSERT(k_inner > 1, "Error in logic");
                    u0 = double(u_range) / double(u_segs) + double(order - 1);
                    v0 = double(v_range * k_inner) / double(v_segs) + double(order - 1);
                    u1 = double(order - 1);
                    v1 = double(v_range * k_outer) / double(segs) + double(order - 1);
                    u2 = u0;
                    v2 = double(v_range * (k_inner - 1)) / double(v_segs) + double(order - 1);    
                    --k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer > 0, "Error in logic");
                    u0 = double(u_range) / double(u_segs) + double(order - 1);
                    v0 = double(v_range * k_inner) / double(v_segs) + double(order - 1);
                    u1 = double(order - 1);
                    v1 = double(v_range * k_outer) / double(segs) + double(order - 1);
                    u2 = u1;
                    v2 = double(v_range * (k_outer - 1)) / double(segs) + double(order - 1);    
                    --k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(bsp, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2,
                                         bsp.TexCoordU(u0), bsp.TexCoordV(v0),
                                         bsp.TexCoordU(u1), bsp.TexCoordV(v1),
                                         bsp.TexCoordU(u2), bsp.TexCoordV(v2),
                                         false, false, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // Now do the regular interior
            u_start = 1;
            v_start = 1;
        }
        else
        {
            // It can be done regularly
            u_start = 0;
            v_start = 0;
        }
    }
    else
    {
        unsigned segs = unsigned(GetRSf()[D3DRS_PATCHSEGMENTS]);
        if(segs == 0)
        {
            segs = 1;
        }
        u_start = 0;
        v_start = 0;
        u_segs = segs;
        v_segs = segs;
    }

    for(unsigned i = v_start; i < v_segs - v_start; ++i)
    {
        double v0 = double(v_range * i) / double(v_segs) + double(order - 1);
        double v1 = double(v_range * (i + 1)) / double(v_segs) + double(order - 1);
        for(unsigned j = u_start; j < u_segs - u_start; ++j)
        {
            double u0 = double(u_range * j) / double(u_segs) + double(order - 1);    
            double u1 = double(u_range * (j + 1)) / double(u_segs) + double(order - 1);    
            HRESULT hr = DrawTessQuad(bsp, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1,
                                      bsp.TexCoordU(u0), bsp.TexCoordV(v0),
                                      bsp.TexCoordU(u1), bsp.TexCoordV(v1),
                                      false);
            if(FAILED(hr))
            {
                return hr;
            }
        }
    }

    return S_OK;
}

//-----------------------------------------------------------------------------
// RDBSpline::Sample
//-----------------------------------------------------------------------------
void RDBSpline::Sample(DWORD dwDataType, double u, double v, const BYTE *pRow, DWORD dwStride, DWORD dwPitch, BYTE *Q) const
{
    double Acc[4] = {0.0, 0.0, 0.0, 0.0};
    unsigned dwElements = 0;
    switch(dwDataType)
    {
        case D3DVSDT_FLOAT4:
            ++dwElements;
        case D3DVSDT_FLOAT3:
            ++dwElements;
        case D3DVSDT_FLOAT2:
            ++dwElements;
        case D3DVSDT_FLOAT1:
            ++dwElements;
            {
                for(unsigned i = 0; i < m_dwHeight; ++i)
                {
                    double N = Basis(i, m_dwOrderV, v);
                    const BYTE *pCol = pRow;
                    for(unsigned j = 0; j < m_dwWidth; ++j)
                    {
                        double NM = N * Basis(j, m_dwOrderU, u);
                        const FLOAT *B = (FLOAT*)pCol;
                        for(unsigned e = 0; e < dwElements; ++e)
                        {
                            Acc[e] += double(B[e]) * NM;
                        }
                        pCol += dwStride;
                    }
                    pRow += dwPitch;
                }
                for(unsigned e = 0; e < dwElements; ++e)
                {
                    ((FLOAT*)Q)[e] = FLOAT(Acc[e]);
                }
            }
            break;
        case D3DVSDT_D3DCOLOR:
        case D3DVSDT_UBYTE4:
            dwElements = 4;
            {
                for(unsigned i = 0; i < m_dwHeight; ++i)
                {
                    double N = Basis(i, m_dwOrderV, v);
                    const BYTE *pCol = pRow;
                    for(unsigned j = 0; j < m_dwWidth; ++j)
                    {
                        double NM = N * Basis(j, m_dwOrderU, u);
                        const BYTE *B = pCol;
                        for(unsigned e = 0; e < 4; ++e)
                        {
                            Acc[e] += double(B[e]) * NM;
                        }
                        pCol += dwStride;
                    }
                    pRow += dwPitch;
                }
                for(unsigned e = 0; e < 4; ++e)
                {
                    int t = int(Acc[e]);
                    Q[e] = BYTE(t < 0 ? 0 : (t > 255 ? 255 : t));
                }
            }
            break;
        case D3DVSDT_SHORT4:
            dwElements += 2;
        case D3DVSDT_SHORT2:
            dwElements += 2;
            {
                for(unsigned i = 0; i < m_dwHeight; ++i)
                {
                    double N = Basis(i, m_dwOrderV, v);
                    const BYTE *pCol = pRow;
                    for(unsigned j = 0; j < m_dwWidth; ++j)
                    {
                        double NM = N * Basis(j, m_dwOrderU, u);
                        const SHORT *B = (SHORT*)pCol;
                        for(unsigned e = 0; e < dwElements; ++e)
                        {
                            Acc[e] += double(B[e]) * NM;
                        }
                        pCol += dwStride;
                    }
                    pRow += dwPitch;
                }
                for(unsigned e = 0; e < dwElements; ++e)
                {
                    ((SHORT*)Q)[e] = SHORT(Acc[e]);
                }
            }
            break;
        default:
            _ASSERT(FALSE, "Ununderstood vertex element data type");
    }
}

//-----------------------------------------------------------------------------
// RDBSpline::SampleNormal
//-----------------------------------------------------------------------------
void RDBSpline::SampleNormal(DWORD dwDataType, double u, double v, const BYTE *pRow, DWORD dwStride, DWORD dwPitch, BYTE *Q) const
{
    double Acc[2][3] = {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}};
    // Fudge u and v if they are on the boundary. This is because the derivative is discontinuous on the boundary
    // and we really want it to be slightly inside the boundary.
    if(v == double(m_dwHeight))
    {
        v -= v * DBL_EPSILON;
    }
    if(u == double(m_dwWidth))
    {
        u -= u * DBL_EPSILON;
    }
    switch(dwDataType)
    {
        case D3DVSDT_FLOAT4:
        case D3DVSDT_FLOAT3:
            {
                for(unsigned i = 0; i < m_dwHeight; ++i)
                {
                    double N      = Basis(i, m_dwOrderV, v);
                    double NPrime = BasisPrime(i, m_dwOrderV, v);
                    const BYTE *pCol = pRow;
                    for(unsigned j = 0; j < m_dwWidth; ++j)
                    {
                        double NMPrime = N      * BasisPrime(j, m_dwOrderU, u);
                        double NPrimeM = NPrime * Basis(j, m_dwOrderU, u);
                        const FLOAT *B = (FLOAT*)pCol;
                        for(unsigned e = 0; e < 3; ++e)
                        {
                            Acc[0][e] += double(B[e]) * NMPrime;
                            Acc[1][e] += double(B[e]) * NPrimeM;
                        }
                        pCol += dwStride;
                    }
                    pRow += dwPitch;
                }
                ((FLOAT*)Q)[0] = FLOAT(Acc[0][1] * Acc[1][2] - Acc[0][2] * Acc[1][1]);
                ((FLOAT*)Q)[1] = FLOAT(Acc[0][2] * Acc[1][0] - Acc[0][0] * Acc[1][2]);
                ((FLOAT*)Q)[2] = FLOAT(Acc[0][0] * Acc[1][1] - Acc[0][1] * Acc[1][0]);
            }
            break;
        case D3DVSDT_D3DCOLOR:
        case D3DVSDT_UBYTE4:
            {
                for(unsigned i = 0; i < m_dwHeight; ++i)
                {
                    double N      = Basis(i, m_dwOrderV, v);
                    double NPrime = BasisPrime(i, m_dwOrderV, v);
                    const BYTE *pCol = pRow;
                    for(unsigned j = 0; j < m_dwWidth; ++j)
                    {
                        double NMPrime = N      * BasisPrime(j, m_dwOrderU, u);
                        double NPrimeM = NPrime * Basis(j, m_dwOrderU, u);
                        const BYTE *B = pCol;
                        for(unsigned e = 0; e < 3; ++e)
                        {
                            Acc[0][e] += double(B[e]) * NMPrime;
                            Acc[1][e] += double(B[e]) * NPrimeM;
                        }
                        pCol += dwStride;
                    }
                    pRow += dwPitch;
                }
                ((FLOAT*)Q)[0] = FLOAT(Acc[0][1] * Acc[1][2] - Acc[0][2] * Acc[1][1]);
                ((FLOAT*)Q)[1] = FLOAT(Acc[0][2] * Acc[1][0] - Acc[0][0] * Acc[1][2]);
                ((FLOAT*)Q)[2] = FLOAT(Acc[0][0] * Acc[1][1] - Acc[0][1] * Acc[1][0]);
            }
            break;
        case D3DVSDT_SHORT4:
            {
                for(unsigned i = 0; i < m_dwHeight; ++i)
                {
                    double N      = Basis(i, m_dwOrderV, v);
                    double NPrime = BasisPrime(i, m_dwOrderV, v);
                    const BYTE *pCol = pRow;
                    for(unsigned j = 0; j < m_dwWidth; ++j)
                    {
                        double NMPrime = N      * BasisPrime(j, m_dwOrderU, u);
                        double NPrimeM = NPrime * Basis(j, m_dwOrderU, u);
                        const SHORT *B = (SHORT*)pCol;
                        for(unsigned e = 0; e < 3; ++e)
                        {
                            Acc[0][e] += double(B[e]) * NMPrime;
                            Acc[1][e] += double(B[e]) * NPrimeM;
                        }
                        pCol += dwStride;
                    }
                    pRow += dwPitch;
                }
                ((FLOAT*)Q)[0] = FLOAT(Acc[0][1] * Acc[1][2] - Acc[0][2] * Acc[1][1]);
                ((FLOAT*)Q)[1] = FLOAT(Acc[0][2] * Acc[1][0] - Acc[0][0] * Acc[1][2]);
                ((FLOAT*)Q)[2] = FLOAT(Acc[0][0] * Acc[1][1] - Acc[0][1] * Acc[1][0]);
            }
            break;
        case D3DVSDT_SHORT2:
        case D3DVSDT_FLOAT2:
        case D3DVSDT_FLOAT1:
        default:
            _ASSERT(FALSE, "Ununderstood vertex element data type");
    }
}

//-----------------------------------------------------------------------------
// RDBSpline::SampleDegenerateNormal
//-----------------------------------------------------------------------------
void RDBSpline::SampleDegenerateNormal(DWORD dwDataType, const BYTE *pRow, DWORD dwStride, DWORD dwPitch, BYTE *Q) const
{
    double Acc[2][3] = {{0.0, 0.0, 0.0}, {0.0, 0.0, 0.0}};
    switch(dwDataType)
    {
        case D3DVSDT_FLOAT4:
        case D3DVSDT_FLOAT3:
            {
                for(unsigned i = 0; i < m_dwHeight; ++i)
                {
                    double JPrime = BasisPrime(i, m_dwOrderV, 0.0);
                    const FLOAT *B1 = (FLOAT*)pRow;
                    const FLOAT *B2 = (FLOAT*)(pRow + (m_dwWidth - 1) * dwStride);
                    for(unsigned e = 0; e < 3; ++e)
                    {
                        Acc[0][e] += double(B2[e]) * JPrime;
                        Acc[1][e] += double(B1[e]) * JPrime;
                    }
                    pRow += dwPitch;
                }
                ((FLOAT*)Q)[0] = FLOAT(Acc[0][1] * Acc[1][2] - Acc[0][2] * Acc[1][1]);
                ((FLOAT*)Q)[1] = FLOAT(Acc[0][2] * Acc[1][0] - Acc[0][0] * Acc[1][2]);
                ((FLOAT*)Q)[2] = FLOAT(Acc[0][0] * Acc[1][1] - Acc[0][1] * Acc[1][0]);
            }
            break;
        case D3DVSDT_D3DCOLOR:
        case D3DVSDT_UBYTE4:
            {
                for(unsigned i = 0; i < m_dwHeight; ++i)
                {
                    double JPrime = BasisPrime(i, m_dwOrderV, 0.0);
                    const BYTE *B1 = pRow;
                    const BYTE *B2 = pRow + (m_dwWidth - 1) * dwStride;
                    for(unsigned e = 0; e < 3; ++e)
                    {
                        Acc[0][e] += double(B2[e]) * JPrime;
                        Acc[1][e] += double(B1[e]) * JPrime;
                    }
                    pRow += dwPitch;
                }
                ((FLOAT*)Q)[0] = FLOAT(Acc[0][1] * Acc[1][2] - Acc[0][2] * Acc[1][1]);
                ((FLOAT*)Q)[1] = FLOAT(Acc[0][2] * Acc[1][0] - Acc[0][0] * Acc[1][2]);
                ((FLOAT*)Q)[2] = FLOAT(Acc[0][0] * Acc[1][1] - Acc[0][1] * Acc[1][0]);
            }
            break;
        case D3DVSDT_SHORT4:
            {
                for(unsigned i = 0; i < m_dwHeight; ++i)
                {
                    double JPrime = BasisPrime(i, m_dwOrderV, 0.0);
                    const SHORT *B1 = (SHORT*)pRow;
                    const SHORT *B2 = (SHORT*)(pRow + (m_dwWidth - 1) * dwStride);
                    for(unsigned e = 0; e < 3; ++e)
                    {
                        Acc[0][e] += double(B2[e]) * JPrime;
                        Acc[1][e] += double(B1[e]) * JPrime;
                    }
                    pRow += dwPitch;
                }
                ((FLOAT*)Q)[0] = FLOAT(Acc[0][1] * Acc[1][2] - Acc[0][2] * Acc[1][1]);
                ((FLOAT*)Q)[1] = FLOAT(Acc[0][2] * Acc[1][0] - Acc[0][0] * Acc[1][2]);
                ((FLOAT*)Q)[2] = FLOAT(Acc[0][0] * Acc[1][1] - Acc[0][1] * Acc[1][0]);
            }
            break;
        case D3DVSDT_FLOAT2:
        case D3DVSDT_FLOAT1:
        case D3DVSDT_SHORT2:
        default:
            _ASSERT(FALSE, "Ununderstood vertex element data type");
    }
}

//-----------------------------------------------------------------------------
// RDBSpline::Basis
//-----------------------------------------------------------------------------
double RDBSpline::Basis(unsigned i, unsigned k, double s) const
{
    if(k == 1)
    {
        if(Knot(i) <= s && s < Knot(i + 1))
        {
            return 1.0;
        }
        else
        {
            return 0.0;
        }
    }
    else
    {
        _ASSERT(k != 0, "Arithmatic error in RDBSpline::Basis");
        return ((s - Knot(i)) * Basis(i, k - 1, s)) / (Knot(i + k - 1) - Knot(i)) + 
               ((Knot(i + k) - s) * Basis(i + 1, k - 1, s)) / (Knot(i + k) - Knot(i + 1));
    }
}

//-----------------------------------------------------------------------------
// RDBSpline::BasisPrime
//-----------------------------------------------------------------------------
double RDBSpline::BasisPrime(unsigned i, unsigned k, double s) const
{
    if(k == 1)
    {
        return 0.0;
    }
    else
    {
        _ASSERT(k != 0, "Arithmatic error in RDBSpline::BasisPrime");
        return (Basis(i, k - 1, s) + (s - Knot(i)) * BasisPrime(i, k - 1, s)) / (Knot(i + k - 1) - Knot(i)) + 
               ((Knot(i + k) - s) * BasisPrime(i + 1, k - 1, s) - Basis(i + 1, k - 1, s)) / (Knot(i + k) - Knot(i + 1));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\hop\catrom.hpp ===
/*============================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       catrom.hpp
 *  Content:    Declarations for Catmull-Rom splines
 *
 ****************************************************************************/

#ifndef _CATROM_HPP
#define _CATROM_HPP

#include "bspline.hpp"

class RDCatRomSpline : public RDBSpline
{
public:
    RDCatRomSpline() : RDBSpline(4, 4, 4, 4) {}

    double TexCoordU(double u) const;
    double TexCoordV(double v) const;

private:
    virtual double Basis(unsigned i, unsigned n, double t) const;
    virtual double BasisPrime(unsigned i, unsigned n, double t) const;
};

#endif // _CATROM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\hop\bspline.hpp ===
/*============================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       bspline.hpp
 *  Content:    Declarations for B-Splines
 *
 ****************************************************************************/

#ifndef _BSPLINE_HPP
#define _BSPLINE_HPP

class RDBSpline 
{
public:
    RDBSpline(DWORD dwWidth, DWORD dwHeight, DWORD dwOrderU, DWORD dwOrderV)
    {
        m_dwWidth = dwWidth;
        m_dwHeight = dwHeight;
        m_dwOrderU = dwOrderU;
        m_dwOrderV = dwOrderV;
    }

    void Sample(DWORD dwDataType, double u, double v, const BYTE *B, DWORD dwStride, DWORD dwPitch, BYTE *Q) const;
    void SampleNormal(DWORD dwDataType, double u, double v, const BYTE *pRow, DWORD dwStride, DWORD dwPitch, BYTE *Q) const;
    void SampleDegenerateNormal(DWORD dwDataType, const BYTE *pRow, DWORD dwStride, DWORD dwPitch, BYTE *Q) const;

    double TexCoordU(double u) const
    {
        return (u - double(m_dwOrderU - 1)) / double(m_dwWidth - (m_dwOrderU - 1));
    }
    double TexCoordV(double v) const
    {
        return (v - double(m_dwOrderV - 1)) / double(m_dwHeight - (m_dwOrderV - 1));
    }

protected:
    virtual double Basis(unsigned i, unsigned k, double s) const;
    virtual double BasisPrime(unsigned i, unsigned k, double s) const;

private:
    DWORD m_dwWidth, m_dwHeight, m_dwOrderU, m_dwOrderV;

    double Knot(unsigned i) const { return double(i); }
};

#endif // _BSPLINE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\hop\drawgrid.cpp ===
/*============================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       drawgrid.cpp
 *  Content:    Implementation for high order surfaces
 *
 ****************************************************************************/

#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
// RDHOCoeffs::operator=
//-----------------------------------------------------------------------------
RDHOCoeffs& RDHOCoeffs::operator=(const RDHOCoeffs &coeffs)
{
    m_Width  = coeffs.m_Width;
    m_Height = coeffs.m_Height;
    m_Stride = coeffs.m_Stride;
    m_Basis  = coeffs.m_Basis;
    m_Order  = coeffs.m_Order;
    if(coeffs.m_pNumSegs != 0)
    {
        m_pNumSegs = new FLOAT[4];
        if(m_pNumSegs != 0)
        {
            memcpy(m_pNumSegs, coeffs.m_pNumSegs, sizeof(FLOAT) * 4);
        }
    }
    else
    {
        m_pNumSegs = 0;
    }
    for(unsigned i = 0; i < RD_MAX_NUMSTREAMS; ++i)
    {
        if(coeffs.m_pData[i] != 0)
        {
            m_DataSize[i] = coeffs.m_DataSize[i];
            m_pData[i] = new BYTE[m_DataSize[i]];
            if(m_pData[i] != 0)
            {
                memcpy(m_pData[i], coeffs.m_pData[i], m_DataSize[i]);
            }
        }
        else
        {
            m_pData[i] = 0;
        }
    }
    return *this;
}

//-----------------------------------------------------------------------------
// RefDev::DrawRectPatch
//-----------------------------------------------------------------------------
HRESULT 
RefDev::DrawRectPatch( LPD3DHAL_DP2DRAWRECTPATCH pDP )
{
    HRESULT hr = S_OK;
    
    if( RDVSD_ISLEGACY( m_CurrentVShaderHandle ) )
    {
        //
        // The legacy FVF style: The Zero'th Stream is implied
        //
        DWORD dwFVF    = m_CurrentVShaderHandle;
        RDVStream& Stream = m_VStream[0];
        DWORD dwStride = Stream.m_dwStride;
        DWORD dwFVFSize = GetFVFVertexSize( dwFVF );

        if( Stream.m_pData == NULL || dwStride == 0 )
        {
            DPFERR("Zero'th stream doesnt have valid VB set");
            return DDERR_INVALIDPARAMS;
        }
        if( dwStride < dwFVFSize )
        {
            DPFERR("The stride set for the vertex stream is less than the FVF vertex size");
            return E_FAIL;
        }        
    }

    FLOAT *pSegs;
    D3DRECTPATCH_INFO Info, *pInfo;
    BYTE *TempData[RD_MAX_NUMSTREAMS + 1];

    if(pDP->Handle != 0)
    {
        if((pDP->Flags & RTPATCHFLAG_HASINFO) != 0) // Is either a first time or a recompute
        {
            HR_RET( m_HOSCoeffs.Grow(pDP->Handle) );

            if((pDP->Flags & RTPATCHFLAG_HASSEGS) != 0)
            {
                pInfo = (D3DRECTPATCH_INFO*)(((BYTE*)(pDP + 1) + sizeof(FLOAT) * 4));
                pSegs = (FLOAT*)(pDP + 1);
            }
            else
            {
                pInfo = (D3DRECTPATCH_INFO*)(pDP + 1);
                pSegs = 0;
            }

            RDHOCoeffs &coeffs = m_HOSCoeffs[pDP->Handle];
            coeffs.m_Width  = pInfo->Width;
            coeffs.m_Height = pInfo->Height;
            coeffs.m_Stride = pInfo->Width;
            coeffs.m_Basis  = pInfo->Basis;
            coeffs.m_Order  = pInfo->Order;

            delete[] coeffs.m_pNumSegs;
            if(pSegs != 0)
            {
                coeffs.m_pNumSegs = new FLOAT[4];
                if(coeffs.m_pNumSegs == 0)
                {
                    return E_OUTOFMEMORY;
                }
                memcpy(coeffs.m_pNumSegs, pSegs, sizeof(FLOAT) * 4);
            }
            else
            {
                coeffs.m_pNumSegs = 0;
            }

            RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;
            for(unsigned i = 0; i < Decl.m_dwNumActiveStreams; ++i) 
            {
                RDVStreamDecl &StreamDecl = Decl.m_StreamArray[i];
                if(StreamDecl.m_dwStreamIndex < RD_MAX_NUMSTREAMS) // ignore the implicit stream
                {
                    RDVStream &Stream = m_VStream[StreamDecl.m_dwStreamIndex];
                    delete[] coeffs.m_pData[StreamDecl.m_dwStreamIndex];
                    coeffs.m_DataSize[StreamDecl.m_dwStreamIndex] = pInfo->Width * pInfo->Height * Stream.m_dwStride;
                    coeffs.m_pData[StreamDecl.m_dwStreamIndex] = new BYTE[coeffs.m_DataSize[StreamDecl.m_dwStreamIndex]];
                    if(coeffs.m_pData[StreamDecl.m_dwStreamIndex] == 0)
                    {
                        return E_OUTOFMEMORY;
                    }
                    for(unsigned k = 0; k < pInfo->Height; ++k)
                    {
                        memcpy(&coeffs.m_pData[StreamDecl.m_dwStreamIndex][k * pInfo->Width * Stream.m_dwStride],
                               &Stream.m_pData[((pInfo->StartVertexOffsetHeight + k) * pInfo->Stride + pInfo->StartVertexOffsetWidth) * Stream.m_dwStride],
                               pInfo->Width * Stream.m_dwStride);
                    }
                }
            }
        }

        // Guard against bad handles
        if(pDP->Handle >= m_HOSCoeffs.GetSize())
        {
            DPFERR("Invalid patch handle specified in Draw*Patch call");
            return E_FAIL;
        }

        RDHOCoeffs &coeffs = m_HOSCoeffs[pDP->Handle];
        Info.StartVertexOffsetWidth  = 0;
        Info.StartVertexOffsetHeight = 0;
        Info.Width                   = coeffs.m_Width;
        Info.Height                  = coeffs.m_Height;
        Info.Stride                  = coeffs.m_Stride;
        Info.Basis                   = coeffs.m_Basis;
        Info.Order                   = coeffs.m_Order;
        pInfo = &Info;

        if((pDP->Flags & RTPATCHFLAG_HASSEGS) != 0)
        {
            pSegs = (FLOAT*)(pDP + 1);
        }
        else
        {
            pSegs = coeffs.m_pNumSegs;
        }
        
        // Save current data stream pointers and replace with 
        // pointer to tessellation output
        hr = LinkCachedTessellatorOutput(pDP->Handle, TempData);
    }
    else
    {
        if((pDP->Flags & RTPATCHFLAG_HASINFO) == 0)
        {
            DPFERR("Need patch info if handle is zero");
            return DDERR_INVALIDPARAMS;
        }
        
        if((pDP->Flags & RTPATCHFLAG_HASSEGS) != 0)
        {
            pInfo = (D3DRECTPATCH_INFO*)(((BYTE*)(pDP + 1) + sizeof(FLOAT) * 4));
            pSegs = (FLOAT*)(pDP + 1);
        }
        else
        {
            pInfo = (D3DRECTPATCH_INFO*)(pDP + 1);
            pSegs = 0;
        }

        // Save current data stream pointers and replace with 
        // pointer to tessellation output
        hr = LinkTessellatorOutput();
    }

    if( SUCCEEDED(hr) )
    {
        switch(pInfo->Basis)
        {
        case D3DBASIS_BSPLINE:
            hr = ProcessBSpline(pInfo->StartVertexOffsetWidth, pInfo->StartVertexOffsetHeight,
                                pInfo->Width, pInfo->Height,
                                pInfo->Stride, pInfo->Order,
                                pSegs);
            break;
        case D3DBASIS_BEZIER:
            hr = ProcessBezier(pInfo->StartVertexOffsetWidth, pInfo->StartVertexOffsetHeight,
                               pInfo->Width, pInfo->Height,
                               pInfo->Stride, pInfo->Order,
                               pSegs,
                               false);
            break;
        case D3DBASIS_INTERPOLATE:
            hr = ProcessCatRomSpline(pInfo->StartVertexOffsetWidth, pInfo->StartVertexOffsetHeight,
                                     pInfo->Width, pInfo->Height,
                                     pInfo->Stride,
                                     pSegs);
            break;
        default:
            hr = E_NOTIMPL;
        }
    }

    if(pDP->Handle != 0)
    {
        // Restore back saved pointer
        UnlinkCachedTessellatorOutput(TempData);
    }
    else
    {
        // Restore back saved pointer
        UnlinkTessellatorOutput();
    }
    
    return hr;
}

//-----------------------------------------------------------------------------
// RefDev::ConvertLinearTriBezierToRectBezier
//-----------------------------------------------------------------------------
HRESULT
RefDev::ConvertLinearTriBezierToRectBezier(DWORD dwDataType, const BYTE *B, DWORD dwStride, BYTE *Q)
{
    DWORD dwElements = 0;
    switch(dwDataType)
    {
    case D3DVSDT_FLOAT4:
        ++dwElements;
    case D3DVSDT_FLOAT3:
        ++dwElements;
    case D3DVSDT_FLOAT2:
        ++dwElements;
    case D3DVSDT_FLOAT1:
        ++dwElements;
        {
            // Replicate first point twice to get a singular edge
            for(unsigned i = 0; i < 2; ++i)
            {
                memcpy(Q, B, sizeof(FLOAT) * dwElements);
                Q += dwStride;
            }
            B += dwStride;

            // Finally we just copy the last row
            for(i = 0; i < 2; ++i)
            {
                memcpy(Q, B, sizeof(FLOAT) * dwElements);
                Q += dwStride;
                B += dwStride;
            }
        }
        break;
    case D3DVSDT_D3DCOLOR:
    case D3DVSDT_UBYTE4:
        dwElements = 4;
        {
            // Replicate first point twice to get a singular edge
            for(unsigned i = 0; i < 2; ++i)
            {
                memcpy(Q, B, sizeof(BYTE) * dwElements);
                Q += dwStride;
            }
            B += dwStride;

            // Finally we just copy the last row
            for(i = 0; i < 2; ++i)
            {
                memcpy(Q, B, sizeof(BYTE) * dwElements);
                Q += dwStride;
                B += dwStride;
            }
        }
        break;
    case D3DVSDT_SHORT4:
        dwElements += 2;
    case D3DVSDT_SHORT2:
        dwElements += 2;
        {
            // Replicate first point twice to get a singular edge
            for(unsigned i = 0; i < 2; ++i)
            {
                memcpy(Q, B, sizeof(SHORT) * dwElements);
                Q += dwStride;
            }
            B += dwStride;

            // Finally we just copy the last row
            for(i = 0; i < 2; ++i)
            {
                memcpy(Q, B, sizeof(SHORT) * dwElements);
                Q += dwStride;
                B += dwStride;
            }
        }
        break;
    default:
        _ASSERT(FALSE, "Ununderstood vertex element data type");
        return DDERR_INVALIDPARAMS;
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
// RefDev::ConvertCubicTriBezierToRectBezier
//-----------------------------------------------------------------------------
HRESULT
RefDev::ConvertCubicTriBezierToRectBezier(DWORD dwDataType, const BYTE *B, DWORD dwStride, BYTE *Q)
{
    DWORD dwElements = 0;
    switch(dwDataType)
    {
    case D3DVSDT_FLOAT4:
        ++dwElements;
    case D3DVSDT_FLOAT3:
        ++dwElements;
    case D3DVSDT_FLOAT2:
        ++dwElements;
    case D3DVSDT_FLOAT1:
        ++dwElements;
        {
            // Replicate first point four times to get a singular edge
            for(unsigned i = 0; i < 4; ++i)
            {
                memcpy(Q, B, sizeof(FLOAT) * dwElements);
                Q += dwStride;
            }
            B += dwStride;

            // For the next row, we simply copy the second point
            // followed by two interpolated control points
            // followed by the third point
            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            
            FLOAT *B021 = (FLOAT*)B, *B120 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B021[i] * 2.0 + B120[i]) / 3.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B021[i] + B120[i] * 2.0) / 3.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            
            FLOAT *B012 = (FLOAT*)B, *B111 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B012[i] + B111[i] * 2.0) / 3.0);
            }
            Q += dwStride;
            B += dwStride;

            FLOAT *B210 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B111[i] * 2.0 + B210[i]) / 3.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Finally we just copy the last row
            for(i = 0; i < 4; ++i)
            {
                memcpy(Q, B, sizeof(FLOAT) * dwElements);
                Q += dwStride;
                B += dwStride;
            }
        }
        break;
    case D3DVSDT_D3DCOLOR:
    case D3DVSDT_UBYTE4:
        dwElements = 4;
        {
            // Replicate first point four times to get a singular edge
            for(unsigned i = 0; i < 4; ++i)
            {
                memcpy(Q, B, sizeof(BYTE) * dwElements);
                Q += dwStride;
            }
            B += dwStride;

            // For the next row, we simply copy the second point
            // followed by two interpolated control points
            // followed by the third point
            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            
            BYTE *B021 = (BYTE*)B, *B120 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B021[i] * 2.0 + B120[i]) / 3.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B021[i] + B120[i] * 2.0) / 3.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            
            BYTE *B012 = (BYTE*)B, *B111 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B012[i] + B111[i] * 2.0) / 3.0);
            }
            Q += dwStride;
            B += dwStride;

            BYTE *B210 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B111[i] * 2.0 + B210[i]) / 3.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Finally we just copy the last row
            for(i = 0; i < 4; ++i)
            {
                memcpy(Q, B, sizeof(BYTE) * dwElements);
                Q += dwStride;
                B += dwStride;
            }
        }
        break;
    case D3DVSDT_SHORT4:
        dwElements += 2;
    case D3DVSDT_SHORT2:
        dwElements += 2;
        {
            // Replicate first point four times to get a singular edge
            for(unsigned i = 0; i < 4; ++i)
            {
                memcpy(Q, B, sizeof(SHORT) * dwElements);
                Q += dwStride;
            }
            B += dwStride;

            // For the next row, we simply copy the second point
            // followed by two interpolated control points
            // followed by the third point
            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            
            SHORT *B021 = (SHORT*)B, *B120 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B021[i] * 2.0 + B120[i]) / 3.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B021[i] + B120[i] * 2.0) / 3.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            
            SHORT *B012 = (SHORT*)B, *B111 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B012[i] + B111[i] * 2.0) / 3.0);
            }
            Q += dwStride;
            B += dwStride;

            SHORT *B210 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B111[i] * 2.0 + B210[i]) / 3.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Finally we just copy the last row
            for(i = 0; i < 4; ++i)
            {
                memcpy(Q, B, sizeof(SHORT) * dwElements);
                Q += dwStride;
                B += dwStride;
            }
        }
        break;
    default:
        _ASSERT(FALSE, "Ununderstood vertex element data type");
        return DDERR_INVALIDPARAMS;
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
// RefDev::ConvertQuinticTriBezierToRectBezier
//-----------------------------------------------------------------------------
HRESULT
RefDev::ConvertQuinticTriBezierToRectBezier(DWORD dwDataType, const BYTE *B, DWORD dwStride, BYTE *Q)
{
    DWORD dwElements = 0;
    switch(dwDataType)
    {
    case D3DVSDT_FLOAT4:
        ++dwElements;
    case D3DVSDT_FLOAT3:
        ++dwElements;
    case D3DVSDT_FLOAT2:
        ++dwElements;
    case D3DVSDT_FLOAT1:
        ++dwElements;
        {
            // Replicate first point six times to get a singular edge
            for(unsigned i = 0; i < 6; ++i)
            {
                memcpy(Q, B, sizeof(FLOAT) * dwElements);
                Q += dwStride;
            }
            B += dwStride;

            // For the next row, we simply copy the second point
            // followed by four interpolated control points
            // followed by the fifth point
            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            
            FLOAT *B041 = (FLOAT*)B, *B140 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B041[i] * 4.0 + B140[i]) / 5.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B041[i] * 3.0 + B140[i] * 2.0) / 5.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B041[i] * 2.0 + B140[i] * 3.0) / 5.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B041[i] + B140[i] * 4.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            
            FLOAT *B032 = (FLOAT*)B, *B131 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B032[i] * 3.0 + B131[i] * 2.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            FLOAT *B230 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B032[i] * 3.0 + B131[i] * 6.0 + B230[i]) / 10.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B032[i] + B131[i] * 6.0 + B230[i] * 3.0) / 10.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B131[i] * 2.0 + B230[i] * 3.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            
            FLOAT *B023 = (FLOAT*)B, *B122 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B023[i] * 2.0 + B122[i] * 3.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            FLOAT *B221 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B023[i] + B122[i] * 6.0 + B221[i] * 3.0) / 10.0);
            }
            Q += dwStride;
            B += dwStride;

            FLOAT *B320 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B122[i] * 3.0 + B221[i] * 6.0 + B320[i]) / 10.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B221[i] * 3.0 + B320[i] * 2.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            
            FLOAT *B014 = (FLOAT*)B, *B113 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B014[i] + B113[i] * 4.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            FLOAT *B212 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B113[i] * 2.0 + B212[i] * 3.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            FLOAT *B311 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B212[i] * 3.0 + B311[i] * 2.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            FLOAT *B410 = (FLOAT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((FLOAT*)Q)[i] = FLOAT((B311[i] * 4.0 + B410[i]) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(FLOAT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Finally we just copy the last row
            for(i = 0; i < 6; ++i)
            {
                memcpy(Q, B, sizeof(FLOAT) * dwElements);
                Q += dwStride;
                B += dwStride;
            }
        }
        break;
    case D3DVSDT_UBYTE4:
    case D3DVSDT_D3DCOLOR:
        dwElements = 4;
        {
            // Replicate first point six times to get a singular edge
            for(unsigned i = 0; i < 6; ++i)
            {
                memcpy(Q, B, sizeof(BYTE) * dwElements);
                Q += dwStride;
            }
            B += dwStride;

            // For the next row, we simply copy the second point
            // followed by four interpolated control points
            // followed by the fifth point
            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            
            BYTE *B041 = (BYTE*)B, *B140 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B041[i] * 4.0 + B140[i]) / 5.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B041[i] * 3.0 + B140[i] * 2.0) / 5.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B041[i] * 2.0 + B140[i] * 3.0) / 5.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B041[i] + B140[i] * 4.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            
            BYTE *B032 = (BYTE*)B, *B131 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B032[i] * 3.0 + B131[i] * 2.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            BYTE *B230 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B032[i] * 3.0 + B131[i] * 6.0 + B230[i]) / 10.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B032[i] + B131[i] * 6.0 + B230[i] * 3.0) / 10.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B131[i] * 2.0 + B230[i] * 3.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            
            BYTE *B023 = (BYTE*)B, *B122 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B023[i] * 2.0 + B122[i] * 3.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            BYTE *B221 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B023[i] + B122[i] * 6.0 + B221[i] * 3.0) / 10.0);
            }
            Q += dwStride;
            B += dwStride;

            BYTE *B320 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B122[i] * 3.0 + B221[i] * 6.0 + B320[i]) / 10.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B221[i] * 3.0 + B320[i] * 2.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            
            BYTE *B014 = (BYTE*)B, *B113 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B014[i] + B113[i] * 4.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            BYTE *B212 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B113[i] * 2.0 + B212[i] * 3.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            BYTE *B311 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B212[i] * 3.0 + B311[i] * 2.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            BYTE *B410 = (BYTE*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((BYTE*)Q)[i] = BYTE((B311[i] * 4.0 + B410[i]) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(BYTE) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Finally we just copy the last row
            for(i = 0; i < 6; ++i)
            {
                memcpy(Q, B, sizeof(BYTE) * dwElements);
                Q += dwStride;
                B += dwStride;
            }
        }
        break;
    case D3DVSDT_SHORT4:
        dwElements += 2;
    case D3DVSDT_SHORT2:
        dwElements += 2;
        {
            // Replicate first point six times to get a singular edge
            for(unsigned i = 0; i < 6; ++i)
            {
                memcpy(Q, B, sizeof(SHORT) * dwElements);
                Q += dwStride;
            }
            B += dwStride;

            // For the next row, we simply copy the second point
            // followed by four interpolated control points
            // followed by the fifth point
            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            
            SHORT *B041 = (SHORT*)B, *B140 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B041[i] * 4.0 + B140[i]) / 5.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B041[i] * 3.0 + B140[i] * 2.0) / 5.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B041[i] * 2.0 + B140[i] * 3.0) / 5.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B041[i] + B140[i] * 4.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            
            SHORT *B032 = (SHORT*)B, *B131 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B032[i] * 3.0 + B131[i] * 2.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            SHORT *B230 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B032[i] * 3.0 + B131[i] * 6.0 + B230[i]) / 10.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B032[i] + B131[i] * 6.0 + B230[i] * 3.0) / 10.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B131[i] * 2.0 + B230[i] * 3.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            
            SHORT *B023 = (SHORT*)B, *B122 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B023[i] * 2.0 + B122[i] * 3.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            SHORT *B221 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B023[i] + B122[i] * 6.0 + B221[i] * 3.0) / 10.0);
            }
            Q += dwStride;
            B += dwStride;

            SHORT *B320 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B122[i] * 3.0 + B221[i] * 6.0 + B320[i]) / 10.0);
            }
            Q += dwStride;

            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B221[i] * 3.0 + B320[i] * 2.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Again, we copy the edge points and interpolate
            // the central ones
            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            
            SHORT *B014 = (SHORT*)B, *B113 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B014[i] + B113[i] * 4.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            SHORT *B212 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B113[i] * 2.0 + B212[i] * 3.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            SHORT *B311 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B212[i] * 3.0 + B311[i] * 2.0) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            SHORT *B410 = (SHORT*)(B + dwStride);
            for(i = 0; i < dwElements; ++i)
            {
                ((SHORT*)Q)[i] = SHORT((B311[i] * 4.0 + B410[i]) / 5.0);
            }
            Q += dwStride;
            B += dwStride;

            memcpy(Q, B, sizeof(SHORT) * dwElements);
            Q += dwStride;
            B += dwStride;

            // Finally we just copy the last row
            for(i = 0; i < 6; ++i)
            {
                memcpy(Q, B, sizeof(SHORT) * dwElements);
                Q += dwStride;
                B += dwStride;
            }
        }
        break;
    default:
        _ASSERT(FALSE, "Ununderstood vertex element data type");
        return DDERR_INVALIDPARAMS;
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
// RefDev::DrawTriPatch
//-----------------------------------------------------------------------------
HRESULT 
RefDev::DrawTriPatch( LPD3DHAL_DP2DRAWTRIPATCH pDP )
{
    HRESULT hr = S_OK;
    
    if( RDVSD_ISLEGACY( m_CurrentVShaderHandle ) )
    {
        //
        // The legacy FVF style: The Zero'th Stream is implied
        //
        DWORD dwFVF    = m_CurrentVShaderHandle;
        RDVStream& Stream = m_VStream[0];
        DWORD dwStride = Stream.m_dwStride;
        DWORD dwFVFSize = GetFVFVertexSize( dwFVF );

        if( Stream.m_pData == NULL || dwStride == 0 )
        {
            DPFERR("Zero'th stream doesnt have valid VB set");
            return DDERR_INVALIDPARAMS;
        }
        if( dwStride < dwFVFSize )
        {
            DPFERR("The stride set for the vertex stream is less than the FVF vertex size");
            return E_FAIL;
        }        
    }

    FLOAT *pSegs;
    D3DRECTPATCH_INFO Info;
    BYTE *TempData[RD_MAX_NUMSTREAMS + 1];

    if(pDP->Handle == 0 && (pDP->Flags & RTPATCHFLAG_HASINFO) == 0)
    {
        DPFERR("Need patch info if handle is zero");
        return DDERR_INVALIDPARAMS;
    }

    if((pDP->Flags & RTPATCHFLAG_HASINFO) != 0) // Is either a first time or a recompute
    {
        HR_RET( m_HOSCoeffs.Grow(pDP->Handle) );

        D3DTRIPATCH_INFO *pInfo;
        if((pDP->Flags & RTPATCHFLAG_HASSEGS) != 0)
        {
            pInfo = (D3DTRIPATCH_INFO*)(((BYTE*)(pDP + 1) + sizeof(FLOAT) * 3));
            pSegs = (FLOAT*)(pDP + 1);
        }
        else
        {
            pInfo = (D3DTRIPATCH_INFO*)(pDP + 1);
            pSegs = 0;
        }

        RDHOCoeffs &coeffs = m_HOSCoeffs[pDP->Handle];
        coeffs.m_Width  = (DWORD)pInfo->Order + 1;
        coeffs.m_Height = (DWORD)pInfo->Order + 1;
        coeffs.m_Stride = (DWORD)pInfo->Order + 1;
        coeffs.m_Basis  = pInfo->Basis;
        coeffs.m_Order  = pInfo->Order;

        delete[] coeffs.m_pNumSegs;
        if(pSegs != 0)
        {
            coeffs.m_pNumSegs = new FLOAT[4];
            if(coeffs.m_pNumSegs == 0)
            {
                return E_OUTOFMEMORY;
            }
            coeffs.m_pNumSegs[0] = pSegs[2];
            memcpy(&coeffs.m_pNumSegs[1], pSegs, sizeof(FLOAT) * 3);
        }
        else
        {
            coeffs.m_pNumSegs = 0;
        }

        RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;

        // Allocate memory to hold rect patches rather than tri patches
        for(unsigned i = 0; i < Decl.m_dwNumActiveStreams; ++i) 
        {
            RDVStreamDecl &StreamDecl = Decl.m_StreamArray[i];
            if(StreamDecl.m_dwStreamIndex < RD_MAX_NUMSTREAMS) // ignore the implicit stream
            {
                RDVStream &Stream = m_VStream[StreamDecl.m_dwStreamIndex];
                delete[] coeffs.m_pData[StreamDecl.m_dwStreamIndex];
                coeffs.m_DataSize[StreamDecl.m_dwStreamIndex] = coeffs.m_Width * coeffs.m_Height * Stream.m_dwStride;
                coeffs.m_pData[StreamDecl.m_dwStreamIndex] = new BYTE[coeffs.m_DataSize[StreamDecl.m_dwStreamIndex]];
                if(coeffs.m_pData[StreamDecl.m_dwStreamIndex] == 0)
                {
                    return E_OUTOFMEMORY;
                }
            }
        }

        // Now go through tri patch data, convert it to rect patch and store it in
        // in the space that we allocated above
        for(unsigned e = 0; e < Decl.m_dwNumElements; ++e)
        {
            RDVElement &velem = Decl.m_VertexElements[e];
            if(!velem.m_bIsTessGen)
            {
                RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
                LPBYTE Q = coeffs.m_pData[velem.m_dwStreamIndex] + velem.m_dwOffset;
                LPBYTE B = vstream.m_pData + pInfo->StartVertexOffset * vstream.m_dwStride + velem.m_dwOffset;
                if(pInfo->Order == D3DORDER_LINEAR)
                {
                    hr = ConvertLinearTriBezierToRectBezier(velem.m_dwDataType, B, vstream.m_dwStride, Q);
                    if(FAILED(hr))
                    {
                        DPFERR("Conversion from Linear Tri Patch to Rect Patch failed");
                        return E_FAIL;
                    }
                }
                else if(pInfo->Order == D3DORDER_CUBIC)
                {
                    hr = ConvertCubicTriBezierToRectBezier(velem.m_dwDataType, B, vstream.m_dwStride, Q);
                    if(FAILED(hr))
                    {
                        DPFERR("Conversion from Cubic Tri Patch to Rect Patch failed");
                        return E_FAIL;
                    }
                }
                else if(pInfo->Order == D3DORDER_QUINTIC)
                {
                    hr = ConvertQuinticTriBezierToRectBezier(velem.m_dwDataType, B, vstream.m_dwStride, Q);
                    if(FAILED(hr))
                    {
                        DPFERR("Conversion from Quintic Tri Patch to Rect Patch failed");
                        return E_FAIL;
                    }
                }
                else
                {
                    DPFERR("Only cubic Bezier patches currently supported");
                    return E_FAIL;
                }
            }
        }
    }

    // Guard against bad handles
    if(pDP->Handle >= m_HOSCoeffs.GetSize())
    {
        DPFERR("Invalid patch handle specified in Draw*Patch call");
        return E_FAIL;
    }

    RDHOCoeffs &coeffs = m_HOSCoeffs[pDP->Handle];
    Info.StartVertexOffsetWidth  = 0;
    Info.StartVertexOffsetHeight = 0;
    Info.Width                   = coeffs.m_Width;
    Info.Height                  = coeffs.m_Height;
    Info.Stride                  = coeffs.m_Stride;
    Info.Basis                   = coeffs.m_Basis;
    Info.Order                   = coeffs.m_Order;
    D3DRECTPATCH_INFO *pInfo = &Info;

    FLOAT Segs[4];
    if((pDP->Flags & RTPATCHFLAG_HASSEGS) != 0)
    {
        Segs[0] = ((FLOAT*)(pDP + 1))[2];
        memcpy(&Segs[1], pDP + 1, sizeof(FLOAT) * 3);
        pSegs = &Segs[0];
    }
    else
    {
        pSegs = coeffs.m_pNumSegs;
    }
    
    // Save current data stream pointers and replace with 
    // pointer to tessellation output
    hr = LinkCachedTessellatorOutput(pDP->Handle, TempData);
    if( SUCCEEDED(hr) )
    {
        switch(pInfo->Basis)
        {
        case D3DBASIS_BEZIER:
            hr = ProcessBezier(pInfo->StartVertexOffsetWidth, pInfo->StartVertexOffsetHeight,
                               pInfo->Width, pInfo->Height,
                               pInfo->Stride, pInfo->Order,
                               pSegs,
                               true);
            break;
        default:
            hr = E_NOTIMPL;
        }
    }

    // Restore back saved pointer
    UnlinkCachedTessellatorOutput(TempData);

    return hr;
}

//---------------------------------------------------------------------
// RefDev::LinkTessellatorOutput
//---------------------------------------------------------------------
HRESULT RefDev::LinkTessellatorOutput()
{
    HRESULT hr = S_OK;
    RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;
    for(unsigned i = 0; i < Decl.m_dwNumActiveStreams; ++i) 
    {
        RDVStreamDecl &StreamDecl = Decl.m_StreamArray[i];
        RDVStream &Stream = m_VStream[StreamDecl.m_dwStreamIndex];
        // Make space for four vertices
        hr |= Stream.m_TessOut.Grow(StreamDecl.m_dwStride * 4);
        Stream.m_pSavedData = Stream.m_pData;
        Stream.m_pData = &Stream.m_TessOut[0];
    }
    return hr;
}

//---------------------------------------------------------------------
// RefDev::LinkCachedTessellatorOutput
//---------------------------------------------------------------------
HRESULT RefDev::LinkCachedTessellatorOutput(DWORD Handle, BYTE **pTempData)
{
    HRESULT hr = S_OK;
    RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;
    for(unsigned i = 0; i < Decl.m_dwNumActiveStreams; ++i) 
    {
        RDVStreamDecl &StreamDecl = Decl.m_StreamArray[i];
        RDVStream &Stream = m_VStream[StreamDecl.m_dwStreamIndex];
        // Make space for four vertices
        hr |= Stream.m_TessOut.Grow(StreamDecl.m_dwStride * 4);
        if(StreamDecl.m_dwStreamIndex < RD_MAX_NUMSTREAMS) // ignore the implicit stream
        {
            Stream.m_pSavedData = m_HOSCoeffs[Handle].m_pData[StreamDecl.m_dwStreamIndex];
            if(Stream.m_pSavedData == 0)
            {
                DPFERR("Deleted or unspecified patch was requested to be drawn");
                hr |= E_FAIL;
            }
        }
        else
        {
            Stream.m_pSavedData = 0;
        }
        pTempData[StreamDecl.m_dwStreamIndex] = Stream.m_pData;
        Stream.m_pData = &Stream.m_TessOut[0];
    }
    return hr;
}

//---------------------------------------------------------------------
// RefDev::UnlinkTessellatorOuput
//---------------------------------------------------------------------
void RefDev::UnlinkTessellatorOutput()
{
    RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;
    for(unsigned i = 0; i < Decl.m_dwNumActiveStreams; ++i) 
    {
        RDVStreamDecl &StreamDecl = Decl.m_StreamArray[i];
        RDVStream &Stream = m_VStream[StreamDecl.m_dwStreamIndex];
        Stream.m_pData = Stream.m_pSavedData;
        Stream.m_pSavedData = NULL;
    }
}

//---------------------------------------------------------------------
// RefDev::UnlinkTessellatorOuput
//---------------------------------------------------------------------
void RefDev::UnlinkCachedTessellatorOutput(BYTE **pTempData)
{
    RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;
    for(unsigned i = 0; i < Decl.m_dwNumActiveStreams; ++i) 
    {
        RDVStreamDecl &StreamDecl = Decl.m_StreamArray[i];
        RDVStream &Stream = m_VStream[StreamDecl.m_dwStreamIndex];
        Stream.m_pData = pTempData[StreamDecl.m_dwStreamIndex];
        Stream.m_pSavedData = NULL;
    }
}

//---------------------------------------------------------------------
// RefDev::DrawTessQuad
//---------------------------------------------------------------------
HRESULT RefDev::DrawTessQuad( const RDBSpline &Surf, DWORD dwOffW, DWORD dwOffH, DWORD dwStride, 
                              const unsigned *m, const unsigned *n, 
                              double u0, double v0, double u1, double v1,
                              double tu0, double tv0, double tu1, double tv1,
                              bool bDegenerate )
{
    RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;
    for(unsigned e = 0; e < Decl.m_dwNumElements; ++e)
    {
        RDVElement &velem = Decl.m_VertexElements[e];
        if(velem.m_bIsTessGen)
        {
            if((velem.m_dwToken & 0x10000000) == 0) // Check if token is D3DVSD_TESSNORMAL
            {
                RDVStream &vstrmin = m_VStream[velem.m_dwStreamIndexIn];
                RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
                LPBYTE Q = &vstream.m_pData[velem.m_dwOffset];
                LPBYTE B = vstrmin.m_pSavedData + ((dwOffH + n[0]) * dwStride + (dwOffW + m[0])) * vstrmin.m_dwStride + velem.m_dwOffsetIn;
                Surf.SampleNormal(velem.m_dwDataType, u0, v0, B, vstrmin.m_dwStride, dwStride * vstrmin.m_dwStride, Q);
                Q += vstream.m_dwStride;
                B = vstrmin.m_pSavedData + ((dwOffH + n[1]) * dwStride + (dwOffW + m[1])) * vstrmin.m_dwStride + velem.m_dwOffsetIn;
                Surf.SampleNormal(velem.m_dwDataType, u1, v0, B, vstrmin.m_dwStride, dwStride * vstrmin.m_dwStride, Q);
                Q += vstream.m_dwStride;
                B = vstrmin.m_pSavedData + ((dwOffH + n[2]) * dwStride + (dwOffW + m[2])) * vstrmin.m_dwStride + velem.m_dwOffsetIn;
                Surf.SampleNormal(velem.m_dwDataType, u1, v1, B, vstrmin.m_dwStride, dwStride * vstrmin.m_dwStride, Q);
                Q += vstream.m_dwStride;
                B = vstrmin.m_pSavedData + ((dwOffH + n[3]) * dwStride + (dwOffW + m[3])) * vstrmin.m_dwStride + velem.m_dwOffsetIn;
                Surf.SampleNormal(velem.m_dwDataType, u0, v1, B, vstrmin.m_dwStride, dwStride * vstrmin.m_dwStride, Q);
            }
            else // it is D3DVSD_TESSUV
            {
                RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
                LPBYTE Q = &vstream.m_pData[velem.m_dwOffset];
                if(bDegenerate)
                {
                    ((FLOAT*)Q)[0] = (FLOAT)(tu0 * tv0);
                    ((FLOAT*)Q)[1] = (FLOAT)tv0;
                }
                else
                {
                    ((FLOAT*)Q)[0] = (FLOAT)tu0;
                    ((FLOAT*)Q)[1] = (FLOAT)tv0;
                }
                Q += vstream.m_dwStride;
                if(bDegenerate)
                {
                    ((FLOAT*)Q)[0] = (FLOAT)(tu1 * tv0);
                    ((FLOAT*)Q)[1] = (FLOAT)tv0;
                }
                else
                {
                    ((FLOAT*)Q)[0] = (FLOAT)tu1;
                    ((FLOAT*)Q)[1] = (FLOAT)tv0;
                }
                Q += vstream.m_dwStride;
                if(bDegenerate)
                {
                    ((FLOAT*)Q)[0] = (FLOAT)(tu1 * tv1);
                    ((FLOAT*)Q)[1] = (FLOAT)tv1;
                }
                else
                {
                    ((FLOAT*)Q)[0] = (FLOAT)tu1;
                    ((FLOAT*)Q)[1] = (FLOAT)tv1;
                }
                Q += vstream.m_dwStride;
                if(bDegenerate)
                {
                    ((FLOAT*)Q)[0] = (FLOAT)(tu0 * tv1);
                    ((FLOAT*)Q)[1] = (FLOAT)tv1;
                }
                else
                {
                    ((FLOAT*)Q)[0] = (FLOAT)tu0;
                    ((FLOAT*)Q)[1] = (FLOAT)tv1;
                }
            }
        }
        else
        {
            RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
            LPBYTE B = vstream.m_pSavedData + ((dwOffH + n[0]) * dwStride + (dwOffW + m[0])) * vstream.m_dwStride + velem.m_dwOffset;
            LPBYTE Q = &vstream.m_pData[velem.m_dwOffset];
            Surf.Sample(velem.m_dwDataType, u0, v0, B, vstream.m_dwStride, dwStride * vstream.m_dwStride, Q);
            Q += vstream.m_dwStride;
            B = vstream.m_pSavedData + ((dwOffH + n[1]) * dwStride + (dwOffW + m[1])) * vstream.m_dwStride + velem.m_dwOffset;
            Surf.Sample(velem.m_dwDataType, u1, v0, B, vstream.m_dwStride, dwStride * vstream.m_dwStride, Q);
            Q += vstream.m_dwStride;
            B = vstream.m_pSavedData + ((dwOffH + n[2]) * dwStride + (dwOffW + m[2])) * vstream.m_dwStride + velem.m_dwOffset;
            Surf.Sample(velem.m_dwDataType, u1, v1, B, vstream.m_dwStride, dwStride * vstream.m_dwStride, Q);
            Q += vstream.m_dwStride;
            B = vstream.m_pSavedData + ((dwOffH + n[3]) * dwStride + (dwOffW + m[3])) * vstream.m_dwStride + velem.m_dwOffset;
            Surf.Sample(velem.m_dwDataType, u0, v1, B, vstream.m_dwStride, dwStride * vstream.m_dwStride, Q);
        }
    }

    HRESULT hr;
    if( m_pCurrentVShader->IsFixedFunction() )
    {
        //
        // With declaration for Fixed Function pipeline, DX8 style
        //
        hr = ProcessPrimitive( D3DPT_TRIANGLEFAN, 0, 4, 0, 0 );
    }
    else
    {
        //
        // Pure Vertex Shader
        //
        hr = ProcessPrimitiveVVM( D3DPT_TRIANGLEFAN, 0, 4, 0, 0 );
    }
    return hr;
}

//---------------------------------------------------------------------
// RefDev::DrawTessTri
//---------------------------------------------------------------------
HRESULT RefDev::DrawTessTri( const RDBSpline &Surf, DWORD dwOffW, DWORD dwOffH, DWORD dwStride, 
                             const unsigned *m, const unsigned *n, 
                             double u0, double v0, double u1, double v1, double u2, double v2,
                             double tu0, double tv0, double tu1, double tv1, double tu2, double tv2,
                             bool bDegenerate0, bool bDegenerate1, bool bDegenerate2 )
{
    RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;
    for(unsigned e = 0; e < Decl.m_dwNumElements; ++e)
    {
        RDVElement &velem = Decl.m_VertexElements[e];
        if(velem.m_bIsTessGen)
        {
            if((velem.m_dwToken & 0x10000000) == 0) // Check if token is D3DVSD_TESSNORMAL
            {
                RDVStream &vstrmin = m_VStream[velem.m_dwStreamIndexIn];
                RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
                LPBYTE Q = &vstream.m_pData[velem.m_dwOffset];
                LPBYTE B = vstrmin.m_pSavedData + ((dwOffH + n[0]) * dwStride + (dwOffW + m[0])) * vstrmin.m_dwStride + velem.m_dwOffsetIn;
                if(bDegenerate0)
                {
                    Surf.SampleDegenerateNormal(velem.m_dwDataType, B, vstrmin.m_dwStride, dwStride * vstrmin.m_dwStride, Q);
                }
                else
                {
                    Surf.SampleNormal(velem.m_dwDataType, u0, v0, B, vstrmin.m_dwStride, dwStride * vstrmin.m_dwStride, Q);
                }
                Q += vstream.m_dwStride;
                B = vstrmin.m_pSavedData + ((dwOffH + n[1]) * dwStride + (dwOffW + m[1])) * vstrmin.m_dwStride + velem.m_dwOffsetIn;
                if(bDegenerate1)
                {
                    Surf.SampleDegenerateNormal(velem.m_dwDataType, B, vstrmin.m_dwStride, dwStride * vstrmin.m_dwStride, Q);
                }
                else
                {
                    Surf.SampleNormal(velem.m_dwDataType, u1, v1, B, vstrmin.m_dwStride, dwStride * vstrmin.m_dwStride, Q);
                }
                Q += vstream.m_dwStride;
                B = vstrmin.m_pSavedData + ((dwOffH + n[2]) * dwStride + (dwOffW + m[2])) * vstrmin.m_dwStride + velem.m_dwOffsetIn;
                if(bDegenerate2)
                {
                    Surf.SampleDegenerateNormal(velem.m_dwDataType, B, vstrmin.m_dwStride, dwStride * vstrmin.m_dwStride, Q);
                }
                else
                {
                    Surf.SampleNormal(velem.m_dwDataType, u2, v2, B, vstrmin.m_dwStride, dwStride * vstrmin.m_dwStride, Q);
                }
            }
            else // it is D3DVSD_TESSUV
            {
                RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
                LPBYTE Q = &vstream.m_pData[velem.m_dwOffset];
                ((FLOAT*)Q)[0] = (FLOAT)tu0;
                ((FLOAT*)Q)[1] = (FLOAT)tv0;
                Q += vstream.m_dwStride;
                ((FLOAT*)Q)[0] = (FLOAT)tu1;
                ((FLOAT*)Q)[1] = (FLOAT)tv1;
                Q += vstream.m_dwStride;
                ((FLOAT*)Q)[0] = (FLOAT)tu2;
                ((FLOAT*)Q)[1] = (FLOAT)tv2;
            }
        }
        else
        {
            RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
            LPBYTE B = vstream.m_pSavedData + ((dwOffH + n[0]) * dwStride + (dwOffW + m[0])) * vstream.m_dwStride + velem.m_dwOffset;
            LPBYTE Q = &vstream.m_pData[velem.m_dwOffset];
            Surf.Sample(velem.m_dwDataType, u0, v0, B, vstream.m_dwStride, dwStride * vstream.m_dwStride, Q);
            Q += vstream.m_dwStride;
            B = vstream.m_pSavedData + ((dwOffH + n[1]) * dwStride + (dwOffW + m[1])) * vstream.m_dwStride + velem.m_dwOffset;
            Surf.Sample(velem.m_dwDataType, u1, v1, B, vstream.m_dwStride, dwStride * vstream.m_dwStride, Q);
            Q += vstream.m_dwStride;
            B = vstream.m_pSavedData + ((dwOffH + n[2]) * dwStride + (dwOffW + m[2])) * vstream.m_dwStride + velem.m_dwOffset;
            Surf.Sample(velem.m_dwDataType, u2, v2, B, vstream.m_dwStride, dwStride * vstream.m_dwStride, Q);
        }
    }

    HRESULT hr;
    if( m_pCurrentVShader->IsFixedFunction() )
    {
        //
        // With declaration for Fixed Function pipeline, DX8 style
        //
        hr = ProcessPrimitive( D3DPT_TRIANGLELIST, 0, 3, 0, 0 );
    }
    else
    {
        //
        // Pure Vertex Shader
        //
        hr = ProcessPrimitiveVVM( D3DPT_TRIANGLELIST, 0, 3, 0, 0 );
    }
    return hr;
}

//---------------------------------------------------------------------
// RefDev::DrawNPatch
//---------------------------------------------------------------------
HRESULT RefDev::DrawNPatch(const RDNPatch &Patch, DWORD dwStride, 
                                        const unsigned *m, const unsigned *n, unsigned segs)
{
    for(unsigned i = 0; i < segs; ++i)
    {
        double v0 = double(i) / double(segs);
        double v1 = v0;
        double v2 = double(i + 1) / double(segs);
        double v3 = v2;
        for(unsigned j = 0; j < segs - i; ++j)
        {
            double u0 = double(j + 1) / double(segs);
            double u1 = double(j) / double(segs);
            double u2 = u1;
            double u3 = u0;
            RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;
            for(unsigned e = 0; e < Decl.m_dwNumElements; ++e)
            {
                RDVElement &velem = Decl.m_VertexElements[e];
                RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
                LPBYTE Q = &vstream.m_pData[velem.m_dwOffset];
                if(velem.m_dwRegister == D3DVSDE_POSITION)
                {
                    Patch.SamplePosition(u0, v0, (FLOAT*)Q);
                    Q += vstream.m_dwStride;
                    Patch.SamplePosition(u1, v1, (FLOAT*)Q);
                    Q += vstream.m_dwStride;
                    Patch.SamplePosition(u2, v2, (FLOAT*)Q);
                    if(j != segs - i - 1)
                    {
                        Q += vstream.m_dwStride;
                        Patch.SamplePosition(u3, v3, (FLOAT*)Q);
                    }
                }
                else
                if(velem.m_dwRegister == D3DVSDE_NORMAL)
                {
                    BYTE* B[3];
                    B[0] = vstream.m_pSavedData + (n[0] * dwStride + m[0]) * vstream.m_dwStride + velem.m_dwOffset;
                    B[1] = vstream.m_pSavedData + (n[1] * dwStride + m[1]) * vstream.m_dwStride + velem.m_dwOffset;
                    B[2] = vstream.m_pSavedData + (n[2] * dwStride + m[2]) * vstream.m_dwStride + velem.m_dwOffset;

                    Patch.SampleNormal(u0, v0, B, (FLOAT*)Q);
                    Q += vstream.m_dwStride;
                    Patch.SampleNormal(u1, v1, B, (FLOAT*)Q);
                    Q += vstream.m_dwStride;
                    Patch.SampleNormal(u2, v2, B, (FLOAT*)Q);
                    if(j != segs - i - 1)
                    {
                        Q += vstream.m_dwStride;
                        Patch.SampleNormal(u3, v3, B, (FLOAT*)Q);
                    }
                }
                else
                {
                    BYTE *B[3];
                    B[0] = vstream.m_pSavedData + (n[0] * dwStride + m[0]) * vstream.m_dwStride + velem.m_dwOffset;
                    B[1] = vstream.m_pSavedData + (n[1] * dwStride + m[1]) * vstream.m_dwStride + velem.m_dwOffset;
                    B[2] = vstream.m_pSavedData + (n[2] * dwStride + m[2]) * vstream.m_dwStride + velem.m_dwOffset;
                    Patch.Sample(velem.m_dwDataType, u0, v0, B, Q);
                    Q += vstream.m_dwStride;
                    Patch.Sample(velem.m_dwDataType, u1, v1, B, Q);
                    Q += vstream.m_dwStride;
                    Patch.Sample(velem.m_dwDataType, u2, v2, B, Q);
                    if(j != segs - i - 1)
                    {
                        Q += vstream.m_dwStride;
                        Patch.Sample(velem.m_dwDataType, u3, v3, B, Q);
                    }
                }
            }
            DWORD cVerts = (j != segs - i - 1) ? 4 : 3;
            HRESULT hr;
            if( m_pCurrentVShader->IsFixedFunction() )
            {
                //
                // With declaration for Fixed Function pipeline, DX8 style
                //
                hr = ProcessPrimitive( D3DPT_TRIANGLEFAN, 0, cVerts, 0, 0 );
            }
            else
            {
                //
                // Pure Vertex Shader
                //
                hr = ProcessPrimitiveVVM( D3DPT_TRIANGLEFAN, 0, cVerts, 0, 0 );
            }
            if(FAILED(hr))
            {
                return hr;
            }
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\hop\npatch.cpp ===
/*============================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       npatch.cpp
 *  Content:    Implementation for N-Patches
 *
 ****************************************************************************/

#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
// RefDev::ProcessTessPrimitive
//-----------------------------------------------------------------------------
HRESULT 
RefDev::ProcessTessPrimitive( LPD3DHAL_DP2DRAWPRIMITIVE pDP )
{
    HRESULT hr = S_OK;

    if( RDVSD_ISLEGACY( m_CurrentVShaderHandle ) )
    {
        //
        // The legacy FVF style: The Zero'th Stream is implied
        //
        DWORD dwFVF    = m_CurrentVShaderHandle;
        RDVStream& Stream = m_VStream[0];
        DWORD dwStride = Stream.m_dwStride;
        DWORD dwFVFSize = GetFVFVertexSize( dwFVF );

        if( Stream.m_pData == NULL || dwStride == 0 )
        {
            DPFERR( "Zero'th stream doesnt have valid VB set" );
            return DDERR_INVALIDPARAMS;
        }
        if( dwStride < dwFVFSize )
        {
            DPFERR( "The stride set for the vertex stream is less than"
                    " the FVF vertex size" );
            return E_FAIL;
        }
    }

    BYTE *pVerts = 0, *pNorms = 0;
    unsigned vstride, nstride;

    // Figure out where the positions and normals are
    RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;
    for(unsigned e = 0; e < Decl.m_dwNumElements; ++e)
    {
        RDVElement &velem = Decl.m_VertexElements[e];
        if(velem.m_dwRegister == D3DVSDE_POSITION) // Position
        {
            RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
            pVerts = vstream.m_pSavedData + pDP->VStart * vstream.m_dwStride + velem.m_dwOffset;
            vstride = vstream.m_dwStride;
        }
        else if(velem.m_dwRegister == D3DVSDE_NORMAL) // Normal
        {
            RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
            pNorms = vstream.m_pSavedData + pDP->VStart * vstream.m_dwStride + velem.m_dwOffset;
            nstride = vstream.m_dwStride;
        }
    }

    if(pVerts == 0 || pNorms == 0)
    {
        DPFERR("This tessellation scheme needs positions and normals explicitely specified");
        return DDERR_INVALIDPARAMS;
    }

    switch(pDP->primType)
    {
    case D3DPT_TRIANGLELIST:
        {
            for(unsigned i = 0; i < pDP->PrimitiveCount; ++i)
            {
                FLOAT *pV[3], *pN[3];
                unsigned iM[3], iN[3];
                
                pV[0] = (FLOAT*)(pVerts + i * 3 * vstride);
                pV[1] = (FLOAT*)(pVerts + (i * 3 + 1) * vstride);
                pV[2] = (FLOAT*)(pVerts + (i * 3 + 2) * vstride);
                pN[0] = (FLOAT*)(pNorms + i * 3 * nstride);
                pN[1] = (FLOAT*)(pNorms + (i * 3 + 1) * nstride);
                pN[2] = (FLOAT*)(pNorms + (i * 3 + 2) * nstride);
                iM[0] = pDP->VStart + i * 3;     iN[0] = 0;
                iM[1] = pDP->VStart + i * 3 + 1; iN[1] = 0;
                iM[2] = pDP->VStart + i * 3 + 2; iN[2] = 0;

                RDNPatch patch(pV, pN, GetRS()[D3DRS_POSITIONORDER], GetRS()[D3DRS_NORMALORDER]);
                
                hr = DrawNPatch(patch, 0, iM, iN, unsigned(GetRSf()[D3DRS_PATCHSEGMENTS]));
                if(FAILED(hr))
                {
                    return hr;
                }
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            for(unsigned i = 0; i < pDP->PrimitiveCount; ++i)
            {
                FLOAT *pV[3], *pN[3];
                unsigned iM[3], iN[3];
                
                pV[0] = (FLOAT*)(pVerts);
                pV[1] = (FLOAT*)(pVerts + (i + 1) * vstride);
                pV[2] = (FLOAT*)(pVerts + (i + 2) * vstride);
                pN[0] = (FLOAT*)(pNorms);
                pN[1] = (FLOAT*)(pNorms + (i + 1) * nstride);
                pN[2] = (FLOAT*)(pNorms + (i + 2) * nstride);
                iM[0] = pDP->VStart;         iN[0] = 0;
                iM[1] = pDP->VStart + i + 1; iN[1] = 0;
                iM[2] = pDP->VStart + i + 2; iN[2] = 0;
                
                RDNPatch patch(pV, pN, GetRS()[D3DRS_POSITIONORDER], GetRS()[D3DRS_NORMALORDER]);

                hr = DrawNPatch(patch, 0, iM, iN, unsigned(GetRSf()[D3DRS_PATCHSEGMENTS]));
                if(FAILED(hr))
                {
                    return hr;
                }
            }
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            for(unsigned i = 0; i < pDP->PrimitiveCount; ++i)
            {
                FLOAT *pV[3], *pN[3];
                unsigned iM[3], iN[3];

                pV[0] = (FLOAT*)(pVerts + i * vstride);
                pN[0] = (FLOAT*)(pNorms + i * nstride);
                iM[0] = pDP->VStart + i; iN[0] = 0;
                iM[0] = pDP->VStart + i; iN[0] = 0;
                if((i & 1) != 0)
                {
                    pV[1] = (FLOAT*)(pVerts + (i + 2) * vstride);
                    pV[2] = (FLOAT*)(pVerts + (i + 1) * vstride);
                    pN[1] = (FLOAT*)(pNorms + (i + 2) * nstride);
                    pN[2] = (FLOAT*)(pNorms + (i + 1) * nstride);
                    iM[1] = pDP->VStart + i + 2; iN[1] = 0;
                    iM[2] = pDP->VStart + i + 1; iN[2] = 0;
                }
                else
                {
                    pV[1] = (FLOAT*)(pVerts + (i + 1) * vstride);
                    pV[2] = (FLOAT*)(pVerts + (i + 2) * vstride);
                    pN[1] = (FLOAT*)(pNorms + (i + 1) * nstride);
                    pN[2] = (FLOAT*)(pNorms + (i + 2) * nstride);
                    iM[1] = pDP->VStart + i + 1; iN[1] = 0;
                    iM[2] = pDP->VStart + i + 2; iN[2] = 0;
                }

                RDNPatch patch(pV, pN, GetRS()[D3DRS_POSITIONORDER], GetRS()[D3DRS_NORMALORDER]);

                hr = DrawNPatch(patch, 0, iM, iN, unsigned(GetRSf()[D3DRS_PATCHSEGMENTS]));
                if(FAILED(hr))
                {
                    return hr;
                }
            }
        }
        break;
    default:
        _ASSERT(FALSE, "Unsupported primitive type");        
        hr = E_FAIL;
    }
    
    return hr;
}

//-----------------------------------------------------------------------------
// RefDev::ProcessTessIndexedPrimitive
//-----------------------------------------------------------------------------
HRESULT 
RefDev::ProcessTessIndexedPrimitive( LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE pDIP )
{
    HRESULT hr = S_OK;

    if( RDVSD_ISLEGACY( m_CurrentVShaderHandle ) )
    {
        //
        // The legacy FVF style: The Zero'th Stream is implied
        //
        DWORD dwFVF    = m_CurrentVShaderHandle;
        RDVStream& Stream = m_VStream[0];
        DWORD dwStride = Stream.m_dwStride;
        DWORD dwFVFSize = GetFVFVertexSize( dwFVF );

        if( Stream.m_pData == NULL || dwStride == 0 )
        {
            DPFERR( "Zero'th stream doesnt have valid VB set" );
            return DDERR_INVALIDPARAMS;
        }
        if( dwStride < dwFVFSize )
        {
            DPFERR( "The stride set for the vertex stream is less than"
                    " the FVF vertex size" );
            return E_FAIL;
        }
        
        if( m_IndexStream.m_pData == NULL )
        {
            DPFERR( "Indices are not available" );
            return E_FAIL;
        }
    }

    BYTE *pVerts = 0, *pNorms = 0;
    unsigned vstride, nstride;

    // Figure out where the positions and normals are
    RDVDeclaration &Decl = m_pCurrentVShader->m_Declaration;
    for(unsigned e = 0; e < Decl.m_dwNumElements; ++e)
    {
        RDVElement &velem = Decl.m_VertexElements[e];
        if(velem.m_dwRegister == D3DVSDE_POSITION) // Position
        {
            RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
            pVerts = vstream.m_pSavedData + pDIP->BaseVertexIndex * vstream.m_dwStride + velem.m_dwOffset;
            vstride = vstream.m_dwStride;
        }
        else if(velem.m_dwRegister == D3DVSDE_NORMAL) // Normal
        {
            RDVStream &vstream = m_VStream[velem.m_dwStreamIndex];
            pNorms = vstream.m_pSavedData + pDIP->BaseVertexIndex * vstream.m_dwStride + velem.m_dwOffset;
            nstride = vstream.m_dwStride;
        }
    }

    if(pVerts == 0 || pNorms == 0)
    {
        DPFERR("This tessellation scheme needs positions and normals explicitely specified");
        return DDERR_INVALIDPARAMS;
    }

    RRIndexAccessor Index(m_IndexStream.m_pData, m_IndexStream.m_dwStride, pDIP->StartIndex);

    switch(pDIP->primType)
    {
    case D3DPT_TRIANGLELIST:
        {
            for(unsigned i = 0; i < pDIP->PrimitiveCount; ++i)
            {
                FLOAT *pV[3], *pN[3];
                unsigned iM[3], iN[3];

                pV[0] = (FLOAT*)(pVerts + Index[i * 3] * vstride);
                pV[1] = (FLOAT*)(pVerts + Index[i * 3 + 1] * vstride);
                pV[2] = (FLOAT*)(pVerts + Index[i * 3 + 2] * vstride);
                pN[0] = (FLOAT*)(pNorms + Index[i * 3] * nstride);
                pN[1] = (FLOAT*)(pNorms + Index[i * 3 + 1] * nstride);
                pN[2] = (FLOAT*)(pNorms + Index[i * 3 + 2] * nstride);
                iM[0] = pDIP->BaseVertexIndex + Index[i * 3];     iN[0] = 0;
                iM[1] = pDIP->BaseVertexIndex + Index[i * 3 + 1]; iN[1] = 0;
                iM[2] = pDIP->BaseVertexIndex + Index[i * 3 + 2]; iN[2] = 0;

                RDNPatch patch(pV, pN, GetRS()[D3DRS_POSITIONORDER], GetRS()[D3DRS_NORMALORDER]);
                
                hr = DrawNPatch(patch, 0, iM, iN, unsigned(GetRSf()[D3DRS_PATCHSEGMENTS]));
                if(FAILED(hr))
                {
                    return hr;
                }
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            for(unsigned i = 0; i < pDIP->PrimitiveCount; ++i)
            {
                FLOAT *pV[3], *pN[3];
                unsigned iM[3], iN[3];
                
                pV[0] = (FLOAT*)(pVerts + Index[0] * vstride);
                pV[1] = (FLOAT*)(pVerts + Index[i + 1] * vstride);
                pV[2] = (FLOAT*)(pVerts + Index[i + 2] * vstride);
                pN[0] = (FLOAT*)(pNorms + Index[0] * nstride);
                pN[1] = (FLOAT*)(pNorms + Index[i + 1] * nstride);
                pN[2] = (FLOAT*)(pNorms + Index[i + 2] * nstride);
                iM[0] = pDIP->BaseVertexIndex + Index[0];     iN[0] = 0;
                iM[1] = pDIP->BaseVertexIndex + Index[i + 1]; iN[1] = 0;
                iM[2] = pDIP->BaseVertexIndex + Index[i + 2]; iN[2] = 0;
                
                RDNPatch patch(pV, pN, GetRS()[D3DRS_POSITIONORDER], GetRS()[D3DRS_NORMALORDER]);

                hr = DrawNPatch(patch, 0, iM, iN, unsigned(GetRSf()[D3DRS_PATCHSEGMENTS]));
                if(FAILED(hr))
                {
                    return hr;
                }
            }
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            for(unsigned i = 0; i < pDIP->PrimitiveCount; ++i)
            {
                FLOAT *pV[3], *pN[3];
                unsigned iM[3], iN[3];

                pV[0] = (FLOAT*)(pVerts + Index[i] * vstride);
                pN[0] = (FLOAT*)(pNorms + Index[i] * nstride);
                iM[0] = pDIP->BaseVertexIndex + Index[i]; iN[0] = 0;
                iM[0] = pDIP->BaseVertexIndex + Index[i]; iN[0] = 0;
                if((i & 1) != 0)
                {
                    pV[1] = (FLOAT*)(pVerts + Index[i + 2] * vstride);
                    pV[2] = (FLOAT*)(pVerts + Index[i + 1] * vstride);
                    pN[1] = (FLOAT*)(pNorms + Index[i + 2] * nstride);
                    pN[2] = (FLOAT*)(pNorms + Index[i + 1] * nstride);
                    iM[1] = pDIP->BaseVertexIndex + Index[i + 2]; iN[1] = 0;
                    iM[2] = pDIP->BaseVertexIndex + Index[i + 1]; iN[2] = 0;
                }
                else
                {
                    pV[1] = (FLOAT*)(pVerts + Index[i + 1] * vstride);
                    pV[2] = (FLOAT*)(pVerts + Index[i + 2] * vstride);
                    pN[1] = (FLOAT*)(pNorms + Index[i + 1] * nstride);
                    pN[2] = (FLOAT*)(pNorms + Index[i + 2] * nstride);
                    iM[1] = pDIP->BaseVertexIndex + Index[i + 1]; iN[1] = 0;
                    iM[2] = pDIP->BaseVertexIndex + Index[i + 2]; iN[2] = 0;
                }

                RDNPatch patch(pV, pN, GetRS()[D3DRS_POSITIONORDER], GetRS()[D3DRS_NORMALORDER]);

                hr = DrawNPatch(patch, 0, iM, iN, unsigned(GetRSf()[D3DRS_PATCHSEGMENTS]));
                if(FAILED(hr))
                {
                    return hr;
                }
            }
        }
        break;
    default:
        _ASSERT(FALSE, "Unsupported primitive type");        
        hr = E_FAIL;
    }
    
    return hr;
}

//-----------------------------------------------------------------------------
// RDCubicBezierTriangle::SamplePosition
//-----------------------------------------------------------------------------
void RDCubicBezierTriangle::SamplePosition(double u, double v, FLOAT *Q) const
{
    for(unsigned e = 0; e < 3; ++e)
    {
        Q[e] = FLOAT(m_B[0][0][e] * Basis(0, 0, u, v) +
                     m_B[0][3][e] * Basis(0, 3, u, v) +
                     m_B[3][0][e] * Basis(3, 0, u, v) +
                     m_B[0][1][e] * Basis(0, 1, u, v) +
                     m_B[0][2][e] * Basis(0, 2, u, v) +
                     m_B[1][2][e] * Basis(1, 2, u, v) +
                     m_B[2][1][e] * Basis(2, 1, u, v) +
                     m_B[2][0][e] * Basis(2, 0, u, v) +
                     m_B[1][0][e] * Basis(1, 0, u, v) +
                     m_B[1][1][e] * Basis(1, 1, u, v));
    }
}

//-----------------------------------------------------------------------------
// RDCubicBezierTriangle::Sample
//-----------------------------------------------------------------------------
void RDCubicBezierTriangle::Sample(DWORD dwDataType, double u, double v, const BYTE* const B[], BYTE *Q) const
{
    double w = 1.0 - u - v;
    unsigned dwElements = 0;
    switch(dwDataType)
    {
        case D3DVSDT_FLOAT4:
            ++dwElements;
        case D3DVSDT_FLOAT3:
            ++dwElements;
        case D3DVSDT_FLOAT2:
            ++dwElements;
        case D3DVSDT_FLOAT1:
            ++dwElements;
            {
                for(unsigned e = 0; e < dwElements; ++e)
                {
                    ((FLOAT*)Q)[e] = FLOAT(w * double(((FLOAT*)B[0])[e]) + v * double(((FLOAT*)B[1])[e]) + u * double(((FLOAT*)B[2])[e]));
                }
            }
            break;
        case D3DVSDT_D3DCOLOR:
        case D3DVSDT_UBYTE4:
            dwElements = 4;
            {
                for(unsigned e = 0; e < 4; ++e)
                {
                    int t = int(w * double(B[0][e]) + v * double(B[1][e]) + u * double(B[2][e]));
                    Q[e] = BYTE(t < 0 ? 0 : (t > 255 ? 255 : t));
                }
            }
            break;
        case D3DVSDT_SHORT4:
            dwElements += 2;
        case D3DVSDT_SHORT2:
            dwElements += 2;
            {
                for(unsigned e = 0; e < dwElements; ++e)
                {
                    ((SHORT*)Q)[e] = SHORT(w * double(((SHORT*)B[0])[e]) + v * double(((SHORT*)B[1])[e]) + u * double(((SHORT*)B[2])[e]));
                }
            }
            break;
        default:
            _ASSERT(FALSE, "Ununderstood vertex element data type");
    }
}

//-----------------------------------------------------------------------------
// RDNPatch::RDNPatch
//-----------------------------------------------------------------------------
RDNPatch::RDNPatch(const FLOAT* const pV[], const FLOAT* const pN[], 
                   const DWORD PositionOrder, const DWORD NormalOrder)
{
    _ASSERT((PositionOrder == D3DORDER_LINEAR) || (PositionOrder == D3DORDER_CUBIC), 
            "Unsupported position order in NPatch");        
    _ASSERT((NormalOrder == D3DORDER_LINEAR) || (NormalOrder == D3DORDER_QUADRATIC), 
            "Unsupported normal order in NPatch");        

    m_PositionOrder = PositionOrder;
    m_NormalOrder = NormalOrder;
    // Assign corner points
    m_B[0][0][0] = double(pV[0][0]);
    m_B[0][0][1] = double(pV[0][1]);
    m_B[0][0][2] = double(pV[0][2]);
    m_B[0][3][0] = double(pV[1][0]);
    m_B[0][3][1] = double(pV[1][1]);
    m_B[0][3][2] = double(pV[1][2]);
    m_B[3][0][0] = double(pV[2][0]);
    m_B[3][0][1] = double(pV[2][1]);
    m_B[3][0][2] = double(pV[2][2]);

    if (PositionOrder == D3DORDER_CUBIC)
    {
        // Compute edge control points
        ComputeEdgeControlPoint(0, 1, pV, pN, 0, 1);
        ComputeEdgeControlPoint(1, 0, pV, pN, 0, 2);
        ComputeEdgeControlPoint(1, 2, pV, pN, 1, 2);
        ComputeEdgeControlPoint(2, 1, pV, pN, 2, 1);
        ComputeEdgeControlPoint(2, 0, pV, pN, 2, 0);
        ComputeEdgeControlPoint(0, 2, pV, pN, 1, 0);

        // Compute central control point
        m_B[1][1][0] = (m_B[2][0][0] + m_B[1][0][0] + m_B[0][2][0] + m_B[0][1][0] + m_B[2][1][0] + m_B[1][2][0]) / 4.0 -
                        (m_B[3][0][0] + m_B[0][3][0] + m_B[0][0][0]) / 6.0;
        m_B[1][1][1] = (m_B[2][0][1] + m_B[1][0][1] + m_B[0][2][1] + m_B[0][1][1] + m_B[2][1][1] + m_B[1][2][1]) / 4.0 -
                        (m_B[3][0][1] + m_B[0][3][1] + m_B[0][0][1]) / 6.0;
        m_B[1][1][2] = (m_B[2][0][2] + m_B[1][0][2] + m_B[0][2][2] + m_B[0][1][2] + m_B[2][1][2] + m_B[1][2][2]) / 4.0 -
                        (m_B[3][0][2] + m_B[0][3][2] + m_B[0][0][2]) / 6.0;
    }
    if (NormalOrder == D3DORDER_QUADRATIC)
    {
        // Compute central control point
        Normalize(*(RDVECTOR3*)pN[0]);
        Normalize(*(RDVECTOR3*)pN[1]);
        Normalize(*(RDVECTOR3*)pN[2]);
        m_N002 = *(RDVECTOR3*)pN[0];
        m_N020 = *(RDVECTOR3*)pN[1];
        m_N200 = *(RDVECTOR3*)pN[2];
        ComputeNormalControlPoint(&m_N110, 1, 2, pV, pN);
        ComputeNormalControlPoint(&m_N101, 2, 0, pV, pN);
        ComputeNormalControlPoint(&m_N011, 0, 1, pV, pN);
    }
}

//-----------------------------------------------------------------------------
// RDNPatch::SamplePosition
//-----------------------------------------------------------------------------
void RDNPatch::SamplePosition(double u, double v, FLOAT *Q) const
{
    if (m_PositionOrder == D3DORDER_CUBIC)
        RDCubicBezierTriangle::SamplePosition(u, v, Q);
    else
    {
        double w = 1.0 - u - v;
        Q[0] = m_B[0][0][0] * w + m_B[0][3][0] * v + m_B[3][0][0] * u;
        Q[1] = m_B[0][0][1] * w + m_B[0][3][1] * v + m_B[3][0][1] * u;
        Q[2] = m_B[0][0][2] * w + m_B[0][3][2] * v + m_B[3][0][2] * u;
    }
}

//-----------------------------------------------------------------------------
// RDNPatch::SampleNormal
//-----------------------------------------------------------------------------
void RDNPatch::SampleNormal(double u, double v, const BYTE* const B[], FLOAT *Q) const
{
    if (m_NormalOrder == D3DORDER_LINEAR)
        RDCubicBezierTriangle::Sample(D3DVSDT_FLOAT3, u, v, B, (BYTE*)Q);
    else
    {
        // Computed by article "Curved PN Triangles" (Chas Boyd, ...)
        double w = 1.0 - u - v;
        double ww = w*w;
        double uu = u*u;
        double vv = v*v;
        double uv = u*v;
        double wu = w*u;
        double wv = w*v;
        Q[0] = m_N200.x * uu + m_N020.x * vv + m_N002.x * ww + m_N110.x * uv + m_N011.x * wv + m_N101.x * wu;
        Q[1] = m_N200.y * uu + m_N020.y * vv + m_N002.y * ww + m_N110.y * uv + m_N011.y * wv + m_N101.y * wu;
        Q[2] = m_N200.z * uu + m_N020.z * vv + m_N002.z * ww + m_N110.z * uv + m_N011.z * wv + m_N101.z * wu;
        Normalize(*(RDVECTOR3*)Q);
    }
}

//-----------------------------------------------------------------------------
// RDNPatch::ComputeNormalControlPoint
//-----------------------------------------------------------------------------
void RDNPatch::ComputeNormalControlPoint(RDVECTOR3* cp, unsigned i, unsigned j,
                                         const FLOAT* const pV[], 
                                         const FLOAT* const pN[])
{
    RDVECTOR3 Pji, Nij;
    SubtractVector(*(RDVECTOR3*)pV[j], *(RDVECTOR3*)pV[i], Pji);
    AddVector(*(RDVECTOR3*)pN[j], *(RDVECTOR3*)pN[i], Nij);
    FLOAT v = 2.0f * DotProduct(Pji, Nij) / DotProduct(Pji, Pji);
    SubtractVector(Nij, ScaleVector(Pji, v), *cp);
}

//-----------------------------------------------------------------------------
// RDNPatch::ComputeEdgeControlPoint
//-----------------------------------------------------------------------------
void RDNPatch::ComputeEdgeControlPoint(unsigned a, unsigned b, const FLOAT* const pV[], const FLOAT* const pN[], unsigned u, unsigned v)
{
    static const double Tension = 1.0 / 3.0; 
    double t, Edge[3];

    Edge[0] = double(pV[b][0]) - double(pV[a][0]);
    Edge[1] = double(pV[b][1]) - double(pV[a][1]);
    Edge[2] = double(pV[b][2]) - double(pV[a][2]);

    t = Edge[0] * double(pN[a][0]) + Edge[1] * double(pN[a][1]) + Edge[2] * double(pN[a][2]);

    m_B[u][v][0] = double(pV[a][0]) + (Edge[0] - t * double(pN[a][0])) * Tension;
    m_B[u][v][1] = double(pV[a][1]) + (Edge[1] - t * double(pN[a][1])) * Tension;
    m_B[u][v][2] = double(pV[a][2]) + (Edge[2] - t * double(pN[a][2])) * Tension;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\hop\catrom.cpp ===
/*============================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       catrom.cpp
 *  Content:    Implementation for Catmull-Rom splines
 *
 ****************************************************************************/

#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
// RefDev::ProcessCatRomSpline
//-----------------------------------------------------------------------------
HRESULT RefDev::ProcessCatRomSpline( DWORD dwOffW, DWORD dwOffH,
                                                  DWORD dwWidth, DWORD dwHeight,
                                                  DWORD dwStride,
                                                  FLOAT *pPrimSegments )
{
    int u_range = dwWidth - 3;
    int v_range = dwHeight - 3;

    if(u_range <= 0 || v_range <= 0)
    {
        DPFERR("A Catmull-Rom spline needs at least 16 control points");
        return DDERR_INVALIDPARAMS;
    }

    RDCatRomSpline catrom;

    unsigned M[4], N[4];

    unsigned u_segs, v_segs, u_start, v_start;

    if(pPrimSegments != 0)
    {
        u_segs = unsigned(double(unsigned(pPrimSegments[0]) + unsigned(pPrimSegments[2])) / 2.0 + 0.5);
        v_segs = unsigned(double(unsigned(pPrimSegments[1]) + unsigned(pPrimSegments[3])) / 2.0 + 0.5);
        if(u_segs == 0)
        {
            u_segs = 1;
        }
        if(v_segs == 0)
        {
            v_segs = 1;
        }
        if(unsigned(pPrimSegments[0]) != unsigned(pPrimSegments[2]) || unsigned(pPrimSegments[1]) != unsigned(pPrimSegments[3]))
        {
            // First, gulp, the irregular outside
            // To make life easier, we don't want to deal with the case when u_segs or v_segs is one
            // This ensures that there is at least one inside point
            if(u_segs == 1)
            {
                u_segs = 2;
            }
            if(v_segs == 1)
            {
                v_segs = 2;
            }
            // Start with top edge
            unsigned segs = unsigned(pPrimSegments[0]);
            unsigned k_outer = 0;
            unsigned k_inner = 1;
            unsigned outer_inc = u_segs - 2;
            unsigned inner_inc = segs;
            unsigned outer = 0;
            unsigned inner = 0;
            double u0, v0, u1, v1, u2, v2, tu0, tv0, tu1, tv1, tu2, tv2;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer < segs))
            {
                if(inner < outer)
                {
                    _ASSERT(k_inner < u_segs - 1, "Error in logic");
                    u0 = double(u_range * k_inner) / double(u_segs) + 3.0;    
                    v0 = double(v_range) / double(v_segs) + 3.0;
                    u1 = double(u_range * k_outer) / double(segs) + 3.0;    
                    v1 = 0.0;
                    u2 = double(u_range * (k_inner + 1)) / double(u_segs) + 3.0;    
                    v2 = v0;
                    tu0 = double(k_inner) / double(u_segs);    
                    tv0 = 1.0 / double(v_segs);
                    tu1 = double(k_outer) / double(segs);    
                    tv1 = 0.0;
                    tu2 = double(k_inner + 1) / double(u_segs);    
                    tv2 = tv0;

                    M[0] = unsigned(u0) - 3; // unsigned(u0) == floor(u0)
                    u0 -= floor(u0);
                    if((u_range * k_outer) % segs == 0)
                    {
                        M[1] = unsigned(u1) - 4;
                        u1 = 1.0;
                    }
                    else
                    {
                        M[1] = unsigned(u1) - 3; // unsigned(u1) == floor(u1)
                        u1 -= floor(u1);
                    }
                    M[2] = unsigned(u2) - 3; // unsigned(u2) == floor(u2)
                    u2 -= floor(u2);
                    N[2] = N[0] = unsigned(v0) - 3; // unsigned(v0) == floor(v0)
                    v2 = v0 = v0 - floor(v0);
                    N[1] = 0;

                    ++k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer < segs, "Error in logic");
                    u0 = double(u_range * k_inner) / double(u_segs) + 3.0;    
                    v0 = double(v_range) / double(v_segs) + 3.0;
                    u1 = double(u_range * k_outer) / double(segs) + 3.0;    
                    v1 = 0.0;
                    u2 = double(u_range * (k_outer + 1)) / double(segs) + 3.0;    
                    v2 = v1;
                    tu0 = double(k_inner) / double(u_segs);    
                    tv0 = 1.0 / double(v_segs);
                    tu1 = double(k_outer) / double(segs);    
                    tv1 = 0.0;
                    tu2 = double(k_outer + 1) / double(segs);    
                    tv2 = tv1;

                    if((u_range * k_inner) % u_segs == 0)
                    {
                        M[0] = unsigned(u0) - 4;
                        u0 = 1.0;
                    }
                    else
                    {
                        M[0] = unsigned(u0) - 3; // unsigned(u0) == floor(u0)
                        u0 -= floor(u0);
                    }
                    M[1] = unsigned(u1) - 3; // unsigned(u1) == floor(u1)
                    u1 -= floor(u1);
                    if((u_range * (k_outer + 1)) % segs == 0)
                    {
                        M[2] = unsigned(u2) - 4;
                        u2 = 1.0;
                    }
                    else
                    {
                        M[2] = unsigned(u2) - 3; // unsigned(u2) == floor(u2)
                        u2 -= floor(u2);
                    }
                    N[0] = unsigned(v0) - 3; // unsigned(v0) == floor(v0)
                    v0 -= floor(v0);
                    N[2] = N[1] = 0;

                    ++k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(catrom, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2, tu0, tv0, tu1, tv1, tu2, tv2, false, false, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // bottom edge
            segs = unsigned(pPrimSegments[2]);
            k_outer = segs;
            k_inner = u_segs - 1;
            inner_inc = segs;
            outer = 0;
            inner = 0;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer > 0))
            {
                if(inner < outer)
                {
                    _ASSERT(k_inner > 1, "Error in logic");
                    u0 = double(u_range * k_inner) / double(u_segs) + 3.0;    
                    v0 = double(v_range * (v_segs - 1)) / double(v_segs) + 3.0;
                    u1 = double(u_range * k_outer) / double(segs) + 3.0;    
                    v1 = double(v_range + 3);
                    u2 = double(u_range * (k_inner - 1)) / double(u_segs) + 3.0;    
                    v2 = v0;
                    tu0 = double(k_inner) / double(u_segs);    
                    tv0 = double(v_segs - 1) / double(v_segs);
                    tu1 = double(k_outer) / double(segs);    
                    tv1 = 1.0;
                    tu2 = double(k_inner - 1) / double(u_segs);    
                    tv2 = tv0;
        
                    M[0] = unsigned(u0) - 3; // unsigned(u0) == floor(u0)
                    u0 -= floor(u0);
                    if((u_range * k_outer) % segs == 0)
                    {
                        M[1] = unsigned(u1) - 4;
                        u1 = 1.0;
                    }
                    else
                    {
                        M[1] = unsigned(u1) - 3; // unsigned(u1) == floor(u1)
                        u1 -= floor(u1);
                    }
                    M[2] = unsigned(u2) - 3; // unsigned(u2) == floor(u2)
                    u2 -= floor(u2);
                    N[2] = N[0] = unsigned(v0) - 3; // unsigned(v0) == floor(v0)
                    v2 = v0 = v0 - floor(v0);
                    N[1] = dwHeight - 4;
                    v1 = 1.0;

                    --k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer > 0, "Error in logic");
                    u0 = double(u_range * k_inner) / double(u_segs) + 3.0;    
                    v0 = double(v_range * (v_segs - 1)) / double(v_segs) + 3.0;
                    u1 = double(u_range * k_outer) / double(segs) + 3.0;    
                    v1 = double(v_range + 3);
                    u2 = double(u_range * (k_outer - 1)) / double(segs) + 3.0;    
                    v2 = v1;
                    tu0 = double(k_inner) / double(u_segs);    
                    tv0 = double(v_segs - 1) / double(v_segs);
                    tu1 = double(k_outer) / double(segs);    
                    tv1 = 1.0;
                    tu2 = double(k_outer - 1) / double(segs);    
                    tv2 = tv1;

                    M[0] = unsigned(u0) - 3; // unsigned(u0) == floor(u0)
                    u0 -= floor(u0);
                    if((u_range * k_outer) % segs == 0)
                    {
                        M[1] = unsigned(u1) - 4;
                        u1 = 1.0;
                    }
                    else
                    {
                        M[1] = unsigned(u1) - 3; // unsigned(u1) == floor(u1)
                        u1 -= floor(u1);
                    }
                    M[2] = unsigned(u2) - 3; // unsigned(u2) == floor(u2)
                    u2 -= floor(u2);
                    N[0] = unsigned(v0) - 3; // unsigned(v0) == floor(v0)
                    v0 -= floor(v0);
                    N[2] = N[1] = dwHeight - 4;
                    v2 = v1 = 1.0;

                    --k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(catrom, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2, tu0, tv0, tu1, tv1, tu2, tv2, false, false, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // right edge
            segs = unsigned(pPrimSegments[1]);
            k_outer = 0;
            k_inner = 1;
            outer_inc = v_segs - 2;
            inner_inc = segs;
            outer = 0;
            inner = 0;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer < segs))
            {
                if(inner < outer)
                {
                    _ASSERT(k_inner < v_segs - 1, "Error in logic");
                    u0 = double(u_range * (u_segs - 1)) / double(u_segs) + 3.0;
                    v0 = double(v_range * k_inner) / double(v_segs) + 3.0;
                    u1 = double(u_range + 3);
                    v1 = double(v_range * k_outer) / double(segs) + 3.0;
                    u2 = u0;
                    v2 = double(v_range * (k_inner + 1)) / double(v_segs) + 3.0;    
                    tu0 = double(u_segs - 1) / double(u_segs);
                    tv0 = double(k_inner) / double(v_segs);
                    tu1 = 1.0;
                    tv1 = double(k_outer) / double(segs);
                    tu2 = tu0;
                    tv2 = double(k_inner + 1) / double(v_segs);    

                    M[2] = M[0] = unsigned(u0) - 3; // unsigned(u0) == floor(u0)
                    u2 = u0 = u0 - floor(u0);
                    M[1] = dwWidth - 4;
                    u1 = 1.0;
                    N[0] = unsigned(v0) - 3; // unsigned(v0) == floor(v0)
                    v0 -= floor(v0);
                    if((v_range * k_outer) % segs == 0)
                    {
                        N[1] = unsigned(v1) - 4;
                        v1 = 1.0;
                    }
                    else
                    {
                        N[1] = unsigned(v1) - 3; // unsigned(v1) == floor(v1)
                        v1 -= floor(v1);
                    }
                    N[2] = unsigned(v2) - 3; // unsigned(v2) == floor(v2)
                    v2 -= floor(v2);

                    ++k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer < segs, "Error in logic");
                    u0 = double(u_range * (u_segs - 1)) / double(u_segs) + 3.0;
                    v0 = double(v_range * k_inner) / double(v_segs) + 3.0;
                    u1 = double(u_range + 3);
                    v1 = double(v_range * k_outer) / double(segs) + 3.0;
                    u2 = u1;
                    v2 = double(v_range * (k_outer + 1)) / double(segs) + 3.0;    
                    tu0 = double(u_segs - 1) / double(u_segs);
                    tv0 = double(k_inner) / double(v_segs);
                    tu1 = 1.0;
                    tv1 = double(k_outer) / double(segs);
                    tu2 = tu1;
                    tv2 = double(k_outer + 1) / double(segs);    

                    M[0] = unsigned(u0) - 3; // unsigned(u0) == floor(u0)
                    u0 -= floor(u0);
                    M[2] = M[1] = dwWidth - 4;
                    u2 = u1 = 1.0;
                    if((v_range * k_inner) % v_segs == 0)
                    {
                        N[0] = unsigned(v0) - 4;
                        v0 = 1.0;
                    }
                    else
                    {
                        N[0] = unsigned(v0) - 3; // unsigned(v0) == floor(v0)
                        v0 -= floor(v0);
                    }
                    N[1] = unsigned(v1) - 3; // unsigned(v1) == floor(v1)
                    v1 -= floor(v1);
                    if((v_range * (k_outer + 1)) % segs == 0)
                    {
                        N[2] = unsigned(v2) - 4;
                        v2 = 1.0;
                    }
                    else
                    {
                        N[2] = unsigned(v2) - 3; // unsigned(v2) == floor(v2)
                        v2 -= floor(v2);
                    }

                    ++k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(catrom, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2, tu0, tv0, tu1, tv1, tu2, tv2, false, false, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // left edge
            segs = unsigned(pPrimSegments[3]);
            k_outer = segs;
            k_inner = v_segs - 1;
            inner_inc = segs;
            outer = 0;
            inner = 0;
            while(outer_inc != 0 ? (inner != inner_inc * outer_inc || outer != inner_inc * outer_inc) : (k_outer > 0))
            {
                if(inner < outer)
                {
                    _ASSERT(k_inner > 1, "Error in logic");
                    u0 = double(u_range) / double(u_segs) + 3.0;
                    v0 = double(v_range * k_inner) / double(v_segs) + 3.0;
                    u1 = 0.0;
                    v1 = double(v_range * k_outer) / double(segs) + 3.0;
                    u2 = u0;
                    v2 = double(v_range * (k_inner - 1)) / double(v_segs) + 3.0;    
                    tu0 = 1.0 / double(u_segs);
                    tv0 = double(k_inner) / double(v_segs);
                    tu1 = 0.0;
                    tv1 = double(k_outer) / double(segs);
                    tu2 = tu0;
                    tv2 = double(k_inner - 1) / double(v_segs);    

                    M[2] = M[0] = unsigned(u0) - 3; // unsigned(u0) == floor(u0)
                    u2 = u0 = u0 - floor(u0);
                    M[1] = 0;
                    N[0] = unsigned(v0) - 3; // unsigned(v0) == floor(v0)
                    v0 -= floor(v0);
                    if((v_range * k_outer) % segs == 0)
                    {
                        N[1] = unsigned(v1) - 4;
                        v1 = 1.0;
                    }
                    else
                    {
                        N[1] = unsigned(v1) - 3; // unsigned(v1) == floor(v1)
                        v1 -= floor(v1);
                    }
                    N[2] = unsigned(v2) - 3; // unsigned(v2) == floor(v2)
                    v2 -= floor(v2);

                    --k_inner;
                    inner += inner_inc;
                }
                else
                {
                    _ASSERT(k_outer > 0, "Error in logic");
                    u0 = double(u_range) / double(u_segs) + 3.0;
                    v0 = double(v_range * k_inner) / double(v_segs) + 3.0;
                    u1 = 0.0;
                    v1 = double(v_range * k_outer) / double(segs) + 3.0;
                    u2 = u1;
                    v2 = double(v_range * (k_outer - 1)) / double(segs) + 3.0;    
                    tu0 = 1.0 / double(u_segs);
                    tv0 = double(k_inner) / double(v_segs);
                    tu1 = 0.0;
                    tv1 = double(k_outer) / double(segs);
                    tu2 = tu1;
                    tv2 = double(k_outer - 1) / double(segs);    

                    M[0] = unsigned(u0) - 3; // unsigned(u0) == floor(u0)
                    u0 -= floor(u0);
                    M[2] = M[1] = 0;
                    N[0] = unsigned(v0) - 3; // unsigned(v0) == floor(v0)
                    v0 -= floor(v0);
                    if((v_range * k_outer) % segs == 0)
                    {
                        N[1] = unsigned(v1) - 4;
                        v1 = 1.0;
                    }
                    else
                    {
                        N[1] = unsigned(v1) - 3; // unsigned(v1) == floor(v1)
                        v1 -= floor(v1);
                    }
                    N[2] = unsigned(v2) - 3; // unsigned(v2) == floor(v2)
                    v2 -= floor(v2);

                    --k_outer;
                    outer += outer_inc;
                }
                HRESULT hr = DrawTessTri(catrom, dwOffW, dwOffH, dwStride, M, N, u0, v0, u1, v1, u2, v2, tu0, tv0, tu1, tv1, tu2, tv2, false, false, false);
                if(FAILED(hr))
                {
                    return hr;
                }
            }
            // Now do the regular interior
            u_start = 1;
            v_start = 1;
        }
        else
        {
            // It can be done regularly
            u_start = 0;
            v_start = 0;
        }
    }
    else
    {
        unsigned segs = unsigned(GetRSf()[D3DRS_PATCHSEGMENTS]);
        if(segs == 0)
        {
            segs = 1;
        }
        u_start = 0;
        v_start = 0;
        u_segs = segs;
        v_segs = segs;
    }

    for(unsigned i = v_start; i < v_segs - v_start; ++i)
    {
        double v0 = double(v_range * i) / double(v_segs) + 3.0;
        double v1 = double(v_range * (i + 1)) / double(v_segs) + 3.0;
        N[1] = N[0] = unsigned(v0) - 3; // unsigned(v0) == floor(v0)
        if((v_range * (i + 1)) % v_segs == 0)
        {
            N[3] = N[2] = unsigned(v1) - 4;
            v1 = 1.0;
        }
        else
        {
            N[3] = N[2] = unsigned(v1) - 3; // unsigned(v1) == floor(v1)
            v1 -= floor(v1);
        }
        for(unsigned j = u_start; j < u_segs - u_start; ++j)
        {
            double u0 = (u_range * double(j)) / double(u_segs) + 3.0;    
            double u1 = (u_range * double(j + 1)) / double(u_segs) + 3.0;    
            M[3] = M[0] = unsigned(u0) - 3; // unsigned(u0) == floor(u0)
            if((u_range * (j + 1)) % u_segs == 0)
            {
                M[2] = M[1] = unsigned(u1) - 4;
                u1 = 1.0;
            }
            else
            {
                M[2] = M[1] = unsigned(u1) - 3; // unsigned(u1) == floor(u1)
                u1 -= floor(u1);
            }
            HRESULT hr = DrawTessQuad(catrom, dwOffW, dwOffH, dwStride, M, N, 
                                      u0 - floor(u0), v0 - floor(v0), u1, v1,
                                      double(j) / double(u_segs), double(i) / double(v_segs),
                                      double(j + 1) / double(u_segs), double(i + 1) / double(v_segs),
                                      false);
            if(FAILED(hr))
            {
                return hr;
            }
        }
    }

    return S_OK;
}

//-----------------------------------------------------------------------------
// RDCatRomSpline::Basis
//-----------------------------------------------------------------------------
double RDCatRomSpline::Basis(unsigned i, unsigned k, double t) const
{
    static const double lut[4][4] = {{-1.0/2.0, 3.0/2.0, -3.0/2.0, 1.0/2.0},
                                     {1.0, -5.0/2.0, 2.0, -1.0/2.0},
                                     {-1.0/2.0, 0.0, 1.0/2.0, 0.0},
                                     {0.0, 1.0, 0.0, 0.0}};    
    _ASSERT(i < 4, "Catmull-Rom spline can be only cubic");
    return t * t * t * lut[0][i] + t * t * lut[1][i] + t * lut[2][i] + lut[3][i];
}

//-----------------------------------------------------------------------------
// RDCatRomSpline::BasisPrime
//-----------------------------------------------------------------------------
double RDCatRomSpline::BasisPrime(unsigned i, unsigned k, double t) const
{
    static const double lut[3][4] = {{-3.0/2.0, 9.0/2.0, -9.0/2.0, 3.0/2.0},
                                     {2.0, -5.0, 4.0, -1.0},
                                     {-1.0/2.0, 0.0, 1.0/2.0, 0.0}};    
    _ASSERT(i < 4, "Catmull-Rom spline can be only cubic");
    return t * t * lut[0][i] + t * lut[1][i] + lut[2][i];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\hop\npatch.hpp ===
/*============================================================================
 *
 *  Copyright (C) 1999-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       npatch.hpp
 *  Content:    Declarations for n-Patch scheme
 *
 ****************************************************************************/

#ifndef _NPATCH_HPP
#define _NPATCH_HPP

class RDCubicBezierTriangle
{
public:
    void SamplePosition(double u, double v, FLOAT *Q) const;
    void Sample(DWORD dwDataType, double u, double v, const BYTE* const B[], BYTE *Q) const;

protected:
    double m_B[4][4][3];

private:
    unsigned factorial(unsigned k) const
    {
        _ASSERT(k < 13, "Factorial out of range");
        for(unsigned i = 1, t = 1; i <= k; t *= i++);
        return t;
    }

    double Basis(unsigned i, unsigned j, double u, double v) const
    {
        unsigned k = 3 - i - j;
        double w = 1.0 - u - v;
        _ASSERT(i + j + k == 3, "Barycentric coordinates need to add to 3");
        return (6.0 * pow(u, double(i)) * pow(v, double(j)) * pow(w, double(k))) / double(factorial(i) * factorial(j) * factorial(k));
    }

};

class RDNPatch : public RDCubicBezierTriangle
{
public:
    RDNPatch(const FLOAT* const pV[], const FLOAT* const pN[], 
             const DWORD PositionOrder, const DWORD NormalOrder);
    void SamplePosition(double u, double v, FLOAT *Q) const;
    void SampleNormal(double u, double v, const BYTE* const B[], FLOAT *Q) const;

private:
    void ComputeEdgeControlPoint(unsigned a, unsigned b, const FLOAT* const pV[], const FLOAT* const pN[], unsigned u, unsigned v);
    void ComputeNormalControlPoint(RDVECTOR3* cp, unsigned i, unsigned j,
                                   const FLOAT* const pV[], 
                                   const FLOAT* const pN[]);
    DWORD m_PositionOrder;
    DWORD m_NormalOrder;
    // Normal coefficients
    RDVECTOR3 m_N200;         
    RDVECTOR3 m_N020;         
    RDVECTOR3 m_N002;         
    RDVECTOR3 m_N110;         
    RDVECTOR3 m_N011;         
    RDVECTOR3 m_N101;         
};

class RRIndexAccessor
{
public:
    RRIndexAccessor(BYTE *pBuf, DWORD dwStride, DWORD dwStart)
    {
        _ASSERT(dwStride == 2 || dwStride == 4, "Unsupported indexbuffer stride");        
        m_pBuf = pBuf + dwStart * dwStride;
        m_32 = (dwStride == 4);
    }

    unsigned operator[](unsigned i) const
    {
        return m_32 ? ((DWORD*)m_pBuf)[i] : ((WORD*)m_pBuf)[i];
    }

private:
    VOID *m_pBuf;
    bool m_32;
};

#endif // _NPATCH_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\hop\pch.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// pch.cpp
//
// Precompiled header file.
//
///////////////////////////////////////////////////////////////////////////////
#include "refdev.hpp"

#include "bspline.hpp"
#include "bezier.hpp"
#include "npatch.hpp"
#include "catrom.hpp"
///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\hop\sources.inc ===
TARGETNAME = refhop
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES)

SOURCES = \
        ..\drawgrid.cpp  \
        ..\bspline.cpp \
        ..\bezier.cpp \
        ..\npatch.cpp \
        ..\catrom.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\inc\rdcomm.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// rdcomm.hpp
//
// Direct3D Reference Device - Common Header
//
///////////////////////////////////////////////////////////////////////////////
#ifndef  _RDCOMM_HPP
#define  _RDCOMM_HPP

#include <math.h>

#ifndef FASTCALL
#ifdef _X86_
#define FASTCALL __fastcall
#else
#define FASTCALL
#endif
#endif

#ifndef CDECL
#ifdef _X86_
#define CDECL __cdecl
#else
#define CDECL
#endif
#endif

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Globals                                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// memory allocation callbacks
extern LPVOID (__cdecl *g_pfnMemAlloc)( size_t size );
extern void   (__cdecl *g_pfnMemFree)( LPVOID lptr );
extern LPVOID (__cdecl *g_pfnMemReAlloc)( LPVOID ptr, size_t size );

// debug print controls
extern int g_iDPFLevel;
extern unsigned long g_uDPFMask;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Typedefs                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#ifndef DllExport
#define DllExport   __declspec( dllexport )
#endif

// width-specific typedefs for basic types
//@@BEGIN_MSINTERNAL
#ifndef _BASETSD_H_
//@@END_MSINTERNAL
typedef signed char             INT8, *PINT8;
typedef short int               INT16, *PINT16;
typedef int                     INT32, *PINT32;
typedef __int64                 INT64, *PINT64;
typedef unsigned char           UINT8, *PUINT8;
typedef unsigned short int      UINT16, *PUINT16;
typedef unsigned int            UINT32, *PUINT32;
typedef unsigned __int64        UINT64, *PUINT64;
//@@BEGIN_MSINTERNAL
#endif
//@@END_MSINTERNAL

typedef float                   FLOAT;
typedef double                  DOUBLE;
typedef int                     BOOL;
typedef FLOAT                  *PFLOAT;
typedef DOUBLE                 *PDOUBLE;

struct RDVECTOR4
{
    RDVECTOR4()
    {
        memset( this, 0, sizeof( *this ) );
    }
    union
    {
        struct
        {
            union
            {
                D3DVALUE x;
                D3DVALUE r;
            };
            union
            {
                D3DVALUE y;
                D3DVALUE g;
            };
            union
            {
                D3DVALUE z;
                D3DVALUE b;
            };
            union
            {
                D3DVALUE w;
                D3DVALUE a;
            };
        };
        D3DVALUE v[4];
    };
};

struct RDVECTOR3
{
    RDVECTOR3()
    {
        memset( this, 0, sizeof( *this ) );
    }

    union
    {
        struct
        {
            D3DVALUE x;
            D3DVALUE y;
            D3DVALUE z;
        };
        D3DVALUE v[3];
    };
};

struct RDCOLOR3
{
    // 0 - 255
    D3DVALUE r,g,b;
};

struct RDCOLOR4
{
    // Normalized 0 - 1
    D3DVALUE r,g,b,a;
};

struct RDLIGHTINGELEMENT
{
    RDVECTOR3 dvPosition;
    RDVECTOR3 dvNormal;
};


//-----------------------------------------------------------------------------
//
// Surface formats for rendering surfaces and textures.  Different subsets are
// supported for render targets and for textures.
//
//-----------------------------------------------------------------------------
typedef enum _RDSurfaceFormat
{
    RD_SF_NULL     = 0,
    RD_SF_B8G8R8   = 1,
    RD_SF_B8G8R8A8 = 2,
    RD_SF_B8G8R8X8 = 3,
    RD_SF_B5G6R5   = 4,
    RD_SF_B5G5R5A1 = 5,
    RD_SF_B5G5R5X1 = 6,
    RD_SF_PALETTE4 = 7,
    RD_SF_PALETTE8 = 8,
    RD_SF_B4G4R4A4 = 9,
    RD_SF_B4G4R4X4 =10,
    RD_SF_L8       =11,          // 8 bit luminance-only
    RD_SF_L8A8     =12,          // 16 bit alpha-luminance
    RD_SF_U8V8     =13,          // 16 bit bump map format
    RD_SF_U5V5L6   =14,          // 16 bit bump map format with luminance
    RD_SF_U8V8L8X8 =15,          // 32 bit bump map format with luminance
    RD_SF_UYVY     =16,          // UYVY format (PC98 compliance)
    RD_SF_YUY2     =17,          // YUY2 format (PC98 compliance)
    RD_SF_DXT1     =18,          // DXT texture compression technique 1
    RD_SF_DXT2     =19,          // DXT texture compression technique 2
    RD_SF_DXT3     =20,          // DXT texture compression technique 3
    RD_SF_DXT4     =21,          // DXT texture compression technique 4
    RD_SF_DXT5     =22,          // DXT texture compression technique 5
    RD_SF_B2G3R3   =23,          // 8 bit RGB texture format
    RD_SF_L4A4     =24,          // 8 bit alpha-luminance
    RD_SF_B2G3R3A8 =25,          // 16 bit alpha-rgb
    RD_SF_U16V16   =26,          // 32 bit bump map format
    RD_SF_U10V11W11=27,          // 32 bit signed format for custom data
    RD_SF_U8V8W8Q8 =28,          // 32 bit signed format for custom data
    RD_SF_A8       =29,          // 8 bit alpha only
    RD_SF_P8A8     =30,          // 8 bit alpha + 8 bit palette

    // The following have been introduced in DX 8.1
    // The byte ordering is opposite to that in the D3DFORMAT_*
    // definition, so RD_SF_R8G8B8A8 here corresponds to D3DFORMAT_A8B8G8R8
    // hence the DWORD contains AAAAAAAABBBBBBBBGGGGGGGGRRRRRRRR
    // This is not true for the Depth formats.

    RD_SF_R10G10B10A2      = 31, 
    RD_SF_R8G8B8A8         = 32,
    RD_SF_R8G8B8X8         = 33,
    RD_SF_R16G16           = 34,
    RD_SF_U11V11W10        = 35,
    RD_SF_U10V10W10A2      = 36,
    RD_SF_U8V8X8A8         = 37,
    RD_SF_U8V8X8L8         = 38,

    RD_SF_Z16S0    =70,
    RD_SF_Z24S8    =71,
    RD_SF_Z24X8    =72,
    RD_SF_Z15S1    =73,
    RD_SF_Z32S0    =74,
    RD_SF_S1Z15    =75,
    RD_SF_S8Z24    =76,
    RD_SF_X8Z24    =77,
    RD_SF_Z24X4S4  =78,
    RD_SF_X4S4Z24  =79,

} RDSurfaceFormat;

// compute pixel address from x,y location, sample number, and surface info
char*
PixelAddress( int iX, int iY, int iZ, BYTE* pBits, int iYPitch, int iZPitch, RDSurfaceFormat SType );

class RDSurface2D;

char*
PixelAddress( int iX, int iY, int iZ, int iSample, RDSurface2D* pRT );

// The most general pixel address calculation
char*
PixelAddress( int iX, int iY, int iZ, int iSample, BYTE* pBits, int iYPitch, int iZPitch, int cSamples,
              RDSurfaceFormat SType );

//---------------------------------------------------------------------
// Inline functions to answer various questions about surface formats.
//---------------------------------------------------------------------
inline BOOL
IsDXTn( DWORD dwFourCC )
{
    return ((dwFourCC == MAKEFOURCC('D', 'X', 'T', '1')) ||
            (dwFourCC == MAKEFOURCC('D', 'X', 'T', '2')) ||
            (dwFourCC == MAKEFOURCC('D', 'X', 'T', '3')) ||
            (dwFourCC == MAKEFOURCC('D', 'X', 'T', '4')) ||
            (dwFourCC == MAKEFOURCC('D', 'X', 'T', '5')));
}

inline BOOL
IsYUV( DWORD dwFourCC )
{
    return ((dwFourCC == MAKEFOURCC('U', 'Y', 'V', 'Y')) ||
            (dwFourCC == MAKEFOURCC('Y', 'U', 'Y', '2')));
}

//---------------------------------------------------------------------
// This class manages growing buffer, aligned to 32 byte boundary
// Number if bytes should be power of 2.
// D3DMalloc is used to allocate memory
//---------------------------------------------------------------------

class RefAlignedBuffer32
{
public:
    RefAlignedBuffer32()  {m_size = 0; m_allocatedBuf = 0; m_alignedBuf = 0;}
    ~RefAlignedBuffer32() {if (m_allocatedBuf) free(m_allocatedBuf);}
    // Returns aligned buffer address
    LPVOID GetAddress() {return m_alignedBuf;}
    // Returns aligned buffer size
    DWORD GetSize() {return m_size;}
    HRESULT Grow(DWORD dwSize);
    HRESULT CheckAndGrow(DWORD dwSize)
    {
        if (dwSize > m_size)
            return Grow(dwSize + 1024);
        else
            return S_OK;
    }
protected:
    LPVOID m_allocatedBuf;
    LPVOID m_alignedBuf;
    DWORD  m_size;
};

//-----------------------------------------------------------------------------
//
// Private FVF flags
//
//-----------------------------------------------------------------------------
#define D3DFVFP_FOG           ((UINT64)1<<32) // Fog is present
#define D3DFVFP_CLIP          ((UINT64)1<<33) // Clip coordinates are present
#define D3DFVFP_POSITION2     ((UINT64)1<<34) // Position2 present (tweening)
#define D3DFVFP_NORMAL2       ((UINT64)1<<35) // Normal2 present (tweening)
#define D3DFVFP_BLENDINDICES  ((UINT64)1<<36) // Blend Indices present.

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Macros                                                                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif

#ifndef NULL
#define NULL 0
#endif

#define MAX(a,b)  (((a) > (b)) ? (a) : (b))
#define MIN(a,b)  (((a) < (b)) ? (a) : (b))
#define ABS(a) (((a) < 0) ? (-(a)) : (a))

// Check the return value and return if something wrong.
// Assume hr has been declared
#define HR_RET(exp)                                                           \
{                                                                             \
    hr = (exp);                                                               \
    if (hr != S_OK)                                                         \
    {                                                                         \
        return hr;                                                            \
    }                                                                         \
}

//-----------------------------------------------------------------------------
// macros for converting n-bit signed integers to floats clamped to [-1.0, 1.0]
//
// e.g. For an 8 bit number, if it is -128, it gets clamped to -127.
//      Then the number is divided by 127.
//
//-----------------------------------------------------------------------------

inline FLOAT CLAMP_SIGNED16(INT16 i)
{
    return (-32768 == i ? -1.f : (FLOAT)i/32767.f);
}

inline FLOAT CLAMP_SIGNED11(INT16 i) //only looks at bottom 11 bits
{
    // sign extend to 16 bits
    i <<= 5; i >>= 5;
    return (-1024 == i ? -1.f : (FLOAT)i/1023.f);
}

inline FLOAT CLAMP_SIGNED10(INT16 i) //only looks at bottom 10 bits
{
    // sign extend to 16 bits
    i <<= 6; i >>= 6;
    return (-512 == i ? -1.f : (FLOAT)i/511.f);
}

inline FLOAT CLAMP_SIGNED8(INT8 i)
{
    return (-128 == i ? -1.f : (FLOAT)i/127.f);
}

inline FLOAT CLAMP_SIGNED6(INT8 i) //only looks at bottom 6 bits
{
    // sign extend to 8 bits
    i <<= 2; i >>= 2;
    return (-32 == i ? -1.f : (FLOAT)i/31.f);
}

inline FLOAT CLAMP_SIGNED5(INT8 i) //only looks at bottom 5 bits
{
    // sign extend to 8 bits
    i <<= 3; i >>= 3;
    return (-16 == i ? -1.f : (FLOAT)i/15.f);
}

inline FLOAT CLAMP_SIGNED4(INT8 i)  //only looks at bottom 4 bits
{
    // sign extend to 8 bits
    i <<= 4; i >>= 4;
    return (-8 == i ? -1.f : (FLOAT)i/7.f);
}

//-----------------------------------------------------------------------------
//
// macros for accessing floating point data as 32 bit integers and vice versa
//
// This is used primarily to do floating point to fixed point conversion with
// the unbiased nearest-even rounding that IEEE floating point does internally
// between operations.  Adding a big number slides the mantissa down to where
// the fixed point equivalent is aligned to the LSB.  IEEE applies a nearest-
// even round to the bits it lops off before storing.  The mantissa can then
// be grabbed by the AS_INT* operations.  Note that the sign and exponent are
// still there, so the easiest thing is to do it with doubles and grab the low
// 32 bits.
//
// The snap values (i.e. the "big number") is the sum of 2**n and 2**(n-1),
// which makes the trick return signed numbers (at least within the mantissa).
//
//-----------------------------------------------------------------------------

#if 0
// NOTE: vc5 optimizing compiler bug breaks this pointer casting technique
#define AS_FLOAT(i) ( *(FLOAT*)&(i) )
#define AS_INT32(f) ( *(INT32*)&(f) )
#define AS_INT16(f) ( *(INT16*)&(f) )
#define AS_UINT32(f) ( *(UINT32*)&(f) )

#else

// workaround using union
typedef union { float f; UINT32 u; INT32 i; } VAL32;
typedef union { double d; UINT64 u; INT64 i; } VAL64;
inline FLOAT AS_FLOAT( long int iVal ) { VAL32 v; v.i = iVal; return v.f; }
inline FLOAT AS_FLOAT( unsigned long int uVal ) { VAL32 v; v.u = uVal; return v.f; }
inline INT32 AS_INT32(  FLOAT fVal ) { VAL32 v; v.f = fVal; return v.i; }
inline INT32 AS_INT32( DOUBLE dVal ) { VAL64 v; v.d = dVal; return (INT32)(v.u & 0xffffffff); }
inline INT16 AS_INT16(  FLOAT fVal ) { VAL32 v; v.f = fVal; return (INT16)(v.u & 0xffff); }
inline INT16 AS_INT16( DOUBLE dVal ) { VAL64 v; v.d = dVal; return (INT16)(v.u & 0xffff); }
inline INT32 AS_UINT32( FLOAT fVal ) { VAL32 v; v.f = fVal; return v.u; }

#endif

//-----------------------------------------------------------------------------
//
// Some common FP values as constants
// point values
//
//-----------------------------------------------------------------------------
#define g_fZero                 (0.0f)
#define g_fOne                  (1.0f)

// Integer representation of 1.0f.
#define INT32_FLOAT_ONE         0x3f800000

const D3DVALUE __HUGE_PWR2 = 1024.0f*1024.0f*2.0f;

//-----------------------------------------------------------------------------
//
// these are handy to form 'magic' constants to snap real values to fixed
// point values
//
//-----------------------------------------------------------------------------
#define C2POW0 1
#define C2POW1 2
#define C2POW2 4
#define C2POW3 8
#define C2POW4 16
#define C2POW5 32
#define C2POW6 64
#define C2POW7 128
#define C2POW8 256
#define C2POW9 512
#define C2POW10 1024
#define C2POW11 2048
#define C2POW12 4096
#define C2POW13 8192
#define C2POW14 16384
#define C2POW15 32768
#define C2POW16 65536
#define C2POW17 131072
#define C2POW18 262144
#define C2POW19 524288
#define C2POW20 1048576
#define C2POW21 2097152
#define C2POW22 4194304
#define C2POW23 8388608
#define C2POW24 16777216
#define C2POW25 33554432
#define C2POW26 67108864
#define C2POW27 134217728
#define C2POW28 268435456
#define C2POW29 536870912
#define C2POW30 1073741824
#define C2POW31 2147483648
#define C2POW32 4294967296
#define C2POW33 8589934592
#define C2POW34 17179869184
#define C2POW35 34359738368
#define C2POW36 68719476736
#define C2POW37 137438953472
#define C2POW38 274877906944
#define C2POW39 549755813888
#define C2POW40 1099511627776
#define C2POW41 2199023255552
#define C2POW42 4398046511104
#define C2POW43 8796093022208
#define C2POW44 17592186044416
#define C2POW45 35184372088832
#define C2POW46 70368744177664
#define C2POW47 140737488355328
#define C2POW48 281474976710656
#define C2POW49 562949953421312
#define C2POW50 1125899906842624
#define C2POW51 2251799813685248
#define C2POW52 4503599627370496

#define FLOAT_0_SNAP    (FLOAT)(C2POW23+C2POW22)
#define FLOAT_4_SNAP    (FLOAT)(C2POW19+C2POW18)
#define FLOAT_5_SNAP    (FLOAT)(C2POW18+C2POW17)
#define FLOAT_8_SNAP    (FLOAT)(C2POW15+C2POW14)
#define FLOAT_17_SNAP   (FLOAT)(C2POW6 +C2POW5 )
#define FLOAT_18_SNAP   (FLOAT)(C2POW5 +C2POW4 )

#define DOUBLE_0_SNAP   (DOUBLE)(C2POW52+C2POW51)
#define DOUBLE_4_SNAP   (DOUBLE)(C2POW48+C2POW47)
#define DOUBLE_5_SNAP   (DOUBLE)(C2POW47+C2POW46)
#define DOUBLE_8_SNAP   (DOUBLE)(C2POW44+C2POW43)
#define DOUBLE_17_SNAP  (DOUBLE)(C2POW35+C2POW34)
#define DOUBLE_18_SNAP  (DOUBLE)(C2POW34+C2POW33)

//-----------------------------------------------------------------------------
//
// Floating point related macros
//
//-----------------------------------------------------------------------------
#define COSF(fV)        ((FLOAT)cos((double)(fV)))
#define SINF(fV)        ((FLOAT)sin((double)(fV)))
#define SQRTF(fV)       ((FLOAT)sqrt((double)(fV)))
#define POWF(fV, fE)    ((FLOAT)pow((double)(fV), (double)(fE)))

#ifdef _X86_
#define FLOAT_CMP_POS(fa, op, fb)       (AS_INT32(fa) op AS_INT32(fb))
#define FLOAT_CMP_PONE(flt, op)         (AS_INT32(flt) op INT32_FLOAT_ONE)

__inline int FLOAT_GTZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return fi.i > 0;
}
__inline int FLOAT_LTZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return fi.u > 0x80000000;
}
__inline int FLOAT_GEZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return fi.u <= 0x80000000;
}
__inline int FLOAT_LEZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return fi.i <= 0;
}
__inline int FLOAT_EQZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) == 0;
}
__inline int FLOAT_NEZ(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    return (fi.u & 0x7fffffff) != 0;
}

// Strip sign bit in integer.
__inline FLOAT
ABSF(FLOAT f)
{
    VAL32 fi;
    fi.f = f;
    fi.u &= 0x7fffffff;
    return fi.f;
}

// Requires chop rounding.
__inline INT
FTOI(FLOAT f)
{
    LARGE_INTEGER i;

    __asm
    {
        fld f
        fistp i
    }

    return i.LowPart;
}

#else

#define FLOAT_GTZ(flt)                  ((flt) > g_fZero)
#define FLOAT_LTZ(flt)                  ((flt) < g_fZero)
#define FLOAT_GEZ(flt)                  ((flt) >= g_fZero)
#define FLOAT_LEZ(flt)                  ((flt) <= g_fZero)
#define FLOAT_EQZ(flt)                  ((flt) == g_fZero)
#define FLOAT_NEZ(flt)                  ((flt) != g_fZero)
#define FLOAT_CMP_POS(fa, op, fb)       ((fa) op (fb))
#define FLOAT_CMP_PONE(flt, op)         ((flt) op g_fOne)

#define ABSF(f)                 ((FLOAT)fabs((double)(f)))
#define FTOI(f)                 ((INT)(f))

#endif // _X86_



//-----------------------------------------------------------------------------
//
// macro wrappers for memory allocation - wrapped around global function ptrs
// set by RefRastSetMemif
//
//-----------------------------------------------------------------------------
#define MEMALLOC(_size)         ((*g_pfnMemAlloc)(_size))
#define MEMFREE(_ptr)           { if (NULL != (_ptr)) { ((*g_pfnMemFree)(_ptr)); } }
#define MEMREALLOC(_ptr,_size)  ((*g_pfnMemReAlloc)((_ptr),(_size)))


//////////////////////////////////////////////////////////////////////////////////
//                                                                              //
// Utility Functions                                                            //
//                                                                              //
//////////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Base class for all RefTnL classes to use common allocation functions
//
//-----------------------------------------------------------------------------
class RDAlloc
{
public:
    void* operator new(size_t s);
    void operator delete(void* p, size_t);
};

//-----------------------------------------------------------------------------
//
// debug printf support
//
//-----------------------------------------------------------------------------

void RDDebugPrintfL( int iLevel, const char* pszFormat, ... );
void RDDebugPrintf( const char* pszFormat, ... );
void RDErrorPrintf( const char* pszFormat, ... );

#define _DPF_IF     0x0001
#define _DPF_INPUT  0x0002
#define _DPF_SETUP  0x0004
#define _DPF_RAST   0x0008
#define _DPF_TEX    0x0010
#define _DPF_PIX    0x0020
#define _DPF_FRAG   0x0040
#define _DPF_STATS  0x0080
#define _DPF_DRV    0x0100
#define _DPF_TNL    0x0200
#define _DPF_VS     0x0400
#define _DPF_VVM    0x0800
#define _DPF_ANY    0xffff
#define _DPF_TEMP   0x8000

#ifdef DBG
    #define DPFERR RDErrorPrintf
    #define DPFRR RDDebugPrintfL
    #define DPFM( _level, _mask, _message) \
        if ((g_iDPFLevel >= (_level)) && (g_uDPFMask & (_DPF_##_mask))) { \
            RDDebugPrintf ## _message; \
        }
    #define DPFINFO RDDebugPrintf
#else
    #pragma warning(disable:4002)
    #define DPFERR
    #define DPFRR()
    #define DPFM( _level, _mask, _message)
    #define DPFINFO
#endif



//-----------------------------------------------------------------------------
//
// assert macros and reporting functions
//
//-----------------------------------------------------------------------------

// ASSERT with simple string
#undef _ASSERT
#define _ASSERT( value, string )                  \
if ( !(value) ) {                                 \
    RDAssertReport( string, __FILE__, __LINE__ ); \
}
// ASSERT with formatted string - note extra parenthesis on report
// usage: _ASSERTf(foo,("foo is %d",foo))
#undef _ASSERTf
#define _ASSERTf(value,report)                      \
if (!(value)) {                                     \
    char __sz__FILE__[] = __FILE__;                 \
    RDAssertReportPrefix(__sz__FILE__,__LINE__);   \
    RDAssertReportMessage ## report;               \
}
// ASSERT with action field
#undef _ASSERTa
#define _ASSERTa(value,string,action)       \
if (!(value)) {                             \
    RDAssertReport(string,__FILE__,__LINE__); \
    action                                  \
}
// ASSERTf with action field
#undef _ASSERTfa
#define _ASSERTfa(value,report,action)     \
if (!(value)) {                            \
    RDAssertReportPrefix(__FILE__,__LINE__); \
    RDAssertReportMessage ## report;         \
    action                                 \
}

extern void RDAssertReport( const char* pszString, const char* pszFile, int iLine );
extern void RDAssertReportPrefix( const char* pszFile, int iLine );
extern void RDAssertReportMessage( const char* pszFormat, ... );


//-----------------------------------------------------------------------------
//
// bit twiddling utilities
//
//-----------------------------------------------------------------------------

extern INT32 CountSetBits( UINT32 uVal, INT32 nBits );
extern INT32 FindFirstSetBit( UINT32 uVal, INT32 nBits );
extern INT32 FindMostSignificantSetBit( UINT32 uVal, INT32 nBits );
extern INT32 FindLastSetBit( UINT32 uVal, INT32 nBits );

// TRUE if integer is a power of 2
inline BOOL IsPowerOf2( INT32 i )
{
    if ( i <= 0 ) return 0;
    return ( 0x0 == ( i & (i-1) ) );
}


//-----------------------------------------------------------------------------
//
// multiply/add routines & macros for unsigned 8 bit values, signed 16 bit values
//
// These are not currently used, but the Mult8x8Scl is an interesting routine
// for hardware designers to look at.  This does a 8x8 multiply combined with
// a 256/255 scale which accurately solves the "0xff * value = value" issue.
// There are refinements on this (involving half-adders) which are not easily
// representable in C.  Credits to Steve Gabriel and Jim Blinn.
//
//-----------------------------------------------------------------------------

// straight 8x8 unsigned multiply returning 8 bits, tossing fractional
// bits (no rounding)
inline UINT8 Mult8x8( const UINT8 uA, const UINT8 uB )
{
    UINT16 uA16 = (UINT16)uA;
    UINT16 uB16 = (UINT16)uB;
    UINT16 uRes16 = uA16*uB16;
    UINT8  uRes8 = (UINT8)(uRes16>>8);
    return uRes8;
}

// 8x8 unsigned multiply with ff*val = val scale adjustment (scale by (256/255))
inline UINT8 Mult8x8Scl( const UINT8 uA, const UINT8 uB )
{
    UINT16 uA16 = (UINT16)uA;
    UINT16 uB16 = (UINT16)uB;
    UINT16 uRes16 = uA16*uB16;
    uRes16 += 0x0080;
    uRes16 += (uRes16>>8);
    UINT8  uRes8 = (UINT8)(uRes16>>8);
    return uRes8;
}

// 8x8 saturated addition - result > 0xff returns 0xff
inline UINT8 SatAdd8x8( const UINT8 uA, const UINT8 uB )
{
    UINT16 uA16 = (UINT16)uA;
    UINT16 uB16 = (UINT16)uB;
    UINT16 uRes16 = uA16+uB16;
    UINT8  uRes8 = (uRes16 > 0xff) ? (0xff) : ((UINT8)uRes16);
    return uRes8;
}

//----------------------------------------------------------------------------
//
// IntLog2
//
// Do a quick, integer log2 for exact powers of 2.
//
//----------------------------------------------------------------------------
inline UINT32 FASTCALL
IntLog2(UINT32 x)
{
    UINT32 y = 0;

    x >>= 1;
    while(x != 0)
    {
        x >>= 1;
        y++;
    }

    return y;
}
//////////////////////////////////////////////////////////////////////////////
// FVF related macros
//////////////////////////////////////////////////////////////////////////////
#define FVF_TRANSFORMED(dwFVF) ((dwFVF & D3DFVF_POSITION_MASK) == D3DFVF_XYZRHW)
#define FVF_TEXCOORD_NUMBER(dwFVF) \
    (((dwFVF) & D3DFVF_TEXCOUNT_MASK) >> D3DFVF_TEXCOUNT_SHIFT)


//////////////////////////////////////////////////////////////////////////////
// State Override Macros
//////////////////////////////////////////////////////////////////////////////
#define IS_OVERRIDE(type)   ((DWORD)(type) > D3DSTATE_OVERRIDE_BIAS)
#define GET_OVERRIDE(type)  ((DWORD)(type) - D3DSTATE_OVERRIDE_BIAS)

#define STATESET_MASK(set, state)       \
    (set).bits[((state) - 1) >> RRSTATEOVERRIDE_DWORD_SHIFT]

#define STATESET_BIT(state)     (1 << (((state) - 1) & (RRSTATEOVERRIDE_DWORD_BITS - 1)))

#define STATESET_ISSET(set, state) \
    STATESET_MASK(set, state) & STATESET_BIT(state)

#define STATESET_SET(set, state) \
    STATESET_MASK(set, state) |= STATESET_BIT(state)

#define STATESET_CLEAR(set, state) \
    STATESET_MASK(set, state) &= ~STATESET_BIT(state)

#define STATESET_INIT(set)      memset(&(set), 0, sizeof(set))

//---------------------------------------------------------------------
// GetVertexCount
//---------------------------------------------------------------------
__inline DWORD
GetVertexCount( D3DPRIMITIVETYPE primType, DWORD cPrims )
{
    switch( primType )
    {
    case D3DPT_POINTLIST:
        return cPrims;
    case D3DPT_LINELIST:
        return cPrims * 2;
    case D3DPT_LINESTRIP:
        return cPrims + 1;
    case D3DPT_TRIANGLELIST:
        return cPrims * 3;
    case D3DPT_TRIANGLESTRIP:
        return cPrims + 2;
    case D3DPT_TRIANGLEFAN:
        return cPrims + 2;
    }
    return 0;
}


//---------------------------------------------------------------------
// GetTexCoordDim:
//     Computes the dimensionality of the given TexCoord in an FVF
//---------------------------------------------------------------------
#ifndef D3DFVF_GETTEXCOORDSIZE
#define D3DFVF_GETTEXCOORDSIZE(FVF, CoordIndex) ((FVF >> (CoordIndex*2 + 16)) & 0x3)
#endif

inline DWORD GetTexCoordDim( UINT64 FVF, DWORD Index)
{
    DWORD dwFVF = (DWORD)FVF;
    DWORD numTex = FVF_TEXCOORD_NUMBER(dwFVF);

    if( (numTex == 0) || (Index >= numTex ) ) return 0;

    switch( D3DFVF_GETTEXCOORDSIZE(FVF, Index) )
    {
    case D3DFVF_TEXTUREFORMAT1: return 1; break;
    case D3DFVF_TEXTUREFORMAT2: return 2; break;
    case D3DFVF_TEXTUREFORMAT3: return 3; break;
    case D3DFVF_TEXTUREFORMAT4: return 4; break;
    }
    return 0;
}

//---------------------------------------------------------------------
// GetFVFVertexSize:
//     Computes total vertex size in bytes for given fvf
//     including the texture coordinates
//---------------------------------------------------------------------
__inline DWORD
GetFVFVertexSize( UINT64 qwFVF )
{
    // Texture formats size  00   01   10   11
    static DWORD dwTextureSize[4] = {2*4, 3*4, 4*4, 4};

    DWORD dwSize = 3 << 2;
    switch( qwFVF & D3DFVF_POSITION_MASK )
    {
    case D3DFVF_XYZRHW: dwSize += 4;      break;
    case D3DFVF_XYZB1:  dwSize += 1*4;    break;
    case D3DFVF_XYZB2:  dwSize += 2*4;    break;
    case D3DFVF_XYZB3:  dwSize += 3*4;    break;
    case D3DFVF_XYZB4:  dwSize += 4*4;    break;
    case D3DFVF_XYZB5:  dwSize += 5*4;    break;
    }
    if (qwFVF & D3DFVF_NORMAL)
        dwSize += 3*4;
    if (qwFVF & D3DFVF_PSIZE)
        dwSize += 4;

    if (qwFVF & D3DFVF_DIFFUSE)
        dwSize += 4;
    if (qwFVF & D3DFVF_SPECULAR)
        dwSize += 4;
    if (qwFVF & D3DFVF_FOG)
        dwSize += 4;

    // Texture coordinates
    DWORD dwNumTexCoord = (DWORD)(FVF_TEXCOORD_NUMBER(qwFVF));
    DWORD dwTextureFormats = (DWORD)qwFVF >> 16;
    if (dwTextureFormats == 0)
    {
        dwSize += dwNumTexCoord * 2 * 4;
    }
    else
    {
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {

            // dwSize += GetTexCoordDim( qwFVF, i ) * sizeof( float);
            dwSize += dwTextureSize[dwTextureFormats & 3];
            dwTextureFormats >>= 2;
        }
    }

    return dwSize;
}

#if 0
//---------------------------------------------------------------------
// ComputeTextureCoordSize:
// Computes the following device data
//  - bTextureCoordSizeTotal
//  - bTextureCoordSize[] array, based on the input FVF id
//---------------------------------------------------------------------
__inline void ComputeTextureCoordInfo( DWORD dwFVF,
                                       LPDWORD pdwNumTexCoord,
                                       LPDWORD pdwTexCoordSizeArray )
{
    // Texture formats size  00   01   10   11
    static BYTE bTextureSize[4] = {2*4, 3*4, 4*4, 4};

    DWORD dwNumTexCoord = FVF_TEXCOORD_NUMBER(dwFVF);
    *pdwNumTexCoord = dwNumTexCoord;

    // Compute texture coordinate size
    DWORD dwTextureFormats = dwFVF >> 16;
    if (dwTextureFormats == 0)
    {
        for (DWORD i=0; i < dwNumTexCoord; i++)
            pdwTexCoordSizeArray[i] = 4*2;
    }
    else
    {
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            BYTE dwSize = bTextureSize[dwTextureFormats & 3];
            pdwTexCoordSizeArray[i] = dwSize;
            dwTextureFormats >>= 2;
        }
    }
    return;
}
#endif

HRESULT
RDFVFCheckAndStride( DWORD dwFVF, DWORD* pdwStride );

///////////////////////////////////////////////////////////////////////////////
// Matrix and Vector routines
///////////////////////////////////////////////////////////////////////////////

inline void
ReverseVector(const RDVECTOR3 &in, RDVECTOR3 &out)
{
    out.x = -in.x;
    out.y = -in.y;
    out.z = -in.z;
}

inline void
AddVector(const RDVECTOR3 &v1, const RDVECTOR3 &v2, RDVECTOR3 &out)
{
    out.x = v1.x + v2.x;
    out.y = v1.y + v2.y;
    out.z = v1.z + v2.z;
}

inline void
SubtractVector(const RDVECTOR3 &v1, const RDVECTOR3 &v2, RDVECTOR3 &out)
{
    out.x = v1.x - v2.x;
    out.y = v1.y - v2.y;
    out.z = v1.z - v2.z;
}

inline RDVECTOR3&
ScaleVector(RDVECTOR3 &v, FLOAT scale)
{
    v.x = v.x * scale;
    v.y = v.y * scale;
    v.z = v.z * scale;
    return v;
}

inline void
SetIdentity(D3DMATRIX &m)
{
    m._11 = m._22 = m._33 = m._44 = 1.0f;
    m._12 = m._13 = m._14 = 0.0f;
    m._21 = m._23 = m._24 = 0.0f;
    m._31 = m._32 = m._34 = 0.0f;
    m._41 = m._42 = m._43 = 0.0f;
}


inline void
SetNull(D3DMATRIX &m)
{
    m._11 = m._22 = m._33 = m._44 = 0.0f;
    m._12 = m._13 = m._14 = 0.0f;
    m._21 = m._23 = m._24 = 0.0f;
    m._31 = m._32 = m._34 = 0.0f;
    m._41 = m._42 = m._43 = 0.0f;
}


inline void
CopyMatrix(D3DMATRIX &s, D3DMATRIX &d)
{
    d._11 = s._11;
    d._12 = s._12;
    d._13 = s._13;
    d._14 = s._14;
    d._21 = s._21;
    d._22 = s._22;
    d._23 = s._23;
    d._24 = s._24;
    d._31 = s._31;
    d._32 = s._32;
    d._33 = s._33;
    d._34 = s._34;
    d._41 = s._41;
    d._42 = s._42;
    d._43 = s._43;
    d._44 = s._44;
}

inline D3DVALUE
SquareMagnitude (const RDVECTOR3& v)
{
    return v.x*v.x + v.y*v.y + v.z*v.z;
}


inline D3DVALUE
Magnitude (const RDVECTOR3& v)
{
    return (D3DVALUE) sqrt(SquareMagnitude(v));
}

inline RDVECTOR3
Normalize (const RDVECTOR3& v)
{
    RDVECTOR3 nv;
    D3DVALUE mag = Magnitude(v);

    if( FLOAT_NEZ( mag ) )
    {
        nv.x = v.x/mag;
        nv.y = v.y/mag;
        nv.z = v.z/mag;
    }

    return nv;
}

inline void
Normalize (RDVECTOR3& v)
{
    D3DVALUE mag = Magnitude(v);

    if( FLOAT_NEZ( mag ) )
    {
        v.x = v.x/mag;
        v.y = v.y/mag;
        v.z = v.z/mag;
    }
    else
    {
        v.x = v.y = v.z = 0.0f;
    }

    return;
}

inline RDVECTOR3
CrossProduct (const RDVECTOR3& v1, const RDVECTOR3& v2)
{
        RDVECTOR3 result;

        result.x = v1.y*v2.z - v1.z*v2.y;
        result.y = v1.z*v2.x - v1.x*v2.z;
        result.z = v1.x*v2.y - v1.y*v2.x;

        return result;
}

inline D3DVALUE
DotProduct (const RDVECTOR3& v1, const RDVECTOR3& v2)
{
        return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z;
}

//---------------------------------------------------------------------
// Multiplies vector (x,y,z,w) by a 4x4 matrix transposed,
// producing a homogeneous vector
//
// res and v should not be the same
//---------------------------------------------------------------------
inline void
XformPlaneBy4x4Transposed(RDVECTOR4 *v, D3DMATRIX *m, RDVECTOR4 *res)
{
    res->x = v->x*m->_11 + v->y*m->_12 + v->z*m->_13 + v->w*m->_14;
    res->y = v->x*m->_21 + v->y*m->_22 + v->z*m->_23 + v->w*m->_24;
    res->z = v->x*m->_31 + v->y*m->_32 + v->z*m->_33 + v->w*m->_34;
    res->w = v->x*m->_41 + v->y*m->_42 + v->z*m->_43 + v->w*m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,w) by 4x4 matrix, producing a homogeneous vector
//
// res and v should not be the same
//---------------------------------------------------------------------
inline void
XformPlaneBy4x4(RDVECTOR4 *v, D3DMATRIX *m, RDVECTOR4 *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + v->w*m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + v->w*m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + v->w*m->_43;
    res->w = v->x*m->_14 + v->y*m->_24 + v->z*m->_34 + v->w*m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x4 matrix, producing a homogeneous vector
//
// res and v should not be the same
//---------------------------------------------------------------------
inline void
XformBy4x4(RDVECTOR3 *v, D3DMATRIX *m, RDVECTOR4 *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
    res->w = v->x*m->_14 + v->y*m->_24 + v->z*m->_34 + m->_44;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z,1) by 4x3 matrix
//
// res and v should not be the same
//---------------------------------------------------------------------
inline void
XformBy4x3(RDVECTOR3 *v, D3DMATRIX *m, RDVECTOR3 *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31 + m->_41;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32 + m->_42;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33 + m->_43;
}
//---------------------------------------------------------------------
// Multiplies vector (x,y,z) by 3x3 matrix
//
// res and v should not be the same
//---------------------------------------------------------------------
inline void
Xform3VecBy3x3(RDVECTOR3 *v, D3DMATRIX *m, RDVECTOR3 *res)
{
    res->x = v->x*m->_11 + v->y*m->_21 + v->z*m->_31;
    res->y = v->x*m->_12 + v->y*m->_22 + v->z*m->_32;
    res->z = v->x*m->_13 + v->y*m->_23 + v->z*m->_33;
}

//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//---------------------------------------------------------------------
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse);


//---------------------------------------------------------------------
// Make RDCOLOR3 from a Packed DWORD
//---------------------------------------------------------------------
inline void MakeRDCOLOR3( RDCOLOR3 *out, DWORD inputColor )
{
    out->r = (D3DVALUE)RGBA_GETRED( inputColor );
    out->g = (D3DVALUE)RGBA_GETGREEN( inputColor );
    out->b = (D3DVALUE)RGBA_GETBLUE( inputColor );
}

//---------------------------------------------------------------------
// Make RDCOLOR4 from a Packed DWORD
//---------------------------------------------------------------------
inline void MakeRDCOLOR4( RDCOLOR4 *out, DWORD inputColor )
{
    out->a = (D3DVALUE)RGBA_GETALPHA( inputColor )/255.0f;
    out->r = (D3DVALUE)RGBA_GETRED  ( inputColor )/255.0f;
    out->g = (D3DVALUE)RGBA_GETGREEN( inputColor )/255.0f;
    out->b = (D3DVALUE)RGBA_GETBLUE ( inputColor )/255.0f;
}

////////////////////////////////////////////////////////////////////////
//
// Macros used to access DDRAW surface info.
//
////////////////////////////////////////////////////////////////////////
#define DDSurf_Width(lpLcl) ( (lpLcl)->lpGbl->wWidth )
#define DDSurf_Pitch(lpLcl) ( (lpLcl)->lpGbl->lPitch )
#define DDSurf_Height(lpLcl) ( (lpLcl)->lpGbl->wHeight )
#define DDSurf_BitDepth(lpLcl) \
    ( (lpLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? \
      (lpLcl->lpGbl->ddpfSurface.dwRGBBitCount) : \
      (lpLcl->lpGbl->lpDD->vmiData.ddpfDisplay.dwRGBBitCount) \
    )
#define DDSurf_PixFmt(lpLcl) \
    ( ((lpLcl)->dwFlags & DDRAWISURF_HASPIXELFORMAT) ? \
      ((lpLcl)->lpGbl->ddpfSurface) : \
      ((lpLcl)->lpGbl->lpDD->vmiData.ddpfDisplay) \
    )
#define VIDEO_MEMORY(pDDSLcl) \
    (!((pDDSLcl)->lpGbl->dwGlobalFlags & DDRAWISURFGBL_SYSMEMREQUESTED))
#define SURFACE_LOCKED(pDDSLcl) \
    ((pDDSLcl)->lpGbl->dwUsageCount > 0)
#define SURFACE_MEMORY(surfLcl) \
(LPVOID)((surfLcl)->lpGbl->fpVidMem)

//---------------------------------------------------------------------
// DDraw extern functions
//---------------------------------------------------------------------
extern "C" HRESULT WINAPI
DDInternalLock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl, LPVOID* lpBits );
extern "C" HRESULT WINAPI
DDInternalUnlock( LPDDRAWI_DDRAWSURFACE_LCL this_lcl );

HRESULT DDGetAttachedSurfaceLcl(
    LPDDRAWI_DDRAWSURFACE_LCL this_lcl,
    LPDDSCAPS2 lpDDSCaps,
    LPDDRAWI_DDRAWSURFACE_LCL *lplpDDAttachedSurfaceLcl);
extern "C" LPDDRAWI_DDRAWSURFACE_LCL WINAPI
GetDDSurfaceLocal( LPDDRAWI_DIRECTDRAW_LCL this_lcl, DWORD handle, BOOL* isnew );

//---------------------------------------------------------------------
// RDListEntry:
//
// To support singly linked lists with no deletion of entries. Useful
// for active lists (Active Lights etc.)
//---------------------------------------------------------------------
struct RDListEntry
{
    RDListEntry(){m_pNext = NULL;}
    virtual ~RDListEntry(){}

    // Seek to the end of the chain and append
    void Append(RDListEntry* p)
    {
        if( m_pNext == NULL )
        {
            m_pNext = p;
            return;
        }
        RDListEntry* c = m_pNext;
        while( c->m_pNext )  c = c->m_pNext;
        c->m_pNext = p;
    }
    RDListEntry *Next() { return m_pNext; }
    RDListEntry *  m_pNext;
};

//---------------------------------------------------------------------
// Registry access
//---------------------------------------------------------------------
#define RESPATH_D3D     "Software\\Microsoft\\Direct3D"
#define RESPATH_D3DREF  RESPATH_D3D "\\ReferenceDevice"

BOOL GetD3DRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize);
BOOL GetD3DRefRegValue(DWORD type, char *valueName, LPVOID value, DWORD dwSize);

///////////////////////////////////////////////////////////////////////////////
#endif  // _RDCOMM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\inc\refdev.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// refdev.hpp
//
// Direct3D Reference Device - Main Header File
//
///////////////////////////////////////////////////////////////////////////////
#ifndef  _REFDEV_HPP
#define  _REFDEV_HPP

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <windows.h>

#pragma warning( disable: 4056) // fp constant
#pragma warning( disable: 4244) // fp DOUBLE->FLOAT

#include <ddraw.h>
#include <ddrawi.h>
#include <d3dhal.h>
#include "d3d8ddi.h"
//@@BEGIN_MSINTERNAL
#include "d3d8p.h"
//@@END_MSINTERNAL

#include <rdcomm.hpp>

// forward declarations
class RDSurfaceManager;
class RDSurface2D;
class RDSurface;
class RDRenderTarget;
class RDTextureStageState;
class RDBSpline;
class RDNPatch;
class RefDev;

#include <templarr.hpp>
#include <vshader.h>
#include <vstream.h>
#include <reftnl.hpp>
#include <refrast.hpp>
#include <pshader.h>

//-----------------------------------------------------------------------------
//
// A special legacy (pre-DX6) texture op we can't easily map into the new
// texture ops.
//
//-----------------------------------------------------------------------------

#define D3DTOP_LEGACY_ALPHAOVR  (0x7fffffff)

//-----------------------------------------------------------------------------
//
// Constants
//
//-----------------------------------------------------------------------------
const DWORD RD_MAX_NUM_TEXTURE_FORMATS = 50;

const DWORD RD_MAX_CLOD = 13*6; // base texture up to 4kx4k for 6 Cubemaps

//-----------------------------------------------------------------------------
//
// RefRastSetMemif - Routine to set memory allocation interface for reference
// rasterizer - takes pointers to functions to use for malloc, free, and realloc.
//
// These must be set prior to new'ing any RefDev objects.
//
//-----------------------------------------------------------------------------
void
RefRastSetMemif(
    LPVOID( _cdecl* pfnMemAlloc )( size_t ),
    void( _cdecl* pfnMemFree )( PVOID ),
    LPVOID( _cdecl* pfnMemReAlloc )( PVOID, size_t ) );

//-----------------------------------------------------------------------------
//
// RDRenderTarget - Class which encompasses all information about rendering
// target, including size, type/pointer/stride for color and depth/stencil
// buffers, guard band clip info, W range info.
//
// Usage is to instantiate, fill out public members, and install into a
// RefDev object via RefDev::SetRenderTarget.
//
//-----------------------------------------------------------------------------
class RDRenderTarget : public RDAlloc
{
public:
    ///////////////////////////////////////////////////////////////////////////
    //
    // public interface
    //
    ///////////////////////////////////////////////////////////////////////////

    RDRenderTarget( void );
    ~RDRenderTarget( void );
//
// these need to be filled in by the user before installing in a
// RefDev object
//
    RECT    m_Clip;         // clipping bounds
    FLOAT   m_fWRange[2];   // range of device W (W at near and far clip planes)

    RDSurface2D* m_pColor;
    RDSurface2D* m_pDepth;

    // This boolean indicates that the DDI used to set render target
    // is a pre-DX7. This is used by the destructor to free up the
    // color and depth buffers.
    BOOL    m_bPreDX7DDI;

    ///////////////////////////////////////////////////////////////////////////
    //
    // internal state and methods
    //
    ///////////////////////////////////////////////////////////////////////////
    friend class RefDev;
    HRESULT Initialize( LPDDRAWI_DIRECTDRAW_LCL pDDLcl, DWORD dwColorHandle,
                        DWORD dwDepthHandle );
    HRESULT Initialize( LPDDRAWI_DIRECTDRAW_LCL pDDLcl,
                        LPDDRAWI_DDRAWSURFACE_LCL pLclColor,
                        LPDDRAWI_DDRAWSURFACE_LCL pLclZ );
    HRESULT Initialize( LPDDRAWI_DDRAWSURFACE_LCL pLclColor,
                        LPDDRAWI_DDRAWSURFACE_LCL pLclZ );

    // read/write specific sample
    void ReadPixelColor   ( INT32 iX, INT32 iY, UINT Sample, RDColor& Color );
    void WritePixelColor  ( INT32 iX, INT32 iY, UINT Sample, const RDColor& Color, BOOL bDither );
    void WritePixelDepth  ( INT32 iX, INT32 iY, UINT Sample, const RDDepth& Depth );
    void ReadPixelDepth   ( INT32 iX, INT32 iY, UINT Sample, RDDepth& Depth );
    void WritePixelStencil( INT32 iX, INT32 iY, UINT Sample, UINT8 uStencil );
    void ReadPixelStencil ( INT32 iX, INT32 iY, UINT Sample, UINT8& uStencil );

    // write all samples
    void WritePixelColor  ( INT32 iX, INT32 iY, const RDColor& Color, BOOL bDither );
    void WritePixelDepth  ( INT32 iX, INT32 iY, const RDDepth& Depth );
    void WritePixelStencil( INT32 iX, INT32 iY, UINT8 uStencil );

    void Clear            ( RDColor fillColor, LPD3DHAL_DP2COMMAND pCmd );
    void ClearDepth       ( RDDepth fillDepth, LPD3DHAL_DP2COMMAND pCmd );
    void ClearStencil     ( UINT8 uStencil, LPD3DHAL_DP2COMMAND pCmd );
    void ClearDepthStencil( RDDepth fillDepth, UINT8 uStencil, LPD3DHAL_DP2COMMAND pCmd );
};

//-----------------------------------------------------------------------------
//
// RDTextureStageState - This holds the per-stage state for texture mapping.
// An array of these are instanced in the RefDev object.
//
// Store texture matrix at the end of the texture stage state.
//
//-----------------------------------------------------------------------------
class RDTextureStageState
{
public:
    union
    {
        DWORD   m_dwVal[D3DTSS_MAX]; // state array (unsigned)
        FLOAT   m_fVal[D3DTSS_MAX];  // state array (float)
    };
};

//-----------------------------------------------------------------------------
//
// RDSurface - Class instanced once per surface which encompasses information
// about a chain of surfaces used either as a mipmap, cubemap, render-target,
// depth-buffer, vertex buffer or an index buffer.  Includes size and type
// (assumed same for each level of detail) and pointer/stride for each LOD.
//
// Created by CreateSurfaceEx DDI call.
//
//-----------------------------------------------------------------------------

// Surface type flags. Some combination of them are legal
const DWORD RR_ST_UNKNOWN                = 0;
const DWORD RR_ST_TEXTURE                = (1<<0);
const DWORD RR_ST_RENDERTARGETCOLOR      = (1<<2);
const DWORD RR_ST_RENDERTARGETDEPTH      = (1<<3);
const DWORD RR_ST_VERTEXBUFFER           = (1<<4);
const DWORD RR_ST_INDEXBUFFER            = (1<<5);

// The following flags track the surface status
const DWORD RRSURFACE_STATUS_INITCALLED =  (1<<0);
const DWORD RRSURFACE_STATUS_REFCREATED =  (1<<1);
const DWORD RRSURFACE_STATUS_ISLOCKED   =  (1<<2);


class RDSurface
{
public:
    RDSurface()
    {
        m_dwStatus          = 0;
        m_MemPool           = D3DPOOL_FORCE_DWORD;
        m_SurfType          = RR_ST_UNKNOWN;
        m_iLockCount        = 0;
    }

    virtual HRESULT Initialize( LPDDRAWI_DDRAWSURFACE_LCL   pDDSLcl ) = 0;

    virtual ~RDSurface()
    {
        return;
    }
    BOOL IsInitialized(){ return (m_dwStatus & RRSURFACE_STATUS_INITCALLED); }
    void SetInitialized(){ m_dwStatus |= RRSURFACE_STATUS_INITCALLED; }

    BOOL IsRefCreated() { return (m_dwStatus & RRSURFACE_STATUS_REFCREATED); }
    void SetRefCreated(){ m_dwStatus |= RRSURFACE_STATUS_REFCREATED; }

    BOOL IsLocked()     { return (m_dwStatus & RRSURFACE_STATUS_ISLOCKED); }
    void Lock()         { m_iLockCount++;   }
    void Unlock()       { if( m_iLockCount > 0 ) m_iLockCount--; }

    DWORD GetSurfaceType() { return m_SurfType; }
    D3DPOOL GetMemPool() { return m_MemPool; }

protected:
    D3DPOOL         m_MemPool;                      // Where is this allocated
    DWORD           m_SurfType;                     // the type of surface
    DWORD           m_dwStatus;
    int             m_iLockCount;
};

//-----------------------------------------------------------------------------
//
// RDCREATESURFPRIVATE
// PrivateData stored in SurfaceGbl->dwReserved1 at CreateSurface call
//
//-----------------------------------------------------------------------------
class RDCREATESURFPRIVATE
{
public:
    RDCREATESURFPRIVATE()
    {
        dwPitch = 0;
        dwLockCount = 0;
        pBits = NULL;

        wSamples = 1;
        dwMultiSamplePitch = 0;
        pMultiSampleBits = NULL;
        SurfaceFormat = RD_SF_NULL;
    }

    ~RDCREATESURFPRIVATE()
    {
        _ASSERT( dwLockCount == 0, "Surface being deleted has some"
                 "outstanding locks" );
        delete [] pBits;
        delete [] pMultiSampleBits;
    }

    void Lock()
    {
        dwLockCount++;
    }

    void Unlock()
    {
        if( dwLockCount > 0)
            dwLockCount--;
    }

    DWORD dwLockCount;

    union
    {
        DWORD dwPitch;
        DWORD dwVBSize;
    };
    BYTE* pBits;

    WORD  wSamples;
    DWORD dwMultiSamplePitch;
    BYTE* pMultiSampleBits;
    RDSurfaceFormat SurfaceFormat;
};

//---------------------------------------------------------------------------
// RDDSurfaceArrayNode
//
// This is a node in the linked list of the growable array of RefSurfaces
// maintained per ddraw lcl.
//---------------------------------------------------------------------------
struct RDSurfaceHandle
{
    RDSurfaceHandle()
    {
        m_pSurf = NULL;
#if DBG
        m_tag = 0;
#endif
    }
    RDSurface* m_pSurf;
#if DBG
    // Non zero means that it has been allocated
    DWORD      m_tag;
#endif
};

class RDSurfaceArrayNode : public RDListEntry
{
public:
    RDSurfaceArrayNode(LPDDRAWI_DIRECTDRAW_LCL pDDLcl);
    ~RDSurfaceArrayNode();
    HRESULT AddSurface( LPDDRAWI_DDRAWSURFACE_LCL   pDDSLcl,
                        RDSurface**                 ppSurf );
    RDSurface* GetSurface( DWORD dwHandle );
    HRESULT RemoveSurface( DWORD dwHandle );

private:
    LPDDRAWI_DIRECTDRAW_LCL  m_pDDLcl;
    GArrayT<RDSurfaceHandle> m_SurfHandleArray;
    RDSurfaceArrayNode* m_pNext;

    friend class RDSurfaceManager;
};

//---------------------------------------------------------------------------
// RDSurfaceManager
//
// This class maintains a linked list of all the
// surface handle tables for each DD_LCL
//---------------------------------------------------------------------------
class RDSurfaceManager
{
public:
    RDSurfaceManager() {m_pFirstNode = NULL;}
    ~RDSurfaceManager()
    {
        RDSurfaceArrayNode *pNode = m_pFirstNode;
        while( pNode )
        {
            RDSurfaceArrayNode *pTmp = pNode;
            pNode = pNode->m_pNext;
            delete pTmp;
        }
    }

    RDSurfaceArrayNode* AddLclNode( LPDDRAWI_DIRECTDRAW_LCL pDDLcl );
    RDSurfaceArrayNode* GetLclNode( LPDDRAWI_DIRECTDRAW_LCL pDDLcl );

    HRESULT AddSurfToList( LPDDRAWI_DIRECTDRAW_LCL     pDDLcl,
                           LPDDRAWI_DDRAWSURFACE_LCL   pDDSLcl,
                           RDSurface**                 ppSurf );
    RDSurface* GetSurfFromList( LPDDRAWI_DIRECTDRAW_LCL   pDDLcl,
                                DWORD                     dwHandle );

    HRESULT RemoveSurfFromList( LPDDRAWI_DIRECTDRAW_LCL     pDDLcl,
                                LPDDRAWI_DDRAWSURFACE_LCL   pDDSLcl);
    HRESULT RemoveSurfFromList( LPDDRAWI_DIRECTDRAW_LCL     pDDLcl,
                                DWORD dwHandle );

private:
    RDSurfaceArrayNode *m_pFirstNode;
};

extern RDSurfaceManager g_SurfMgr;


//-----------------------------------------------------------------------------
//
// RDVertexBuffer - The RefDev's representation of the VertexBuffer. It gets
// created on a CreateSurfaceEx call.
//
//-----------------------------------------------------------------------------
class RDVertexBuffer : public RDSurface
{
public:
    RDVertexBuffer()
    {
        m_pBits = NULL;
        m_cbSize = 0;
        m_FVF = 0;
    }

    virtual ~RDVertexBuffer() { return; }
    HRESULT Initialize( LPDDRAWI_DDRAWSURFACE_LCL pLcl );
    LPBYTE GetBits() { return m_pBits; }
    int GetFVF()  { return m_FVF; }
    int GetSize()  { return m_cbSize; }

protected:
    DWORD   m_FVF;
    BYTE*   m_pBits;
    DWORD   m_cbSize;
};

//-----------------------------------------------------------------------------
//
// RDPalette - Class for representing and managing palettes in RefDev
//
//-----------------------------------------------------------------------------
class RDPalette
{
public:
    RDPalette()
    {
        m_dwFlags = 0;
        memset( m_Entries, 0, sizeof( m_Entries ) );
    }

    D3DCOLOR* GetEntries()
    {
        return m_Entries;
    }

    static const DWORD RDPAL_ALPHAINPALETTE;
    static const DWORD m_dwNumEntries;

    HRESULT Update( WORD StartIndex, WORD wNumEntries,
                    PALETTEENTRY* pEntries );
    BOOL HasAlpha()
    {
        return (m_dwFlags & RDPAL_ALPHAINPALETTE);
    }

    DWORD     m_dwFlags;
    D3DCOLOR  m_Entries[256];
};


struct RDPaletteHandle
{
    RDPaletteHandle()
    {
        m_pPal = NULL;
#if DBG
        m_tag = 0;
#endif
    }
    RDPalette* m_pPal;
#if DBG
    // Non zero means that it has been allocated
    DWORD      m_tag;
#endif
};

//-----------------------------------------------------------------------------
//
// RDSurface2D - Class instanced once per 2D surface which could be either
// texture, color render target or  depth buffer information
// about a chain of surfaces.  Includes size and type
// (assumed same for each level of detail) and pointer/stride for each LOD.
//
// Also includes pointer to palette, and colorkey value (legacy support only).
//
//-----------------------------------------------------------------------------
class RDSurface2D : public RDSurface
{
public:
    ///////////////////////////////////////////////////////////////////////////
    //
    // public interface
    //
    ///////////////////////////////////////////////////////////////////////////

    RDSurface2D( void );
    ~RDSurface2D( void );

    friend class RefDev;
    class RefDev *  m_pRefDev;  // refdev which created this - used only when this is bound as a texture
    void SetRefDev( RefDev* pRefDev) { m_pRefDev = pRefDev; }

    DWORD           m_uFlags;       // RR_TEXTURE_* bitdefs
// bit definitions for RDSurface2D::uFlags
#define RR_TEXTURE_HAS_CK           (1L<< 0)    // set if texture has colorkey
#define RR_TEXTURE_ALPHAINPALETTE   (1L<< 1)    // set if alpha channel in palette
#define RR_TEXTURE_CUBEMAP          (1L<< 2)    // set if texture is Cubemap with 6 times the number of surfaces
#define RR_TEXTURE_VOLUME           (1L<< 4)    // set if texture is volume

    // basic info
    UINT            m_iSamples;
    int             m_iWidth;                       // size of top-level map
    int             m_iHeight;
    int             m_iDepth;                       // depth of volume texture
    BYTE*           m_pBits[RD_MAX_CLOD];         // pointer to surface bits
    int             m_iPitch[RD_MAX_CLOD];        // pitch in bytes
    int             m_iSlicePitch[RD_MAX_CLOD];   // slice pitch in bytes
                                                    // for volume texture
    int             m_cLOD;     // 0..(n-1) count of LODs currently available

    RDSurfaceFormat m_SurfFormat;                   // format of pixel

    DWORD           m_dwColorKey;   // D3DCOLOR colorkey value

    DWORD           m_dwEmptyFaceColor;     // D3DCOLOR empty cubemap empty face value

    DWORD*          m_pPalette;     // pointer to D3DCOLOR palette (may be NULL)
    RDPalette*      m_pPalObj;

    // DD surface pointers for locking/unlocking and GetSurf callback
    LPDDRAWI_DDRAWSURFACE_LCL m_pDDSLcl[RD_MAX_CLOD];
    int             m_cLODDDS;  // 0..(n-1) count of LODs actually in the pDDS array

    D3DTEXTUREHANDLE    m_hTex; // texture handle

    ///////////////////////////////////////////////////////////////////////////
    //
    // internal state and methods
    //
    ///////////////////////////////////////////////////////////////////////////
    BOOL            m_bHasAlpha;        // TRUE if texture has an alpha channel

    int             m_cDimension;       // 1,2,3 for 1D,2D,3D textures
    int             m_cTexels[RD_MAX_CLOD][3]; // integer number of texels in each dimension
    float           m_fTexels[RD_MAX_CLOD][3]; // float number of texels in each dimension


    HRESULT Initialize( LPDDRAWI_DDRAWSURFACE_LCL pLcl );
    DWORD ComputePitch( LPDDRAWI_DDRAWSURFACE_LCL pLcl ) const;
    DWORD ComputePitch( LPDDRAWI_DDRAWSURFACE_LCL pLcl,
                        RDSurfaceFormat SurfFormat,
                        DWORD width, DWORD height ) const;

    void SetPalette( RDPalette* pPal )
    {
        m_pPalObj = pPal;
    }

    void UpdatePalette();
    BOOL Validate( void );
    void ReadColor( INT32 iX, INT32 iY, INT32 iZ, INT32 iLOD, RDColor& Texel, BOOL &bColorKeyKill );

    inline int GetPitch( DWORD level = 0 )  { return m_iPitch[level]; }
    inline LPBYTE GetBits( DWORD level = 0) { return m_pBits[level]; }
    inline int GetWidth()  { return m_iWidth; }
    inline int GetHeight() { return m_iHeight; }
    inline int GetSamples() { return m_iSamples; }
    HRESULT SetLod( DWORD dwLOD )
    {
        return S_OK;
    }
    inline RDSurfaceFormat GetSurfaceFormat() { return m_SurfFormat; }

    friend class RDRenderTarget;
};

#define RD_STATESET_GROWDELTA      1

#define RRSTATEOVERRIDE_DWORD_BITS      32
#define RRSTATEOVERRIDE_DWORD_SHIFT     5

typedef TemplArray<UINT8> StateSetData;
typedef StateSetData *LPStateSetData;

typedef HRESULT (*PFN_DP2REFOPERATION)(RefDev *pRefDev, LPD3DHAL_DP2COMMAND pCmd);
typedef HRESULT (*PFN_DP2REFOPERATIONUPDATE)(RefDev *pRefDev, LPD3DHAL_DP2COMMAND* ppCmd);
typedef HRESULT (*PFN_DP2REFSETRENDERSTATES)(RefDev *pRefDev,
                                        DWORD dwFvf,
                                        LPD3DHAL_DP2COMMAND pCmd,
                                        LPDWORD lpdwRuntimeRStates);
typedef HRESULT (*PFN_DP2REFTEXTURESTAGESTATE)(RefDev *pRefDev,
                                            DWORD dwFvf,
                                            LPD3DHAL_DP2COMMAND pCmd);
typedef HRESULT (*PFN_DP2REFSETLIGHT)(RefDev *pRefDev,
                                      LPD3DHAL_DP2COMMAND pCmd,
                                      LPDWORD pdwStride);
typedef HRESULT (*PFN_DP2REFSETVERTEXSHADEDCONSTS)
    (RefDev *pRefDev, DWORD StartReg, DWORD dwCount,
                                     LPDWORD pData );
typedef HRESULT (*PFN_DP2REFSETPIXELSHADEDCONSTS)
    (RefDev *pRefDev, DWORD StartReg, DWORD dwCount,
                                     LPDWORD pData );

typedef struct _RD_STATESETFUNCTIONTBL
{
    DWORD                       dwSize;                 // size of struct
    PFN_DP2REFSETRENDERSTATES pfnDp2SetRenderStates;
    PFN_DP2REFTEXTURESTAGESTATE pfnDp2TextureStageState;
    PFN_DP2REFOPERATION pfnDp2SetViewport;
    PFN_DP2REFOPERATION pfnDp2SetWRange;
    PFN_DP2REFOPERATION pfnDp2SetMaterial;
    PFN_DP2REFOPERATION pfnDp2SetZRange;
    PFN_DP2REFSETLIGHT  pfnDp2SetLight;
    PFN_DP2REFOPERATION pfnDp2CreateLight;
    PFN_DP2REFOPERATION pfnDp2SetTransform;
    PFN_DP2REFOPERATION pfnDp2SetExtention;
    PFN_DP2REFOPERATION pfnDp2SetClipPlane;
    PFN_DP2REFOPERATION pfnDp2SetVertexShader;
    PFN_DP2REFSETVERTEXSHADEDCONSTS pfnDp2SetVertexShaderConsts;
    PFN_DP2REFOPERATION pfnDp2SetPixelShader;
    PFN_DP2REFSETPIXELSHADEDCONSTS  pfnDp2SetPixelShaderConsts;
    PFN_DP2REFOPERATION pfnDp2SetStreamSource;
    PFN_DP2REFOPERATION pfnDp2SetIndices;
    PFN_DP2REFOPERATION pfnDp2MultiplyTransform;
} RD_STATESETFUNCTIONTBL, *LPRD_STATESETFUNCTIONTBL;

//
// The device type that the RefDev should emulate
//
typedef enum {
    RDDDI_UNKNOWN = 0,
    RDDDI_OLDHAL  = 1,
    RDDDI_DPHAL,
    RDDDI_DP2HAL,          // DX6 HAL
    RDDDI_DX7HAL,          // DX7 HAL w/out T&L, with state sets
    RDDDI_DX7TLHAL,
    RDDDI_DX8HAL,
    RDDDI_DX8TLHAL,
    RDDDI_FORCE_DWORD = 0xffffffff
} RDDDITYPE;

typedef struct _RRSTATEOVERRIDES
{
    DWORD    bits[D3DSTATE_OVERRIDE_BIAS >> RRSTATEOVERRIDE_DWORD_SHIFT];
} RRSTATEOVERRIDES;

struct RDHOCoeffs
{
    RDHOCoeffs()
    {
        m_pNumSegs = 0;
        for(unsigned i = 0; i < RD_MAX_NUMSTREAMS; m_pData[i++] = 0);
    }
    ~RDHOCoeffs()
    {
        delete[] m_pNumSegs;
        for(unsigned i = 0; i < RD_MAX_NUMSTREAMS; delete[] m_pData[i++]);
    }

    RDHOCoeffs& operator=(const RDHOCoeffs &coeffs);

    UINT           m_Width;
    UINT           m_Height;
    UINT           m_Stride;
    D3DBASISTYPE   m_Basis;
    D3DORDERTYPE   m_Order;
    FLOAT         *m_pNumSegs;
    BYTE          *m_pData[RD_MAX_NUMSTREAMS];
    UINT           m_DataSize[RD_MAX_NUMSTREAMS];
};

//-----------------------------------------------------------------------------
//
// RefDev - Primary object for reference rasterizer.  Each instance
// of this corresponds to a D3D device.
//
// Usage is to instantiate, install RDRenderTarget (and optional RDSurface2D's),
// and set state and draw primitives.
//
//-----------------------------------------------------------------------------
class RefDev : public RDAlloc
{
public:
    friend class RDDebugMonitor;
    friend class RefRast;
    friend class RDPShader;
    ///////////////////////////////////////////////////////////////////////////
    //
    // public interface
    //
    ///////////////////////////////////////////////////////////////////////////

    RefDev( LPDDRAWI_DIRECTDRAW_LCL pDDLcl, DWORD dwInterfaceType,
            RDDDITYPE dwDDIType, D3DCAPS8* pCaps8 );
    ~RefDev( void );
    LPDDRAWI_DIRECTDRAW_LCL GetDDLcl() { return m_pDDLcl; }

    // Methods to get embedded objects
    RefVP&      GetVP()      {  return m_RefVP;  }
    RefVM&      GetVM()      {  return m_RefVM;  }
    RefClipper& GetClipper() { return m_Clipper; }

    RefRast&    GetRast()    { return m_Rast; }

    // DDI methods
    HRESULT DrawPrimitives2( PUINT8 pUMVtx, UINT16 dwStride, DWORD dwFvf,
                             DWORD dwNumVertices, LPD3DHAL_DP2COMMAND *ppCmd,
                             LPDWORD lpdwRStates );

    // Dp2 token handling functions
    HRESULT Dp2RecRenderStates(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd, LPDWORD lpdwRuntimeRStates);
    HRESULT Dp2RecTextureStageState(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecViewport(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecWRange(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecMaterial(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecZRange(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecSetLight(LPD3DHAL_DP2COMMAND pCmd, LPDWORD pdwStride);
    HRESULT Dp2RecCreateLight(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecTransform(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecExtention(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecClipPlane(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecSetVertexShader(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecSetVertexShaderConsts(DWORD StartReg, DWORD dwCount,
                                        LPDWORD pData);
    HRESULT Dp2RecSetPixelShader(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecSetPixelShaderConsts(DWORD StartReg, DWORD dwCount,
                                       LPDWORD pData);
    HRESULT Dp2RecSetStreamSource(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2RecSetIndices(LPD3DHAL_DP2COMMAND pCmd);

    HRESULT Dp2SetRenderStates(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd, LPDWORD lpdwRuntimeRStates);
    HRESULT Dp2SetTextureStageState(DWORD dwFvf, LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetViewport(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetWRange(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetMaterial(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetZRange(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetLight(LPD3DHAL_DP2COMMAND pCmd, PDWORD pdwStride);
    HRESULT Dp2CreateLight(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetTransform(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2MultiplyTransform(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetExtention(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetRenderTarget(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetClipPlane(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2DrawPrimitive(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2DrawPrimitive2(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2DrawIndexedPrimitive(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2DrawIndexedPrimitive2(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2DrawClippedTriFan(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2CreateVertexShader(DWORD handle,
                                  DWORD dwDeclSize, LPDWORD pDecl,
                                  DWORD dwCodeSize, LPDWORD pCode);
    HRESULT Dp2DeleteVertexShader(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetVertexShader(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetVertexShaderConsts(DWORD StartReg, DWORD dwCount,
                                     LPDWORD pData);
    HRESULT Dp2SetStreamSource(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetStreamSourceUM(LPD3DHAL_DP2COMMAND pCmd, PUINT8 pUMVtx );
    HRESULT Dp2SetIndices(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2CreatePixelShader(DWORD handle,
                                 DWORD dwCodeSize, LPDWORD pCode);
    HRESULT Dp2DeletePixelShader(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetPixelShader(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2SetPixelShaderConsts(DWORD StartReg, DWORD dwCount,
                                    LPDWORD pData);
    HRESULT Dp2SetPalette(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT Dp2UpdatePalette(LPD3DHAL_DP2UPDATEPALETTE pUP,
                             PALETTEENTRY *pEntries);
    HRESULT Dp2SetTexLod(LPD3DHAL_DP2COMMAND pCmd);

    // StateSet related functions
    void SetRecStateFunctions(void);
    void SetSetStateFunctions(void);
    HRESULT BeginStateSet(DWORD dwHandle);
    HRESULT EndStateSet(void);
    HRESULT ExecuteStateSet(DWORD dwHandle);
    HRESULT DeleteStateSet(DWORD dwHandle);
    HRESULT CaptureStateSet(DWORD dwHandle);
    HRESULT CreateStateSet(DWORD dwHandle, D3DSTATEBLOCKTYPE sbType);
    HRESULT RecordAllState( DWORD dwHandle );
    HRESULT RecordVertexState( DWORD dwHandle );
    HRESULT RecordPixelState( DWORD dwHandle );

    HRESULT RecordStates(PUINT8 pData, DWORD dwSize);
    HRESULT RecordLastState(LPD3DHAL_DP2COMMAND pCmd, DWORD dwUnitSize);

    LPRD_STATESETFUNCTIONTBL pStateSetFuncTbl;

    // Interface style
    BOOL IsInterfaceDX6AndBefore() {return (m_dwInterfaceType <= 2);}
    BOOL IsInterfaceDX7AndBefore() {return (m_dwInterfaceType <= 3);}

    // DriverStyle
    BOOL IsDriverDX6AndBefore()
    {
        return ((m_dwDDIType <= RDDDI_DP2HAL) && (m_dwDDIType > 0));
    }
    BOOL IsDriverDX7AndBefore()
    {
        return ((m_dwDDIType <= RDDDI_DX7TLHAL) && (m_dwDDIType > 0));
    }

    RDDDITYPE GetDDIType()
    {
        return m_dwDDIType;
    }

    // Last Pixel State
    void StoreLastPixelState(BOOL bStore);

    // RenderTarget control
    void SetRenderTarget( RDRenderTarget* pRenderTarget );
    RDRenderTarget* GetRenderTarget( void );

    // state management functions
    void SetRenderState( DWORD dwState, DWORD dwValue );
    void SetTextureStageState( DWORD dwStage, DWORD dwStageState, DWORD dwValue );
    void SceneCapture( DWORD dwFlags );

    // texture management functions
    BOOL TextureCreate  ( LPD3DTEXTUREHANDLE phTex, RDSurface2D** ppTexture );
    BOOL TextureDestroy ( D3DTEXTUREHANDLE hTex );
    DWORD TextureGetSurf( D3DTEXTUREHANDLE hTex );

    // rendering functions
    HRESULT Clear(LPD3DHAL_DP2COMMAND pCmd);
    HRESULT BeginRendering( void );
    HRESULT EndRendering( void  );

    HRESULT UpdateRastState( void );
    DWORD   m_dwRastFlags;  // rasterizer-core specific flags
#define RDRF_MULTISAMPLE_CHANGED        (1L<<0)
#define RDRF_PIXELSHADER_CHANGED        (1L<<1)
#define RDRF_LEGACYPIXELSHADER_CHANGED  (1L<<2)
#define RDRF_TEXTURESTAGESTATE_CHANGED  (1L<<3)


    // Method to convert FVF vertices into the internal RDVertex. Used for
    // TLVertex rendering and legacy driver models.
    void FvfToRDVertex( PUINT8 pVtx, GArrayT<RDVertex>& dstArray, DWORD dwFvf,
                        DWORD dwStride, UINT cVertices );

    // Rasterizer functions
    void DrawPoint( RDVertex* pvV0 );
    void DrawLine( RDVertex* pvV0, RDVertex* pvV1, RDVertex* pvVFlat = NULL );
    void DrawTriangle( RDVertex* pvV0, RDVertex* pvV1, RDVertex* pvV2,
                       WORD wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE );

    HRESULT DrawOnePrimitive( GArrayT<RDVertex>& VtxArray,
                              DWORD dwStartVertex,
                              D3DPRIMITIVETYPE PrimType,
                              UINT cVertices );
    HRESULT DrawOneIndexedPrimitive( GArrayT<RDVertex>& VtxArray,
                                     int StartVertexIndex,
                                     LPWORD pIndices,
                                     DWORD StartIndex,
                                     UINT  cIndices,
                                     D3DPRIMITIVETYPE PrimType );
    HRESULT DrawOneIndexedPrimitive( GArrayT<RDVertex>& VtxArray,
                                     int StartVertexIndex,
                                     LPDWORD pIndices,
                                     DWORD StartIndex,
                                     UINT cIndices,
                                     D3DPRIMITIVETYPE PrimType );
    HRESULT DrawOneEdgeFlagTriangleFan( GArrayT<RDVertex>& VtxArray,
                                        UINT cVertices,
                                        UINT32 dwEdgeFlags );

//
// these are used to facilitate the way refdev is used in the D3D runtime
//
    // functions to manipulate current set of texture
    int GetCurrentTextureMaps( D3DTEXTUREHANDLE* phTex, RDSurface2D** pTex );
    BOOL SetTextureMap( D3DTEXTUREHANDLE hTex, RDSurface2D* pTex );

//
// T&L Hal specific functions
//

    HRESULT ProcessPrimitive( D3DPRIMITIVETYPE primType,
                              DWORD dwStartVertex,// Index of the start vertex
                              DWORD cVertices,
                              DWORD dwStartIndex,
                              DWORD cIndices );
    HRESULT ProcessPrimitiveVVM( D3DPRIMITIVETYPE primType,
                                 DWORD dwStartVertex,
                                 DWORD cVertices,
                                 DWORD dwStartIndex,
                                 DWORD cIndices );
    HRESULT ProcessBSpline( DWORD dwOffW, DWORD dwOffH,
                            DWORD dwWidth, DWORD dwHeight,
                            DWORD dwStride, DWORD order,
                            FLOAT *pPrimSegments);
    HRESULT ProcessBezier ( DWORD dwOffW, DWORD dwOffH,
                            DWORD dwWidth, DWORD dwHeight,
                            DWORD dwStride, DWORD order,
                            FLOAT *pPrimSegments,
                            bool bDegenerate );
    HRESULT ProcessCatRomSpline ( DWORD dwOffW, DWORD dwOffH,
                                  DWORD dwWidth, DWORD dwHeight,
                                  DWORD dwStride,
                                  FLOAT *pPrimSegments);
    HRESULT ProcessTessPrimitive( LPD3DHAL_DP2DRAWPRIMITIVE pDP );
    HRESULT ProcessTessIndexedPrimitive( LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE pDP );
    HRESULT DrawTessQuad( const RDBSpline &Surf, DWORD dwOffW, DWORD dwOffH, DWORD dwStride,
                          const unsigned *m, const unsigned *n,
                          double u0, double v0, double u1, double v1,
                          double tu0, double tv0, double tu1, double tv1,
                          bool bDegenerate );
    HRESULT DrawTessTri( const RDBSpline &Surf, DWORD dwOffW, DWORD dwOffH, DWORD dwStride,
                         const unsigned *m, const unsigned *n,
                         double u0, double v0, double u1, double v1, double u2, double v2,
                         double tu0, double tv0, double tu1, double tv1, double tu2, double tv2,
                         bool bDegenerate0, bool bDegenerate1, bool bDegenerate2 );
    HRESULT DrawNPatch( const RDNPatch &Patch, DWORD dwStride,
                        const unsigned *m, const unsigned *n, unsigned segs );

    HRESULT ConvertLinearTriBezierToRectBezier(DWORD dwDataType, const BYTE *B, DWORD dwStride, BYTE *Q);
    HRESULT ConvertCubicTriBezierToRectBezier(DWORD dwDataType, const BYTE *B, DWORD dwStride, BYTE *Q);
    HRESULT ConvertQuinticTriBezierToRectBezier(DWORD dwDataType, const BYTE *B, DWORD dwStride, BYTE *Q);

    HRESULT SetupStrides();
    HRESULT UpdateTLState();
    HRESULT UpdateClipper();

    HRESULT DrawDX8Prim(  LPD3DHAL_DP2DRAWPRIMITIVE pDP );
    HRESULT DrawDX8Prim2(  LPD3DHAL_DP2DRAWPRIMITIVE2 pDP );
    HRESULT DrawRectPatch(  LPD3DHAL_DP2DRAWRECTPATCH pDP );
    HRESULT DrawTriPatch(  LPD3DHAL_DP2DRAWTRIPATCH pDP );
    HRESULT DrawDX8IndexedPrim( LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE pDIP );
    HRESULT DrawDX8IndexedPrim2( LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2 pDIP );
    HRESULT DrawDX8ClippedTriFan( LPD3DHAL_CLIPPEDTRIANGLEFAN pDIP );

    inline RDVStream& GetVStream( DWORD index )
    {
        return m_VStream[index];
    }

    inline HRESULT GrowTLVArray( DWORD dwNumVerts )
    {
        return m_TLVArray.Grow( dwNumVerts );
    }

    inline GArrayT<RDVertex>& GetTLVArray()
    {
        return m_TLVArray;
    }

private:
    ///////////////////////////////////////////////////////////////////////////
    //
    // internal state and methods
    //
    ///////////////////////////////////////////////////////////////////////////

    //-------------------------------------------------------------------------
    // Embedded Objects
    //-------------------------------------------------------------------------
    RefVP       m_RefVP;          // The fixed function T&L object
    RefVM       m_RefVM;          // The programmable vertex machine object
    RefClipper  m_Clipper;        // Clipper object

    RefRast     m_Rast;           // Rasterizer object

    //-------------------------------------------------------------------------
    // state
    //-------------------------------------------------------------------------

    // Caps struct, potentially modified from static caps settings.  Ref code
    //  will behave according to settings of some of the caps in this struct.
    D3DCAPS8    m_Caps8;

    // DDraw Local, needed for the new texture handles from DX7 onwards
    LPDDRAWI_DIRECTDRAW_LCL m_pDDLcl;

    // This is obtained from CONTEXTCREATE->ddrval, indicates
    // what kind of emulation (DX3, DX5, DX6 or DX7) the driver should do.
    RDDDITYPE       m_dwDDIType;

    // This is obtained from CONTEXTCREATE->dwhContext, indicates
    // which D3D Device interface called the driver.
    DWORD           m_dwInterfaceType;

    // save area for floating point unit control
    WORD            m_wSaveFP;

    // TRUE if in begin/end primitive sequence
    BOOL            m_bInBegin;

    // TRUE if in rendering point sprite triangles
    BOOL            m_bPointSprite;

    // render target (color & Z buffer)
    RDRenderTarget* m_pRenderTarget;
    FLOAT           m_fWBufferNorm[2]; // { Wnear, 1/(Wfar-Wnear) } to normalize W buffer value

    // D3D renderstate
    union
    {
        DWORD       m_dwRenderState[D3DHAL_MAX_RSTATES];
        FLOAT       m_fRenderState[D3DHAL_MAX_RSTATES];
    };

    // State Override flags
    RRSTATEOVERRIDES m_renderstate_override;

    // Palette handles
    GArrayT<RDPaletteHandle> m_PaletteHandleArray;

    // texture state - per-stage state and pointer to associated texture
    int                 m_cActiveTextureStages; // count of active texture stages (range 0..D3DHAL_TSS_MAXSTAGES)
    DWORD               m_ReferencedTexCoordMask; // which texture coordinate sets are referenced
    RDSurface2D*        m_pTexture[D3DHAL_TSS_MAXSTAGES];  //  texture maps associated with texture stages
    union
    {
        DWORD   m_dwTextureStageState[D3DHAL_TSS_MAXSTAGES][D3DTSS_MAX]; // state array (unsigned)
        FLOAT   m_fTextureStageState[D3DHAL_TSS_MAXSTAGES][D3DTSS_MAX];  // state array (float)
        RDTextureStageState m_TextureStageState[D3DHAL_TSS_MAXSTAGES];
    };
    DWORD*  m_pTextureStageState[D3DHAL_TSS_MAXSTAGES]; // to speed GetTSS

    BOOL                m_bOverrideTCI;
    DWORD               m_dwTexArrayLength;

    // Vertex and Index streams
    // The extra VStream is for the Tesselator generated data.
    RDVStream                m_VStream[RD_MAX_NUMSTREAMS + 1];
    RDIStream                m_IndexStream;

    // Buffer to store transformed vertices
    GArrayT<RDVertex>        m_TLVArray;

    // Vertex shader state
    GArrayT<RDVShaderHandle> m_VShaderHandleArray;
    RDVShader                m_FVFShader; // Declaration for the legacy (FVF)
                                          // shader
    DWORD                    m_CurrentVShaderHandle;
    RDVShader*               m_pCurrentVShader;
    UINT64                   m_qwFVFOut;  // Desired FVF for the output
                                          // vertices

    // Coefficient storage for HOS
    GArrayT<RDHOCoeffs>      m_HOSCoeffs;

    // Primitive information
    D3DPRIMITIVETYPE m_primType;      // Current primitive being drawn
    DWORD            m_dwNumVertices; // Number of vertices to process
    DWORD            m_dwStartVertex;
    DWORD            m_dwNumIndices;
    DWORD            m_dwStartIndex;

    // Last state
    DWORD m_LastState;

    // Array of StateSets, which are in turn implemented with TemplArray as
    // TemplArray<UINT8> StateSetData
    TemplArray<LPStateSetData> m_pStateSets;

    // pixel shader state
    DWORD                    m_CurrentPShaderHandle;
    GArrayT<RDPShaderHandle> m_PShaderHandleArray;

    // Buffer used to process clear rects
    GArrayT<BYTE>            m_ClearRectBuffer;

    //-------------------------------------------------------------------------
    // methods
    //-------------------------------------------------------------------------

// refrasti.cpp
    HRESULT GrowTexArray( DWORD dwHandle );
    HRESULT SetTextureHandle( int iStage, DWORD dwHandle );
    void MapTextureHandleToDevice( int iStage );
    void UpdateActiveTexStageCount( void );
    RDSurface2D* MapHandleToTexture( D3DTEXTUREHANDLE hTex );

// MapLegcy.cpp
    void MapLegacyTextureBlend( void );
    void MapLegacyTextureFilter( void );

// primfns.cpp
    HRESULT GrowLightArray(const DWORD dwIndex);

    // pixel shader handle manipulation
    inline RDPShader* GetPShader( DWORD dwHandle )
    {
        if( m_PShaderHandleArray.IsValidIndex( dwHandle ) )
            return m_PShaderHandleArray[dwHandle].m_pShader;
        return NULL;
    }

// drawgrid.cpp
    HRESULT LinkTessellatorOutput();
    HRESULT LinkCachedTessellatorOutput(DWORD Handle, BYTE **pTempData);
    void UnlinkTessellatorOutput();
    void UnlinkCachedTessellatorOutput(BYTE **pTempData);

public:
    ///////////////////////////////////////////////////////////////////////////
    //
    // methods used by refdev objects to get at device state
    //
    ///////////////////////////////////////////////////////////////////////////
    inline DWORD* GetRS( void ) { return m_dwRenderState; }
    inline FLOAT* GetRSf( void ) { return m_fRenderState; }
    inline DWORD* GetTSS( DWORD Stage ) { return m_pTextureStageState[Stage]; }
    inline FLOAT* GetTSSf( DWORD Stage ) { return (FLOAT*)m_pTextureStageState[Stage]; }
    inline BOOL ColorKeyEnabled( void )
    {
        return
            m_dwRenderState[D3DRENDERSTATE_COLORKEYENABLE] ||
            m_dwRenderState[D3DRENDERSTATE_COLORKEYBLENDENABLE];
    }

    inline D3DCAPS8* GetCaps8( void ) { return &m_Caps8; }
};

//-------------------------------------------------------------------------
// DXTn compressed texture formats
//-------------------------------------------------------------------------
// number of DXT compression formats
#define NUM_DXT_FORMATS    5
// number of pixels in block
#define DXT_BLOCK_PIXELS   16

// DXT block size array
extern int g_DXTBlkSize[];

typedef struct  {
    BYTE    rgba[4];
} DXT_COLOR;

typedef WORD        RGB565;     // packed color
typedef DWORD       PIXBM;      // 2 BPP bitmap


typedef struct  {
    RGB565      rgb0;       // color for index 0
    RGB565      rgb1;       // color for index 1
    PIXBM       pixbm;      // pixel bitmap
} DXTBlockRGB;

typedef struct  {
    WORD        alphabm[4]; // alpha bitmap at 4 BPP
    DXTBlockRGB    rgb;        // color block
} DXTBlockAlpha4;

typedef struct  {
    BYTE        alpha0;     // alpha for index 0
    BYTE        alpha1;     // alpha for index 1
    BYTE        alphabm[6]; // alpha bitmap at 3 BPP
    DXTBlockRGB    rgb;        // color block
} DXTBlockAlpha3;

void DecodeBlockRGB (DXTBlockRGB *pblockSrc,
                     DXT_COLOR colorDst[DXT_BLOCK_PIXELS]);
void DecodeBlockAlpha4(DXTBlockAlpha4 *pblockSrc,
                       DXT_COLOR colorDst[DXT_BLOCK_PIXELS]);
void DecodeBlockAlpha3(DXTBlockAlpha3 *pblockSrc,
                       DXT_COLOR colorDst[DXT_BLOCK_PIXELS]);

///////////////////////////////////////////////////////////////////////////////
#endif // _REFDEV_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\inc\refrast.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// refrast.hpp
//
// Direct3D Reference Device - Rasterizer Core
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _REFRAST_HPP
#define _REFRAST_HPP

#include "pshader.h"

inline INT32 FloatToNdot4( FLOAT f )
{

// alternate form if FPU is set up to do double precision
//    return AS_INT32( (DOUBLE)f + DOUBLE_4_SNAP );

    INT32 i = AS_INT32( f + FLOAT_4_SNAP );
    i <<= 10; i >>= 10; // sign extend
    return i;
}

inline INT32 FloatToNdot5( FLOAT f )
{

// alternate form if FPU is set up to do double precision
//    return AS_INT32( (DOUBLE)f + DOUBLE_5_SNAP );

    INT32 i = AS_INT32( f + FLOAT_5_SNAP );
    i <<= 10; i >>= 10; // sign extend
    return i;
}

//-----------------------------------------------------------------------------
//
// Constants
//
//-----------------------------------------------------------------------------
const DWORD RD_MAX_MULTISAMPLES = 9;

const UINT RDPRIM_MAX_EDGES = 4;    // 4 edges for a point sprite
const UINT RDATTR_MAX_DIMENSIONALITY = 4;   // up to 4 scalars per attribute

// attribute array assignments
#define RDATTR_DEPTH                0
#define RDATTR_FOG                  1
#define RDATTR_COLOR                2
#define RDATTR_SPECULAR             3
#define RDATTR_TEXTURE0             4
#define RDATTR_TEXTURE1             5
#define RDATTR_TEXTURE2             6
#define RDATTR_TEXTURE3             7
#define RDATTR_TEXTURE4             8
#define RDATTR_TEXTURE5             9
#define RDATTR_TEXTURE6             10
#define RDATTR_TEXTURE7             11
const UINT RDPRIM_MAX_ATTRIBUTES = 12;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Pixel Component Classes                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Color Value Class - Holds an array of floats.
//
//-----------------------------------------------------------------------------
class RDColor
{
public:
    FLOAT R,G,B,A;

    inline RDColor( void ) { R = G = B = 0.0f; A = 1.0f; }
    // assignment constructors
    inline RDColor( UINT32 uVal )
    {
        R = (FLOAT)RGBA_GETRED(   uVal )*(1.f/255.f);
        G = (FLOAT)RGBA_GETGREEN( uVal )*(1.f/255.f);
        B = (FLOAT)RGBA_GETBLUE(  uVal )*(1.f/255.f);
        A = (FLOAT)RGBA_GETALPHA( uVal )*(1.f/255.f);
    }
    inline RDColor( FLOAT fR, FLOAT fG, FLOAT fB, FLOAT fA )
    {
        R = fR; G = fG; B = fB; A = fA;
    }
    inline RDColor( FLOAT* pC )
    {
        R = *(pC+0); G = *(pC+1); B= *(pC+2); A = *(pC+3);
    }

    // UINT32 copy operator
    inline void operator=(const UINT32 uVal)
    {
        R = (FLOAT)RGBA_GETRED(   uVal )*(1.f/255.f);
        G = (FLOAT)RGBA_GETGREEN( uVal )*(1.f/255.f);
        B = (FLOAT)RGBA_GETBLUE(  uVal )*(1.f/255.f);
        A = (FLOAT)RGBA_GETALPHA( uVal )*(1.f/255.f);
    }
    // FLOAT array copy operator
    inline void operator=(const FLOAT* pFVal)
    {
        R = *(pFVal+0);
        G = *(pFVal+1);
        B = *(pFVal+2);
        A = *(pFVal+3);
    }
    // casting operator
    inline operator UINT32() const
    {
        return D3DRGBA( R, G, B, A );
    }

    // set all channels
    inline void SetAllChannels( FLOAT fVal )
    {
        R = fVal; G = fVal; B = fVal; A = fVal;
    }

    // clamp to unity
    inline void Saturate( void )
    {
        R = MIN( 1.f, R );
        G = MIN( 1.f, G );
        B = MIN( 1.f, B );
        A = MIN( 1.f, A );
    }

    inline void Clamp( void )
    {
        R = MAX( 0.f, MIN( 1.f, R ) );
        G = MAX( 0.f, MIN( 1.f, G ) );
        B = MAX( 0.f, MIN( 1.f, B ) );
        A = MAX( 0.f, MIN( 1.f, A ) );
    }

    // copy to array of FLOATs
    inline void CopyTo( FLOAT* pF )
    {
        *(pF+0) = R;
        *(pF+1) = G;
        *(pF+2) = B;
        *(pF+3) = A;
    }

    //
    // conversions between surface format and RDColor - these define the
    // correct way to map between resolutions
    //

    // convert from surface type format to RDColor
    void ConvertFrom( RDSurfaceFormat Type, const char* pSurfaceBits );

    // Convert surface type format to RDColor
    void ConvertTo( RDSurfaceFormat Type, float fRoundOffset, char* pSurfaceBits ) const;
};

//-----------------------------------------------------------------------------
//
// RDDepth - Class for storing and manipulating pixel depth values.  Underlying
// storage is a double precision floating point, which has sufficient precision
// and range to support 16 and 32 bit fixed point and 32 bit floating point.
//
// The UINT32 methods receive a 24 or 32 bit value, and the UINT16
// methods receive a 15 or 16 bit value.
//
//-----------------------------------------------------------------------------
class RDDepth
{
    DOUBLE m_dVal;
    RDSurfaceFormat m_DepthSType;
    DOUBLE dGetValClamped(void) const { return min(1.,max(0.,m_dVal)); }
    DOUBLE dGetCnvScale(void) const
    {
        switch(m_DepthSType)
        {
        case RD_SF_Z16S0:
            return DOUBLE((1<<16)-1);
        case RD_SF_Z24S8:
        case RD_SF_Z24X8:
        case RD_SF_S8Z24:
        case RD_SF_X8Z24:
        case RD_SF_Z24X4S4:
        case RD_SF_X4S4Z24:
            return DOUBLE((1<<24)-1);
        case RD_SF_Z15S1:
        case RD_SF_S1Z15:
            return DOUBLE((1<<15)-1);
        case RD_SF_Z32S0:
            return DOUBLE(0xffffffff);  // too big to be generated as above without INT64's
        default:
            DPFRR(0, "RDDepth not initialized correctly");
            return DOUBLE(0.0);
        }
    }
    DOUBLE dGetCnvInvScale(void) const
    {
        switch(m_DepthSType)
        {
        case RD_SF_Z16S0:
            return DOUBLE( 1./(DOUBLE)((1<<16)-1) );
        case RD_SF_Z24S8:
        case RD_SF_Z24X8:
        case RD_SF_S8Z24:
        case RD_SF_X8Z24:
        case RD_SF_Z24X4S4:
        case RD_SF_X4S4Z24:
            return DOUBLE( 1./(DOUBLE)((1<<24)-1) );
        case RD_SF_Z15S1:
        case RD_SF_S1Z15:
            return DOUBLE( 1./(DOUBLE)((1<<15)-1) );
        case RD_SF_Z32S0:
            return DOUBLE( 1./(DOUBLE)(0xffffffff) );  // too big to be generated as above without INT64's
        default:
            DPFRR(0, "RDDepth not initialized correctly");
            return DOUBLE(0.0);
        }
    }
public:
    RDDepth() {;}
    // assignment constructors
    RDDepth(RDSurfaceFormat SType)             : m_dVal(0.F), m_DepthSType(SType)                         {;}
    RDDepth(UINT16 uVal, RDSurfaceFormat SType): m_DepthSType(SType), m_dVal((DOUBLE)uVal*dGetCnvInvScale()) {;}
    RDDepth(UINT32 uVal, RDSurfaceFormat SType): m_DepthSType(SType), m_dVal((DOUBLE)uVal*dGetCnvInvScale()) {;}

    // copy and assignment operators
    RDDepth& operator=(const RDDepth& A) { m_dVal = A.m_dVal; m_DepthSType = A.m_DepthSType; return *this; }
    RDDepth& operator=(UINT16 uVal) { m_dVal = (DOUBLE)uVal*dGetCnvInvScale(); return *this; }
    RDDepth& operator=(UINT32 uVal) { m_dVal = (DOUBLE)uVal*dGetCnvInvScale(); return *this; }
    RDDepth& operator=(FLOAT fVal) { m_dVal = (DOUBLE)fVal; return *this; }

    // round for integer get operations
    operator UINT16() const { return (UINT16)( (dGetValClamped()*dGetCnvScale()) + .5); }
    operator UINT32() const { return (UINT32)( (dGetValClamped()*dGetCnvScale()) + .5); }

    operator DOUBLE() const { return dGetValClamped(); }
    operator FLOAT()  const { return (FLOAT)dGetValClamped(); }
    void SetSType(RDSurfaceFormat SType)  { m_DepthSType = SType; }
    RDSurfaceFormat GetSType(void) const { return m_DepthSType; }
};

//-----------------------------------------------------------------------------
//
// Texture
//
//-----------------------------------------------------------------------------

#define RRTEX_LODFRAC       5
#define RRTEX_LODFRACMASK   0x1F
#define RRTEX_LODFRACF      .03125f

#define RRTEX_MAPFRAC       5
#define RRTEX_MAPFRACMASK   0x1F
#define RRTEX_MAPFRACF      .03125f

typedef struct _TextureSample
{
    INT32   iLOD;
    FLOAT   fWgt;
    INT32   iCrd[3];
} TextureSample;

typedef struct _TextureFilterControl
{
    int                     cSamples;
    TextureSample           pSamples[16*4*2];   // handles 16:1 aniso in two LODs
    D3DTEXTUREFILTERTYPE    MinFilter;
    D3DTEXTUREFILTERTYPE    MagFilter;
    D3DTEXTUREFILTERTYPE    MipFilter;
    D3DTEXTUREFILTERTYPE    CvgFilter;
    FLOAT                   fCrd[3];    // temporary: to run old filter/sample code
} TextureFilterControl;

typedef struct _TextureCoverage
{
    FLOAT               fLOD;
    FLOAT               fAnisoRatio;
    FLOAT               fAnisoLine[3];
    INT16               iLOD;           // n.RRTEX_LODFRAC fixed point LOD
    BOOL                bMagnify;
    int                 cLOD;           // 1 or 2, for accessing one or two LOD maps
    INT32               iLODMap[2];     // map index for maps adjacent to sample point
    FLOAT               fLODFrc[2];     // (fractional) weighting for each adjacent map
    FLOAT               fGradients[3][2];   // need to store gradients for cube maps
} TextureCoverage;

//
// structure containing texture coordinate and gradient information
// for lookup and filtering
//
class RDTextureCoord
{
public:
    union { FLOAT C0; FLOAT fNX; FLOAT fU; };
    union { FLOAT C1; FLOAT fNY; FLOAT fV; };
    union { FLOAT C2; FLOAT fNZ; FLOAT fW; };
    union { FLOAT DC0DX; FLOAT fDNXDX; FLOAT fDUDX; };
    union { FLOAT DC0DY; FLOAT fDNXDY; FLOAT fDUDY; };
    union { FLOAT DC1DX; FLOAT fDNYDX; FLOAT fDVDX; };
    union { FLOAT DC1DY; FLOAT fDNYDY; FLOAT fDVDY; };
    union { FLOAT DC2DX; FLOAT fDNZDX; };
    union { FLOAT DC2DY; FLOAT fDNZDY; };
};

void
ComputeMipCoverage(
    const FLOAT (*fGradients)[2],
    FLOAT& fLOD, int cDim );
void
ComputeAnisoCoverage(
    const FLOAT (*fGradients)[2], FLOAT fMaxAniso,
    FLOAT& fLOD, FLOAT& fRatio, FLOAT fDelta[] );
void
ComputeCubeCoverage(
    const FLOAT (*fGradients)[2],
    FLOAT& fLOD );
void
DoCubeRemap(
    INT32 iCrd[], INT32 iCrdMax[],
    D3DCUBEMAP_FACES& Face, UINT uOut0, UINT uOut1);

//-----------------------------------------------------------------------------
//
// Primitive edge function - Computes, stores, and evaluates linear function
// for edges.  Basic function is stored in fixed point.  Gradient sign terms
// are computed and stored separately to adhere to fill rules.
//
// This can evaluate edges to a 1/16th subpixel resolution grid.
//
//-----------------------------------------------------------------------------
class RDEdge
{
public:
    INT32   m_iA;       // n.4 fixed point
    INT32   m_iB;       // n.4 fixed point
    INT64   m_iC;       // n.8 fixed point
    BOOL    m_bAPos;    // carefully computed signs of A,B
    BOOL    m_bBPos;

    void Set(
        BOOL bDetSign,
        INT32 iX0, INT32 iY0,
        INT32 iX1, INT32 iY1);

    BOOL Test(INT32 iX, INT32 iY );
};

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
class RDAttribute
{
public:
    friend class RefRast;
    // pointer back to containing refrast object
    RefRast* m_pRR;

    BOOL    m_bPerspective;
    BOOL    m_bClamp;           // clamp to 0..1 if TRUE
    UINT    m_cDimensionality;
    UINT    m_cProjection;      // project by c'th element (0 == disable)
    DWORD   m_dwWrapFlags;      // wrap flags for each dimension (from LSB)
    BOOL    m_bFlatShade;

    // per-dimension attribute functions
    FLOAT   m_fA[RDATTR_MAX_DIMENSIONALITY];
    FLOAT   m_fB[RDATTR_MAX_DIMENSIONALITY];
    FLOAT   m_fC[RDATTR_MAX_DIMENSIONALITY];

    // things generally only set once
    void Init(
        RefRast* pPrimitive, // RefRast with which this attrib is used
        UINT cDimensionality,
        BOOL bPerspective,
        BOOL bClamp );

    // things generally set as RS or TSS changes
    void SetFlatShade( BOOL bFlatShade )    { m_bFlatShade = bFlatShade; }
    void SetWrapFlags( DWORD dwWrapFlags )  { m_dwWrapFlags = dwWrapFlags; }
    void SetProjection( UINT cProjection )  { m_cProjection = cProjection; }
    void SetPerspective( BOOL bPerspective) { m_bPerspective = bPerspective; }

    void Setup(
        const FLOAT* pVtx0, const FLOAT* pVtx1, const FLOAT* pVtx2);
    void LineSetup(
        const FLOAT* pVtx0, const FLOAT* pVtx1, const FLOAT* pVtxFlat = NULL );
    void Setup(
        DWORD dwVtx0, DWORD dwVtx1, DWORD dwVtx2);

    // fully general sample function
    void Sample( FLOAT* pSampleData, FLOAT fX, FLOAT fY,
        BOOL bNoProjectionOverride = TRUE, BOOL bClampOverride = FALSE );
    // sample scalar attribute at given location; assumes no perspective or projection
    //  (used for Depth)
    FLOAT Sample( FLOAT fX, FLOAT fY );
};

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
class RefRast
{
public:
    friend class RDAttribute;
    friend class RDEdge;

    RefDev* m_pRD;
    ~RefRast();
    void Init( RefDev* pRD );

// used for all primitives
    BOOL    m_bIsLine;  // TRUE if rendering a line
    UINT    m_iFlatVtx; // 0..2 range; which vertex to use for flat shading color

    RDAttribute m_Attr[RDPRIM_MAX_ATTRIBUTES];

    FLOAT   m_fX0, m_fY0;   // first vertex, snapped (for initial evaluation)
    FLOAT   m_fRHW0, m_fRHW1, m_fRHW2;  // 1/W data for perspective correction
    FLOAT   m_fRHWA, m_fRHWB, m_fRHWC;  // linear function for 1/W for perspective correction
    FLOAT   SampleAndInvertRHW( FLOAT fX, FLOAT fY );   // sample 1/W at current given location, invert, and return

// triangle and point rendering
    RDEdge  m_Edge[RDPRIM_MAX_EDGES];
    INT32   m_iEdgeCount;

    // integer x,y coords snapped to n.4 grid
    INT32   m_iX0, m_iY0, m_iX1, m_iY1, m_iX2, m_iY2;
    INT64   m_iDet; // n.8 determinant

    FLOAT   m_fDelX10, m_fDelX02; // float x,y deltas
    FLOAT   m_fDelY01, m_fDelY20; //
    FLOAT   m_fTriOODet;          // 1/determinant for triangle function normalization

    // integer x,y scan area, intersected with viewport and guardband
    INT32   m_iXMin, m_iXMax, m_iYMin, m_iYMax;

    BOOL PerTriangleSetup(
        FLOAT* pVtx0, FLOAT* pVtx1, FLOAT* pVtx2,
        DWORD CullMode,
        RECT* pClip);

    BOOL EvalPixelPosition( int iPix );

// line rendering
    INT64   m_iLineEdgeFunc[3];     // line function: Pminor = ([0]*Pmajor + [1])/[2]
    BOOL    m_bLineXMajor;          // TRUE if X major for line function
    INT32   m_iLineMin, m_iLineMax; // min and max pixel extent in major direction
    INT32   m_iLineStep;            // +1 or -1 depending on line major direction
    FLOAT   m_fLineMajorLength;     // major length for line function
    INT32   m_cLineSteps;           // number of steps to take in line iteration

    BOOL PerLineSetup(
        FLOAT* pVtx0, FLOAT* pVtx1,
        BOOL bLastPixel,
        RECT* pClip);

    void StepLine( void );
    INT32   m_iMajorCoord;

// per-pixel data
    int         m_iPix; // which of 4 pixels are currently being worked on

    // per-pixel values
    BOOL        m_bPixelIn[4];
    INT32       m_iX[4], m_iY[4]; // current position
    FLOAT       m_fW[4];
    FLOAT       m_FogIntensity[4];
    RDDepth     m_Depth[4]; // TODO - get rid of this...

    // per-(pixel&sample) values
    BOOL        m_bSampleCovered[RD_MAX_MULTISAMPLES][4];
    RDDepth     m_SampleDepth[RD_MAX_MULTISAMPLES][4];

    // pixel shader stuff
    BOOL        m_bLegacyPixelShade;
    RDPShader*  m_pCurrentPixelShader;
    UINT        m_CurrentPSInst;
    BOOL        m_bPixelDiscard[4];

    // register files
    FLOAT       m_InputReg[RDPS_MAX_NUMINPUTREG][4][4];
    FLOAT       m_TempReg[RDPS_MAX_NUMTEMPREG][4][4];
    FLOAT       m_ConstReg[RDPS_MAX_NUMCONSTREG][4][4];
    FLOAT       m_TextReg[RDPS_MAX_NUMTEXTUREREG][4][4];

    // additional ref-specific registers for holding temporary values in pixel shader
    FLOAT       m_PostModSrcReg[RDPS_MAX_NUMPOSTMODSRCREG][4][4]; // temporary values holding src mod results for 3 source parameters
    FLOAT       m_ScratchReg[RDPS_MAX_NUMSCRATCHREG][4][4]; // just a general scratchpad register (example use: storing eye/reflection vector)
    FLOAT       m_ZeroReg[4][4];  // register containing 0.0f.
    FLOAT       m_OneReg[4][4];   // register containing 1.0f.
    FLOAT       m_TwoReg[4][4];   // register containing 2.0f.
    FLOAT       m_QueuedWriteReg[RDPS_MAX_NUMQUEUEDWRITEREG][4][4];  // staging registers for queued writes
    PSQueuedWriteDst  m_QueuedWriteDst[RDPS_MAX_NUMQUEUEDWRITEREG]; // destination register on flush for queued write

    FLOAT       m_Gradients[3][2];        // gradients for texture sampling

    void ExecShader( void );
    void DoRegToRegOp( PixelShaderInstruction* pInst );
#if DBG
    BOOL        m_bDebugPrintTranslatedPixelShaderTokens;
#endif


    RDPShader*  m_pLegacyPixelShader;
    void UpdateLegacyPixelShader( void );

// multi-sample stuff
    UINT    m_SampleCount;      // count and deltas for current MS buffer type
    INT32   m_SampleDelta[RD_MAX_MULTISAMPLES][2];
    DWORD   m_SampleMask;       // copy of renderstate

    UINT    m_CurrentSample;    // current sample number for 'NextSample' stepper

    inline void SetSampleMask( DWORD SampleMask ) { m_SampleMask = SampleMask; }
    inline BOOL GetCurrentSampleMask( void )
    {
        if ( m_SampleCount <= 1 ) return TRUE; // not effective when not MS buffer
        return ( (1<<m_CurrentSample) & m_SampleMask ) ? TRUE : FALSE;
    }

    inline UINT GetCurrentSample( void ) { return m_CurrentSample; }

    // returns TRUE until samples exhausted and then resets itself on FALSE return
    inline BOOL NextSample( void )
    {
        if (++m_CurrentSample == m_SampleCount)
        {
            // done iterating thru samples, so reset and return FALSE
            m_CurrentSample = 0;
            return FALSE;
        }
        return TRUE;
    }

    // returns x,y deltas (n.4 fixed point) of current sample
    inline INT32 GetCurrentSampleX( int iPix )
        { return (m_iX[iPix]<<4) + m_SampleDelta[m_CurrentSample][0]; }
    inline INT32 GetCurrentSampleY( int iPix )
        { return (m_iY[iPix]<<4) + m_SampleDelta[m_CurrentSample][1]; }
    inline FLOAT GetCurrentSamplefX( int iPix )
        { return (FLOAT)GetCurrentSampleX(iPix) * (1./16.); }
    inline FLOAT GetCurrentSamplefY( int iPix )
        { return (FLOAT)GetCurrentSampleY(iPix) * (1./16.); }

    // sets internal sample number and per-sample deltas based on FSAA type
    void SetSampleMode( UINT MultiSampleCount, BOOL bAntialias );
    UINT GetCurrentNumberOfSamples( void )
        { return m_SampleCount; }


// setup.cpp
    void SetAttributeFunctions(
        const RDVertex& Vtx0,
        const RDVertex& Vtx1,
        const RDVertex& Vtx2 );

// scancnv.cpp
    FLOAT ComputeFogIntensity( FLOAT fX, FLOAT fY );
    void SnapDepth( void );
    void DoScanCnvGenPixels( void );
    void DoScanCnvTri( int iEdgeCount );
    void DoScanCnvLine( void );

// texture filtering
    TextureCoverage         m_TexCvg[D3DHAL_TSS_MAXSTAGES];
    TextureFilterControl    m_TexFlt[D3DHAL_TSS_MAXSTAGES];
    void UpdateTextureControls( void );
    void ComputeTextureCoverage( int iStage, FLOAT (*fGradients)[2] );
    void ComputePerLODControls( int iStage );
    void ComputePointSampleCoords(
        int iStage, INT32 iLOD, FLOAT fCrd[],
        INT32 iCrd[] );
    void ComputeLinearSampleCoords(
        int iStage, INT32 iLOD, FLOAT fCrd[],
        INT32 iCrdFlr[], INT32 iCrdClg[], FLOAT fCrdFrcF[], FLOAT fCrdFrcC[] );
    void SetUp1DTextureSample(
        int iStage, int Start,
        INT32 iLODMap, FLOAT fLODScale,
        INT32 iCrdF, INT32 iCrdC,
        FLOAT fCrdFrcF, FLOAT fCrdFrcC );
    void SetUp2DTextureSample(
        int iStage, int Start,
        INT32 iLODMap, FLOAT fLODScale,
        INT32 iCrdF[], INT32 iCrdC[],
        FLOAT fCrdFrcF[], FLOAT fCrdFrcC[] );
    void SetUp3DTextureSample(
        int iStage, int Start,
        INT32 iLODMap, FLOAT fLODScale,
        INT32 iCrdF[], INT32 iCrdC[],
        FLOAT fCrdFrcF[], FLOAT fCrdFrcC[] );
    void SetUpCubeMapLinearSample(
        int iStage, D3DCUBEMAP_FACES Face,
        INT32 iLODMap, FLOAT fLODScale,
        INT32 (*iCrd)[2], FLOAT (*fFrc)[2] );
    void ComputeTextureFilter( int iStage, FLOAT fCrd[] );
    void ComputeCubeTextureFilter( int iStage, FLOAT fCrd[] );
    void SampleTexture( INT32 iStage, FLOAT fCol[] );


// texstage.cpp
    void ComputeTextureBlendArg(
        DWORD dwArgCtl, BOOL bAlphaOnly,
        const RDColor& DiffuseColor,
        const RDColor& SpecularColor,
        const RDColor& CurrentColor,
        const RDColor& TextureColor,
        const RDColor& TempColor,
        RDColor& BlendArg);
    void DoTextureBlendStage(
        int iStage,
        const RDColor& DiffuseColor,
        const RDColor& SpecularColor,
        const RDColor& CurrentColor,
        const RDColor& TextureColor,
        RDColor& TempColor,
        RDColor& OutputColor);

// pixproc.cpp
    void DoPixels( void );
    BOOL DepthCloser( const RDDepth& DepthVal, const RDDepth& DepthBuf );
    BOOL AlphaTest( FLOAT fAlpha );
    BOOL DoStencil( UINT8 uStncBuf, BOOL bDepthTest, RDSurfaceFormat DepthSFormat, UINT8& uStncRet );
    void DoAlphaBlend( const RDColor& SrcColor, const RDColor& DstColor, RDColor& ResColor );

// pixref.cpp
    void WritePixel( INT32 iX, INT32 iY, UINT Sample, const RDColor& Color, const RDDepth& Depth);

};


///////////////////////////////////////////////////////////////////////////////
#endif // _REFRAST_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\inc\pshader.h ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// pshader.h
//
// Direct3D Reference Device - Pixel Shader
//
///////////////////////////////////////////////////////////////////////////////
#ifndef _PSHADER_H
#define _PSHADER_H

class RefRast;

//---------------------------------------------------------------------
// Constants
//---------------------------------------------------------------------

const DWORD RD_MAX_TEXTURE_STAGES       = D3DHAL_TSS_MAXSTAGES;

const DWORD RD_MAX_COISSUED_INSTRUCTIONS = 2;

// version 1.1 register bank sizes
const DWORD RDPS_MAX_NUMTEMPREG_V255    = 6;
const DWORD RDPS_MAX_NUMINPUTREG_V255   = 8;
const DWORD RDPS_MAX_NUMCONSTREG_V255   = 16;
const DWORD RDPS_MAX_NUMTEXTUREREG_V255 = 8;

// version-independent consts for sizing arrays
const DWORD RDPS_MAX_NUMTEMPREG         = RDPS_MAX_NUMTEMPREG_V255;
const DWORD RDPS_MAX_NUMINPUTREG        = RDPS_MAX_NUMINPUTREG_V255;
const DWORD RDPS_MAX_NUMCONSTREG        = RDPS_MAX_NUMCONSTREG_V255;
const DWORD RDPS_MAX_NUMTEXTUREREG      = RDPS_MAX_NUMTEXTUREREG_V255;

// sizes for internal register arrays
const DWORD RDPS_MAX_NUMQUEUEDWRITEREG   = RD_MAX_COISSUED_INSTRUCTIONS - 1;
const DWORD RDPS_MAX_NUMPOSTMODSRCREG    = 3;
const DWORD RDPS_MAX_NUMSCRATCHREG       = 5;

// refdev-specific pixel shader 'instructions' to match legacy pixel processing
#define D3DSIO_TEXBEM_LEGACY    ((D3DSHADER_INSTRUCTION_OPCODE_TYPE)0xC001)
#define D3DSIO_TEXBEML_LEGACY   ((D3DSHADER_INSTRUCTION_OPCODE_TYPE)0xC002)


//---------------------------------------------------------------------
//

// pshader.cpp

// Structure that describes each D3DSIO_ pixelshader instruction
typedef struct _PixelShaderInstruction
{
    char    Text[128];
    DWORD*  pComment;
    DWORD   CommentSize;

    // instruction tokens
    DWORD   Opcode;
    DWORD   DstParam;
    DWORD   SrcParam[3];
    DWORD   SrcParamCount;
    UINT    uiTSSNum;
    BOOL    bTexOp;

    BOOL    bQueueWrite;
    BOOL    bFlushQueue;        // flush write - TRUE for all singly issued instructions, 
                                // and for the last in any sequence of co-issued instructions.

} PixelShaderInstruction;

// Enum listing refrast's pixelshader register files
typedef enum _RDPS_REGISTER_TYPE
{
    RDPSREG_UNINITIALIZED_TYPE = 0,
    RDPSREG_INPUT,
    RDPSREG_TEMP,
    RDPSREG_CONST,
    RDPSREG_TEXTURE,
    RDPSREG_POSTMODSRC,
    RDPSREG_SCRATCH,
    RDPSREG_QUEUEDWRITE,
    RDPSREG_ZERO,
    RDPSREG_ONE,
    RDPSREG_TWO,
} RDPS_REGISTER_TYPE;

// Type that is a pointer to an array of RGBA vectors.
typedef FLOAT (*PRGBAVEC)[4];

// Type used to refer to a register.
class RDPSRegister
{
private:
    RDPS_REGISTER_TYPE  m_RegType;
    UINT                m_RegNum;
    PRGBAVEC            m_pReg;       // pointer to [4][4] array -> 4 pixel RGBA
                                      // this is computed when m_RegType and m_RegNum are set
public:
    RDPSRegister() {m_pReg = NULL; m_RegType = RDPSREG_UNINITIALIZED_TYPE; m_RegNum = (UINT)-1;}
    void Set(RDPS_REGISTER_TYPE RegType, UINT RegNum, RefRast* pRast);
    inline RDPS_REGISTER_TYPE GetRegType() {return m_RegType;}
    inline UINT GetRegNum() {return m_RegNum;}
    inline PRGBAVEC GetRegPtr() {return m_pReg;}
};

// "RISC" opcodes which are used to implement D3DSIO_ API pixelshader instructions
typedef enum _RDPS_INSTRUCTION_OPCODE_TYPE
{
    RDPSINST_EVAL,
    RDPSINST_SAMPLE,
    RDPSINST_KILL,
    RDPSINST_BEM,
    RDPSINST_LUMINANCE,
    RDPSINST_DEPTH,
    RDPSINST_SRCMOD,
    RDPSINST_SWIZZLE,
    RDPSINST_DSTMOD,
    RDPSINST_MOV,
    RDPSINST_RCP,
    RDPSINST_FRC,
    RDPSINST_ADD,
    RDPSINST_SUB,
    RDPSINST_MUL,
    RDPSINST_DP3,
    RDPSINST_DP4,
    RDPSINST_MAD,
    RDPSINST_LRP,
    RDPSINST_CND,
    RDPSINST_CMP,
    RDPSINST_END,

    RDPSINST_TEXCOVERAGE,
    RDPSINST_QUADLOOPBEGIN,
    RDPSINST_QUADLOOPEND,
    RDPSINST_QUEUEWRITE,
    RDPSINST_FLUSHQUEUE,
    RDPSINST_NEXTD3DPSINST,

} RDPS_INSTRUCTION_OPCODE_TYPE;

// Structures defining the parameters for all the "RISC" opcodes listed above.
// RDPSINST_BASE_PARAMS is the root from which the rest are inherited.


typedef struct _RDPSINST_BASE_PARAMS
{
public:
    union{
        RDPS_INSTRUCTION_OPCODE_TYPE   Inst;

        // Force structure alignment to pointer-size multiples.
        // IA64 (at least) needs this for structure packing to work.
        void*                          AlignmentDummy; 
    };

} RDPSINST_BASE_PARAMS;

typedef struct _RDPSINST_EVAL_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    UINT            uiCoordSet;
    BOOL            bIgnoreD3DTTFF_PROJECTED;
    BOOL            bClamp;
} RDPSINST_EVAL_PARAMS;

typedef struct _RDPSINST_SAMPLE_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    CoordReg;
    UINT            uiStage;
} RDPSINST_SAMPLE_PARAMS;

typedef struct _RDPSINST_BEM_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    BYTE            WriteMask;
    UINT            uiStage;
} RDPSINST_BEM_PARAMS;

typedef struct _RDPSINST_LUMINANCE_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    UINT            uiStage;
} RDPSINST_LUMINANCE_PARAMS;

typedef struct _RDPSINST_DEPTH_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
} RDPSINST_DEPTH_PARAMS;

typedef struct _RDPSINST_KILL_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
} RDPSINST_KILL_PARAMS;

typedef struct _RDPSINST_SRCMOD_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    BYTE            WriteMask;
    BOOL            bBias;
    BOOL            bTimes2;
    BOOL            bComplement;
    FLOAT           fRangeMin;
    FLOAT           fRangeMax;
} RDPSINST_SRCMOD_PARAMS;

typedef struct _RDPSINST_SWIZZLE_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    BYTE            WriteMask;
    BYTE            Swizzle;
} RDPSINST_SWIZZLE_PARAMS;

typedef struct _RDPSINST_DSTMOD_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    BYTE            WriteMask;
    FLOAT           fScale;
    FLOAT           fRangeMin;
    FLOAT           fRangeMax;
} RDPSINST_DSTMOD_PARAMS;

typedef struct _RDPSINST_MOV_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    BOOL            bSrcReg0_Negate;
    BYTE            WriteMask;
} RDPSINST_MOV_PARAMS;

typedef struct _RDPSINST_FRC_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    BOOL            bSrcReg0_Negate;
    BYTE            WriteMask;
} RDPSINST_FRC_PARAMS;

typedef struct _RDPSINST_RCP_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    BOOL            bSrcReg0_Negate;
    BYTE            WriteMask;
} RDPSINST_RCP_PARAMS;

typedef struct _RDPSINST_ADD_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    BYTE            WriteMask;
} RDPSINST_ADD_PARAMS;

typedef struct _RDPSINST_SUB_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    BYTE            WriteMask;
} RDPSINST_SUB_PARAMS;

typedef struct _RDPSINST_MUL_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    BYTE            WriteMask;
} RDPSINST_MUL_PARAMS;

typedef struct _RDPSINST_DP3_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    BYTE            WriteMask;
} RDPSINST_DP3_PARAMS;

typedef struct _RDPSINST_DP4_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    BYTE            WriteMask;
} RDPSINST_DP4_PARAMS;

typedef struct _RDPSINST_MAD_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    RDPSRegister    SrcReg2;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    BOOL            bSrcReg2_Negate;
    BYTE            WriteMask;
} RDPSINST_MAD_PARAMS;

typedef struct _RDPSINST_LRP_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    RDPSRegister    SrcReg2;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    BOOL            bSrcReg2_Negate;
    BYTE            WriteMask;
} RDPSINST_LRP_PARAMS;

typedef struct _RDPSINST_CND_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    RDPSRegister    SrcReg2;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    BOOL            bSrcReg2_Negate;
    BYTE            WriteMask;
} RDPSINST_CND_PARAMS;

typedef struct _RDPSINST_CMP_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    RDPSRegister    SrcReg0;
    RDPSRegister    SrcReg1;
    RDPSRegister    SrcReg2;
    BOOL            bSrcReg0_Negate;
    BOOL            bSrcReg1_Negate;
    BOOL            bSrcReg2_Negate;
    BYTE            WriteMask;
} RDPSINST_CMP_PARAMS;

typedef struct _RDPSINST_END_PARAMS : public RDPSINST_BASE_PARAMS
{
} RDPSINST_END_PARAMS;

typedef struct _RDPSINST_TEXCOVERAGE_PARAMS : public RDPSINST_BASE_PARAMS
{
    UINT        uiStage;
    FLOAT       (*pGradients)[2];
    FLOAT*      pDUDX_0;
    FLOAT*      pDUDX_1;
    FLOAT*      pDUDY_0;
    FLOAT*      pDUDY_1;
    FLOAT*      pDVDX_0;
    FLOAT*      pDVDX_1;
    FLOAT*      pDVDY_0;
    FLOAT*      pDVDY_1;
    FLOAT*      pDWDX_0;
    FLOAT*      pDWDX_1;
    FLOAT*      pDWDY_0;
    FLOAT*      pDWDY_1;
} RDPSINST_TEXCOVERAGE_PARAMS;

typedef struct _RDPSINST_QUADLOOPBEGIN_PARAMS : public RDPSINST_BASE_PARAMS
{
} RDPSINST_QUADLOOPBEGIN_PARAMS;

typedef struct _RDPSINST_QUADLOOPEND_PARAMS : public RDPSINST_BASE_PARAMS
{
    size_t      JumpBackByOffset;
} RDPSINST_QUADLOOPEND_PARAMS;

typedef struct _RDPSINST_QUEUEWRITE_PARAMS : public RDPSINST_BASE_PARAMS
{
    RDPSRegister    DstReg;
    BYTE            WriteMask;
} RDPSINST_QUEUEWRITE_PARAMS;

typedef struct _RDPSINST_FLUSHQUEUE_PARAMS : public RDPSINST_BASE_PARAMS
{
} RDPSINST_FLUSHQUEUE_PARAMS;

typedef struct _RDPSINST_NEXTD3DPSINST_PARAMS : public RDPSINST_BASE_PARAMS
{
    PixelShaderInstruction* pInst;
} RDPSINST_NEXTD3DPSINST_PARAMS;

// End of "RISC" instruction parameter definitions

typedef struct _ConstDef
{
    float   f[4];
    UINT    RegNum;
} ConstDef;

typedef struct _PSQueuedWriteDst
{
    RDPSRegister    DstReg;
    BYTE            WriteMask;
} PSQueuedWriteDst;

#define RDPS_COMPONENTMASK_SHIFT    16
#define RDPS_COMPONENTMASK_0        (D3DSP_WRITEMASK_0 >> RDPS_COMPONENTMASK_SHIFT)
#define RDPS_COMPONENTMASK_1        (D3DSP_WRITEMASK_1 >> RDPS_COMPONENTMASK_SHIFT)
#define RDPS_COMPONENTMASK_2        (D3DSP_WRITEMASK_2 >> RDPS_COMPONENTMASK_SHIFT)
#define RDPS_COMPONENTMASK_3        (D3DSP_WRITEMASK_3 >> RDPS_COMPONENTMASK_SHIFT)
#define RDPS_COMPONENTMASK_ALL      (D3DSP_WRITEMASK_ALL >> RDPS_COMPONENTMASK_SHIFT)

#define RDPS_NOSWIZZLE          (D3DSP_NOSWIZZLE >> D3DSP_SWIZZLE_SHIFT)
#define RDPS_REPLICATERED       (D3DSP_REPLICATERED >> D3DSP_SWIZZLE_SHIFT)
#define RDPS_REPLICATEGREEN     (D3DSP_REPLICATEGREEN >> D3DSP_SWIZZLE_SHIFT)
#define RDPS_REPLICATEBLUE      (D3DSP_REPLICATEBLUE >> D3DSP_SWIZZLE_SHIFT)
#define RDPS_REPLICATEALPHA     (D3DSP_REPLICATEALPHA >> D3DSP_SWIZZLE_SHIFT)
#define RDPS_SELECT_R           0
#define RDPS_SELECT_G           1
#define RDPS_SELECT_B           2
#define RDPS_SELECT_A           3

// creates BYTE swizzle description:  bits xxyyzzww made of RSPS_SELECT_* for each component
#define _Swizzle(x,y,z,w)   ((x)|(y<<2)|(z<<4)|(w<<6))

//-----------------------------------------------------------------------------
//
// RDPShader: Pixel Shader Class
//
//-----------------------------------------------------------------------------
class RDPShader
{
public:
    RDPShader();
    ~RDPShader();
    HRESULT     Initialize(RefDev* pRD, DWORD* pCode, DWORD ByteCodeSize, D3DCAPS8* pCaps);


    RefDev*     m_pRD;

    DWORD*      m_pCode;    // function tokens passed to API
    UINT        m_CodeSize; // number of DWORDs

    // info extracted by parsing shader
    UINT        m_cActiveTextureStages; // number of texture stages used by this shader
    DWORD       m_ReferencedTexCoordMask; // Which texture coordinate sets are referenced
    UINT        m_cInst;                // number of shader instructions
    PixelShaderInstruction* m_pInst;    // processed instructions

    GArrayT<BYTE> m_RDPSInstBuffer;  // buffer containint refrast "RISC" translated version of shader
    UINT        m_cConstDefs;           // number of D3DSIO_DEF instructions
    ConstDef*   m_pConstDefs;           // array of constant definitions

};
typedef RDPShader *PRDPSHADER;


//-----------------------------------------------------------------------------
// Struct holding the shader ptr
//-----------------------------------------------------------------------------
struct RDPShaderHandle
{
    RDPShaderHandle()
    {
        m_pShader = NULL;
#if DBG
        m_tag = 0;
#endif
    }
    RDPShader* m_pShader;
#if DBG
    // Non zero means that it has been allocated
    DWORD      m_tag;
#endif
};

// psutil.cpp
int
PixelShaderInstDisAsm(
    char* pStrRet, int StrSizeRet, DWORD* pShader, DWORD Flags );

void
RDPSDisAsm(BYTE*        pRDPSInstBuffer, 
           ConstDef*    pConstDefs, 
           UINT         cConstDefs, 
           FLOAT        fMaxPixelShaderValue,
           DWORD        dwVersion);


#endif _PSHADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\inc\reftnl.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// reftnl.hpp
//
// Direct3D Reference Transform and Lighting - Main Header File
//
///////////////////////////////////////////////////////////////////////////////
#ifndef  _REFTNL_HPP
#define  _REFTNL_HPP

#define RD_GB_LEFT   -32768.f
#define RD_GB_TOP    -32768.f
#define RD_GB_RIGHT   32767.f
#define RD_GB_BOTTOM  32767.f

//-----------------------------------------------------------------------------
//
// Constants
//
//-----------------------------------------------------------------------------
// Default color values that should be used when ther is no lighting and
// color in vertices provided
const DWORD RD_DEFAULT_DIFFUSE  = 0xFFFFFFFF;
const DWORD RD_DEFAULT_SPECULAR = 0;

const DWORD RD_MAX_FVF_TEXCOORD = 8;

const DWORD RD_MAX_VERTEX_COUNT = 2048;

// Number of clipping planes
const DWORD RD_MAX_USER_CLIPPLANES = 6;

// Number of clipping planes
const DWORD RD_MAX_CLIPPING_PLANES = (6+RD_MAX_USER_CLIPPLANES);

// Number of blend weights
const DWORD RD_MAX_BLEND_WEIGHTS = 4;

// Number of world matrices
const DWORD RD_MAX_WORLD_MATRICES = 256;

const DWORD RD_WORLDMATRIXBASE  = 256;

// Space for vertices generated/copied while clipping one triangle
const DWORD RD_MAX_CLIP_VERTICES = (( 2 * RD_MAX_CLIPPING_PLANES ) + 3 );

// 3 verts. -> 1 tri, 4 v -> 2 t, N vertices -> (N - 2) triangles
const DWORD RD_MAX_CLIP_TRIANGLES = ( RD_MAX_CLIP_VERTICES - 2 );

// make smaller than guard band for easier clipping
const float RD_MAX_POINT_SIZE = 64;

//-----------------------------------------------------------------------------
//
// Forward defines
//
//-----------------------------------------------------------------------------
class RDLight;

//-----------------------------------------------------------------------------
//
// Typedefs
//
//-----------------------------------------------------------------------------
typedef DWORD RDCLIPCODE;
typedef D3DMATRIX RDMATRIX;

//-----------------------------------------------------------------------------
//
// RDVertex - Internal vertex structure of the refrast. This is the
//            structure exchanged between the T&L and Rasterization parts
//            of the refrast.
//
//-----------------------------------------------------------------------------

class RDVertex
{
public:
    RDVertex()
    {
        Init();
    }

    RDVertex( LPDWORD pVtx, DWORD dwFvf )
    {
        SetFvfData( pVtx, (UINT64)dwFvf );
    }

    RDVertex( LPDWORD pVtx, UINT64 qwFvf )
    {
        SetFvfData( pVtx, qwFvf );
    }

    RDCLIPCODE m_clip;
    FLOAT      m_clip_x;
    FLOAT      m_clip_y;
    FLOAT      m_clip_z;
    FLOAT      m_clip_w;
    RDVECTOR3  m_pos;            // This is screen coordinates
    FLOAT      m_rhw;
    RDCOLOR4   m_diffuse;        // ARGB (0..1 each component)
    RDCOLOR4   m_specular;       // ARGB
    FLOAT      m_fog;            // 0..1
    FLOAT      m_pointsize;
    RDVECTOR4  m_tex[8];

    UINT64 m_qwFVF;

    void Init()
    {
        m_clip = 0;
        m_clip_x = m_clip_y = m_clip_z = m_clip_w = 0.0f;
        m_rhw = 0.0f;
        m_diffuse.a = m_diffuse.r = m_diffuse.g = m_diffuse.b = 1.0f;
        m_specular.a = m_specular.r = m_specular.g = m_specular.b = 0.0f;
        m_fog = 0.0f;
        m_pointsize = 1.0f;
        // Initialize texture coordinates to {0.0, 0.0, 0.0, 1.0}
        memset( m_tex, 0, sizeof(m_tex) );
        for( int i=0; i<8; i++ ) m_tex[i].w = 1.0f;
        m_qwFVF = 0;
    }

    void SetFVF( UINT64 qwControl )
    {
        m_qwFVF = qwControl;
    }

    void SetFvfData( LPDWORD pVtx, UINT64 qwFVF )
    {
        DWORD cDWORD = 0;
        Init();
        m_qwFVF = qwFVF;
        switch( qwFVF & D3DFVF_POSITION_MASK )
        {
        case D3DFVF_XYZRHW:
            memcpy( &m_pos, pVtx, 3*sizeof( float ) );
            pVtx += 3;
            m_rhw = *(float *)(pVtx);
            pVtx += 1;
            break;
        default:
            _ASSERT( TRUE, "RDVertex can only hold Transformed Vertices" );
            return;
        }

        if (qwFVF & D3DFVF_PSIZE)
        {
            m_pointsize = *(FLOAT*)pVtx;
            pVtx++;
        }
        if (qwFVF & D3DFVF_DIFFUSE)
        {
            MakeRDCOLOR4( &m_diffuse, *pVtx );
            pVtx++;
        }
        if (qwFVF & D3DFVF_SPECULAR)
        {
            MakeRDCOLOR4( &m_specular, *pVtx );
            m_fog = m_specular.a;
            m_qwFVF |= D3DFVFP_FOG;
            pVtx++;
        }
        if (qwFVF & D3DFVF_FOG)
        {
            m_fog = *(FLOAT*)pVtx;
            m_qwFVF |= D3DFVFP_FOG;
            pVtx++;
        }
        DWORD dwNumTexCoord = (DWORD)(FVF_TEXCOORD_NUMBER(qwFVF));
        DWORD dwTextureFormats = (DWORD)qwFVF >> 16;

        // Texture formats size  00   01   10   11
        static DWORD dwTextureSize[4] = {2, 3, 4, 1};
        for (DWORD i=0; i < dwNumTexCoord; i++)
        {
            memcpy( &m_tex[i], pVtx,
                    sizeof( float )*dwTextureSize[dwTextureFormats & 3] );
            pVtx += dwTextureSize[dwTextureFormats & 3];
            dwTextureFormats >>= 2;
        }
    }

    FLOAT GetRHW( void ) const
    {
        return ( m_qwFVF & D3DFVF_XYZRHW ) ? m_rhw : 1.f ;
    }

    FLOAT* GetPtrXYZ( void ) { return (FLOAT*)&m_pos; }
    FLOAT GetX( void ) const  { return m_pos.x; }
    FLOAT GetY( void ) const  { return m_pos.y; }
    FLOAT GetZ( void ) const  { return m_pos.z; }
    DWORD GetDiffuse( void ) const
    {
        DWORD diff =
            D3DRGBA(m_diffuse.r, m_diffuse.g, m_diffuse.b, m_diffuse.a);
        // return color if available else white (default)
        return ( m_qwFVF & D3DFVF_DIFFUSE ) ? diff : 0xffffffff;
    }

    DWORD GetSpecular( void ) const
    {
        DWORD spec =
            D3DRGBA(m_specular.r, m_specular.g, m_specular.b, m_specular.a);
        // return color if available else black (default)
        return ( m_qwFVF & D3DFVF_SPECULAR ) ? spec : 0x00000000;
    }

    UINT TexCrdCount( void ) const
    {
        return
            (UINT)(( m_qwFVF & D3DFVF_TEXCOUNT_MASK ) >> D3DFVF_TEXCOUNT_SHIFT);
    }

    FLOAT GetTexCrd( UINT iCrd, UINT iCrdSet ) const
    {
        // This function ensures that right defaults are returned.
        // Note, except for the q coordinate (which defaults to 1.0)
        // the rest are 0.0.
        if( (iCrdSet < TexCrdCount()) &&
            (iCrd < GetTexCoordDim(m_qwFVF, iCrdSet)) )
        {
            return *( (FLOAT*)&m_tex[iCrdSet] + iCrd );
        }
        else if( iCrd == 3 )
        {
            return 1.0f;
        }
        else
        {
            return 0.0f;
        }
    }

    FLOAT GetLastTexCrd( UINT iCrdSet ) const
    {
        // Return the last texture coordinate if present else 1.0
        if( iCrdSet < TexCrdCount() )
        {
            return *( (FLOAT*)&m_tex[iCrdSet] +
                      GetTexCoordDim(m_qwFVF, iCrdSet) - 1);
        }
        else
        {
            return 1.0f;
        }
    }

    FLOAT GetPointSize( void ) const
    {
        return ( m_qwFVF & D3DFVF_PSIZE ) ? m_pointsize : 1.0f;
    }

    FLOAT GetFog( void ) const
    {
        return ( m_qwFVF & D3DFVFP_FOG ) ? m_fog : 0.0f;
    }
};

class RDClipVertex : public RDVertex
{
public:
    RDClipVertex()
    {
        next = NULL;
    }

    RDClipVertex  *next;
};

struct RDCLIPTRIANGLE
{
    RDCLIPTRIANGLE()
    {
        memset( this, 0, sizeof(*this) );
    }

    RDClipVertex  *v[3];
};

struct RDUSERCLIPPLANE
{
    RDUSERCLIPPLANE()
    {
        memset( this, 0, sizeof(*this) );
    }

    RDVECTOR4       plane;
    BOOL            bActive;
};

//-----------------------------------------------------------------------------
//
// RDTRANSFORMDATA - Transformation data used by Refrence T&L implementation
// to transform vertices.
//
//-----------------------------------------------------------------------------
struct RDTRANSFORMDATA
{
    RDTRANSFORMDATA()
    {
        memset( this, 0, sizeof(*this) );
    }

    RDMATRIX      m_PS;         // Mproj * Mshift
    RDMATRIX      m_VPS;        // Mview * PS
    RDMATRIX      m_VPSInv;     // Inverse( Mview * PS )
    RDMATRIX      m_CTMI;       // Inverse current transformation matrix
    RDVECTOR4     m_frustum[6]; // Normalized plane equations for viewing
    // frustum in the model space
    DWORD          m_dwFlags;
};

//---------------------------------------------------------------------
// RDLIGHTINGDATA
// All the lighting related state clubbed together
//---------------------------------------------------------------------

struct RDLIGHTINGDATA
{
    RDLIGHTINGDATA()
    {
        memset( this, 0, sizeof(*this) );
    }

    // Active Light list
    RDLight           *pActiveLights;

    // Temporary data used when computing lighting

    RDVECTOR3       eye_in_eye;         // eye position in eye space
    // It is (0, 0, 0)

    // Ma * La + Me (Ambient and Emissive) ------
    RDCOLOR3           ambEmiss;

    // ColorVertex stuff ------------------------
    RDCOLOR3 *pAmbientSrc;
    RDCOLOR3 *pDiffuseSrc;
    RDCOLOR3 *pSpecularSrc;
    RDCOLOR3 *pEmissiveSrc;

    // Diffuse ----------------------------------
    RDCOLOR3           vertexDiffuse; // Provided with a vertex, used if
    // COLORVERTEX is enabled and a diffuse
    // color is provided in the vertex
    RDCOLOR3           diffuse;       // Diffuse accumulates here
    DWORD             outDiffuse;    // Diffuse color result of lighting


    // Specular --------------------------------
    RDCOLOR3           vertexSpecular;// Provided with a vertex, used if
    // COLORVERTEX is enabled and a specular
    // color is provided in the vertex
    RDCOLOR3           specular;      // Specular accumulates here
    DWORD             outSpecular;   // Specular color result of lighting

    D3DVALUE          specThreshold;  // If the dot product is less than this
    // value, specular factor is zero
    // End of temporary data

    // RENDERSTATEAMBIENT --------------------------------------

    // Ambient color set by D3DRENDERSTATE_AMBIENT
    // They are all scaled to 0 - 1
    D3DVALUE          ambient_red;
    D3DVALUE          ambient_green;
    D3DVALUE          ambient_blue;
    DWORD             ambient_save;       // Original unscaled color

    // Fog -----------------------------------------------------
    int               fog_mode;
    D3DCOLOR          fog_color;
    D3DVALUE          fog_density;
    D3DVALUE          fog_start;
    D3DVALUE          fog_end;
    D3DVALUE          fog_factor;     // 255 / (fog_end - fog_start)

    D3DCOLORMODEL     color_model;

    // Material ------------------------------------------------

    // For color material
    LPDWORD           pDiffuseAlphaSrc;
    LPDWORD           pSpecularAlphaSrc;

    DWORD               materialDiffAlpha;  // Current material diffuse
    // alpha (0-255) shifted left
    // by 24 bits

    DWORD               materialSpecAlpha;  // Current material specular
    // alpha (0-255) shifted left
    // by 24 bits

    DWORD               vertexDiffAlpha;    // Current material diffuse
    // alpha (0-255) shifted left
    // by 24 bits

    DWORD               vertexSpecAlpha;    // Current material specular
    // alpha (0-255) shifted left
    // by 24 bits

    D3DMATERIAL7      material;           // Cached material data
    RDCOLOR3           matAmb;
    RDCOLOR3           matDiff;
    RDCOLOR3           matSpec;
    RDCOLOR3           matEmis;
};

//-----------------------------------------------------------------------------
//
// RDLight - The light object used by the Reference T&L implementation
// An array of these are instanced in the RefDev object.
//
//-----------------------------------------------------------------------------
struct RDLIGHTI
{
    RDLIGHTI()
    {
        memset( this, 0, sizeof(*this) );
    }

    DWORD           flags;

    RDVECTOR3       position_in_eye;  // In the eye space
    RDVECTOR3       direction_in_eye; // In the eye space

    //
    // Saved light colors scaled from 0 - 255, needed for COLORVERTEX
    //
    D3DCOLORVALUE   La;         //  light ambient
    D3DCOLORVALUE   Ld;         //  light diffuse
    D3DCOLORVALUE   Ls;         //  light specular

    //
    // Precomputed colors scaled from 0 - 255,
    //
    D3DCOLORVALUE   Ma_La;         // Material ambient times light ambient
    D3DCOLORVALUE   Md_Ld;         // Material diffuse times light diffuse
    D3DCOLORVALUE   Ms_Ls;         // Material specular times light specular


    RDVECTOR3       halfway;

    // Stuff for SpotLights
    D3DVALUE        range_squared;
    D3DVALUE        cos_theta_by_2;
    D3DVALUE        cos_phi_by_2;
    D3DVALUE        inv_theta_minus_phi;

};


//-----------------------------------------------------------------------------
// Function pointer to the functions that light a vertex
//-----------------------------------------------------------------------------
typedef void (*RDLIGHTVERTEXFN)( RDLIGHTINGDATA& LData, D3DLIGHT7 *pLight,
                                 RDLIGHTI *pLightI, RDLIGHTINGELEMENT *in,
                                 DWORD dwFlags, UINT64 qwFVFIn );

//-----------------------------------------------------------------------------
// Functions to compute lighting
//-----------------------------------------------------------------------------
struct RDLIGHTVERTEX_FUNC_TABLE
{
    RDLIGHTVERTEX_FUNC_TABLE()
    {
        memset( this, 0, sizeof(*this) );
    }

    RDLIGHTVERTEXFN   pfnDirectional;
    RDLIGHTVERTEXFN   pfnParallelPoint;
    RDLIGHTVERTEXFN   pfnSpot;
    RDLIGHTVERTEXFN   pfnPoint;
};

//-----------------------------------------------------------------------------
//
// RDLight - The light object used by the Reference T&L implementation
// An array of these are instanced in the RefDev object.
//
//-----------------------------------------------------------------------------
#define RDLIGHT_ENABLED              0x00000001  // Is the light active
#define RDLIGHT_NEEDSPROCESSING      0x00000002  // Is the light data processed
#define RDLIGHT_REFERED              0x00000004  // Has the light been refered
                                                 // to

class RDLight : public RDAlloc
{
public:
    RDLight();
    BOOL IsEnabled() {return (m_dwFlags & RDLIGHT_ENABLED);}
    BOOL NeedsProcessing() {return (m_dwFlags & RDLIGHT_NEEDSPROCESSING);}
    BOOL IsRefered() { return (m_dwFlags & RDLIGHT_REFERED); }
    HRESULT SetLight(LPD3DLIGHT7 pLight);
    HRESULT GetLight( LPD3DLIGHT7 pLight );
    void ProcessLight( D3DMATERIAL7 *mat, RDLIGHTVERTEX_FUNC_TABLE *pTbl);
    void XformLight( D3DMATRIX* mV );
    void Enable( RDLight **ppRoot );
    void Disable( RDLight **ppRoot );

private:

    // Flags
    DWORD m_dwFlags;

    // Active List next element
    RDLight *m_Next;

    // Specific function to light the vertex
    RDLIGHTVERTEXFN   m_pfnLightVertex;

    // Light data set by the runtime
    D3DLIGHT7 m_Light;

    // Light data computed by the driver
    RDLIGHTI  m_LightI;

    friend class RefDev;
    friend class RefVP;
};

//---------------------------------------------------------------------
//
// The clipper object. Contains digested Viewport information
// calculated from viewport settings.
//
//---------------------------------------------------------------------
class RefClipper
{
public:
    RefClipper();

    // The pointer to the driver object to obtain state
    RefDev* m_pDev;

    // m_dwDirtyFlags
    static const DWORD RCLIP_DIRTY_ZRANGE;
    static const DWORD RCLIP_DIRTY_VIEWRECT;
    static const DWORD RCLIP_DO_FLATSHADING;
    static const DWORD RCLIP_DO_WIREFRAME;
    static const DWORD RCLIP_DO_ADJUSTWRAP;
    static const DWORD RCLIP_Z_ENABLE;
    DWORD m_dwFlags;

    // Viewport data from the DDI.
    D3DVIEWPORT7 m_Viewport;

    // Is it guardband or not ?
    BOOL m_bUseGB;

    D3DVALUE dvX;               // dwX
    D3DVALUE dvY;               // dwY
    D3DVALUE dvWidth;           // dwWidth
    D3DVALUE dvHeight;          // dwHeight

    // Coefficients to compute screen coordinates from normalized window
    // coordinates
    D3DVALUE scaleX;            // dvWidth/2
    D3DVALUE scaleY;            // dvHeight/2
    D3DVALUE scaleZ;            // (Viewport->dvMaxZ - Viewport->dvMinZ)
    D3DVALUE offsetX;           // dvX + scaleX
    D3DVALUE offsetY;           // dvY + scaleY
    D3DVALUE offsetZ;           // Viewport->dvMinZ

    // Coefficients to compute screen coordinates from normalized window
    // coordinates
    D3DVALUE scaleXi;           // Inverse of scaleX
    D3DVALUE scaleYi;           // Inverse of scaleY
    D3DVALUE scaleZi;           // Inverse of scaleZ

    // Min and max values for viewport window in pixels
    D3DVALUE minX;              // offsetX - scaleX
    D3DVALUE minY;              // offsetY - scaleY
    D3DVALUE maxX;              // offsetX + scaleX
    D3DVALUE maxY;              // offsetY + scaleY

    // Min and max window values with guard band in pixels
    D3DVALUE minXgb;
    D3DVALUE minYgb;
    D3DVALUE maxXgb;
    D3DVALUE maxYgb;

    // Coefficients to transform a vertex to perform the guard band clipping
    // x*gb11 + w*gb41
    // y*gb22 + w*gb42
    //
    D3DVALUE gb11;
    D3DVALUE gb22;
    D3DVALUE gb41;
    D3DVALUE gb42;

    // Coefficients to apply clipping rules for the guard band clipping
    // They are used by clipping routins
    // w*Kgbx1 < x < w*Kgbx2
    // w*Kgby1 < y < w*Kgby2
    //
    D3DVALUE Kgbx1;
    D3DVALUE Kgby1;
    D3DVALUE Kgbx2;
    D3DVALUE Kgby2;


    // Clipping related
    RDCLIPCODE m_clipUnion;            // OR of all vertex clip flags
    RDCLIPCODE m_clipIntersection;     // AND of all vertex clip flags

    GArrayT<RDVertex>  ClipBuf;
    RDClipVertex  *clip_vbuf1[RD_MAX_CLIP_VERTICES];
    RDClipVertex  *clip_vbuf2[RD_MAX_CLIP_VERTICES];
    RDClipVertex **current_vbuf;  // clip_vbuf1 or clip_vbuf2
    RDClipVertex   clip_vertices[RD_MAX_CLIP_VERTICES];
    DWORD       m_dwInterpolate;
    int         clip_vertices_used;
    RDCOLOR4    clip_color;
    RDCOLOR4    clip_specular;

    // User defined clipping planes
    RDVECTOR4 m_userClipPlanes[RD_MAX_USER_CLIPPLANES];

    // User clip planes transformed
    RDUSERCLIPPLANE m_xfmUserClipPlanes[RD_MAX_USER_CLIPPLANES];

    //---------------------------------------------------
    // Methods
    //---------------------------------------------------
    HRESULT UpdateViewData();
    void MakeClipVertexFromVertex( RDClipVertex& cv, RDVertex& v,
                                   DWORD dwClipMask);
    inline BOOL UseGuardBand() { return m_bUseGB; }
    RDCLIPCODE ComputeClipCodes(RDCLIPCODE* pclipIntersection,
                                RDCLIPCODE* pclipUnion, FLOAT x_clip,
                                FLOAT y_clip, FLOAT z_clip, FLOAT w_clip);
    void ComputeClipCodesTL( RDVertex* pVtx );
    void Interpolate( RDClipVertex *out, RDClipVertex *p1, RDClipVertex *p2,
                      int code, D3DVALUE num, D3DVALUE denom );
    int ClipByPlane( RDClipVertex **inv, RDClipVertex **outv, RDVECTOR4 *plane,
                     DWORD dwClipFlag, int count );
    int ClipLineByPlane( RDCLIPTRIANGLE *line, RDVECTOR4 *plane,
                         DWORD dwClipBit);
    void ComputeScreenCoordinates( RDClipVertex **inv, int count );
    DWORD ComputeClipCodeGB( RDClipVertex *p );
    DWORD ComputeClipCode( RDClipVertex *p );
#if 0
    DWORD ComputeClipCodeUserPlanes( RDUSERCLIPPLANE *UserPlanes,
                                     RDClipVertex *p);
#endif
    int ClipLeft( RDClipVertex **inv, RDClipVertex **outv, int count);
    int ClipRight( RDClipVertex **inv, RDClipVertex **outv, int count);
    int ClipTop( RDClipVertex **inv, RDClipVertex **outv, int count);
    int ClipBottom( RDClipVertex **inv, RDClipVertex **outv, int count);
    int ClipFront( RDClipVertex **inv, RDClipVertex **outv, int count);
    int ClipBack( RDClipVertex **inv, RDClipVertex **outv, int count);
    int ClipLeftGB( RDClipVertex **inv, RDClipVertex **outv, int count);
    int ClipRightGB( RDClipVertex **inv, RDClipVertex **outv, int count);
    int ClipTopGB( RDClipVertex **inv, RDClipVertex **outv, int count);
    int ClipBottomGB( RDClipVertex **inv, RDClipVertex **outv, int count);

    int ClipLineLeft( RDCLIPTRIANGLE *inv);
    int ClipLineRight( RDCLIPTRIANGLE *inv);
    int ClipLineTop( RDCLIPTRIANGLE *inv);
    int ClipLineBottom( RDCLIPTRIANGLE *inv);
    int ClipLineFront( RDCLIPTRIANGLE *inv);
    int ClipLineBack( RDCLIPTRIANGLE *inv);
    int ClipLineLeftGB( RDCLIPTRIANGLE *inv);
    int ClipLineRightGB( RDCLIPTRIANGLE *inv);
    int ClipLineTopGB( RDCLIPTRIANGLE *inv);
    int ClipLineBottomGB( RDCLIPTRIANGLE *inv);

    int ClipSingleLine( RDCLIPTRIANGLE *line );
    int ClipSingleTriangle( RDCLIPTRIANGLE *tri,
                            RDClipVertex ***clipVertexPointer );

    void DrawPoint( RDVertex* pvV0 );
    void DrawLine( RDVertex* pvV0, RDVertex* pvV1 );
    void DrawTriangle( RDVertex* pvV0, RDVertex* pvV1, RDVertex* pvV2,
                       WORD wFlags = D3DTRIFLAG_EDGEENABLETRIANGLE );

    HRESULT DrawOnePrimitive( GArrayT<RDVertex>& VtxArray,
                              DWORD dwStartVertex,
                              D3DPRIMITIVETYPE PrimType,
                              UINT cVertices );
    HRESULT DrawOneIndexedPrimitive( GArrayT<RDVertex>& VtxArray,
                                     int StartVertexIndex,
                                     LPWORD pIndices,
                                     DWORD StartIndex,
                                     UINT  cIndices,
                                     D3DPRIMITIVETYPE PrimType );
    HRESULT DrawOneIndexedPrimitive( GArrayT<RDVertex>& VtxArray,
                                     int StartVertexIndex,
                                     LPDWORD pIndices,
                                     DWORD StartIndex,
                                     UINT  cIndices,
                                     D3DPRIMITIVETYPE PrimType );

};


// RefVP::m_dwTLState flags
#define RDPV_DOLIGHTING                0x00000001
#define RDPV_DOCLIPPING                0x00000002
#define RDPV_DOFOG                     0x00000004
#define RDPV_DOSPECULAR                0x00000008
#define RDPV_RANGEFOG                  0x00000010
#define RDPV_NORMALIZENORMALS          0x00000020
#define RDPV_LOCALVIEWER               0x00000040
#define RDPV_DOCOMPUTEPOINTSIZE        0x00000080
#define RDPV_DOPOINTSCALE              0x00000100
#define RDPV_DOTEXXFORM                0x00000200
#define RDPV_DOTEXGEN                  0x00000400
#define RDPV_NEEDEYEXYZ                0x00000800
#define RDPV_NEEDEYENORMAL             0x00001000

// ColorVertexFlags
#define RDPV_VERTEXDIFFUSENEEDED       0x00002000
#define RDPV_VERTEXSPECULARNEEDED      0x00004000
#define RDPV_COLORVERTEXAMB            0x00008000
#define RDPV_COLORVERTEXDIFF           0x00010000
#define RDPV_COLORVERTEXSPEC           0x00020000
#define RDPV_COLORVERTEXEMIS           0x00040000
#define RDPV_COLORVERTEXFLAGS     (RDPV_VERTEXDIFFUSENEEDED       | \
                                   RDPV_VERTEXSPECULARNEEDED      | \
                                   RDPV_COLORVERTEXAMB            | \
                                   RDPV_COLORVERTEXDIFF           | \
                                   RDPV_COLORVERTEXSPEC           | \
                                   RDPV_COLORVERTEXEMIS )
#define RDPV_DOINDEXEDVERTEXBLEND      0x00100000
#define RDPV_DOPOSITIONTWEENING        0x00200000
#define RDPV_DONORMALTWEENING          0x00400000


// RefVP::m_dwDirtyFlags flags
#define RDPV_DIRTY_PROJXFM     0x00000001
#define RDPV_DIRTY_VIEWXFM     0x00000002
#define RDPV_DIRTY_WORLDXFM    0x00000004
#define RDPV_DIRTY_WORLD1XFM   0x00000008
#define RDPV_DIRTY_WORLD2XFM   0x00000010
#define RDPV_DIRTY_WORLD3XFM   0x00000020
#define RDPV_DIRTY_XFORM       (RDPV_DIRTY_PROJXFM   | \
                                RDPV_DIRTY_VIEWXFM   | \
                                RDPV_DIRTY_WORLDXFM  | \
                                RDPV_DIRTY_WORLD1XFM | \
                                RDPV_DIRTY_WORLD2XFM | \
                                RDPV_DIRTY_WORLD3XFM)
#define RDPV_DIRTY_MATERIAL        0x00000100
#define RDPV_DIRTY_SETLIGHT        0x00000200
#define RDPV_DIRTY_NEEDXFMLIGHT    0x00000400
#define RDPV_DIRTY_COLORVTX        0x00000800
#define RDPV_DIRTY_LIGHTING    (RDPV_DIRTY_MATERIAL     | \
                                RDPV_DIRTY_SETLIGHT     | \
                                RDPV_DIRTY_NEEDXFMLIGHT | \
                                RDPV_DIRTY_COLORVTX)
#define RDPV_DIRTY_FOG              0x00010000
#define RDPV_DIRTY_INVERSEWORLDVIEW 0x00020000

//---------------------------------------------------------------------
// RDPTRSTRIDE: A class instanced once per vertex element.
//---------------------------------------------------------------------
    class RDPTRSTRIDE
    {
    public:
        RDPTRSTRIDE()
        {
            Null();
        }
        inline void Init( LPVOID pData, DWORD dwStride )
        {
            m_pData = m_pCurrent = pData;
            m_dwStride = dwStride;
        }
        inline void Null()
        {
            memset( this, 0, sizeof( *this ) );
        }
        inline void SetStride( DWORD dwStride )
        {
            m_dwStride = dwStride;
        }
        inline DWORD GetStride()
        {
            return m_dwStride;
        }
        inline LPVOID GetFirst()
        {
            return m_pData;
        }
        inline LPVOID GetCurrent()
        {
            return m_pCurrent;
        }
        inline LPVOID Reset()
        {
            return (m_pCurrent = m_pData);
        }
        inline LPVOID Next()
        {
            m_pCurrent = (LPVOID)((LPBYTE)m_pCurrent + m_dwStride);
            return m_pCurrent;
        }

        LPVOID operator []( DWORD dwIndex ) const
        {
            return (LPVOID)((LPBYTE)m_pData + dwIndex*m_dwStride);
        }


    protected:
        LPVOID m_pData;
        DWORD  m_dwStride; // in number of bytes
        LPVOID m_pCurrent;
        DWORD m_dwCurrentIndex;
    };

//---------------------------------------------------------------------
// Struct holding the shader ptr
//---------------------------------------------------------------------
struct RDVShaderHandle
{
    RDVShaderHandle()
    {
        m_pShader = NULL;
#if DBG
        m_tag = 0;
#endif
    }
    RDVShader* m_pShader;
#if DBG
    // Non zero means that it has been allocated
    DWORD      m_tag;
#endif
};


//---------------------------------------------------------------------
// Fixed function vertex processing pipeline object
//---------------------------------------------------------------------
class RefVP : public RDAlloc
{
protected:

    // The pointer to the driver object to obtain state
    RefDev* m_pDev;

    //-------------------------------------------------------------------------
    // Unprocessed state set by the DDI
    //-------------------------------------------------------------------------
    // Growable Light array
    GArrayT<RDLight>  m_LightArray;

    // Current material to use for lighting
    D3DMATERIAL7 m_Material;

    // Transformation state stored by the reference implementation
    RDMATRIX      m_xfmProj;
    RDMATRIX      m_xfmView;
    RDMATRIX      m_xfmWorld[RD_MAX_WORLD_MATRICES];
    RDMATRIX      m_xfmTex[D3DHAL_TSS_MAXSTAGES];

    //-------------------------------------------------------------------------
    // Vertex Elements
    //-------------------------------------------------------------------------
    RDPTRSTRIDE m_position;
    RDPTRSTRIDE m_position2;
    RDPTRSTRIDE m_blendweights;
    RDPTRSTRIDE m_blendindices;
    RDPTRSTRIDE m_normal;
    RDPTRSTRIDE m_normal2;
    RDPTRSTRIDE m_specular;
    RDPTRSTRIDE m_diffuse;
    RDPTRSTRIDE m_pointsize;
    RDPTRSTRIDE m_tex[8];

    //-------------------------------------------------------------------------
    // Cached T&L related render-state info
    //-------------------------------------------------------------------------
    DWORD m_dwTLState;           // RenderState related flags
    DWORD m_dwDirtyFlags;        // Dirty flags

    //-------------------------------------------------------------------------
    // Transformation data
    //-------------------------------------------------------------------------

    // Current transformation matrix
    RDMATRIX m_xfmCurrent[RD_MAX_WORLD_MATRICES];  // using WORLDi matrix
    RDMATRIX m_xfmToEye[RD_MAX_WORLD_MATRICES];    // Transforms to camera
    // space (Mworld*Mview)
    RDMATRIX m_xfmToEyeInv[RD_MAX_WORLD_MATRICES]; // and its Inverse
    BYTE m_WorldProcessed[RD_MAX_WORLD_MATRICES];

    UINT64  m_qwFVFIn;              // FVF of the input vertices
    UINT64  m_qwFVFOut;             // FVF of the output vertices

    int     m_numVertexBlends;
    RDTRANSFORMDATA m_TransformData;

    FLOAT m_fPointSize;
    FLOAT m_fPointAttA;
    FLOAT m_fPointAttB;
    FLOAT m_fPointAttC;
    FLOAT m_fPointSizeMin;
    FLOAT m_fPointSizeMax;

    FLOAT m_fTweenFactor;

    //-------------------------------------------------------------------------
    // Lighting data
    //-------------------------------------------------------------------------
    RDLIGHTVERTEX_FUNC_TABLE    m_LightVertexTable;
    RDLIGHTINGDATA              m_lighting;   // Lighting state

    DWORD m_dwNumActiveTextureStages;

    ///////////////////////////////////////////////////////////////////////////
    // Methods
    ///////////////////////////////////////////////////////////////////////////

    HRESULT UpdateXformData();
    void UpdateWorld( DWORD i );
    HRESULT UpdateLightingData();
    HRESULT UpdateFogData();
    RDCLIPCODE ProcessVertices( UINT64 outFVF, GArrayT<RDVertex>& VtxArray,
                                DWORD count );
    void LightVertex( RDLIGHTINGELEMENT *le );
    void FogVertex  ( RDVertex& Vout, RDVECTOR3 &v, RDLIGHTINGELEMENT *le,
                      int numVertexBlends, float *pBlendFactors,
                      BOOL bVertexInEyeSpace );

public:
    RefVP();

    inline void LightEnable( DWORD dwIndex, BOOL bEnable )
    {
        if( bEnable )
        {
            m_LightArray[dwIndex].Enable(&m_lighting.pActiveLights);
            m_dwDirtyFlags |= RDPV_DIRTY_SETLIGHT;
        }
        else
        {
            m_LightArray[dwIndex].Disable(&m_lighting.pActiveLights);
        }
    }

    inline HRESULT SetLightData( DWORD dwIndex, D3DLIGHT7* pData )
    {
        HRESULT hr = S_OK;
        HR_RET(m_LightArray[dwIndex].SetLight(pData));
        m_dwDirtyFlags |= RDPV_DIRTY_SETLIGHT;
        return S_OK;
    }
    HRESULT GrowLightArray( DWORD dwIndex );
    friend class RefDev;
};

// Vertex Lighting functions
void RDLV_Directional( RDLIGHTINGDATA&, D3DLIGHT7 *, RDLIGHTI *,
                       RDLIGHTINGELEMENT *, DWORD, UINT64 );
void RDLV_PointAndSpot( RDLIGHTINGDATA&, D3DLIGHT7 *, RDLIGHTI *,
                        RDLIGHTINGELEMENT *, DWORD, UINT64 );


///////////////////////////////////////////////////////////////////////////////
#endif // _REFTNL_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\inc\templarr.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// temparr.hpp
//
// Template class used by Direct3D RefDev for stateset and so on.
//
// The following error codes should be defined before included this file:
// DDERR_OUTOFMEMORY
// D3D_OK
// DDERR_INVALIDPARAMS
///////////////////////////////////////////////////////////////////////////////
#ifndef  _TEMPLARR_HPP
#define  _TEMPLARR_HPP


//--------------------------------------------------------------------------
//
// Template for growable arrays
//
//--------------------------------------------------------------------------


template <class ARRAY_ELEMENT>
class GArrayT
{
public:
    GArrayT()
    {
        m_pArray = NULL;
        m_dwArraySize = 0;
        m_dwGrowSize = 8;
    }

    ~GArrayT()
    {
        char tmp[256];
        wsprintf( tmp, "m_dwArraySize = %d, m_pArray = %08x\n", m_dwArraySize,
                  m_pArray );
        _ASSERT( !((m_dwArraySize == 0)^(m_pArray == NULL)), tmp );
        if( m_pArray ) delete[] m_pArray;
    }

    virtual void SetGrowSize( DWORD dwGrowSize)
    {
         m_dwGrowSize = dwGrowSize;
    }

    virtual HRESULT Grow( DWORD dwIndex )
    {
        if( dwIndex < m_dwArraySize ) return S_OK;
        DWORD dwNewArraySize = (dwIndex/m_dwGrowSize + 1) * m_dwGrowSize;
        ARRAY_ELEMENT *pNewArray = AllocArray( dwNewArraySize );
        if( pNewArray == NULL ) return DDERR_OUTOFMEMORY;

        for( DWORD i = 0; i<m_dwArraySize; i++ )
            pNewArray[i] = m_pArray[i];

        delete[] m_pArray;
        m_pArray = pNewArray;
        m_dwArraySize = dwNewArraySize;
        return S_OK;
    }

    virtual HRESULT Grow( DWORD dwIndex, BOOL* pRealloc )
    {
        if( dwIndex < m_dwArraySize ) 
        {
            if( pRealloc ) *pRealloc = FALSE;
            return S_OK;
        }
        if( pRealloc ) *pRealloc = TRUE;
        
        DWORD dwNewArraySize = m_dwArraySize;
        while( dwNewArraySize <= dwIndex ) dwNewArraySize += m_dwGrowSize;
        ARRAY_ELEMENT *pNewArray = AllocArray( dwNewArraySize );
        if( pNewArray == NULL ) return DDERR_OUTOFMEMORY;

        for( DWORD i = 0; i<m_dwArraySize; i++ )
            pNewArray[i] = m_pArray[i];

        delete[] m_pArray;
        m_pArray = pNewArray;
        m_dwArraySize = dwNewArraySize;
        return S_OK;
    }

    virtual ARRAY_ELEMENT *AllocArray( DWORD dwSize ) const
    {
        return new ARRAY_ELEMENT[dwSize];
    }

    virtual ARRAY_ELEMENT& operator []( DWORD dwIndex ) const
    {
        char tmp[256];
        wsprintf( tmp, "dwIndex = %d, m_dwArraySize = %d\n", dwIndex, 
                  m_dwArraySize );
        _ASSERT(dwIndex < m_dwArraySize, tmp);
        return m_pArray[dwIndex];
    }

    virtual BOOL IsValidIndex( DWORD dwIndex ) const
    {
        return (dwIndex < m_dwArraySize);
    }

    virtual DWORD GetSize() const
    {
        return m_dwArraySize;
    }

    virtual DWORD GetGrowSize() const
    {
        return m_dwGrowSize;
    }

protected:
    ARRAY_ELEMENT *m_pArray;
    DWORD          m_dwArraySize;
    DWORD          m_dwGrowSize;
};

//--------------------------------------------------------------------------
//
// A more powerful template for a growable array
//
//--------------------------------------------------------------------------

template <class T> class TemplArray
{
public:
    TemplArray( void );
    ~TemplArray( void );

    // It is the user of this operator who makes sure 0<=iIndex<m_dwArraySize.
    T& operator []( int iIndex );

    HRESULT CheckAndGrow( DWORD iIndex, DWORD dwGrowDelta = 16 );
    HRESULT CheckRange ( DWORD iIndex );

    // The user needs to make sure 0<=m_dwCurrent<m_dwArraySize.
    inline T CurrentItem(void) { return m_pArray[m_dwCurrent];};
    inline void SetCurrentItem(T item) { m_pArray[m_dwCurrent] = item;};
    inline DWORD CurrentIndex(void) { return m_dwCurrent;};
    inline void SetCurrentIndex(DWORD dwIdx) {m_dwCurrent = dwIdx;};

    inline DWORD ArraySize(void) { return m_dwArraySize;};

private:
    T *m_pArray;
    DWORD m_dwArraySize;
    // Index to the current item or the size of data stored in the array
    DWORD m_dwCurrent;
};


template <class T>
TemplArray< T >::TemplArray( void )
{
    m_pArray = NULL;
    m_dwArraySize = 0;
    m_dwCurrent = 0;
}

template <class T>
TemplArray< T >::~TemplArray( void )
{
    if (m_pArray != NULL)
        delete m_pArray;
    m_dwArraySize = 0;
}

template <class T> T&
TemplArray< T >::operator[]( int iIndex )
{
    return m_pArray[iIndex];
}

template <class T> HRESULT
TemplArray< T >::CheckAndGrow( DWORD iIndex, DWORD dwGrowDelta )
{
    if (iIndex >= m_dwArraySize)
    {
        DWORD dwNewArraySize = m_dwArraySize + dwGrowDelta;
        while (iIndex >= dwNewArraySize)
            dwNewArraySize += dwGrowDelta;

        T *pTmpArray = new T[dwNewArraySize];
        if (pTmpArray == NULL)
            return DDERR_OUTOFMEMORY;
        memset(pTmpArray, 0, sizeof(T) * dwNewArraySize);

        if (m_pArray != NULL)
        {
            _ASSERT(m_dwArraySize != 0,
                    "CheckAndGrow: Array size cannot be NULL" );

            // Copy existing stuff into new array
            memcpy(pTmpArray, m_pArray, m_dwArraySize * sizeof(T));

            // Free up existing array
            delete [] m_pArray;
        }


        // Assign new array
        m_pArray = pTmpArray;
        m_dwArraySize = dwNewArraySize;
    }
    return D3D_OK;
}

template <class T> HRESULT
TemplArray< T >::CheckRange( DWORD iIndex )
{
    if (iIndex >= m_dwArraySize)
    {
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

#endif _TEMPLARR_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\link\sources.inc ===
MAJORCOMP=d3d
MINORCOMP=d3d8
TARGETNAME=d3dref8
TARGETPATH=obj
TARGETTYPE=DYNLINK
DLLDEF=..\$(TARGETNAME).def

SYNCHRONIZE_DRAIN = 1

INCLUDES=$(DXROOT)\inc;$(INCLUDES)

!if "$(BUILD_MSREF)" != ""

REFLIBPATH = $(SDK_LIB_PATH)
DDRAWLIB = ddrawp

!else

REFLIBPATH = $(DDK_LIB_PATH)
DDRAWLIB = ddraw

!endif

TARGETLIBS = \
        $(REFLIBPATH)\user32.lib   \
        $(REFLIBPATH)\advapi32.lib \
        $(REFLIBPATH)\uuid.lib     \
        $(REFLIBPATH)\winmm.lib     \
        $(REFLIBPATH)\kernel32.lib

LINKLIBS = \
        ..\..\drv\$(PLAT_DIR)\$(_OBJ_DIR)\*\refdrv.lib    \
        ..\..\common\$(PLAT_DIR)\$(_OBJ_DIR)\*\refcomm.lib  \
        ..\..\rast\$(PLAT_DIR)\$(_OBJ_DIR)\*\refrast.lib  \
        ..\..\tnl\$(PLAT_DIR)\$(_OBJ_DIR)\*\reftnl.lib    \
        ..\..\hop\$(PLAT_DIR)\$(_OBJ_DIR)\*\refhop.lib

DLLENTRY = _DllMainCRTStartup

SOURCES = \
    ..\d3dref8.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\inc\vshader.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   vshader.h
 *  Content:    Direct3D Vertex Shader header
 *
 *
 ***************************************************************************/
#ifndef _VSHADER_H
#define _VSHADER_H

//---------------------------------------------------------------------
// Forward defines
//---------------------------------------------------------------------
class RDVShaderCode;

//---------------------------------------------------------------------
// Constants
//---------------------------------------------------------------------
// Register sets
const DWORD RD_MAX_NUMINPUTREG = 16;
const DWORD RD_MAX_NUMTMPREG   = 12;
const DWORD RD_MAX_NUMCONSTREG = 96;
const DWORD RD_MAX_NUMADDRREG  = 1;
const DWORD RD_MAX_NUMCOLREG   = 2;
const DWORD RD_MAX_NUMTEXREG   = 8;

// The version of the Vertex shader supported in Reference Device.
const DWORD RDVS_CODEMAJORVERSION  = 1;
const DWORD RDVS_CODEMINORVERSION  = 0;
const DWORD RDVS_CODEVERSIONTOKEN  = D3DPS_VERSION( RDVS_CODEMAJORVERSION,
                                                    RDVS_CODEMINORVERSION );

//---------------------------------------------------------------------
//
// RDVVMREG: Register set of the Reference Rasterizer Vertex
//           virtual machine.
//
//---------------------------------------------------------------------
struct RDVVMREG
{
    RDVECTOR4 m_i[RD_MAX_NUMINPUTREG];
    RDVECTOR4 m_t[RD_MAX_NUMTMPREG];
    RDVECTOR4 m_c[RD_MAX_NUMCONSTREG];
    RDVECTOR4 m_a[RD_MAX_NUMADDRREG];

    // Output registers
    RDVECTOR4 m_out[3];
    RDVECTOR4 m_col[RD_MAX_NUMCOLREG];
    RDVECTOR4 m_tex[RD_MAX_NUMTEXREG];
};

//-----------------------------------------------------------------------------
//
// RefVM
//      Vertex Virtual Machine object
//
//-----------------------------------------------------------------------------
class RefDev;
class RefVM
{
public:
    RefVM() { memset( this, 0, sizeof( this ) ); }
    ~RefVM(){};
    RDVVMREG* GetRegisters(){ return &m_reg; }

    // Parses binary shader representation, compiles is and returns
    // compiled object
    RDVShaderCode* CompileCode( DWORD dwSize, LPDWORD pBits );
    HRESULT SetActiveShaderCode( RDVShaderCode* pCode )
    { m_pCurrentShaderCode = pCode; return S_OK; }
    RDVShaderCode* GetActiveShaderCode() {return m_pCurrentShaderCode;}
    HRESULT ExecuteShader(RefDev* pRD);
    // HRESULT GetDataPointer(DWORD dwMemType, VVM_WORD ** pData);
    // Set internal registers to user data
    HRESULT SetData(DWORD RegType, DWORD start, DWORD count, LPVOID buffer);
    // Get data from internal registers
    HRESULT GetData(DWORD RegType, DWORD start, DWORD count, LPVOID buffer);
    inline RDVECTOR4* GetDataAddr( DWORD dwRegType, DWORD dwElementIndex );
    inline UINT GetCurrentInstIndex( void ) { return m_CurInstIndex; }

protected:
    inline void InstMov();
    inline void InstAdd();
    inline void InstMad();
    inline void InstMul();
    inline void InstRcp();
    inline void InstRsq();
    inline void InstDP3();
    inline void InstDP4();
    inline void InstMin();
    inline void InstMax();
    inline void InstSlt();
    inline void InstSge();
    inline void InstExp();
    inline void InstLog();
    inline void InstExpP();
    inline void InstLogP();
    inline void InstLit();
    inline void InstDst();
    inline void InstFrc();
    inline void InstM4x4();
    inline void InstM4x3();
    inline void InstM3x4();
    inline void InstM3x3();
    inline void InstM3x2();
    inline void WriteResult();
    inline HRESULT SetDestReg();
    inline HRESULT SetSrcReg( DWORD index );
    inline HRESULT SetSrcReg( DWORD index, DWORD count );

    RDVVMREG        m_reg;                  // Virtual machine reg set
    RDVShaderCode*  m_pCurrentShaderCode;   // Current shader

    DWORD*          m_pCurToken;        // Current token during parsing
    DWORD           m_dwRegOffset;      // Offset in the register file for
                                        // destination operand
    DWORD           m_WriteMask;        // Write mask for destination operand
    UINT            m_CurInstIndex;     // Current instruction index

    RDVECTOR4*      m_pDest;            // Pointer to destination operand
    RDVECTOR4       m_Source[5];        // Source operands
    RDVECTOR4       m_TmpReg;           // Temporary register for the first

    // The pointer to the driver object to obtain state
    RefDev* m_pDev;
    friend class RefDev;
};

#endif //_VSHADER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\inc\vstream.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995-2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   vstream.h
 *  Content:    Direct3D Vertex Streams header
 *
 *
 ***************************************************************************/
#ifndef _VSTREAM_H
#define _VSTREAM_H

//---------------------------------------------------------------------
// Constants
//---------------------------------------------------------------------
const DWORD RD_MAX_NUMELEMENTS = 16;
const DWORD RD_MAX_NUMSTREAMS  = RD_MAX_NUMELEMENTS;
const DWORD RDVSD_STREAMTESS = RD_MAX_NUMSTREAMS;
const DWORD RD_MAX_SHADERINSTSTRING = 128;
const DWORD RD_MAX_SHADERTOKENSPERINST = 32;

//---------------------------------------------------------------------
// macros for parsing Declaration Token Array

// TRUE, if shader handle is DX7 FVF code
//---------------------------------------------------------------------
#define RDVSD_ISLEGACY(ShaderHandle) !(ShaderHandle & D3DFVF_RESERVED0)

enum RDVSD_DATALOAD
{
    RDVSD_LOADREGISTER = 0,
    RDVSD_SKIP
};

#define RDVSD_GETTOKENTYPE(token)           \
    ((token & D3DVSD_TOKENTYPEMASK) >> D3DVSD_TOKENTYPESHIFT)
#define RDVSD_ISSTREAMTESS(token)           \
    ((token & D3DVSD_STREAMTESSMASK) >> D3DVSD_STREAMTESSSHIFT)
#define RDVSD_GETDATALOADTYPE(token)        \
    ((token & D3DVSD_DATALOADTYPEMASK) >> D3DVSD_DATALOADTYPESHIFT)
#define RDVSD_GETDATATYPE(token)            \
    ((token & D3DVSD_DATATYPEMASK) >> D3DVSD_DATATYPESHIFT)
#define RDVSD_GETSKIPCOUNT(token)           \
    ((token & D3DVSD_SKIPCOUNTMASK) >> D3DVSD_SKIPCOUNTSHIFT)
#define RDVSD_GETSTREAMNUMBER(token)        \
    ((token & D3DVSD_STREAMNUMBERMASK) >> D3DVSD_STREAMNUMBERSHIFT)
#define RDVSD_GETVERTEXREG(token)           \
    ((token & D3DVSD_VERTEXREGMASK) >> D3DVSD_VERTEXREGSHIFT)
#define RDVSD_GETVERTEXREGIN(token)         \
    ((token & D3DVSD_VERTEXREGINMASK) >> D3DVSD_VERTEXREGINSHIFT)
#define RDVSD_GETCONSTCOUNT(token)          \
    ((token & D3DVSD_CONSTCOUNTMASK) >> D3DVSD_CONSTCOUNTSHIFT)
#define RDVSD_GETCONSTADDRESS(token)        \
    ((token & D3DVSD_CONSTADDRESSMASK) >> D3DVSD_CONSTADDRESSSHIFT)
#define RDVSD_GETCONSTRS(token)             \
    ((token & D3DVSD_CONSTRSMASK) >> D3DVSD_CONSTRSSHIFT)
#define RDVSD_GETEXTCOUNT(token)            \
    ((token & D3DVSD_EXTCOUNTMASK) >> D3DVSD_EXTCOUNTSHIFT)
#define RDVSD_GETEXTINFO(token)             \
    ((token & D3DVSD_EXTINFOMASK) >> D3DVSD_EXTINFOSHIFT)

//---------------------------------------------------------------------
//
// RDVElement: Describes a vertex element
//
//---------------------------------------------------------------------

// Function pointer that copies a vertex element into the 4-float vector.
typedef void (*PFN_RDCOPYELEMENT)(LPVOID pInputStream,
                                  RDVECTOR4* pVertexRegister);

class RDVElement
{
public:
    RDVElement()
    {
        memset( this, 0, sizeof( RDVElement ) );
    }

    // Pointer to a function to convert input vertex element data type to
    // the RDVECTOR4
    PFN_RDCOPYELEMENT  m_pfnCopy;
    DWORD   m_dwToken;       // The token that described this vertex element.
    DWORD   m_dwRegister;    // Input register index
    DWORD   m_dwDataType;    // Data type and dimension
    DWORD   m_dwStreamIndex; // API stream index
    DWORD   m_dwOffset;      // Offset in the input stream in bytes

    //
    // Tesselator support
    //
    BOOL    m_bIsTessGen;     // Is this vertex element generated by
                              // tesselator
    DWORD   m_dwRegisterIn;   // Tesselator Input register index
    DWORD   m_dwStreamIndexIn;// API stream index for m_dwRegisterIn
    DWORD   m_dwOffsetIn;     // Offset for m_dwRegisterIn in bytes

};

//---------------------------------------------------------------------
//
// RDVConstantData: Constant data that is used by a shader
//
//---------------------------------------------------------------------
class RDVConstantData: public RDListEntry
{
public:
    RDVConstantData()     {m_pData = NULL; m_dwCount = 0;}
    ~RDVConstantData()    {delete m_pData;}

    DWORD   m_dwCount;          // Number of 4*DWORDs to load
    DWORD   m_dwAddress;        // Start constant register
    DWORD*  m_pData;            // Data. Multiple of 4*DWORD
};
//-----------------------------------------------------------------------------
//
//  RDVStream: Class representing the vertex stream.
//
//-----------------------------------------------------------------------------
class RDVStream
{
public:
    RDVStream()
    {
        m_pData = NULL;
        m_pSavedData = NULL;
        m_dwHandle = 0;
        m_dwNumVertices = 0;
        m_dwSize = 0;
    }

    // Stream memory.
    LPBYTE  m_pData;
    // Temporary pointer
    LPBYTE  m_pSavedData;
    // Vertex buffer handle
    DWORD                   m_dwHandle;
    // Vertex (or index) stride in bytes
    DWORD                   m_dwStride;
    // Max number of vertices (or indices in case of index buffer) the buffer
    // can store
    DWORD                   m_dwNumVertices;
    // Buffer size in bytes
    DWORD                   m_dwSize;
    // Output array for a tessellator
    GArrayT<BYTE>           m_TessOut;
};
//-----------------------------------------------------------------------------
//
//  RDIStream: Class representing the current Index stream
//
//-----------------------------------------------------------------------------
class RDIStream: public RDVStream
{
public:
    RDIStream()
    {
        m_dwFlags = 0;
    }
    DWORD   m_dwFlags;      // User passed flags
};
//---------------------------------------------------------------------
//
// RDVStreamDecl:
//
//      Describes a stream, used by a declaration
//
//---------------------------------------------------------------------
class RDVStreamDecl
{
public:
    RDVStreamDecl();

    // Parses declaration.
    // For fixed-function pipeline computes FVF and FVF2 (used to record
    // texture presence)
    HRESULT Parse(DWORD ** ppToken, BOOL bFixedFunction, BOOL bStreamTess,
                  UINT64* pqwFVF, UINT64* pqwFVF2, DWORD* pdwNumBetas);
    HRESULT MakeVElementArray( UINT64 qwFVF );
    RDVElement  m_Elements[RD_MAX_NUMELEMENTS];  // Vertex elements in the
                                                // stream.
    DWORD       m_dwNumElements;                // Number of elements to use
    DWORD       m_dwStride;                     // Vertex size in bytes
    DWORD       m_dwStreamIndex;                // Index to device streams
    BOOL        m_bIsStreamTess;                // Is it a tesselator stream ?
};
//---------------------------------------------------------------------
//
// RDVShaderInst:
//     The object representing each shader instruction.  Used for
//     debugging, since the reference implementation directly interprets
//     the raw token stream during vshader execution.
//-----------------------------------------------------------------------------
class RDVShaderInst
{
public:
    char    m_String[RD_MAX_SHADERINSTSTRING];
    DWORD   m_Tokens[RD_MAX_SHADERTOKENSPERINST];
    DWORD*  m_pComment;
    DWORD   m_CommentSize;
};
//---------------------------------------------------------------------
//
// RDVShaderCode:
//     The object representing the compiled shader code.
//     In the reference implementation, there is really no compiling
//     happening. The compile phase consists of:
//           1) Validating the the code.
//           2) Computing the output FVF.
//           3) Saving the original bits for later interpretation.
//    In the execution phase (in the RefVM) these saved bits are
//    interpreted.
//-----------------------------------------------------------------------------
class RDVShaderCode
{
public:
    RDVShaderCode() { memset( this, 0, sizeof( this ) ); }
    ~RDVShaderCode(){ delete m_pRawBits; if (m_pInst) delete m_pInst; }
    inline UINT GetInstructionCount( void ) { return m_InstCount; }

    LPDWORD      m_pRawBits;      // Raw code bits
    DWORD        m_dwSize;        // Number of DWORDs

    UINT         m_InstCount;     // Instruction count (for debug monitor)
    RDVShaderInst*   m_pInst;     // Instruction array (for debug monitor)

    // Output FVF for this shaders
    UINT64 m_qwFVFOut;
};
//---------------------------------------------------------------------
//
// RDVDeclaration:
//     The object representing the parsed and compiled declaration.
//-----------------------------------------------------------------------------
class RDVDeclaration
{
public:
    RDVDeclaration()
    {
        memset( this, 0, sizeof( RDVDeclaration ) );
    }
    ~RDVDeclaration();
    HRESULT Parse( DWORD * decl, BOOL bFixedFunction );
    HRESULT MakeVElementArray( UINT64 qwFVF );

    // List of streams, which are used by the declaration
    // The additional one is used for the Tesselator stream.
    RDVStreamDecl   m_StreamArray[RD_MAX_NUMSTREAMS + 1];

    // Number of active streams
    DWORD           m_dwNumActiveStreams;

    // Corresponding FVF for fixed-function pipeline
    // This is OR of all streams input FVF
    UINT64          m_qwInputFVF;

    // Constant data that should be loaded when shader becomes active
    RDVConstantData* m_pConstants;

    // The description of all vertex elements to be loaded into input
    // registers. The array is built by going through active streams and
    // elements inside each stream
    RDVElement       m_VertexElements[RD_MAX_NUMELEMENTS];

    // Number of used members of m_VertexElements
    DWORD           m_dwNumElements;

    // Stride computed for the implicit tesselator stream
    DWORD           m_dwStreamTessStride;
};
//-----------------------------------------------------------------------------
//
// RDVShader: Vertex Shader Class
//
//-----------------------------------------------------------------------------
class RDVShader
{
public:
    RDVShader();
    ~RDVShader();
    HRESULT Initialize(DWORD* lpdwDeclaration, DWORD* lpdwFunction);

    RDVDeclaration   m_Declaration;
    RDVShaderCode*   m_pCode;

    inline BOOL IsFixedFunction()
    {
        return (m_pCode == NULL);
    }
};
typedef RDVShader *PRDVSHADER;


#endif _VSTREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\rast\pch.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// pch.cpp
//
// Precompiled header file.
//
///////////////////////////////////////////////////////////////////////////////
#include "refdev.hpp"

#include "refrasti.hpp"
///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\rast\ctexfilt.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// ctexfilt.cpp
//
// Direct3D Reference Device - Cube Texture Map Filtering
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
void
RefRast::ComputeCubeTextureFilter( int iStage, FLOAT fCrd[] )
{
#define POS_NX 1
#define POS_NY 2
#define POS_NZ 3
#define NEG_NORM 4
#define NEG_NX (NEG_NORM | POS_NX)
#define NEG_NY (NEG_NORM | POS_NY)
#define NEG_NZ (NEG_NORM | POS_NZ)

    // determine which map face the texture coordinate normal is facing
    UINT uMap;
    if ( fabs(fCrd[0]) > fabs(fCrd[1]) )
    {
        if ( fabs(fCrd[0]) > fabs(fCrd[2]) )
            uMap = POS_NX | ((fCrd[0] < 0.0) ? (NEG_NORM) : 0);
        else
            uMap = POS_NZ | ((fCrd[2] < 0.0) ? (NEG_NORM) : 0);
    }
    else
    {
        if ( fabs(fCrd[1]) > fabs(fCrd[2]) )
            uMap = POS_NY | ((fCrd[1] < 0.0) ? (NEG_NORM) : 0);
        else
            uMap = POS_NZ | ((fCrd[2] < 0.0) ? (NEG_NORM) : 0);
    }

    // munged texture coordinate and gradient info for cubemaps
    D3DCUBEMAP_FACES Face;  // face index (0..5) to which normal is (mostly) pointing
    FLOAT fMajor;           // coord in major direction
    FLOAT fMapCrd[2];       // coords into 2D map
    FLOAT fMajorGrad[2];    // dMajor/d(X,Y)
    FLOAT fMapGrad[2][2];   // d(U/Major,V/Major)/d(X,Y)

#define _MapFaceParams( _Face, _IM, _bFlipM, _IU, _bFlipU, _IV, _bFlipV ) \
{ \
    Face = D3DCUBEMAP_FACE_##_Face; \
    fMajor     = (_bFlipM) ? (-fCrd[_IM]) : ( fCrd[_IM]); \
    fMapCrd[0] = (_bFlipU) ? (-fCrd[_IU]) : ( fCrd[_IU]); \
    fMapCrd[1] = (_bFlipV) ? (-fCrd[_IV]) : ( fCrd[_IV]); \
    fMajorGrad[0]  = m_TexCvg[iStage].fGradients[_IM][0]; if (_bFlipM) fMajorGrad[0]  = -fMajorGrad[0]; \
    fMajorGrad[1]  = m_TexCvg[iStage].fGradients[_IM][1]; if (_bFlipM) fMajorGrad[1]  = -fMajorGrad[1]; \
    fMapGrad[0][0] = m_TexCvg[iStage].fGradients[_IU][0]; if (_bFlipU) fMapGrad[0][0] = -fMapGrad[0][0]; \
    fMapGrad[0][1] = m_TexCvg[iStage].fGradients[_IU][1]; if (_bFlipU) fMapGrad[0][1] = -fMapGrad[0][1]; \
    fMapGrad[1][0] = m_TexCvg[iStage].fGradients[_IV][0]; if (_bFlipV) fMapGrad[1][0] = -fMapGrad[1][0]; \
    fMapGrad[1][1] = m_TexCvg[iStage].fGradients[_IV][1]; if (_bFlipV) fMapGrad[1][1] = -fMapGrad[1][1]; \
}
    switch (uMap)
    {
    case POS_NX: _MapFaceParams( POSITIVE_X, 0,0, 2,1, 1,1 ); break;
    case POS_NY: _MapFaceParams( POSITIVE_Y, 1,0, 0,0, 2,0 ); break;
    case POS_NZ: _MapFaceParams( POSITIVE_Z, 2,0, 0,0, 1,1 ); break;
    case NEG_NX: _MapFaceParams( NEGATIVE_X, 0,1, 2,0, 1,1 ); break;
    case NEG_NY: _MapFaceParams( NEGATIVE_Y, 1,1, 0,0, 2,1 ); break;
    case NEG_NZ: _MapFaceParams( NEGATIVE_Z, 2,1, 0,1, 1,1 ); break;
    }

    // compute gradients prior to normalizing map coords
    FLOAT fInvMajor = 1.F/fMajor;
    if ( m_TexFlt[iStage].CvgFilter != D3DTEXF_NONE )
    {
        // Compute d(U/Major)/dx, d(U/Major)/dy, d(V/Major)/dx, d(V/Major)/dy.
        // 
        // i.e., for d(U/Major))/dx
        // Given: U' = unprojected U0 coord (fMapCrd[0])
        //        U0 = U'/Major (fMapCrd[0]/fMajor)
        //        U1 = (U' + dU'/dX)/(Major + dMajor/dX)
        //
        //        d(U/Major)/dx = U1 - U0
        //                      = (Major*(dU'/dX) - U'*(dMajor/dX)) / (Major * (Major + dMajor/dX))
        //        (Use FLT_MAX if denominator is zero)

        float fDenom; 
        fDenom = fMajor * (fMajor + fMajorGrad[0]);
        if( 0 == fDenom )
        {
            fMapGrad[0][0] = fMapGrad[1][0] = FLT_MAX;
        }
        else
        {
            fDenom = 1.F/fDenom;
            fMapGrad[0][0] = (fMajor*fMapGrad[0][0] - fMapCrd[0]*fMajorGrad[0])*fDenom;
            fMapGrad[1][0] = (fMajor*fMapGrad[1][0] - fMapCrd[1]*fMajorGrad[0])*fDenom;
        }

        fDenom = fMajor * (fMajor + fMajorGrad[1]);
        if( 0 == fDenom )
        {
            fMapGrad[0][1] = fMapGrad[1][1] = FLT_MAX;
        }
        else
        {
            fDenom = 1.F/fDenom;
            fMapGrad[0][1] = (fMajor*fMapGrad[0][1] - fMapCrd[0]*fMajorGrad[1])*fDenom;
            fMapGrad[1][1] = (fMajor*fMapGrad[1][1] - fMapCrd[1]*fMajorGrad[1])*fDenom;
        }
        // scale gradients to texture LOD 0 size; scale by .5F to match coord scale below
        fMapGrad[0][0] *= m_pRD->m_pTexture[iStage]->m_fTexels[0][0]*.5F;
        fMapGrad[0][1] *= m_pRD->m_pTexture[iStage]->m_fTexels[0][0]*.5F;
        fMapGrad[1][0] *= m_pRD->m_pTexture[iStage]->m_fTexels[0][1]*.5F;
        fMapGrad[1][1] *= m_pRD->m_pTexture[iStage]->m_fTexels[0][1]*.5F;

        ComputeCubeCoverage( fMapGrad, m_TexCvg[iStage].fLOD );
        ComputePerLODControls( iStage );
    }

    // normalize map coords (-1. to 1. range), then map to 0. to 1.
    fMapCrd[0] = (fMapCrd[0]*fInvMajor)*.5F + .5F;
    fMapCrd[1] = (fMapCrd[1]*fInvMajor)*.5F + .5F;

    int iL;
    D3DTEXTUREFILTERTYPE Filter =
        m_TexCvg[iStage].bMagnify ? m_TexFlt[iStage].MagFilter : m_TexFlt[iStage].MinFilter;
    switch ( Filter )
    {
    default:
    case D3DTEXF_POINT:
        for ( iL = 0; iL < m_TexCvg[iStage].cLOD; iL++ )
        {
            m_TexFlt[iStage].pSamples[iL].iLOD = Face + 6*m_TexCvg[iStage].iLODMap[iL];
            m_TexFlt[iStage].pSamples[iL].fWgt = m_TexCvg[iStage].fLODFrc[iL];
            ComputePointSampleCoords( iStage, m_TexFlt[iStage].pSamples[iL].iLOD,
                fMapCrd, m_TexFlt[iStage].pSamples[iL].iCrd );
            m_TexFlt[iStage].cSamples++;
        }
        break;

    case D3DTEXF_LINEAR:
        for ( iL = 0; iL < m_TexCvg[iStage].cLOD; iL++ )
        {

            if ( 0 == m_TexCvg[iStage].iLODMap[iL] )
            {
                // TODO: correct sampling position near edges on map 0
            }

            INT32 iCrdMap[2][2];
            FLOAT fCrdFrc[2][2];
            ComputeLinearSampleCoords(
                iStage, 6*m_TexCvg[iStage].iLODMap[iL]+Face, fMapCrd,
                iCrdMap[0], iCrdMap[1], fCrdFrc[0], fCrdFrc[1] );
            SetUpCubeMapLinearSample( iStage, Face,
                6*m_TexCvg[iStage].iLODMap[iL]+Face, m_TexCvg[iStage].fLODFrc[iL],
                iCrdMap, fCrdFrc );
        }
        break;
    }
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
void
RefRast::SetUpCubeMapLinearSample(
    int iStage, D3DCUBEMAP_FACES Face,
    INT32 iLODMap, FLOAT fLODScale,
    INT32 (*iCrd)[2], FLOAT (*fFrc)[2] )
{
    int iC,iS;
    INT32 iCrdMax[2];
    iCrdMax[0] = m_pRD->m_pTexture[iStage]->m_cTexels[iLODMap][0] - 1;
    iCrdMax[1] = m_pRD->m_pTexture[iStage]->m_cTexels[iLODMap][1] - 1;

    // form flags indicating if sample coordinate is out in either direction
    UINT uOut[2][2] = { 0, 0, 0, 0, };
    for ( iC = 0; iC < 2; iC++ )
    {
        if ( iCrd[iC][0] < 0          )  uOut[iC][0] = 1;
        if ( iCrd[iC][0] > iCrdMax[0] )  uOut[iC][0] = 2;
        if ( iCrd[iC][1] < 0          )  uOut[iC][1] = 1;
        if ( iCrd[iC][1] > iCrdMax[1] )  uOut[iC][1] = 2;
    }

    // compute sample weights and per-sample out flags
    FLOAT fWgtS[4]; BOOL bOutS[4];
    for ( iS = 0; iS < 4; iS ++ )
    {
        fWgtS[iS] = fLODScale*fFrc[iS&1][0]*fFrc[iS>>1][1];
        bOutS[iS] = uOut[iS&1][0] || uOut[iS>>1][1];
    }

    // compute per-sample coords; discard samples which are off in corner;
    //  conditionally remap to adjacent face
    INT32 iCrdS[4][2];
    D3DCUBEMAP_FACES FaceS[4];
    for ( iS = 0; iS < 4; iS ++ )
    {
        iCrdS[iS][0] = iCrd[iS&1][0];
        iCrdS[iS][1] = iCrd[iS>>1][1];
        FaceS[iS] = Face;
        if ( uOut[iS&1][0] && uOut[iS>>1][1] )
        {
            // sample is out on both sides, so don't take this sample (set weight to
            // zero) and divide it's weight evenly between the two singly-out samples
            FLOAT fWgtDist = fWgtS[iS]*.5f;
            fWgtS[iS] = 0.f;
            for ( int iSp = 0; iSp < 4; iSp ++ )
            {
                if (iSp == iS) continue;
                if (bOutS[iSp]) fWgtS[iSp] += fWgtDist;   // will hit 2 of 4
            }
            continue;
        }
        if ( bOutS[iS] )
        {
            // sample is out on one side - remap coordinate only adjacent face
            DoCubeRemap( iCrdS[iS], iCrdMax, FaceS[iS], uOut[iS&1][0], uOut[iS>>1][1] );
        }
    }
    // form the samples
    TextureSample* pS = &m_TexFlt[iStage].pSamples[m_TexFlt[iStage].cSamples];
    for ( iS = 0; iS < 4; iS ++ )
    {
        pS->iLOD = iLODMap - Face + FaceS[iS];
        pS->fWgt = fWgtS[iS];
        pS->iCrd[0] = iCrdS[iS][0];
        pS->iCrd[1] = iCrdS[iS][1];
        pS++; m_TexFlt[iStage].cSamples++;
    }
}

//
// uCubeEdgeTable
//
// This table looks up how to map a given [0] and [1] that are out of range
// on their primary face.  The first (leftmost) index to the table is the current
// face.  The second index is 0 if [1] is in range, 1 if [1] is negative
// and 2 if [1] is larger than the texture.  Likewise, the last index is 0
// if [0] is in range, 1 if [0] is negative, and 2 if [0] is larger than
// than the texture.
//
// defines for the actions returned by the uCubeEdgeTable
//
#define CET_FACEMASK    0x0F    // new face
#define CET_0MASK       0x30    // coord [0] mask
#define CET_00          0x00    // new face [0] is old face  [0]
#define CET_0c0         0x10    // new face [0] is old face ~[0]
#define CET_01          0x20    // new face [0] is old face  [1]
#define CET_0c1         0x30    // new face [0] is old face ~[1]
#define CET_1MASK       0xC0    // coord [1] mask
#define CET_10          0x00    // new face [1] is old face  [0]
#define CET_1c0         0x40    // new face [1] is old face ~[0]
#define CET_11          0x80    // new face [1] is old face  [1]
#define CET_1c1         0xC0    // new face [1] is old face ~[1]
#define CET_INVALID     0xFF    // invalid entry (out on two sides)

#define _SetCET( _Face, _Crd0, _Crd1 ) (_Face)|(CET_0##_Crd0)|(CET_1##_Crd1)

static UINT CubeEdgeTable[6][3][3] = {
{
    { _SetCET( 0,  0,  1 ), _SetCET( 4, c0,  1 ), _SetCET( 5, c0,  1 ), },
    { _SetCET( 2, c1, c0 ),     CET_INVALID,          CET_INVALID,      },
    { _SetCET( 3,  1,  0 ),     CET_INVALID,          CET_INVALID,      },
},
{
    { _SetCET( 1,  0,  1 ), _SetCET( 5, c0,  1 ), _SetCET( 4, c0,  1 ), },
    { _SetCET( 2,  1,  0 ),     CET_INVALID,          CET_INVALID,      },
    { _SetCET( 3, c1, c0 ),     CET_INVALID,          CET_INVALID,      },
},
{
    { _SetCET( 2,  0,  1 ), _SetCET( 1,  1,  0 ), _SetCET( 0, c1, c0 ), },
    { _SetCET( 5,  c0, 1 ),     CET_INVALID,          CET_INVALID,      },
    { _SetCET( 4,  0, c1 ),     CET_INVALID,          CET_INVALID,      },
},
{
    { _SetCET( 3,  0,  1 ), _SetCET( 1, c1, c0 ), _SetCET( 0,  1,  0 ), },
    { _SetCET( 4,  0, c1 ),     CET_INVALID,          CET_INVALID,      },
    { _SetCET( 5,  c0, 1 ),     CET_INVALID,          CET_INVALID,      },
},
{
    { _SetCET( 4,  0,  1 ), _SetCET( 1, c0,  1 ), _SetCET( 0, c0,  1 ), },
    { _SetCET( 2,  0, c1 ),     CET_INVALID,          CET_INVALID,      },
    { _SetCET( 3,  0, c1 ),     CET_INVALID,          CET_INVALID,      },
},
{
    { _SetCET( 5,  0,  1 ), _SetCET( 0, c0,  1 ), _SetCET( 1, c0,  1 ), },
    { _SetCET( 2, c0,  1 ),     CET_INVALID,          CET_INVALID,      },
    { _SetCET( 3, c0,  1 ),     CET_INVALID,          CET_INVALID,      },
},
};

//-----------------------------------------------------------------------------
//
// DoCubeRemap - Interprets the edge table and munges coords and face.
//
//-----------------------------------------------------------------------------
void
DoCubeRemap(
    INT32 iCrd[], INT32 iCrdMax[],
    D3DCUBEMAP_FACES& Face, UINT uOut0, UINT uOut1)
{
    UINT Table = CubeEdgeTable[Face][uOut1][uOut0];
    _ASSERT( Table != CET_INVALID, "Illegal cube map lookup" );
    INT32 iCrdIn[2];
    iCrdIn[0] = iCrd[0];
    iCrdIn[1] = iCrd[1];
    switch ( Table & CET_0MASK )
    {
    default:
    case CET_00:  iCrd[0] =            iCrdIn[0]; break;
    case CET_0c0: iCrd[0] = iCrdMax[0]-iCrdIn[0]; break;
    case CET_01:  iCrd[0] =            iCrdIn[1]; break;
    case CET_0c1: iCrd[0] = iCrdMax[1]-iCrdIn[1]; break;
    }
    switch ( Table & CET_1MASK )
    {
    default:
    case CET_10:  iCrd[1] =            iCrdIn[0]; break;
    case CET_1c0: iCrd[1] = iCrdMax[0]-iCrdIn[0]; break;
    case CET_11:  iCrd[1] =            iCrdIn[1]; break;
    case CET_1c1: iCrd[1] = iCrdMax[1]-iCrdIn[1]; break;
    }
    Face = (D3DCUBEMAP_FACES)(Table & CET_FACEMASK);
}

//-----------------------------------------------------------------------------
//
// Computes level of detail for cube mapping, looks better if
// we err on the side of fuzziness.
//
//-----------------------------------------------------------------------------
void
ComputeCubeCoverage( const FLOAT (*fGradients)[2], FLOAT& fLOD )
{
    // compute length of coverage in U and V axis
    FLOAT fLenX = RR_LENGTH( fGradients[0][0], fGradients[1][0] );
    FLOAT fLenY = RR_LENGTH( fGradients[0][1], fGradients[1][1] );

    FLOAT fCoverage;
#if 0
    // take average since one length can be pathologically small
    // for large areas of triangles when cube mapping
    fCoverage = (fLenX+fLenY)/2;
#else
    // use the MAX of the lengths
    fCoverage = MAX(fLenX,fLenY);
#endif

    // take log2 of coverage for LOD
    fLOD = RR_LOG2(fCoverage);
}


///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\rast\pixproc.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// pixproc.cpp
//
// Direct3D Reference Device - Pixel Processor
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// WritePixel - Writes pixel and (maybe) depth to current render target.
//
//-----------------------------------------------------------------------------
void
RefRast::WritePixel(
    INT32 iX, INT32 iY, UINT Sample,
    const RDColor& Color, const RDDepth& Depth)
{
    m_pRD->m_pRenderTarget->WritePixelColor( iX, iY, Sample, Color,
        m_pRD->GetRS()[D3DRS_DITHERENABLE]);

    // don't write if Z buffering disabled or Z write disabled
    if ( !( m_pRD->GetRS()[D3DRS_ZENABLE     ] ) ||
         !( m_pRD->GetRS()[D3DRS_ZWRITEENABLE] ) ) { return; }

    m_pRD->m_pRenderTarget->WritePixelDepth( iX, iY, Sample, Depth );
}

//-----------------------------------------------------------------------------
//
// DoPixels - Invoked for each set of 2x2 pixels by the scan converter, applies
// texture, specular, fog, alpha blend, and writes result to surface.  Also
// implements depth, alpha, and stencil tests.
//
//-----------------------------------------------------------------------------
void
RefRast::DoPixels( void )
{
    // pixel shader executed for all 4 pixels of 2x2 grid at one time
    if (m_pCurrentPixelShader)
        ExecShader();

    for ( m_iPix = 0; m_iPix < 4; m_iPix++ )
    {
        if ( !m_bPixelIn[m_iPix] ) continue;
        if ( m_bPixelDiscard[m_iPix] ) continue;

        RDColor PixelColor;
        if ( !m_bLegacyPixelShade )
        {
            // pixel shader final color always left in temp register 0
            PixelColor = m_TempReg[0][m_iPix];
            // saturate before blend and FB access
            PixelColor.Clamp();
        }
        else
        {
            // apply legacy pixel shading (texture lookups already done by ExecShader)
            PixelColor = m_InputReg[0][m_iPix];
            RDColor PixelSpecular( m_InputReg[1][m_iPix] );
            RDColor LastStageColor( PixelColor );
            RDColor ResultColor( PixelColor );
            RDColor TempColor( (UINT32)0x0 );
            for ( int iStage=0; iStage<m_pRD->m_cActiveTextureStages; iStage++ )
            {

                if ( m_pRD->GetTSS(iStage)[D3DTSS_COLOROP] == D3DTOP_DISABLE )
                {
                    ResultColor = LastStageColor; // pass result of previous stage
                    break;
                }

                // no blend if texture bound to stage is bumpmap
                if ( ( m_pRD->GetTSS(iStage)[D3DTSS_COLOROP] == D3DTOP_BUMPENVMAP ) ||
                     ( m_pRD->GetTSS(iStage)[D3DTSS_COLOROP] == D3DTOP_BUMPENVMAPLUMINANCE ) )
                {
                    continue;
                }

                RDColor TextureColor( m_TextReg[iStage][m_iPix] );
                DoTextureBlendStage( iStage, PixelColor, PixelSpecular,
                    LastStageColor, TextureColor, TempColor, ResultColor );

                // set color for next stage
                LastStageColor = ResultColor;
            }
            PixelColor = ResultColor;

            // add specular and saturate
            if ( m_pRD->GetRS()[D3DRS_SPECULARENABLE] )
            {
                PixelColor.R += PixelSpecular.R;
                PixelColor.G += PixelSpecular.G;
                PixelColor.B += PixelSpecular.B;
                PixelColor.Saturate();
            }
        }

        // do alpha test - bail out if failed
        if ( m_pRD->GetRS()[D3DRS_ALPHATESTENABLE] &&
             !AlphaTest( PixelColor.A ) )
        {
            continue;
        }

        // apply fog
        if ( m_pRD->GetRS()[D3DRS_FOGENABLE] )
        {
            RDColor FogColor = m_pRD->GetRS()[D3DRS_FOGCOLOR];
            // (TODO: account for pre-multiplied alpha here??)
            FLOAT ObjColorFrac = m_FogIntensity[m_iPix];
            FLOAT FogColorFrac = 1.f - m_FogIntensity[m_iPix];
            PixelColor.R = (ObjColorFrac * PixelColor.R) + (FogColorFrac * FogColor.R);
            PixelColor.G = (ObjColorFrac * PixelColor.G) + (FogColorFrac * FogColor.G);
            PixelColor.B = (ObjColorFrac * PixelColor.B) + (FogColorFrac * FogColor.B);
        }

        //
        // remainder is done per-sample for multisample buffers
        //
        INT32 iX = m_iX[m_iPix];
        INT32 iY = m_iY[m_iPix];
        do
        {
            RDColor FinalPixelColor = PixelColor;
            UINT iSample = GetCurrentSample();

            if ( !m_bIsLine &&
                   ( !GetCurrentSampleMask() ||
                     !m_bSampleCovered[iSample][m_iPix] ) )
            {
                // iSample not covered by this geometry
                continue;
            }
            //
            // read current depth for this pixel and do depth test - cannot
            // bail out if failed because stencil may need to be updated
            //
            BOOL bDepthTestPassed = TRUE;
            if ( m_pRD->GetRS()[D3DRS_ZENABLE] )
            {
                m_Depth[m_iPix] = m_SampleDepth[iSample][m_iPix];

                RDDepth BufferDepth( m_Depth[m_iPix].GetSType() );
                m_pRD->m_pRenderTarget->ReadPixelDepth( iX, iY, iSample, BufferDepth );
                bDepthTestPassed = DepthCloser( m_Depth[m_iPix], BufferDepth );
            }

            //
            // do stencil operation
            //
            BOOL bStencilTestPassed = TRUE;
            if ( m_pRD->GetRS()[D3DRS_STENCILENABLE] )
            {
                // read stencil buffer and do stencil operation
                UINT8 uStncBuf = 0x0;
                m_pRD->m_pRenderTarget->ReadPixelStencil( iX, iY, iSample, uStncBuf );
                UINT8 uStncNew;
                bStencilTestPassed =
                    DoStencil( uStncBuf, bDepthTestPassed, m_pRD->m_pRenderTarget->m_pDepth->GetSurfaceFormat(), uStncNew );

                // update stencil only if changed
                if ( uStncNew != uStncBuf )
                {
                    // compute new buffer value based on write mask
                    UINT8 uStncWMask = m_pRD->GetRS()[D3DRS_STENCILWRITEMASK];
                    UINT8 uStncBufNew = (uStncBuf & ~uStncWMask) | (uStncNew & uStncWMask);
                    m_pRD->m_pRenderTarget->WritePixelStencil( iX, iY, iSample, uStncBufNew );
                }
            }

            if ( !(bDepthTestPassed && bStencilTestPassed) )
            {
                continue;
            }

            //
            // do alpha blend and write mask
            //
            if ( ( ( m_pRD->GetRS()[D3DRS_COLORWRITEENABLE] & 0xF) != 0xF ) ||
                 ( m_pRD->GetRS()[D3DRS_ALPHABLENDENABLE] ) )
            {
                RDColor BufferColor;
                m_pRD->m_pRenderTarget->ReadPixelColor( iX, iY, iSample, BufferColor );

                if ( m_pRD->GetRS()[D3DRS_ALPHABLENDENABLE] )
                {
                    DoAlphaBlend( FinalPixelColor, BufferColor, FinalPixelColor );
                }

                if ( !(m_pRD->GetRS()[D3DRS_COLORWRITEENABLE] & D3DCOLORWRITEENABLE_RED) )
                    FinalPixelColor.R = BufferColor.R;
                if ( !(m_pRD->GetRS()[D3DRS_COLORWRITEENABLE] & D3DCOLORWRITEENABLE_GREEN) )
                    FinalPixelColor.G = BufferColor.G;
                if ( !(m_pRD->GetRS()[D3DRS_COLORWRITEENABLE] & D3DCOLORWRITEENABLE_BLUE) )
                    FinalPixelColor.B = BufferColor.B;
                if ( !(m_pRD->GetRS()[D3DRS_COLORWRITEENABLE] & D3DCOLORWRITEENABLE_ALPHA) )
                    FinalPixelColor.A = BufferColor.A;
            }

#if 0
{
    extern float g_GammaTable[];
    FinalPixelColor.R = g_GammaTable[ (UINT8)(255.f*FinalPixelColor.R) ];
    FinalPixelColor.G = g_GammaTable[ (UINT8)(255.f*FinalPixelColor.G) ];
    FinalPixelColor.B = g_GammaTable[ (UINT8)(255.f*FinalPixelColor.B) ];
}
#endif
            //
            // update color and depth buffers
            //
            WritePixel( iX, iY, iSample, FinalPixelColor, m_Depth[m_iPix] );

        } while (NextSample());
    }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Pixel Processing Utility Functions                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Depth compare method used for Z buffering and fragment processing.
//
// Returns TRUE if DepthVal is closer than DepthBuf.  DepthA is the generated
// value and DepthB
//
//-----------------------------------------------------------------------------
BOOL
RefRast::DepthCloser(
    const RDDepth& DepthVal,
    const RDDepth& DepthBuf )
{
    if ( !m_pRD->GetRS()[D3DRS_ZENABLE] ) { return TRUE; }


    switch ( m_pRD->GetRS()[D3DRS_ZFUNC] )
    {
    case D3DCMP_NEVER:        return FALSE;
    case D3DCMP_LESS:         return ( DOUBLE(DepthVal) <  DOUBLE(DepthBuf) );
    case D3DCMP_EQUAL:        return ( DOUBLE(DepthVal) == DOUBLE(DepthBuf) );
    case D3DCMP_LESSEQUAL:    return ( DOUBLE(DepthVal) <= DOUBLE(DepthBuf) );
    case D3DCMP_GREATER:      return ( DOUBLE(DepthVal) >  DOUBLE(DepthBuf) );
    case D3DCMP_NOTEQUAL:     return ( DOUBLE(DepthVal) != DOUBLE(DepthBuf) );
    case D3DCMP_GREATEREQUAL: return ( DOUBLE(DepthVal) >= DOUBLE(DepthBuf) );
    case D3DCMP_ALWAYS:       return TRUE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// Alpha test method for pixel processing.
//
// Returns TRUE if alpha test passes.
//
//-----------------------------------------------------------------------------
BOOL
RefRast::AlphaTest( FLOAT fAlpha )
{
    // grab 8 bit unsigned alpha value
    UINT8 uAlpha = (UINT8)(255.f*fAlpha);

    // form 8 bit alpha reference value
    UINT8 uAlphaRef8 = m_pRD->GetRS()[D3DRS_ALPHAREF];

    // do alpha test and either return directly or pass through
    switch ( m_pRD->GetRS()[D3DRS_ALPHAFUNC] )
    {
    case D3DCMP_NEVER:        return FALSE;
    case D3DCMP_LESS:         return (uAlpha <  uAlphaRef8);
    case D3DCMP_EQUAL:        return (uAlpha == uAlphaRef8);
    case D3DCMP_LESSEQUAL:    return (uAlpha <= uAlphaRef8);
    case D3DCMP_GREATER:      return (uAlpha >  uAlphaRef8);
    case D3DCMP_NOTEQUAL:     return (uAlpha != uAlphaRef8);
    case D3DCMP_GREATEREQUAL: return (uAlpha >= uAlphaRef8);
    case D3DCMP_ALWAYS:       return TRUE;
    }

    return TRUE;
}

//-----------------------------------------------------------------------------
//
// DoStencil - Performs stencil test.  Returns TRUE if stencil test passed.
// Also computes stencil result value (to be written back to stencil planes
// if test passes, subject to stencil write mask).
//
//-----------------------------------------------------------------------------
BOOL
RefRast::DoStencil(
    UINT8 uStncBuf,     // in: stencil buffer value
    BOOL bDepthTest,    // in: boolean result of depth test
    RDSurfaceFormat DepthSType,   // in: surface type of Z buffer
    UINT8& uStncRet)    // out: stencil value result
{
    // support 8 bit stencil only, so do everything as UINT8's

    // max value for masking and saturation ops
    UINT8 uStncMax;
    switch(DepthSType)
    {
    case RD_SF_Z24S8:
    case RD_SF_S8Z24: uStncMax = 0xff; break;
    case RD_SF_Z15S1:
    case RD_SF_S1Z15: uStncMax = 0x1;  break;
    case RD_SF_Z24X4S4:
    case RD_SF_X4S4Z24: uStncMax = 0xf;  break;
    default:          uStncMax = 0;    break;  // don't let stencil become non 0
    }

    // get reference from renderstate
    UINT8 uStncRef = (UINT8)(m_pRD->GetRS()[D3DRS_STENCILREF]);
    // mask to use only bits possibly present in stencil buffer
    uStncRef &= uStncMax;

    // form masked values for test
    UINT8 uStncMask = (UINT8)(m_pRD->GetRS()[D3DRS_STENCILMASK]);
    UINT8 uStncBufM = uStncBuf & uStncMask;
    UINT8 uStncRefM = uStncRef & uStncMask;

    // do stencil compare function
    BOOL bStncTest = FALSE;
    switch ( m_pRD->GetRS()[D3DRS_STENCILFUNC] )
    {
    case D3DCMP_NEVER:        bStncTest = FALSE; break;
    case D3DCMP_LESS:         bStncTest = (uStncRefM <  uStncBufM); break;
    case D3DCMP_EQUAL:        bStncTest = (uStncRefM == uStncBufM); break;
    case D3DCMP_LESSEQUAL:    bStncTest = (uStncRefM <= uStncBufM); break;
    case D3DCMP_GREATER:      bStncTest = (uStncRefM >  uStncBufM); break;
    case D3DCMP_NOTEQUAL:     bStncTest = (uStncRefM != uStncBufM); break;
    case D3DCMP_GREATEREQUAL: bStncTest = (uStncRefM >= uStncBufM); break;
    case D3DCMP_ALWAYS:       bStncTest = TRUE; break;
    }

    // determine which stencil operation to perform
    DWORD dwStencilOp;
    if ( !bStncTest )
    {
        // stencil test failed - depth test does not matter
        dwStencilOp = m_pRD->GetRS()[D3DRS_STENCILFAIL];
    }
    else
    {
        // stencil test passed - select based on depth pass/fail
        dwStencilOp = ( !bDepthTest )
            ? ( m_pRD->GetRS()[D3DRS_STENCILZFAIL] )
            : ( m_pRD->GetRS()[D3DRS_STENCILPASS] );
    }

    uStncRet = 0x0;
    switch ( dwStencilOp )
    {
    case D3DSTENCILOP_KEEP:    uStncRet = uStncBuf; break;
    case D3DSTENCILOP_ZERO:    uStncRet = 0x00; break;
    case D3DSTENCILOP_REPLACE: uStncRet = uStncRef; break;
    case D3DSTENCILOP_INCRSAT:
        uStncRet = (uStncBuf==uStncMax)?(uStncMax):(uStncBuf+1); break;
    case D3DSTENCILOP_DECRSAT:
        uStncRet = (uStncBuf==0x00)?(0x00):(uStncBuf-1); break;
    case D3DSTENCILOP_INVERT:  uStncRet = ~uStncBuf; break;
    case D3DSTENCILOP_INCR:    uStncRet = uStncBuf+1; break;
    case D3DSTENCILOP_DECR:    uStncRet = uStncBuf-1; break;
    }

    return bStncTest;
}

//-----------------------------------------------------------------------------
//
// DoAlphaBlend - Performs color blending of source and destination colors
// producing a result color.
//
//-----------------------------------------------------------------------------
void
RefRast::DoAlphaBlend(
    const RDColor& SrcColor,    // in: source pixel color
    const RDColor& DstColor,    // in: destination (buffer) color
    RDColor& ResColor)          // out: result (blended) color
{
    RDColor SrcColorFactor;
    RDColor DstColorFactor;
    BOOL bDestBlendOverride = FALSE;

    // no SRC/DST blend (or clamp) required for MIN or MAX BLENDOP
    switch ( m_pRD->GetRS()[D3DRS_BLENDOP] )
    {
    case D3DBLENDOP_MIN:
        ResColor.R = MIN(SrcColor.R,DstColor.R);
        ResColor.G = MIN(SrcColor.G,DstColor.G);
        ResColor.B = MIN(SrcColor.B,DstColor.B);
        ResColor.A = MIN(SrcColor.A,DstColor.A);
        return;
    case D3DBLENDOP_MAX:
        ResColor.R = MAX(SrcColor.R,DstColor.R);
        ResColor.G = MAX(SrcColor.G,DstColor.G);
        ResColor.B = MAX(SrcColor.B,DstColor.B);
        ResColor.A = MAX(SrcColor.A,DstColor.A);
        return;
    }

    // compute source blend factors
    switch ( m_pRD->GetRS()[D3DRS_SRCBLEND] )
    {

    default:
    case D3DBLEND_ZERO:
        SrcColorFactor.SetAllChannels( 0.F );
        break;

    case D3DBLEND_ONE:
        SrcColorFactor.SetAllChannels( 1.F );
        break;

    case D3DBLEND_SRCCOLOR:
        SrcColorFactor.R = SrcColor.R;
        SrcColorFactor.G = SrcColor.G;
        SrcColorFactor.B = SrcColor.B;
        SrcColorFactor.A = SrcColor.A;
        break;

    case D3DBLEND_INVSRCCOLOR:
        SrcColorFactor.R = ( 1.f - SrcColor.R );
        SrcColorFactor.G = ( 1.f - SrcColor.G );
        SrcColorFactor.B = ( 1.f - SrcColor.B );
        SrcColorFactor.A = ( 1.f - SrcColor.A );
        break;

    case D3DBLEND_SRCALPHA:
        SrcColorFactor.SetAllChannels( SrcColor.A );
        break;

    case D3DBLEND_INVSRCALPHA:
        SrcColorFactor.SetAllChannels( 1.f - SrcColor.A );
        break;

    case D3DBLEND_DESTALPHA:
        SrcColorFactor.SetAllChannels( DstColor.A );
        break;

    case D3DBLEND_INVDESTALPHA:
        SrcColorFactor.SetAllChannels( 1.f - DstColor.A );
        break;

    case D3DBLEND_DESTCOLOR:
        SrcColorFactor.R = DstColor.R;
        SrcColorFactor.G = DstColor.G;
        SrcColorFactor.B = DstColor.B;
        SrcColorFactor.A = DstColor.A;
        break;

    case D3DBLEND_INVDESTCOLOR:
        SrcColorFactor.R = ( 1.f - DstColor.R );
        SrcColorFactor.G = ( 1.f - DstColor.G );
        SrcColorFactor.B = ( 1.f - DstColor.B );
        SrcColorFactor.A = ( 1.f - DstColor.A );
        break;

    case D3DBLEND_SRCALPHASAT:
        {
            FLOAT F = MIN( SrcColor.A, 1.f - DstColor.A );
            SrcColorFactor.R = F;
            SrcColorFactor.G = F;
            SrcColorFactor.B = F;
        }
        SrcColorFactor.A = 1.F;
        break;

    // these are for SRCBLEND only and override DESTBLEND
    case D3DBLEND_BOTHSRCALPHA:
        bDestBlendOverride = TRUE;
        SrcColorFactor.SetAllChannels( SrcColor.A );
        DstColorFactor.SetAllChannels( 1.f - SrcColor.A );
        break;

    case D3DBLEND_BOTHINVSRCALPHA:
        bDestBlendOverride = TRUE;
        SrcColorFactor.SetAllChannels( 1.f - SrcColor.A );
        DstColorFactor.SetAllChannels( SrcColor.A );
        break;
    }

    // compute destination blend factors
    if ( !bDestBlendOverride )
    {
        switch ( m_pRD->GetRS()[D3DRS_DESTBLEND] )
        {

        default:
        case D3DBLEND_ZERO:
            DstColorFactor.SetAllChannels( 0.F );
            break;

        case D3DBLEND_ONE:
            DstColorFactor.SetAllChannels( 1.F );
            break;

        case D3DBLEND_SRCCOLOR:
            DstColorFactor.R = SrcColor.R;
            DstColorFactor.G = SrcColor.G;
            DstColorFactor.B = SrcColor.B;
            DstColorFactor.A = SrcColor.A;
            break;

        case D3DBLEND_INVSRCCOLOR:
            DstColorFactor.R = ( 1.f - SrcColor.R );
            DstColorFactor.G = ( 1.f - SrcColor.G );
            DstColorFactor.B = ( 1.f - SrcColor.B );
            DstColorFactor.A = ( 1.f - SrcColor.A );
            break;

        case D3DBLEND_SRCALPHA:
            DstColorFactor.SetAllChannels( SrcColor.A );
            break;

        case D3DBLEND_INVSRCALPHA:
            DstColorFactor.SetAllChannels( 1.f - SrcColor.A );
            break;

        case D3DBLEND_DESTALPHA:
            DstColorFactor.SetAllChannels( DstColor.A );
            break;

        case D3DBLEND_INVDESTALPHA:
            DstColorFactor.SetAllChannels( 1.f - DstColor.A );
            break;

        case D3DBLEND_DESTCOLOR:
            DstColorFactor.R = DstColor.R;
            DstColorFactor.G = DstColor.G;
            DstColorFactor.B = DstColor.B;
            DstColorFactor.A = DstColor.A;
            break;

        case D3DBLEND_INVDESTCOLOR:
            DstColorFactor.R = ( 1.f - DstColor.R );
            DstColorFactor.G = ( 1.f - DstColor.G );
            DstColorFactor.B = ( 1.f - DstColor.B );
            DstColorFactor.A = ( 1.f - DstColor.A );
            break;

        case D3DBLEND_SRCALPHASAT:
            {
                FLOAT F = MIN( SrcColor.A, 1.f - DstColor.A );
                DstColorFactor.R = F;
                DstColorFactor.G = F;
                DstColorFactor.B = F;
            }
            DstColorFactor.A = 1.F;
            break;
        }
    }

    // apply blend factors to update pixel color (MIN and MAX handled above)
    RDColor SclSrc, SclDst;
    SclSrc.R = SrcColorFactor.R * SrcColor.R;
    SclSrc.G = SrcColorFactor.G * SrcColor.G;
    SclSrc.B = SrcColorFactor.B * SrcColor.B;
    SclSrc.A = SrcColorFactor.A * SrcColor.A;
    SclDst.R = DstColorFactor.R * DstColor.R;
    SclDst.G = DstColorFactor.G * DstColor.G;
    SclDst.B = DstColorFactor.B * DstColor.B;
    SclDst.A = DstColorFactor.A * DstColor.A;
    switch ( m_pRD->GetRS()[D3DRS_BLENDOP] )
    {
    default:
    case D3DBLENDOP_ADD:
        ResColor.R = SclSrc.R + SclDst.R;
        ResColor.G = SclSrc.G + SclDst.G;
        ResColor.B = SclSrc.B + SclDst.B;
        ResColor.A = SclSrc.A + SclDst.A;
        break;
    case D3DBLENDOP_SUBTRACT:
        ResColor.R = SclSrc.R - SclDst.R;
        ResColor.G = SclSrc.G - SclDst.G;
        ResColor.B = SclSrc.B - SclDst.B;
        ResColor.A = SclSrc.A - SclDst.A;
        break;
    case D3DBLENDOP_REVSUBTRACT:
        ResColor.R = SclDst.R - SclSrc.R;
        ResColor.G = SclDst.G - SclSrc.G;
        ResColor.B = SclDst.B - SclSrc.B;
        ResColor.A = SclDst.A - SclSrc.A;
        break;
    }

    // clamp result
    ResColor.Clamp();
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\rast\pshader.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// pixshade.cpp
//
// Direct3D Reference Device - Pixel Shader
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
RDPShader::RDPShader(void)
{
    m_pRD = NULL;
    m_pCode = NULL;
    m_CodeSize = 0;
    m_cActiveTextureStages = 0;
    m_ReferencedTexCoordMask = 0;
    m_cInst = 0;
    m_pInst = NULL;
    m_cConstDefs = 0;
    m_pConstDefs = NULL;
}

//-----------------------------------------------------------------------------
RDPShader::~RDPShader()
{
    if (NULL != m_pCode)        delete[] m_pCode;
    if (NULL != m_pInst)        delete[] m_pInst;
    if (NULL != m_pConstDefs)   delete[] m_pConstDefs;
}

#define _DWordCount() (pToken - pCode)

#define _RegisterNeedsToBeInitializedWithTexcoords(Reg) (*pReferencedTexCoordMask)|=(1<<Reg);

//-----------------------------------------------------------------------------
//
// UpdateReferencedTexCoords
//
// Called for each instruction while parsing a 1.3 pixelshader.
// Updates pReferencedTexCoordMask (bitfield) to represent
// which texture coordinate sets are actually used by the shader.
// This is used to eliminate unnecessary attribute setup/sampling during
// primitive rasterization.
//
//-----------------------------------------------------------------------------
void UpdateReferencedTexCoords(PixelShaderInstruction* pInst,
                               DWORD* pReferencedTexCoordMask )
{
    switch( pInst->Opcode & D3DSI_OPCODE_MASK )
    {
    case D3DSIO_TEX:  
    case D3DSIO_TEXCOORD:
    case D3DSIO_TEXDEPTH:
        {
            for( UINT i = 0; i < 3; i++ )
            {
                UINT  RegNum = pInst->SrcParam[i] & 0xFF;
                if( D3DSPR_TEXTURE == (pInst->SrcParam[i] & D3DSP_REGTYPE_MASK) )
                    _RegisterNeedsToBeInitializedWithTexcoords(RegNum);
            }
        }
        break;
    case D3DSIO_TEXKILL:  // treat dest param as source
        {
            UINT  RegNum = pInst->DstParam & 0xFF;
            if( D3DSPR_TEXTURE == (pInst->DstParam & D3DSP_REGTYPE_MASK) )
                _RegisterNeedsToBeInitializedWithTexcoords(RegNum);
        }
        break;
    }
}

void CalculateSourceReadMasks(PixelShaderInstruction* pInst, BYTE* pSourceReadMasks, BOOL bAfterSwizzle, DWORD dwVersion)
{
    UINT i, j;
    DWORD Opcode = pInst->Opcode & D3DSI_OPCODE_MASK;
    BYTE  ComponentMask[4]= {RDPS_COMPONENTMASK_0, RDPS_COMPONENTMASK_1, RDPS_COMPONENTMASK_2, RDPS_COMPONENTMASK_3};

    for( i = 0; i < pInst->SrcParamCount; i++ )
    {
        BYTE  NeededComponents;
        BYTE  ReadComponents = 0;

        switch( Opcode )
        {
        case D3DSIO_TEX:      // only in ps.1.4 does texld have source parameter
            if( D3DPS_VERSION(1,4) == dwVersion )
            {
                // for ps.1.4, texld has a source parameter
                NeededComponents = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 | RDPS_COMPONENTMASK_2;
            }
            else // versions < ps.1.4 don't have a src param on tex, so we shouldn't get here.  But maybe in ps.2.0...
            {
                NeededComponents = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 | RDPS_COMPONENTMASK_2 | RDPS_COMPONENTMASK_3;
            }
            break;
        case D3DSIO_TEXCOORD:
            if( D3DPS_VERSION(1,4) == dwVersion )
            {
                // for ps.1.4, texcrd has a source parameter
                NeededComponents = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 | RDPS_COMPONENTMASK_2;
            }
            else // versions < ps.1.4 don't have a src param on texcoord, so we shouldn't get here.  But maybe in ps.2.0...
            {
                NeededComponents = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 | RDPS_COMPONENTMASK_2 | RDPS_COMPONENTMASK_3;
            }
            break;
        case D3DSIO_TEXBEM:
        case D3DSIO_TEXBEML:
            NeededComponents = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1;
            break;
        case D3DSIO_DP3:
            NeededComponents = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 | RDPS_COMPONENTMASK_2;
            break;
        case D3DSIO_DP4:
            NeededComponents = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 | RDPS_COMPONENTMASK_2 | RDPS_COMPONENTMASK_3;
            break;
        case D3DSIO_BEM: // ps.1.4
            NeededComponents = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1;
            break;
        default: 
            // standard component-wise instruction, 
            // OR an op we know reads .rgba and we also know it will be validated to .rgba writemask
            NeededComponents = (pInst->DstParam & D3DSP_WRITEMASK_ALL) >> RDPS_COMPONENTMASK_SHIFT;
            break;
        }

        if( bAfterSwizzle )
        {
            pSourceReadMasks[i] = NeededComponents;
        }
        else
        {
            // Figure out which components of this source parameter are read (taking into account swizzle)
            for(j = 0; j < 4; j++)
            {
                if( NeededComponents & ComponentMask[j] )
                    ReadComponents |= ComponentMask[((pInst->SrcParam[i] & D3DSP_SWIZZLE_MASK) >> (D3DVS_SWIZZLE_SHIFT + 2*j)) & 0x3];
            }
            pSourceReadMasks[i] = ReadComponents;
        }
    }
}

void RDPSRegister::Set(RDPS_REGISTER_TYPE RegType, UINT RegNum, RefRast* pRast)
{
    m_RegType = RegType;
    m_RegNum = RegNum;

    UINT MaxRegNum = 0;

    switch( RegType )
    {
    case RDPSREG_INPUT:
        MaxRegNum = RDPS_MAX_NUMINPUTREG - 1;
        m_pReg = pRast->m_InputReg[RegNum];
        break;
    case RDPSREG_TEMP:
        MaxRegNum = RDPS_MAX_NUMTEMPREG - 1;
        m_pReg = pRast->m_TempReg[RegNum];
        break;
    case RDPSREG_CONST:
        MaxRegNum = RDPS_MAX_NUMCONSTREG - 1;
        m_pReg = pRast->m_ConstReg[RegNum];
        break;
    case RDPSREG_TEXTURE:
        MaxRegNum = RDPS_MAX_NUMTEXTUREREG - 1;
        m_pReg = pRast->m_TextReg[RegNum];
        break;
    case RDPSREG_POSTMODSRC:
        MaxRegNum = RDPS_MAX_NUMPOSTMODSRCREG - 1;
        m_pReg = pRast->m_PostModSrcReg[RegNum];
        break;
    case RDPSREG_SCRATCH:
        MaxRegNum = RDPS_MAX_NUMSCRATCHREG - 1;
        m_pReg = pRast->m_ScratchReg[RegNum];
        break;
    case RDPSREG_QUEUEDWRITE:
        MaxRegNum = RDPS_MAX_NUMQUEUEDWRITEREG - 1;
        m_pReg = pRast->m_QueuedWriteReg[RegNum];
        break;
    case RDPSREG_ZERO:
        MaxRegNum = 0;
        m_pReg = pRast->m_ZeroReg;
        break;
    case RDPSREG_ONE:
        MaxRegNum = 0;
        m_pReg = pRast->m_OneReg;
        break;
    case RDPSREG_TWO:
        MaxRegNum = 0;
        m_pReg = pRast->m_TwoReg;
        break;
    default:
        m_pReg = NULL;
        _ASSERT(FALSE,"RDPSRegister::SetReg - Unknown register type.");
        break;
    }
    if( RegNum > MaxRegNum )
    {
        _ASSERT(FALSE,"RDPSRegister::SetReg - Register number too high.");
    }
    return;
}

//-----------------------------------------------------------------------------
//
// Initialize 
// 
// - Copies pixel shader token stream from DDI token stream.
// - Counts the number of active texture stages for m_cActiveTextureStages.
// - Translates shader into "RISC" instruction set to be executed 
//   by refrast's shader VM
//
//-----------------------------------------------------------------------------
HRESULT
RDPShader::Initialize(
    RefDev* pRD, DWORD* pCode, DWORD ByteCodeSize, D3DCAPS8* pCaps )
{
    m_pRD = pRD;
    m_CodeSize = ByteCodeSize/4;    // bytecount -> dword count

    FLOAT   fMin = -(pCaps->MaxPixelShaderValue);
    FLOAT   fMax =  (pCaps->MaxPixelShaderValue);

    // ------------------------------------------------------------------------
    //
    // First pass through shader to find the number of instructions,
    // figure out how many constants there are.
    //
    // ------------------------------------------------------------------------
    {
        DWORD* pToken = pCode;
        pToken++;    // version token
        while (*pToken != D3DPS_END())
        {
            DWORD Inst = *pToken;
            if (*pToken++ & (1L<<31))    // instruction token
            {
                DPFERR("PixelShader Token #%d: instruction token error",_DWordCount());
                return E_FAIL;
            }
            if ( (Inst & D3DSI_OPCODE_MASK) == D3DSIO_COMMENT )
            {
                pToken += (Inst & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;
                m_cInst++;
            }
            else if( (Inst & D3DSI_OPCODE_MASK) == D3DSIO_DEF )
            {
                m_cConstDefs++;
                pToken += 5;
            }
            else
            {
                if (*pToken & (1L<<31)) pToken++;    // destination param token
                while (*pToken & (1L<<31)) pToken++; // source param tokens
                m_cInst++;
            }
            if (_DWordCount() > (int)m_CodeSize)
            {
                DPFERR("PixelShader(%d tokens, %d expected): count error",_DWordCount(),m_CodeSize);
                return E_FAIL;
            }
        }
        pToken++; // step over END token
        if (_DWordCount() != (int)m_CodeSize)
        {
            DPFERR("PixelShader(%d tokens, %d expected): count error",_DWordCount(),m_CodeSize);
            return E_FAIL;
        }

        // make copy of original shader
        m_pCode = new DWORD[m_CodeSize];
        if (NULL == m_pCode)
            return E_OUTOFMEMORY;
        memcpy( m_pCode, pCode, ByteCodeSize );

        // allocate instruction array
        m_pInst = new PixelShaderInstruction[m_cInst];
        if (NULL == m_pInst)
            return E_OUTOFMEMORY;
        memset( m_pInst, 0x0, sizeof(PixelShaderInstruction)*m_cInst );

        m_pConstDefs = new ConstDef[m_cConstDefs];
        if (NULL == m_pConstDefs)
            return E_OUTOFMEMORY;
    }

    // ------------------------------------------------------------------------
    //
    // Second pass through shader to:
    //      - produce a list of instructions, each one including opcodes, 
    //        comments, and disassembled text for access by shader debuggers.
    //      - figure out the TSS # used (if any) by each instruction
    //      - figure out the max texture stage # used
    //      - figure out when the ref. pixel shader executor should
    //        queue writes up and when to flush the queue, in order to
    //        simulate co-issue.
    //      - figure out which texture coordinate sets get used
    //      - process constant DEF instructions into a list that can be
    //        executed whenever SetPixelShader is done.
    //
    // ------------------------------------------------------------------------
    {
        DWORD* pToken = m_pCode;
        PixelShaderInstruction* pInst = m_pInst;
        PixelShaderInstruction* pPrevious_NonTrivial_Inst = NULL;
        pToken++; // skip over version

        BOOL    bMinimizeReferencedTexCoords;

        if( (D3DPS_VERSION(1,3) >= *pCode) ||
            (D3DPS_VERSION(254,254) == *pCode ) )//legacy
        {
            bMinimizeReferencedTexCoords    = FALSE;
        }
        else
        {
            bMinimizeReferencedTexCoords    = TRUE;
        }


        UINT    CurrConstDef = 0;

        while (*pToken != D3DPS_END())
        {
            switch( (*pToken) & D3DSI_OPCODE_MASK )
            {
            case D3DSIO_COMMENT:
                pInst->Opcode = *pToken;
                pInst->pComment = (pToken+1);
                pInst->CommentSize = ((*pToken) & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT;
                pToken += (pInst->CommentSize+1);
                pInst++;
                continue;
            case D3DSIO_DEF:
                {
                    pToken++;
                    m_pConstDefs[CurrConstDef].RegNum = (*pToken++) & D3DSP_REGNUM_MASK;

                    // clamp constants on input to range of values in pixel shaders
                    for( UINT i = 0; i < 4; i++ )
                    {
                        m_pConstDefs[CurrConstDef].f[i] = MAX( fMin, MIN( fMax, *(FLOAT*)pToken));
                        pToken++;
                    }

                    CurrConstDef++;
                    continue;
                }
            case D3DSIO_NOP:
                // get disasm string
#if DBG
                PixelShaderInstDisAsm( pInst->Text, 128, pToken, 0x0 );
#else // !DBG
                pInst->Text[ 0 ] = '\0';
#endif // !DBG
                pInst->Opcode = *pToken++;
                pInst++;
                continue;
            }

            // get disasm string
#if DBG
            PixelShaderInstDisAsm( pInst->Text, 128, pToken, 0x0 );
#else // !DBG
            pInst->Text[ 0 ] = '\0';
#endif // !DBG

            // get next instruction and parameters
            pInst->Opcode = *pToken++;

            pInst->SrcParamCount = 0;
            if (*pToken & (1L<<31))
            {
                pInst->DstParam = *pToken++;
            }
            while (*pToken & (1L<<31))
            {
                pInst->SrcParam[pInst->SrcParamCount++] = *pToken++;
            }


            // process TEX ops
            //
            BOOL bLegacyTexOp = FALSE;
            switch (pInst->Opcode & D3DSI_OPCODE_MASK)
            {
            default: break;
            case D3DSIO_TEXBEM_LEGACY:
            case D3DSIO_TEXBEML_LEGACY:
                bLegacyTexOp = TRUE;
                // fall through
            case D3DSIO_TEXCOORD:
            case D3DSIO_TEXKILL:
            case D3DSIO_TEX:
            case D3DSIO_TEXBEM:
            case D3DSIO_TEXBEML:
            case D3DSIO_TEXREG2AR:
            case D3DSIO_TEXREG2GB:
            case D3DSIO_TEXM3x2PAD:
            case D3DSIO_TEXM3x2TEX:
            case D3DSIO_TEXM3x3PAD:
            case D3DSIO_TEXM3x3TEX:
            case D3DSIO_TEXM3x3SPEC:
            case D3DSIO_TEXM3x3VSPEC:
            case D3DSIO_TEXM3x2DEPTH:
            case D3DSIO_TEXDP3:
            case D3DSIO_TEXREG2RGB:
            case D3DSIO_TEXDEPTH:
            case D3DSIO_TEXDP3TEX:
            case D3DSIO_TEXM3x3:
                pInst->bTexOp = TRUE;
                break;
            }
            if (pInst->bTexOp)
            {
                // update stage count and assign ptr to TSS for this op
                if (bLegacyTexOp)
                {
                    m_cActiveTextureStages =
                        max(m_cActiveTextureStages,(pInst->DstParam&D3DSP_REGNUM_MASK)+1);
                    pInst->uiTSSNum = (pInst->DstParam&D3DSP_REGNUM_MASK)-1;
                }
                else
                {
                    UINT Stage;
                    BOOL bStageUsed = TRUE;

                    switch(pInst->Opcode & D3DSI_OPCODE_MASK)
                    {
                    case D3DSIO_TEXCOORD:
                    case D3DSIO_TEXDEPTH:
                    case D3DSIO_TEXKILL:
                        if( bMinimizeReferencedTexCoords )
                        {
                            bStageUsed = FALSE;
                            break;
                        }
                        // falling through
                    case D3DSIO_TEX:
                    default:
                        Stage = pInst->DstParam&D3DSP_REGNUM_MASK;
                        break;
                    }

                    if( bStageUsed )
                    {
                        m_cActiveTextureStages = max(m_cActiveTextureStages,Stage+1);
                        pInst->uiTSSNum = Stage;
                    }
                }
            }

            if( pPrevious_NonTrivial_Inst )
            {
                // Queue write of last instruction if the current instruction has the
                // COISSUE flag.
                if( pInst->Opcode & D3DSI_COISSUE )
                {
                    pPrevious_NonTrivial_Inst->bQueueWrite = TRUE;
                }

                // Flush writes after the previous instruction if it had the COISSUE
                // flag and the current instruction doesn't have it.
                if( !(pInst->Opcode & D3DSI_COISSUE) && (pPrevious_NonTrivial_Inst->Opcode & D3DSI_COISSUE) )
                {
                    pPrevious_NonTrivial_Inst->bFlushQueue = TRUE;
                }
            }

            pPrevious_NonTrivial_Inst = pInst;

            if( bMinimizeReferencedTexCoords )
            {
                UpdateReferencedTexCoords(pInst, &m_ReferencedTexCoordMask);
            }

            pInst++;
        }

        if( !bMinimizeReferencedTexCoords )
        {
           m_ReferencedTexCoordMask = (1<<m_cActiveTextureStages) - 1;
        }
    }

    // ------------------------------------------------------------------------
    //
    // Third pass through the shader (through the list of instructions made
    // in the last pass) to translate instructions into a more basic ("RISC") 
    // instruction set for the refrast executor.
    //
    // ------------------------------------------------------------------------
    {
        #define _Set(RegType, RegNum)               Set(RegType,RegNum,pRast)

        #define _NewPSInst(__INST)                                                              \
            {                                                                                   \
                RDPSOffset = pRDPSInst - pRDPSInstBuffer + LastRDPSInstSize;                    \
                m_RDPSInstBuffer.SetGrowSize(MAX(512,RDPSOffset));                              \
                if( FAILED(m_RDPSInstBuffer.Grow(RDPSOffset + sizeof(__INST##_PARAMS))))        \
                {return E_OUTOFMEMORY;}                                                         \
                pRDPSInstBuffer = &m_RDPSInstBuffer[0];                                         \
                pRDPSInst = pRDPSInstBuffer + RDPSOffset;                                       \
                ((__INST##_PARAMS UNALIGNED64*)pRDPSInst)->Inst = __INST;                                   \
                LastRDPSInstSize = sizeof(__INST##_PARAMS);                                     \
            }

        #define _InstParam(__INST)     (*(__INST##_PARAMS UNALIGNED64*)pRDPSInst)

        #define _NoteInstructionEvent  _NewPSInst(RDPSINST_NEXTD3DPSINST); \
                                        _InstParam(RDPSINST_NEXTD3DPSINST).pInst = pInst;

        #define _EnterQuadPixelLoop    if(!bInQuadPixelLoop)                                                       \
                                        {                                                                          \
                                            _NewPSInst(RDPSINST_QUADLOOPBEGIN);                                    \
                                            RDPSLoopOffset = RDPSOffset + sizeof(RDPSINST_QUADLOOPBEGIN_PARAMS);   \
                                            bInQuadPixelLoop = TRUE;                                               \
                                        }

        #define _LeaveQuadPixelLoop     if(bInQuadPixelLoop)                                             \
                                        {                                                               \
                                            _NewPSInst(RDPSINST_QUADLOOPEND);                           \
                                            _InstParam(RDPSINST_QUADLOOPEND).JumpBackByOffset =         \
                                                                            RDPSOffset - RDPSLoopOffset;\
                                            bInQuadPixelLoop = FALSE;                                   \
                                        }

        #define _EmitDstMod(__dstReg,__mask)    _NewPSInst(RDPSINST_DSTMOD);                            \
                                                _InstParam(RDPSINST_DSTMOD).DstReg    = __dstReg;       \
                                                _InstParam(RDPSINST_DSTMOD).WriteMask = __mask;         \
                                                _InstParam(RDPSINST_DSTMOD).fScale    = DstScale;       \
                                                _InstParam(RDPSINST_DSTMOD).fRangeMin = DstRange[0];    \
                                                _InstParam(RDPSINST_DSTMOD).fRangeMax = DstRange[1];    
                    

        // Th macro _EmitProj emits instructions to do the following:
        // - Put reciprocal of source (x,y,z,w) component __COMPONENT (ex. w) into scratch register 0 component (for w example:) 4
        // - Replicate reciprocal to rgb components of scratch register 0 (w example yields: 1/,1/w,1/w, <--1/w)
        // - Multiply source register register by scratch register (x/w,y/w,z/w,1) and put the result into the dest register.
        #define _EmitProj(__DESTTYPE,__DESTNUM,__SRCTYPE,__SRCNUM,__COMPONENT)                                                      \
                    _NewPSInst(RDPSINST_RCP);                                                                                       \
                    _InstParam(RDPSINST_RCP).DstReg._Set(RDPSREG_SCRATCH,0);                                                        \
                    _InstParam(RDPSINST_RCP).SrcReg0._Set(__SRCTYPE,__SRCNUM);                                                      \
                    _InstParam(RDPSINST_RCP).bSrcReg0_Negate = FALSE;                                                               \
                    _InstParam(RDPSINST_RCP).WriteMask  = __COMPONENT;                                                              \
                                                                                                                                    \
                    _NewPSInst(RDPSINST_SWIZZLE);                                                                                   \
                    _InstParam(RDPSINST_SWIZZLE).DstReg._Set(RDPSREG_SCRATCH,0);                                                    \
                    _InstParam(RDPSINST_SWIZZLE).SrcReg0._Set(RDPSREG_SCRATCH,0);                                                   \
                    _InstParam(RDPSINST_SWIZZLE).WriteMask  = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1                           \
                                                            | RDPS_COMPONENTMASK_2 | RDPS_COMPONENTMASK_3;                          \
                    _InstParam(RDPSINST_SWIZZLE).Swizzle    =                                                                       \
                                      (RDPS_COMPONENTMASK_0 == __COMPONENT) ? RDPS_REPLICATERED :                                   \
                                      (RDPS_COMPONENTMASK_1 == __COMPONENT) ? RDPS_REPLICATEGREEN :                                 \
                                      (RDPS_COMPONENTMASK_2 == __COMPONENT) ? RDPS_REPLICATEBLUE : RDPS_REPLICATEALPHA;             \
                                                                                                                                    \
                    _NewPSInst(RDPSINST_MUL);                                                                                       \
                    _InstParam(RDPSINST_MUL).DstReg._Set(__DESTTYPE,__DESTNUM);                                                     \
                    _InstParam(RDPSINST_MUL).SrcReg0._Set(RDPSREG_SCRATCH,0);                                                       \
                    _InstParam(RDPSINST_MUL).SrcReg1._Set(__SRCTYPE,__SRCNUM);                                                      \
                    _InstParam(RDPSINST_MUL).bSrcReg0_Negate = FALSE;                                                               \
                    _InstParam(RDPSINST_MUL).bSrcReg1_Negate = FALSE;                                                               \
                    _InstParam(RDPSINST_MUL).WriteMask  =                                                                           \
                                      (RDPS_COMPONENTMASK_0 == __COMPONENT) ? RDPS_COMPONENTMASK_0 :                                \
                                      (RDPS_COMPONENTMASK_1 == __COMPONENT) ? RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 :         \
                                      (RDPS_COMPONENTMASK_2 == __COMPONENT) ? RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 |         \
                                                                              RDPS_COMPONENTMASK_2 : RDPS_COMPONENTMASK_ALL;

        BYTE    ComponentSwizzle[4] = {RDPS_REPLICATERED, RDPS_REPLICATEGREEN, RDPS_REPLICATEBLUE, RDPS_REPLICATEALPHA};
        BYTE    ComponentMask[4]    = {RDPS_COMPONENTMASK_0, RDPS_COMPONENTMASK_1, RDPS_COMPONENTMASK_2, RDPS_COMPONENTMASK_3};
        int     QueueIndex          = -1; // current queue location (for staging results when simulating coissue)
        UINT    i;
        BOOL    bInQuadPixelLoop = FALSE;

        RefRast* pRast = &m_pRD->m_Rast;

        RDPSRegister ZeroReg; ZeroReg._Set(RDPSREG_ZERO,0);
        RDPSRegister OneReg;  OneReg._Set(RDPSREG_ONE,0);
        RDPSRegister TwoReg;  TwoReg._Set(RDPSREG_TWO,0);

        // destination parameter controls
        RDPSRegister    DstReg;
        FLOAT           DstScale;           // Result Shift Scale - +/- 2**n only
        FLOAT           DstRange[2];        // clamp dest to this range
        BYTE            DstWriteMask;       // per-component write mask
        PRGBAVEC        pDstReg;            // address of dest register

        // source parameter controls
        RDPSRegister SrcReg[3];

        BYTE*   pRDPSInstBuffer     = NULL;
        BYTE*   pRDPSInst           = pRDPSInstBuffer;
        size_t  RDPSOffset, RDPSLoopOffset;
        size_t  LastRDPSInstSize    = 0;

        DWORD   Version = *m_pCode;
    
        for (UINT CurrentPSInst=0; CurrentPSInst < m_cInst; CurrentPSInst++)
        {
            PixelShaderInstruction* pInst = m_pInst + CurrentPSInst;
            DWORD   Opcode = pInst->Opcode & D3DSI_OPCODE_MASK;
            DWORD   SrcSwizzle[3];     
            BYTE    SourceReadMasks[3];
            BYTE    SourceReadMasksAfterSwizzle[3];
            BOOL    bForceNeg1To1Clamp[3]  = {FALSE, FALSE, FALSE};
            BOOL    bEmitQueueWrite        = FALSE;
            RDPSRegister QueuedWriteDstReg;
            BYTE    QueuedWriteDstWriteMask;
            BYTE    ProjComponent[3]       = {0,0,0};
            BOOL    bEmitProj[3]           = {FALSE, FALSE, FALSE};
            BOOL    bProjOnEval[3]         = {FALSE, FALSE, FALSE};
            BOOL    bEmitSrcMod[3]         = {FALSE, FALSE, FALSE};
            BOOL    bEmitSwizzle[3]        = {FALSE, FALSE, FALSE};
            BOOL    bSrcNegate[3]          = {FALSE, FALSE, FALSE};
            BOOL    bSrcBias[3]            = {FALSE, FALSE, FALSE};
            BOOL    bSrcTimes2[3]          = {FALSE, FALSE, FALSE};
            BOOL    bSrcComplement[3]      = {FALSE, FALSE, FALSE};
        
            switch( Opcode )
            {
                continue;
            case D3DSIO_DEF:
                // nothing to do -> DEF has already been processed out and is not an true instruction
                continue;
            case D3DSIO_COMMENT:
                continue;
            case D3DSIO_PHASE:
            case D3DSIO_NOP:
    #if DBG
                _NoteInstructionEvent
    #endif
                continue;
            }

    #if DBG
                _NoteInstructionEvent
    #endif

            // do some preliminary setup for this instruction

            UINT RegNum = pInst->DstParam & D3DSP_REGNUM_MASK;
            switch (pInst->DstParam & D3DSP_REGTYPE_MASK)
            {
            case D3DSPR_TEXTURE:
                DstReg._Set(RDPSREG_TEXTURE, RegNum); break;
            case D3DSPR_TEMP:
                DstReg._Set(RDPSREG_TEMP, RegNum); break;
            default:
                _ASSERT( FALSE, "RDPShader::Initialize - Unexpected destination register type." );
                break;
            }

            DstWriteMask = (pInst->DstParam & D3DSP_WRITEMASK_ALL) >> RDPS_COMPONENTMASK_SHIFT;

            if( pInst->bQueueWrite )
            {
                QueueIndex++;

                QueuedWriteDstReg = DstReg;
                QueuedWriteDstWriteMask = DstWriteMask;
                DstReg._Set(RDPSREG_QUEUEDWRITE,QueueIndex);
                _ASSERT(QueueIndex <= RDPS_MAX_NUMQUEUEDWRITEREG, "Too many queued writes in pixelshader (improperly handled co-issue)." );
                bEmitQueueWrite = TRUE;
            }

            CalculateSourceReadMasks(pInst, SourceReadMasks, FALSE,Version);
            CalculateSourceReadMasks(pInst, SourceReadMasksAfterSwizzle, TRUE,Version);
            for (i=0; i < pInst->SrcParamCount; i++)
            {
                RegNum = pInst->SrcParam[i]&D3DSP_REGNUM_MASK;
                switch (pInst->SrcParam[i] & D3DSP_REGTYPE_MASK)
                {
                case D3DSPR_TEMP:
                    SrcReg[i]._Set(RDPSREG_TEMP, RegNum); break;
                case D3DSPR_TEXTURE:
                    SrcReg[i]._Set(RDPSREG_TEXTURE, RegNum); break;
                case D3DSPR_INPUT:
                    SrcReg[i]._Set(RDPSREG_INPUT, RegNum); break;
                case D3DSPR_CONST:
                    SrcReg[i]._Set(RDPSREG_CONST, RegNum);
                    // Force a [-1,1] clamp after applying modifier (for constants only)
                    // This overrides the the standard [-MaxPixelShaderValue,MaxPixelShaderValue] clamp.
                    // An IHV that supports MaxPixelShaderValue > 1 forgot to do this for constants.
                    bForceNeg1To1Clamp[i] = TRUE;
                    break;
                default:
                    _ASSERT( FALSE, "RDPShader::Initialize - Unexpected source register type." );
                    break;
                }

                if( (D3DSPSM_DZ == (pInst->SrcParam[i] & D3DSP_SRCMOD_MASK)) || 
                    (D3DSPSM_DW == (pInst->SrcParam[i] & D3DSP_SRCMOD_MASK)) )
                {
                    if( D3DSPSM_DZ == (pInst->SrcParam[i] & D3DSP_SRCMOD_MASK))
                    {
                        ProjComponent[i] = RDPS_COMPONENTMASK_2;
                    }
                    else // _DW
                    {
                        if( D3DPS_VERSION(1,4) == Version )
                            ProjComponent[i] = RDPS_COMPONENTMASK_2;
                        else
                            ProjComponent[i] = RDPS_COMPONENTMASK_3;
                    }

                    
                    if( D3DSPR_TEXTURE == (pInst->SrcParam[i] & D3DSP_REGTYPE_MASK ) ) // t# register being used to represent evaluated texcoord.
                    {
                        bProjOnEval[i] = TRUE;
                    }                               
                    else
                        bEmitProj[i] = TRUE;
                }
                else
                {
                    bEmitSrcMod[i] = TRUE;

                    switch (pInst->SrcParam[i] & D3DSP_SRCMOD_MASK)
                    {
                    default:
                    case D3DSPSM_NONE:      
                        if( !bForceNeg1To1Clamp[i] ) 
                            bEmitSrcMod[i] = FALSE; 
                        break;
                    case D3DSPSM_NEG:       
                        bSrcNegate[i]   = TRUE; // negate is not part of source modifier
                        if( !bForceNeg1To1Clamp[i] ) 
                            bEmitSrcMod[i] = FALSE; 
                        break;
                    case D3DSPSM_BIAS:
                        bSrcBias[i]         = TRUE;
                        break;
                    case D3DSPSM_BIASNEG:
                        bSrcNegate[i]       = TRUE; 
                        bSrcBias[i]         = TRUE;
                        break;
                    case D3DSPSM_SIGN:              // _bx2
                        bSrcBias[i]         = TRUE;
                        bSrcTimes2[i]       = TRUE;
                        break;
                    case D3DSPSM_SIGNNEG:           // negative _bx2
                        bSrcNegate[i]       = TRUE; // negate is not part of source modifier
                        bSrcBias[i]         = TRUE;
                        bSrcTimes2[i]       = TRUE;
                        break;                        
                    case D3DSPSM_COMP:    
                        bSrcComplement[i]   = TRUE;
                        break;
                    case D3DSPSM_X2:
                        bSrcTimes2[i]       = TRUE;
                        break;
                    case D3DSPSM_X2NEG:     
                        bSrcNegate[i]       = TRUE; // negate is not part of source modifier
                        bSrcTimes2[i]       = TRUE;
                        break;
                    }

                    _ASSERT(!(bSrcComplement[i] && (bSrcTimes2[i]||bSrcBias[i]||bSrcNegate[i])),"RDPShader::Initialize - Complement cannot be combined with other modifiers.");
                }

                SrcSwizzle[i] = (pInst->SrcParam[i] & D3DSP_SWIZZLE_MASK) >> D3DSP_SWIZZLE_SHIFT;
                bEmitSwizzle[i] = (D3DSP_NOSWIZZLE != (pInst->SrcParam[i] & D3DSP_SWIZZLE_MASK));
            }

            // set clamp values
            switch (pInst->DstParam & D3DSP_DSTMOD_MASK)
            {
            default:
            case D3DSPDM_NONE:
                if(pInst->bTexOp)
                {
                    DstRange[0] = -FLT_MAX;
                    DstRange[1] =  FLT_MAX;
                }
                else
                {
                    DstRange[0] = fMin;
                    DstRange[1] = fMax;
                }
                break;
            case D3DSPDM_SATURATE:
                DstRange[0] = 0.F;
                DstRange[1] = 1.F;
                break;
            }

            UINT ShiftScale =
                (pInst->DstParam & D3DSP_DSTSHIFT_MASK) >> D3DSP_DSTSHIFT_SHIFT;
            if (ShiftScale & 0x8)
            {
                ShiftScale = ((~ShiftScale)&0x7)+1; // negative magnitude
                DstScale = 1.f/(FLOAT)(1<<ShiftScale);
            }
            else
            {
                DstScale = (FLOAT)(1<<ShiftScale);
            }

            // finished preliminary setup, now start emitting ops...

            _EnterQuadPixelLoop

            if( bEmitQueueWrite )
            {
                _NewPSInst(RDPSINST_QUEUEWRITE); 
                _InstParam(RDPSINST_QUEUEWRITE).DstReg          = QueuedWriteDstReg;
                _InstParam(RDPSINST_QUEUEWRITE).WriteMask       = QueuedWriteDstWriteMask;
            }

            for (i=0; i < pInst->SrcParamCount; i++)
            {
                if( bEmitProj[i] )
                {
                    _EmitProj(RDPSREG_POSTMODSRC,i,SrcReg[i].GetRegType(),SrcReg[i].GetRegNum(),ProjComponent[i]);
                    SrcReg[i]._Set(RDPSREG_POSTMODSRC,i);
                }

                if( bEmitSrcMod[i] )
                {
                    _NewPSInst(RDPSINST_SRCMOD);
                    _InstParam(RDPSINST_SRCMOD).DstReg._Set(RDPSREG_POSTMODSRC,i);
                    _InstParam(RDPSINST_SRCMOD).SrcReg0            = SrcReg[i];
                    _InstParam(RDPSINST_SRCMOD).WriteMask          = SourceReadMasks[i];
                    _InstParam(RDPSINST_SRCMOD).bBias              = bSrcBias[i];
                    _InstParam(RDPSINST_SRCMOD).bTimes2            = bSrcTimes2[i];
                    _InstParam(RDPSINST_SRCMOD).bComplement        = bSrcComplement[i];
                    _InstParam(RDPSINST_SRCMOD).fRangeMin          = bForceNeg1To1Clamp[i] ? -1.0f : fMin;
                    _InstParam(RDPSINST_SRCMOD).fRangeMax          = bForceNeg1To1Clamp[i] ? 1.0f : fMax;
                    SrcReg[i]._Set(RDPSREG_POSTMODSRC,i);
                }

                if( bEmitSwizzle[i] && !bProjOnEval[i] )
                {
                    _NewPSInst(RDPSINST_SWIZZLE);
                    _InstParam(RDPSINST_SWIZZLE).DstReg._Set(RDPSREG_POSTMODSRC,i);
                    _InstParam(RDPSINST_SWIZZLE).SrcReg0   = SrcReg[i];
                    _InstParam(RDPSINST_SWIZZLE).WriteMask = SourceReadMasksAfterSwizzle[i];
                    _InstParam(RDPSINST_SWIZZLE).Swizzle   = SrcSwizzle[i];
                    SrcReg[i]._Set(RDPSREG_POSTMODSRC,i);
                }
            }

            switch(Opcode)
            {
            case D3DSIO_TEXCOORD:
            case D3DSIO_TEXKILL:
                {
                    if( !(  (D3DSIO_TEXKILL == Opcode)  && 
                            (D3DSPR_TEMP    == (pInst->DstParam & D3DSP_REGTYPE_MASK))
                         )
                      )
                    {
                        UINT CoordSet = pInst->SrcParam[0] ? (pInst->SrcParam[0] & D3DSP_REGNUM_MASK) : 
                                                             (pInst->DstParam & D3DSP_REGNUM_MASK);

                        RDPSRegister CoordReg;
                        if(bProjOnEval[0])
                            CoordReg._Set(RDPSREG_POSTMODSRC,0);
                        else
                            CoordReg = DstReg;

                        // For TEXCOORD, clamp 0. to 1 only there is no source parameter (ps.1.0, ps.1.1)
                        // For TEXKILL, never clamp
                        // NOTE: the TEXCOORD clamp is a temporary limitation for DX8 shader models
                        BOOL bTexCoordClamp = ((D3DSIO_TEXCOORD == Opcode) && (!pInst->SrcParam[0])) ? TRUE : FALSE;

                        _NewPSInst(RDPSINST_EVAL);
                        _InstParam(RDPSINST_EVAL).DstReg                    = CoordReg;
                        _InstParam(RDPSINST_EVAL).uiCoordSet                = CoordSet;
                        _InstParam(RDPSINST_EVAL).bIgnoreD3DTTFF_PROJECTED  = TRUE; // projection disabled (unless _p modifier used -> _EmitProj below)
                        _InstParam(RDPSINST_EVAL).bClamp                    = bTexCoordClamp;

                        if( bProjOnEval[0] )
                        {
                            if( bEmitSwizzle[0] )
                            {
                                _NewPSInst(RDPSINST_SWIZZLE);
                                _InstParam(RDPSINST_SWIZZLE).DstReg    = DstReg;
                                _InstParam(RDPSINST_SWIZZLE).SrcReg0   = CoordReg;
                                _InstParam(RDPSINST_SWIZZLE).WriteMask = SourceReadMasksAfterSwizzle[0];
                                _InstParam(RDPSINST_SWIZZLE).Swizzle   = SrcSwizzle[0];
                            }
                            _EmitProj(DstReg.GetRegType(),DstReg.GetRegNum(),DstReg.GetRegType(),DstReg.GetRegNum(),ProjComponent[0]);
                        }

                        // check version (first DWORD of code token stream), and always
                        //  set 4th component to 1.0 for ps.1.3 or earlier
                        if ( D3DPS_VERSION(1,3) >= Version )
                        {
                            _NewPSInst(RDPSINST_MOV);
                            _InstParam(RDPSINST_MOV).DstReg             = DstReg;
                            _InstParam(RDPSINST_MOV).SrcReg0            = OneReg; // 1.0f
                            _InstParam(RDPSINST_MOV).bSrcReg0_Negate    = FALSE; 
                            _InstParam(RDPSINST_MOV).WriteMask          = RDPS_COMPONENTMASK_3;
                        }
                    }

                    _EmitDstMod(DstReg,DstWriteMask)

                    if( D3DSIO_TEXKILL == Opcode )
                    {
                        _NewPSInst(RDPSINST_KILL);
                        _InstParam(RDPSINST_KILL).DstReg    = DstReg;
                    }
                }
                break;
            case D3DSIO_TEX:
                {
                    RDPSRegister CoordReg;
                    BOOL bDoSampleCoords = TRUE;

                    UINT CoordSet = pInst->SrcParam[0] ? (pInst->SrcParam[0] & D3DSP_REGNUM_MASK) : 
                                                         (pInst->DstParam & D3DSP_REGNUM_MASK);

                    if( pInst->SrcParam[0] )
                    {
                        CoordReg = SrcReg[0];
                        if( D3DSPR_TEMP  == (pInst->SrcParam[0] & D3DSP_REGTYPE_MASK) )
                            bDoSampleCoords = FALSE;
                    }
                    else // no source param.
                    {
                        CoordReg._Set(RDPSREG_SCRATCH,0);
                    }

                    if( bDoSampleCoords )
                    {
                        _NewPSInst(RDPSINST_EVAL);
                        _InstParam(RDPSINST_EVAL).DstReg                    = CoordReg;
                        _InstParam(RDPSINST_EVAL).uiCoordSet                = CoordSet;
                        _InstParam(RDPSINST_EVAL).bIgnoreD3DTTFF_PROJECTED  = bProjOnEval[0]; // if we have _p modifier, we do _EmitProj below
                        _InstParam(RDPSINST_EVAL).bClamp                    = FALSE;
                    }

                    if( bProjOnEval[0] )
                    {
                        if( bEmitSwizzle[0] )
                        {
                            _NewPSInst(RDPSINST_SWIZZLE);
                            _InstParam(RDPSINST_SWIZZLE).DstReg._Set(RDPSREG_POSTMODSRC,0);
                            _InstParam(RDPSINST_SWIZZLE).SrcReg0   = CoordReg;
                            _InstParam(RDPSINST_SWIZZLE).WriteMask = SourceReadMasksAfterSwizzle[0];
                            _InstParam(RDPSINST_SWIZZLE).Swizzle   = SrcSwizzle[0];
                            CoordReg._Set(RDPSREG_POSTMODSRC,0);
                        }
                        _EmitProj(RDPSREG_POSTMODSRC,0,CoordReg.GetRegType(),CoordReg.GetRegNum(),ProjComponent[0]);
                        CoordReg._Set(RDPSREG_POSTMODSRC,0);
                    }

                    _LeaveQuadPixelLoop

                    PRGBAVEC    pCoordReg = CoordReg.GetRegPtr();

                    _NewPSInst(RDPSINST_TEXCOVERAGE);
                    _InstParam(RDPSINST_TEXCOVERAGE).uiStage = pInst->DstParam & D3DSP_REGNUM_MASK;
                    _InstParam(RDPSINST_TEXCOVERAGE).pGradients = pRast->m_Gradients; // where to store gradients
                    // data from which to compute gradients.  i.e.: du/dx = DUDX_0 - DUDX_1
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_0 = &pCoordReg[1][0]; // du/dx
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_1 = &pCoordReg[0][0];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_0 = &pCoordReg[2][0]; // du/dy
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_1 = &pCoordReg[0][0];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_0 = &pCoordReg[1][1]; // dv/dx
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_1 = &pCoordReg[0][1];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_0 = &pCoordReg[2][1]; // dv/dy
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_1 = &pCoordReg[0][1];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_0 = &pCoordReg[1][2]; // dw/dx
                    _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_1 = &pCoordReg[0][2];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_0 = &pCoordReg[2][2]; // dw/dy
                    _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_1 = &pCoordReg[0][2];

                    _EnterQuadPixelLoop

                    _NewPSInst(RDPSINST_SAMPLE);
                    _InstParam(RDPSINST_SAMPLE).DstReg     = DstReg;
                    _InstParam(RDPSINST_SAMPLE).CoordReg   = CoordReg;
                    _InstParam(RDPSINST_SAMPLE).uiStage    = pInst->DstParam & D3DSP_REGNUM_MASK;

                    _EmitDstMod(DstReg,DstWriteMask)
                }
                break;
            case D3DSIO_TEXDP3:
            case D3DSIO_TEXDP3TEX:
                {
                    RDPSRegister CoordReg;
                    CoordReg._Set(RDPSREG_SCRATCH,0);

                    _NewPSInst(RDPSINST_EVAL);
                    _InstParam(RDPSINST_EVAL).DstReg                    = CoordReg;
                    _InstParam(RDPSINST_EVAL).uiCoordSet                = pInst->DstParam & D3DSP_REGNUM_MASK;
                    _InstParam(RDPSINST_EVAL).bIgnoreD3DTTFF_PROJECTED  = TRUE; // no projection
                    _InstParam(RDPSINST_EVAL).bClamp                    = FALSE;

                    if( D3DSIO_TEXDP3 == Opcode )
                    {
                        _NewPSInst(RDPSINST_DP3);
                        _InstParam(RDPSINST_DP3).DstReg          = DstReg;
                        _InstParam(RDPSINST_DP3).SrcReg0         = SrcReg[0];
                        _InstParam(RDPSINST_DP3).SrcReg1         = CoordReg;
                        _InstParam(RDPSINST_DP3).bSrcReg0_Negate = FALSE;
                        _InstParam(RDPSINST_DP3).bSrcReg1_Negate = FALSE;
                        _InstParam(RDPSINST_DP3).WriteMask       = RDPS_COMPONENTMASK_ALL;
                        _EmitDstMod(DstReg,DstWriteMask)
                    }
                    else // D3DSIO_TEXDP3TEX
                    {
                        _NewPSInst(RDPSINST_DP3);
                        _InstParam(RDPSINST_DP3).DstReg          = CoordReg;
                        _InstParam(RDPSINST_DP3).SrcReg0         = SrcReg[0];
                        _InstParam(RDPSINST_DP3).SrcReg1         = CoordReg;
                        _InstParam(RDPSINST_DP3).bSrcReg0_Negate = FALSE;
                        _InstParam(RDPSINST_DP3).bSrcReg1_Negate = FALSE;
                        _InstParam(RDPSINST_DP3).WriteMask       = RDPS_COMPONENTMASK_0;

                        _NewPSInst(RDPSINST_MOV);
                        _InstParam(RDPSINST_MOV).DstReg          = CoordReg;
                        _InstParam(RDPSINST_MOV).SrcReg0         = ZeroReg; // 0.0f
                        _InstParam(RDPSINST_MOV).bSrcReg0_Negate = FALSE;
                        _InstParam(RDPSINST_MOV).WriteMask       = RDPS_COMPONENTMASK_1 | RDPS_COMPONENTMASK_2;

                        _LeaveQuadPixelLoop

                        PRGBAVEC pCoordReg = CoordReg.GetRegPtr();

                        _NewPSInst(RDPSINST_TEXCOVERAGE);
                        _InstParam(RDPSINST_TEXCOVERAGE).uiStage = pInst->DstParam & D3DSP_REGNUM_MASK;
                        _InstParam(RDPSINST_TEXCOVERAGE).pGradients = pRast->m_Gradients; // where to store gradients
                        // data from which to compute gradients.  i.e.: du/dx = DUDX_0 - DUDX_1
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_0 = &pCoordReg[1][0];         // du/dx
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_1 = &pCoordReg[0][0];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_0 = &pCoordReg[2][0];         // du/dy
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_1 = &pCoordReg[0][0];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_0 =                           // dv/dx
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_1 = 
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_0 =                           // dv/dy
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_1 = 
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_0 =                           // dw/dx
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_1 = 
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_0 =                           // dw/dy
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_1 = &ZeroReg.GetRegPtr()[0][0];  // 0.0f

                        _EnterQuadPixelLoop

                        _NewPSInst(RDPSINST_SAMPLE);
                        _InstParam(RDPSINST_SAMPLE).DstReg      = DstReg;
                        _InstParam(RDPSINST_SAMPLE).CoordReg    = CoordReg;
                        _InstParam(RDPSINST_SAMPLE).uiStage     = pInst->DstParam & D3DSP_REGNUM_MASK;

                        _EmitDstMod(DstReg,DstWriteMask)           
                    }
                }
                break;
            case D3DSIO_TEXREG2AR:
            case D3DSIO_TEXREG2GB:
            case D3DSIO_TEXREG2RGB:
                {
                    UINT I0, I1;
                    PRGBAVEC pSrcReg0 = SrcReg[0].GetRegPtr();

                    switch( Opcode )
                    {
                    case D3DSIO_TEXREG2AR:
                        I0 = 3;
                        I1 = 0;
                        break;
                    case D3DSIO_TEXREG2GB:
                        I0 = 1;
                        I1 = 2;
                        break;
                    case D3DSIO_TEXREG2RGB:
                        I0 = 0;
                        I1 = 1;
                        break;
                    }

                    _LeaveQuadPixelLoop

                    _NewPSInst(RDPSINST_TEXCOVERAGE);
                    _InstParam(RDPSINST_TEXCOVERAGE).uiStage    = pInst->DstParam & D3DSP_REGNUM_MASK;
                    _InstParam(RDPSINST_TEXCOVERAGE).pGradients = pRast->m_Gradients; // where to store gradients
                    // data from which to compute gradients.  i.e.: du/dx = DUDX_0 - DUDX_1
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_0 = &pSrcReg0[1][I0]; // du/dx
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_1 = &pSrcReg0[0][I0];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_0 = &pSrcReg0[2][I0]; // du/dy
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_1 = &pSrcReg0[0][I0];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_0 = &pSrcReg0[1][I1]; // dv/dx
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_1 = &pSrcReg0[0][I1]; 
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_0 = &pSrcReg0[2][I1]; // dv/dy
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_1 = &pSrcReg0[0][I1];
                    switch( Opcode )
                    {
                    case D3DSIO_TEXREG2AR:
                    case D3DSIO_TEXREG2GB:
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_0 =  // dw/dx
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_1 = 
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_0 =  // dw/dy
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_1 = &ZeroReg.GetRegPtr()[0][0]; // 0.0f
                        break;
                    case D3DSIO_TEXREG2RGB:
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_0 = &pSrcReg0[1][2]; // dw/dx
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_1 = &pSrcReg0[0][2];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_0 = &pSrcReg0[2][2]; // dw/dy
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_1 = &pSrcReg0[0][2]; 
                        break;
                    }

                    _EnterQuadPixelLoop

                    RDPSRegister CoordReg;  
                    CoordReg._Set(RDPSREG_SCRATCH,0);

                    _NewPSInst(RDPSINST_SWIZZLE);
                    _InstParam(RDPSINST_SWIZZLE).DstReg         = CoordReg;
                    _InstParam(RDPSINST_SWIZZLE).SrcReg0        = SrcReg[0];
                    _InstParam(RDPSINST_SWIZZLE).WriteMask      = RDPS_COMPONENTMASK_0;
                    _InstParam(RDPSINST_SWIZZLE).Swizzle        = ComponentSwizzle[I0];

                    _NewPSInst(RDPSINST_SWIZZLE);
                    _InstParam(RDPSINST_SWIZZLE).DstReg         = CoordReg;
                    _InstParam(RDPSINST_SWIZZLE).SrcReg0        = SrcReg[0];
                    _InstParam(RDPSINST_SWIZZLE).WriteMask      = RDPS_COMPONENTMASK_1;
                    _InstParam(RDPSINST_SWIZZLE).Swizzle        = ComponentSwizzle[I1];

                    _NewPSInst(RDPSINST_MOV);
                    _InstParam(RDPSINST_MOV).DstReg             = CoordReg;
                    _InstParam(RDPSINST_MOV).SrcReg0            = (D3DSIO_TEXREG2RGB == Opcode ? SrcReg[0] : ZeroReg );
                    _InstParam(RDPSINST_MOV).bSrcReg0_Negate    = FALSE;
                    _InstParam(RDPSINST_MOV).WriteMask          = RDPS_COMPONENTMASK_2;

                    _NewPSInst(RDPSINST_SAMPLE);
                    _InstParam(RDPSINST_SAMPLE).DstReg          = DstReg;
                    _InstParam(RDPSINST_SAMPLE).CoordReg        = CoordReg;
                    _InstParam(RDPSINST_SAMPLE).uiStage         = pInst->DstParam & D3DSP_REGNUM_MASK;

                    _EmitDstMod(DstReg,DstWriteMask)
                }
                break;
            case D3DSIO_TEXBEM:
            case D3DSIO_TEXBEML:
            case D3DSIO_TEXBEM_LEGACY:      // refrast only -> used with legacy fixed function rasterizer
            case D3DSIO_TEXBEML_LEGACY:     // refrast only -> used with legacy fixed function rasterizer
                {                
                    BOOL bDoLuminance = ((D3DSIO_TEXBEML == Opcode) || (D3DSIO_TEXBEML_LEGACY == Opcode));
                    RDPSRegister CoordReg;
                    CoordReg._Set(RDPSREG_SCRATCH,0);

                    _NewPSInst(RDPSINST_EVAL);
                    _InstParam(RDPSINST_EVAL).DstReg                    = CoordReg;
                    _InstParam(RDPSINST_EVAL).uiCoordSet                = pInst->DstParam & D3DSP_REGNUM_MASK;
                    _InstParam(RDPSINST_EVAL).bIgnoreD3DTTFF_PROJECTED  = FALSE;
                    _InstParam(RDPSINST_EVAL).bClamp                    = FALSE;

                    _NewPSInst(RDPSINST_BEM);
                    _InstParam(RDPSINST_BEM).DstReg             = CoordReg;
                    _InstParam(RDPSINST_BEM).SrcReg0            = CoordReg;
                    _InstParam(RDPSINST_BEM).SrcReg1            = SrcReg[0];
                    _InstParam(RDPSINST_BEM).bSrcReg0_Negate    = FALSE;
                    _InstParam(RDPSINST_BEM).bSrcReg1_Negate    = FALSE;
                    _InstParam(RDPSINST_BEM).WriteMask          = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1;
                    _InstParam(RDPSINST_BEM).uiStage            = pInst->uiTSSNum;

                    _EmitDstMod(CoordReg,RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1)

                    _LeaveQuadPixelLoop

                    PRGBAVEC pCoordReg = CoordReg.GetRegPtr();

                    _NewPSInst(RDPSINST_TEXCOVERAGE);
                    _InstParam(RDPSINST_TEXCOVERAGE).uiStage = pInst->DstParam & D3DSP_REGNUM_MASK;
                    _InstParam(RDPSINST_TEXCOVERAGE).pGradients = pRast->m_Gradients; // where to store gradients
                    // data from which to compute gradients.  i.e.: du/dx = DUDX_0 - DUDX_1
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_0 = &pCoordReg[1][0]; // du/dx
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_1 = &pCoordReg[0][0];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_0 = &pCoordReg[2][0]; // du/dy
                    _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_1 = &pCoordReg[0][0];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_0 = &pCoordReg[1][1]; // dv/dx
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_1 = &pCoordReg[0][1];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_0 = &pCoordReg[2][1]; // dv/dy
                    _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_1 = &pCoordReg[0][1];
                    _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_0 =                   // dw/dx
                    _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_1 = 
                    _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_0 =                   // dw/dy
                    _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_1 = &ZeroReg.GetRegPtr()[0][0]; // 0.0f

                    _EnterQuadPixelLoop

                    _NewPSInst(RDPSINST_SAMPLE);
                    _InstParam(RDPSINST_SAMPLE).DstReg      = DstReg;
                    _InstParam(RDPSINST_SAMPLE).CoordReg    = CoordReg;
                    _InstParam(RDPSINST_SAMPLE).uiStage     = pInst->DstParam & D3DSP_REGNUM_MASK;

                    if( bDoLuminance )
                    {
                        _NewPSInst(RDPSINST_LUMINANCE);
                        _InstParam(RDPSINST_LUMINANCE).DstReg             = DstReg;
                        _InstParam(RDPSINST_LUMINANCE).SrcReg0            = DstReg;
                        _InstParam(RDPSINST_LUMINANCE).SrcReg1            = SrcReg[0];
                        _InstParam(RDPSINST_LUMINANCE).bSrcReg0_Negate    = FALSE;
                        _InstParam(RDPSINST_LUMINANCE).bSrcReg1_Negate    = FALSE;
                        _InstParam(RDPSINST_LUMINANCE).uiStage            = pInst->uiTSSNum;
                    }

                    _EmitDstMod(DstReg,DstWriteMask)
                }
                break;
            case D3DSIO_TEXDEPTH:
                _NewPSInst(RDPSINST_DEPTH);
                _InstParam(RDPSINST_DEPTH).DstReg   = DstReg;
                break;
            case D3DSIO_TEXM3x2PAD:
                {
                    RDPSRegister CoordReg;
                    CoordReg._Set(RDPSREG_SCRATCH,0);

                    // do dot product for first row of matrix multiply

                    // evaluate texture coordinate; projection disabled
                    _NewPSInst(RDPSINST_EVAL);
                    _InstParam(RDPSINST_EVAL).DstReg                    = CoordReg;
                    _InstParam(RDPSINST_EVAL).uiCoordSet                = pInst->DstParam & D3DSP_REGNUM_MASK;
                    _InstParam(RDPSINST_EVAL).bIgnoreD3DTTFF_PROJECTED  = TRUE; // no projection
                    _InstParam(RDPSINST_EVAL).bClamp                    = FALSE;
               
                    // do row of transform - tex coord * vector loaded from texture (on previous stage)
                    _NewPSInst(RDPSINST_DP3);
                    _InstParam(RDPSINST_DP3).DstReg._Set(DstReg.GetRegType(),DstReg.GetRegNum()+1);
                    _InstParam(RDPSINST_DP3).SrcReg0            = SrcReg[0];
                    _InstParam(RDPSINST_DP3).SrcReg1            = CoordReg;
                    _InstParam(RDPSINST_DP3).bSrcReg0_Negate    = FALSE;
                    _InstParam(RDPSINST_DP3).bSrcReg1_Negate    = FALSE;
                    _InstParam(RDPSINST_DP3).WriteMask          = RDPS_COMPONENTMASK_0;
                }
                break;
            case D3DSIO_TEXM3x3PAD:
                {
                    BOOL bSecondPad = (D3DSIO_TEXM3x3PAD != ((pInst + 1)->Opcode & D3DSI_OPCODE_MASK));
                    BOOL bInVSPECSequence = (D3DSIO_TEXM3x3VSPEC == (((pInst + (bSecondPad?1:2))->Opcode) & D3DSI_OPCODE_MASK));
                    RDPSRegister CoordReg, EyeReg;
                    CoordReg._Set(RDPSREG_SCRATCH,0);
                    EyeReg._Set(RDPSREG_SCRATCH,1);

                    // do dot product for first row of matrix multiply

                    // evaluate texture coordinate; projection disabled
                    _NewPSInst(RDPSINST_EVAL);
                    _InstParam(RDPSINST_EVAL).DstReg                    = CoordReg;
                    _InstParam(RDPSINST_EVAL).uiCoordSet                = pInst->DstParam & D3DSP_REGNUM_MASK;
                    _InstParam(RDPSINST_EVAL).bIgnoreD3DTTFF_PROJECTED  = TRUE; // no projection
                    _InstParam(RDPSINST_EVAL).bClamp                    = FALSE;
               
                    // do row of transform - tex coord * vector loaded from texture (on previous stage)
                    _NewPSInst(RDPSINST_DP3);
                    _InstParam(RDPSINST_DP3).DstReg._Set(DstReg.GetRegType(),DstReg.GetRegNum()+(bSecondPad?1:2));
                    _InstParam(RDPSINST_DP3).SrcReg0            = SrcReg[0];
                    _InstParam(RDPSINST_DP3).SrcReg1            = CoordReg;
                    _InstParam(RDPSINST_DP3).bSrcReg0_Negate    = FALSE;
                    _InstParam(RDPSINST_DP3).bSrcReg1_Negate    = FALSE;
                    _InstParam(RDPSINST_DP3).WriteMask          = bSecondPad?RDPS_COMPONENTMASK_1:RDPS_COMPONENTMASK_0;

                    if(bInVSPECSequence)
                    {
                        // eye vector encoded in 4th element of texture coordinates
                        _NewPSInst(RDPSINST_SWIZZLE);
                        _InstParam(RDPSINST_SWIZZLE).DstReg     = EyeReg;
                        _InstParam(RDPSINST_SWIZZLE).SrcReg0    = CoordReg;
                        _InstParam(RDPSINST_SWIZZLE).WriteMask  = bSecondPad?RDPS_COMPONENTMASK_1:RDPS_COMPONENTMASK_0;
                        _InstParam(RDPSINST_SWIZZLE).Swizzle    = RDPS_REPLICATEALPHA;
                    }
                }
                break;
            case D3DSIO_TEXM3x2TEX:
            case D3DSIO_TEXM3x3:
            case D3DSIO_TEXM3x3TEX:
            case D3DSIO_TEXM3x3SPEC:
            case D3DSIO_TEXM3x3VSPEC:
            case D3DSIO_TEXM3x2DEPTH:
                {
                    BOOL bIs3D = (D3DSIO_TEXM3x2TEX != Opcode) && (D3DSIO_TEXM3x2DEPTH != Opcode);
                    RDPSRegister CoordReg, EyeReg;
                    CoordReg._Set(RDPSREG_SCRATCH,0);
                    EyeReg._Set(RDPSREG_SCRATCH,1);

                    // do dot product for last row of matrix multiply

                    // evaluate texture coordinate; projection disabled
                    _NewPSInst(RDPSINST_EVAL);
                    _InstParam(RDPSINST_EVAL).DstReg                    = CoordReg;
                    _InstParam(RDPSINST_EVAL).uiCoordSet                = pInst->DstParam & D3DSP_REGNUM_MASK;
                    _InstParam(RDPSINST_EVAL).bIgnoreD3DTTFF_PROJECTED  = TRUE; // no projection
                    _InstParam(RDPSINST_EVAL).bClamp                    = FALSE;
               
                    // do row of transform - tex coord * vector loaded from texture (on previous stage)
                    _NewPSInst(RDPSINST_DP3);
                    _InstParam(RDPSINST_DP3).DstReg             = DstReg;
                    _InstParam(RDPSINST_DP3).SrcReg0            = SrcReg[0];
                    _InstParam(RDPSINST_DP3).SrcReg1            = CoordReg;
                    _InstParam(RDPSINST_DP3).bSrcReg0_Negate    = FALSE;
                    _InstParam(RDPSINST_DP3).bSrcReg1_Negate    = FALSE;
                    _InstParam(RDPSINST_DP3).WriteMask          = bIs3D ? RDPS_COMPONENTMASK_2 : RDPS_COMPONENTMASK_1;

                    if(D3DSIO_TEXM3x3VSPEC == Opcode)
                    {
                        // eye vector encoded in 4th element of texture coordinates
                        _NewPSInst(RDPSINST_SWIZZLE);
                        _InstParam(RDPSINST_SWIZZLE).DstReg     = EyeReg;
                        _InstParam(RDPSINST_SWIZZLE).SrcReg0    = CoordReg;
                        _InstParam(RDPSINST_SWIZZLE).WriteMask  = RDPS_COMPONENTMASK_2;
                        _InstParam(RDPSINST_SWIZZLE).Swizzle    = RDPS_REPLICATEALPHA;
                    }

                    // Now do stuff that depends on which TEXM3x* instruction this is...

                    if( D3DSIO_TEXM3x3 == Opcode )
                    {
                        _NewPSInst(RDPSINST_MOV);
                        _InstParam(RDPSINST_MOV).DstReg             = DstReg;
                        _InstParam(RDPSINST_MOV).SrcReg0            = OneReg; // 1.0f
                        _InstParam(RDPSINST_MOV).bSrcReg0_Negate    = FALSE;
                        _InstParam(RDPSINST_MOV).WriteMask          = RDPS_COMPONENTMASK_3;
                
                        _EmitDstMod(DstReg,DstWriteMask)
                    }
                    else if ( (D3DSIO_TEXM3x2TEX == Opcode) ||
                              (D3DSIO_TEXM3x3TEX == Opcode) )
                    {
                        // do straight lookup with transformed tex coords - this
                        // vector is not normalized, but normalization is not necessary
                        // for a cubemap lookup

                        // compute gradients for diffuse lookup
                        _LeaveQuadPixelLoop

                        PRGBAVEC pDstReg = DstReg.GetRegPtr();

                        _NewPSInst(RDPSINST_TEXCOVERAGE);
                        _InstParam(RDPSINST_TEXCOVERAGE).uiStage = pInst->DstParam & D3DSP_REGNUM_MASK;
                        _InstParam(RDPSINST_TEXCOVERAGE).pGradients = pRast->m_Gradients; // where to store gradients
                        // data from which to compute gradients.  i.e.: du/dx = DUDX_0 - DUDX_1
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_0 = &pDstReg[1][0]; // du/dx
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_1 = &pDstReg[0][0];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_0 = &pDstReg[2][0]; // du/dy
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_1 = &pDstReg[0][0];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_0 = &pDstReg[1][1]; // dv/dx
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_1 = &pDstReg[0][1];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_0 = &pDstReg[2][1]; // dv/dy
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_1 = &pDstReg[0][1];
                        if( bIs3D )
                        {
                            _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_0 = &pDstReg[1][2]; // dw/dx
                            _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_1 = &pDstReg[0][2];
                            _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_0 = &pDstReg[2][2]; // dw/dy
                            _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_1 = &pDstReg[0][2];
                        }
                        else
                        {
                            _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_0 =       // dw/dx
                            _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_1 = 
                            _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_0 =       // dw/dy
                            _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_1 = &ZeroReg.GetRegPtr()[0][0]; // 0.0f
                        }

                        _EnterQuadPixelLoop

                        // do lookup
                        if( !bIs3D )
                        {
                            _NewPSInst(RDPSINST_MOV);
                            _InstParam(RDPSINST_MOV).DstReg             = DstReg;
                            _InstParam(RDPSINST_MOV).SrcReg0            = ZeroReg; // 0.0f
                            _InstParam(RDPSINST_MOV).bSrcReg0_Negate    = FALSE;
                            _InstParam(RDPSINST_MOV).WriteMask          = RDPS_COMPONENTMASK_2;  
                        }

                        _NewPSInst(RDPSINST_SAMPLE);
                        _InstParam(RDPSINST_SAMPLE).DstReg      = DstReg;
                        _InstParam(RDPSINST_SAMPLE).CoordReg    = DstReg;
                        _InstParam(RDPSINST_SAMPLE).uiStage     = pInst->DstParam & D3DSP_REGNUM_MASK;

                        _EmitDstMod(DstReg,DstWriteMask)
                    }
                    else if ( Opcode == D3DSIO_TEXM3x2DEPTH )
                    {
                        // Take resulting u,v values and compute u/v, which
                        // can be interpreted is z/w = perspective correct depth.
                        // Then perturb the z coord for the pixel.
                        _NewPSInst(RDPSINST_DEPTH);
                        _InstParam(RDPSINST_DEPTH).DstReg   = DstReg;
                    }
                    else if ( (Opcode == D3DSIO_TEXM3x3SPEC) ||
                              (Opcode == D3DSIO_TEXM3x3VSPEC) )
                    {
                        RDPSRegister NdotE, NdotN, RCPNdotN, Scale, ReflReg;
                        NdotE._Set(RDPSREG_SCRATCH,2);
                        NdotN._Set(RDPSREG_SCRATCH,3);
                        RCPNdotN    = NdotN;    // reuse same register
                        Scale       = NdotE;    // reuse same register
                        ReflReg  = CoordReg; // reuse same register

                        // compute reflection vector and do lookup - the normal needs
                        // to be normalized here, which is included in this expression
                        if (D3DSIO_TEXM3x3SPEC == Opcode)
                        {
                            // eye vector is constant register
                            EyeReg = SrcReg[1];
                        } // else (TEXM3x3VSPEC) -> eye is what was copied out of the 4th component of 3 texcoords


                        // Compute reflection vector: 2(NdotE/NdotN) * N - E ...

                        // Calculate NdotE
                        _NewPSInst(RDPSINST_DP3);
                        _InstParam(RDPSINST_DP3).DstReg             = NdotE;
                        _InstParam(RDPSINST_DP3).SrcReg0            = DstReg; // N
                        _InstParam(RDPSINST_DP3).SrcReg1            = EyeReg; // E
                        _InstParam(RDPSINST_DP3).bSrcReg0_Negate    = FALSE;
                        _InstParam(RDPSINST_DP3).bSrcReg1_Negate    = FALSE;
                        _InstParam(RDPSINST_DP3).WriteMask          = RDPS_COMPONENTMASK_3;

                        // Calculate NdotN
                        _NewPSInst(RDPSINST_DP3);
                        _InstParam(RDPSINST_DP3).DstReg             = NdotN;
                        _InstParam(RDPSINST_DP3).SrcReg0            = DstReg; // N
                        _InstParam(RDPSINST_DP3).SrcReg1            = DstReg; // N
                        _InstParam(RDPSINST_DP3).bSrcReg0_Negate    = FALSE;
                        _InstParam(RDPSINST_DP3).bSrcReg1_Negate    = FALSE;
                        _InstParam(RDPSINST_DP3).WriteMask          = RDPS_COMPONENTMASK_3;

                        // Calculate scale = 2(NdotE/NdotN):

                        // a) Calculate reciprocal of NdotN
                        _NewPSInst(RDPSINST_RCP);
                        _InstParam(RDPSINST_RCP).DstReg             = RCPNdotN;
                        _InstParam(RDPSINST_RCP).SrcReg0            = NdotN;
                        _InstParam(RDPSINST_RCP).bSrcReg0_Negate    = FALSE;
                        _InstParam(RDPSINST_RCP).WriteMask          = RDPS_COMPONENTMASK_3;

                        // b) Multiply NdotE by reciprocal NdotN
                        _NewPSInst(RDPSINST_MUL);
                        _InstParam(RDPSINST_MUL).DstReg             = Scale;
                        _InstParam(RDPSINST_MUL).SrcReg0            = NdotE;
                        _InstParam(RDPSINST_MUL).SrcReg1            = RCPNdotN;
                        _InstParam(RDPSINST_MUL).bSrcReg0_Negate    = FALSE;
                        _InstParam(RDPSINST_MUL).bSrcReg1_Negate    = FALSE;
                        _InstParam(RDPSINST_MUL).WriteMask          = RDPS_COMPONENTMASK_3;

                        // c) Multiply by 2
                        _NewPSInst(RDPSINST_MUL);
                        _InstParam(RDPSINST_MUL).DstReg             = Scale;
                        _InstParam(RDPSINST_MUL).SrcReg0            = Scale;
                        _InstParam(RDPSINST_MUL).SrcReg1            = TwoReg; // 2.0f
                        _InstParam(RDPSINST_MUL).bSrcReg0_Negate    = FALSE;
                        _InstParam(RDPSINST_MUL).bSrcReg1_Negate    = FALSE;
                        _InstParam(RDPSINST_MUL).WriteMask          = RDPS_COMPONENTMASK_3;

                        // d) Replicate result to rgb
                        _NewPSInst(RDPSINST_SWIZZLE);
                        _InstParam(RDPSINST_SWIZZLE).DstReg     = Scale;
                        _InstParam(RDPSINST_SWIZZLE).SrcReg0    = Scale;
                        _InstParam(RDPSINST_SWIZZLE).WriteMask  = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 | RDPS_COMPONENTMASK_2;
                        _InstParam(RDPSINST_SWIZZLE).Swizzle    = RDPS_REPLICATEALPHA;

                        // Calculate reflection = scale * N - E

                        _NewPSInst(RDPSINST_MUL);
                        _InstParam(RDPSINST_MUL).DstReg             = ReflReg;
                        _InstParam(RDPSINST_MUL).SrcReg0            = Scale;  // scale *
                        _InstParam(RDPSINST_MUL).SrcReg1            = DstReg; // N
                        _InstParam(RDPSINST_MUL).bSrcReg0_Negate    = FALSE;
                        _InstParam(RDPSINST_MUL).bSrcReg1_Negate    = FALSE;
                        _InstParam(RDPSINST_MUL).WriteMask          = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 | RDPS_COMPONENTMASK_2;

                        _NewPSInst(RDPSINST_SUB);
                        _InstParam(RDPSINST_SUB).DstReg             = ReflReg;
                        _InstParam(RDPSINST_SUB).SrcReg0            = ReflReg; // (scale * N) - 
                        _InstParam(RDPSINST_SUB).SrcReg1            = EyeReg;  // E
                        _InstParam(RDPSINST_SUB).bSrcReg0_Negate    = FALSE;
                        _InstParam(RDPSINST_SUB).bSrcReg1_Negate    = FALSE;
                        _InstParam(RDPSINST_SUB).WriteMask          = RDPS_COMPONENTMASK_0 | RDPS_COMPONENTMASK_1 | RDPS_COMPONENTMASK_2;

                        // compute gradients for reflection lookup
                        _LeaveQuadPixelLoop

                        PRGBAVEC pReflReg = ReflReg.GetRegPtr();

                        _NewPSInst(RDPSINST_TEXCOVERAGE);
                        _InstParam(RDPSINST_TEXCOVERAGE).uiStage = pInst->DstParam & D3DSP_REGNUM_MASK;
                        _InstParam(RDPSINST_TEXCOVERAGE).pGradients = pRast->m_Gradients; // where to store gradients
                        // data from which to compute gradients.  i.e.: du/dx = DUDX_0 - DUDX_1
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_0 = &pReflReg[1][0]; // du/dx
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDX_1 = &pReflReg[0][0];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_0 = &pReflReg[2][0]; // du/dy
                        _InstParam(RDPSINST_TEXCOVERAGE).pDUDY_1 = &pReflReg[0][0];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_0 = &pReflReg[1][1]; // dv/dx
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDX_1 = &pReflReg[0][1];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_0 = &pReflReg[2][1]; // dv/dy
                        _InstParam(RDPSINST_TEXCOVERAGE).pDVDY_1 = &pReflReg[0][1];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_0 = &pReflReg[1][2]; // dw/dx
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDX_1 = &pReflReg[0][2];
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_0 = &pReflReg[2][2]; // dw/dy
                        _InstParam(RDPSINST_TEXCOVERAGE).pDWDY_1 = &pReflReg[0][2];

                        _EnterQuadPixelLoop

                        // do lookup
                        _NewPSInst(RDPSINST_SAMPLE);
                        _InstParam(RDPSINST_SAMPLE).DstReg      = DstReg;
                        _InstParam(RDPSINST_SAMPLE).CoordReg    = ReflReg;
                        _InstParam(RDPSINST_SAMPLE).uiStage     = pInst->DstParam & D3DSP_REGNUM_MASK;

                        _EmitDstMod(DstReg,DstWriteMask)
                    }
                }
                break;
            case D3DSIO_BEM:
                _NewPSInst(RDPSINST_BEM);
                _InstParam(RDPSINST_BEM).DstReg             = DstReg;
                _InstParam(RDPSINST_BEM).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_BEM).SrcReg1            = SrcReg[1];
                _InstParam(RDPSINST_BEM).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_BEM).bSrcReg1_Negate    = bSrcNegate[1];
                _InstParam(RDPSINST_BEM).WriteMask          = DstWriteMask;
                _InstParam(RDPSINST_BEM).uiStage            = pInst->DstParam & D3DSP_REGNUM_MASK;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_MOV:
                _NewPSInst(RDPSINST_MOV);
                _InstParam(RDPSINST_MOV).DstReg             = DstReg;
                _InstParam(RDPSINST_MOV).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_MOV).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_MOV).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_FRC:
                _NewPSInst(RDPSINST_FRC);
                _InstParam(RDPSINST_FRC).DstReg             = DstReg;
                _InstParam(RDPSINST_FRC).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_FRC).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_FRC).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_ADD:
                _NewPSInst(RDPSINST_ADD);
                _InstParam(RDPSINST_ADD).DstReg             = DstReg;
                _InstParam(RDPSINST_ADD).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_ADD).SrcReg1            = SrcReg[1];
                _InstParam(RDPSINST_ADD).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_ADD).bSrcReg1_Negate    = bSrcNegate[1];
                _InstParam(RDPSINST_ADD).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_SUB:
                _NewPSInst(RDPSINST_SUB);
                _InstParam(RDPSINST_SUB).DstReg             = DstReg;
                _InstParam(RDPSINST_SUB).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_SUB).SrcReg1            = SrcReg[1];
                _InstParam(RDPSINST_SUB).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_SUB).bSrcReg1_Negate    = bSrcNegate[1];
                _InstParam(RDPSINST_SUB).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_MUL:
                _NewPSInst(RDPSINST_MUL);
                _InstParam(RDPSINST_MUL).DstReg             = DstReg;
                _InstParam(RDPSINST_MUL).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_MUL).SrcReg1            = SrcReg[1];
                _InstParam(RDPSINST_MUL).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_MUL).bSrcReg1_Negate    = bSrcNegate[1];
                _InstParam(RDPSINST_MUL).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_DP3:
                _NewPSInst(RDPSINST_DP3);
                _InstParam(RDPSINST_DP3).DstReg             = DstReg;
                _InstParam(RDPSINST_DP3).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_DP3).SrcReg1            = SrcReg[1];
                _InstParam(RDPSINST_DP3).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_DP3).bSrcReg1_Negate    = bSrcNegate[1];
                _InstParam(RDPSINST_DP3).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_DP4:
                _NewPSInst(RDPSINST_DP4);
                _InstParam(RDPSINST_DP4).DstReg             = DstReg;
                _InstParam(RDPSINST_DP4).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_DP4).SrcReg1            = SrcReg[1];
                _InstParam(RDPSINST_DP4).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_DP4).bSrcReg1_Negate    = bSrcNegate[1];
                _InstParam(RDPSINST_DP4).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_MAD:
                _NewPSInst(RDPSINST_MAD);
                _InstParam(RDPSINST_MAD).DstReg             = DstReg;
                _InstParam(RDPSINST_MAD).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_MAD).SrcReg1            = SrcReg[1];
                _InstParam(RDPSINST_MAD).SrcReg2            = SrcReg[2];
                _InstParam(RDPSINST_MAD).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_MAD).bSrcReg1_Negate    = bSrcNegate[1];
                _InstParam(RDPSINST_MAD).bSrcReg2_Negate    = bSrcNegate[2];
                _InstParam(RDPSINST_MAD).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_LRP:
                _NewPSInst(RDPSINST_LRP);
                _InstParam(RDPSINST_LRP).DstReg             = DstReg;
                _InstParam(RDPSINST_LRP).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_LRP).SrcReg1            = SrcReg[1];
                _InstParam(RDPSINST_LRP).SrcReg2            = SrcReg[2];
                _InstParam(RDPSINST_LRP).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_LRP).bSrcReg1_Negate    = bSrcNegate[1];
                _InstParam(RDPSINST_LRP).bSrcReg2_Negate    = bSrcNegate[2];
                _InstParam(RDPSINST_LRP).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_CND:
                _NewPSInst(RDPSINST_CND);
                _InstParam(RDPSINST_CND).DstReg             = DstReg;
                _InstParam(RDPSINST_CND).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_CND).SrcReg1            = SrcReg[1];
                _InstParam(RDPSINST_CND).SrcReg2            = SrcReg[2];
                _InstParam(RDPSINST_CND).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_CND).bSrcReg1_Negate    = bSrcNegate[1];
                _InstParam(RDPSINST_CND).bSrcReg2_Negate    = bSrcNegate[2];
                _InstParam(RDPSINST_CND).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            case D3DSIO_CMP:
                _NewPSInst(RDPSINST_CMP);
                _InstParam(RDPSINST_CMP).DstReg             = DstReg;
                _InstParam(RDPSINST_CMP).SrcReg0            = SrcReg[0];
                _InstParam(RDPSINST_CMP).SrcReg1            = SrcReg[1];
                _InstParam(RDPSINST_CMP).SrcReg2            = SrcReg[2];
                _InstParam(RDPSINST_CMP).bSrcReg0_Negate    = bSrcNegate[0];
                _InstParam(RDPSINST_CMP).bSrcReg1_Negate    = bSrcNegate[1];
                _InstParam(RDPSINST_CMP).bSrcReg2_Negate    = bSrcNegate[2];
                _InstParam(RDPSINST_CMP).WriteMask          = DstWriteMask;
                _EmitDstMod(DstReg,DstWriteMask)
                break;
            default:
                break;
            }

            if( pInst->bFlushQueue )
            {
                _EnterQuadPixelLoop
                _NewPSInst(RDPSINST_FLUSHQUEUE);
                QueueIndex = -1;
            }

#if DBG
            _LeaveQuadPixelLoop
#endif
        }

        // Flush queue at end of shader if there is anything on it
        if( -1 != QueueIndex )
        {
            _EnterQuadPixelLoop
            _NewPSInst(RDPSINST_FLUSHQUEUE);
            QueueIndex = -1;
        }

        _LeaveQuadPixelLoop

        _NewPSInst(RDPSINST_END);

#if DBG
        if( pRast->m_bDebugPrintTranslatedPixelShaderTokens )
            RDPSDisAsm(pRDPSInstBuffer, m_pConstDefs, m_cConstDefs,pCaps->MaxPixelShaderValue, Version);
#endif
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\rast\rastattr.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// rastattr.cpp
//
// Direct3D Reference Device -
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
void RDAttribute::Init(
    RefRast* pRefRast, // RefRast with which this attrib is used
    UINT cDimensionality,
    BOOL bPerspective,
    BOOL bClamp )
{
    m_pRR = pRefRast;

    m_cDimensionality = cDimensionality;
    m_bPerspective = bPerspective;
    m_bClamp = bClamp;

    m_cProjection = 0;
    m_dwWrapFlags = 0x0;
    m_bFlatShade = FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
// Sampling Routines
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// Sample - Sample attribute at given location.
//
//-----------------------------------------------------------------------------
void RDAttribute::Sample(
    FLOAT*  pSample,
    FLOAT   fX,
    FLOAT   fY,
    BOOL    bNoProjectionOverride,  // disables projection if TRUE
    BOOL    bClampOverride)         // enables (forces) clamp if TRUE
{
    FLOAT fPScale = 1.0F;

    if (m_cProjection && !m_bFlatShade && !bNoProjectionOverride)
    {
        // note that perspective is already incorporated into projective coord
        fPScale = 1.0F/( fX*m_fA[m_cProjection] + fY*m_fB[m_cProjection] + m_fC[m_cProjection] );
    }
    else if (m_bPerspective && !m_bFlatShade)
    {
        fPScale = m_pRR->m_fW[m_pRR->m_iPix];
    }

    for ( UINT i=0; i<m_cDimensionality; i++)
    {
        if (m_bFlatShade)
        {
            *(pSample+i) = m_fC[i];
        }
        else
        {
            *(pSample+i) =
                fPScale * ( fX*m_fA[i] + fY*m_fB[i] + m_fC[i] );
        }

        if (m_bClamp || bClampOverride)
        {
            *(pSample+i) = MIN( 1.F, MAX( 0.F, *(pSample+i) ) );
        }
    }
}

//-----------------------------------------------------------------------------
//
// Sample - Sample scalar attribute at given location.  Assumes no perspective
// or projection.  (Used for W or Depth.)
//
//-----------------------------------------------------------------------------
FLOAT RDAttribute::Sample(
    FLOAT   fX,
    FLOAT   fY)
{
    return fX*m_fA[0] + fY*m_fB[0] + m_fC[0];
}

///////////////////////////////////////////////////////////////////////////////
//
// Setup Routines
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// WrapDiff - returns the difference (B-A) as defined under the D3D WRAPU/V
// rules which is the shortest path between the two assuming a coincident
// position at 1. and 0.  The fA and fB input range is 0. to 1.
//
//-----------------------------------------------------------------------------
static FLOAT
WrapDiff( FLOAT fB, FLOAT fA )
{
    // compute straight distance
    FLOAT fDist1 = fB - fA;
    // compute distance 'warping' between 0. and 1.
    FLOAT fDist2 = ( fDist1 < 0 ) ? ( fDist1+1 ) : ( fDist1-1 );

    // return minimum of these
    return ( fabs( fDist1) < fabs( fDist2) ) ? ( fDist1) : ( fDist2 );
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------

void RDAttribute::Setup(
    const FLOAT* pVtx0, const FLOAT* pVtx1, const FLOAT* pVtx2)
{
    if (m_pRR->m_bIsLine)
    {
        LineSetup( pVtx0, pVtx1, pVtx2 );
        return;
    }

    for ( UINT i=0; i<m_cDimensionality; i++)
    {
        FLOAT fVal0 = (pVtx0) ? (*(pVtx0+i)) : (0.);
        FLOAT fVal1 = (pVtx1) ? (*(pVtx1+i)) : (0.);
        FLOAT fVal2 = (pVtx2) ? (*(pVtx2+i)) : (0.);

        if (m_bFlatShade)
        {
            m_fA[i] = m_fB[i] = 0.F;
            switch ( m_pRR->m_iFlatVtx )
            {
            default:
            case 0: m_fC[i] = fVal0; break;
            case 1: m_fC[i] = fVal1; break;
            case 2: m_fC[i] = fVal2; break;
            }
            continue;
        }

        // extract wrap flag for this dimension
        BOOL bWrap = m_dwWrapFlags & (1<<i);

        // compute adjusted values for vertices 1,2 based on wrap flag
        FLOAT fVal1P = bWrap ? ( fVal0 + WrapDiff(fVal1,fVal0) ) : (fVal1);
        FLOAT fVal2P = bWrap ? ( fVal0 + WrapDiff(fVal2,fVal0) ) : (fVal2);

        // compute (maybe) perspective corrected linear deltas along two edges
        FLOAT fRHW0 = (m_bPerspective) ? (m_pRR->m_fRHW0) : (1.0F);
        FLOAT fRHW1 = (m_bPerspective) ? (m_pRR->m_fRHW1) : (1.0F);
        FLOAT fRHW2 = (m_bPerspective) ? (m_pRR->m_fRHW2) : (1.0F);

        FLOAT fDelAttrib10 = ( fVal1P * fRHW1 ) - ( fVal0 * fRHW0 );
        FLOAT fDelAttrib20 = ( fVal2P * fRHW2 ) - ( fVal0 * fRHW0 );

        // compute A & B terms (dVdX and dVdY)
        m_fA[i] = m_pRR->m_fTriOODet *
            ( fDelAttrib10 * m_pRR->m_fDelY20 + fDelAttrib20 * m_pRR->m_fDelY01 );
        m_fB[i] = m_pRR->m_fTriOODet *
            ( fDelAttrib20 * m_pRR->m_fDelX10 + fDelAttrib10 * m_pRR->m_fDelX02 );

        // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
        m_fC[i] = ( fVal0 * fRHW0 )
            - ( m_fA[i] * m_pRR->m_fX0 ) - ( m_fB[i] * m_pRR->m_fY0 );
    }
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
void RDAttribute::LineSetup(
    const FLOAT* pVtx0, const FLOAT* pVtx1, const FLOAT* pVtxFlat)
{
    for ( UINT i=0; i<m_cDimensionality; i++)
    {
        FLOAT fVal0 = (pVtx0) ? (*(pVtx0+i)) : (0.);
        FLOAT fVal1 = (pVtx1) ? (*(pVtx1+i)) : (0.);

        if (m_bFlatShade)
        {
            m_fA[i] = m_fB[i] = 0.F;
            m_fC[i] = (pVtxFlat) ? (*(pVtxFlat+i)) : fVal0;
            continue;
        }

        // extract wrap flag for this dimension
        BOOL bWrap = m_dwWrapFlags & (1<<i);

        // compute adjusted values for vertices 1,2 based on wrap flag
        FLOAT fVal1P = bWrap ? ( fVal0 + WrapDiff(fVal1,fVal0) ) : (fVal1);

        // compute (maybe) perspective corrected linear deltas along two edges
        FLOAT fRHW0 = (m_bPerspective) ? (m_pRR->m_fRHW0) : (1.0F);
        FLOAT fRHW1 = (m_bPerspective) ? (m_pRR->m_fRHW1) : (1.0F);

        FLOAT fDelta = ( fVal1P*fRHW1 - fVal0*fRHW0) / m_pRR->m_fLineMajorLength;
        m_fA[i] = ( m_pRR->m_bLineXMajor ) ? ( fDelta ) : ( 0. );
        m_fB[i] = ( m_pRR->m_bLineXMajor ) ? ( 0. ) : ( fDelta );
        // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
        m_fC[i] = ( fVal0* fRHW0)
            - ( m_fA[i] * m_pRR->m_fX0 ) - ( m_fB[i] * m_pRR->m_fY0 );
    }
}

//-----------------------------------------------------------------------------
//
// Setup attribute given packed DWORD color.  Color format is that of the
// colors in the FVF vertex, which corresponds to D3DFMT_A8R8G8B8 (and is
// the same as D3DCOLOR).
//
//-----------------------------------------------------------------------------
void RDAttribute::Setup(
    DWORD dwVtx0, DWORD dwVtx1, DWORD dwVtx2)
{
    FLOAT fVtx0[4];
    FLOAT fVtx1[4];
    FLOAT fVtx2[4];

    fVtx0[0] = RGBA_GETRED(   dwVtx0 ) * (1./255.);
    fVtx0[1] = RGBA_GETGREEN( dwVtx0 ) * (1./255.);
    fVtx0[2] = RGBA_GETBLUE(  dwVtx0 ) * (1./255.);
    fVtx0[3] = RGBA_GETALPHA( dwVtx0 ) * (1./255.);
    fVtx1[0] = RGBA_GETRED(   dwVtx1 ) * (1./255.);
    fVtx1[1] = RGBA_GETGREEN( dwVtx1 ) * (1./255.);
    fVtx1[2] = RGBA_GETBLUE(  dwVtx1 ) * (1./255.);
    fVtx1[3] = RGBA_GETALPHA( dwVtx1 ) * (1./255.);
    fVtx2[0] = RGBA_GETRED(   dwVtx2 ) * (1./255.);
    fVtx2[1] = RGBA_GETGREEN( dwVtx2 ) * (1./255.);
    fVtx2[2] = RGBA_GETBLUE(  dwVtx2 ) * (1./255.);
    fVtx2[3] = RGBA_GETALPHA( dwVtx2 ) * (1./255.);

    Setup( fVtx0, fVtx1, fVtx2);
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\rast\psexec.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// psexec.cpp
//
// Direct3D Reference Device - Pixel Shader Execution
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// ExecShader - Executes the current pixel shader.
//
//-----------------------------------------------------------------------------
void
RefRast::ExecShader( void )
{
    #define _InstParam(__INST)         (*(__INST##_PARAMS UNALIGNED64*)pRDPSInstBuffer)
    #define _StepOverInst(__INST)       pRDPSInstBuffer += sizeof(__INST##_PARAMS);
    #define _DeclArgs(__INST)           __INST##_PARAMS& Args = _InstParam(__INST);

    #define _PerChannel(__STATEMENT)                                \
                for( iChn=0; iChn<4; iChn++ )                       \
                {                                                   \
                    __STATEMENT                                     \
                }                                                   \

    #define _PerChannelMasked(__STATEMENT)                         \
                for( iChn=0; iChn<4; iChn++ )                       \
                {                                                   \
                    if( !(Args.WriteMask & ComponentMask[iChn] ) )  \
                        continue;                                   \
                    __STATEMENT                                     \
                }                                                   \

    #define _Dst            Args.DstReg.GetRegPtr()[m_iPix][iChn]
    #define _DstC(__chn)    Args.DstReg.GetRegPtr()[m_iPix][__chn]

    #define _Src0           Args.SrcReg0.GetRegPtr()[m_iPix][iChn]
    #define _Src1           Args.SrcReg1.GetRegPtr()[m_iPix][iChn]
    #define _Src2           Args.SrcReg2.GetRegPtr()[m_iPix][iChn]
    #define _Src0C(__chn)   Args.SrcReg0.GetRegPtr()[m_iPix][__chn]
    #define _Src1C(__chn)   Args.SrcReg1.GetRegPtr()[m_iPix][__chn]
    #define _Src2C(__chn)   Args.SrcReg2.GetRegPtr()[m_iPix][__chn]

    #define _Src0N          (Args.bSrcReg0_Negate?(-_Src0):_Src0)
    #define _Src1N          (Args.bSrcReg1_Negate?(-_Src1):_Src1)
    #define _Src2N          (Args.bSrcReg2_Negate?(-_Src2):_Src2)
    #define _Src0NC(__chn)  (Args.bSrcReg0_Negate?(-_Src0C(__chn)):_Src0C(__chn))
    #define _Src1NC(__chn)  (Args.bSrcReg1_Negate?(-_Src1C(__chn)):_Src1C(__chn))
    #define _Src2NC(__chn)  (Args.bSrcReg2_Negate?(-_Src2C(__chn)):_Src2C(__chn))

    BYTE ComponentMask[4] = {RDPS_COMPONENTMASK_0, RDPS_COMPONENTMASK_1, RDPS_COMPONENTMASK_2, RDPS_COMPONENTMASK_3};
    BYTE* pRDPSInstBuffer = &m_pCurrentPixelShader->m_RDPSInstBuffer[0]; // Buffer of "RISC" RDPS_* instructions to execute.
    int   QueueIndex[4] = {-1,-1,-1,-1}; // For simulating co-issue sequentially ("parallel" writes staged in queue)
    int   iChn; // For macros

#if DBG
    PixelShaderInstruction* pCurrD3DPSInst = NULL;              // Current true D3DSIO_ instruction being simulated.
#endif

    m_bPixelDiscard[0] = m_bPixelDiscard[1] = m_bPixelDiscard[2] = m_bPixelDiscard[3] = FALSE;
  
    while(RDPSINST_END != _InstParam(RDPSINST_BASE).Inst)
    {
        switch(_InstParam(RDPSINST_BASE).Inst)
        {
        case RDPSINST_EVAL:
            {
                _DeclArgs(RDPSINST_EVAL)
                m_Attr[RDATTR_TEXTURE0+Args.uiCoordSet].Sample( Args.DstReg.GetRegPtr()[m_iPix],
                                                                (FLOAT)m_iX[m_iPix], (FLOAT)m_iY[m_iPix], 
                                                                Args.bIgnoreD3DTTFF_PROJECTED, Args.bClamp );
            }
            _StepOverInst(RDPSINST_EVAL)
            break;
        case RDPSINST_SAMPLE:
            {
                _DeclArgs(RDPSINST_SAMPLE)
                ComputeTextureFilter( Args.uiStage, Args.CoordReg.GetRegPtr()[m_iPix] );
                SampleTexture( Args.uiStage, Args.DstReg.GetRegPtr()[m_iPix] );
            }
            _StepOverInst(RDPSINST_SAMPLE)
            break;
        case RDPSINST_KILL:
            {
                _DeclArgs(RDPSINST_KILL)
                DWORD TexKillFlags = 0x0;   // TODO: get these from TSS or per-instruction
                _PerChannel(
                    // compare against zero according to kill flags
                    if ( TexKillFlags & (1<<iChn) )
                    {
                        if ( _Dst >= 0. )
                            m_bPixelDiscard[m_iPix] |= 0x1;
                    }
                    else
                    {
                        if ( _Dst < 0. )
                            m_bPixelDiscard[m_iPix] |= 0x1;
                    }
                )

            }
            _StepOverInst(RDPSINST_KILL)
            break;
        case RDPSINST_BEM:
            {
                _DeclArgs(RDPSINST_BEM)

                RDTextureStageState*  pTSS = &m_pRD->m_TextureStageState[Args.uiStage];
                // Just assuming Args.WriteMask is .rg

                _DstC(0) = _Src0NC(0) + 
                    pTSS->m_fVal[D3DTSS_BUMPENVMAT00] * _Src1NC(0) +
                    pTSS->m_fVal[D3DTSS_BUMPENVMAT10] * _Src1NC(1);
                _DstC(1) = _Src0NC(1) + 
                    pTSS->m_fVal[D3DTSS_BUMPENVMAT01] * _Src1NC(0) +
                    pTSS->m_fVal[D3DTSS_BUMPENVMAT11] * _Src1NC(1);
            }
            _StepOverInst(RDPSINST_BEM)
            break;
        case RDPSINST_LUMINANCE:
            {
                _DeclArgs(RDPSINST_LUMINANCE)
                RDTextureStageState*  pTSS = &m_pRD->m_TextureStageState[Args.uiStage];

                FLOAT fLum = _Src1NC(2) * 
                             pTSS->m_fVal[D3DTSS_BUMPENVLSCALE] +
                             pTSS->m_fVal[D3DTSS_BUMPENVLOFFSET];

                fLum = min(max(fLum, 0.0f), 1.0F);

                // apply luminance modulation to RGB only
                _DstC(0) = _Src0C(0)*fLum;
                _DstC(1) = _Src0C(1)*fLum;
                _DstC(2) = _Src0C(2)*fLum;
            }
            _StepOverInst(RDPSINST_LUMINANCE)
            break;
        case RDPSINST_DEPTH:
            {
                _DeclArgs(RDPSINST_DEPTH)

                FLOAT result;

                FLOAT* pDstReg = Args.DstReg.GetRegPtr()[m_iPix];
                if( pDstReg[1] )
                    result = pDstReg[0] / pDstReg[1];
                else
                    result = 1.0f;

                // clamp
                m_Depth[m_iPix] = MAX(0, MIN(1, result));

                // snap off extra bits by converting to/from buffer format - necessary
                // to make depth buffer equality tests function correctly
                SnapDepth();

                do
                {
                    m_SampleDepth[m_CurrentSample][m_iPix] = m_Depth[m_iPix];
                }
                while (NextSample());
            }
            _StepOverInst(RDPSINST_DEPTH)
            break;
        case RDPSINST_SRCMOD:
            {
                _DeclArgs(RDPSINST_SRCMOD)
                _PerChannelMasked(

                    if( Args.bComplement )
                        _Dst = 1 - _Src0;
                    else if( Args.bBias && Args.bTimes2 )
                        _Dst = 2*(_Src0 - 0.5);
                    else if( Args.bBias )
                        _Dst = _Src0 - 0.5f;
                    else if( Args.bTimes2 )
                        _Dst = 2*_Src0;
                    else
                        _Dst = _Src0;

                    _Dst = MAX( _Dst, Args.fRangeMin );
                    _Dst = MIN( _Dst, Args.fRangeMax );
                )
            }
            _StepOverInst(RDPSINST_SRCMOD)
            break;
        case RDPSINST_SWIZZLE:
            {
                _DeclArgs(RDPSINST_SWIZZLE)
                BYTE Swizzle = Args.Swizzle;
                _PerChannelMasked(
                    _Dst = _Src0C(Swizzle&0x3);
                    Swizzle >>= 2;
                )
            }
            _StepOverInst(RDPSINST_SWIZZLE)
            break;
        case RDPSINST_DSTMOD:
            {
                _DeclArgs(RDPSINST_DSTMOD)

                _PerChannelMasked(
                    _Dst *= Args.fScale;
                    // clamp to range
                    _Dst = MAX( _Dst, Args.fRangeMin );
                    _Dst = MIN( _Dst, Args.fRangeMax );
                )
            }
            _StepOverInst(RDPSINST_DSTMOD)
            break;
        case RDPSINST_MOV:
            {
                _DeclArgs(RDPSINST_MOV)
                _PerChannelMasked(_Dst = _Src0N;)
            }
            _StepOverInst(RDPSINST_MOV)
            break;
        case RDPSINST_RCP:
            {
                _DeclArgs(RDPSINST_RCP)
                _PerChannelMasked(_Dst = _Src0N ? 1/_Src0N : 1.0f;)
            }
            _StepOverInst(RDPSINST_RCP)
            break;
        case RDPSINST_FRC:
            {
                _DeclArgs(RDPSINST_FRC)
                _PerChannelMasked(_Dst = _Src0N - (float)floor(_Src0N);)
            }
            _StepOverInst(RDPSINST_FRC)
            break;
        case RDPSINST_ADD:
            {
                _DeclArgs(RDPSINST_ADD)
                _PerChannelMasked(_Dst = _Src0N + _Src1N;)
            }
            _StepOverInst(RDPSINST_ADD)
            break;
        case RDPSINST_SUB:
            {
                _DeclArgs(RDPSINST_SUB)
                _PerChannelMasked(_Dst = _Src0N - _Src1N;)
            }
            _StepOverInst(RDPSINST_SUB)
            break;
        case RDPSINST_MUL:
            {
                _DeclArgs(RDPSINST_MUL)
                _PerChannelMasked(_Dst = _Src0N * _Src1N;);
            }
            _StepOverInst(RDPSINST_MUL)
            break;
        case RDPSINST_DP3:
            {
                _DeclArgs(RDPSINST_DP3)
                FLOAT dp3 = _Src0NC(0) * _Src1NC(0) +
                            _Src0NC(1) * _Src1NC(1) +
                            _Src0NC(2) * _Src1NC(2);
                _PerChannelMasked(_Dst = dp3;)
            }
            _StepOverInst(RDPSINST_DP3)
            break;
        case RDPSINST_DP4:
            {
                _DeclArgs(RDPSINST_DP4)
                FLOAT dp4 = _Src0NC(0) * _Src1NC(0) +
                            _Src0NC(1) * _Src1NC(1) +
                            _Src0NC(2) * _Src1NC(2) +
                            _Src0NC(3) * _Src1NC(3);
                _PerChannelMasked(_Dst = dp4;)
            }
            _StepOverInst(RDPSINST_DP4)
            break;
        case RDPSINST_MAD:
            {
                _DeclArgs(RDPSINST_MAD)
                _PerChannelMasked(_Dst = _Src0N * _Src1N + _Src2N;)
            }
            _StepOverInst(RDPSINST_MAD)
            break;
        case RDPSINST_LRP:
            {
                _DeclArgs(RDPSINST_LRP)
                _PerChannelMasked(_Dst = (_Src0N*(_Src1N - _Src2N)) + _Src2N;)
            }
            _StepOverInst(RDPSINST_LRP)
            break;
        case RDPSINST_CND:
            {
                _DeclArgs(RDPSINST_CND)
                _PerChannelMasked(_Dst = _Src0N > 0.5f ? _Src1N : _Src2N;)
            }
            _StepOverInst(RDPSINST_CND)
            break;
        case RDPSINST_CMP:
            {
                _DeclArgs(RDPSINST_CMP)
                _PerChannelMasked(_Dst = _Src0N >= 0.f ? _Src1N : _Src2N;)
            }
            _StepOverInst(RDPSINST_CMP)
            break;
        case RDPSINST_TEXCOVERAGE:
            {   
                _DeclArgs(RDPSINST_TEXCOVERAGE);
                Args.pGradients[0][0] = *Args.pDUDX_0 - *Args.pDUDX_1; // du/dx
                Args.pGradients[0][1] = *Args.pDUDY_0 - *Args.pDUDY_1; // du/dy
                Args.pGradients[1][0] = *Args.pDVDX_0 - *Args.pDVDX_1; // dv/dx
                Args.pGradients[1][1] = *Args.pDVDY_0 - *Args.pDVDY_1; // dv/dy
                Args.pGradients[2][0] = *Args.pDWDX_0 - *Args.pDWDX_1; // dw/dx
                Args.pGradients[2][1] = *Args.pDWDY_0 - *Args.pDWDY_1; // dw/dy
                ComputeTextureCoverage( Args.uiStage, Args.pGradients );
            }
            _StepOverInst(RDPSINST_TEXCOVERAGE)
            break;
        case RDPSINST_QUADLOOPBEGIN:
            m_iPix = 0;
            _StepOverInst(RDPSINST_QUADLOOPBEGIN)
            break;
        case RDPSINST_QUADLOOPEND:
            {
                _DeclArgs(RDPSINST_QUADLOOPEND);
                if( 4 > ++m_iPix ) 
                    pRDPSInstBuffer -= Args.JumpBackByOffset;
                else
                    _StepOverInst(RDPSINST_QUADLOOPEND)
            }
            break;
        case RDPSINST_QUEUEWRITE:
            {
                _DeclArgs(RDPSINST_QUEUEWRITE);
                QueueIndex[m_iPix]++;
                m_QueuedWriteDst[QueueIndex[m_iPix]].DstReg    = Args.DstReg;
                m_QueuedWriteDst[QueueIndex[m_iPix]].WriteMask = Args.WriteMask;
            }
            _StepOverInst(RDPSINST_QUEUEWRITE)
            break;
        case RDPSINST_FLUSHQUEUE:
            {
                _ASSERT(QueueIndex[m_iPix] >= 0, "Nothing in pixelshader write queue to flush.  Refrast mistranslated this pixelshader." );
                _ASSERT(QueueIndex[m_iPix] < RDPS_MAX_NUMQUEUEDWRITEREG, "Pixelshader write queue overflow.  Refrast mistranslated this pixelshader." );
                for( int i = 0; i <= QueueIndex[m_iPix]; i++ )
                {
                    _PerChannel(
                        if (m_QueuedWriteDst[i].WriteMask & ComponentMask[iChn])
                            m_QueuedWriteDst[i].DstReg.GetRegPtr()[m_iPix][iChn] = m_QueuedWriteReg[i][m_iPix][iChn];
                    )
                }
                QueueIndex[m_iPix] = -1;
            }
            _StepOverInst(RDPSINST_FLUSHQUEUE)
            break;
        case RDPSINST_NEXTD3DPSINST:
#if DBG
            pCurrD3DPSInst = _InstParam(RDPSINST_NEXTD3DPSINST).pInst; // Handy to look at when debugging.
#endif
            _StepOverInst(RDPSINST_NEXTD3DPSINST)
            break;
        default:
            _ASSERT(FALSE,"Refrast::ExecShader() - Unrecognized micro-instruction!");
            break;
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\rast\psutil.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// psutil.cpp
//
// Direct3D Reference Device - Pixel Shader Utilities
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

#if DBG
#define _ADDSTR( _Str )             {_snprintf( pStr, 256, "%s" _Str , pStr );}
#define _ADDSTRP( _Str, _Param )    {_snprintf( pStr, 256, "%s" _Str , pStr, _Param );}

//-----------------------------------------------------------------------------
//
// PixelShaderInstDisAsm - Generates instruction disassembly string for a single
// pixel shader instruction.  String interface is similar to _snprintf.
//
//-----------------------------------------------------------------------------
int
PixelShaderInstDisAsm(
    char* pStrRet, int StrSizeRet, DWORD* pShader, DWORD Flags )
{
    UINT    i,j;
    DWORD*  pToken = pShader;
    
    // stage in local string, then copy
    char pStr[256] = "";

    DWORD Inst = *pToken++;

    if( Inst & D3DSI_COISSUE )
    {
        _ADDSTR("+");
    }

    DWORD Opcode = (Inst & D3DSI_OPCODE_MASK);
    DWORD DstParam = 0;
    DWORD SrcParam[3];
    DWORD SrcParamCount = 0;

    if (*pToken & (1L<<31))
    {
        DstParam = *pToken++;
        while (*pToken & (1L<<31))
        {
            SrcParam[SrcParamCount] = *pToken++;
            SrcParamCount++;
        }
    }

    switch (Opcode)
    {
    case D3DSIO_PHASE: _ADDSTR("phase"); break;
    case D3DSIO_NOP: _ADDSTR("nop"); break;
    case D3DSIO_MOV: _ADDSTR("mov"); break;
    case D3DSIO_ADD: _ADDSTR("add"); break;
    case D3DSIO_SUB: _ADDSTR("sub"); break;
    case D3DSIO_MUL: _ADDSTR("mul"); break;
    case D3DSIO_MAD: _ADDSTR("mad"); break;
    case D3DSIO_LRP: _ADDSTR("lrp"); break;
    case D3DSIO_CND: _ADDSTR("cnd"); break;
    case D3DSIO_DP3: _ADDSTR("dp3"); break;
    case D3DSIO_DEF: _ADDSTR("def"); break;
    case D3DSIO_DP4: _ADDSTR("dp4"); break;
    case D3DSIO_CMP: _ADDSTR("cmp"); break;
    case D3DSIO_FRC: _ADDSTR("frc"); break;
    case D3DSIO_BEM: _ADDSTR("bem"); break;

    case D3DSIO_TEXCOORD    : if(SrcParamCount)
                                  _ADDSTR("texcrd")
                              else 
                                  _ADDSTR("texcoord"); 
                              break;
    case D3DSIO_TEX         : if(SrcParamCount)
                                  _ADDSTR("texld")
                              else
                                  _ADDSTR("tex"); 
                              break;
    case D3DSIO_TEXKILL     : _ADDSTR("texkill"); break;
    case D3DSIO_TEXBEM_LEGACY:
    case D3DSIO_TEXBEM      : _ADDSTR("texbem"); break;
    case D3DSIO_TEXBEML_LEGACY:
    case D3DSIO_TEXBEML     : _ADDSTR("texbeml"); break;
    case D3DSIO_TEXREG2AR   : _ADDSTR("texreg2ar"); break;
    case D3DSIO_TEXREG2GB   : _ADDSTR("texreg2gb"); break;
    case D3DSIO_TEXM3x2PAD  : _ADDSTR("texm3x2pad"); break;
    case D3DSIO_TEXM3x2TEX  : _ADDSTR("texm3x2tex"); break;
    case D3DSIO_TEXM3x3PAD  : _ADDSTR("texm3x3pad"); break;
    case D3DSIO_TEXM3x3TEX  : _ADDSTR("texm3x3tex"); break;
    case D3DSIO_TEXM3x3SPEC : _ADDSTR("texm3x3spec"); break;
    case D3DSIO_TEXM3x3VSPEC: _ADDSTR("texm3x3vspec"); break;
    case D3DSIO_TEXM3x2DEPTH : _ADDSTR("texm3x2depth"); break;
    case D3DSIO_TEXDP3      : _ADDSTR("texdp3"); break;
    case D3DSIO_TEXREG2RGB  : _ADDSTR("texreg2rgb"); break;
    case D3DSIO_TEXDEPTH    : _ADDSTR("texdepth"); break;
    case D3DSIO_TEXDP3TEX   : _ADDSTR("texdp3tex"); break;
    case D3DSIO_TEXM3x3     : _ADDSTR("texm3x3"); break;
    case D3DSIO_END         : _ADDSTR("END"); break;
    default:
        _ASSERT(FALSE,"Attempt to disassemble unknown instruction!");
    }

    if (DstParam)
    {
        switch ( (DstParam & D3DSP_DSTSHIFT_MASK) >> D3DSP_DSTSHIFT_SHIFT )
        {
        default:
        case 0x0: break;
        case 0x1: _ADDSTR("_x2"); break;
        case 0x2: _ADDSTR("_x4"); break;
        case 0x3: _ADDSTR("_x8"); break;
        case 0xF: _ADDSTR("_d2"); break;
        case 0xE: _ADDSTR("_d4"); break;
        case 0xD: _ADDSTR("_d8"); break;
        }
        switch (DstParam & D3DSP_DSTMOD_MASK)
        {
        default:
        case D3DSPDM_NONE:      break;
        case D3DSPDM_SATURATE:  _ADDSTR("_sat"); break;
        }

        switch (DstParam & D3DSP_REGTYPE_MASK)
        {
        default:
        case D3DSPR_TEMP:    _ADDSTRP(" r%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_TEXTURE: _ADDSTRP(" t%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_CONST:   _ADDSTRP(" c%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        }
        if (D3DSP_WRITEMASK_ALL != (DstParam & D3DSP_WRITEMASK_ALL))
        {
            _ADDSTR(".");
            if (DstParam & D3DSP_WRITEMASK_0) _ADDSTR("r");
            if (DstParam & D3DSP_WRITEMASK_1) _ADDSTR("g");
            if (DstParam & D3DSP_WRITEMASK_2) _ADDSTR("b");
            if (DstParam & D3DSP_WRITEMASK_3) _ADDSTR("a");
        }

        if( D3DSIO_DEF == Opcode )
        {
            for( i = 0; i < 4; i++ )
                _ADDSTRP(", %f", (float)(*pToken++) );
            goto EXIT;
        }
    }

    for( i = 0; i < SrcParamCount; i++ )
    {
        _ADDSTR(",");

        switch (SrcParam[i] & D3DSP_SRCMOD_MASK)
        {
        default:
        case D3DSPSM_NONE:    _ADDSTR(" "); break;
        case D3DSPSM_NEG:     _ADDSTR(" -"); break;
        case D3DSPSM_BIAS:    _ADDSTR(" "); break;
        case D3DSPSM_BIASNEG: _ADDSTR(" -"); break;
        case D3DSPSM_SIGN:    _ADDSTR(" "); break;
        case D3DSPSM_SIGNNEG: _ADDSTR(" -"); break;
        case D3DSPSM_COMP:    _ADDSTR(" 1-"); break;
        case D3DSPSM_X2:      _ADDSTR(" "); break;
        case D3DSPSM_X2NEG:   _ADDSTR(" -"); break;
        }
        switch (SrcParam[i] & D3DSP_REGTYPE_MASK)
        {
        case D3DSPR_TEMP:    _ADDSTRP("r%d", (SrcParam[i] & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_INPUT:   _ADDSTRP("v%d", (SrcParam[i] & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_CONST:   _ADDSTRP("c%d", (SrcParam[i] & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_TEXTURE: _ADDSTRP("t%d", (SrcParam[i] & D3DSP_REGNUM_MASK) ); break;
        }
        switch (SrcParam[i] & D3DSP_SRCMOD_MASK)
        {
        default:
        case D3DSPSM_NONE:    break;
        case D3DSPSM_NEG:     break;
        case D3DSPSM_BIAS:    _ADDSTR("_bias"); break;
        case D3DSPSM_BIASNEG: _ADDSTR("_bias"); break;
        case D3DSPSM_SIGN:    _ADDSTR("_bx2"); break;
        case D3DSPSM_SIGNNEG: _ADDSTR("_bx2"); break;
        case D3DSPSM_COMP:    break;
        case D3DSPSM_X2:      _ADDSTR("_x2"); break;
        case D3DSPSM_X2NEG:   _ADDSTR("_x2"); break;
        case D3DSPSM_DZ:      _ADDSTR("_db"); break;
        case D3DSPSM_DW:      _ADDSTR("_da"); break;
        }
        switch (SrcParam[i] & D3DVS_SWIZZLE_MASK)
        {
        case D3DSP_NOSWIZZLE:       break;
        case D3DSP_REPLICATEALPHA:  _ADDSTR(".a"); break;
        case D3DSP_REPLICATERED:    _ADDSTR(".r"); break;
        case D3DSP_REPLICATEGREEN:  _ADDSTR(".g"); break;
        case D3DSP_REPLICATEBLUE:   _ADDSTR(".b"); break;
        default:
            _ADDSTR(".");
            for(j = 0; j < 4; j++)
            {
                switch(((SrcParam[i] & D3DVS_SWIZZLE_MASK) >> (D3DVS_SWIZZLE_SHIFT + 2*j)) & 0x3)
                {
                case 0:
                    _ADDSTR("r");
                    break;
                case 1:
                    _ADDSTR("g");
                    break;
                case 2:
                    _ADDSTR("b");
                    break;
                case 3:
                    _ADDSTR("a");
                    break;
                }
            }
            break;
        }
    }
EXIT:
    return _snprintf( pStrRet, StrSizeRet, "%s", pStr );
}

int
RDPSInstSrcDisAsm(
    char* pStrRet, int StrSizeRet, RDPSRegister& SrcReg, BYTE Swizzle, BOOL bNegate, BOOL bForceShowFullSwizzle = FALSE )
{
    // stage in local string, then copy
    char pStr[256] = "";
    UINT i;
    BOOL bDoRegNum = TRUE;

    if( bNegate )
        _ADDSTR( "-" );

    switch( SrcReg.GetRegType() )
    {
    case RDPSREG_INPUT:
        _ADDSTR( "v" ); break;
    case RDPSREG_TEMP:
        _ADDSTR( "r" ); break;
    case RDPSREG_CONST:
        _ADDSTR( "c" ); break;
    case RDPSREG_TEXTURE:
        _ADDSTR( "t" ); break;
    case RDPSREG_POSTMODSRC:
        _ADDSTR( "postModSrc" ); break;
    case RDPSREG_SCRATCH:
        _ADDSTR( "scratch" ); break;
    case RDPSREG_QUEUEDWRITE:
        _ADDSTR( "queuedWrite" ); break;
    case RDPSREG_ZERO:
        _ADDSTR( "<0.0f>" ); bDoRegNum = FALSE; break;
    case RDPSREG_ONE:
        _ADDSTR( "<1.0f>" ); bDoRegNum = FALSE; break;
    case RDPSREG_TWO:
        _ADDSTR( "<2.0f>" ); bDoRegNum = FALSE; break;
    default:
        _ASSERT(FALSE,"RDPSInstSrcDisAsm - Unknown register type.");
        break;
    }

    if( bDoRegNum )
    {
        _ADDSTRP("%d", SrcReg.GetRegNum() );
    }


    if( !bForceShowFullSwizzle )
    {
        switch( Swizzle )
        {
        case RDPS_NOSWIZZLE:                         break;
        case RDPS_REPLICATERED:     _ADDSTR( ".r" ); break;
        case RDPS_REPLICATEGREEN:   _ADDSTR( ".g" ); break;
        case RDPS_REPLICATEBLUE:    _ADDSTR( ".b" ); break;
        case RDPS_REPLICATEALPHA:   _ADDSTR( ".a" ); break;
        default: bForceShowFullSwizzle = TRUE; break;
        }
    }
    if( bForceShowFullSwizzle )
    {
        _ADDSTR( "." );
        for( i=0; i<4; i++ )
        {
            switch( Swizzle & 0x3 )
            {
            case RDPS_SELECT_R: _ADDSTR("r"); break;
            case RDPS_SELECT_G: _ADDSTR("g"); break;
            case RDPS_SELECT_B: _ADDSTR("b"); break;
            case RDPS_SELECT_A: _ADDSTR("a"); break;
            }
            Swizzle >>= 2;        
        }
    }

    return _snprintf( pStrRet, StrSizeRet, "%s", pStr );
}

int
RDPSInstDestDisAsm(
    char* pStrRet, int StrSizeRet, RDPSRegister& DestReg, BYTE WriteMask )
{
    // stage in local string, then copy
    char pStr[256] = "";

    switch( DestReg.GetRegType() )
    {
    case RDPSREG_TEMP:
        _ADDSTR( "r" ); break;
    case RDPSREG_TEXTURE:
        _ADDSTR( "t" ); break;
    case RDPSREG_POSTMODSRC:
        _ADDSTR( "postModSrc" ); break;
    case RDPSREG_SCRATCH:
        _ADDSTR( "scratch" ); break;
    case RDPSREG_QUEUEDWRITE:
        _ADDSTR( "queuedWrite" ); break;
    default:
        _ASSERT(FALSE,"RDPSInstSrcDisAsm - Unknown or invalid destination register type.");
        break;
    }

    _ADDSTRP("%d", DestReg.GetRegNum() );

    if( 0 == WriteMask )
    {
        _ASSERT(FALSE,"RDPSInstSrcDisAsm - Invalid destination write mask (0).");
    }
    else if( RDPS_COMPONENTMASK_ALL != WriteMask )
    {
        _ADDSTR(".");
        if( RDPS_COMPONENTMASK_0 & WriteMask )
        {
            _ADDSTR("r");
        }
        if( RDPS_COMPONENTMASK_1 & WriteMask )
        {
            _ADDSTR("g");
        }
        if( RDPS_COMPONENTMASK_2 & WriteMask )
        {
            _ADDSTR("b");
        }
        if( RDPS_COMPONENTMASK_3 & WriteMask )
        {
            _ADDSTR("a");
        }
    }

    return _snprintf( pStrRet, StrSizeRet, "%s", pStr );
}

//-----------------------------------------------------------------------------
//
//
//-----------------------------------------------------------------------------
void
RDPSDisAsm(BYTE* pRDPSInstBuffer, ConstDef* pConstDefs, UINT cConstDefs, FLOAT fMaxPixelShaderValue, DWORD dwVersion)
{
    #define _InstParam(__INST)         (*(__INST##_PARAMS UNALIGNED64*)pRDPSInstBuffer)
    #define _StepOverInst(__INST)       pRDPSInstBuffer += sizeof(__INST##_PARAMS);
    #define _DeclArgs(__INST)           __INST##_PARAMS& Args = _InstParam(__INST);
    // stage in local string, then copy
    char pStr[256] = "";
    char pTempStr[256] = "";

    _ADDSTR("-----------------------------------------------------------------------------");
    RDDebugPrintf( pStr ); *pStr = 0;

    _ADDSTR("CreatePixelShader - Listing refrast's 'RISC' translation of pixel shader.    ");
    RDDebugPrintf( pStr ); *pStr = 0;

    _ADDSTR("                    Using MaxPixelShaderValue: ");
    if( FLT_MAX == fMaxPixelShaderValue )
    {
        _ADDSTR("FLT_MAX");
    }
    else
    {
        _ADDSTRP("%f",fMaxPixelShaderValue);
    }
    RDDebugPrintf( pStr ); *pStr = 0;
    _ADDSTR("                    Pixel shader version:      ");
    _ADDSTRP("ps.%d", D3DSHADER_VERSION_MAJOR(dwVersion));
    _ADDSTRP(".%d", D3DSHADER_VERSION_MINOR(dwVersion));
    RDDebugPrintf( pStr ); *pStr = 0;

    _ADDSTR("-----------------------------------------------------------------------------");
    RDDebugPrintf( pStr ); *pStr = 0;

    for( UINT i = 0; i < cConstDefs; i++ )
    {
        _ADDSTRP("def         c%d, [",pConstDefs[i].RegNum);
        _ADDSTRP("%f,",pConstDefs[i].f[0]);
        _ADDSTRP("%f,",pConstDefs[i].f[1]);
        _ADDSTRP("%f,",pConstDefs[i].f[2]);
        _ADDSTRP("%f] (post-MaxPSVal-clamp shown)",pConstDefs[i].f[3]);
        RDDebugPrintf( pStr ); *pStr = 0;
    }
    
    while(RDPSINST_END != _InstParam(RDPSINST_BASE).Inst)
    {
#ifdef _IA64_
        _ASSERT(0 == ((ULONG_PTR)pRDPSInstBuffer & 0x7), "RDPSDisAsm() - Misaligned instuction pointer!");
#endif
        switch(_InstParam(RDPSINST_BASE).Inst)
        {
        case RDPSINST_EVAL:
            {
                _DeclArgs(RDPSINST_EVAL)
                _ADDSTR("eval        ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,RDPS_COMPONENTMASK_ALL); 
                _ADDSTRP("%s <-- ", pTempStr);
                _ADDSTRP("CoordSet: %d, ", Args.uiCoordSet );
                _ADDSTR("bIgnoreD3DTTFF_PROJECTED: ");
                if( Args.bIgnoreD3DTTFF_PROJECTED ) 
                {
                    _ADDSTR( "TRUE");
                }
                else
                {
                    _ADDSTR( "FALSE");
                }
                _ADDSTR(", bClamp: ");
                if( Args.bClamp )
                {
                    _ADDSTR( "TRUE");
                }
                else
                {
                    _ADDSTR( "FALSE");
                }
            }
            _StepOverInst(RDPSINST_EVAL)
            break;
        case RDPSINST_SAMPLE:
            {
                _DeclArgs(RDPSINST_SAMPLE)
                _ADDSTR("sample      ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,RDPS_COMPONENTMASK_ALL); _ADDSTRP("%s <-- ", pTempStr);
                _ADDSTRP("TexStage: %d, TexCoords: ", Args.uiStage);
                RDPSInstSrcDisAsm(pTempStr,256,Args.CoordReg,RDPS_NOSWIZZLE,FALSE); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_SAMPLE)
            break;
        case RDPSINST_KILL:
            {
                _DeclArgs(RDPSINST_KILL)
                _ADDSTR("kill        ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,RDPS_COMPONENTMASK_ALL); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_KILL)
            break;
        case RDPSINST_BEM:
            {
                _DeclArgs(RDPSINST_BEM)
                _ADDSTR("bem         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s, ", pTempStr);
                _ADDSTRP("D3DTSS_BUMPENVMAT** Stage: %d", Args.uiStage);
            }
            _StepOverInst(RDPSINST_BEM)
            break;
        case RDPSINST_LUMINANCE:
            {
                _DeclArgs(RDPSINST_LUMINANCE)
                _ADDSTR("luminance   ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,RDPS_COMPONENTMASK_ALL); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s, ", pTempStr);
                _ADDSTRP("D3DTSS_BUMPENVLSCALE/OFFSET Stage: %d", Args.uiStage);
            }
            _StepOverInst(RDPSINST_LUMINANCE)
            break;
        case RDPSINST_DEPTH:
            {
                _DeclArgs(RDPSINST_DEPTH)
                _ADDSTR("depth       ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,RDPS_COMPONENTMASK_ALL); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_DEPTH)
            break;
        case RDPSINST_SRCMOD:
            {
                _DeclArgs(RDPSINST_SRCMOD)
                _ADDSTR("srcMod      ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                if( Args.bComplement )
                    _ADDSTR("1-");
                if( Args.bTimes2 )
                    _ADDSTR("2*");
                if( Args.bTimes2 && Args.bBias )
                    _ADDSTR("(");
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,FALSE); _ADDSTRP("%s", pTempStr);
                if( Args.bBias )
                    _ADDSTR("-0.5");
                if( Args.bTimes2 && Args.bBias )
                    _ADDSTR(")");
                _ADDSTR(", Clamp[");
                if( -FLT_MAX == Args.fRangeMin )
                {
                    _ADDSTR("-FLT_MAX,");
                }
                else
                {
                    _ADDSTRP("%.0f,",Args.fRangeMin);
                }
                if( FLT_MAX == Args.fRangeMax )
                {
                    _ADDSTR("FLT_MAX]");
                }
                else
                {
                    _ADDSTRP("%.0f]",Args.fRangeMax);
                }
            }
            _StepOverInst(RDPSINST_SRCMOD)
            break;
        case RDPSINST_SWIZZLE:
            {
                _DeclArgs(RDPSINST_SWIZZLE)
                _ADDSTR("swizzle     ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,Args.Swizzle,FALSE,TRUE); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_SWIZZLE)
            break;
        case RDPSINST_DSTMOD:
            {
                _DeclArgs(RDPSINST_DSTMOD)
                _ADDSTR("dstMod      ");

                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.DstReg,RDPS_NOSWIZZLE,FALSE); _ADDSTRP("%s", pTempStr);

                if( (1.0f == Args.fScale) ||
                    (2.0f == Args.fScale) ||
                    (4.0f == Args.fScale) ||
                    (8.0f == Args.fScale) )
                {
                    _ADDSTRP("*%.0f",Args.fScale);
                }
                else if( (0.5f == Args.fScale) ||
                         (0.25f == Args.fScale) ||
                         (0.125f == Args.fScale) )
                {
                    _ADDSTRP("/%.0f",1/Args.fScale);
                }
                else
                    _ASSERT(FALSE,"RDPSDisAsm - Unexpected dest shift.");

                _ADDSTR(", Clamp[");
                if( -FLT_MAX == Args.fRangeMin )
                {
                    _ADDSTR("-FLT_MAX,");
                }
                else
                {
                    if( Args.fRangeMin == ceil(Args.fRangeMin) )
                    {
                        _ADDSTRP("%.0f,",Args.fRangeMin);
                    }
                    else
                    {
                        _ADDSTRP("%.4f,",Args.fRangeMin);
                    }
                }
                if( FLT_MAX == Args.fRangeMax )
                {
                    _ADDSTR("FLT_MAX]");
                }
                else
                {
                    if( Args.fRangeMax == floor(Args.fRangeMax) )
                    {
                        _ADDSTRP("%.0f]",Args.fRangeMax);
                    }
                    else
                    {
                        _ADDSTRP("%.4f]",Args.fRangeMax);
                    }
                }
            }
            _StepOverInst(RDPSINST_DSTMOD)
            break;
        case RDPSINST_MOV:
            {
                _DeclArgs(RDPSINST_MOV)
                _ADDSTR("mov         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_MOV)
            break;
        case RDPSINST_RCP:
            {
                _DeclArgs(RDPSINST_RCP)
                _ADDSTR("rcp         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_RCP)
            break;
        case RDPSINST_FRC:
            {
                _DeclArgs(RDPSINST_FRC)
                _ADDSTR("frc         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_FRC)
            break;
        case RDPSINST_ADD:
            {
                _DeclArgs(RDPSINST_ADD)
                _ADDSTR("add         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_ADD)
            break;
        case RDPSINST_SUB:
            {
                _DeclArgs(RDPSINST_SUB)
                _ADDSTR("sub         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_SUB)
            break;
        case RDPSINST_MUL:
            {
                _DeclArgs(RDPSINST_MUL)
                _ADDSTR("mul         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_MUL)
            break;
        case RDPSINST_DP3:
            {
                _DeclArgs(RDPSINST_DP3)
                _ADDSTR("dp3         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_DP3)
            break;
        case RDPSINST_DP4:
            {
                _DeclArgs(RDPSINST_DP4)
                _ADDSTR("dp4 ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_DP4)
            break;
        case RDPSINST_MAD:
            {
                _DeclArgs(RDPSINST_MAD)
                _ADDSTR("mad         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg2,RDPS_NOSWIZZLE,Args.bSrcReg2_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_MAD)
            break;
        case RDPSINST_LRP:
            {
                _DeclArgs(RDPSINST_LRP)
                _ADDSTR("lrp         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg2,RDPS_NOSWIZZLE,Args.bSrcReg2_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_LRP)
            break;
        case RDPSINST_CND:
            {
                _DeclArgs(RDPSINST_LRP)
                _ADDSTR("cnd         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg2,RDPS_NOSWIZZLE,Args.bSrcReg2_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_CND)
            break;
        case RDPSINST_CMP:
            {
                _DeclArgs(RDPSINST_CMP)
                _ADDSTR("cmp         ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s <-- ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg0,RDPS_NOSWIZZLE,Args.bSrcReg0_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg1,RDPS_NOSWIZZLE,Args.bSrcReg1_Negate); _ADDSTRP("%s, ", pTempStr);
                RDPSInstSrcDisAsm(pTempStr,256,Args.SrcReg2,RDPS_NOSWIZZLE,Args.bSrcReg2_Negate); _ADDSTRP("%s", pTempStr);
            }
            _StepOverInst(RDPSINST_CMP)
            break;
        case RDPSINST_TEXCOVERAGE:
            // don't bother to spew this (ref specific)
            _StepOverInst(RDPSINST_TEXCOVERAGE)
            break;
        case RDPSINST_QUADLOOPBEGIN:
            // don't bother to spew this
            _StepOverInst(RDPSINST_QUADLOOPBEGIN)
            break;
        case RDPSINST_QUADLOOPEND:
            // don't bother to spew this
            _StepOverInst(RDPSINST_QUADLOOPEND)
            break;
        case RDPSINST_QUEUEWRITE:
            {
                _DeclArgs(RDPSINST_QUEUEWRITE)
                _ADDSTR("queueWrite  ");
                RDPSInstDestDisAsm(pTempStr,256,Args.DstReg,Args.WriteMask); _ADDSTRP("%s", pTempStr);
                _StepOverInst(RDPSINST_QUEUEWRITE)
                break;
            }
        case RDPSINST_FLUSHQUEUE:
            _ADDSTR("flushQueue  ");
            _StepOverInst(RDPSINST_FLUSHQUEUE)
            break;
        case RDPSINST_NEXTD3DPSINST:
            _ADDSTRP("------------------------------------------------- D3D PS Inst: '%s'",
                        _InstParam(RDPSINST_NEXTD3DPSINST).pInst->Text);
            _StepOverInst(RDPSINST_NEXTD3DPSINST)
            break;
        default:
            _ASSERT(FALSE,"RDPSDisAsm - Unrecognized refrast internal pixel shader instruction.");
            break;
        }
        if( 0 != *pStr )
        {
            RDDebugPrintf( pStr ); 
            *pStr = 0;
        }
    }
    _ADDSTR("------------------------------------------------- End of pixel shader. ------");
    RDDebugPrintf( pStr ); 
}
#endif // DBG

//-----------------------------------------------------------------------------
//
// UpdateLegacyPixelShader - Constructs pixel shader which performs all of
// the texture lookups, including bump mapping, for the legacy pixel shading
// model.  Result of running this shader is the full set of texture lookups
// in the temporary registers, which are then blended with the pixel diffuse
// and specular colors using the legacy texture blend code.
//
//-----------------------------------------------------------------------------

// destination parameter token
#define D3DSPD( _RegFile, _Num ) (\
    (1L<<31) |  (D3DSPR_##_RegFile) |\
    ((_Num)&D3DSP_REGNUM_MASK) |\
    (D3DSP_WRITEMASK_0|D3DSP_WRITEMASK_1|D3DSP_WRITEMASK_2|D3DSP_WRITEMASK_3) )

// source paramater token
#define D3DPSPS( _RegFile, _Num ) (\
    (1L<<31) | ((_Num)&D3DSP_REGNUM_MASK) |\
    D3DSP_NOSWIZZLE | (D3DSPR_##_RegFile) )

void
RefRast::UpdateLegacyPixelShader( void )
{
    if (m_pLegacyPixelShader) delete m_pLegacyPixelShader;
    m_pLegacyPixelShader = NULL;

    DWORD Tokens[64];
    DWORD* pToken = Tokens;

    *pToken++ = D3DPS_VERSION(0xfe,0xfe);
    BOOL bSkipNextStage = FALSE;
    for ( int iStage=0; iStage<D3DHAL_TSS_MAXSTAGES; iStage++ )
    {
        if ( m_pRD->m_TextureStageState[iStage].m_dwVal[D3DTSS_COLOROP] == D3DTOP_DISABLE )
        {
            break;
        }
        if (bSkipNextStage) { bSkipNextStage = FALSE; continue; }

        BOOL bIsBEM  = ( m_pRD->m_TextureStageState[iStage].m_dwVal[D3DTSS_COLOROP] == D3DTOP_BUMPENVMAP );
        BOOL bIsBEML = ( m_pRD->m_TextureStageState[iStage].m_dwVal[D3DTSS_COLOROP] == D3DTOP_BUMPENVMAPLUMINANCE );
        if ( bIsBEM || bIsBEML )
        {
            // DX6/7 BEM(L) was set for stage with bump map (i.e. first of two), while DX8
            // BEM(L) is set for a subsequent stage, so we have to set a 'standard' texture
            // to this stage and BEM(L) for the next stage, then stop anything else from being
            // set for the next stage
            *pToken++ = D3DSIO_TEX;
            *pToken++ = D3DSPD(TEXTURE, iStage);
            *pToken++ = (bIsBEM) ? (D3DSIO_TEXBEM_LEGACY) : (D3DSIO_TEXBEML_LEGACY);
            *pToken++ = D3DSPD(TEXTURE, iStage+1);
            *pToken++ = D3DPSPS(TEXTURE, iStage);
            bSkipNextStage = TRUE;
        }
        else
        {
            // simple lookup into 'iStage' texture register
            *pToken++ = D3DSIO_TEX;
            *pToken++ = D3DSPD(TEXTURE, iStage);
        }
    }
    *pToken++ = D3DPS_END();

    if ( pToken > (Tokens+2) )
    {
        m_pLegacyPixelShader = new RDPShader;
        if (NULL == m_pLegacyPixelShader)
            DPFERR("E_OUTOFMEMORY");
        m_pLegacyPixelShader->Initialize( m_pRD, Tokens, 4*(pToken-Tokens), m_pRD->GetCaps8() );
    }

    return;
}

//-----------------------------------------------------------------------------
//
// Pixel Shader DP2 Command Functions
//
//-----------------------------------------------------------------------------
HRESULT
RefDev::Dp2CreatePixelShader( DWORD handle, DWORD dwCodeSize, LPDWORD pCode )
{
    HRESULT hr = S_OK;

    HR_RET( m_PShaderHandleArray.Grow( handle ) );

    //
    // Validation sequence
    //
#if DBG
    _ASSERT( m_PShaderHandleArray[handle].m_tag == 0,
             "A shader exists with the given handle, tag is non-zero" );
#endif
    _ASSERT( m_PShaderHandleArray[handle].m_pShader == NULL,
             "A shader exists with the given handle" );


    RDPShader* pShader;

    pShader = m_PShaderHandleArray[handle].m_pShader = new RDPShader;

    if( pShader == NULL )
        return E_OUTOFMEMORY;

    hr = pShader->Initialize( this, pCode, dwCodeSize, GetCaps8() );
    if( FAILED( hr ) )
    {
        delete pShader;
        m_PShaderHandleArray[handle].m_pShader = NULL;
#if DBG
        m_PShaderHandleArray[handle].m_tag = 0;
#endif
        return hr;
    }

#if DBG
    // Everything successful, mark this handle as in use.
    m_PShaderHandleArray[handle].m_tag = 1;
#endif
    return hr;
}

HRESULT
RefDev::Dp2DeletePixelShader(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;

    LPD3DHAL_DP2PIXELSHADER pPS =
        (LPD3DHAL_DP2PIXELSHADER)(pCmd + 1);
    for( int i = 0; i < pCmd->wStateCount; i++ )
    {
        DWORD handle = pPS[i].dwHandle;

        _ASSERT( m_PShaderHandleArray.IsValidIndex( handle ),
             "DeletePixelShader: invalid shader handle" );

        _ASSERT( m_PShaderHandleArray[handle].m_pShader,
             "DeletePixelShader: invalid shader" );

        delete m_PShaderHandleArray[handle].m_pShader;
        m_PShaderHandleArray[handle].m_pShader = NULL;
#if DBG
        m_PShaderHandleArray[handle].m_tag = 0;
#endif

        if( handle == m_CurrentPShaderHandle )
        {
            m_CurrentPShaderHandle = 0;
            m_dwRastFlags |= RDRF_PIXELSHADER_CHANGED;
        }
    }
    return hr;
}

HRESULT
RefDev::Dp2SetPixelShader(LPD3DHAL_DP2COMMAND pCmd)
{
    HRESULT hr = S_OK;
    RDPShader* pShader = NULL;
    LPD3DHAL_DP2PIXELSHADER pPS =
        (LPD3DHAL_DP2PIXELSHADER)(pCmd + 1);

    // Just set the last Pixel Shader in this array
    DWORD handle = pPS[pCmd->wStateCount-1].dwHandle;

    if (handle)
    {
        if( !m_PShaderHandleArray.IsValidIndex( handle ) 
            ||
            (m_PShaderHandleArray[handle].m_pShader == NULL) )
        {
            DPFERR( "Such a Pixel Shader has not been created" );
            return E_INVALIDARG;
        }
        
        pShader = m_PShaderHandleArray[handle].m_pShader;
    }
    
    m_CurrentPShaderHandle = handle;
    m_dwRastFlags |= RDRF_PIXELSHADER_CHANGED;


    if( pShader )
    {
        for( UINT i = 0; i < pShader->m_cConstDefs; i++ )
        {
            // constant regs are duplicated for 4 pixel grid
            for (UINT iP=0; iP<4; iP++)
            {
                // Consts from DEF instructions have already been clamped,
                // so just copy them.
                memcpy( m_Rast.m_ConstReg[pShader->m_pConstDefs[i].RegNum][iP],
                        pShader->m_pConstDefs[i].f, 4*sizeof(FLOAT) ); 
            }
        }
    }

    return hr;
}

HRESULT
RefDev::Dp2SetPixelShaderConsts( DWORD StartReg, DWORD dwCount,
                                               LPDWORD pData )
{
    HRESULT hr = S_OK;

    if ( (StartReg+dwCount) > RDPS_MAX_NUMCONSTREG )
    {
        DPFERR("start/count out of range in SetPixelShaderConstant");
        return D3DERR_INVALIDCALL;
    }

    FLOAT* pfData = (FLOAT*)pData;
    FLOAT fMin = -(GetCaps8()->MaxPixelShaderValue);
    FLOAT fMax =  (GetCaps8()->MaxPixelShaderValue);
    UINT End = StartReg + dwCount;
    for (UINT iR=StartReg; iR<End; iR++)
    {
        // clamp constants on input to range of values in pixel shaders
        FLOAT fConst[4];
        fConst[0] = MAX( fMin, MIN( fMax, *(pfData+0) ) );
        fConst[1] = MAX( fMin, MIN( fMax, *(pfData+1) ) );
        fConst[2] = MAX( fMin, MIN( fMax, *(pfData+2) ) );
        fConst[3] = MAX( fMin, MIN( fMax, *(pfData+3) ) );
        pfData += 4;

        // constant regs are duplicated for 4 pixel grid
        for (UINT iP=0; iP<4; iP++)
        {
            m_Rast.m_ConstReg[iR][iP][0] = fConst[0];
            m_Rast.m_ConstReg[iR][iP][1] = fConst[1];
            m_Rast.m_ConstReg[iR][iP][2] = fConst[2];
            m_Rast.m_ConstReg[iR][iP][3] = fConst[3];
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\rast\rastedge.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// rastedge.cpp
//
// Direct3D Reference Device - Edge Function Processing
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// Set - Computes edge function and associated information.
//
//-----------------------------------------------------------------------------
void
RDEdge::Set(
    BOOL bDetPositive,
    INT32 iX0, INT32 iY0,
    INT32 iX1, INT32 iY1)
{
    // compute A,B (gradient) terms - these are n.4 fixed point
    m_iA = iY0 - iY1;
    m_iB = iX1 - iX0;

    // flip gradient signs if backfacing so functions are consistently
    // greater than zero outside of primitive
    if ( bDetPositive ) { m_iA = -m_iA; m_iB = -m_iB; }

    // compute C term
    //
    // function is by definition zero at the vertices, so:
    //     0 = A*Xv + B*Yv + C  =>  C = - A*Xv - B*Yv
    //
    // A*Xv & B*Yv are n.4 * n.4 = n.8, so C is n.8 fixed point
    m_iC = - ( (INT64)iX0 * (INT64)m_iA ) - ( (INT64)iY0 * (INT64)m_iB );

    // compute edge function sign flags - must be done consistently for vertical
    // and horizontal cases to adhere to point sample fill rules
    BOOL bEdgeAEQZero = ( m_iA == 0. );
    BOOL bEdgeBEQZero = ( m_iB == 0. );
    BOOL bEdgeAGTZero = ( m_iA > 0. );
    BOOL bEdgeBGTZero = ( m_iB > 0. );
    m_bAPos = bEdgeAEQZero ? bEdgeBGTZero : bEdgeAGTZero;
    m_bBPos = bEdgeBEQZero ? bEdgeAGTZero : bEdgeBGTZero;
}

//-----------------------------------------------------------------------------
//
// Supports the Direct3D left-top fill rule.
//
// inputs are n.4 floating point
//
//-----------------------------------------------------------------------------
BOOL
RDEdge::Test( INT32 iX, INT32 iY )
{
    // evaluate edge distance function (n.8 fixed point)
    INT64 iEdgeDist =
        ( (INT64)m_iA * (INT64)iX ) +  // n.4 * n.4 = n.8
        ( (INT64)m_iB * (INT64)iY ) +  // n.4 * n.4 = n.8
        (INT64)m_iC;                   // n.8

    // pixel sample position is outside edge if distance is > zero
    //
    // This implements the D3D left-top fill rule
    //
    // For exactly-on-edge case (distance == zero), the sign of the Y gradient
    // is used to determine if the pixel is to be considered inside or outside
    // of the edge. For the non-horizontal case, the m_bAPos bit is based
    // simply on the sign of the Y slope.  This implements the 'left' part of
    // the 'left-top' rule.
    //
    // For the horizontal case,  the sign of the B gradient (X slope) is taken
    // into account in the computation of the m_bAPos bit when the A gradient
    // is exactly zero, which forces a pixel exactly on a 'top' edge to be
    // considered in and a pixel exactly on a 'bottom' edge to be considered out.
    //
    if ( ( iEdgeDist > 0 ) || ( ( iEdgeDist == 0 ) && m_bAPos ) )
    {
        // pixel is out
        return FALSE;
    }
    // pixel is in
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\rast\rastprim.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// rastprim.cpp
//
// Direct3D Reference Device - Rasterizer Primitive Routines
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
RefRast::~RefRast()
{
    delete m_pLegacyPixelShader;
}

//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------
void RefRast::Init( RefDev* pRD )
{
    m_pRD = pRD;
    m_bIsLine = FALSE;
    m_iFlatVtx = 0;

    // initialize attributes           xD  Persp  Clamp
    m_Attr[RDATTR_DEPTH   ].Init( this, 1, FALSE, TRUE );
    m_Attr[RDATTR_FOG     ].Init( this, 1, TRUE,  TRUE );
    m_Attr[RDATTR_COLOR   ].Init( this, 4, TRUE,  TRUE );
    m_Attr[RDATTR_SPECULAR].Init( this, 4, TRUE,  TRUE );
    m_Attr[RDATTR_TEXTURE0].Init( this, 4, TRUE,  FALSE );
    m_Attr[RDATTR_TEXTURE1].Init( this, 4, TRUE,  FALSE );
    m_Attr[RDATTR_TEXTURE2].Init( this, 4, TRUE,  FALSE );
    m_Attr[RDATTR_TEXTURE3].Init( this, 4, TRUE,  FALSE );
    m_Attr[RDATTR_TEXTURE4].Init( this, 4, TRUE,  FALSE );
    m_Attr[RDATTR_TEXTURE5].Init( this, 4, TRUE,  FALSE );
    m_Attr[RDATTR_TEXTURE6].Init( this, 4, TRUE,  FALSE );
    m_Attr[RDATTR_TEXTURE7].Init( this, 4, TRUE,  FALSE );

    m_iPix = 0;
    memset( m_bPixelIn, 0, sizeof(m_bPixelIn) );
    memset( m_bSampleCovered, 0, sizeof(m_bSampleCovered) );
    m_bLegacyPixelShade = TRUE;
    m_pCurrentPixelShader = NULL;
    m_CurrentPSInst = 0;
#if DBG
    {
        DWORD v = 0;
        if( GetD3DRefRegValue(REG_DWORD, "VerboseCreatePixelShader", &v, sizeof(DWORD)) && v != 0 )
            m_bDebugPrintTranslatedPixelShaderTokens = TRUE;
        else
            m_bDebugPrintTranslatedPixelShaderTokens = FALSE;
    }
#endif

    // default value registers
    UINT i, j;
    for( i = 0 ; i < 4; i++ )
    {
        for( j = 0; j < 4; j++ )
        {
            m_ZeroReg[i][j] = 0.0f;
            m_OneReg[i][j]  = 1.0f;
            m_TwoReg[i][j]  = 2.0f;
        }
    }

    m_bLegacyPixelShade = TRUE;
    m_pLegacyPixelShader = NULL;

    memset( m_bPixelDiscard, 0, sizeof(m_bPixelDiscard) );

    // multi-sample stuff
    m_CurrentSample = 0;
    m_SampleMask = 0xffffffff;
    SetSampleMode( 1, TRUE );
    m_bSampleCovered[0][0] =
    m_bSampleCovered[0][1] =
    m_bSampleCovered[0][2] =
    m_bSampleCovered[0][3] = TRUE;

    memset( m_TexCvg, 0, sizeof(m_TexCvg) );
    memset( m_TexFlt, 0, sizeof(m_TexFlt) );
}

//-----------------------------------------------------------------------------
//
// SampleAndInvertRHW - Sample 1/W at current given location, invert, return
//
//-----------------------------------------------------------------------------
FLOAT RefRast::SampleAndInvertRHW( FLOAT fX, FLOAT fY )
{
    FLOAT fPixelRHW = fX*m_fRHWA + fY*m_fRHWB + m_fRHWC;
    FLOAT fPixelW = ( 0. != fPixelRHW ) ? ( 1./fPixelRHW ) : ( 0. );
    return fPixelW;
}

//-----------------------------------------------------------------------------
//
//
//-----------------------------------------------------------------------------
BOOL
RefRast::EvalPixelPosition( int iPix )
{
    BOOL bPixelIn;

    if (m_SampleCount > 1)
    {
        bPixelIn = FALSE; // assume out, then set if any in

        // generating multiple samples, so must evaluate all
        // sample positions for in/out
        do
        {
            BOOL bPixelSampleIn = GetCurrentSampleMask();
            if (!bPixelSampleIn) continue;

            // get sample location
            INT32 iX = GetCurrentSampleX(iPix);
            INT32 iY = GetCurrentSampleY(iPix);

            // test each edge
            for ( int iEdge=0; iEdge<m_iEdgeCount; iEdge++ )
            {
                bPixelSampleIn &= m_Edge[iEdge].Test( iX, iY );
                if (!bPixelSampleIn) break;
            }

            m_bSampleCovered[m_CurrentSample][iPix] = bPixelSampleIn;

            // accumulate per-sample test into per-pixel test
            bPixelIn |= bPixelSampleIn;

        } while (NextSample());
    }
    else
    {
        bPixelIn = TRUE; // assume pixel is inside all edges

        // single sample, so just test pixel center
        for ( int iEdge=0; iEdge<m_iEdgeCount; iEdge++ )
        {
            bPixelIn &= m_Edge[iEdge].Test( m_iX[iPix]<<4, m_iY[iPix]<<4 );
            if (!bPixelIn) break;
        }
    }
    return bPixelIn;

}

///////////////////////////////////////////////////////////////////////////////
//
// Triangle (& Point) Setup
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// PerTriangleSetup - Per-triangle portion of triangle setup excluding any
// per-edge or per-attribute work.  Includes snapping of x,y coords to n.4
// grid to enable subsequent edge computations to be exact fixed point;
// computation of determinant; culling; computation and intersection tests
// of scan area; and setup of perspective correction function.
//
//-----------------------------------------------------------------------------
BOOL RefRast::PerTriangleSetup(
    FLOAT* pVtx0, FLOAT* pVtx1, FLOAT* pVtx2,
    DWORD CullMode,
    RECT* pClip)
{
    m_bIsLine = FALSE;

    FLOAT fX0 = *(pVtx0+0);
    FLOAT fY0 = *(pVtx0+1);
    FLOAT fX1 = *(pVtx1+0);
    FLOAT fY1 = *(pVtx1+1);
    FLOAT fX2 = *(pVtx2+0);
    FLOAT fY2 = *(pVtx2+1);

    // compute fixed point x,y coords snapped to n.4 with nearest-even round
    m_iX0 = FloatToNdot4(fX0);
    m_iY0 = FloatToNdot4(fY0);
    m_iX1 = FloatToNdot4(fX1);
    m_iY1 = FloatToNdot4(fY1);
    m_iX2 = FloatToNdot4(fX2);
    m_iY2 = FloatToNdot4(fY2);

    // compute integer deltas
    INT32 iDelX10 = m_iX1 - m_iX0;
    INT32 iDelX02 = m_iX0 - m_iX2;
    INT32 iDelY01 = m_iY0 - m_iY1;
    INT32 iDelY20 = m_iY2 - m_iY0;

    // compute determinant in n.8 fixed point (n.4 * n.4 = n.8)
    m_iDet =
        ( (INT64)iDelX10 * (INT64)iDelY20 ) -
        ( (INT64)iDelX02 * (INT64)iDelY01 );

    // check for degeneracy (no area)
    if ( 0 == m_iDet ) { return TRUE; }

    // do culling
    switch ( CullMode )
    {
    case D3DCULL_NONE:  break;
    case D3DCULL_CW:    if ( m_iDet > 0 )  { return TRUE; }  break;
    case D3DCULL_CCW:   if ( m_iDet < 0 )  { return TRUE; }  break;
    }

    // compute bounding box for scan area
    FLOAT fXMin = MIN( fX0, MIN( fX1, fX2 ) );
    FLOAT fXMax = MAX( fX0, MAX( fX1, fX2 ) );
    FLOAT fYMin = MIN( fY0, MIN( fY1, fY2 ) );
    FLOAT fYMax = MAX( fY0, MAX( fY1, fY2 ) );
    // convert to integer (round to +inf)
    m_iXMin = (INT32)(fXMin+.5);
    m_iXMax = (INT32)(fXMax+.5);
    m_iYMin = (INT32)(fYMin+.5);
    m_iYMax = (INT32)(fYMax+.5);

    // clip bbox to rendering surface
    m_iXMin = MAX( m_iXMin, pClip->left   );
    m_iXMax = MIN( m_iXMax, pClip->right  );
    m_iYMin = MAX( m_iYMin, pClip->top    );
    m_iYMax = MIN( m_iYMax, pClip->bottom );

    // reject if no coverage
    if ( ( m_iXMin < pClip->left   ) ||
         ( m_iXMax > pClip->right  ) ||
         ( m_iYMin < pClip->top    ) ||
         ( m_iYMax > pClip->bottom ) )
    {
        return TRUE;
    }

    // compute float versions of snapped coord data
    m_fX0 = (FLOAT)m_iX0 * 1.0F/16.0F;
    m_fY0 = (FLOAT)m_iY0 * 1.0F/16.0F;
    m_fDelX10 = (FLOAT)iDelX10 * 1.0F/16.0F;
    m_fDelX02 = (FLOAT)iDelX02 * 1.0F/16.0F;
    m_fDelY01 = (FLOAT)iDelY01 * 1.0F/16.0F;
    m_fDelY20 = (FLOAT)iDelY20 * 1.0F/16.0F;

    // compute inverse determinant
    FLOAT fDet = (1./(FLOAT)(1<<8)) * (FLOAT)m_iDet;
    m_fTriOODet = 1.f/fDet;

    // compute linear function for 1/W (for perspective correction)
    m_fRHW0 = *(pVtx0+3);
    m_fRHW1 = *(pVtx1+3);
    m_fRHW2 = *(pVtx2+3);

    // compute linear deltas along two edges
    FLOAT fDelAttrib10 = m_fRHW1 - m_fRHW0;
    FLOAT fDelAttrib20 = m_fRHW2 - m_fRHW0;

    // compute A & B terms (dVdX and dVdY)
    m_fRHWA = m_fTriOODet * ( fDelAttrib10 * m_fDelY20 + fDelAttrib20 * m_fDelY01 );
    m_fRHWB = m_fTriOODet * ( fDelAttrib20 * m_fDelX10 + fDelAttrib10 * m_fDelX02 );

    // compute C term (Fv = A*Xv + B*Yv + C => C = Fv - A*Xv - B*Yv)
    m_fRHWC = m_fRHW0 - ( m_fRHWA * m_fX0 ) - ( m_fRHWB * m_fY0 );

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
//
// Line Setup & Evaluate
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// PointDiamondCheck - Tests if vertex is within diamond of nearest candidate
// position.  The +.5 (lower-right) tests are used because this is pixel-relative
// test - this corresponds to an upper-left test for a vertex-relative position.
//
//-----------------------------------------------------------------------------
static BOOL
PointDiamondCheck(
    INT32 iXFrac, INT32 iYFrac,
    BOOL bSlopeIsOne, BOOL bSlopeIsPosOne )
{
    const INT32 iPosHalf =  0x8;
    const INT32 iNegHalf = -0x8;

    INT32 iFracAbsSum = labs( iXFrac ) + labs( iYFrac );

    // return TRUE if point is in fully-exclusive diamond
    if ( iFracAbsSum < iPosHalf ) return TRUE;

    // else return TRUE if diamond is on left or top extreme of point
    if ( ( iXFrac == ( bSlopeIsPosOne ? iNegHalf : iPosHalf ) ) &&
         ( iYFrac == 0 ) )
        return TRUE;

    if ( ( iYFrac == iPosHalf ) &&
         ( iXFrac == 0 ) )
        return TRUE;

    // return true if slope is one, vertex is on edge, and (other conditions...)
    if ( bSlopeIsOne && ( iFracAbsSum == iPosHalf ) )
    {
        if (  bSlopeIsPosOne && ( iXFrac < 0 ) && ( iYFrac > 0 ) )
            return TRUE;

        if ( !bSlopeIsPosOne && ( iXFrac > 0 ) && ( iYFrac > 0 ) )
            return TRUE;
    }

    return FALSE;
}

//-----------------------------------------------------------------------------
//
// PerLineSetup - Does per-line setup including scan conversion
//
// This implements the Grid Intersect Quanization (GIQ) convention (which is
// also used in Windows).
//
// Returns: TRUE if line is discarded; FALSE if line to be drawn
//
//-----------------------------------------------------------------------------
BOOL
RefRast::PerLineSetup(
    FLOAT* pVtx0, FLOAT* pVtx1,
    BOOL bLastPixel,
    RECT* pClip)
{
    m_bIsLine = TRUE;

    FLOAT fX0 = *(pVtx0+0);
    FLOAT fY0 = *(pVtx0+1);
    FLOAT fX1 = *(pVtx1+0);
    FLOAT fY1 = *(pVtx1+1);

    // compute fixed point x,y coords snapped to n.4 with nearest-even round
    m_iX0 = FloatToNdot4( fX0 );
    m_iY0 = FloatToNdot4( fY0 );
    m_iX1 = FloatToNdot4( fX1 );
    m_iY1 = FloatToNdot4( fY1 );

    // compute x,y extents of the line (fixed point)
    INT32 iXSize = m_iX1 - m_iX0;
    INT32 iYSize = m_iY1 - m_iY0;

    if ( ( iXSize == 0 ) && ( iYSize == 0 ) ) { return TRUE; }

    // determine major direction and compute line function
    // use GreaterEqual compare here so X major will be used when slope is
    // exactly one - this forces the per-pixel evaluation to be done on the
    // Y axis and thus adheres to the rule of inclusive right (instead of
    // inclusive left) for slope == 1 cases
    if ( labs( iXSize ) >= labs( iYSize )  )
    {
        // here for X major
        m_bLineXMajor = TRUE;
        m_fLineMajorLength = (FLOAT)iXSize * (1./16.);

        // line function: y = F(x) = ( [0]*x + [1] ) / [2]
        m_iLineEdgeFunc[0] = iYSize;
        m_iLineEdgeFunc[1] = (INT64)m_iY0*(INT64)m_iX1 - (INT64)m_iY1*(INT64)m_iX0;
        m_iLineEdgeFunc[2] = iXSize;
    }
    else
    {
        // here for Y major
        m_bLineXMajor = FALSE;
        m_fLineMajorLength = (FLOAT)iYSize * (1./16.);

        // line function: x = F(y) = ( [0]*y + [1] ) / [2]
        m_iLineEdgeFunc[0] = iXSize;
        m_iLineEdgeFunc[1] = (INT64)m_iX0*(INT64)m_iY1 - (INT64)m_iX1*(INT64)m_iY0;
        m_iLineEdgeFunc[2] = iYSize;
    }

    BOOL bSlopeIsOne = ( labs( iXSize ) == labs( iYSize ) );
    BOOL bSlopeIsPosOne =
        bSlopeIsOne &&
        ( ( (FLOAT)m_iLineEdgeFunc[0]/(FLOAT)m_iLineEdgeFunc[2] ) > 0. );

    // compute candidate pixel location for line endpoints
    //
    //       n                   n
    //   O-------*           *-------O
    //  n-.5    n+.5        n-.5    n+.5
    //
    //  Nearest Ceiling     Nearest Floor
    //
    // always nearest ceiling for Y; use nearest floor for X for exception (slope == +1)
    // case else use nearest ceiling
    //
    // nearest ceiling of Y is ceil( Y - .5), and is done by converting to floor via:
    //
    //   ceil( A/B ) = floor( (A+B-1)/B )
    //
    // where A is coordinate - .5, and B is 0x10 (thus A/B is an n.4 fixed point number)
    //
    // A+B-1 = ( (Y - half) + B - 1 = ( (Y-0x8) + 0x10 - 0x1 = Y + 0x7
    // since B is 2**4, divide by B is right shift by 4
    //
    INT32 iPixX0 = ( m_iX0 + ( bSlopeIsPosOne ? 0x8 : 0x7 ) ) >> 4;
    INT32 iPixX1 = ( m_iX1 + ( bSlopeIsPosOne ? 0x8 : 0x7 ) ) >> 4;
    INT32 iPixY0 = ( m_iY0 + 0x7 ) >> 4;
    INT32 iPixY1 = ( m_iY1 + 0x7 ) >> 4;


    // check for vertices in/out of diamond
    BOOL bV0InDiamond = PointDiamondCheck( m_iX0 - (iPixX0<<4), m_iY0 - (iPixY0<<4), bSlopeIsOne, bSlopeIsPosOne );
    BOOL bV1InDiamond = PointDiamondCheck( m_iX1 - (iPixX1<<4), m_iY1 - (iPixY1<<4), bSlopeIsOne, bSlopeIsPosOne );

    // compute step value
    m_iLineStep = ( m_fLineMajorLength > 0 ) ? ( +1 ) : ( -1 );

    // compute float and integer major start (V0) and end (V1) positions
    INT32 iLineMajor0 = ( m_bLineXMajor ) ? ( m_iX0 ) : ( m_iY0 );
    INT32 iLineMajor1 = ( m_bLineXMajor ) ? ( m_iX1 ) : ( m_iY1 );
    m_iLineMin = ( m_bLineXMajor ) ? ( iPixX0 ) : ( iPixY0 );
    m_iLineMax = ( m_bLineXMajor ) ? ( iPixX1 ) : ( iPixY1 );

// need to do lots of compares which are flipped if major direction is negative
#define LINEDIR_CMP( _A, _B ) \
( ( m_fLineMajorLength > 0 ) ? ( (_A) < (_B) ) : ( (_A) > (_B) ) )

    // do first pixel handling - keep first pixel if not in or behind diamond
    if ( !( bV0InDiamond || LINEDIR_CMP( iLineMajor0, (m_iLineMin<<4) ) ) )
    {
        m_iLineMin += m_iLineStep;
    }

    // do last-pixel handling - keep last pixel if past diamond (in which case
    // the pixel is always filled) or if in diamond and rendering last pixel
    if ( !( ( !bV1InDiamond && LINEDIR_CMP( (m_iLineMax<<4), iLineMajor1 ) ) ||
            ( bV1InDiamond && bLastPixel ) ) )
    {
        m_iLineMax -= m_iLineStep;
    }

    // return if no (major) extent (both before and after clamping to render buffer)
    if ( LINEDIR_CMP( m_iLineMax, m_iLineMin ) ) return TRUE;

    // snap major extent to render buffer
    INT16 iRendBufMajorMin = m_bLineXMajor ? pClip->left  : pClip->top;
    INT16 iRendBufMajorMax = m_bLineXMajor ? pClip->right : pClip->bottom;
    if ( ( ( m_iLineMin < iRendBufMajorMin ) &&
           ( m_iLineMax < iRendBufMajorMin ) ) ||
         ( ( m_iLineMin > iRendBufMajorMax ) &&
           ( m_iLineMax > iRendBufMajorMax ) ) )  { return TRUE; }
    m_iLineMin = MAX( 0, MIN( iRendBufMajorMax, m_iLineMin ) );
    m_iLineMax = MAX( 0, MIN( iRendBufMajorMax, m_iLineMax ) );

    // return if no (major) extent
    if ( LINEDIR_CMP( m_iLineMax, m_iLineMin ) ) return TRUE;

    // number of steps to iterate
    m_cLineSteps = abs( m_iLineMax - m_iLineMin );

    // initial state for per-pixel line iterator
    m_iMajorCoord = m_iLineMin;

    // compute float versions of snapped coord data
    m_fX0 = (FLOAT)m_iX0 * 1.0F/16.0F;
    m_fY0 = (FLOAT)m_iY0 * 1.0F/16.0F;

    // compute linear function for 1/W (for perspective correction)
    m_fRHW0 = *(pVtx0+3);
    m_fRHW1 = *(pVtx1+3);

    FLOAT fDelta = ( m_fRHW1 - m_fRHW0 ) / m_fLineMajorLength;
    m_fRHWA = ( m_bLineXMajor ) ? ( fDelta ) : ( 0. );
    m_fRHWB = ( m_bLineXMajor ) ? ( 0. ) : ( fDelta );
    m_fRHWC = m_fRHW0 - ( m_fRHWA * m_fX0 ) - ( m_fRHWB * m_fY0 );

    return FALSE;
}

//-----------------------------------------------------------------------------
//
// DivRoundDown(A,B) = ceiling(A/B - 1/2)
//
// ceiling(A/B - 1/2) == floor(A/B + 1/2 - epsilon)
// == floor( (A + (B/2 - epsilon))/B )
//
// Does correct thing for all sign combinations of A and B.
//
//-----------------------------------------------------------------------------
static INT64
DivRoundDown(INT64 iA, INT32 iB)
{
    INT32 i = 0;
    static const INT32 iEps[3] =
    {
        1,      // iA > 0, iB > 0
        0,      // iA < 0, iB > 0  OR iA > 0, iB < 0
        1       // iA < 0, iB < 0
    };
    if (iA < 0)
    {
        i++;
        iA = -iA;
    }
    if (iB < 0)
    {
        i++;
        iB = -iB;
    }
    iA += (iB-iEps[i]) >> 1;
    iA /= iB;
    if (iEps[i] == 0)
        iA = -iA;
    return(iA);
}

//-----------------------------------------------------------------------------
//
// DoScanCnvLine - Walks the line major axis, computes the appropriate minor
// axis coordinate, and generates pixels.
//
//-----------------------------------------------------------------------------
void
RefRast::StepLine( void )
{
    // evaluate line function to compute minor coord for this major
    INT64 iMinorCoord =
        ( ( m_iLineEdgeFunc[0] * (INT64)(m_iMajorCoord<<4) ) + m_iLineEdgeFunc[1] );
    iMinorCoord = DivRoundDown(iMinorCoord, m_iLineEdgeFunc[2]<<4);

    // grab x,y
    m_iX[0] = m_bLineXMajor ? m_iMajorCoord : iMinorCoord;
    m_iY[0] = m_bLineXMajor ? iMinorCoord : m_iMajorCoord;

    // step major for next evaluation
    m_iMajorCoord += m_iLineStep;
}


///////////////////////////////////////////////////////////////////////////////
//
// Multi-Sample Controls
//
///////////////////////////////////////////////////////////////////////////////

#define _SetSampleDelta( _SampleNumber, _XOffset, _YOffset ) \
{ \
    m_SampleDelta[_SampleNumber][0] = ((INT32)((_XOffset)*16.F)); \
    m_SampleDelta[_SampleNumber][1] = ((INT32)((_YOffset)*16.F)); \
}

void
RefRast::SetSampleMode( UINT MultiSamples, BOOL bAntialias )
{
    switch (MultiSamples)
    {
    default:
    case 1:
        m_SampleCount = 1;
        _SetSampleDelta( 0, 0., 0. );
        break;

    case 4:
        m_SampleCount = 4;
        _SetSampleDelta( 0, -.25, -.25 );
        _SetSampleDelta( 1, +.25, -.25 );
        _SetSampleDelta( 2, +.25, +.25 );
        _SetSampleDelta( 3, -.25, +.25 );
        break;

    case 9:
        m_SampleCount = 9;
        _SetSampleDelta( 0, -.333, -.333 );
        _SetSampleDelta( 1, -.333,   0.0 );
        _SetSampleDelta( 2, -.333, +.333 );
        _SetSampleDelta( 3,   0.0, -.333 );
        _SetSampleDelta( 4,   0.0,   0.0 );
        _SetSampleDelta( 5,   0.0, +.333 );
        _SetSampleDelta( 6, +.333, -.333 );
        _SetSampleDelta( 7, +.333,   0.0 );
        _SetSampleDelta( 8, +.333, +.333 );
        break;
    }

    // if not FSAA then sample all at pixel center
    if (!bAntialias)
    {
        for (UINT Sample=0; Sample<m_SampleCount; Sample++)
        {
            _SetSampleDelta( Sample, 0., 0. );
        }
    }

    m_CurrentSample = 0;
    m_bSampleCovered[0][0] =
    m_bSampleCovered[0][1] =
    m_bSampleCovered[0][2] =
    m_bSampleCovered[0][3] = TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\rast\refrast.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// refrast.cpp
//
// Direct3D Reference Device - rasterizer miscellaneous
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// RDColor                                                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
void
RDColor::ConvertFrom( RDSurfaceFormat Type, const char* pSurfaceBits )
{
    UINT16 u16BITS;
    UINT8 u8BITS;

    switch (Type)
    {
    default:
    case RD_SF_NULL: return;
    case RD_SF_B8G8R8A8: *this = *((UINT32*)pSurfaceBits); break;
    case RD_SF_B8G8R8X8: *this = *((UINT32*)pSurfaceBits); A = 1.F; break;

    case RD_SF_B5G6R5:
        u16BITS = *((UINT16*)pSurfaceBits);
        R = ((u16BITS>>(6+5)) & 0x001F)/31.f;
        G = ((u16BITS>>   5) & 0x003F)/63.f;
        B = ((u16BITS      ) & 0x001F)/31.f;
        A = 1.F;
        break;

    case RD_SF_B5G5R5X1:
        u16BITS = *((UINT16*)pSurfaceBits);
        R = ((u16BITS>>(5+5)) & 0x001F)/31.f;
        G = ((u16BITS>>   5) & 0x001F)/31.f;
        B = ((u16BITS      ) & 0x001F)/31.f;
        A = 1.F;
        break;

    case RD_SF_B5G5R5A1:
        u16BITS = *((UINT16*)pSurfaceBits);
        R = ((u16BITS>>(5+5)) & 0x001F)/31.f;
        G = ((u16BITS>>   5) & 0x001F)/31.f;
        B = ((u16BITS      ) & 0x001F)/31.f;
        A = ( u16BITS & 0x8000 ) ? 1.f : 0.f;
        break;

    case RD_SF_B4G4R4A4:
        u16BITS = *((UINT16*)pSurfaceBits);
        R = ((u16BITS>>  (4+4)) & 0x000F)/15.f;
        G = ((u16BITS>>    (4)) & 0x000F)/15.f;
        B = ((u16BITS         ) & 0x000F)/15.f;
        A = ((u16BITS>>(4+4+4)) & 0x000F)/15.f;
        break;

    case RD_SF_B4G4R4X4:
        u16BITS = *((UINT16*)pSurfaceBits);
        R = ((u16BITS>>(4+4)) & 0x000F)/15.f;
        G = ((u16BITS>>  (4)) & 0x000F)/15.f;
        B = ((u16BITS       ) & 0x000F)/15.f;
        A = 1.f;
        break;

    case RD_SF_B8G8R8:
        R = *((UINT8*)pSurfaceBits+2)/255.f;
        G = *((UINT8*)pSurfaceBits+1)/255.f;
        B = *((UINT8*)pSurfaceBits+0)/255.f;
        A = 1.F;
        break;

    case RD_SF_L8:
        R = G = B = *((UINT8*)pSurfaceBits)/255.f;
        A = 1.F;
        break;

    case RD_SF_L8A8:
        u16BITS = *((UINT16*)pSurfaceBits);
        R = G = B = (UINT8)(0xff & u16BITS)/255.f;
        A = (UINT8)(0xff & (u16BITS >> 8))/255.f;
        break;

    case RD_SF_A8:
        R = G = B = 0.f;
        A = *((UINT8*)pSurfaceBits)/255.f;
        break;

    case RD_SF_B2G3R3:
        u8BITS = *((UINT8*)pSurfaceBits);
        R = ((u8BITS>>(3+2)) & 0x07)/7.f;
        G = ((u8BITS>>   2) & 0x07)/7.f;
        B = ((u8BITS      ) & 0x03)/3.f;
        A = 1.F;
        break;

    case RD_SF_L4A4:
        u16BITS = *((UINT8*)pSurfaceBits);
        R = G = B = (u16BITS & 0x0f)/15.f;
        A =    ((u16BITS>>4) & 0x0f)/15.f;
        break;

    case RD_SF_B2G3R3A8:
        u16BITS = *((UINT16*)pSurfaceBits);
        R = ((u16BITS>>(3+2)) & 0x07)/7.f;
        G = ((u16BITS>>   2) & 0x07)/7.f;
        B = ((u16BITS      ) & 0x03)/3.f;
        A = (UINT8)(0xff & (u16BITS >> 8))/255.f;
        break;

    case RD_SF_U8V8:
        {
            INT8 iDU = *(( INT8*)pSurfaceBits+0);
            INT8 iDV = *(( INT8*)pSurfaceBits+1);
            R = CLAMP_SIGNED8(iDU);     // fDU
            G = CLAMP_SIGNED8(iDV);     // fDV
            B = 1.0F;                   // fL
            A = 1.F;
        }
        break;

    case RD_SF_U16V16:
        {
            INT16 iDU = *(( INT16*)pSurfaceBits+0);
            INT16 iDV = *(( INT16*)pSurfaceBits+1);
            R = CLAMP_SIGNED16(iDU);     // fDU
            G = CLAMP_SIGNED16(iDV);     // fDV
            B = 1.0f;   // 1.0 here is intentional
            A = 1.0f;
        }
        break;

    case RD_SF_U5V5L6:
        {
            UINT16 u16BITS = *((UINT16*)pSurfaceBits);
            INT8 iDU = (INT8)(u16BITS & 0x1f);
            INT8 iDV = (INT8)((u16BITS>>5) & 0x1f);
            UINT8 uL = (UINT8)(u16BITS >> 10);
            R = CLAMP_SIGNED5(iDU);      // fDU
            G = CLAMP_SIGNED5(iDV);      // fDV
            // the unsigned uL is normalized with 2^N - 1, since this is the
            // largest representable value
            B = (FLOAT)uL * (1.0F/63.0F);       // fL
            A = 1.0f;
        }
        break;

    case RD_SF_U8V8L8X8:
        {
            INT8 iDU = *(( INT8*)pSurfaceBits+0);
            INT8 iDV = *(( INT8*)pSurfaceBits+1);
            UINT8 uL  = *((UINT8*)pSurfaceBits+2);
            R = CLAMP_SIGNED8(iDU);     // fDU
            G = CLAMP_SIGNED8(iDV);     // fDV
            // the unsigned uL is normalized with 2^N - 1, since this is the
            // largest representable value
            B = (FLOAT)uL * (1.0F/255.0F);      // fL
            A = 1.0f;
        }
        break;
    case RD_SF_U8V8W8Q8:
        {
            INT8 iDU = *(( INT8*)pSurfaceBits+0);
            INT8 iDV = *(( INT8*)pSurfaceBits+1);
            INT8 iDW = *(( INT8*)pSurfaceBits+2);
            INT8 iDQ = *(( INT8*)pSurfaceBits+3);
            // signed values are normalized with 2^(N-1), since -2^(N-1) can
            // be exactly expressed in N bits
            R = CLAMP_SIGNED8(iDU);     // fDU
            G = CLAMP_SIGNED8(iDV);     // fDV
            B = CLAMP_SIGNED8(iDW);     // fDW
            A = CLAMP_SIGNED8(iDQ);     // fDQ
        }
        break;
    case RD_SF_U10V11W11:
        {
            UINT32 u32BITS = *((UINT32*)pSurfaceBits);
            INT16 iDU = (INT16)((u32BITS>>(0    )) & 0x3FF);
            INT16 iDV = (INT16)((u32BITS>>(10   )) & 0x7FF);
            INT16 iDW = (INT16)((u32BITS>>(10+11)) & 0x7FF);

            // signed values are normalized with 2^(N-1), since -2^(N-1) can
            // be exactly expressed in N bits
            R = CLAMP_SIGNED10(iDU);    // fDU
            G = CLAMP_SIGNED11(iDV);    // fDV
            B = CLAMP_SIGNED11(iDW);    // fDW
            A = 1.0f;
        }
        break;
    case RD_SF_R10G10B10A2:
        {
            UINT32 u32BITS = *((UINT32*)pSurfaceBits);
            R = ((u32BITS>>(0    ))  & 0x3FF)/1023.f;
            G = ((u32BITS>>(10   ))  & 0x3FF)/1023.f;
            B = ((u32BITS>>(10+10))  & 0x3FF)/1023.f;
            A = ((u32BITS>>(10+10+10)) & 0x3)/3.f;
        }
    break;
    case RD_SF_R8G8B8A8:
        {
            R = *(( UINT8*)pSurfaceBits+0)/255.f;
            G = *(( UINT8*)pSurfaceBits+1)/255.f;
            B = *(( UINT8*)pSurfaceBits+2)/255.f;
            A = *(( UINT8*)pSurfaceBits+3)/255.f;
        }
    break;
    case RD_SF_R8G8B8X8:
        {
            R = *(( UINT8*)pSurfaceBits+0)/255.f;
            G = *(( UINT8*)pSurfaceBits+1)/255.f;
            B = *(( UINT8*)pSurfaceBits+2)/255.f;
            A = 1.f;
        }
    break;
    case RD_SF_R16G16:
        {
            R = *(( UINT16*)pSurfaceBits+0)/65535.f;
            G = *(( UINT16*)pSurfaceBits+1)/65535.f;
            B = 1.0f;   // 1.0 here is intentional
            A = 1.0f;
        }
    break;
    case RD_SF_U11V11W10:
        {
            UINT32 u32BITS = *((UINT32*)pSurfaceBits);
            INT16 iDU = (INT16)((u32BITS>>(0    )) & 0x7FF);
            INT16 iDV = (INT16)((u32BITS>>(11   )) & 0x7FF);
            INT16 iDW = (INT16)((u32BITS>>(11+11)) & 0x3FF);

            // signed values are normalized with 2^(N-1), since -2^(N-1) can
            // be exactly expressed in N bits
            R = CLAMP_SIGNED11(iDU);    // fDU
            G = CLAMP_SIGNED11(iDV);    // fDV
            B = CLAMP_SIGNED10(iDW);    // fDW
            A = 1.0f;
        }
    break;
    case RD_SF_U10V10W10A2:
        {
            UINT32 u32BITS = *((UINT32*)pSurfaceBits);
            INT16 iDU = (INT16)((u32BITS>>(0    )) & 0x3FF);
            INT16 iDV = (INT16)((u32BITS>>(10   )) & 0x3FF);
            INT16 iDW = (INT16)((u32BITS>>(10+10)) & 0x3FF);

            // signed values are normalized with 2^(N-1), since -2^(N-1) can
            // be exactly expressed in N bits
            R = CLAMP_SIGNED10(iDU);    // fDU
            G = CLAMP_SIGNED10(iDV);    // fDV
            B = CLAMP_SIGNED10(iDW);    // fDW

            // Note: The A component is treated as an unsigned component
            A = ((u32BITS>>(10+10+10)) & 0x3)/3.f; 
        }
    break;
    case RD_SF_U8V8X8A8:
        {
            INT8 iU = *(( INT8*)pSurfaceBits+0);
            INT8 iV = *(( INT8*)pSurfaceBits+1);
            
            // signed values are normalized with 2^(N-1), since -2^(N-1) can
            // be exactly expressed in N bits
            R = CLAMP_SIGNED8(iU);
            G = CLAMP_SIGNED8(iV);
            B = 1.0f;

            // Note: The A component is treated as unsigned 
            A = *(( INT8*)pSurfaceBits+3)/255.f;
        }
    break;
    case RD_SF_U8V8X8L8:
        {
            INT8 iU = *(( INT8*)pSurfaceBits+0);
            INT8 iV = *(( INT8*)pSurfaceBits+1);
            INT8 iL = *(( INT8*)pSurfaceBits+3);
            
            // signed values are normalized with 2^(N-1), since -2^(N-1) can
            // be exactly expressed in N bits
            R = CLAMP_SIGNED8(iU);
            G = CLAMP_SIGNED8(iV);
            B = CLAMP_SIGNED8(iL);
            A = 1.0f;
        }
    break;
    // shadow map texture formats (read only, not needed for ConvertTo)
    case RD_SF_Z16S0:
        {
            UINT16 u16BITS = *((UINT16*)pSurfaceBits);
            R = 0.0F;
            G = (FLOAT)u16BITS * (1.0F/(FLOAT)0xffff);
            B = 0.0F;
            A = 1.0f;
        }
        break;

    case RD_SF_Z24S8:
    case RD_SF_Z24X8:
    case RD_SF_Z24X4S4:
        {
            UINT32 u32BITS = *((UINT32*)pSurfaceBits);
            R = 0.0F;
            G = (FLOAT)(u32BITS>>8) * (1.0F/(FLOAT)0xffffff);
            B = 0.0F;
            A = 1.0f;
        }
        break;

    case RD_SF_S8Z24:
    case RD_SF_X8Z24:
    case RD_SF_X4S4Z24:
        {
            UINT32 u32BITS = *((UINT32*)pSurfaceBits);
            R = 0.0F;
            G = (FLOAT)(u32BITS&0x00ffffff) * (1.0F/(FLOAT)0xffffff);
            B = 0.0F;
            A = 1.0f;
        }
        break;

    case RD_SF_Z15S1:
        {
            UINT16 u16BITS = *((UINT16*)pSurfaceBits);
            R = 0.0F;
            G = (FLOAT)(u16BITS>>1) * (1.0F/(FLOAT)0x7fff);
            B = 0.0F;
            A = 1.0f;
        }
        break;

    case RD_SF_S1Z15:
        {
            UINT16 u16BITS = *((UINT16*)pSurfaceBits);
            R = 0.0F;
            G = (FLOAT)(u16BITS&0x7fff) * (1.0F/(FLOAT)0x7fff);
            B = 0.0F;
            A = 1.0f;
        }
        break;

    case RD_SF_Z32S0:
        {
            UINT32 u32BITS = *((UINT32*)pSurfaceBits);
            R = 0.0F;
            G = (FLOAT)u32BITS * (1.0F/(FLOAT)0xffffffff);
            B = 0.0F;
            A = 1.0f;
        }
        break;
    }
}

// Convert surface type format to RDColor
void
RDColor::ConvertTo( RDSurfaceFormat Type, float fRoundOffset, char* pSurfaceBits ) const
{
    int iR, iG, iB, iA;

    switch (Type)
    {
    case RD_SF_B8G8R8A8:
        *((UINT8*)pSurfaceBits+0) = (UINT8)((FLOAT)B * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+1) = (UINT8)((FLOAT)G * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+2) = (UINT8)((FLOAT)R * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+3) = (UINT8)((FLOAT)A * 255. + fRoundOffset);
        break;

    case RD_SF_B8G8R8X8:
        *((UINT8*)pSurfaceBits+0) = (UINT8)((FLOAT)B * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+1) = (UINT8)((FLOAT)G * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+2) = (UINT8)((FLOAT)R * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+3) = 0x00;
        break;

    case RD_SF_B8G8R8:
        *((UINT8*)pSurfaceBits+0) = (UINT8)((FLOAT)B * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+1) = (UINT8)((FLOAT)G * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+2) = (UINT8)((FLOAT)R * 255. + fRoundOffset);
        break;

    case RD_SF_B4G4R4A4:
        iA = (FLOAT)A * 15. + fRoundOffset;
        iR = (FLOAT)R * 15. + fRoundOffset;
        iG = (FLOAT)G * 15. + fRoundOffset;
        iB = (FLOAT)B * 15. + fRoundOffset;
        *((UINT16*)pSurfaceBits) = (iA<<12) | (iR<<8) | (iG<<4) | iB;
        break;

    case RD_SF_B4G4R4X4:
        iR = (FLOAT)R * 15. + fRoundOffset;
        iG = (FLOAT)G * 15. + fRoundOffset;
        iB = (FLOAT)B * 15. + fRoundOffset;
        *((UINT16*)pSurfaceBits) = (0x00<<12) | (iR<<8) | (iG<<4) | iB;
        break;

    case RD_SF_B5G6R5:
        iR = (FLOAT)R * 31. + fRoundOffset; // apply rounding bias then truncate
        iG = (FLOAT)G * 63. + fRoundOffset;
        iB = (FLOAT)B * 31. + fRoundOffset;
        *((UINT16*)pSurfaceBits) =            (iR<<11) | (iG<<5) | iB;
        break;

    case RD_SF_B5G5R5A1:
        iA = (FLOAT)A *  1. + fRoundOffset;
        iR = (FLOAT)R * 31. + fRoundOffset;
        iG = (FLOAT)G * 31. + fRoundOffset;
        iB = (FLOAT)B * 31. + fRoundOffset;
        *((UINT16*)pSurfaceBits) = (iA<<15) | (iR<<10) | (iG<<5) | iB;
        break;

    case RD_SF_B5G5R5X1:
        iR = (FLOAT)R * 31. + fRoundOffset;
        iG = (FLOAT)G * 31. + fRoundOffset;
        iB = (FLOAT)B * 31. + fRoundOffset;
        *((UINT16*)pSurfaceBits) = (iR<<10) | (iG<<5) | iB;
        break;

    case RD_SF_B2G3R3:
        iR = (FLOAT)R * 7. + fRoundOffset;
        iG = (FLOAT)G * 7. + fRoundOffset;
        iB = (FLOAT)B * 3. + fRoundOffset;
        *((UINT8*)pSurfaceBits) = (iR<<5) | (iG<<2) | iB;
        break;

    case RD_SF_B2G3R3A8:
        iA = (FLOAT)A * 255. + fRoundOffset;
        iR = (FLOAT)R * 7. + fRoundOffset;
        iG = (FLOAT)G * 7. + fRoundOffset;
        iB = (FLOAT)B * 3. + fRoundOffset;
        *((UINT16*)pSurfaceBits) = (iA<<8) | (iR<<5) | (iG<<2) | iB;
        break;

    case RD_SF_R10G10B10A2:
        iR = (FLOAT)R * 1023.f + fRoundOffset;
        iG = (FLOAT)G * 1023.f + fRoundOffset;
        iB = (FLOAT)B * 1023.f + fRoundOffset;
        iA = (FLOAT)A * 3.f + fRoundOffset;
        *((UINT32*)pSurfaceBits) = (iA<<(10+10+10)) | (iB<<(10+10)) | (iG<<10) | iR;
        break;

    case RD_SF_R8G8B8A8:
        *((UINT8*)pSurfaceBits+0) = (UINT8)((FLOAT)R * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+1) = (UINT8)((FLOAT)G * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+2) = (UINT8)((FLOAT)B * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+3) = (UINT8)((FLOAT)A * 255. + fRoundOffset);
        break;

    case RD_SF_R8G8B8X8:
        *((UINT8*)pSurfaceBits+0) = (UINT8)((FLOAT)R * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+1) = (UINT8)((FLOAT)G * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+2) = (UINT8)((FLOAT)B * 255. + fRoundOffset);
        *((UINT8*)pSurfaceBits+3) = 0x00;
        break;

    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\rast\refrasti.hpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// refrasti.hpp
//
// Direct3D Reference Device - Main Internal Header File
//
///////////////////////////////////////////////////////////////////////////////
#ifndef  _REFRASTI_HPP
#define  _REFRASTI_HPP

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Texture Mapping Utility Functions                                         //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// various approximations and tricks to speed up the texture map coverage
// computations
//

// Integer value of first exponent bit in a float.  Provides a scaling factor
// for exponent values extracted directly from float representation.
#define FLOAT_EXPSCALE          ((FLOAT)0x00800000)
#define FLOAT_OOEXPSCALE        ((FLOAT)(1.0 / (double)FLOAT_EXPSCALE))

// Integer representation of 1.0f.
#define INT32_FLOAT_ONE         0x3f800000

static inline FLOAT
RR_LOG2(FLOAT f)
{
    return (FLOAT)(AS_INT32(f) - INT32_FLOAT_ONE) * FLOAT_OOEXPSCALE;
}

static inline FLOAT
RR_ALOG2(FLOAT f)
{
    INT32 i = (INT32)(f * FLOAT_EXPSCALE) + INT32_FLOAT_ONE;
    return AS_FLOAT((long int)i);
}

static inline FLOAT
RR_ABSF(FLOAT f)
{
    UINT32 i = AS_UINT32(f) & 0x7fffffff;
    return AS_FLOAT((unsigned long int)i);
}

static inline FLOAT
RR_SQRT(FLOAT f)
{
    INT32 i = (AS_INT32(f) >> 1) + (INT32_FLOAT_ONE >> 1);
    return AS_FLOAT((long int)i);
}

//
// Steve Gabriel's version of an octagonal approximation euclidian distance -
// return is approximating sqrt(fX*fX + fY*fY)
//
static inline FLOAT
RR_LENGTH(FLOAT fX, FLOAT fY)
{
    fX = RR_ABSF(fX);
    fY = RR_ABSF(fY);
    return ((11.0f/32.0f)*(fX + fY) + (21.0f/32.0f)*max(fX, fY));
}

// compute level of detail (texel->pixel coverage)
void
ComputeSimpleLevelOfDetail(
    const RDTextureCoord& TCoord,   // inputs
    FLOAT& fLOD );                  // outputs

void
ComputeCubeMapLevelOfDetail(
    const RDTextureCoord& TCoord,   // inputs
    FLOAT& fLOD );                  // outputs

void
ComputeAnisotropicLevelOfDetail(
    const RDTextureCoord& TCoord, FLOAT fMaxAniso,  //  inputs
    FLOAT& fLOD, FLOAT& fRatio, FLOAT fDelta[] );   //  outputs

// color interpolation utilities
void LerpColor(RDColor& Color,
    const RDColor& Color0, const RDColor& Color1, UINT8 uT);
void BiLerpColor( RDColor& OutColor,
    const RDColor& Color00, const RDColor& Color01,
    const RDColor& Color10, const RDColor& Color11,
    UINT8 uA, UINT8 uB);
void BiLerpColor3D( RDColor& OutColor,
    const RDColor& Color000, const RDColor& Color010,
    const RDColor& Color100, const RDColor& Color110,
    const RDColor& Color001, const RDColor& Color011,
    const RDColor& Color101, const RDColor& Color111,
    UINT8 uA, UINT8 uB, UINT8 uC);

///////////////////////////////////////////////////////////////////////////////
#endif  // _REFRASTI_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\rast\sources.inc ===
TARGETNAME = refrast
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES);..\..\drv

SOURCES = \
        ..\refrast.cpp\
        ..\setup.cpp\
        ..\rastprim.cpp\
        ..\rastattr.cpp\
        ..\rastedge.cpp\
        ..\scancnv.cpp\
        ..\texfilt.cpp\
        ..\ctexfilt.cpp\
        ..\texstage.cpp\
        ..\pixproc.cpp\
        ..\pshader.cpp\
        ..\psutil.cpp\
        ..\psexec.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\rast\scancnv.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// scancnv.cpp
//
// Direct3D Reference Device - Primitive Scan Conversion
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Scan Conversion Utilities                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// ComputeFogIntensity - Computes scalar fog intensity value and writes it to
// the RDPixel.FogIntensity value.
//
//-----------------------------------------------------------------------------
FLOAT
RefRast::ComputeFogIntensity( FLOAT fX, FLOAT fY )
{
    if ( !m_pRD->GetRS()[D3DRS_FOGENABLE] )
    {
        // fog blending not enabled, so don't need to compute fog intensity
        return 0.;
    }

    // compute fog intensity

    // select between vertex and table fog - vertex fog is selected if
    // fog is enabled but the renderstate fog table mode is disabled
    if ( D3DFOG_NONE == m_pRD->GetRS()[D3DRS_FOGTABLEMODE] )
    {
        // table fog disabled, so use interpolated vertex fog value for fog intensity
        FLOAT tmpFloat[4];
        m_Attr[RDATTR_FOG].Sample( tmpFloat, fX, fY );
        return tmpFloat[0];
    }

    // here for table fog, so compute fog from Z or W
    FLOAT fFogDensity, fPow;
    FLOAT fFogStart, fFogEnd;

    // select fog index - this is either Z or W depending on the W range
    //
    // use Z if projection matrix is set to an affine projection, else use W
    // (both for perspective projection and an unset projection matrix - the
    // latter is preferred for legacy content which uses TLVERTEX)
    //
    FLOAT fFogIndex =
        ( ( 1.f == m_pRD->m_pRenderTarget->m_fWRange[0] ) &&
          ( 1.f == m_pRD->m_pRenderTarget->m_fWRange[1] ) )
        ? ( m_Attr[RDATTR_DEPTH].Sample( fX, fY ) )
        : ( SampleAndInvertRHW( fX, fY ) ); // use W for non-affine projection
    FLOAT fFogIntensity;

    switch ( m_pRD->GetRS()[D3DRS_FOGTABLEMODE] )
    {
    case D3DFOG_LINEAR:
        fFogStart = m_pRD->GetRSf()[D3DRS_FOGSTART];
        fFogEnd   = m_pRD->GetRSf()[D3DRS_FOGEND];
        if (fFogIndex >= fFogEnd)
        {
            fFogIntensity = 0.0f;
        }
        else if (fFogIndex <= fFogStart)
        {
            fFogIntensity = 1.0f;
        }
        else
        {
            fFogIntensity = ( fFogEnd - fFogIndex ) / ( fFogEnd - fFogStart );
        }
        break;

    case D3DFOG_EXP:
        fFogDensity = m_pRD->GetRSf()[D3DRS_FOGDENSITY];
        fPow = fFogDensity * fFogIndex;
        // note that exp(-x) returns a result in the range (0.0, 1.0]
        // for x >= 0
        fFogIntensity = (float)exp( -fPow );
        break;

    case D3DFOG_EXP2:
        fFogDensity = m_pRD->GetRSf()[D3DRS_FOGDENSITY];
        fPow = fFogDensity * fFogIndex;
        fFogIntensity = (float)exp( -(fPow*fPow) );
        break;
    }
    return fFogIntensity;
}

//-----------------------------------------------------------------------------
//
// SnapDepth - Snap off extra depth bits by converting to/from buffer format
// - necessary to make depth buffer equality tests function correctly
//
//-----------------------------------------------------------------------------
void RefRast::SnapDepth()
{
    if (m_pRD->m_pRenderTarget->m_pDepth)
    {
        switch ( m_pRD->m_pRenderTarget->m_pDepth->GetSurfaceFormat() )
        {
        case RD_SF_Z16S0: m_Depth[m_iPix] = UINT16( m_Depth[m_iPix] ); break;
        case RD_SF_Z24X4S4:
        case RD_SF_Z24X8:
        case RD_SF_Z24S8: m_Depth[m_iPix] = UINT32( m_Depth[m_iPix] ); break;
        case RD_SF_Z15S1: m_Depth[m_iPix] = UINT16( m_Depth[m_iPix] ); break;
        case RD_SF_Z32S0: m_Depth[m_iPix] = UINT32( m_Depth[m_iPix] ); break;
        case RD_SF_S1Z15: m_Depth[m_iPix] = UINT16( m_Depth[m_iPix] ); break;
        case RD_SF_X4S4Z24:
        case RD_SF_X8Z24:
        case RD_SF_S8Z24: m_Depth[m_iPix] = UINT32( m_Depth[m_iPix] ); break;
        }
    }
}

//-----------------------------------------------------------------------------
//
// DoScanCnvGenPixel - This is called for each 2x2 grid of pixels, and extracts and
// processes attributes from the interpolator state, and passes the pixels on to
// the pixel processing module.
//
//-----------------------------------------------------------------------------
void
RefRast::DoScanCnvGenPixels( void )
{
    for ( m_iPix = 0; m_iPix < 4; m_iPix++ )
    {
        FLOAT fPixX = (FLOAT)m_iX[m_iPix];
        FLOAT fPixY = (FLOAT)m_iY[m_iPix];

        m_fW[m_iPix] = SampleAndInvertRHW( fPixX, fPixY );

        // RHW needed for non-in pixels, but nothing else so bail
        if ( !m_bPixelIn[m_iPix] ) continue;

        // get depth from clamp interpolator and clamp
        if ( m_pRD->GetRS()[D3DRS_ZENABLE] ||
             m_pRD->GetRS()[D3DRS_FOGENABLE])
        {
            if (m_pRD->m_pRenderTarget->m_pDepth)
                m_Depth[m_iPix].SetSType(m_pRD->m_pRenderTarget->m_pDepth->GetSurfaceFormat());

            // evaluate depth at all sample locations
            do
            {
                // compute sample location
                FLOAT fSampX = GetCurrentSamplefX(m_iPix);
                FLOAT fSampY = GetCurrentSamplefY(m_iPix);

                if ( D3DZB_USEW == m_pRD->GetRS()[D3DRS_ZENABLE] )
                {
                    // depth buffering with W value
                    FLOAT fW = SampleAndInvertRHW( fSampX, fSampY );
                    // apply normalization to get to 0. to 1. range
                    fW = (fW - m_pRD->m_fWBufferNorm[0]) * m_pRD->m_fWBufferNorm[1];
                    m_Depth[m_iPix] = fW;
                }
                else
                {
                    // depth buffering with Z value
                    m_Depth[m_iPix] =
                        m_Attr[RDATTR_DEPTH].Sample( fSampX, fSampY );
                }

                // snap off extra bits by converting to/from buffer format - necessary
                // to make depth buffer equality tests function correctly
                SnapDepth();

                m_SampleDepth[m_CurrentSample][m_iPix] = m_Depth[m_iPix];

            } while (NextSample());
        }

        // set pixel diffuse and specular color from clamped interpolator values
        m_Attr[RDATTR_COLOR].Sample( m_InputReg[0][m_iPix], fPixX, fPixY );
        m_Attr[RDATTR_SPECULAR].Sample( m_InputReg[1][m_iPix], fPixX, fPixY );

        // compute fog intensity
        m_FogIntensity[m_iPix] = ComputeFogIntensity( fPixX, fPixY );

    }
    DoPixels();
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Triangle Scan Conversion                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// DoScanCnvTri - Scans the bounding box of the triangle and generates pixels.
//
// Does 4 pixels at a time in a 2x2 grid.
//
//-----------------------------------------------------------------------------
void
RefRast::DoScanCnvTri( int iEdgeCount )
{
    m_iEdgeCount = iEdgeCount;

    //
    // do simple scan of surface-intersected triangle bounding box
    //
    for ( m_iY[0] = m_iYMin;
          m_iY[0] <= m_iYMax;
          m_iY[0] += 2 )
    {
        m_iY[1] = m_iY[0]+0;
        m_iY[2] = m_iY[0]+1;
        m_iY[3] = m_iY[0]+1;
        BOOL bPartialY = (m_iY[3] > m_iYMax);

        for ( m_iX[0] = m_iXMin;
              m_iX[0] <= m_iXMax;
              m_iX[0] += 2 )
        {
            m_iX[1] = m_iX[0]+1;
            m_iX[2] = m_iX[0]+0;
            m_iX[3] = m_iX[0]+1;
            BOOL bPartialX = (m_iX[3] > m_iXMax);

            m_bPixelIn[0] = EvalPixelPosition(0);
            m_bPixelIn[1] = ( bPartialX ) ? ( FALSE ) : EvalPixelPosition(1);
            m_bPixelIn[2] = ( bPartialY ) ? ( FALSE ) : EvalPixelPosition(2);
            m_bPixelIn[3] = ( bPartialX || bPartialY ) ? ( FALSE ) : EvalPixelPosition(3);

            if ( m_bPixelIn[0] ||
                 m_bPixelIn[1] ||
                 m_bPixelIn[2] ||
                 m_bPixelIn[3] )
            {
                // at least one pixel in
                DoScanCnvGenPixels();
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Line Scan Conversion                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//----------------------------------------------------------------------------
//
// LinePatternStateMachine
//
// Runs the line pattern state machine and returns TRUE if the pixel is to be
// drawn, false otherwise.  Always returns true if wRepeatFactor is 0, which
// means pattern is disabled.
//
//----------------------------------------------------------------------------

// NOTE: The implementation of LinePattern in RefDev is incorrect. Please refer 
//       to the DDK documentation for the right implementation.
static BOOL
LinePatternStateMachine(DWORD dwLinePattern, WORD& wRepeati, WORD& wPatterni)
{
    union
    {
        D3DLINEPATTERN LPat;
        DWORD dwLPat;
    } LinePat;
    LinePat.dwLPat = dwLinePattern;

    if (LinePat.LPat.wRepeatFactor)
    {
        WORD wBit = (LinePat.LPat.wLinePattern >> wPatterni) & 1;
        if (++wRepeati >= LinePat.LPat.wRepeatFactor)
        {
            wRepeati = 0;
            wPatterni = (wPatterni+1) & 0xf;
        }
        return (BOOL)wBit;
    }
    else
    {
        return TRUE;
    }
}

//-----------------------------------------------------------------------------
//
// DoScanCnvLine - Walks the line major axis, computes the appropriate minor
// axis coordinate, and generates pixels.
//
//-----------------------------------------------------------------------------
void
RefRast::DoScanCnvLine( void )
{
    // state for line pattern state machine
    WORD wRepeati = 0;
    WORD wPatterni = 0;

    m_bPixelIn[0] = TRUE;
    m_bPixelIn[1] =
    m_bPixelIn[2] =
    m_bPixelIn[3] = FALSE;

    for ( int cStep = 0; cStep <= m_cLineSteps; cStep++ )
    {
        // compute next x,y location in line
        StepLine();

        // check if the point is inside the viewport
        if ( ( m_iX[0] >= m_pRD->m_pRenderTarget->m_Clip.left   ) &&
             ( m_iX[0] <= m_pRD->m_pRenderTarget->m_Clip.right  ) &&
             ( m_iY[0] >= m_pRD->m_pRenderTarget->m_Clip.top    ) &&
             ( m_iY[0] <= m_pRD->m_pRenderTarget->m_Clip.bottom ) )
        {
            // The line pattern should have been walked in from its origin, which may have been
            // offscreen, to be completely correct.
            if (LinePatternStateMachine(m_pRD->GetRS()[D3DRS_LINEPATTERN], wRepeati, wPatterni))
            {
                DoScanCnvGenPixels();
            }
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\rast\setup.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// setup.cpp
//
// Direct3D Reference Device - Primitive Setup
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
//-----------------------------------------------------------------------------

// texture coordinates for use in point sprite mode
static const
FLOAT g_PSTexCoord[3][4] =
{
    { 0., 0., 0., 1. },
    { 1., 0., 0., 1. },
    { 0., 1., 0., 1. },
};


void
RefRast::SetAttributeFunctions(
    const RDVertex& Vtx0,
    const RDVertex& Vtx1,
    const RDVertex& Vtx2 )
{
    _ASSERT( Vtx0.m_qwFVF, "0x0 FVF code in setup" );

    // compute depth function
    if ( D3DZB_USEW == m_pRD->GetRS()[D3DRS_ZENABLE] )
    {
        FLOAT fW0 = 1./Vtx0.GetRHW();
        FLOAT fW1 = 1./Vtx1.GetRHW();
        FLOAT fW2 = 1./Vtx2.GetRHW();
        m_Attr[RDATTR_DEPTH].Setup( &fW0, &fW1, &fW2 );
    }
    else
    {
        FLOAT z0 = Vtx0.GetZ();
        FLOAT z1 = Vtx1.GetZ();
        FLOAT z2 = Vtx2.GetZ();

        m_Attr[RDATTR_DEPTH].Setup( &z0, &z1, &z2 );
    }

    if( m_pRD->GetRS()[D3DRS_SHADEMODE] == D3DSHADE_FLAT )
    {
        m_Attr[RDATTR_COLOR].m_bFlatShade = TRUE;
        m_Attr[RDATTR_SPECULAR].m_bFlatShade = TRUE;
    }
    else
    {
        m_Attr[RDATTR_COLOR].m_bFlatShade = FALSE;
        m_Attr[RDATTR_SPECULAR].m_bFlatShade = FALSE;
    }

    // compute color functions
    m_Attr[RDATTR_COLOR].Setup(
        Vtx0.GetDiffuse(), Vtx1.GetDiffuse(), Vtx2.GetDiffuse() );

    m_Attr[RDATTR_SPECULAR].Setup(
        Vtx0.GetSpecular(), Vtx1.GetSpecular(), Vtx2.GetSpecular() );

    // compute vertex fog function
    if ( m_pRD->GetRS()[D3DRS_FOGENABLE] &&
         ( m_pRD->GetRS()[D3DRS_FOGTABLEMODE] == D3DFOG_NONE ) )
    {
        FLOAT fF0 = Vtx0.GetFog();
        FLOAT fF1 = Vtx1.GetFog();
        FLOAT fF2 = Vtx2.GetFog();
        m_Attr[RDATTR_FOG].Setup( &fF0, &fF1, &fF2 );
    }

    for (INT32 iStage = 0; iStage < D3DHAL_TSS_MAXSTAGES; iStage++)
    {
        FLOAT TexCrd0[4];
        FLOAT TexCrd1[4];
        FLOAT TexCrd2[4];

        if( !(m_pRD->m_ReferencedTexCoordMask & (1<<iStage) ) )
            continue;
        
        if (m_pRD->m_bPointSprite)
        {
            // set texture coords to map full range
            m_Attr[RDATTR_TEXTURE0+iStage].Setup( &g_PSTexCoord[0][0], 
                                                  &g_PSTexCoord[1][0], 
                                                  &g_PSTexCoord[2][0]);
        }
        else
        {
            // TCI pass through
            UINT CoordSet;
            if( m_pRD->m_bOverrideTCI )
            {
                CoordSet = iStage;
            }
            else
            {
                CoordSet = (UINT)m_pRD->GetTSS(iStage)[D3DTSS_TEXCOORDINDEX] & 0x0000FFFF;
            }

            for( UINT i=0; i<4; i++)
            {
                TexCrd0[i] = Vtx0.GetTexCrd( i, CoordSet );
                TexCrd1[i] = Vtx1.GetTexCrd( i, CoordSet );
                TexCrd2[i] = Vtx2.GetTexCrd( i, CoordSet );
            }
            
            if( m_pRD->GetTSS(iStage)[D3DTSS_TEXTURETRANSFORMFLAGS] & 
                D3DTTFF_PROJECTED )
            {
                // Always divide by the 4th coordinate while projecting.
                m_Attr[RDATTR_TEXTURE0+iStage].SetProjection(3);

                // For the projection, fix up the 4th coordinate
                // for the fixed function vertex-shaders.
                if( m_pRD->m_pCurrentVShader->IsFixedFunction() )
                {
                    TexCrd0[3] = Vtx0.GetLastTexCrd( CoordSet );
                    TexCrd1[3] = Vtx1.GetLastTexCrd( CoordSet );
                    TexCrd2[3] = Vtx2.GetLastTexCrd( CoordSet );
                }
            }
            else
            {
                m_Attr[RDATTR_TEXTURE0+iStage].SetProjection(0);
            }

            m_Attr[RDATTR_TEXTURE0+iStage].SetWrapFlags(
                m_pRD->GetRS()[D3DRS_WRAP0+CoordSet] );

            m_Attr[RDATTR_TEXTURE0+iStage].Setup( TexCrd0, TexCrd1, TexCrd2 );
        }
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Triangle Drawing
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// DrawTriangle - Takes three vertices and does triangle setup, setting the
// primitive, attribute, and edge structures which are input to the triangle
// scanner, then invokes the scan conversion.
//
// wFlags - Edge (and other) flags.
//
//-----------------------------------------------------------------------------

void
RefDev::DrawTriangle(
   RDVertex* pV0, RDVertex* pV1, RDVertex* pV2, WORD wFlags )
{
    UpdateRastState();

    // sort to ensure consistent attribute evaluation
    // for identical vertices passed in different order
    RDVertex* pV[3];
    {
        FLOAT fD0 = *(pV0->GetPtrXYZ()+0) + *(pV0->GetPtrXYZ()+1);
        FLOAT fD1 = *(pV1->GetPtrXYZ()+0) + *(pV1->GetPtrXYZ()+1);
        FLOAT fD2 = *(pV2->GetPtrXYZ()+0) + *(pV2->GetPtrXYZ()+1);
        UINT MinVtx = 0;
        if ( (fD1 < fD0) )                MinVtx = 1;
        if ( (fD2 < fD0) && (fD2 < fD1) ) MinVtx = 2;
        switch (MinVtx)
        {
        case 0: pV[0] = pV0; pV[1] = pV1; pV[2] = pV2; m_Rast.m_iFlatVtx = 0; break;
        case 1: pV[0] = pV1; pV[1] = pV2; pV[2] = pV0; m_Rast.m_iFlatVtx = 2; break;
        case 2: pV[0] = pV2; pV[1] = pV0; pV[2] = pV1; m_Rast.m_iFlatVtx = 1; break;
        }
    }

    if ( m_Rast.PerTriangleSetup(
          pV[0]->GetPtrXYZ(), pV[1]->GetPtrXYZ(), pV[2]->GetPtrXYZ(),
          m_dwRenderState[D3DRS_CULLMODE],
          &(m_pRenderTarget->m_Clip)) )
    {
        return; // discarded due to degenerate, cull, or no viewport overlap
    }

    // process point and wireframe fill mode
    if ( m_dwRenderState[D3DRS_FILLMODE] == D3DFILL_POINT )
    {
        if( m_dwRenderState[D3DRS_SHADEMODE] == D3DSHADE_FLAT )
        {
            // Colors from the first vertex are used for all vertices in flat
            // shading mode
            
            RDCOLOR4 diffuse1 = pV1->m_diffuse;
            RDCOLOR4 diffuse2 = pV2->m_diffuse;
            RDCOLOR4 specular1 = pV1->m_specular;
            RDCOLOR4 specular2 = pV2->m_specular;

            // Colors are modified in place
            pV1->m_diffuse  = pV0->m_diffuse;
            pV1->m_specular = pV0->m_specular;
            pV2->m_diffuse  = pV0->m_diffuse;
            pV2->m_specular = pV0->m_specular;

            DrawPoint( pV0 );
            DrawPoint( pV1 );
            DrawPoint( pV2 );

            // Restore old color values
            pV1->m_diffuse  = diffuse1;
            pV2->m_diffuse  = diffuse2;
            pV1->m_specular = specular1;
            pV2->m_specular = specular2;
        }
        else
        {
            DrawPoint( pV0 );
            DrawPoint( pV1 );
            DrawPoint( pV2 );
        }
        return;
    }
    else if ( m_dwRenderState[D3DRS_FILLMODE] == D3DFILL_WIREFRAME )
    {
        // use original vertex pointers for lines so edge enables line up
        if ( wFlags & D3DTRIFLAG_EDGEENABLE1 ) { DrawLine( pV0, pV1, pV0 ); }
        if ( wFlags & D3DTRIFLAG_EDGEENABLE2 ) { DrawLine( pV1, pV2, pV0 ); }
        if ( wFlags & D3DTRIFLAG_EDGEENABLE3 ) { DrawLine( pV2, pV0, pV0 ); }
        return;
    }

    // compute edge functions
    m_Rast.m_Edge[0].Set( m_Rast.m_iDet > 0,
        m_Rast.m_iX0, m_Rast.m_iY0, m_Rast.m_iX1, m_Rast.m_iY1 );
    m_Rast.m_Edge[1].Set( m_Rast.m_iDet > 0,
        m_Rast.m_iX1, m_Rast.m_iY1, m_Rast.m_iX2, m_Rast.m_iY2 );
    m_Rast.m_Edge[2].Set( m_Rast.m_iDet > 0,
        m_Rast.m_iX2, m_Rast.m_iY2, m_Rast.m_iX0, m_Rast.m_iY0 );

    // compute attribute functions
    m_Rast.SetAttributeFunctions( *pV[0], *pV[1], *pV[2] );

    // not culled, so rasterize it
    m_Rast.DoScanCnvTri(3);
}

///////////////////////////////////////////////////////////////////////////////
//
// Point Drawing
//
///////////////////////////////////////////////////////////////////////////////

void
RefDev::DrawPoint(
   RDVertex* pvV0Public )
{
    UpdateRastState();

    // copy pointsprite enable for duration of point rendering (only)
    m_bPointSprite = m_dwRenderState[D3DRS_POINTSPRITEENABLE];

    RDVertex V0, V1, V2;
    V0 = V1 = V2 = *pvV0Public;

    FLOAT fS = 1.0f;
    if (pvV0Public->m_qwFVF & D3DFVF_PSIZE)
    {
        fS = V0.GetPointSize();
    }
    else
    {
        fS = m_fRenderState[D3DRS_POINTSIZE];
    }
    fS = MAX( m_fRenderState[D3DRS_POINTSIZE_MIN], fS );
    fS = MIN( MIN(m_fRenderState[D3DRS_POINTSIZE_MAX], RD_MAX_POINT_SIZE), fS );

    // divide point size by 2 to get delta
    fS *= .5f;

    // Move points based on point size
    FLOAT *pXY = V0.GetPtrXYZ();
    FLOAT fX3 = pXY[0] + fS;
    FLOAT fY3 = pXY[1] + fS;
    pXY[0] += -fS;
    pXY[1] += -fS;

    pXY = V1.GetPtrXYZ();
    pXY[0] +=  fS;
    pXY[1] += -fS;

    pXY = V2.GetPtrXYZ();
    pXY[0] += -fS;
    pXY[1] +=  fS;


    if ( m_Rast.PerTriangleSetup(
          V0.GetPtrXYZ(), V1.GetPtrXYZ(), V2.GetPtrXYZ(),
          D3DCULL_NONE, // never cull points
          &(m_pRenderTarget->m_Clip)) )
    {
        m_bPointSprite = FALSE;
        return;
    }

    // compute edge functions
    INT32 iX3 = FloatToNdot4( fX3 );
    INT32 iY3 = FloatToNdot4( fY3 );
#define DP_POINT_UL  m_Rast.m_iX0, m_Rast.m_iY0 // upper left
#define DP_POINT_UR  m_Rast.m_iX1, m_Rast.m_iY1 // upper right
#define DP_POINT_LL  m_Rast.m_iX2, m_Rast.m_iY2 // lower left
#define DP_POINT_LR  iX3, iY3                       // lower right
    m_Rast.m_Edge[0].Set( m_Rast.m_iDet > 0, DP_POINT_UL, DP_POINT_UR );
    m_Rast.m_Edge[1].Set( m_Rast.m_iDet > 0, DP_POINT_UR, DP_POINT_LR );
    m_Rast.m_Edge[2].Set( m_Rast.m_iDet > 0, DP_POINT_LR, DP_POINT_LL );
    m_Rast.m_Edge[3].Set( m_Rast.m_iDet > 0, DP_POINT_LL, DP_POINT_UL );

    // compute attribute functions
    m_Rast.SetAttributeFunctions( V0, V1, V2 );

    // not culled, so rasterize it
    m_Rast.DoScanCnvTri(4);

    m_bPointSprite = FALSE;
    return;
}

///////////////////////////////////////////////////////////////////////////////
//
// Line Drawing
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
//
// DrawLine - Takes two vertices and draws a line.
//
//-----------------------------------------------------------------------------
void
RefDev::DrawLine(
   RDVertex* pV0, RDVertex* pV1, RDVertex* pVFlat )
{
    UpdateRastState();

    if( m_Rast.m_SampleCount > 1 )
    {
        // if multisampling draw quad
        D3DVALUE Perp[2];
        RDVertex Quad[4];
        Perp[0] = pV1->m_pos.y - pV0->m_pos.y;
        Perp[1] = -(pV1->m_pos.x - pV0->m_pos.x);
        float Length = SQRTF(Perp[0]*Perp[0] + Perp[1]*Perp[1]);

        if( 0 == Length )
            return;

        float Scale = 0.7f / Length;    // 0.7 makes the line width 1.4. 
                                        // (arbitrary "nice looking" choice)
                                        // Dividing by Length to normalize perp. vector.
        Perp[0] *= Scale;
        Perp[1] *= Scale;

        Quad[0] = *pV0;
        Quad[0].m_pos.x -= Perp[0];
        Quad[0].m_pos.y -= Perp[1];

        Quad[1] = *pV0;
        Quad[1].m_pos.x += Perp[0];
        Quad[1].m_pos.y += Perp[1];

        Quad[2] = *pV1;
        Quad[2].m_pos.x += Perp[0];
        Quad[2].m_pos.y += Perp[1];

        Quad[3] = *pV1;
        Quad[3].m_pos.x -= Perp[0];
        Quad[3].m_pos.y -= Perp[1];

        DWORD dwCull = m_dwRenderState[D3DRS_CULLMODE];
        DWORD dwFill = m_dwRenderState[D3DRS_FILLMODE];
        m_dwRenderState[D3DRS_CULLMODE] = D3DCULL_NONE;
        m_dwRenderState[D3DRS_FILLMODE] = D3DFILL_SOLID;

        DrawTriangle(&Quad[0],&Quad[1],&Quad[2],0 );
        DrawTriangle(&Quad[0],&Quad[2],&Quad[3],0 );

        m_dwRenderState[D3DRS_CULLMODE] = dwCull;
        m_dwRenderState[D3DRS_FILLMODE] = dwFill;

        return;
    }

    if ( m_Rast.PerLineSetup(
          pV0->GetPtrXYZ(), pV1->GetPtrXYZ(),
          m_dwRenderState[D3DRS_LASTPIXEL],
          &(m_pRenderTarget->m_Clip)) )
    {
        return; // discarded due to degenerate or no viewport overlap
    }

    // compute attribute functions
    m_Rast.SetAttributeFunctions( *pV0, *pV1, pVFlat ? (*pVFlat) : (*pV0) );

    // rasterize it
    m_Rast.DoScanCnvLine();
}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\rast\texfilt.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// texfilt.cpp
//
// Direct3D Reference Device - Texture Map Filtering Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

void
RefRast::UpdateTextureControls( void )
{
    for (int iStage=0; iStage<m_pRD->m_cActiveTextureStages; iStage++)
    {
        // check for requirement to do level-of-detail (coverage) computation - either
        // for mipmap or per-pixel filter selection
        BOOL bComputeLOD =
            ( m_pRD->GetTSS(iStage)[D3DTSS_MIPFILTER] == D3DTEXF_POINT ) ||
            ( m_pRD->GetTSS(iStage)[D3DTSS_MIPFILTER] == D3DTEXF_LINEAR ) ||
            ( m_pRD->GetTSS(iStage)[D3DTSS_MAGFILTER] != m_pRD->GetTSS(iStage)[D3DTSS_MINFILTER] );

        // check for anisotropic filtering in either mag filter or in min filter
        BOOL bDoAniso =
            ( D3DTEXF_ANISOTROPIC == m_pRD->GetTSS(iStage)[D3DTSS_MAGFILTER] ) ||
            ( bComputeLOD && (D3DTEXF_ANISOTROPIC == m_pRD->GetTSS(iStage)[D3DTSS_MINFILTER]) );

        // compute filter type for coverage computation
        if (bDoAniso)           m_TexFlt[iStage].CvgFilter = D3DTEXF_ANISOTROPIC;
        else if (bComputeLOD)   m_TexFlt[iStage].CvgFilter = D3DTEXF_LINEAR;
        else                    m_TexFlt[iStage].CvgFilter = D3DTEXF_NONE;

        // compute filter type for magnify (also used for non-LOD case)
        switch ( m_pRD->GetTSS(iStage)[D3DTSS_MAGFILTER] )
        {
        default:
        case D3DTEXF_POINT:         m_TexFlt[iStage].MagFilter = D3DTEXF_POINT; break;
        case D3DTEXF_FLATCUBIC:
        case D3DTEXF_GAUSSIANCUBIC:
        case D3DTEXF_LINEAR:        m_TexFlt[iStage].MagFilter = D3DTEXF_LINEAR; break;
        case D3DTEXF_ANISOTROPIC:   m_TexFlt[iStage].MagFilter = D3DTEXF_ANISOTROPIC; break;
        }

        // compute filter type(s) for minify
        switch ( m_pRD->GetTSS(iStage)[D3DTSS_MINFILTER] )
        {
        default:
        case D3DTEXF_POINT:         m_TexFlt[iStage].MinFilter = D3DTEXF_POINT;  break;
        case D3DTEXF_LINEAR:        m_TexFlt[iStage].MinFilter = D3DTEXF_LINEAR; break;
        case D3DTEXF_ANISOTROPIC:   m_TexFlt[iStage].MinFilter = D3DTEXF_ANISOTROPIC;  break;
        }

        switch ( m_pRD->GetTSS(iStage)[D3DTSS_MIPFILTER] )
        {
        default:
        case D3DTEXF_NONE:          m_TexFlt[iStage].MipFilter = D3DTEXF_NONE; break;
        case D3DTEXF_POINT:         m_TexFlt[iStage].MipFilter = D3DTEXF_POINT; break;
        case D3DTEXF_LINEAR:        m_TexFlt[iStage].MipFilter = D3DTEXF_LINEAR; break;
        }

        // set default state
        m_TexCvg[iStage].fLOD = 0.f;
        m_TexCvg[iStage].iLOD = 0;
        m_TexCvg[iStage].iLODMap[0] = 0;
        m_TexCvg[iStage].iLODMap[1] = 0;
        m_TexCvg[iStage].fLODFrc[0] = 1.f;
        m_TexCvg[iStage].fLODFrc[1] = 1.f;
        m_TexCvg[iStage].bMagnify = FALSE;
        m_TexCvg[iStage].cLOD = 1;
    }
}

//
// called once per each set of 2x2 samples
//
void
RefRast::ComputeTextureCoverage( int iStage, FLOAT (*fGradients)[2] )
{
    if ( !m_pRD->m_pTexture[iStage] ) return;
    if ( m_pRD->m_pTexture[iStage]->m_uFlags & RR_TEXTURE_CUBEMAP )
    {
        // store gradients for cubemaps
        memcpy( m_TexCvg[iStage].fGradients, fGradients, 3*2*sizeof(FLOAT) );
        return;
    }

    if ( D3DTEXF_NONE == m_TexFlt[iStage].CvgFilter ) return;

    // scale gradients to texture LOD 0 size
    for (int iD=0; iD < m_pRD->m_pTexture[iStage]->m_cDimension; iD++ )
    {
        fGradients[iD][0] *= m_pRD->m_pTexture[iStage]->m_fTexels[0][iD];
        fGradients[iD][1] *= m_pRD->m_pTexture[iStage]->m_fTexels[0][iD];
    }

    if ( (m_TexFlt[iStage].CvgFilter == D3DTEXF_ANISOTROPIC) &&
         (m_pRD->m_pTexture[iStage]->m_cDimension == 2) ) // do aniso for 2D textures only
    {
        ComputeAnisoCoverage( fGradients, MIN( 16.f, (FLOAT)m_pRD->GetTSS(iStage)[D3DTSS_MAXANISOTROPY]),
            m_TexCvg[iStage].fLOD, m_TexCvg[iStage].fAnisoRatio, m_TexCvg[iStage].fAnisoLine );
    }
    else
    {
        ComputeMipCoverage( fGradients, m_TexCvg[iStage].fLOD, m_pRD->m_pTexture[iStage]->m_cDimension );
        m_TexCvg[iStage].fAnisoRatio = 1.f;
    }

    ComputePerLODControls( iStage );
}

//
// called by ComputeTextureCoverage and ComputeCubeTextureFilter
//
void
RefRast::ComputePerLODControls( int iStage )
{
    m_TexCvg[iStage].fLOD += m_pRD->GetTSSf(iStage)[D3DTSS_MIPMAPLODBIAS];
    m_TexCvg[iStage].iLOD = AS_INT16( m_TexCvg[iStage].fLOD + FLOAT_5_SNAP );
    m_TexCvg[iStage].bMagnify = (m_TexCvg[iStage].iLOD <= 0);

    m_TexCvg[iStage].cLOD = 1;
    m_TexCvg[iStage].fLODFrc[0] = 1.f;
    if ( m_TexCvg[iStage].bMagnify || ( m_TexFlt[iStage].MipFilter == D3DTEXF_NONE ) )
    {
        m_TexCvg[iStage].iLODMap[0] = 0;
        // clamp to max LOD
        m_TexCvg[iStage].iLODMap[0] = MAX( m_TexCvg[iStage].iLODMap[0], (INT32)m_pRD->GetTSS(iStage)[D3DTSS_MAXMIPLEVEL] );
        // clamp to available maps
        m_TexCvg[iStage].iLODMap[0] = MIN( m_TexCvg[iStage].iLODMap[0], (INT32)m_pRD->m_pTexture[iStage]->m_cLOD );
    }
    else if ( m_TexFlt[iStage].MipFilter == D3DTEXF_POINT )
    {
        // round and truncate (add .5 and shift off fractional bits)
        m_TexCvg[iStage].iLODMap[0] = (m_TexCvg[iStage].iLOD + (1<<(RRTEX_LODFRAC-1))) >> RRTEX_LODFRAC;
        // clamp to max LOD
        m_TexCvg[iStage].iLODMap[0] = MAX( m_TexCvg[iStage].iLODMap[0], (INT32)m_pRD->GetTSS(iStage)[D3DTSS_MAXMIPLEVEL] );
        // clamp to available maps
        m_TexCvg[iStage].iLODMap[0] = MIN( m_TexCvg[iStage].iLODMap[0], (INT32)m_pRD->m_pTexture[iStage]->m_cLOD );
    }
    else // mip filter D3DTEXF_LINEAR
    {
        // compute index for two adjacent LODs
        m_TexCvg[iStage].iLODMap[0] = m_TexCvg[iStage].iLOD >> RRTEX_LODFRAC;  // floor
        m_TexCvg[iStage].iLODMap[1] = m_TexCvg[iStage].iLODMap[0] + 1;
        // clamp to max LOD
        m_TexCvg[iStage].iLODMap[0] = MAX( m_TexCvg[iStage].iLODMap[0], (INT32)m_pRD->GetTSS(iStage)[D3DTSS_MAXMIPLEVEL] );
        m_TexCvg[iStage].iLODMap[1] = MAX( m_TexCvg[iStage].iLODMap[1], (INT32)m_pRD->GetTSS(iStage)[D3DTSS_MAXMIPLEVEL] );
        // clamp to available maps
        m_TexCvg[iStage].iLODMap[0] = MIN( m_TexCvg[iStage].iLODMap[0], (INT32)m_pRD->m_pTexture[iStage]->m_cLOD );
        m_TexCvg[iStage].iLODMap[1] = MIN( m_TexCvg[iStage].iLODMap[1], (INT32)m_pRD->m_pTexture[iStage]->m_cLOD );

        // check that both maps actually contribute to texel
        if ( (m_TexCvg[iStage].iLODMap[0] != m_TexCvg[iStage].iLODMap[1]) &&
             (m_TexCvg[iStage].iLOD & RRTEX_LODFRACMASK) )
        {
            m_TexCvg[iStage].fLODFrc[1]  = (FLOAT)(m_TexCvg[iStage].iLOD & RRTEX_LODFRACMASK) * RRTEX_LODFRACF;
            m_TexCvg[iStage].fLODFrc[0] = 1.f - m_TexCvg[iStage].fLODFrc[1];
            m_TexCvg[iStage].cLOD = 2;
        }
    }
}

void
RefRast::ComputePointSampleCoords(
    int iStage, INT32 iLOD, FLOAT fCrd[],
    INT32 iCrd[] )
{
    for (int iD=0; iD<m_pRD->m_pTexture[iStage]->m_cDimension; iD++)
    {
        FLOAT fScaledCrd =
            ( fCrd[iD] * m_pRD->m_pTexture[iStage]->m_fTexels[iLOD][iD] ) - .5f;
        // truncate to -infinity to be compatible with ANDing off low order
        // bits of a fixed point fScaledCoord.  This makes the generation of
        // iCoord more hardware like, and does not make a glitch at 0 for
        // a wrapped texture.
        if ( fCrd[iD] >= 0.f ) iCrd[iD] = (INT32)( fScaledCrd + .5f );
        else                   iCrd[iD] = (INT32)( fScaledCrd - .5f );
    }
}

void
RefRast::ComputeLinearSampleCoords(
    int iStage, INT32 iLOD, FLOAT fCrd[],
    INT32 iCrdFlr[], INT32 iCrdClg[], FLOAT fCrdFrcF[], FLOAT fCrdFrcC[]  )
{
    for (int iD=0; iD<m_pRD->m_pTexture[iStage]->m_cDimension; iD++)
    {
        FLOAT fScaledCrd =
            ( fCrd[iD] * m_pRD->m_pTexture[iStage]->m_fTexels[iLOD][iD] ) - .5f;
        INT32 iCrd = FloatToNdot5(fScaledCrd);
        iCrdFlr[iD] = iCrd >> RRTEX_MAPFRAC;
        iCrdClg[iD] = iCrdFlr[iD] + 1;
        fCrdFrcC[iD] = (FLOAT)(iCrd & RRTEX_MAPFRACMASK) * RRTEX_MAPFRACF;
        fCrdFrcF[iD] = 1.f - fCrdFrcC[iD];
    }
}

void
RefRast::SetUp1DTextureSample(
    int iStage, int Start,
    INT32 iLODMap, FLOAT fLODScale,
    INT32 iCrdF, INT32 iCrdC,
    FLOAT fCrdFrcF, FLOAT fCrdFrcC )
{
    m_TexFlt[iStage].pSamples[Start+0].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+1].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+0].iCrd[0] = iCrdF;
    m_TexFlt[iStage].pSamples[Start+1].iCrd[0] = iCrdC;
    m_TexFlt[iStage].pSamples[Start+0].fWgt = fCrdFrcF*fLODScale;
    m_TexFlt[iStage].pSamples[Start+1].fWgt = fCrdFrcC*fLODScale;
}

#define _Set2( _DstAr, _Src0, _Src1 ) \
    _DstAr[0] = _Src0; _DstAr[1] = _Src1;

void
RefRast::SetUp2DTextureSample(
    int iStage, int Start,
    INT32 iLODMap, FLOAT fLODScale,
    INT32 iCrdF[], INT32 iCrdC[],
    FLOAT fCrdFrcF[], FLOAT fCrdFrcC[] )
{
    m_TexFlt[iStage].pSamples[Start+0].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+1].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+2].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+3].iLOD = iLODMap;
    _Set2( m_TexFlt[iStage].pSamples[Start+0].iCrd, iCrdF[0], iCrdF[1] )
    _Set2( m_TexFlt[iStage].pSamples[Start+1].iCrd, iCrdC[0], iCrdF[1] )
    _Set2( m_TexFlt[iStage].pSamples[Start+2].iCrd, iCrdC[0], iCrdC[1] )
    _Set2( m_TexFlt[iStage].pSamples[Start+3].iCrd, iCrdF[0], iCrdC[1] )
    m_TexFlt[iStage].pSamples[Start+0].fWgt = fCrdFrcF[0] * fCrdFrcF[1] * fLODScale;
    m_TexFlt[iStage].pSamples[Start+1].fWgt = fCrdFrcC[0] * fCrdFrcF[1] * fLODScale;
    m_TexFlt[iStage].pSamples[Start+2].fWgt = fCrdFrcC[0] * fCrdFrcC[1] * fLODScale;
    m_TexFlt[iStage].pSamples[Start+3].fWgt = fCrdFrcF[0] * fCrdFrcC[1] * fLODScale;
}

#define _Set3( _DstAr, _Src0, _Src1, _Src2 ) \
    _DstAr[0] = _Src0; _DstAr[1] = _Src1; _DstAr[2] = _Src2;

void
RefRast::SetUp3DTextureSample(
    int iStage, int Start,
    INT32 iLODMap, FLOAT fLODScale,
    INT32 iCrdF[], INT32 iCrdC[],
    FLOAT fCrdFrcF[], FLOAT fCrdFrcC[] )
{
    m_TexFlt[iStage].pSamples[Start+0].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+1].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+2].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+3].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+4].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+5].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+6].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+7].iLOD = iLODMap;
    m_TexFlt[iStage].pSamples[Start+0].fWgt = fCrdFrcF[0] * fCrdFrcF[1] * fCrdFrcF[2] * fLODScale;
    m_TexFlt[iStage].pSamples[Start+1].fWgt = fCrdFrcC[0] * fCrdFrcF[1] * fCrdFrcF[2] * fLODScale;
    m_TexFlt[iStage].pSamples[Start+2].fWgt = fCrdFrcC[0] * fCrdFrcC[1] * fCrdFrcF[2] * fLODScale;
    m_TexFlt[iStage].pSamples[Start+3].fWgt = fCrdFrcF[0] * fCrdFrcC[1] * fCrdFrcF[2] * fLODScale;
    m_TexFlt[iStage].pSamples[Start+4].fWgt = fCrdFrcF[0] * fCrdFrcF[1] * fCrdFrcC[2] * fLODScale;
    m_TexFlt[iStage].pSamples[Start+5].fWgt = fCrdFrcC[0] * fCrdFrcF[1] * fCrdFrcC[2] * fLODScale;
    m_TexFlt[iStage].pSamples[Start+6].fWgt = fCrdFrcC[0] * fCrdFrcC[1] * fCrdFrcC[2] * fLODScale;
    m_TexFlt[iStage].pSamples[Start+7].fWgt = fCrdFrcF[0] * fCrdFrcC[1] * fCrdFrcC[2] * fLODScale;
    _Set3( m_TexFlt[iStage].pSamples[Start+0].iCrd, iCrdF[0], iCrdF[1], iCrdF[2] )
    _Set3( m_TexFlt[iStage].pSamples[Start+1].iCrd, iCrdC[0], iCrdF[1], iCrdF[2] )
    _Set3( m_TexFlt[iStage].pSamples[Start+2].iCrd, iCrdC[0], iCrdC[1], iCrdF[2] )
    _Set3( m_TexFlt[iStage].pSamples[Start+3].iCrd, iCrdF[0], iCrdC[1], iCrdF[2] )
    _Set3( m_TexFlt[iStage].pSamples[Start+4].iCrd, iCrdF[0], iCrdF[1], iCrdC[2] )
    _Set3( m_TexFlt[iStage].pSamples[Start+5].iCrd, iCrdC[0], iCrdF[1], iCrdC[2] )
    _Set3( m_TexFlt[iStage].pSamples[Start+6].iCrd, iCrdC[0], iCrdC[1], iCrdC[2] )
    _Set3( m_TexFlt[iStage].pSamples[Start+7].iCrd, iCrdF[0], iCrdC[1], iCrdC[2] )
}

//
// called once for each pixel
//
void
RefRast::ComputeTextureFilter( int iStage, FLOAT fCrd[] )
{
    m_TexFlt[iStage].cSamples = 0;
    if ( !m_pRD->m_pTexture[iStage] ) return;

    if ( m_pRD->m_pTexture[iStage]->m_uFlags & RR_TEXTURE_CUBEMAP )
    {
        ComputeCubeTextureFilter( iStage, fCrd );
        return;
    }
    // here for 1,2,3D texture
    int iL,iD;
#define _PerDimension(_Par) for (_Par=0;_Par<m_pRD->m_pTexture[iStage]->m_cDimension;_Par++)
    D3DTEXTUREFILTERTYPE Filter =
        m_TexCvg[iStage].bMagnify ? m_TexFlt[iStage].MagFilter : m_TexFlt[iStage].MinFilter;
    switch ( Filter )
    {
    default:
    case D3DTEXF_POINT:
        for ( iL = 0; iL < m_TexCvg[iStage].cLOD; iL++ )
        {
            m_TexFlt[iStage].pSamples[m_TexFlt[iStage].cSamples].iLOD = m_TexCvg[iStage].iLODMap[iL];
            m_TexFlt[iStage].pSamples[m_TexFlt[iStage].cSamples].fWgt = m_TexCvg[iStage].fLODFrc[iL];
            ComputePointSampleCoords( iStage, m_TexCvg[iStage].iLODMap[iL], fCrd,
                m_TexFlt[iStage].pSamples[m_TexFlt[iStage].cSamples].iCrd );
            m_TexFlt[iStage].cSamples++;
        }
        break;

    case D3DTEXF_LINEAR:
        for ( iL = 0; iL < m_TexCvg[iStage].cLOD; iL++ )
        {
            INT32 iCrdFlr[3], iCrdClg[3];
            FLOAT fCrdFrcF[3], fCrdFrcC[3];
            ComputeLinearSampleCoords(
                iStage, m_TexCvg[iStage].iLODMap[iL], fCrd,
                iCrdFlr, iCrdClg, fCrdFrcF, fCrdFrcC );
            switch ( m_pRD->m_pTexture[iStage]->m_cDimension )
            {
            default:
            case 1:
                SetUp1DTextureSample( iStage, m_TexFlt[iStage].cSamples, m_TexCvg[iStage].iLODMap[iL], m_TexCvg[iStage].fLODFrc[iL],
                    iCrdFlr[0], iCrdClg[0], fCrdFrcF[0], fCrdFrcC[0] );
                m_TexFlt[iStage].cSamples += 2;
                break;
            case 2:
                SetUp2DTextureSample( iStage, m_TexFlt[iStage].cSamples, m_TexCvg[iStage].iLODMap[iL], m_TexCvg[iStage].fLODFrc[iL],
                    iCrdFlr, iCrdClg, fCrdFrcF, fCrdFrcC );
                m_TexFlt[iStage].cSamples += 4;
                break;
            case 3:
                SetUp3DTextureSample( iStage, m_TexFlt[iStage].cSamples, m_TexCvg[iStage].iLODMap[iL], m_TexCvg[iStage].fLODFrc[iL],
                    iCrdFlr, iCrdClg, fCrdFrcF, fCrdFrcC );
                m_TexFlt[iStage].cSamples += 8;
                break;
            }
        }
        break;

    case D3DTEXF_ANISOTROPIC:
        for ( iL = 0; iL < m_TexCvg[iStage].cLOD; iL++ )
        {
            FLOAT fStepScale[3];
            fStepScale[0] = 1.f/m_pRD->m_pTexture[iStage]->m_fTexels[m_TexCvg[iStage].iLODMap[iL]][0];
            fStepScale[1] = 1.f/m_pRD->m_pTexture[iStage]->m_fTexels[m_TexCvg[iStage].iLODMap[iL]][1];
            fStepScale[2] = 0.f;

            FLOAT fUnitStep[3];
            _PerDimension(iD) { fUnitStep[iD] = fStepScale[iD]*m_TexCvg[iStage].fAnisoLine[iD]; }

            int cAnisoSamples;
            FLOAT fACrd[16][3];
            FLOAT fAScale[16];
            if ( m_TexCvg[iStage].fAnisoRatio <= 1.f )
            {
                // just like mip D3DTEXF_LINEAR
                cAnisoSamples = 1; fAScale[0] = 1.f;
                _PerDimension(iD) { fACrd[0][iD] = fCrd[iD]; }
            }
            else if ( m_TexCvg[iStage].fAnisoRatio <= 2.f )
            {
                // take two sets of samples and average
                cAnisoSamples = 2; fAScale[0] = fAScale[1] = .5f;
                FLOAT fStepSize = .5f*(m_TexCvg[iStage].fAnisoRatio - 1.f);
                _PerDimension(iD)
                {
                    FLOAT fStep = fStepSize*fUnitStep[iD];
                    fACrd[0][iD] = fCrd[iD] + fStep;
                    fACrd[1][iD] = fCrd[iD] - fStep;
                }
            }
            else
            {
                // walk line of anisotropy in both directions from center point
                FLOAT fInvRatio = 1.f/m_TexCvg[iStage].fAnisoRatio;
                FLOAT fRatioRemainder = m_TexCvg[iStage].fAnisoRatio;
                // start steps centered 1/2 away
                _PerDimension(iD)
                {
                    fACrd[0][iD] = fCrd[iD] + fUnitStep[iD]*.5f;
                    fACrd[1][iD] = fCrd[iD] - fUnitStep[iD]*.5f;
                }
                cAnisoSamples = 0;
                do
                {
                    fAScale[cAnisoSamples+0] = fInvRatio;
                    fAScale[cAnisoSamples+1] = fInvRatio;
                    if ( fRatioRemainder < 2.f )
                    {
                        fAScale[cAnisoSamples+0] *= .5f*fRatioRemainder;
                        fAScale[cAnisoSamples+1] *= .5f*fRatioRemainder;
                    }
                    if ( fRatioRemainder > 2.f )
                    {
                        _PerDimension(iD)
                        {
                            fACrd[cAnisoSamples+2][iD] = fACrd[cAnisoSamples+0][iD] + fUnitStep[iD];
                            fACrd[cAnisoSamples+3][iD] = fACrd[cAnisoSamples+1][iD] - fUnitStep[iD];
                        }
                    }
                    cAnisoSamples += 2;
                    fRatioRemainder -= 2.f;
                }
                while ( fRatioRemainder > 0.f );
            }
            for ( int iS = 0; iS < cAnisoSamples; iS ++ )
            {
                INT32 iCrdFlr[3], iCrdClg[3];
                FLOAT fCrdFrcF[3], fCrdFrcC[3];
                ComputeLinearSampleCoords(
                    iStage, m_TexCvg[iStage].iLODMap[iL], fACrd[iS],
                    iCrdFlr, iCrdClg, fCrdFrcF, fCrdFrcC );
                FLOAT fSampleScale = fAScale[iS]*m_TexCvg[iStage].fLODFrc[iL];
                switch ( m_pRD->m_pTexture[iStage]->m_cDimension )
                {
                default:
                case 1:
                    SetUp1DTextureSample( iStage, m_TexFlt[iStage].cSamples, m_TexCvg[iStage].iLODMap[iL], fSampleScale,
                        iCrdFlr[0], iCrdClg[0], fCrdFrcF[0], fCrdFrcC[0] );
                    m_TexFlt[iStage].cSamples += 2;
                    break;
                case 2:
                    SetUp2DTextureSample( iStage, m_TexFlt[iStage].cSamples, m_TexCvg[iStage].iLODMap[iL], fSampleScale,
                        iCrdFlr, iCrdClg, fCrdFrcF, fCrdFrcC );
                    m_TexFlt[iStage].cSamples += 4;
                    break;
                case 3:
                    SetUp3DTextureSample( iStage, m_TexFlt[iStage].cSamples, m_TexCvg[iStage].iLODMap[iL], fSampleScale,
                        iCrdFlr, iCrdClg, fCrdFrcF, fCrdFrcC );
                    m_TexFlt[iStage].cSamples += 8;
                    break;
                }
            }
        }
        break;
    }
}

const DWORD g_D3DTSS_ADDRESS_MAP[3] = { D3DTSS_ADDRESSU, D3DTSS_ADDRESSV, D3DTSS_ADDRESSW };

void
RefRast::SampleTexture( INT32 iStage, FLOAT fCol[] )
{
    if ( m_pRD->m_pTexture[iStage] == NULL )
    {
        // return opaque black if no texture bound
        fCol[0] = fCol[1] = fCol[2] = 0.f;
        fCol[3] = 1.f;
        return;
    }
    fCol[0] = fCol[1] = fCol[2] = fCol[3] = 0.f;
    TextureSample* pS = m_TexFlt[iStage].pSamples;
    RDSurface2D* pTex = m_pRD->m_pTexture[iStage];
    for (int iS = 0; iS < m_TexFlt[iStage].cSamples; iS++, pS++ )
    {
        if ( pS->fWgt )
        {
            BOOL bUseBorder = FALSE;
            for (int iD=0; iD < pTex->m_cDimension; iD++)
            {
                INT32 iCrdMax = (pTex->m_cTexels[pS->iLOD][iD] - 1);
                if ( ( pS->iCrd[iD] < 0) || ( pS->iCrd[iD] > iCrdMax ) )
                {
                    switch ( m_pRD->GetTSS(iStage)[g_D3DTSS_ADDRESS_MAP[iD]] )
                    {
                    case D3DTADDRESS_WRAP:
                        // Pow-2 texture:                        
                        // pS->iCrd[iD] = pS->iCrd[iD] & iCrdMax;

                        // Non-Pow-2 texture:
                        pS->iCrd[iD] %= (iCrdMax + 1);
                        if( pS->iCrd[iD] < 0 )
                            pS->iCrd[iD] = iCrdMax + 1 + pS->iCrd[iD];
                        break;
                    case D3DTADDRESS_MIRROR:
                        // Pow-2 texture:
                        // lop off non-fractional bits + flip index if LSB (non-fraction) is set
                        // BOOL bFlip; bFlip = pS->iCrd[iD] & (iCrdMax+1);
                        // pS->iCrd[iD] &= iCrdMax; 
                        // if (bFlip) { pS->iCrd[iD] = iCrdMax - pS->iCrd[iD]; }

                        // Non-Pow-2 texture:
                        if( pS->iCrd[iD] < 0 )
                            pS->iCrd[iD] = -pS->iCrd[iD] - 1;
                        BOOL bFlip; bFlip = ((pS->iCrd[iD]/(iCrdMax + 1)) & 1);
                        pS->iCrd[iD] %= (iCrdMax + 1);
                        if( bFlip ) pS->iCrd[iD] = iCrdMax - pS->iCrd[iD];

                        break;
                    case D3DTADDRESS_BORDER:
                        bUseBorder = TRUE;
                        break;
                    case D3DTADDRESS_MIRRORONCE:
                        if ( pS->iCrd[iD] < 0 )  pS->iCrd[iD] = (-pS->iCrd[iD]) - 1;
                        // fall through to clamp for outside of -1 to +1 range
                    case D3DTADDRESS_CLAMP:
                        pS->iCrd[iD] = MAX( 0, MIN( pS->iCrd[iD], iCrdMax ) );
                        break;
                    }
                }
            }
            RDColor Texel;
            (bUseBorder)
                ? Texel = m_pRD->GetTSS(iStage)[D3DTSS_BORDERCOLOR]
                : pTex->ReadColor(
                    pS->iCrd[0], pS->iCrd[1], pS->iCrd[2], pS->iLOD,
                    Texel, m_bPixelDiscard[m_iPix] );

            fCol[0] += ( Texel.R * pS->fWgt );
            fCol[1] += ( Texel.G * pS->fWgt );
            fCol[2] += ( Texel.B * pS->fWgt );
            fCol[3] += ( Texel.A * pS->fWgt );
        }
    }
}

//-----------------------------------------------------------------------------
//
// Computes level of detail for standard trilinear mipmapping, in which
// the four texture index gradients are consolidated into a single number
// to select level of detail.
//
// The basic approach is to compute the lengths of the pixel coverage for
// the per-dimensional extent of the approximate pixel coverage area.  The
// max of lengths are used for the single LOD result.
//
//-----------------------------------------------------------------------------
void
ComputeMipCoverage( const FLOAT (*fGradients)[2], FLOAT& fLOD, int cDim )
{
    // compute length of coverage in each dimension
    FLOAT fLen[2];
    switch (cDim)
    {
    default:
    case 1:  fLOD = 0.f; return;
    case 2:
        fLen[0] = RR_LENGTH( fGradients[0][0], fGradients[1][0] );
        fLen[1] = RR_LENGTH( fGradients[0][1], fGradients[1][1] );
        break;
    case 3:
        fLen[0] = RR_SQRT(
            (fGradients[0][0]*fGradients[0][0]) +
            (fGradients[1][0]*fGradients[1][0]) +
            (fGradients[2][0]*fGradients[2][0]) );
        fLen[1] = RR_SQRT(
            (fGradients[0][1]*fGradients[0][1]) +
            (fGradients[1][1]*fGradients[1][1]) +
            (fGradients[2][1]*fGradients[2][1]) );
        break;
    }

    // take the MAX for the coverage
    FLOAT fCoverage = MAX( fLen[0], fLen[1] );

    // take log2 of coverage for LOD
    fLOD = RR_LOG2(fCoverage);
}

//-----------------------------------------------------------------------------
//
// Computes level of detail and other factors in preparation for anisotropic
// filtering.  This is for 2D texture maps only.
//
//-----------------------------------------------------------------------------
void
ComputeAnisoCoverage(
    const FLOAT (*fGradients)[2], FLOAT fMaxAniso, // inputs
    FLOAT& fLOD, FLOAT& fRatio, FLOAT fDelta[] )   // outputs
{
    // compute axis lengths and determinant
    FLOAT fLenX2 = (fGradients[0][0]*fGradients[0][0])+(fGradients[1][0]*fGradients[1][0]);
    FLOAT fLenY2 = (fGradients[0][1]*fGradients[0][1])+(fGradients[1][1]*fGradients[1][1]);
    FLOAT fDet = RR_ABSF((fGradients[0][0]*fGradients[1][1])-(fGradients[0][1]*fGradients[1][0]));

    // select major axis
    BOOL bXMajor = (fLenX2 > fLenY2);

    // select and normalize steps; compute aniso ratio
    FLOAT fMaj2 = (bXMajor) ? (fLenX2) : (fLenY2);
    FLOAT fMaj = RR_SQRT(fMaj2);
    FLOAT fMajNorm = 1./fMaj;
    fDelta[0] = ( bXMajor ? fGradients[0][0] : fGradients[0][1] ) * fMajNorm;
    fDelta[1] = ( bXMajor ? fGradients[1][0] : fGradients[1][1] ) * fMajNorm;
    if( !FLOAT_EQZ(fDet) )
        fRatio = fMaj2/fDet;
    else
        fRatio = FLT_MAX;

    // clamp ratio and compute LOD
    FLOAT fMin;
    if ( fRatio > fMaxAniso )
    {
        // ratio is clamped - LOD is based on ratio (preserves area)
        fRatio = fMaxAniso;
        fMin = fMaj/fRatio;
    }
    else
    {
        // ratio not clamped - LOD is based on area
        fMin = fDet/fMaj;
    }

    // clamp to top LOD
    if (fMin < 1.0)
    {
        fRatio = MAX( 1.0, fRatio*fMin );
        fMin = 1.0;
    }

    // take log2 of minor for LOD
    fLOD = RR_LOG2(fMin);
}

// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\tnl\clipping.hpp ===
#ifndef __CLIPPER_HPP_
#define __CLIPPER_HPP_

//----------------------------------------------------------------------------
// Clipping macros
//----------------------------------------------------------------------------
// Interpolation flags
#define RDCLIP_INTERPOLATE_COLOR       (1<< 0)
#define RDCLIP_INTERPOLATE_SPECULAR    (1<< 1)
#define RDCLIP_INTERPOLATE_TEXTURE     (1<< 2)
#define RDCLIP_INTERPOLATE_S           (1<< 3)
#define RDCLIP_INTERPOLATE_FOG         (1<< 4)

// Non guardband clipping bits
#define RDCLIP_LEFT   D3DCS_LEFT
#define RDCLIP_RIGHT  D3DCS_RIGHT
#define RDCLIP_TOP    D3DCS_TOP
#define RDCLIP_BOTTOM D3DCS_BOTTOM
#define RDCLIP_FRONT  D3DCS_FRONT
#define RDCLIP_BACK   D3DCS_BACK

//----------------------------------------------------------------------------
// User define clip plane bits.
// Each of these bits is set if the vertex is clipped by the associated
// clip plane.
//----------------------------------------------------------------------------
#define RDCLIP_USERCLIPPLANE0    D3DCS_PLANE0
#define RDCLIP_USERCLIPPLANE1    D3DCS_PLANE1
#define RDCLIP_USERCLIPPLANE2    D3DCS_PLANE2
#define RDCLIP_USERCLIPPLANE3    D3DCS_PLANE3
#define RDCLIP_USERCLIPPLANE4    D3DCS_PLANE4
#define RDCLIP_USERCLIPPLANE5    D3DCS_PLANE5
const DWORD RDCLIP_USERPLANES_ALL =  (RDCLIP_USERCLIPPLANE0 |
                                      RDCLIP_USERCLIPPLANE1 |
                                      RDCLIP_USERCLIPPLANE2 |
                                      RDCLIP_USERCLIPPLANE3 |
                                      RDCLIP_USERCLIPPLANE4 |
                                      RDCLIP_USERCLIPPLANE5 );

//---------------------------------------------------------------------
// Guard band clipping bits
//
// A guard bit is set when a point is out of guard band
// Guard bits should be cleared before a call to clip a triangle, because
// they are the same as CLIPPED_... bits
//
// Example of clipping bits setting for X coordinate:
//
// if -w < x < w           no clipping bit is set
// if -w*ax1 < x <= -w     RDCLIP_LEFT bit is set
// if x < -w*ax1           RDCLIPGB_LEFT bit is set
//---------------------------------------------------------------------

#define RDCLIPGB_LEFT    (RDCLIP_USERCLIPPLANE5 << 1)
#define RDCLIPGB_RIGHT   (RDCLIP_USERCLIPPLANE5 << 2)
#define RDCLIPGB_TOP     (RDCLIP_USERCLIPPLANE5 << 3)
#define RDCLIPGB_BOTTOM  (RDCLIP_USERCLIPPLANE5 << 4)




#define RDCLIP_ALL (RDCLIP_LEFT  | RDCLIP_RIGHT   |         \
                    RDCLIP_TOP   | RDCLIP_BOTTOM  |         \
                    RDCLIP_FRONT | RDCLIP_BACK    |         \
                    RDCLIP_USERPLANES_ALL)

#define RDCLIPGB_ALL (RDCLIPGB_LEFT | RDCLIPGB_RIGHT |      \
                      RDCLIPGB_TOP | RDCLIPGB_BOTTOM |      \
                      RDCLIP_FRONT | RDCLIP_BACK     |      \
                      RDCLIP_USERPLANES_ALL)

// If only these bits are set, then this point is inside the guard band
#define RDCLIP_INGUARDBAND (RDCLIP_LEFT | RDCLIP_RIGHT |    \
                            RDCLIP_TOP  | RDCLIP_BOTTOM)
//---------------------------------------------------------------------
// Bit numbers for each clip flag
//
#define RDCLIP_LEFTBIT     1
#define RDCLIP_RIGHTBIT    2
#define RDCLIP_TOPBIT      3
#define RDCLIP_BOTTOMBIT   4
#define RDCLIP_FRONTBIT    5
#define RDCLIP_BACKBIT     6

#define RDCLIP_USERCLIPLANE0BIT     7
#define RDCLIP_USERCLIPLANE1BIT     8
#define RDCLIP_USERCLIPLANE2BIT     9
#define RDCLIP_USERCLIPLANE3BIT     10
#define RDCLIP_USERCLIPLANE4BIT     11
#define RDCLIP_USERCLIPLANE5BIT     12

#define RDCLIPGB_LEFTBIT   13
#define RDCLIPGB_RIGHTBIT  14
#define RDCLIPGB_TOPBIT    15
#define RDCLIPGB_BOTTOMBIT 16

#define CLIPPED_LEFT    (RDCLIP_USERCLIPPLANE5 << 1)
#define CLIPPED_RIGHT   (RDCLIP_USERCLIPPLANE5 << 2)
#define CLIPPED_TOP     (RDCLIP_USERCLIPPLANE5 << 3)
#define CLIPPED_BOTTOM  (RDCLIP_USERCLIPPLANE5 << 4)
#define CLIPPED_FRONT   (RDCLIP_USERCLIPPLANE5 << 5)
#define CLIPPED_BACK    (RDCLIP_USERCLIPPLANE5 << 6)

#define CLIPPED_ENABLE  (RDCLIP_USERCLIPPLANE5 << 7) // wireframe enable flag

#define CLIPPED_ALL (CLIPPED_LEFT|CLIPPED_RIGHT     \
             |CLIPPED_TOP|CLIPPED_BOTTOM            \
             |CLIPPED_FRONT|CLIPPED_BACK)

const DWORD CLIPPED_USERCLIPPLANE0 = RDCLIP_USERCLIPPLANE5 << 8;
const DWORD CLIPPED_USERCLIPPLANE1 = RDCLIP_USERCLIPPLANE5 << 9;
const DWORD CLIPPED_USERCLIPPLANE2 = RDCLIP_USERCLIPPLANE5 << 10;
const DWORD CLIPPED_USERCLIPPLANE3 = RDCLIP_USERCLIPPLANE5 << 11;
const DWORD CLIPPED_USERCLIPPLANE4 = RDCLIP_USERCLIPPLANE5 << 12;
const DWORD CLIPPED_USERCLIPPLANE5 = RDCLIP_USERCLIPPLANE5 << 13;


//---------------------------------------------------------------------
// Make RDVertex from clip vertex
//
// in    - clipVertex
// out   - RD vertex
//---------------------------------------------------------------------
inline void
MakeVertexFromClipVertex( RDVertex& v, RDClipVertex& cv )
{
    memcpy( &v, &cv, sizeof( RDVertex ) );
#if 0
    v.m_rhw = D3DVAL(1)/cv.m_clip_w;
#endif
}

//---------------------------------------------------------------------
// Returns TRUE if clipping is needed
//---------------------------------------------------------------------
inline BOOL
NeedClipping(BOOL bUseGB, RDCLIPCODE clipUnion)
{
    if( bUseGB && (clipUnion & ~RDCLIP_INGUARDBAND) )
    {
        return  TRUE;
    }
    else if( clipUnion )
    {
        return  TRUE;
    }

    return FALSE;
}


#endif //__CLIPPER_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\tnl\clipping.cpp ===
#include "pch.cpp"
#pragma hdrstop

#define GET_NEW_CLIP_VERTEX \
&clip_vertices[clip_vertices_used++];


//---------------------------------------------------------------------
inline void
InterpolateColor(RDClipVertex *out,
                 RDClipVertex *p1,
                 RDClipVertex *p2,
                 D3DVALUE num_denom )
{
    FLOAT r1, g1, b1, a1;
    FLOAT r2, g2, b2, a2;

    r1 = p1->m_diffuse.r;
    g1 = p1->m_diffuse.g;
    b1 = p1->m_diffuse.b;
    a1 = p1->m_diffuse.a;
    r2 = p2->m_diffuse.r;
    g2 = p2->m_diffuse.g;
    b2 = p2->m_diffuse.b;
    a2 = p2->m_diffuse.a;
    out->m_diffuse.r = (r1 + (r2 - r1) * num_denom);
    out->m_diffuse.g = (g1 + (g2 - g1) * num_denom);
    out->m_diffuse.b = (b1 + (b2 - b1) * num_denom);
    out->m_diffuse.a = (a1 + (a2 - a1) * num_denom);
}
//---------------------------------------------------------------------
inline void
InterpolateSpecular(RDClipVertex *out,
                    RDClipVertex *p1,
                    RDClipVertex *p2,
                    D3DVALUE num_denom )
{
    FLOAT r1, g1, b1, a1;
    FLOAT r2, g2, b2, a2;

    r1 = p1->m_specular.r;
    g1 = p1->m_specular.g;
    b1 = p1->m_specular.b;
    a1 = p1->m_specular.a;
    r2 = p2->m_specular.r;
    g2 = p2->m_specular.g;
    b2 = p2->m_specular.b;
    a2 = p2->m_specular.a;
    out->m_specular.r = (r1 + (r2 - r1) * num_denom);
    out->m_specular.g = (g1 + (g2 - g1) * num_denom);
    out->m_specular.b = (b1 + (b2 - b1) * num_denom);
    out->m_specular.a = (a1 + (a2 - a1) * num_denom);
}
//---------------------------------------------------------------------
// Inline texture coordinate difference.
__inline FLOAT
TextureDiff(FLOAT fTb, FLOAT fTa, INT iMode)
{
    FLOAT fDiff1 = fTb - fTa;

    if( iMode == 0 )
    {
        // Wrap not set, return plain difference.
        return fDiff1;
    }
    else
    {
        FLOAT fDiff2;

        // Wrap set, compute shortest distance of plain difference
        // and wrap difference.

        fDiff2 = fDiff1;
        if( FLOAT_LTZ(fDiff1) )
        {
            fDiff2 += g_fOne;
        }
        else if( FLOAT_GTZ(fDiff1) )
        {
            fDiff2 -= g_fOne;
        }
        if( ABSF(fDiff1) < ABSF(fDiff2) )
        {
            return fDiff1;
        }
        else
        {
            return fDiff2;
        }
    }
}

//---------------------------------------------------------------------
inline D3DVALUE
InterpolateTexture(D3DVALUE t1,
                   D3DVALUE t2,
                   D3DVALUE num_denom,
                   DWORD    bWrap)
{
    if( !bWrap )
    {
        return ((t2 - t1) * num_denom + t1);
    }
    else
    {
        D3DVALUE t = (TextureDiff(t2, t1, 1) * num_denom + t1);
        if( t > 1.0f ) t -= 1.0f;
        return t;
    }
}


//////////////////////////////////////////////////////////////////////////////
//
// RefClipper implementation
//
//////////////////////////////////////////////////////////////////////////////
const DWORD RefClipper::RCLIP_DIRTY_ZRANGE   = (1 << 0);
const DWORD RefClipper::RCLIP_DIRTY_VIEWRECT = (1 << 1);
const DWORD RefClipper::RCLIP_DO_FLATSHADING = (1 << 2);
const DWORD RefClipper::RCLIP_DO_WIREFRAME   = (1 << 3);
const DWORD RefClipper::RCLIP_DO_ADJUSTWRAP  = (1 << 4);
const DWORD RefClipper::RCLIP_Z_ENABLE       = (1 << 5);

RefClipper::RefClipper()
{
    m_dwFlags = 0;
    memset( &m_Viewport, 0, sizeof( m_Viewport) );

    dvX = dvY = dvWidth = dvHeight = 0.0f;
    scaleX = scaleY = scaleZ = 0.0f;
    offsetX = offsetY = offsetZ = 0.0f;
    scaleXi = scaleYi = scaleZi = 0.0f;
    minX = minY = maxX = maxY = 0.0f;
    minXgb = minYgb = maxXgb = maxYgb = 0.0f;
    gb11 = gb22 = gb41 = gb42 = 0.0f;
    Kgbx1 = Kgby1 = Kgbx2 = Kgby2 = 0.0f;

    memset( clip_vbuf1, 0, sizeof(RDClipVertex*)*RD_MAX_CLIP_VERTICES );
    memset( clip_vbuf2, 0, sizeof(RDClipVertex*)*RD_MAX_CLIP_VERTICES );
    current_vbuf = 0;
    memset( clip_vertices, 0, sizeof(RDClipVertex)*RD_MAX_CLIP_VERTICES );
    m_dwInterpolate = 0;
    clip_vertices_used = 0;

    m_clipUnion = 0;
    m_clipIntersection = 0;

   // By default enable Guardband and set the extents equal
    // to the default RefRast parameters
    m_bUseGB = TRUE;
    minXgb = (RD_GB_LEFT);
    maxXgb = RD_GB_RIGHT;
    minYgb = (RD_GB_TOP);
    maxYgb = RD_GB_BOTTOM;

    memset( m_userClipPlanes, 0, sizeof(RDVECTOR4)*RD_MAX_USER_CLIPPLANES );

#if DBG
    DWORD v = 0;
    // Guardband parameters
    if( GetD3DRegValue(REG_DWORD, "DisableGB", &v, 4) && v != 0 )
    {
        m_bUseGB = FALSE;
    }
    // Try to get test values for the guard band
    char value[80];
    if( GetD3DRegValue(REG_SZ, "GuardBandLeft", &value, 80) &&
        value[0] != 0 )
        sscanf(value, "%f", &minXgb);
    if( GetD3DRegValue(REG_SZ, "GuardBandRight", &value, 80) &&
        value[0] != 0 )
        sscanf(value, "%f", &maxXgb);
    if( GetD3DRegValue(REG_SZ, "GuardBandTop", &value, 80) &&
        value[0] != 0 )
        sscanf(value, "%f", &minYgb);
    if( GetD3DRegValue(REG_SZ, "GuardBandBottom", &value, 80) &&
        value[0] != 0 )
        sscanf(value, "%f", &maxYgb);
#endif // DBG
}


//---------------------------------------------------------------------
// RefClipper::UpdateViewData
//             Updates View data used by ProcessVertices[VVM]
//---------------------------------------------------------------------
HRESULT
RefClipper::UpdateViewData()
{
    HRESULT hr = D3D_OK;

    // Update viewport information
    if( m_dwFlags & RCLIP_DIRTY_ZRANGE )
    {
        scaleZ  = m_Viewport.dvMaxZ - m_Viewport.dvMinZ;
        offsetZ = m_Viewport.dvMinZ;
        // ATTENTION: This could be a Divide by Zero here if
        // the dvMaxZ == dvMinZ. Fix it later.
        scaleZi = D3DVAL(1) / scaleZ;
    }

    if( m_dwFlags & RCLIP_DIRTY_VIEWRECT )
    {
        // Bail if we are going to cause any divide by zero exceptions.
        // The likely reason is that we have a bogus viewport set by
        // TLVertex execute buffer app.
        if(m_Viewport.dwWidth == 0 || m_Viewport.dwHeight == 0 )
            return DDERR_GENERIC;

        dvX = D3DVAL(m_Viewport.dwX);
        dvY = D3DVAL(m_Viewport.dwY);
        dvWidth = D3DVAL(m_Viewport.dwWidth);
        dvHeight = D3DVAL(m_Viewport.dwHeight);

        // Coefficients to compute screen coordinates from normalized window
        // coordinates
        scaleX  = dvWidth;
        scaleY  = - dvHeight;
        offsetX = dvX;
        offsetY = dvY + dvHeight;

#if 0
        // Small offset is added to prevent generation of negative screen
        // coordinates (this could happen because of precision errors).
        // Not needed (or wanted) for devices which do guardband.
        offsetX += SMALL_NUMBER;
        offsetY += SMALL_NUMBER;
#endif

        scaleXi = D3DVAL(1) / scaleX;
        scaleYi = D3DVAL(1) / scaleY;

        minX = dvX;
        maxX = dvX + dvWidth;
        minY = dvY;
        maxY = dvY + dvHeight;

        if( m_bUseGB )
        {
            // Because we clip by guard band window we have to use its extents
            D3DVALUE w = 2.0f / dvWidth;
            D3DVALUE h = 2.0f / dvHeight;
            D3DVALUE ax1 = -(minXgb - dvX) * w + 1.0f;
            D3DVALUE ax2 =  (maxXgb - dvX) * w - 1.0f;
            D3DVALUE ay1 =  (maxYgb - dvY) * h - 1.0f;
            D3DVALUE ay2 = -(minYgb - dvY) * h + 1.0f;
            gb11 = 2.0f / (ax1 + ax2);
            gb41 = gb11 * (ax1 - 1.0f) * 0.5f;
            gb22 = 2.0f / (ay1 + ay2);
            gb42 = gb22 * (ay1 - 1.0f) * 0.5f;

            Kgbx1 = 0.5f * (1.0f - ax1);
            Kgbx2 = 0.5f * (1.0f + ax2);
            Kgby1 = 0.5f * (1.0f - ay1);
            Kgby2 = 0.5f * (1.0f + ay2);
        }
        else
        {
            minXgb = minX;
            maxXgb = maxX;
            minYgb = minY;
            maxYgb = maxY;
        }
    }

    // Clear the dirty transform flags
    m_dwFlags &= ~(RCLIP_DIRTY_VIEWRECT | RCLIP_DIRTY_ZRANGE);
    return hr;
}

//---------------------------------------------------------------------
// Make clip vertex from RDVertex
//
// cv     - clipVertex
// v      - a TL vertex
// qwFVF  - FVF of the input TL vertex
//---------------------------------------------------------------------
void
RefClipper::MakeClipVertexFromVertex( RDClipVertex& cv, RDVertex& v,
                                        DWORD dwClipMask )
{
    DWORD dwClipFlag = (DWORD) v.m_clip;

    memcpy( &cv, &v, sizeof( RDVertex ) );

    // If the clip flag for this vertex is set, that means that the
    // transformation loop has not computed the screen coordinates for
    // this vertex, it has simply stored the clip coordinates for this
    // vertex
#if 0
    if( v.m_clip & dwClipMask )
    {
        // This is a clipped vertex, simply no screen coordinates
        cv.m_pos.x  = D3DVALUE(0);
        cv.m_pos.y  = D3DVALUE(0);
        cv.m_pos.z  = D3DVALUE(0);
        cv.m_rhw    = D3DVALUE(0);

        // Since this vertex has been clipped, the transformation loop
        // has put in the clip coordinates instead
        cv.hx  = v.m_pos.x;
        cv.hy  = v.m_pos.y;
        cv.hz  = v.m_pos.z;
        cv.hw  = v.m_rhw;
    }
    else
    {
        // This vertex is not clipped, so its screen coordinates have been
        // computed

        // Transform the screen coordinate back to the clipping space
        cv.hw  = 1.0f / cv.m_rhw;
        cv.hx  = (cv.m_pos.x - offsetX) * cv.hw * scaleXi;
        cv.hy  = (cv.m_pos.y - offsetY) * cv.hw * scaleYi;
        cv.hz  = (cv.m_pos.z - offsetZ) * cv.hw * scaleZi;

    }
#endif
}

//---------------------------------------------------------------------
// RefVP::ComputeClipCodes
//---------------------------------------------------------------------
RDCLIPCODE
RefClipper::ComputeClipCodes(RDCLIPCODE* pclipIntersection,
                             RDCLIPCODE* pclipUnion,
                             FLOAT x_clip, FLOAT y_clip,
                             FLOAT z_clip, FLOAT w_clip)
{
    D3DVALUE xx = w_clip - x_clip;
    D3DVALUE yy = w_clip - y_clip;
    D3DVALUE zz = w_clip - z_clip;

    // if( x < 0 )  clip |= RDCLIP_LEFTBIT;
    // if( x >= we ) clip |= RDCLIP_RIGHTBIT;
    // if( y < 0 )  clip |= RDCLIP_BOTTOMBIT;
    // if( y >= we ) clip |= RDCLIP_TOPBIT;
    // if( z < 0 )    clip |= RDCLIP_FRONTBIT;
    // if( z >= we ) clip |= RDCLIP_BACKBIT;
    RDCLIPCODE clip =
        ((AS_INT32(x_clip)  & 0x80000000) >>  (32-RDCLIP_LEFTBIT))  |
        ((AS_INT32(y_clip)  & 0x80000000) >>  (32-RDCLIP_BOTTOMBIT))|
        ((AS_INT32(z_clip)  & 0x80000000) >>  (32-RDCLIP_FRONTBIT)) |
        ((AS_INT32(xx)      & 0x80000000) >>  (32-RDCLIP_RIGHTBIT)) |
        ((AS_INT32(yy)      & 0x80000000) >>  (32-RDCLIP_TOPBIT))   |
        ((AS_INT32(zz)      & 0x80000000) >>  (32-RDCLIP_BACKBIT));

    RDCLIPCODE clipBit = RDCLIP_USERCLIPPLANE0;
    for( DWORD j=0; j<RD_MAX_USER_CLIPPLANES; j++)
    {
        if( m_xfmUserClipPlanes[j].bActive )
        {
            RDVECTOR4& plane = m_xfmUserClipPlanes[j].plane;
            FLOAT fComp = 0.0f;
            if( (x_clip*plane.x +
                 y_clip*plane.y +
                 z_clip*plane.z +
                 w_clip*plane.w) < fComp )
            {
                clip |= clipBit;
            }
        }
        clipBit <<= 1;
    }

    if( clip == 0 )
    {
        *pclipIntersection = 0;
        return clip;
    }
    else
    {
        if( m_bUseGB )
        {
            // We do guardband check in the projection space, so
            // we transform X and Y of the vertex there
            D3DVALUE xnew = x_clip * gb11 +
                            w_clip * gb41;
            D3DVALUE ynew = y_clip * gb22 +
                            w_clip * gb42;
            D3DVALUE xx = w_clip - xnew;
            D3DVALUE yy = w_clip - ynew;
            clip |= ((AS_INT32(xnew) & 0x80000000) >> (32-RDCLIPGB_LEFTBIT))   |
                    ((AS_INT32(ynew) & 0x80000000) >> (32-RDCLIPGB_BOTTOMBIT)) |
                    ((AS_INT32(xx)   & 0x80000000) >> (32-RDCLIPGB_RIGHTBIT))  |
                    ((AS_INT32(yy)   & 0x80000000) >> (32-RDCLIPGB_TOPBIT));
        }
        *pclipIntersection &= clip;
        *pclipUnion |= clip;
        return clip;
    }
}

//---------------------------------------------------------------------
// RefVP::ComputeClipCodesTL
//---------------------------------------------------------------------
void
RefClipper::ComputeClipCodesTL( RDVertex* pVtx )
{
    FLOAT x, y, z;
    DWORD clip = 0;

    _ASSERT( FVF_TRANSFORMED( pVtx->m_qwFVF ),
             "Can compute clipcodes only for Transformed vertices." );
    DWORD clipZF = (m_dwFlags & RCLIP_Z_ENABLE) ? RDCLIP_FRONT : 0;
    DWORD clipZB = (m_dwFlags & RCLIP_Z_ENABLE) ? RDCLIP_BACK : 0;

    // Invert to compenstate for the sign during the
    // divide by w.
    if( pVtx->m_rhw < 0 )
    {
        x = -pVtx->m_pos.x;
        y = -pVtx->m_pos.y;
        z = -pVtx->m_pos.z;
    }
    else
    {
        x = pVtx->m_pos.x;
        y = pVtx->m_pos.y;
        z = pVtx->m_pos.z;
    }

    if( x < minX )
        clip |= RDCLIP_LEFT;
    else if( x >= maxX )
        clip |= RDCLIP_RIGHT;

    if (y < minY)
        clip |= RDCLIP_TOP;
    else if (y >= maxY)
        clip |= RDCLIP_BOTTOM;

    if (z < 0.0f)
        clip |= clipZF;
    else if (z >= 1.0f)
        clip |= clipZB;

    if( m_bUseGB )
    {
        if( x < minXgb )
            clip |= RDCLIPGB_LEFT;
        else if( x >= maxXgb )
            clip |= RDCLIPGB_RIGHT;

        if( y < minYgb )
            clip |= RDCLIPGB_TOP;
        else if( y >= maxYgb )
            clip |= RDCLIPGB_BOTTOM;
    }

    pVtx->m_clip = clip;

    // Back transform to obtain the clip-coordinates
    pVtx->m_clip_w =  1.0f / pVtx->m_rhw;   // This is w_clip
    pVtx->m_clip_x  = (pVtx->m_pos.x - offsetX) * pVtx->m_clip_w * scaleXi;
    pVtx->m_clip_y  = (pVtx->m_pos.y - offsetY) * pVtx->m_clip_w * scaleYi;
    pVtx->m_clip_z  = (pVtx->m_pos.z - offsetZ) * pVtx->m_clip_w * scaleZi;

    return;
}

//---------------------------------------------------------------------
// Clipping a triangle by a plane
//
// Returns number of vertices in the clipped triangle
//---------------------------------------------------------------------
int
RefClipper::ClipByPlane( RDClipVertex **inv, RDClipVertex **outv,
                         RDVECTOR4 *plane, DWORD dwClipFlag, int count )
{
    int i;
    int out_count = 0;
    RDClipVertex *curr, *prev;
    D3DVALUE curr_inside;
    D3DVALUE prev_inside;

    prev = inv[count-1];
    curr = *inv++;
    prev_inside = prev->m_clip_x*plane->x + prev->m_clip_y*plane->y +
                  prev->m_clip_z*plane->z + prev->m_clip_w*plane->w;
    for (i = count; i; i--)
    {
        curr_inside = curr->m_clip_x*plane->x + curr->m_clip_y*plane->y +
                      curr->m_clip_z*plane->z + curr->m_clip_w*plane->w;
        // We interpolate always from the inside vertex to the outside vertex
        // to reduce precision problems
        if( FLOAT_LTZ(prev_inside) )
        { // first point is outside
            if( FLOAT_GEZ(curr_inside) )
            { // second point is inside
              // Find intersection and insert in into the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                outv[out_count]->m_qwFVF = prev->m_qwFVF;
                Interpolate( outv[out_count],
                             curr, prev,
                             (prev->m_clip & CLIPPED_ENABLE) | dwClipFlag,
                             curr_inside, curr_inside - prev_inside);
                out_count++;
            }
        } else
        { // first point is inside - put it to the output buffer first
            outv[out_count++] = prev;
            if( FLOAT_LTZ(curr_inside) )
            { // second point is outside
              // Find intersection and put it to the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                outv[out_count]->m_qwFVF = prev->m_qwFVF;
                Interpolate( outv[out_count],
                             prev, curr,
                             dwClipFlag,
                             prev_inside, prev_inside - curr_inside);
                out_count++;
            }
        }
        prev = curr;
        curr = *inv++;
        prev_inside = curr_inside;
    }
    return out_count;
}
//-------------------------------------------------------------------------
// Clips a line by a plane
//
// Returns 1 if the line is outside the frustum, 0 otherwise
//
int
RefClipper::ClipLineByPlane( RDCLIPTRIANGLE *line, RDVECTOR4 *plane,
                             DWORD dwClipBit )
{
    D3DVALUE in1, in2;
    RDClipVertex outv;
    in1 = line->v[0]->m_clip_x * plane->x +
          line->v[0]->m_clip_y * plane->y +
          line->v[0]->m_clip_z * plane->z +
          line->v[0]->m_clip_w * plane->w;
    in2 = line->v[1]->m_clip_x * plane->x +
          line->v[1]->m_clip_y * plane->y +
          line->v[1]->m_clip_z * plane->z +
          line->v[1]->m_clip_w * plane->w;
    if( in1 < 0 )
    {
        if( in2 < 0 )
            return 1;
        Interpolate( &outv, line->v[0], line->v[1],
                     dwClipBit, in1, in1 - in2);
        *line->v[0] = outv;
    }
    else
    {
        if( in2 < 0 )
        {
            Interpolate( &outv, line->v[0], line->v[1],
                         dwClipBit, in1, in1 - in2);
            *line->v[1] = outv;
        }
    }
    return 0;
}
/*------------------------------------------------------------------------
 * Calculate the screen coords for any new vertices
 * introduced into the polygon.
 */
void
RefClipper::ComputeScreenCoordinates( RDClipVertex **inv, int count )
{
    int i;

    for (i = 0; i < count; i++)
    {
        RDClipVertex *p;
        p = inv[i];

        //
        // Catch any vertices that need screen co-ordinates generated.
        // There are two possibilities
        //      1) Vertices generated during interpolation
        //      2) Vertices marked for clipping by the transform but
        //              not clipped here due to the finite precision
        //              of the floating point unit.
        //

        if( p->m_clip & ~CLIPPED_ENABLE )
        {
            D3DVALUE inv_w;

            inv_w = D3DVAL(1.0)/p->m_clip_w;
            switch ((int)p->m_clip & (CLIPPED_LEFT|CLIPPED_RIGHT))
            {
            case CLIPPED_LEFT:  p->m_pos.x = minXgb; break;
            case CLIPPED_RIGHT: p->m_pos.x = maxXgb; break;
            default:
                p->m_pos.x = p->m_clip_x * scaleX * inv_w + offsetX;
                if( p->m_pos.x < minXgb )
                    p->m_pos.x = minXgb;
                if( p->m_pos.x > maxXgb )
                    p->m_pos.x = maxXgb;
            }
            switch ((int)p->m_clip & (CLIPPED_TOP|CLIPPED_BOTTOM))
            {
            case CLIPPED_BOTTOM: p->m_pos.y = maxYgb; break;
            case CLIPPED_TOP:    p->m_pos.y = minYgb; break;
            default:
                p->m_pos.y = p->m_clip_y * scaleY * inv_w + offsetY;
                if( p->m_pos.y < minYgb )
                    p->m_pos.y = minYgb;
                if( p->m_pos.y > maxYgb )
                    p->m_pos.y = maxYgb;
            }
            p->m_pos.z = p->m_clip_z * scaleZ * inv_w + offsetZ;
            p->m_rhw = inv_w;
        }
    }
}
//---------------------------------------------------------------------
void
RefClipper::Interpolate( RDClipVertex *out, RDClipVertex *p1, RDClipVertex *p2,
                         int code, D3DVALUE num, D3DVALUE denom )
{
    DWORD dwInterpolate = m_dwInterpolate;
    D3DVALUE num_denom = num / denom;

    out->m_clip = (((int)p1->m_clip & (int)p2->m_clip) & ~CLIPPED_ENABLE) | code;
    out->m_clip_x = p1->m_clip_x + (p2->m_clip_x - p1->m_clip_x) * num_denom;
    out->m_clip_y = p1->m_clip_y + (p2->m_clip_y - p1->m_clip_y) * num_denom;
    out->m_clip_z = p1->m_clip_z + (p2->m_clip_z - p1->m_clip_z) * num_denom;
    out->m_clip_w = p1->m_clip_w + (p2->m_clip_w - p1->m_clip_w) * num_denom;
    out->m_diffuse = clip_color;
    out->m_specular = clip_specular;

    /*
     * Interpolate any other color model or quality dependent values.
     */
    if( dwInterpolate & RDCLIP_INTERPOLATE_COLOR )
    {
        InterpolateColor(out, p1, p2, num_denom);
    }

    if( dwInterpolate & RDCLIP_INTERPOLATE_SPECULAR )
    {
        InterpolateSpecular(out, p1, p2, num_denom);
    }

    if( dwInterpolate & RDCLIP_INTERPOLATE_TEXTURE )
    {
        UINT64 qwFVF = p1->m_qwFVF;

        // Assume that D3DRENDERSTATE_WRAPi are sequential
        DWORD numTex = FVF_TEXCOORD_NUMBER(qwFVF);
        for (DWORD i = 0; i < numTex; i++)
        {
            FLOAT* pTexture1 = (FLOAT *)&p1->m_tex[i];
            FLOAT* pTexture2 = (FLOAT *)&p2->m_tex[i];
            FLOAT* pTexture  = (FLOAT *)&out->m_tex[i];
            DWORD wrapState;

            if( m_dwFlags & RCLIP_DO_ADJUSTWRAP )
            {
                DWORD TCI = m_pDev->GetTSS(i)[D3DTSS_TEXCOORDINDEX] & 0xffff;
                wrapState = m_pDev->GetRS()[D3DRENDERSTATE_WRAP0 + TCI];
            }
            else
            {
                wrapState = m_pDev->GetRS()[D3DRENDERSTATE_WRAP0 + i];
            }

            DWORD n = GetTexCoordDim(qwFVF, i);
            // DWORD n = (DWORD)(m_dwTexCoordSizeArray[i] >> 2);
            DWORD dwWrapBit = 1;
            for (DWORD j=0; j < n; j++)
            {
                pTexture[j] = InterpolateTexture(pTexture1[j], pTexture2[j],
                                                 num_denom,
                                                 wrapState & dwWrapBit);
                dwWrapBit <<= 1;
            }
        }
    }
    if( dwInterpolate & RDCLIP_INTERPOLATE_S )
    {
        out->m_pointsize = p1->m_pointsize +
            (p2->m_pointsize - p1->m_pointsize) * num_denom;
    }
    if( dwInterpolate & RDCLIP_INTERPOLATE_FOG )
    {
        out->m_fog = p1->m_fog + (p2->m_fog - p1->m_fog) * num_denom;
    }
}

//------------------------------------------------------------------------------
// Functions for clipping by frustum window
//
#define __CLIP_NAME ClipLeft
#define __CLIP_LINE_NAME ClipLineLeft
#define __CLIP_FLAG CLIPPED_LEFT
#define __CLIP_COORD m_clip_x
#include "clip.h"

#define __CLIP_NAME ClipRight
#define __CLIP_LINE_NAME ClipLineRight
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_RIGHT
#define __CLIP_COORD m_clip_x
#include "clip.h"

#define __CLIP_NAME ClipBottom
#define __CLIP_LINE_NAME ClipLineBottom
#define __CLIP_FLAG CLIPPED_BOTTOM
#define __CLIP_COORD m_clip_y
#include "clip.h"

#define __CLIP_NAME ClipTop
#define __CLIP_LINE_NAME ClipLineTop
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_TOP
#define __CLIP_COORD m_clip_y
#include "clip.h"

#define __CLIP_NAME ClipBack
#define __CLIP_LINE_NAME ClipLineBack
#define __CLIP_W
#define __CLIP_FLAG CLIPPED_BACK
#define __CLIP_COORD m_clip_z
#include "clip.h"

#define __CLIP_NAME ClipFront
#define __CLIP_LINE_NAME ClipLineFront
#define __CLIP_FLAG CLIPPED_FRONT
#define __CLIP_COORD m_clip_z
#include "clip.h"
//------------------------------------------------------------------------------
// Functions for guard band clipping
//
#define __CLIP_GUARDBAND
#define __CLIP_NAME ClipLeftGB
#define __CLIP_LINE_NAME ClipLineLeftGB
#define __CLIP_FLAG CLIPPED_LEFT
#define __CLIP_COORD m_clip_x
#define __CLIP_SIGN -
#define __CLIP_GBCOEF Kgbx1
#include "clip.h"

#define __CLIP_NAME ClipRightGB
#define __CLIP_LINE_NAME ClipLineRightGB
#define __CLIP_FLAG CLIPPED_RIGHT
#define __CLIP_COORD m_clip_x
#define __CLIP_GBCOEF Kgbx2
#define __CLIP_SIGN +
#include "clip.h"

#define __CLIP_NAME ClipBottomGB
#define __CLIP_LINE_NAME ClipLineBottomGB
#define __CLIP_FLAG CLIPPED_BOTTOM
#define __CLIP_COORD m_clip_y
#define __CLIP_SIGN -
#define __CLIP_GBCOEF Kgby1
#include "clip.h"

#define __CLIP_NAME ClipTopGB
#define __CLIP_LINE_NAME ClipLineTopGB
#define __CLIP_FLAG CLIPPED_TOP
#define __CLIP_COORD m_clip_y
#define __CLIP_GBCOEF Kgby2
#define __CLIP_SIGN +
#include "clip.h"

#undef __CLIP_GUARDBAND

//---------------------------------------------------------------------
inline DWORD
ComputeClipCodeUserPlanes( RDUSERCLIPPLANE *UserPlanes, RDClipVertex *p)
{
    DWORD clip = 0;
    DWORD dwClipBit = RDCLIP_USERCLIPPLANE0;
    for( DWORD j=0; j<RD_MAX_USER_CLIPPLANES; j++)
    {
        if( UserPlanes[j].bActive )
        {
            RDVECTOR4& plane = UserPlanes[j].plane;
            if( (p->m_clip_x*plane.x +
                 p->m_clip_y*plane.y +
                 p->m_clip_z*plane.z +
                 p->m_clip_w*plane.w) < 0 )
            {
                clip |= dwClipBit;
            }
        }
        dwClipBit <<= 1;
    }
    return clip;
}

//---------------------------------------------------------------------
inline DWORD
RefClipper::ComputeClipCodeGB( RDClipVertex *p )
{
    DWORD clip = 0;
    if( p->m_clip_x < p->m_clip_w * Kgbx1 )
        clip |= RDCLIPGB_LEFT;
    if( p->m_clip_x > p->m_clip_w * Kgbx2 )
        clip |= RDCLIPGB_RIGHT;
    if( p->m_clip_y < p->m_clip_w * Kgby1 )
        clip |= RDCLIPGB_BOTTOM;
    if( p->m_clip_y > p->m_clip_w * Kgby2 )
        clip |= RDCLIPGB_TOP;
    if( p->m_clip_z > p->m_clip_w )
        clip |= RDCLIP_BACK;
    clip |= ComputeClipCodeUserPlanes( m_xfmUserClipPlanes, p );
    p->m_clip = (p->m_clip & (CLIPPED_ENABLE | CLIPPED_FRONT)) | clip;
    return clip;
}

//---------------------------------------------------------------------
inline DWORD
RefClipper::ComputeClipCode( RDClipVertex *p )
{
    DWORD clip = 0;
    if( FLOAT_LTZ(p->m_clip_x) )
        clip |= RDCLIP_LEFT;
    if( p->m_clip_x > p->m_clip_w )
        clip |= RDCLIP_RIGHT;
    if( FLOAT_LTZ(p->m_clip_y) )
        clip |= RDCLIP_BOTTOM;
    if( p->m_clip_y > p->m_clip_w )
        clip |= RDCLIP_TOP;
    if( p->m_clip_z > p->m_clip_w )
        clip |= RDCLIP_BACK;
    clip |= ComputeClipCodeUserPlanes( m_xfmUserClipPlanes, p );
    p->m_clip = (p->m_clip & (CLIPPED_ENABLE | CLIPPED_FRONT)) | clip;
    return clip;
}

//---------------------------------------------------------------------
// RefDev::UpdateClipper
//             Updates clipping data used by ProcessVertices
// BOOL bProgrammablePipeLine: If this is true, it means that the 
//                             programmable vertex machine is invoking
//                             this method.
//---------------------------------------------------------------------
HRESULT
RefDev::UpdateClipper()
{
    HRESULT hr = D3D_OK;

    HR_RET( m_Clipper.UpdateViewData() );
    DWORD dwClipPlanesEnable =
        GetRS()[D3DRENDERSTATE_CLIPPLANEENABLE];

    if( !GetRS()[D3DRENDERSTATE_CLIPPING] )
        return S_OK;

    m_Clipper.m_dwFlags &= ~RefClipper::RCLIP_DO_ADJUSTWRAP;
    if( (m_RefVP.m_dwTLState & (RDPV_DOTEXXFORM | RDPV_DOTEXGEN)) &&
        m_pCurrentVShader->IsFixedFunction() )
        m_Clipper.m_dwFlags |= RefClipper::RCLIP_DO_ADJUSTWRAP;

    // Figure out which pieces need to be interpolated in new vertices.
    m_Clipper.m_dwInterpolate = 0;
    if(  GetRS()[D3DRENDERSTATE_SHADEMODE] == D3DSHADE_GOURAUD  )
    {
        m_Clipper.m_dwInterpolate |= RDCLIP_INTERPOLATE_COLOR;

        if( m_qwFVFOut & D3DFVF_SPECULAR )
        {
            m_Clipper.m_dwInterpolate |= RDCLIP_INTERPOLATE_SPECULAR;
        }
    }

    // if( GetRS()[D3DRENDERSTATE_FOGENABLE] )
    if( m_qwFVFOut & D3DFVFP_FOG )
    {
        m_Clipper.m_dwInterpolate |= RDCLIP_INTERPOLATE_FOG;
    }

    if( FVF_TEXCOORD_NUMBER(m_qwFVFOut) != 0 )
    {
        m_Clipper.m_dwInterpolate |= RDCLIP_INTERPOLATE_TEXTURE;
    }

    if( m_qwFVFOut & D3DFVF_PSIZE ) // m_primType == D3DPT_POINTLIST
    {
        m_Clipper.m_dwInterpolate |= RDCLIP_INTERPOLATE_S;
    }

    // Clear clip union and intersection flags
    m_Clipper.m_clipIntersection = 0;
    m_Clipper.m_clipUnion = 0;

    // The matrix to transform user clip planes depends on whether it is a
    // fixed function pipeline or a programmable pipeline. 
    // Programmable pipeline: the clip-planes are transformed by the 
    //     Inverse(Mshift) to adjust for clipping in the clipper. The user is 
    //     assumed to have pre-transformed the clip-planes to the clipping 
    //     space.
    // Fixed function pipeline: the clip-planes are transformed to the clipping
    //     space by the Inverse(Mview * Mproj * Mshift).
    RDMATRIX* pUserClipPlaneMatrix = NULL; 
    RDMATRIX matProgPipe = 
    { 
        2, 0, 0, 0,
        0, 2, 0, 0,
        0, 0, 1, 0,
       -1,-1, 0, 1 
    };
    
    if( m_pCurrentVShader->IsFixedFunction() )
    {
        pUserClipPlaneMatrix = &(m_RefVP.m_TransformData.m_VPSInv);
    }
    else
    {
        pUserClipPlaneMatrix = &matProgPipe;
    }

    // Update the user defined clip plane data
    for( DWORD i=0; i<RD_MAX_USER_CLIPPLANES; i++ )
    {
        // Figure out if it is active
        m_Clipper.m_xfmUserClipPlanes[i].bActive =
            (BOOL)(dwClipPlanesEnable & 0x1);
        dwClipPlanesEnable >>= 1;

        // If it is active, transform it into eye-space using the
        // view transform. The clip planes are defined in the
        // world space.
        if( m_Clipper.m_xfmUserClipPlanes[i].bActive )
        {
            XformPlaneBy4x4Transposed( &(m_Clipper.m_userClipPlanes[i]),
                                       pUserClipPlaneMatrix,
                                       &(m_Clipper.m_xfmUserClipPlanes[i].plane) );
        }
    }
    return hr;
}

//----------------------------------------------------------------------------
//
// DrawOnePrimitive
//
// Draw one clipped primitive.
//
//----------------------------------------------------------------------------
HRESULT
RefClipper::DrawOnePrimitive( GArrayT<RDVertex>& VtxArray,
                              DWORD dwStartVertex,
                              D3DPRIMITIVETYPE PrimType,
                              UINT cVertices )
{
    INT i;
    RDVertex* pV0;
    RDVertex* pV1;
    RDVertex* pV2;
    HRESULT hr;
    DWORD dwCurrVtx = dwStartVertex;

    switch( PrimType )
    {
    case D3DPT_POINTLIST:
        for (i = 0; i < (INT)cVertices; i++)
        {
            DrawPoint(&VtxArray[i]);
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cVertices / 2; i > 0; i--)
        {
            pV0 = &VtxArray[dwCurrVtx++];
            pV1 = &VtxArray[dwCurrVtx++];

            DrawLine(pV0, pV1);
        }
        break;
    case D3DPT_LINESTRIP:
        {
            pV1 = &VtxArray[dwCurrVtx];

            // Disable last-pixel setting for shared verties and store prestate.
            m_pDev->StoreLastPixelState(TRUE);

            // Initial pV0.
            for (i = (INT)cVertices - 1; i > 1; i--)
            {
                pV0 = pV1;
                dwCurrVtx++;
                pV1 = &VtxArray[dwCurrVtx];
                DrawLine(pV0, pV1);
            }

            // Restore last-pixel setting.
            m_pDev->StoreLastPixelState(FALSE);

            // Draw last line with last-pixel setting from state.
            if( i == 1 )
            {
                dwCurrVtx++;
                pV0 = &VtxArray[dwCurrVtx];
                DrawLine(pV1, pV0);
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cVertices; i > 0; i -= 3)
        {
            pV0 = &VtxArray[dwCurrVtx++];
            pV1 = &VtxArray[dwCurrVtx++];
            pV2 = &VtxArray[dwCurrVtx++];

            DrawTriangle(pV0, pV1, pV2);
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = &VtxArray[dwCurrVtx++];
            pV2 = &VtxArray[dwCurrVtx++];

            for (i = (INT)cVertices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[dwCurrVtx++];
                DrawTriangle(pV0, pV1, pV2);

                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[dwCurrVtx++];
                DrawTriangle(pV0, pV2, pV1);
            }

            if( i > 0 )
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[dwCurrVtx];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            RDCLIPCODE c0, c1, c2;

            pV2 = &VtxArray[dwCurrVtx++];
            // Preload initial pV0.
            pV1 = &VtxArray[dwCurrVtx++];
            for (i = (INT)cVertices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = &VtxArray[dwCurrVtx++];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;

    default:
        DPFERR("Refrast Error: Unknown or unsupported primitive type "
            "requested of DrawOnePrimitive");
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

//----------------------------------------------------------------------------
//
// DrawOneIndexedPrimitive
//
// Draw one list of clipped indexed primitives.
//
//----------------------------------------------------------------------------
HRESULT
RefClipper::DrawOneIndexedPrimitive( GArrayT<RDVertex>& VtxArray,
                                     int  StartVertexIndex,
                                     LPWORD pIndices,
                                     DWORD StartIndex,
                                     UINT  cIndices,
                                     D3DPRIMITIVETYPE PrimType )
{
    INT i;
    RDVertex* pV0;
    RDVertex* pV1;
    RDVertex* pV2;
    LPWORD puIndices = pIndices + StartIndex;
    DWORD dwCurrIndex;

    HRESULT hr;

    switch( PrimType )
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cIndices; i > 0; i--)
        {
            pV0 = &VtxArray[StartVertexIndex + *puIndices++];
            DrawPoint( pV0 );
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cIndices / 2; i > 0; i--)
        {
            pV0 = &VtxArray[StartVertexIndex + *puIndices++];
            pV1 = &VtxArray[StartVertexIndex + *puIndices++];
            DrawLine(pV0, pV1);
        }
        break;
    case D3DPT_LINESTRIP:
        {
            // Disable last-pixel setting for shared verties and store prestate.
            m_pDev->StoreLastPixelState(TRUE);
            // Initial pV1.
            pV1 = &VtxArray[StartVertexIndex + *puIndices++];
            for (i = (INT)cIndices - 1; i > 1; i--)
            {
                pV0 = pV1;
                pV1 = &VtxArray[StartVertexIndex + *puIndices++];
                DrawLine(pV0, pV1);
            }
            // Restore last-pixel setting.
            m_pDev->StoreLastPixelState(FALSE);

            // Draw last line with last-pixel setting from state.
            if( i == 1 )
            {
                pV0 = &VtxArray[StartVertexIndex + *puIndices];
                DrawLine(pV1, pV0);
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cIndices; i > 0; i -= 3)
        {
            pV0 = &VtxArray[StartVertexIndex + *puIndices++];
            pV1 = &VtxArray[StartVertexIndex + *puIndices++];
            pV2 = &VtxArray[StartVertexIndex + *puIndices++];
            DrawTriangle(pV0, pV1, pV2);
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = &VtxArray[StartVertexIndex + *puIndices++];
            pV2 = &VtxArray[StartVertexIndex + *puIndices++];

            for (i = (INT)cIndices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + *puIndices++];
                DrawTriangle(pV0, pV1, pV2);

                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + *puIndices++];
                DrawTriangle(pV0, pV2, pV1);
            }

            if( i > 0 )
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + *puIndices++];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = &VtxArray[StartVertexIndex + *puIndices++];
            // Preload initial pV0.
            pV1 = &VtxArray[StartVertexIndex + *puIndices++];
            for (i = (INT)cIndices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = &VtxArray[StartVertexIndex + *puIndices++];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;

    default:
        DPFERR("Refrast Error: Unknown or unsupported primitive type "
            "requested of DrawOneIndexedPrimitive");
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}

HRESULT
RefClipper::DrawOneIndexedPrimitive( GArrayT<RDVertex>& VtxArray,
                                     int   StartVertexIndex,
                                     LPDWORD pIndices,
                                     DWORD StartIndex,
                                     UINT  cIndices,
                                     D3DPRIMITIVETYPE PrimType )
{
    INT i;
    RDVertex* pV0;
    RDVertex* pV1;
    RDVertex* pV2;
    LPDWORD puIndices = pIndices + StartIndex;

    HRESULT hr;

    switch( PrimType )
    {
    case D3DPT_POINTLIST:
        for (i = (INT)cIndices; i > 0; i--)
        {
            pV0 = &VtxArray[StartVertexIndex + *puIndices++];
            DrawPoint(pV0);
        }
        break;

    case D3DPT_LINELIST:
        for (i = (INT)cIndices / 2; i > 0; i--)
        {
            pV0 = &VtxArray[StartVertexIndex + *puIndices++];
            pV1 = &VtxArray[StartVertexIndex + *puIndices++];
            DrawLine(pV0, pV1);
        }
        break;
    case D3DPT_LINESTRIP:
        {
            // Disable last-pixel setting for shared verties and store prestate.
            m_pDev->StoreLastPixelState(TRUE);
            // Initial pV1.
            pV1 = &VtxArray[StartVertexIndex + *puIndices++];
            for (i = (INT)cIndices - 1; i > 1; i--)
            {
                pV0 = pV1;
                pV1 = &VtxArray[StartVertexIndex + *puIndices++];
                DrawLine(pV0, pV1);
            }
            // Restore last-pixel setting.
            m_pDev->StoreLastPixelState(FALSE);

            // Draw last line with last-pixel setting from state.
            if( i == 1 )
            {
                pV0 = &VtxArray[StartVertexIndex + *puIndices];
                DrawLine(pV1, pV0);
            }
        }
        break;

    case D3DPT_TRIANGLELIST:
        for (i = (INT)cIndices; i > 0; i -= 3)
        {
            pV0 = &VtxArray[StartVertexIndex + *puIndices++];
            pV1 = &VtxArray[StartVertexIndex + *puIndices++];
            pV2 = &VtxArray[StartVertexIndex + *puIndices++];
            DrawTriangle(pV0, pV1, pV2);
        }
        break;
    case D3DPT_TRIANGLESTRIP:
        {
            // Get initial vertex values.
            pV1 = &VtxArray[StartVertexIndex + *puIndices++];
            pV2 = &VtxArray[StartVertexIndex + *puIndices++];

            for (i = (INT)cIndices - 2; i > 1; i -= 2)
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + *puIndices++];
                DrawTriangle(pV0, pV1, pV2);

                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + *puIndices++];
                DrawTriangle(pV0, pV2, pV1);
            }

            if( i > 0 )
            {
                pV0 = pV1;
                pV1 = pV2;
                pV2 = &VtxArray[StartVertexIndex + *puIndices++];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;
    case D3DPT_TRIANGLEFAN:
        {
            pV2 = &VtxArray[StartVertexIndex + *puIndices++];
            // Preload initial pV0.
            pV1 = &VtxArray[StartVertexIndex + *puIndices++];
            for (i = (INT)cIndices - 2; i > 0; i--)
            {
                pV0 = pV1;
                pV1 = &VtxArray[StartVertexIndex + *puIndices++];
                DrawTriangle(pV0, pV1, pV2);
            }
        }
        break;

    default:
        DPFERR("Refrast Error: Unknown or unsupported primitive type "
               "requested of DrawOneIndexedPrimitive");
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}


///////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////

void
RefClipper::DrawTriangle( RDVertex* pV0, RDVertex* pV1, RDVertex* pV2,
                          WORD wFlags )
{
    // If the clip-codes dont exist then compute them. This happens only
    // for Transformed vertices that are directly passed in to be rasterized.
    if( (pV0->m_qwFVF & D3DFVFP_CLIP) == 0 ) ComputeClipCodesTL( pV0 );
    if( (pV1->m_qwFVF & D3DFVFP_CLIP) == 0 ) ComputeClipCodesTL( pV1 );
    if( (pV2->m_qwFVF & D3DFVFP_CLIP) == 0 ) ComputeClipCodesTL( pV2 );

    RDCLIPCODE c0 = pV0->m_clip;
    RDCLIPCODE c1 = pV1->m_clip;
    RDCLIPCODE c2 = pV2->m_clip;

    DWORD dwInter = (c0 & c1 & c2);
    DWORD dwUnion = (c0 | c1 | c2);
    DWORD dwMask = (UseGuardBand()) ? RDCLIPGB_ALL : RDCLIP_ALL;

    // All vertices outside the frustum or guardband,
    // return without drawing
    if( dwInter )
    {
        return;
    }

    // If all the vertices are in, draw and return
    if( (dwUnion & dwMask) == 0 )
    {
        m_pDev->DrawTriangle( pV0, pV1, pV2, wFlags );
        return;
    }

    // Do Clipping
    RDCLIPTRIANGLE newtri;
    RDClipVertex cv[3];

    MakeClipVertexFromVertex( cv[0], *pV0, dwMask);
    MakeClipVertexFromVertex( cv[1], *pV1, dwMask);
    MakeClipVertexFromVertex( cv[2], *pV2, dwMask);

    newtri.v[0] = &cv[0]; cv[0].next = &cv[1];
    newtri.v[1] = &cv[1]; cv[1].next = &cv[2];
    newtri.v[2] = &cv[2]; cv[2].next = NULL;

    int count;
    RDClipVertex **ver;
    cv[0].m_clip |= CLIPPED_ENABLE;
    cv[1].m_clip |= CLIPPED_ENABLE;
    cv[2].m_clip |= CLIPPED_ENABLE;

    if( count = ClipSingleTriangle( &newtri, &ver ) )
    {
        int i;

        // Temporary Byte Array
        if( FAILED( ClipBuf.Grow(count) ) ) return;

        for (i = 0; i < count; i++)
        {
            MakeVertexFromClipVertex( ClipBuf[i], *(ver[i]) );
            ClipBuf[i].SetFVF( pV0->m_qwFVF );
        }

        // If it is in wireframe mode, convert the clipper output to
        // a line list.
        if( m_dwFlags & RCLIP_DO_WIREFRAME )
        {
            DWORD dwEdgeFlags = 0;
            for (i = 0; i < count; i++)
            {
                if( ver[i]->m_clip & CLIPPED_ENABLE ) dwEdgeFlags |= (1 << i);
            }

            m_pDev->DrawOneEdgeFlagTriangleFan( ClipBuf, count, dwEdgeFlags );
        }
        else
        {
            m_pDev->DrawOnePrimitive( ClipBuf, 0, D3DPT_TRIANGLEFAN, count );
        }
    }
}

void
RefClipper::DrawLine( RDVertex* pV0, RDVertex* pV1 )
{
    // If the clip-codes dont exist then compute them. This happens only
    // for Transformed vertices that are directly passed in to be rasterized.
    if( (pV0->m_qwFVF & D3DFVFP_CLIP) == 0 ) ComputeClipCodesTL( pV0 );
    if( (pV1->m_qwFVF & D3DFVFP_CLIP) == 0 ) ComputeClipCodesTL( pV1 );

    RDCLIPCODE c0 = pV0->m_clip;
    RDCLIPCODE c1 = pV1->m_clip;

    DWORD dwInter = (c0 & c1);
    DWORD dwUnion = (c0 | c1);
    DWORD dwMask = (UseGuardBand()) ? RDCLIPGB_ALL : RDCLIP_ALL;

    // All vertices outside the frustum or guardband,
    // return without drawing
    if( dwInter )
    {
        return;
    }

    // If all the vertices are in, draw and return
    if( (dwUnion & dwMask) == 0 )
    {
        m_pDev->DrawLine( pV0, pV1 );
        return;
    }

    RDCLIPTRIANGLE newline;
    RDClipVertex cv[2];

    MakeClipVertexFromVertex( cv[0], *pV0, dwMask );
    MakeClipVertexFromVertex( cv[1], *pV1, dwMask );

    newline.v[0] = &cv[0];
    newline.v[1] = &cv[1];

    if( ClipSingleLine( &newline ) )
    {
        // Temporary Byte Array
        if( FAILED(ClipBuf.Grow( 2 )) ) return;
        MakeVertexFromClipVertex( ClipBuf[0], *(newline.v[0]) );
        MakeVertexFromClipVertex( ClipBuf[1], *(newline.v[1]) );
        ClipBuf[0].SetFVF( pV0->m_qwFVF );
        ClipBuf[1].SetFVF( pV0->m_qwFVF );

        m_pDev->DrawLine( &ClipBuf[0], &ClipBuf[1] );
    }
}

void
RefClipper::DrawPoint( RDVertex* pV0 )
{
    // If the clip-codes dont exist then compute them. This happens only
    // for Transformed vertices that are directly passed in to be rasterized.
    if( (pV0->m_qwFVF & D3DFVFP_CLIP) == 0 ) ComputeClipCodesTL( pV0 );

    RDCLIPCODE c0 = pV0->m_clip;
    DWORD dwMask = (UseGuardBand()) ? RDCLIPGB_ALL : RDCLIP_ALL;

    // if definitely out
#if 0
    if( c0 & (RDCLIP_FRONT | RDCLIP_BACK |
              (1<<RDCLIPGB_LEFTBIT) | (1<<RDCLIPGB_RIGHTBIT) |
              (1<<RDCLIPGB_TOPBIT) | (1<<RDCLIPGB_BOTTOMBIT)) )
        return;
#else
    if( c0 & dwMask ) return;
#endif
    // is completely in, just draw it
    m_pDev->DrawPoint( pV0 );
}

////////////////////////////////////////////////////////////////////////////
//
//  Returns 0, if triangle is clipped. Number of vertices otherwise.
//
//  Original vertices should not be modified inside the function
////////////////////////////////////////////////////////////////////////////

int
RefClipper::ClipSingleTriangle( RDCLIPTRIANGLE *tri,
                                RDClipVertex ***clipVertexPointer )
{
    int accept;
    int i, j;
    int count;
    RDClipVertex **inv;
    RDClipVertex **outv;
    RDClipVertex *p;
    ULONG_PTR swapv;
    RDCOLOR4 diffuse1;          // Original colors
    RDCOLOR4 specular1;
    RDCOLOR4 diffuse2;
    RDCOLOR4 specular2;
    DWORD dwClipBit;
    DWORD dwClippedBit;

    if( m_dwFlags & RCLIP_DO_FLATSHADING )
    {
        // It is easier to set all vertices to the same color here
        RDCOLOR4 diffuse  = tri->v[0]->m_diffuse;
        RDCOLOR4 specular = tri->v[0]->m_specular;

        //Save original colors
        diffuse1  = tri->v[1]->m_diffuse;
        specular1 = tri->v[1]->m_specular;
        diffuse2  = tri->v[2]->m_diffuse;
        specular2 = tri->v[2]->m_specular;

        tri->v[1]->m_diffuse = diffuse;
        tri->v[1]->m_specular = specular;
        tri->v[2]->m_diffuse = diffuse;
        tri->v[2]->m_specular = specular;
    }
    accept = (tri->v[0]->m_clip | tri->v[1]->m_clip | tri->v[2]->m_clip);

    inv = tri->v;
    count = 3;
    outv = clip_vbuf1;
    clip_color = tri->v[0]->m_diffuse;
    clip_specular = tri->v[0]->m_specular;

    /*
     * XXX assumes sizeof(void*) == sizeof(unsigned long)
     */
    {
        ULONG_PTR tmp1;
        ULONG_PTR tmp2;

        tmp1 = (ULONG_PTR)clip_vbuf1;
        tmp2 = (ULONG_PTR)clip_vbuf2;

        swapv = tmp1 + tmp2;
    }
    clip_vertices_used = 0;

#define SWAP(inv, outv)     \
    inv = outv;             \
    outv = (RDClipVertex**) (swapv - (ULONG_PTR) outv)

    if( accept & RDCLIP_FRONT )
    {
        count = ClipFront( inv, outv, count );
        if( count < 3 )
            goto out_of_here;
        SWAP(inv, outv);
    }
    if( UseGuardBand() )
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if( accept & RDCLIP_FRONT )
        {
            accept = 0;
            for (i = 0; i < count; i++)
            {
                RDClipVertex *p;
                p = inv[i];
                if( p->m_clip & CLIPPED_FRONT )
                    accept |= ComputeClipCodeGB( p );
                else
                    accept |= p->m_clip;
            }
        }
        if( accept & RDCLIP_BACK )
        {
            count = ClipBack( inv, outv, count );
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
        if( accept & RDCLIPGB_LEFT )
        {
            count = ClipLeftGB( inv, outv, count );
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
        if( accept & RDCLIPGB_RIGHT )
        {
            count = ClipRightGB( inv, outv, count );
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
        if( accept & RDCLIPGB_BOTTOM )
        {
            count = ClipBottomGB( inv, outv, count );
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
        if( accept & RDCLIPGB_TOP )
        {
            count = ClipTopGB( inv, outv, count );
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
    }
    else
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if( accept & RDCLIP_FRONT )
        {
            accept = 0;
            for (i = 0; i < count; i++)
            {
                RDClipVertex *p;
                p = inv[i];
                if( p->m_clip & (CLIPPED_FRONT) )
                    accept |= ComputeClipCode( p );
                else
                    accept |= p->m_clip;
            }
        }
        if( accept & RDCLIP_BACK )
        {
            count = ClipBack( inv, outv, count );
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
        if( accept & RDCLIP_LEFT )
        {
            count = ClipLeft( inv, outv, count );
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
        if( accept & RDCLIP_RIGHT )
        {
            count = ClipRight( inv, outv, count );
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
        if( accept & RDCLIP_BOTTOM )
        {
            count = ClipBottom( inv, outv, count );
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
        if( accept & RDCLIP_TOP )
        {
            count = ClipTop( inv, outv, count );
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
    }

    dwClipBit = RDCLIP_USERCLIPPLANE0;
    dwClippedBit = CLIPPED_USERCLIPPLANE0;
    // User Clip Planes
    for( j=0; j<RD_MAX_USER_CLIPPLANES; j++)
    {
        if( accept & dwClipBit )
        {
            count = ClipByPlane( inv, outv, &(m_xfmUserClipPlanes[j].plane),
                                 dwClippedBit, count);
            if( count < 3 )
                goto out_of_here;
            SWAP(inv, outv);
        }
        dwClipBit <<= 1;
        dwClippedBit <<= 1;
    }

#undef SWAP

    ComputeScreenCoordinates( inv, count );

    *clipVertexPointer = inv;
    current_vbuf = inv;
    return count;

out_of_here:

    *clipVertexPointer = NULL;
    return 0;
}

//-----------------------------------------------------------------------
//
int
RefClipper::ClipSingleLine( RDCLIPTRIANGLE *line )
{
    int         accept;
    int         j;
    D3DVALUE    in1, in2;
    DWORD dwClipBit;
    DWORD dwClippedBit;

    accept = (line->v[0]->m_clip | line->v[1]->m_clip);

    clip_color = line->v[0]->m_diffuse;
    clip_specular = line->v[0]->m_specular;

    if( accept & D3DCS_FRONT )
        if( ClipLineFront(line) )
            goto out_of_here;
    if( UseGuardBand() )
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if( accept & D3DCS_FRONT )
        {
            RDClipVertex * p;
            accept = 0;
            p = line->v[0];
            if( p->m_clip & CLIPPED_FRONT )
                accept |= ComputeClipCodeGB( p );
            else
                accept |= p->m_clip;
            p = line->v[1];
            if( p->m_clip & CLIPPED_FRONT )
                accept |= ComputeClipCodeGB( p );
            else
                accept |= p->m_clip;
        }
        if( accept & D3DCS_BACK )
            if( ClipLineBack( line ) )
                goto out_of_here;
        if( accept & RDCLIPGB_LEFT )
            if( ClipLineLeftGB( line ) )
                goto out_of_here;
        if( accept & RDCLIPGB_RIGHT )
            if( ClipLineRightGB( line ) )
                goto out_of_here;
        if( accept & RDCLIPGB_TOP )
            if( ClipLineTopGB( line ) )
                goto out_of_here;
        if( accept & RDCLIPGB_BOTTOM )
            if( ClipLineBottomGB( line ) )
                goto out_of_here;
    }
    else
    {
        // If there was clipping by the front plane it is better to
        // compute clip code for new vertices and re-compute accept.
        // Otherwise we will try to clip by sides when it is not necessary
        if( accept & D3DCS_FRONT )
        {
            RDClipVertex * p;
            accept = 0;
            p = line->v[0];
            if( p->m_clip & CLIPPED_FRONT )
                accept |= ComputeClipCode( p );
            else
                accept |= p->m_clip;
            p = line->v[1];
            if( p->m_clip & CLIPPED_FRONT )
                accept |= ComputeClipCode( p );
            else
                accept |= p->m_clip;
        }
        if( accept & D3DCS_BACK )
            if( ClipLineBack( line ) )
                goto out_of_here;
        if( accept & D3DCS_LEFT )
            if( ClipLineLeft( line ) )
                goto out_of_here;
        if( accept & D3DCS_RIGHT )
            if( ClipLineRight( line ) )
                goto out_of_here;
        if( accept & D3DCS_TOP )
            if( ClipLineTop( line ) )
                goto out_of_here;
        if( accept & D3DCS_BOTTOM )
            if( ClipLineBottom( line ) )
                goto out_of_here;
    }

    // User Clip Planes
    dwClipBit = RDCLIP_USERCLIPPLANE0;
    dwClippedBit = CLIPPED_USERCLIPPLANE0;
    for( j=0; j<RD_MAX_USER_CLIPPLANES; j++)
    {
        if( accept & dwClipBit )
        {
            if( ClipLineByPlane( line, &m_xfmUserClipPlanes[j].plane,
                                 dwClippedBit ))
                goto out_of_here;
        }
        dwClipBit <<= 1;
        dwClippedBit <<= 1;
    }

    ComputeScreenCoordinates( line->v, 2 );

    return 1;
out_of_here:
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\rast\texstage.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 2000.
//
// texstage.cpp
//
// Direct3D Reference Device - Texture Processing Stage Methods
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop

//-----------------------------------------------------------------------------
//
// ComputeTextureBlendArg - Computes texture argument for blending, using the
// specified argument control (D3DTA_* fields).  This is called 4 times per
// texture processing stage: 2 arguments for color and 2 arguments for alpha.
//
//-----------------------------------------------------------------------------
void
RefRast::ComputeTextureBlendArg(
    DWORD dwArgCtl, BOOL bAlphaOnly,
    const RDColor& DiffuseColor,
    const RDColor& SpecularColor,
    const RDColor& CurrentColor,
    const RDColor& TextureColor,
    const RDColor& TempColor,
    RDColor& BlendArg)
{
    // argument MUX
    switch ( dwArgCtl & D3DTA_SELECTMASK )
    {
    case D3DTA_DIFFUSE:  BlendArg = DiffuseColor; break;
    case D3DTA_CURRENT:  BlendArg = CurrentColor; break;
    case D3DTA_SPECULAR: BlendArg = SpecularColor; break;
    case D3DTA_TEXTURE:  BlendArg = TextureColor; break;
    case D3DTA_TFACTOR:
        BlendArg = m_pRD->GetRS()[D3DRS_TEXTUREFACTOR]; break;
    case D3DTA_TEMP:     BlendArg = TempColor; break;
    }

    // take compliment of all channels
    if ( dwArgCtl & D3DTA_COMPLEMENT )
    {
        BlendArg.A = 1.f - BlendArg.A;
        if ( !bAlphaOnly )
        {
            BlendArg.R = ( 1.f - BlendArg.R );
            BlendArg.G = ( 1.f - BlendArg.G );
            BlendArg.B = ( 1.f - BlendArg.B );
        }
    }

    // replicate alpha to color (after compliment)
    if ( !bAlphaOnly && ( dwArgCtl & D3DTA_ALPHAREPLICATE ) )
    {
        BlendArg.R =
        BlendArg.G =
        BlendArg.B = BlendArg.A;
    }
}

//-----------------------------------------------------------------------------
//
// DoTextureBlendStage - Does texture blend for one texture processing stage,
// combining results from the texture processing with the interpolated color(s)
// and previous stage's color.
//
// Note: All color channel multiplies should be done in such a way that a unit
// value on one side passes the value on the other side.  Thus for 8 bit color
// channels, '0xff * value' should return value, and 0xff * 0xff = 0xff,
// not 0xfe(01).
//
// RDColorChannel performs these operations with floating point. 8 bit color
// values of 0x00 to 0xff are mapped into the 0. to 1. range.  Performing these
// multiplies in fixed point requires an adjustment to adhere to this rule.
//
//
//-----------------------------------------------------------------------------
void
RefRast::DoTextureBlendStage(
    int iStage,
    const RDColor& DiffuseColor,
    const RDColor& SpecularColor,
    const RDColor& CurrentColor,
    const RDColor& TextureColor,
    RDColor& TempColor,
    RDColor& CurrentReturnColor)
{
    DPFM(5, TEX, ("DoTextureBlend\n"));

    RDColor BlendedColor;

    if (iStage >= 1)
    {
        if (m_pRD->GetTSS(iStage-1)[D3DTSS_COLOROP] == D3DTOP_PREMODULATE)
        {
            // pre-modulate the results of the last stage before using them
            // in this stage if last stage exists and is D3DTOP_PREMODULATE
            // cast away the const'ness, just for PREMODULATE
            ((RDColor&)CurrentColor).R = CurrentColor.R * TextureColor.R;
            ((RDColor&)CurrentColor).G = CurrentColor.G * TextureColor.G;
            ((RDColor&)CurrentColor).B = CurrentColor.B * TextureColor.B;
        }
        if (m_pRD->GetTSS(iStage-1)[D3DTSS_ALPHAOP] == D3DTOP_PREMODULATE)
        {
            // pre-modulate the results of the last stage before using them
            // in this stage if last stage exists and is D3DTOP_PREMODULATE
            ((RDColor&)CurrentColor).A *= CurrentColor.A * TextureColor.A;
        }
    }

    // compute arg0,1,2 for color channel blend
    RDColor ColorArg0, ColorArg1, ColorArg2;
    RDColor AlphaArg0, AlphaArg1, AlphaArg2;
    ComputeTextureBlendArg( m_pRD->GetTSS(iStage)[D3DTSS_COLORARG0], FALSE,
        DiffuseColor, SpecularColor, CurrentColor, TextureColor, TempColor, ColorArg0 );
    ComputeTextureBlendArg( m_pRD->GetTSS(iStage)[D3DTSS_COLORARG1], FALSE,
        DiffuseColor, SpecularColor, CurrentColor, TextureColor, TempColor, ColorArg1 );
    ComputeTextureBlendArg( m_pRD->GetTSS(iStage)[D3DTSS_COLORARG2], FALSE,
        DiffuseColor, SpecularColor, CurrentColor, TextureColor, TempColor, ColorArg2 );

    // do color channel blend
    FLOAT fModulateScale;
    FLOAT fBlendFactor;
    switch ( m_pRD->GetTSS(iStage)[D3DTSS_COLOROP] )
    {

    case D3DTOP_SELECTARG1:
        BlendedColor.R = ColorArg1.R;
        BlendedColor.G = ColorArg1.G;
        BlendedColor.B = ColorArg1.B;
        break;
    case D3DTOP_SELECTARG2:
        BlendedColor.R = ColorArg2.R;
        BlendedColor.G = ColorArg2.G;
        BlendedColor.B = ColorArg2.B;
        break;

    case D3DTOP_ADD:
        BlendedColor.R = ColorArg1.R + ColorArg2.R;
        BlendedColor.G = ColorArg1.G + ColorArg2.G;
        BlendedColor.B = ColorArg1.B + ColorArg2.B;
        break;
    case D3DTOP_ADDSIGNED:
        BlendedColor.R = ColorArg1.R + ColorArg2.R - .5f;
        BlendedColor.G = ColorArg1.G + ColorArg2.G - .5f;
        BlendedColor.B = ColorArg1.B + ColorArg2.B - .5f;
        break;
    case D3DTOP_ADDSIGNED2X:
        BlendedColor.R = (ColorArg1.R + ColorArg2.R - .5f)*2.0f;
        BlendedColor.G = (ColorArg1.G + ColorArg2.G - .5f)*2.0f;
        BlendedColor.B = (ColorArg1.B + ColorArg2.B - .5f)*2.0f;
        break;
    case D3DTOP_SUBTRACT:
        // true unsigned subtract that gets around saturation
        // ~a = 1-a, so ~((~a1 + a2)) = 1-(1-a1 + a2) = a1 - a2
        BlendedColor.R = 1.f - ((1.f - ColorArg1.R) + ColorArg2.R);
        BlendedColor.G = 1.f - ((1.f - ColorArg1.G) + ColorArg2.G);
        BlendedColor.B = 1.f - ((1.f - ColorArg1.B) + ColorArg2.B);
        break;
    case D3DTOP_ADDSMOOTH:
        // Arg1 + Arg2 - Arg1*Arg2 = Arg1 + (1-Arg1)*Arg2
        BlendedColor.R = ColorArg1.R + (1.f - ColorArg1.R)*ColorArg2.R;
        BlendedColor.G = ColorArg1.G + (1.f - ColorArg1.G)*ColorArg2.G;
        BlendedColor.B = ColorArg1.B + (1.f - ColorArg1.B)*ColorArg2.B;
        break;

    case D3DTOP_MODULATE:   fModulateScale = 1.; goto _DoModulateC;
    case D3DTOP_MODULATE2X: fModulateScale = 2.; goto _DoModulateC;
    case D3DTOP_MODULATE4X: fModulateScale = 4.; goto _DoModulateC;
_DoModulateC:
        BlendedColor.R = ColorArg1.R * ColorArg2.R * fModulateScale;
        BlendedColor.G = ColorArg1.G * ColorArg2.G * fModulateScale;
        BlendedColor.B = ColorArg1.B * ColorArg2.B * fModulateScale;
        break;

    case D3DTOP_BLENDDIFFUSEALPHA: fBlendFactor = DiffuseColor.A; goto _DoBlendC;
    case D3DTOP_BLENDTEXTUREALPHA: fBlendFactor = TextureColor.A; goto _DoBlendC;
    case D3DTOP_BLENDCURRENTALPHA: fBlendFactor = CurrentColor.A; goto _DoBlendC;
    case D3DTOP_BLENDFACTORALPHA:
        fBlendFactor = RGBA_GETALPHA( m_pRD->GetRS()[D3DRS_TEXTUREFACTOR] )*(1./255.);
        goto _DoBlendC;
_DoBlendC:
        BlendedColor.R = fBlendFactor * (ColorArg1.R - ColorArg2.R) + ColorArg2.R;
        BlendedColor.G = fBlendFactor * (ColorArg1.G - ColorArg2.G) + ColorArg2.G;
        BlendedColor.B = fBlendFactor * (ColorArg1.B - ColorArg2.B) + ColorArg2.B;
        break;

    case D3DTOP_BLENDTEXTUREALPHAPM:
        BlendedColor.R = ColorArg1.R + ( (1.f - TextureColor.A) * ColorArg2.R );
        BlendedColor.G = ColorArg1.G + ( (1.f - TextureColor.A) * ColorArg2.G );
        BlendedColor.B = ColorArg1.B + ( (1.f - TextureColor.A) * ColorArg2.B );
        break;

    case D3DTOP_PREMODULATE:
        // just copy ColorArg1 now, but remember to do the pre-modulate
        // when we get to the next stage
        BlendedColor.R = ColorArg1.R;
        BlendedColor.G = ColorArg1.G;
        BlendedColor.B = ColorArg1.B;
        break;
    case D3DTOP_MODULATEALPHA_ADDCOLOR:
        BlendedColor.R = ColorArg1.R + ColorArg1.A*ColorArg2.R;
        BlendedColor.G = ColorArg1.G + ColorArg1.A*ColorArg2.G;
        BlendedColor.B = ColorArg1.B + ColorArg1.A*ColorArg2.B;
        break;
    case D3DTOP_MODULATECOLOR_ADDALPHA:
        BlendedColor.R = ColorArg1.R*ColorArg2.R + ColorArg1.A;
        BlendedColor.G = ColorArg1.G*ColorArg2.G + ColorArg1.A;
        BlendedColor.B = ColorArg1.B*ColorArg2.B + ColorArg1.A;
        break;
    case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
        BlendedColor.R = (1.f - ColorArg1.A)*ColorArg2.R + ColorArg1.R;
        BlendedColor.G = (1.f - ColorArg1.A)*ColorArg2.G + ColorArg1.G;
        BlendedColor.B = (1.f - ColorArg1.A)*ColorArg2.B + ColorArg1.B;
        break;
    case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
        BlendedColor.R = (1.f - ColorArg1.R)*ColorArg2.R + ColorArg1.A;
        BlendedColor.G = (1.f - ColorArg1.G)*ColorArg2.G + ColorArg1.A;
        BlendedColor.B = (1.f - ColorArg1.B)*ColorArg2.B + ColorArg1.A;
        break;

    case D3DTOP_DOTPRODUCT3:
        BlendedColor.R = ((ColorArg1.R-0.5f)*2.0f*(ColorArg2.R-0.5f)*2.0f +
             (ColorArg1.G-0.5f)*2.0f*(ColorArg2.G-0.5f)*2.0f +
             (ColorArg1.B-0.5f)*2.0f*(ColorArg2.B-0.5f)*2.0f);
        BlendedColor.G = BlendedColor.R;
        BlendedColor.B = BlendedColor.R;
        BlendedColor.A = BlendedColor.R;
        goto _SkipAlphaChannelBlend;
        break;

    case D3DTOP_MULTIPLYADD:
        BlendedColor.R = ColorArg0.R + (ColorArg1.R * ColorArg2.R);
        BlendedColor.G = ColorArg0.G + (ColorArg1.G * ColorArg2.G);
        BlendedColor.B = ColorArg0.B + (ColorArg1.B * ColorArg2.B);
        break;

    case D3DTOP_LERP:   // (Arg0)*Arg1 + (1-Arg0)*Arg2 = Arg2 + Arg0*(Arg1-Arg2)
        BlendedColor.R = ColorArg2.R + ColorArg0.R*(ColorArg1.R - ColorArg2.R);
        BlendedColor.G = ColorArg2.G + ColorArg0.G*(ColorArg1.G - ColorArg2.G);
        BlendedColor.B = ColorArg2.B + ColorArg0.B*(ColorArg1.B - ColorArg2.B);
        break;
    }


    // compute arg0,1,2 for alpha channel blend
    ComputeTextureBlendArg( m_pRD->GetTSS(iStage)[D3DTSS_ALPHAARG0], TRUE,
        DiffuseColor, SpecularColor, CurrentColor, TextureColor, TempColor, AlphaArg0 );
    ComputeTextureBlendArg( m_pRD->GetTSS(iStage)[D3DTSS_ALPHAARG1], TRUE,
        DiffuseColor, SpecularColor, CurrentColor, TextureColor, TempColor, AlphaArg1 );
    ComputeTextureBlendArg( m_pRD->GetTSS(iStage)[D3DTSS_ALPHAARG2], TRUE,
        DiffuseColor, SpecularColor, CurrentColor, TextureColor, TempColor, AlphaArg2 );

    // do alpha channel blend
    switch ( m_pRD->GetTSS(iStage)[D3DTSS_ALPHAOP] )
    {
    case D3DTOP_LEGACY_ALPHAOVR:
        if (m_pRD->m_pTexture[0])
        {
            BlendedColor.A = ( m_pRD->m_pTexture[0]->m_bHasAlpha ) ? AlphaArg1.A : AlphaArg2.A;
        }
        else
        {
            BlendedColor.A = AlphaArg1.A;
        }
        break;

    case D3DTOP_SELECTARG1:
        BlendedColor.A = AlphaArg1.A;
        break;
    case D3DTOP_SELECTARG2:
        BlendedColor.A = AlphaArg2.A;
        break;

    case D3DTOP_ADD:
        BlendedColor.A = AlphaArg1.A + AlphaArg2.A;
        break;
    case D3DTOP_ADDSIGNED:
        BlendedColor.A = AlphaArg1.A + AlphaArg2.A - .5f;
        break;
    case D3DTOP_ADDSIGNED2X:
        BlendedColor.A = (AlphaArg1.A + AlphaArg2.A - .5f)*2.0f;
        break;
    case D3DTOP_SUBTRACT:
        // true unsigned subtract that gets around saturation
        // ~a = 1-a, so ~((~a1 + a2)) = 1-(1-a1 + a2) = a1 - a2
        BlendedColor.A = 1.f - ((1.f - AlphaArg1.A) + AlphaArg2.A);
        break;
    case D3DTOP_ADDSMOOTH:
        // Arg1 + Arg2 - Arg1*Arg2 = Arg1 + (1-Arg1)*Arg2
        BlendedColor.A = AlphaArg1.A + (1.f - AlphaArg1.A)*AlphaArg2.A;
        break;

    case D3DTOP_MODULATE:   fModulateScale = 1.; goto _DoModulateA;
    case D3DTOP_MODULATE2X: fModulateScale = 2.; goto _DoModulateA;
    case D3DTOP_MODULATE4X: fModulateScale = 4.; goto _DoModulateA;
_DoModulateA:
        BlendedColor.A = AlphaArg1.A * AlphaArg2.A * fModulateScale;
        break;

    case D3DTOP_BLENDDIFFUSEALPHA: fBlendFactor = DiffuseColor.A; goto _DoBlendA;
    case D3DTOP_BLENDTEXTUREALPHA: fBlendFactor = TextureColor.A; goto _DoBlendA;
    case D3DTOP_BLENDCURRENTALPHA: fBlendFactor = CurrentColor.A; goto _DoBlendA;
    case D3DTOP_BLENDFACTORALPHA:
        fBlendFactor = RGBA_GETALPHA( m_pRD->GetRS()[D3DRS_TEXTUREFACTOR] )*(1./255.);
        goto _DoBlendA;
_DoBlendA:
        BlendedColor.A = fBlendFactor * (AlphaArg1.A - AlphaArg2.A) + AlphaArg2.A;
        break;

    case D3DTOP_BLENDTEXTUREALPHAPM:
        BlendedColor.A = AlphaArg1.A + ( (1.f - TextureColor.A) * AlphaArg2.A );
        break;

    case D3DTOP_PREMODULATE:
        // just copy AlphaArg1 now, but remember to do the pre-modulate
        // when we get to the next stage
        BlendedColor.A = AlphaArg1.A;
        break;

    case D3DTOP_MODULATEALPHA_ADDCOLOR:
    case D3DTOP_MODULATECOLOR_ADDALPHA:
    case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
    case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
    case D3DTOP_DOTPRODUCT3:
        // does nothing, not valid alpha op's
        break;

    case D3DTOP_MULTIPLYADD:
        BlendedColor.A = ColorArg0.A + (ColorArg1.A * ColorArg2.A);
        break;

    case D3DTOP_LERP:   // (Arg0)*Arg1 + (1-Arg0)*Arg2 = Arg2 + Arg0*(Arg1-Arg2)
        BlendedColor.A = ColorArg2.A + ColorArg0.A*(ColorArg1.A - ColorArg2.A);
        break;
    }

_SkipAlphaChannelBlend:

    // clamp blended color after each blend stage
    BlendedColor.Clamp();

    // write to selected result register
    switch ( m_pRD->GetTSS(iStage)[D3DTSS_RESULTARG] )
    {
    default:
    case D3DTA_CURRENT: CurrentReturnColor = BlendedColor; break;
    case D3DTA_TEMP:    TempColor = BlendedColor; break;
    }

}

///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\tnl\lighting.cpp ===
#include "pch.cpp"
#pragma hdrstop

///////////////////////////////////////////////////////////////////////////////
// Vertex Lighting function implementations
///////////////////////////////////////////////////////////////////////////////
//---------------------------------------------------------------------
void
RDLV_Directional(
    RDLIGHTINGDATA& LData,
    D3DLIGHT7 *pLight,
    RDLIGHTI *pLightI,
    RDLIGHTINGELEMENT *in,
    DWORD  dwFlags,
    UINT64 qwFVFIn)
{
    // ATTENTION: Need to heed the specular flag set per light here!!
    BOOL bDoSpecular = dwFlags & RDPV_DOSPECULAR;
    BOOL bDoLocalViewer = dwFlags & RDPV_LOCALVIEWER;
    BOOL bDoColVertexAmbient = dwFlags & RDPV_COLORVERTEXAMB;
    BOOL bDoColVertexDiffuse = dwFlags & RDPV_COLORVERTEXDIFF;
    BOOL bDoColVertexSpecular = dwFlags & RDPV_COLORVERTEXSPEC;

    //
    // Add the material's ambient component
    //
    if (!bDoColVertexAmbient)
    {
        LData.diffuse.r += pLightI->Ma_La.r;
        LData.diffuse.g += pLightI->Ma_La.g;
        LData.diffuse.b += pLightI->Ma_La.b;
    }
    else
    {
        //
        // Note:
        // In case ColorVertexAmbient is enabled, note that it uses
        // VertexSpecular instead of VertexDiffuse
        //
        LData.diffuse.r += pLightI->La.r * LData.pAmbientSrc->r;
        LData.diffuse.g += pLightI->La.g * LData.pAmbientSrc->g;
        LData.diffuse.b += pLightI->La.b * LData.pAmbientSrc->b;
    }

    //
    // If no normals are present, bail out since we cannot perform the
    // normal-dependent computations
    //
    if( (qwFVFIn & D3DFVF_NORMAL) == 0 )
    {
        return;
    }

    D3DVALUE dot = DotProduct( pLightI->direction_in_eye, in->dvNormal );
    if (FLOAT_GTZ(dot))
    {
        if (!bDoColVertexDiffuse)
        {
            LData.diffuse.r += pLightI->Md_Ld.r * dot;
            LData.diffuse.g += pLightI->Md_Ld.g * dot;
            LData.diffuse.b += pLightI->Md_Ld.b * dot;
        }
        else
        {
            LData.diffuse.r += pLightI->Ld.r * LData.pDiffuseSrc->r * dot;
            LData.diffuse.g += pLightI->Ld.g * LData.pDiffuseSrc->g * dot;
            LData.diffuse.b += pLightI->Ld.b * LData.pDiffuseSrc->b * dot;
        }

        if (bDoSpecular)
        {
            RDVECTOR3 h;      // halfway vector
            RDVECTOR3 eye;    // incident vector ie vector from eye

            if (bDoLocalViewer)
            {
                // calc vector from vertex to the eye
                SubtractVector( LData.eye_in_eye, in->dvPosition, eye );

                // normalize
                Normalize( eye );
            }
            else
            {
                eye.x = D3DVALUE( 0.0 );
                eye.y = D3DVALUE( 0.0 );
                eye.z = D3DVALUE(-1.0 );
            }

            // calc halfway vector
            AddVector( pLightI->direction_in_eye, eye, h );

            // normalize
            Normalize( h );

            dot = DotProduct( h, in->dvNormal );

            if (FLOAT_GTZ(dot))
            {
                if (FLOAT_CMP_POS(dot, >=, LData.specThreshold))
                {
                    D3DVALUE coeff = pow( dot, LData.material.power );
                    if (!bDoColVertexSpecular)
                    {
                        LData.specular.r += pLightI->Ms_Ls.r * coeff;
                        LData.specular.g += pLightI->Ms_Ls.g * coeff;
                        LData.specular.b += pLightI->Ms_Ls.b * coeff;
                    }
                    else
                    {
                        LData.specular.r += (pLightI->Ls.r *
                                             LData.pSpecularSrc->r * coeff);
                        LData.specular.g += (pLightI->Ls.g *
                                             LData.pSpecularSrc->g * coeff);
                        LData.specular.b += (pLightI->Ls.b *
                                             LData.pSpecularSrc->b * coeff);
                    }
                }
            }
        }
    }
    return;
}

void
RDLV_PointAndSpot(
    RDLIGHTINGDATA &LData,
    D3DLIGHT7 *pLight,
    RDLIGHTI *pLightI,
    RDLIGHTINGELEMENT *in,
    DWORD  dwFlags,
    UINT64 qwFVFIn)
{
    // ATTENTION: Need to heed the specular flag set per light here!!
    BOOL bDoSpecular = dwFlags & RDPV_DOSPECULAR;
    BOOL bDoLocalViewer = dwFlags & RDPV_LOCALVIEWER;
    BOOL bDoColVertexAmbient = dwFlags & RDPV_COLORVERTEXAMB;
    BOOL bDoColVertexDiffuse = dwFlags & RDPV_COLORVERTEXDIFF;
    BOOL bDoColVertexSpecular = dwFlags & RDPV_COLORVERTEXSPEC;
    RDVECTOR3 d;    // Direction to light
    D3DVALUE att;
    D3DVALUE dist;
    D3DVALUE dot;

    SubtractVector( pLightI->position_in_eye, in->dvPosition, d );

    // early out if out of range or exactly on the vertex
    D3DVALUE distSquared = SquareMagnitude( d );
    if (FLOAT_CMP_POS(distSquared, >=, pLightI->range_squared) ||
        FLOAT_EQZ(distSquared))
    {
        return;
    }

    //
    // Compute the attenuation
    //
    dist = SQRTF( distSquared );
    att = pLight->dvAttenuation0 + pLight->dvAttenuation1 * dist +
        pLight->dvAttenuation2 * distSquared;

    if (FLOAT_EQZ(att))
        att = FLT_MAX;
    else
        att = (D3DVALUE)1.0/att;

    dist = D3DVAL(1)/dist;

    //
    // If the light is a spotlight compute the spot-light factor
    //
    if (pLight->dltType == D3DLIGHT_SPOT)
    {
        // Calc dot product of direction to light with light direction to
        // be compared anganst the cone angles to see if we are in the
        // light.
        // Note that cone_dot is still scaled by dist
        D3DVALUE cone_dot = DotProduct(d, pLightI->direction_in_eye) * dist;

        if (FLOAT_CMP_POS(cone_dot, <=, pLightI->cos_phi_by_2))
        {
            return;
        }

        // modify att if in the region between phi and theta
        if (FLOAT_CMP_POS(cone_dot, <, pLightI->cos_theta_by_2))
        {
            D3DVALUE val = (cone_dot - pLightI->cos_phi_by_2) *
                pLightI->inv_theta_minus_phi;

            if (!FLOAT_EQZ( pLight->dvFalloff - 1.0 ))
            {
                val = POWF( val, pLight->dvFalloff );
            }
            att *= val;
        }
    }

    //
    // Add the material's ambient component
    //
    if (!bDoColVertexAmbient)
    {
        LData.diffuse.r += att*pLightI->Ma_La.r;
        LData.diffuse.g += att*pLightI->Ma_La.g;
        LData.diffuse.b += att*pLightI->Ma_La.b;
    }
    else
    {
        //
        // Note:
        // In case ColorVertexAmbient is enabled, note that it uses
        // VertexSpecular instead of VertexDiffuse
        //
        LData.diffuse.r += att*pLightI->La.r * LData.pAmbientSrc->r;
        LData.diffuse.g += att*pLightI->La.g * LData.pAmbientSrc->g;
        LData.diffuse.b += att*pLightI->La.b * LData.pAmbientSrc->b;
    }

    // Calc dot product of light dir with normal.  Note that since we
    // didn't normalize the direction the result is scaled by the distance.
    if( (qwFVFIn & D3DFVF_NORMAL) == 0)
    {
        // If no normals are present, bail out since we cannot perform the
        // normal-dependent computations
        return;
    }
    else
    {
        dot = DotProduct( d, in->dvNormal );
    }

    if (FLOAT_GTZ( dot ))
    {
        dot *= dist*att;

        if (!bDoColVertexDiffuse)
        {
            LData.diffuse.r += pLightI->Md_Ld.r * dot;
            LData.diffuse.g += pLightI->Md_Ld.g * dot;
            LData.diffuse.b += pLightI->Md_Ld.b * dot;
        }
        else
        {
            LData.diffuse.r += pLightI->Ld.r * LData.pDiffuseSrc->r * dot;
            LData.diffuse.g += pLightI->Ld.g * LData.pDiffuseSrc->g * dot;
            LData.diffuse.b += pLightI->Ld.b * LData.pDiffuseSrc->b * dot;
        }

        if (bDoSpecular)
        {
            RDVECTOR3 h;      // halfway vector
            RDVECTOR3 eye;    // incident vector ie vector from eye

            // normalize light direction
            d.x *= dist;
            d.y *= dist;
            d.z *= dist;

            if (bDoLocalViewer)
            {
                // calc vector from vertex to the eye
                SubtractVector( LData.eye_in_eye, in->dvPosition, eye );

                // normalize
                Normalize( eye );
            }
            else
            {
                eye.x = D3DVALUE( 0.0 );
                eye.y = D3DVALUE( 0.0 );
                eye.z = D3DVALUE(-1.0 );
            }

            // calc halfway vector
            AddVector( d, eye, h );
            Normalize( h );

            dot = DotProduct( h, in->dvNormal );

            if (FLOAT_CMP_POS(dot, >=, LData.specThreshold))
            {
                D3DVALUE coeff = pow( dot, LData.material.power ) * att;
                if (!bDoColVertexSpecular)
                {
                    LData.specular.r += pLightI->Ms_Ls.r * coeff;
                    LData.specular.g += pLightI->Ms_Ls.g * coeff;
                    LData.specular.b += pLightI->Ms_Ls.b * coeff;
                }
                else
                {
                    LData.specular.r += (pLightI->Ls.r *
                                         LData.pSpecularSrc->r * coeff);
                    LData.specular.g += (pLightI->Ls.g *
                                         LData.pSpecularSrc->g * coeff);
                    LData.specular.b += (pLightI->Ls.b *
                                         LData.pSpecularSrc->b * coeff);
                }
            }
        }
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////
// RDLight
///////////////////////////////////////////////////////////////////////////////
RDLight::RDLight()
{
    m_dwFlags = RDLIGHT_NEEDSPROCESSING;
    m_Next = NULL;

    ZeroMemory(&m_Light, sizeof(m_Light));
    ZeroMemory(&m_LightI, sizeof(m_LightI));

    // Initialize the light to some default values
    m_Light.dltType        = D3DLIGHT_DIRECTIONAL;

    m_Light.dcvDiffuse.r   = 1;
    m_Light.dcvDiffuse.g   = 1;
    m_Light.dcvDiffuse.b   = 1;
    m_Light.dcvDiffuse.a   = 0;

    m_Light.dvDirection.x  = 0;
    m_Light.dvDirection.y  = 0;
    m_Light.dvDirection.z  = 1;

    // m_Light.dcvSpecular = {0,0,0,0};
    // m_Light.dcvAmbient  = {0,0,0,0};
    // m_Light.dvPosition  = {0,0,0};

    // m_Light.dvRange        = 0;
    // m_Light.dvFalloff      = 0;
    // m_Light.dvAttenuation0 = 0;
    // m_Light.dvAttenuation1 = 0;
    // m_Light.dvAttenuation2 = 0;
    // m_Light.dvTheta        = 0;
    // m_Light.dvPhi          = 0;

    return;
}


HRESULT
RDLight::SetLight(LPD3DLIGHT7 pLight)
{

    // Validate the parameters passed
    switch (pLight->dltType)
    {
    case D3DLIGHT_POINT:
    case D3DLIGHT_SPOT:
    case D3DLIGHT_DIRECTIONAL:
        break;
    default:
        // No other light types are allowed
        DPFRR(0, "Invalid light type passed");
        return DDERR_INVALIDPARAMS;
    }
    if (pLight)
        m_Light = *pLight;

    // Mark it for processing later
    m_dwFlags |= (RDLIGHT_NEEDSPROCESSING | RDLIGHT_REFERED);
    return DD_OK;
}

HRESULT
RDLight::GetLight(LPD3DLIGHT7 pLight)
{
    if (pLight == NULL) return DDERR_GENERIC;
    *pLight = m_Light;
    return D3D_OK;
}

void
RDLight::ProcessLight(D3DMATERIAL7 *mat, RDLIGHTVERTEX_FUNC_TABLE *pTbl)
{
    //
    // If it is already processed, return
    //
    if (!NeedsProcessing()) return;

    //
    // Save the ambient light  (0-1)
    //
    m_LightI.La.r  = m_Light.dcvAmbient.r;
    m_LightI.La.g  = m_Light.dcvAmbient.g;
    m_LightI.La.b  = m_Light.dcvAmbient.b;

    //
    // Save the diffuse light  (0-1)
    //
    m_LightI.Ld.r  = m_Light.dcvDiffuse.r;
    m_LightI.Ld.g  = m_Light.dcvDiffuse.g;
    m_LightI.Ld.b  = m_Light.dcvDiffuse.b;

    //
    // Save the specular light (0-1)
    //
    m_LightI.Ls.r  = m_Light.dcvSpecular.r;
    m_LightI.Ls.g  = m_Light.dcvSpecular.g;
    m_LightI.Ls.b  = m_Light.dcvSpecular.b;

    //
    // Material Ambient times Light Ambient
    //
    m_LightI.Ma_La.r = m_LightI.La.r * mat->ambient.r * D3DVALUE(255.0);
    m_LightI.Ma_La.g = m_LightI.La.g * mat->ambient.g * D3DVALUE(255.0);
    m_LightI.Ma_La.b = m_LightI.La.b * mat->ambient.b * D3DVALUE(255.0);

    //
    // Material Diffuse times Light Diffuse
    //
    m_LightI.Md_Ld.r = m_LightI.Ld.r * mat->diffuse.r * D3DVALUE(255.0);
    m_LightI.Md_Ld.g = m_LightI.Ld.g * mat->diffuse.g * D3DVALUE(255.0);
    m_LightI.Md_Ld.b = m_LightI.Ld.b * mat->diffuse.b * D3DVALUE(255.0);

    //
    // Material Specular times Light Specular
    //
    m_LightI.Ms_Ls.r = m_LightI.Ls.r * mat->specular.r * D3DVALUE(255.0);
    m_LightI.Ms_Ls.g = m_LightI.Ls.g * mat->specular.g * D3DVALUE(255.0);
    m_LightI.Ms_Ls.b = m_LightI.Ls.b * mat->specular.b * D3DVALUE(255.0);


    //
    // Assign the actual lighting function pointer, in addition to
    // performing some precomputation of light-type specific data
    //
    m_pfnLightVertex = NULL;
    switch (m_Light.dltType)
    {
    case D3DLIGHT_DIRECTIONAL:
        m_pfnLightVertex = pTbl->pfnDirectional;
        break;
    case D3DLIGHT_POINT:
        m_LightI.range_squared = m_Light.dvRange * m_Light.dvRange;
        m_LightI.inv_theta_minus_phi = 1.0f;
        m_pfnLightVertex = pTbl->pfnPoint;
        break;
    case D3DLIGHT_SPOT:
        m_LightI.range_squared = m_Light.dvRange * m_Light.dvRange;
        m_LightI.cos_theta_by_2 = (float)cos(m_Light.dvTheta / 2.0);
        m_LightI.cos_phi_by_2 = (float)cos(m_Light.dvPhi / 2.0);
        m_LightI.inv_theta_minus_phi = m_LightI.cos_theta_by_2 -
            m_LightI.cos_phi_by_2;
        if (m_LightI.inv_theta_minus_phi != 0.0)
        {
            m_LightI.inv_theta_minus_phi = 1.0f/m_LightI.inv_theta_minus_phi;
        }
        else
        {
            m_LightI.inv_theta_minus_phi = 1.0f;
        }
        m_pfnLightVertex = pTbl->pfnSpot;
        break;
    default:
        DPFRR( 0, "Cannot process light of unknown type" );
        break;
    }

    // Mark it as been processed
    m_dwFlags &= ~RDLIGHT_NEEDSPROCESSING;
    return;
}

void
RDLight::Enable(RDLight **ppRoot)
{
    // Assert that it is not already enabled
    if (IsEnabled()) return;

    // Assert that Root Ptr is not Null
    if (ppRoot == NULL) return;

    RDLight *pTmp = *ppRoot;
    *ppRoot = this;
    m_Next = pTmp;
    m_dwFlags |= (RDLIGHT_ENABLED | RDLIGHT_REFERED);

    return;
}

void
RDLight::Disable(RDLight **ppRoot)
{
    // Assert that the light is enabled
    if (!IsEnabled()) return;

    // Assert that Root Ptr is not Null
    if (ppRoot == NULL) return;

    RDLight *pLightPrev = *ppRoot;

    // If this is the first light in the active list
    if (pLightPrev == this)
    {
        *ppRoot = m_Next;
        m_dwFlags &= ~RDLIGHT_ENABLED;
        return;
    }

    while (pLightPrev->m_Next != this)
    {
        // Though this light was marked as enabled, it is not on
        // the active list. Assert this.
        if (pLightPrev->m_Next == NULL)
        {
            m_dwFlags &= ~RDLIGHT_ENABLED;
            return;
        }

        // Else get the next pointer
        pLightPrev = pLightPrev->m_Next;
    }

    pLightPrev->m_Next = m_Next;
    m_dwFlags &= ~RDLIGHT_ENABLED;
    m_dwFlags |= RDLIGHT_REFERED;
    return;
}

void
RDLight::XformLight( RDMATRIX *mView )
{
    // If the light is not a directional light,
    // tranform its position to camera space
    if (m_Light.dltType != D3DLIGHT_DIRECTIONAL)
    {
        XformBy4x3((RDVECTOR3*)&m_Light.dvPosition, mView,
                   &m_LightI.position_in_eye);
    }

    if (m_Light.dltType != D3DLIGHT_POINT)
    {
        // Transform light direction to the eye space
        Xform3VecBy3x3( (RDVECTOR3*)&m_Light.dvDirection, mView,
                        &m_LightI.direction_in_eye );
        // Normalize it
        Normalize( m_LightI.direction_in_eye );

        // Reverse it such that the direction is to the light
        ReverseVector( m_LightI.direction_in_eye, m_LightI.direction_in_eye );
    }

    return;
}

//---------------------------------------------------------------------
// ScaleRGBColorTo255: Scales colors from 0-1 range to 0-255 range
//---------------------------------------------------------------------
void
ScaleRGBColorTo255( const D3DCOLORVALUE& src, RDCOLOR3& dest )
{
    dest.r = D3DVALUE(255.0) * src.r;
    dest.g = D3DVALUE(255.0) * src.g;
    dest.b = D3DVALUE(255.0) * src.b;
}


//---------------------------------------------------------------------
// RefVP::GrowLightArray
//             Grows the light array and recreated the active-list
//             if a realloc has taken place.
//---------------------------------------------------------------------
HRESULT
RefVP::GrowLightArray( DWORD dwIndex )
{
    HRESULT hr = S_OK;
    BOOL bRealloc = FALSE;

    HR_RET(m_LightArray.Grow( dwIndex, &bRealloc ));
    if( bRealloc == TRUE )
    {
        m_lighting.pActiveLights = NULL;
        for( DWORD i = 0; i < m_LightArray.GetSize(); i++ )
        {
            if( m_LightArray[i].IsEnabled() )
            {
                m_LightArray[i].m_Next = m_lighting.pActiveLights;
                m_lighting.pActiveLights = &(m_LightArray[i]);
            }
        }
    }

    return S_OK;
}


//---------------------------------------------------------------------
// RefVP::UpdateLightingData
//             Updates lighting data used by ProcessVertices
//---------------------------------------------------------------------
HRESULT
RefVP::UpdateLightingData()
{
    HRESULT hr = D3D_OK;
    RDLIGHTINGDATA& LData = m_lighting;
    RDLight *pLight = m_lighting.pActiveLights;
    RDVECTOR3   t;
    D3DMATERIAL7 *mat = &m_Material;

    //
    // Eye in eye space
    //
    LData.eye_in_eye.x = (D3DVALUE)0;
    LData.eye_in_eye.y = (D3DVALUE)0;
    LData.eye_in_eye.z = (D3DVALUE)0;

    // ATTENTION: Colorvertex may have changed the values of the
    // material alphas
    if (m_dwDirtyFlags & RDPV_DIRTY_MATERIAL)
    {
        //
        // Save the material to be used to light vertices
        //
        LData.material = *mat;
        ScaleRGBColorTo255( mat->ambient, LData.matAmb );
        ScaleRGBColorTo255( mat->diffuse, LData.matDiff );
        ScaleRGBColorTo255( mat->specular, LData.matSpec );
        ScaleRGBColorTo255( mat->emissive, LData.matEmis );

        //
        // Compute the Material Diffuse Alpha
        //
        LData.materialDiffAlpha = mat->diffuse.a * D3DVALUE(255);
        if (mat->diffuse.a < 0)
            LData.materialDiffAlpha = 0;
        else if (LData.materialDiffAlpha > 255)
            LData.materialDiffAlpha = 255 << 24;
        else LData.materialDiffAlpha <<= 24;

        //
        // Compute the Material Specular Alpha
        //
        LData.materialSpecAlpha = mat->specular.a * D3DVALUE(255);
        if (mat->specular.a < 0)
            LData.materialSpecAlpha = 0;
        else if (LData.materialSpecAlpha > 255)
            LData.materialSpecAlpha = 255 << 24;
        else LData.materialSpecAlpha <<= 24;

        //
        // Precompute the ambient and emissive components that are
        // not dependent on any contribution by the lights themselves
        //
        LData.ambEmiss.r = LData.ambient_red   * LData.matAmb.r +
            LData.matEmis.r;
        LData.ambEmiss.g = LData.ambient_green * LData.matAmb.g +
            LData.matEmis.g;
        LData.ambEmiss.b = LData.ambient_blue  * LData.matAmb.b +
            LData.matEmis.b;

        //
        // If the dot product is less than this
        // value, specular factor is zero
        //
        if (mat->power > D3DVAL(0.001))
        {
            LData.specThreshold = D3DVAL(pow(0.001, 1.0/mat->power));
        }
    }

    while (pLight)
    {
        if ((m_dwDirtyFlags & RDPV_DIRTY_MATERIAL) ||
            pLight->NeedsProcessing())
        {
            // If the material is dirty, light needs processing, regardless
            if (m_dwDirtyFlags & RDPV_DIRTY_MATERIAL)
            {
                pLight->m_dwFlags |= RDLIGHT_NEEDSPROCESSING;
            }

            // If the light has been set, or some material paramenters
            // changed, re-process the light.
            pLight->ProcessLight( &m_Material, &m_LightVertexTable );

            // Transform the light to Eye space
            // Lights are defined in world space, so simply apply the
            // Viewing transform
            pLight->XformLight( &m_xfmView );

        }
        else if (m_dwDirtyFlags & RDPV_DIRTY_NEEDXFMLIGHT)
        {
            pLight->XformLight( &m_xfmView );
        }

        pLight = pLight->m_Next;
    }

    // Clear Lighting dirty flags
    m_dwDirtyFlags &= ~RDPV_DIRTY_LIGHTING;
    return hr;
}


//---------------------------------------------------------------------
// RefVP::UpdateFogData
//             Updates Fog data used by ProcessVertices
//---------------------------------------------------------------------
HRESULT
RefVP::UpdateFogData()
{
    HRESULT hr = D3D_OK;

    if (m_lighting.fog_end == m_lighting.fog_start)
        m_lighting.fog_factor = D3DVAL(0.0);
    else
        m_lighting.fog_factor = D3DVAL(255) / (m_lighting.fog_end -
                                               m_lighting.fog_start);

    // Clear Fog dirty flags
    m_dwDirtyFlags &= ~RDPV_DIRTY_FOG;
    return hr;
}

//---------------------------------------------------------------------
// RefVP::LightVertex
//           Actual lighting computation takes place here
//---------------------------------------------------------------------
void
RefVP::LightVertex(RDLIGHTINGELEMENT *pLE)
{
    RDLIGHTINGDATA &LData = m_lighting;
    RDLight  *pLight;

    //
    // Initialize Diffuse color with the Ambient and Emissive component
    // independent of the light (Ma*La + Me)
    //

    if (m_dwTLState & (RDPV_COLORVERTEXEMIS | RDPV_COLORVERTEXAMB))
    {
        // If the material values need to be replaced, compute

        LData.diffuse.r = LData.ambient_red * LData.pAmbientSrc->r +
            LData.pEmissiveSrc->r;
        LData.diffuse.g = LData.ambient_green * LData.pAmbientSrc->g +
            LData.pEmissiveSrc->g;
        LData.diffuse.b = LData.ambient_blue  * LData.pAmbientSrc->b +
            LData.pEmissiveSrc->b;
    }
    else
    {
        // If none of the material values needs to be replaced

        LData.diffuse = LData.ambEmiss;
    }


    //
    // Initialize the Specular to Zero
    //
    LData.specular.r = D3DVAL(0);
    LData.specular.g = D3DVAL(0);
    LData.specular.b = D3DVAL(0);

    //
    // In a loop accumulate color from the activated lights
    //
    pLight = LData.pActiveLights;
    while (pLight)
    {
        if (pLight->m_pfnLightVertex)
            (*pLight->m_pfnLightVertex)(m_lighting,
                                        &pLight->m_Light,
                                        &pLight->m_LightI,
                                        pLE,
                                        m_dwTLState,
                                        m_qwFVFIn);
        pLight = pLight->m_Next;
    }

    //
    // Compute the diffuse color of the vertex
    //
    int r = FTOI(LData.diffuse.r);
    int g = FTOI(LData.diffuse.g);
    int b = FTOI(LData.diffuse.b);
    DWORD a = *LData.pDiffuseAlphaSrc;

    //
    // Clamp the r, g, b, components
    //
    if (r < 0) r = 0; else if (r > 255) r = 255;
    if (g < 0) g = 0; else if (g > 255) g = 255;
    if (b < 0) b = 0; else if (b > 255) b = 255;

    LData.outDiffuse =  a + (r<<16) + (g<<8) + b;


    //
    // Obtain the specular Alpha
    //
    a = *(LData.pSpecularAlphaSrc);

    //
    // Compute the RGB part of the specular color
    //
    if (m_dwTLState & RDPV_DOSPECULAR)
    {
        r = FTOI(LData.specular.r);
        g = FTOI(LData.specular.g);
        b = FTOI(LData.specular.b);

        //
        // Clamp the r, g, b, components
        //
        if (r < 0) r = 0; else if (r > 255) r = 255;
        if (g < 0) g = 0; else if (g > 255) g = 255;
        if (b < 0) b = 0; else if (b > 255) b = 255;

    }
    // Need another render-state to control if the 
    // the specular color (color2) needs to be passed down to
    // the rasterizer.

    //
    // If SPECULAR is not enabled but the specular color
    // had been provided in the input vertex, simply copy.
    //
    else if (m_qwFVFOut & D3DFVF_SPECULAR )
    {
        r = FTOI(LData.vertexSpecular.r);
        g = FTOI(LData.vertexSpecular.g);
        b = FTOI(LData.vertexSpecular.b);
        a = LData.vertexSpecAlpha;
    }
    //
    // If SpecularColor is not enabled
    //
    else
    {
        r = g = b = 0;
    }

    LData.outSpecular =  a + (r<<16) + (g<<8) + b;

    return;
}

//---------------------------------------------------------------------
// RefVP::FogVertex
//           Vertex Fog computation
// Input:
//      v    - input vertex in the model space
//      le   - vertex, transformed to the camera space
// Output:
//      Alpha component of pv->lighting.outSpecular is set
//---------------------------------------------------------------------
void
RefVP::FogVertex( RDVertex& Vout, RDVECTOR3 &v, RDLIGHTINGELEMENT *pLE,
                  int numVertexBlends, float *pBlendFactors,
                  BOOL bVertexInEyeSpace )
{
    D3DVALUE dist = 0.0f;

    //
    // Calculate the distance
    //
    if (bVertexInEyeSpace)
    {
        // Vertex is already transformed to the camera space
        if (m_dwTLState & RDPV_RANGEFOG)
        {
            dist = SQRTF(pLE->dvPosition.x*pLE->dvPosition.x +
                         pLE->dvPosition.y*pLE->dvPosition.y +
                         pLE->dvPosition.z*pLE->dvPosition.z);
        }
        else
        {
            dist = ABSF( pLE->dvPosition.z );
        }
    }
    else if (m_dwTLState & RDPV_RANGEFOG)
    {
        D3DVALUE x = 0, y = 0, z = 0;
        float cumulBlend = 0.0f;

        for( int j=0; j<=numVertexBlends; j++)
        {
            float blend;

            if( numVertexBlends == 0 )
            {
                blend = 1.0f;
            }
            else if( j == numVertexBlends )
            {
                blend = 1.0f - cumulBlend;
            }
            else
            {
                blend = pBlendFactors[j];
                cumulBlend += pBlendFactors[j];
            }
            if( m_dwTLState & RDPV_DOINDEXEDVERTEXBLEND )
            {
                BYTE m = ((BYTE *)&pBlendFactors[numVertexBlends])[j];
                UpdateWorld( m );
                x += (v.x*m_xfmToEye[m]._11 +
                      v.y*m_xfmToEye[m]._21 +
                      v.z*m_xfmToEye[m]._31 +
                      m_xfmToEye[m]._41) * blend;
                y += (v.x*m_xfmToEye[m]._12 +
                      v.y*m_xfmToEye[m]._22 +
                      v.z*m_xfmToEye[m]._32 +
                      m_xfmToEye[m]._42) * blend;
                z += (v.x*m_xfmToEye[m]._13 +
                      v.y*m_xfmToEye[m]._23 +
                      v.z*m_xfmToEye[m]._33 +
                      m_xfmToEye[m]._43) * blend;
            }
            else
            {
                x += (v.x*m_xfmToEye[j]._11 +
                      v.y*m_xfmToEye[j]._21 +
                      v.z*m_xfmToEye[j]._31 +
                      m_xfmToEye[j]._41) * blend;
                y += (v.x*m_xfmToEye[j]._12 +
                      v.y*m_xfmToEye[j]._22 +
                      v.z*m_xfmToEye[j]._32 +
                      m_xfmToEye[j]._42) * blend;
                z += (v.x*m_xfmToEye[j]._13 +
                      v.y*m_xfmToEye[j]._23 +
                      v.z*m_xfmToEye[j]._33 +
                      m_xfmToEye[j]._43) * blend;
            }
        }

        dist = SQRTF(x*x + y*y + z*z);
    }
    else
    {
        float cumulBlend = 0.0f;

        for( int j=0; j<=numVertexBlends; j++)
        {
            float blend;

            if( numVertexBlends == 0 )
            {
                blend = 1.0f;
            }
            else if( j == numVertexBlends )
            {
                blend = 1.0f - cumulBlend;
            }
            else
            {
                blend = pBlendFactors[j];
                cumulBlend += pBlendFactors[j];
            }

            if( m_dwTLState & RDPV_DOINDEXEDVERTEXBLEND )
            {
                BYTE m = ((BYTE *)&pBlendFactors[numVertexBlends])[j];
                UpdateWorld( m );
                dist += (v.x*m_xfmToEye[m]._13 +
                         v.y*m_xfmToEye[m]._23 +
                         v.z*m_xfmToEye[m]._33 +
                         m_xfmToEye[m]._43) * blend;
            }
            else
            {
                dist += (v.x*m_xfmToEye[j]._13 +
                         v.y*m_xfmToEye[j]._23 +
                         v.z*m_xfmToEye[j]._33 +
                         m_xfmToEye[j]._43) * blend;
            }
        }
        dist = ABSF( dist );
    }

    if (m_lighting.fog_mode == D3DFOG_LINEAR)
    {
        if (dist < m_lighting.fog_start)
        {
            Vout.m_fog = 1.0f;
        }
        else if (dist >= m_lighting.fog_end)
        {
            Vout.m_fog = 0.0f;
        }
        else
        {
            Vout.m_fog = (m_lighting.fog_end - dist) *
                m_lighting.fog_factor / 255.0f ;
        }
    }
    else
    {
        D3DVALUE tmp = dist * m_lighting.fog_density;
        if (m_lighting.fog_mode == D3DFOG_EXP2)
        {
            tmp *= tmp;
        }
        Vout.m_fog = (FLOAT)exp(-tmp);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\tnl\clip.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1997 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       clip.h
 *  Content:    Template for functions to clip by a frustum side
 *
 * The following symbol should be defined before included this file:
 * __CLIP_NAME 	    - name for a function to clip triangles
 * __CLIP_LINE_NAME - name for a function to clip lines
 * __CLIP_W         - if this functions are for Coord <= W. Otherwise they 
 *                    are for 0 < Coord
 * __CLIP_COORD     - should be hx, hy or hz
 * __CLIP_FLAG      - clipping flag to set
 * __CLIP_GUARDBAND - defined when clipping by guardband window
 * __CLIP_SIGN      - "-" if clipping by left or bottom sides of guard band 
 *                    window
 * __CLIP_GBCOEF    - coefficient to multiply W when clipping by guard band
 *                    window
 *
 * All these symbols are undefined at the end of this file
 ***************************************************************************/
//
// Clipping for triangle
//
// Returns number of vertices in the clipped triangle
//
int 
RefClipper::__CLIP_NAME(RDClipVertex **inv, RDClipVertex **outv, int count)
{
    int i;
    int out_count = 0;
    RDClipVertex *curr, *prev;
    D3DVALUE curr_inside;
    D3DVALUE prev_inside;

    prev = inv[count-1];
    curr = *inv++;
#ifdef __CLIP_GUARDBAND
    prev_inside = __CLIP_SIGN(prev->m_clip_w * __CLIP_GBCOEF - 
                              prev->__CLIP_COORD);
#else
#ifdef __CLIP_W
    prev_inside = prev->m_clip_w - prev->__CLIP_COORD;
#else
    prev_inside = prev->__CLIP_COORD;
#endif
#endif
    for (i = count; i; i--) 
    {
#ifdef __CLIP_GUARDBAND
        curr_inside = __CLIP_SIGN(curr->m_clip_w * __CLIP_GBCOEF - 
                                  curr->__CLIP_COORD);
#else
#ifdef __CLIP_W
        curr_inside = curr->m_clip_w - curr->__CLIP_COORD;
#else
        curr_inside = curr->__CLIP_COORD;
#endif
#endif
        // We interpolate always from the inside vertex to the outside vertex
        // to reduce precision problems
        if (FLOAT_LTZ(prev_inside)) 
        { // first point is outside
            if (FLOAT_GEZ(curr_inside)) 
            { // second point is inside
              // Find intersection and insert in into the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                outv[out_count]->m_qwFVF = prev->m_qwFVF;
                Interpolate(outv[out_count],
                            curr, prev, 
                            (prev->m_clip & CLIPPED_ENABLE) | __CLIP_FLAG,
                            curr_inside, curr_inside - prev_inside);
                out_count++;
            }
        } 
        else 
        { // first point is inside - put it to the output buffer first
            outv[out_count++] = prev;
            if (FLOAT_LTZ(curr_inside)) 
            { // second point is outside
              // Find intersection and put it to the output buffer
                outv[out_count] = GET_NEW_CLIP_VERTEX;
                outv[out_count]->m_qwFVF = prev->m_qwFVF;
                Interpolate(outv[out_count],
                            prev, curr,
                            __CLIP_FLAG,
                            prev_inside, prev_inside - curr_inside);
                out_count++;
            }
        }
        prev = curr;
        curr = *inv++;
        prev_inside = curr_inside;
    }
    return out_count;
}
//-------------------------------------------------------------------------
// Clipping for lines
//
// Returns 1 if the line is outside the frustum, 0 otherwise
//
int 
RefClipper::__CLIP_LINE_NAME(RDCLIPTRIANGLE *line) 
{
    D3DVALUE in1, in2;
    RDClipVertex outv;
#ifdef __CLIP_GUARDBAND
    in1 = __CLIP_SIGN(line->v[0]->m_clip_w * __CLIP_GBCOEF - 
                      line->v[0]->__CLIP_COORD);
    in2 = __CLIP_SIGN(line->v[1]->m_clip_w * __CLIP_GBCOEF - 
                      line->v[1]->__CLIP_COORD);
#else
#ifdef __CLIP_W
    in1 = line->v[0]->m_clip_w - line->v[0]->__CLIP_COORD;
    in2 = line->v[1]->m_clip_w - line->v[1]->__CLIP_COORD;
#else
    in1 = line->v[0]->__CLIP_COORD;
    in2 = line->v[1]->__CLIP_COORD;
#endif
#endif
    if (in1 < 0) 
    {
        if (in2 < 0) 
            return 1;
        Interpolate(&outv, line->v[0], line->v[1], 
                    __CLIP_FLAG, in1, in1 - in2);
        *line->v[0] = outv;
    } 
    else 
    {
        if (in2 < 0) 
        {
            Interpolate(&outv, line->v[0], line->v[1],
                        __CLIP_FLAG, in1, in1 - in2);
            *line->v[1] = outv;
        }
    }
    return 0;
}

#undef __CLIP_FLAG
#undef __CLIP_COORD
#undef __CLIP_NAME
#undef __CLIP_LINE_NAME
#undef __CLIP_W
#undef __CLIP_SIGN
#undef __CLIP_GBCOEF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\tnl\pch.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// pch.cpp
//
// Precompiled header file.
//
///////////////////////////////////////////////////////////////////////////////
#include "refdev.hpp"

#include "clipping.hpp"
///////////////////////////////////////////////////////////////////////////////
// end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\tnl\reftnl.cpp ===
///////////////////////////////////////////////////////////////////////////////
// Copyright (C) Microsoft Corporation, 1998.
//
// reftnl.cpp
//
// Direct3D Reference Transformation and Lighting  - public interface
//
///////////////////////////////////////////////////////////////////////////////
#include "pch.cpp"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\tnl\procprim.cpp ===
#include "pch.cpp"
#pragma hdrstop

//---------------------------------------------------------------------
// Constructor:
//
//---------------------------------------------------------------------
RefVP::RefVP() : 
    m_LightArray(), 
    m_LightVertexTable()
{
    m_LightArray.SetGrowSize( 32 );

    memset( &m_Material, 0, sizeof(m_Material) );

    memset( &m_xfmProj, 0, sizeof(m_xfmProj) );
    memset( &m_xfmView, 0, sizeof(m_xfmView) );
    memset( m_xfmWorld, 0, sizeof(m_xfmView)*RD_MAX_WORLD_MATRICES );

    m_dwTLState = 0;
    m_dwDirtyFlags = 0;

    memset( m_xfmCurrent, 0, sizeof(m_xfmView)*RD_MAX_WORLD_MATRICES );
    memset( m_xfmToEye, 0, sizeof(m_xfmView)*RD_MAX_WORLD_MATRICES );
    memset( m_xfmToEyeInv, 0, sizeof(m_xfmView)*RD_MAX_WORLD_MATRICES );

    m_qwFVFIn = 0;

    m_numVertexBlends = 0;
    memset( &m_TransformData, 0, sizeof(m_TransformData) ) ;

    m_fPointSize = 0;
    m_fPointAttA = 0;
    m_fPointAttB = 0;
    m_fPointAttC = 0;
    m_fPointSizeMin = 0;
    m_fPointSizeMax = RD_MAX_POINT_SIZE;
    m_fTweenFactor = 0.0f;
    
    m_LightVertexTable.pfnDirectional = RDLV_Directional;
    m_LightVertexTable.pfnParallelPoint = RDLV_Directional;
    m_LightVertexTable.pfnSpot = RDLV_PointAndSpot;
    m_LightVertexTable.pfnPoint = RDLV_PointAndSpot;
    
    m_dwNumActiveTextureStages = 0;
    
    m_pDev = NULL;
}

//---------------------------------------------------------------------
// SetupStrides:
//---------------------------------------------------------------------
HRESULT
RefDev::SetupStrides()
{

    RDVDeclaration& Decl = m_pCurrentVShader->m_Declaration;
    
    // Null out the PtrStrides
    m_RefVP.m_position.Null();
    m_RefVP.m_position2.Null();
    m_RefVP.m_blendweights.Null();
    m_RefVP.m_blendindices.Null();
    m_RefVP.m_normal.Null();
    m_RefVP.m_normal2.Null();
    m_RefVP.m_specular.Null();
    m_RefVP.m_diffuse.Null();
    m_RefVP.m_pointsize.Null();
    for( int t = 0; t < 8 ; t++ )
        m_RefVP.m_tex[t].Null();

    for( DWORD i = 0; i < Decl.m_dwNumElements; i++ )
    {
        RDVElement& Element = Decl.m_VertexElements[i];
        RDVStream&  Stream =  m_VStream[Element.m_dwStreamIndex];
        DWORD dwStride = Stream.m_dwStride;
        DWORD dwStartVertex = m_dwStartVertex;
        
        switch( Element.m_dwRegister )
        {
        case D3DVSDE_POSITION:
            m_RefVP.m_position.Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_POSITION2:
            m_RefVP.m_position2.Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_BLENDWEIGHT:
            m_RefVP.m_blendweights.Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_BLENDINDICES:
            // This only happens if the vertex declaration is a non-FVF one
            _ASSERT( !RDVSD_ISLEGACY( m_CurrentVShaderHandle ),
                     "FVF shader could not have provided a" 
                     "  separate blend-index" );
            m_RefVP.m_blendindices.Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_NORMAL:
            m_RefVP.m_normal.Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_NORMAL2:
            m_RefVP.m_normal2.Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_PSIZE:
            m_RefVP.m_pointsize.Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_DIFFUSE:
            m_RefVP.m_diffuse.Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_SPECULAR:
            m_RefVP.m_specular.Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_TEXCOORD0:
            m_RefVP.m_tex[0].Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_TEXCOORD1:
            m_RefVP.m_tex[1].Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_TEXCOORD2:
            m_RefVP.m_tex[2].Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_TEXCOORD3:
            m_RefVP.m_tex[3].Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_TEXCOORD4:
            m_RefVP.m_tex[4].Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_TEXCOORD5:
            m_RefVP.m_tex[5].Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_TEXCOORD6:
            m_RefVP.m_tex[6].Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        case D3DVSDE_TEXCOORD7:
            m_RefVP.m_tex[7].Init(
                (LPBYTE)Stream.m_pData + Element.m_dwOffset +
                dwStride * dwStartVertex, dwStride );
            break;
        }
    }
    
    // If it is a FVF vertex shader and index-vertex blending is enabled
    // then the blend-indices are found in the last beta (which is the blend 
    // weight) of the vertex.
    if( RDVSD_ISLEGACY( m_CurrentVShaderHandle ) && 
        (m_RefVP.m_dwTLState & RDPV_DOINDEXEDVERTEXBLEND) )
    {
        m_RefVP.m_blendindices.Init(
            (float *)m_RefVP.m_blendweights.GetFirst() + 
            m_RefVP.m_numVertexBlends,
            m_RefVP.m_blendweights.GetStride() );
    }
    
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
// Process primitives implementation:
// 1) Compute FVF info
// 2) Grow buffers to the requisite size
// 3) Initialize clipping state
// 4) Update T&L state
// 5) Transform, Light and compute clipping for vertices
// 6) Clip and Draw the primitives
//
///////////////////////////////////////////////////////////////////////////////
HRESULT
RefDev::ProcessPrimitive( D3DPRIMITIVETYPE PrimType,
                          DWORD StartVertex,
                          DWORD cVertices,
                          DWORD StartIndex,
                          DWORD cIndices )
{
    HRESULT hr = D3D_OK;
    DWORD dwVertexPoolSize = 0;

    // Save Prim Type for later use
    m_primType      = PrimType;
    m_dwNumVertices = cVertices;
    m_dwStartVertex = StartVertex;
    m_dwNumIndices  = cIndices;
    m_dwStartIndex  = StartIndex;

    //
    // Update T&L state (must be before FVFData is set up)
    //

    // Update Lighting and related state and flags and computes Output FVF
    HR_RET( UpdateTLState() );

    //
    // Clipping information depends both on the output FVF computation
    // and the other State, so do it here after both have been computed
    //
    HR_RET( UpdateClipper() );

    //
    // Grow TLVArray if required
    //
    if( FAILED( m_TLVArray.Grow( m_dwNumVertices ) ) )
    {
        DPFERR( "Could not grow TL vertex buffer" );
        return DDERR_OUTOFMEMORY;
    }

    //
    // Transform, Light and compute clipping for vertices
    //
    DWORD clipIntersection = m_RefVP.ProcessVertices( m_qwFVFOut, m_TLVArray, 
                                                      m_dwNumVertices );

    if( m_primType == D3DPT_POINTLIST )
    {
        // We clip points by Z planes and user clip planes, because point 
        // sprites could be still visible when a point is outside X or Y plane
        clipIntersection &= ~(RDCLIP_LEFT | RDCLIP_RIGHT | 
                              RDCLIP_TOP | RDCLIP_BOTTOM |
                              RDCLIPGB_ALL);

    }

    if( clipIntersection )
    {
        // If the entire primitive lies outside the view frustum, quit
        // without drawing
        return D3D_OK;
    }

    //
    // Clip and Draw the primitives
    //
    if( m_dwNumIndices )
    {
        if( !NeedClipping(m_Clipper.UseGuardBand(), m_Clipper.m_clipUnion) )
        {
            if( m_IndexStream.m_dwStride == 4 )
                hr = DrawOneIndexedPrimitive( 
                    m_TLVArray,
                    0,
                    (LPDWORD)m_IndexStream.m_pData,
                    m_dwStartIndex,
                    m_dwNumIndices,
                    m_primType );
            else
                hr = DrawOneIndexedPrimitive( 
                    m_TLVArray,
                    0,
                    (LPWORD)m_IndexStream.m_pData,
                    m_dwStartIndex,
                    m_dwNumIndices,
                    m_primType );
        }
        else
        {
            if( m_IndexStream.m_dwStride == 4 )
                hr = m_Clipper.DrawOneIndexedPrimitive( 
                    m_TLVArray,
                    0,
                    (LPDWORD)m_IndexStream.m_pData,
                    m_dwStartIndex,
                    m_dwNumIndices,
                    m_primType );
            else
                hr = m_Clipper.DrawOneIndexedPrimitive( 
                    m_TLVArray,
                    0,
                    (LPWORD)m_IndexStream.m_pData,
                    m_dwStartIndex,
                    m_dwNumIndices,
                    m_primType );
        }
    }
    else
    {
        if( !NeedClipping((m_Clipper.UseGuardBand()), m_Clipper.m_clipUnion) )
        {
            hr = DrawOnePrimitive( 
                m_TLVArray, 
                0, 
                m_primType, 
                m_dwNumVertices );
        }
        else
        {
            hr = m_Clipper.DrawOnePrimitive( 
                m_TLVArray, 
                0,
                m_primType, 
                m_dwNumVertices );
        }
    }

    return hr;
}



//---------------------------------------------------------------------
// RefDev::UpdateTLState
//             Updates transform and lighting related state
//---------------------------------------------------------------------
HRESULT
RefDev::UpdateTLState()
{
    HRESULT hr = D3D_OK;
    UINT64 qwFVFIn = m_RefVP.m_qwFVFIn;
    
    //
    // Sort out vertex blending.
    //

    // Total number of floats/dwords provided per vertex according to
    // the FVF.
    DWORD numBetas = 0;
    if( (qwFVFIn & D3DFVF_POSITION_MASK) != 
        (D3DFVF_XYZ & D3DFVF_POSITION_MASK) )
        numBetas   = ((qwFVFIn & D3DFVF_POSITION_MASK) >> 1) - 2;
    DWORD numWeights = GetRS()[D3DRENDERSTATE_VERTEXBLEND];

    // If tweening is enabled, there better be Position2 or Normal2
    if( numWeights == D3DVBF_TWEENING ) 
    {
        if( (qwFVFIn & (D3DFVFP_POSITION2 | D3DFVFP_NORMAL2)) == 0 )
        {
            DPFERR( "Tweening is enabled, but there is neither position2"
                    " nor normal2 available\n" );
            return E_FAIL;
        }
        if( qwFVFIn & D3DFVFP_POSITION2 )
            m_RefVP.m_dwTLState |= RDPV_DOPOSITIONTWEENING;
        if( qwFVFIn & D3DFVFP_NORMAL2 )
            m_RefVP.m_dwTLState |= RDPV_DONORMALTWEENING;
        
        numWeights = 0;
    }
    else
    {
        m_RefVP.m_dwTLState &= ~(RDPV_DOPOSITIONTWEENING | 
                                 RDPV_DONORMALTWEENING);
    }
    
    if( numWeights == D3DVBF_DISABLE ) 
        m_RefVP.m_dwTLState &= ~RDPV_DOINDEXEDVERTEXBLEND;
    if( numWeights == D3DVBF_0WEIGHTS ) numWeights = 0;
    if( m_RefVP.m_dwTLState & RDPV_DOINDEXEDVERTEXBLEND )
    {
        // If it is a FVF shader (legacy) the blend indices are provided as
        // the betas. There should be enough betas to cover this.
        if( RDVSD_ISLEGACY( m_CurrentVShaderHandle ) && 
            (numBetas < (numWeights + 1)) )
        {
            DPFERR( "Not enough blend-weights to do indexed vertex blending" );
            return E_FAIL;
        }
        else if( !RDVSD_ISLEGACY( m_CurrentVShaderHandle ) && 
                 ((qwFVFIn & D3DFVFP_BLENDINDICES) == 0) )
        {
            DPFERR( "Blend-indices not provided" );
            return E_FAIL;
        }
    }
    else if( numWeights )
    {
        if( numBetas < numWeights )
        {
            DPFERR( "Not enough blend-weights to do vertex blending" );
            return E_FAIL;
        }
    }
    m_RefVP.m_numVertexBlends = numWeights;
    
    
    //
    // Check prim type to see if point size computation is needed
    // Need to set this before the transform state is set
    //
    m_RefVP.m_dwTLState &= ~(RDPV_DOCOMPUTEPOINTSIZE | RDPV_DOPOINTSCALE);
    switch(m_primType)
    {
    case D3DPT_POINTLIST:
        m_RefVP.m_dwTLState |= RDPV_DOCOMPUTEPOINTSIZE;
        if( GetRS()[D3DRS_POINTSCALEENABLE] )
            m_RefVP.m_dwTLState |= RDPV_DOPOINTSCALE;
        break;
    }

    // Fog or not:
    // Compute fog if: 1) Fogging is enabled
    //                 2) VertexFog mode is not FOG_NONE
    //                 3) TableFog mode is FOG_NONE
    // If both table and vertex fog are not FOG_NONE, table fog
    // is applied.
    if( GetRS()[D3DRENDERSTATE_FOGENABLE] &&
        GetRS()[D3DRENDERSTATE_FOGVERTEXMODE] &&
        !GetRS()[D3DRENDERSTATE_FOGTABLEMODE] )
    {
        m_RefVP.m_dwTLState |= RDPV_DOFOG;
        // Range Fog
        if( GetRS()[D3DRENDERSTATE_RANGEFOGENABLE] )
        {
            m_RefVP.m_dwTLState |= RDPV_RANGEFOG;
        }
        else
        {
            m_RefVP.m_dwTLState &= ~RDPV_RANGEFOG;
        }
    }
    else
    {
        m_RefVP.m_dwTLState &= ~(RDPV_DOFOG | RDPV_RANGEFOG);
    }

    // 
    // Evaluate if any texture transform/gen is required. If so, then compute
    // the output Texture Coordinates
    //
    UpdateActiveTexStageCount();
    m_RefVP.m_dwNumActiveTextureStages = m_cActiveTextureStages;
    m_RefVP.m_dwTLState &= ~(RDPV_DOTEXGEN | RDPV_DOTEXXFORM | 
                             RDPV_NEEDEYENORMAL | RDPV_NEEDEYEXYZ);
    for(  DWORD dwStage=0; dwStage<(DWORD)m_cActiveTextureStages; dwStage++  )
    {
        if( (GetTSS(dwStage)[D3DTSS_TEXTURETRANSFORMFLAGS] 
             & ~D3DTTFF_PROJECTED) != D3DTTFF_DISABLE )
        {
            m_RefVP.m_dwTLState |= RDPV_DOTEXXFORM;
        }
        
        if( GetTSS(dwStage)[D3DTSS_TEXCOORDINDEX] & 0xffff0000 )
        {
            m_RefVP.m_dwTLState |= RDPV_DOTEXGEN;
        }
    }

    // Something changed in the transformation state
    // Recompute digested transform state
    HR_RET(m_RefVP.UpdateXformData());

    // Something changed in the lighting state
    if( (m_RefVP.m_dwTLState & RDPV_DOLIGHTING) &&
        (m_RefVP.m_dwDirtyFlags & RDPV_DIRTY_LIGHTING) )
    {
        RDLIGHTINGDATA& LData = m_RefVP.m_lighting;
        
        //
        // Compute Colorvertex flags only if the lighting is enabled
        //
        m_RefVP.m_dwTLState &= ~RDPV_COLORVERTEXFLAGS;
        LData.pAmbientSrc = &LData.matAmb;
        LData.pDiffuseSrc = &LData.matDiff;
        LData.pSpecularSrc = &LData.matSpec;
        LData.pEmissiveSrc = &LData.matEmis;
        LData.pDiffuseAlphaSrc = &LData.materialDiffAlpha;
        LData.pSpecularAlphaSrc = &LData.materialSpecAlpha;
        if( GetRS()[D3DRENDERSTATE_COLORVERTEX] )
        {
            switch( GetRS()[D3DRENDERSTATE_AMBIENTMATERIALSOURCE] )
            {
            case D3DMCS_MATERIAL:
                break;
            case D3DMCS_COLOR1:
                {
                    if( qwFVFIn & D3DFVF_DIFFUSE )
                    {
                        m_RefVP.m_dwTLState |=
                            (RDPV_VERTEXDIFFUSENEEDED | RDPV_COLORVERTEXAMB);
                        LData.pAmbientSrc = &LData.vertexDiffuse;
                    }
                }
                break;
            case D3DMCS_COLOR2:
                {
                    if( qwFVFIn & D3DFVF_SPECULAR )
                    {
                        m_RefVP.m_dwTLState |=
                            (RDPV_VERTEXSPECULARNEEDED | RDPV_COLORVERTEXAMB);
                        LData.pAmbientSrc = &LData.vertexSpecular;
                    }
                }
                break;
            }

            switch( GetRS()[D3DRENDERSTATE_DIFFUSEMATERIALSOURCE] )
            {
            case D3DMCS_MATERIAL:
                break;
            case D3DMCS_COLOR1:
                {
                    if( qwFVFIn & D3DFVF_DIFFUSE )
                    {
                        m_RefVP.m_dwTLState |=
                            (RDPV_VERTEXDIFFUSENEEDED | RDPV_COLORVERTEXDIFF);
                        LData.pDiffuseSrc = &LData.vertexDiffuse;
                        LData.pDiffuseAlphaSrc =
                            &LData.vertexDiffAlpha;
                    }
                }
                break;
            case D3DMCS_COLOR2:
                {
                    if( qwFVFIn & D3DFVF_SPECULAR )
                    {
                        m_RefVP.m_dwTLState |=
                            (RDPV_VERTEXSPECULARNEEDED | RDPV_COLORVERTEXDIFF);
                        LData.pDiffuseSrc = &LData.vertexSpecular;
                        LData.pDiffuseAlphaSrc =
                            &LData.vertexSpecAlpha;
                    }
                }
                break;
            }

            switch( GetRS()[D3DRENDERSTATE_SPECULARMATERIALSOURCE] )
            {
            case D3DMCS_MATERIAL:
                break;
            case D3DMCS_COLOR1:
                {
                    if( qwFVFIn & D3DFVF_DIFFUSE )
                    {
                        m_RefVP.m_dwTLState |=
                            (RDPV_VERTEXDIFFUSENEEDED | RDPV_COLORVERTEXSPEC);
                        LData.pSpecularSrc = &LData.vertexDiffuse;
                        LData.pSpecularAlphaSrc =
                            &LData.vertexDiffAlpha;
                    }
                }
                break;
            case D3DMCS_COLOR2:
                {
                    if( qwFVFIn & D3DFVF_SPECULAR )
                    {
                        m_RefVP.m_dwTLState |=
                            (RDPV_VERTEXSPECULARNEEDED | RDPV_COLORVERTEXSPEC);
                        LData.pSpecularSrc = &LData.vertexSpecular;
                        LData.pSpecularAlphaSrc =
                            &LData.vertexSpecAlpha;
                    }
                }
                break;
            }

            switch( GetRS()[D3DRENDERSTATE_EMISSIVEMATERIALSOURCE] )
            {
            case D3DMCS_MATERIAL:
                break;
            case D3DMCS_COLOR1:
                {
                    if( qwFVFIn & D3DFVF_DIFFUSE )
                    {
                        m_RefVP.m_dwTLState |=
                            (RDPV_VERTEXDIFFUSENEEDED | RDPV_COLORVERTEXEMIS);
                        LData.pEmissiveSrc = &LData.vertexDiffuse;
                    }
                }
                break;
            case D3DMCS_COLOR2:
                {
                    if( qwFVFIn & D3DFVF_SPECULAR )
                    {
                        m_RefVP.m_dwTLState |=
                            (RDPV_VERTEXSPECULARNEEDED | RDPV_COLORVERTEXEMIS);
                        LData.pEmissiveSrc = &LData.vertexSpecular;
                    }
                }
                break;
            }
        }

        // If specular is needed in the output and has been provided
        // in the input, force the copy of specular data
        if( qwFVFIn & D3DFVF_SPECULAR )
        {
            m_RefVP.m_dwTLState |= RDPV_VERTEXSPECULARNEEDED;
        }

        //
        // Update the remaining light state
        //
        HR_RET(m_RefVP.UpdateLightingData());
    }

    if( (m_RefVP.m_dwTLState & RDPV_DOFOG) &&
        (m_RefVP.m_dwDirtyFlags & RDPV_DIRTY_FOG) )
    {
        HR_RET(m_RefVP.UpdateFogData());
    }

    //
    // Compute output FVF
    //

    BOOL bFogEnabled = GetRS()[D3DRENDERSTATE_FOGENABLE];
    BOOL bSpecularEnabled = GetRS()[D3DRENDERSTATE_SPECULARENABLE];
    m_qwFVFOut = D3DFVF_XYZRHW;

    // If normal is present we have to compute specular and diffuse
    // Otherwise set these bits the same as input.
    // Not that normal should not be present for XYZRHW position type
    if( m_RefVP.m_dwTLState & RDPV_DOLIGHTING )
    {
        m_qwFVFOut |= D3DFVF_DIFFUSE | D3DFVF_SPECULAR;
    }
    else
    {
        m_qwFVFOut |= (qwFVFIn & (D3DFVF_DIFFUSE | D3DFVF_SPECULAR));
    }

    // Clear specular flag if specular disabled
    // else if( !this->rstates[D3DRENDERSTATE_SPECULARENABLE] )
    if( !bSpecularEnabled && ((qwFVFIn & D3DFVF_SPECULAR) == 0))
    {
        m_qwFVFOut &= ~D3DFVF_SPECULAR;
    }

    // Always set specular flag if fog is enabled
    // if( this->rstates[D3DRENDERSTATE_FOGENABLE] )
    if( bFogEnabled && (!GetRS()[D3DRENDERSTATE_FOGTABLEMODE]) )
    {
        m_qwFVFOut |= D3DFVFP_FOG;
    }

    // Reserve space for point size, if needed
    if( m_RefVP.m_dwTLState & RDPV_DOCOMPUTEPOINTSIZE )
    {
        m_qwFVFOut |= D3DFVF_PSIZE;
    }

    if( m_RefVP.m_dwTLState & (RDPV_DOTEXGEN | RDPV_DOTEXXFORM) )
    {
        // If there was any need for TexTransform or TexGen, we need to 
        // override the TCI per stage.
        m_bOverrideTCI = TRUE;
        m_qwFVFOut |= (m_cActiveTextureStages << D3DFVF_TEXCOUNT_SHIFT);

        // Now compute the texture formats
        for( dwStage = 0; dwStage < (DWORD)m_cActiveTextureStages; dwStage++ )
        {
            DWORD dwTextureFormat = 0;
            DWORD TCI = GetTSS(dwStage)[D3DTSS_TEXCOORDINDEX];
            DWORD TexGenMode = TCI & ~0xFFFF;
            TCI &= 0xFFFF;
            switch( TexGenMode )
            {
            case D3DTSS_TCI_CAMERASPACENORMAL:
                dwTextureFormat = D3DFVF_TEXCOORDSIZE3(dwStage);
                m_RefVP.m_dwTLState |= RDPV_NEEDEYENORMAL;
                break;
            case D3DTSS_TCI_CAMERASPACEPOSITION:
                dwTextureFormat = D3DFVF_TEXCOORDSIZE3(dwStage);
                m_RefVP.m_dwTLState |= RDPV_NEEDEYEXYZ;
                break;
            case D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR:
                dwTextureFormat = D3DFVF_TEXCOORDSIZE3(dwStage);
                m_RefVP.m_dwTLState |= (RDPV_NEEDEYENORMAL | RDPV_NEEDEYEXYZ);
                break;
            case 0: // No TexGen
                // Set back the input texture format
                dwTextureFormat = 
                    (D3DFVF_GETTEXCOORDSIZE( qwFVFIn, TCI ) << (dwStage*2 + 16));
                break;
            default:
                DPFERR( "Unknown TexGen mode" );
                return E_FAIL;
            }

            // Adjust the format for TexTransform
            DWORD TexXfmFlags = 
                GetTSS(dwStage)[D3DTSS_TEXTURETRANSFORMFLAGS];
            if( TexXfmFlags )
            {
                switch( TexXfmFlags & ~D3DTTFF_PROJECTED )
                {
                case D3DTTFF_DISABLE:
                    break;
                case D3DTTFF_COUNT1:
                    dwTextureFormat = D3DFVF_TEXCOORDSIZE1( dwStage );
                    break;
                case D3DTTFF_COUNT2:
                    dwTextureFormat = D3DFVF_TEXCOORDSIZE2( dwStage );
                    break;
                case D3DTTFF_COUNT3:
                    dwTextureFormat = D3DFVF_TEXCOORDSIZE3( dwStage );
                    break;
                case D3DTTFF_COUNT4:
                    dwTextureFormat = D3DFVF_TEXCOORDSIZE4( dwStage );
                    break;
                default:
                    DPFERR( "Unknown dimension" );
                    return E_FAIL;
                }
            }
            m_qwFVFOut |= dwTextureFormat;
        }
    }
    else
    {
        // Set up number of texture coordinates and copy texture formats
        DWORD numTex = FVF_TEXCOORD_NUMBER(qwFVFIn);
        m_qwFVFOut |= (numTex << D3DFVF_TEXCOUNT_SHIFT) |
            (qwFVFIn & 0xFFFF0000);
    }
    
    m_RefVP.m_qwFVFOut = m_qwFVFOut;
    
    //
    // Set up the strides for the vertex processing
    //
    return SetupStrides();
}

///////////////////////////////////////////////////////////////////////////////
// RefVP method implementations
///////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------
// RefVP::ProcessVertices
//---------------------------------------------------------------------
RDCLIPCODE
RefVP::ProcessVertices( UINT64 outFVF, GArrayT<RDVertex>& VtxArray, 
                        DWORD count )
{
    UINT64      inFVF = m_qwFVFIn;
    RefClipper& Clipper = m_pDev->GetClipper();
    DWORD       flags = m_dwTLState;
    RDCLIPCODE  clipIntersection = ~0;
    RDCLIPCODE  clipUnion = 0;
    RDLIGHTINGELEMENT le;
    BOOL bVertexInEyeSpace = FALSE;
    DWORD       dwCurrVtx = 0;
    RDVECTOR3*  pPos = (RDVECTOR3 *)m_position.GetFirst();
    RDVECTOR3*  pPos2 = (RDVECTOR3 *)m_position2.GetFirst();
    float*      pBlendFactors = (float *)m_blendweights.GetFirst();
    DWORD*      pBlendIndices = (DWORD *)m_blendindices.GetFirst();
    RDVECTOR3*  pNormal = (RDVECTOR3 *)m_normal.GetFirst();
    RDVECTOR3*  pNormal2 = (RDVECTOR3 *)m_normal2.GetFirst();
    DWORD*      pDiffuse = (DWORD *)m_diffuse.GetFirst();
    DWORD*      pSpecular = (DWORD *)m_specular.GetFirst();
    float*      pPointSize = (float *)m_pointsize.GetFirst();
    float*      pTex[8];
    RDVECTOR3 positionT, normalT; // Tweening results are saved here
    
    for( int t = 0; t < 8 ; t++ )
        pTex[t] = (float *)m_tex[t].GetFirst();

    //
    // Number of vertices to blend. i.e number of blend-matrices to
    // use is numVertexBlends+1.
    //
    int numVertexBlends = m_numVertexBlends;
    m_lighting.outDiffuse  = RD_DEFAULT_DIFFUSE;
    m_lighting.outSpecular = RD_DEFAULT_SPECULAR;

    //
    // The main transform loop
    //
    for( DWORD i = count; i; i-- )
    {
        RDVertex& Vout = VtxArray[dwCurrVtx++];
        Vout.SetFVF( outFVF | D3DFVFP_CLIP );
        float x_clip=0.0f, y_clip=0.0f, z_clip=0.0f, w_clip=0.0f;
        float inv_w_clip=0.0f;
        float cumulBlend = 0; // Blend accumulated so far
        ZeroMemory( &le, sizeof(RDLIGHTINGELEMENT) );
        RDVECTOR3 ZeroNormal;
        if( pNormal == NULL )
        {
            pNormal = &ZeroNormal;
        }
                
        //
        // Transform vertex to the clipping space, and position and normal
        // into eye space, if needed.
        //

        // Tween the Position if needed
        if( flags & RDPV_DOPOSITIONTWEENING )
        {
            positionT.x = pPos->x * (1.0f - m_fTweenFactor) + 
                pPos2->x * m_fTweenFactor;
            positionT.y = pPos->y * (1.0f - m_fTweenFactor) + 
                pPos2->y * m_fTweenFactor;
            positionT.z = pPos->z * (1.0f - m_fTweenFactor) + 
                pPos2->z * m_fTweenFactor;

            pPos = &positionT;
        }
        
        if( flags & RDPV_DONORMALTWEENING )
        {
            normalT.x = pNormal->x * (1.0f - m_fTweenFactor) + 
                pNormal2->x * m_fTweenFactor;
            normalT.y = pNormal->y * (1.0f - m_fTweenFactor) + 
                pNormal2->y * m_fTweenFactor;
            normalT.z = pNormal->z * (1.0f - m_fTweenFactor) + 
                pNormal2->z * m_fTweenFactor;

            pNormal = &normalT;
        }
        
        for( int j=0; j<=numVertexBlends; j++)
        {
            float blend;

            if( numVertexBlends == 0 )
            {
                blend = 1.0f;
            }
            else if( j == numVertexBlends )
            {
                blend = 1.0f - cumulBlend;
            }
            else
            {
                blend = pBlendFactors[j];
                cumulBlend += pBlendFactors[j];
            }

            if( flags & (RDPV_DOCOMPUTEPOINTSIZE | RDPV_DOLIGHTING |
                         RDPV_NEEDEYEXYZ) )
            {
                bVertexInEyeSpace = TRUE;
                if( flags & RDPV_DOINDEXEDVERTEXBLEND )
                {
                    BYTE m = ((BYTE *)pBlendIndices)[j];
                    UpdateWorld( m );
                    le.dvPosition.x += (pPos->x*m_xfmToEye[m]._11 +
                                        pPos->y*m_xfmToEye[m]._21 +
                                        pPos->z*m_xfmToEye[m]._31 +
                                        m_xfmToEye[m]._41) * blend;
                    le.dvPosition.y += (pPos->x*m_xfmToEye[m]._12 +
                                        pPos->y*m_xfmToEye[m]._22 +
                                        pPos->z*m_xfmToEye[m]._32 +
                                        m_xfmToEye[m]._42) * blend;
                    le.dvPosition.z += (pPos->x*m_xfmToEye[m]._13 +
                                        pPos->y*m_xfmToEye[m]._23 +
                                        pPos->z*m_xfmToEye[m]._33 +
                                        m_xfmToEye[m]._43) * blend;
                }
                else
                {
                    le.dvPosition.x += (pPos->x*m_xfmToEye[j]._11 +
                                        pPos->y*m_xfmToEye[j]._21 +
                                        pPos->z*m_xfmToEye[j]._31 +
                                        m_xfmToEye[j]._41) * blend;
                    le.dvPosition.y += (pPos->x*m_xfmToEye[j]._12 +
                                        pPos->y*m_xfmToEye[j]._22 +
                                        pPos->z*m_xfmToEye[j]._32 +
                                        m_xfmToEye[j]._42) * blend;
                    le.dvPosition.z += (pPos->x*m_xfmToEye[j]._13 +
                                        pPos->y*m_xfmToEye[j]._23 +
                                        pPos->z*m_xfmToEye[j]._33 +
                                        m_xfmToEye[j]._43) * blend;
                }
            }

            if( flags & (RDPV_DOLIGHTING | RDPV_NEEDEYENORMAL) )
            {
                if( flags & RDPV_DOINDEXEDVERTEXBLEND )
                {
                    BYTE m = ((BYTE *)pBlendIndices)[j];
                    UpdateWorld( m );
                    le.dvNormal.x += (pNormal->x*m_xfmToEyeInv[m]._11 +
                                      pNormal->y*m_xfmToEyeInv[m]._12 +
                                      pNormal->z*m_xfmToEyeInv[m]._13) * blend;
                    le.dvNormal.y += (pNormal->x*m_xfmToEyeInv[m]._21 +
                                      pNormal->y*m_xfmToEyeInv[m]._22 +
                                      pNormal->z*m_xfmToEyeInv[m]._23) * blend;
                    le.dvNormal.z += (pNormal->x*m_xfmToEyeInv[m]._31 +
                                      pNormal->y*m_xfmToEyeInv[m]._32 +
                                      pNormal->z*m_xfmToEyeInv[m]._33) * blend;
                }
                else
                {
                    // Transform vertex normal to the eye space
                    // We use inverse transposed matrix
                    le.dvNormal.x += (pNormal->x*m_xfmToEyeInv[j]._11 +
                                      pNormal->y*m_xfmToEyeInv[j]._12 +
                                      pNormal->z*m_xfmToEyeInv[j]._13) * blend;
                    le.dvNormal.y += (pNormal->x*m_xfmToEyeInv[j]._21 +
                                      pNormal->y*m_xfmToEyeInv[j]._22 +
                                      pNormal->z*m_xfmToEyeInv[j]._23) * blend;
                    le.dvNormal.z += (pNormal->x*m_xfmToEyeInv[j]._31 +
                                      pNormal->y*m_xfmToEyeInv[j]._32 +
                                      pNormal->z*m_xfmToEyeInv[j]._33) * blend;
                }
            }

            if( flags & RDPV_DOINDEXEDVERTEXBLEND )
            {
                BYTE m = ((BYTE *)pBlendIndices)[j];
                UpdateWorld( m );
                x_clip += (pPos->x*m_xfmCurrent[m]._11 +
                           pPos->y*m_xfmCurrent[m]._21 +
                           pPos->z*m_xfmCurrent[m]._31 +
                           m_xfmCurrent[m]._41) * blend;
                y_clip += (pPos->x*m_xfmCurrent[m]._12 +
                           pPos->y*m_xfmCurrent[m]._22 +
                           pPos->z*m_xfmCurrent[m]._32 +
                           m_xfmCurrent[m]._42) * blend;
                z_clip += (pPos->x*m_xfmCurrent[m]._13 +
                           pPos->y*m_xfmCurrent[m]._23 +
                           pPos->z*m_xfmCurrent[m]._33 +
                           m_xfmCurrent[m]._43) * blend;
                w_clip += (pPos->x*m_xfmCurrent[m]._14 +
                           pPos->y*m_xfmCurrent[m]._24 +
                           pPos->z*m_xfmCurrent[m]._34 +
                           m_xfmCurrent[m]._44) * blend;
            }
            else
            {
                // Apply WORLDj
                x_clip += (pPos->x*m_xfmCurrent[j]._11 +
                           pPos->y*m_xfmCurrent[j]._21 +
                           pPos->z*m_xfmCurrent[j]._31 +
                           m_xfmCurrent[j]._41) * blend;
                y_clip += (pPos->x*m_xfmCurrent[j]._12 +
                           pPos->y*m_xfmCurrent[j]._22 +
                           pPos->z*m_xfmCurrent[j]._32 +
                           m_xfmCurrent[j]._42) * blend;
                z_clip += (pPos->x*m_xfmCurrent[j]._13 +
                           pPos->y*m_xfmCurrent[j]._23 +
                           pPos->z*m_xfmCurrent[j]._33 +
                           m_xfmCurrent[j]._43) * blend;
                w_clip += (pPos->x*m_xfmCurrent[j]._14 +
                           pPos->y*m_xfmCurrent[j]._24 +
                           pPos->z*m_xfmCurrent[j]._34 +
                           m_xfmCurrent[j]._44) * blend;
            }
        }

        // Save the clip-coordinates
        Vout.m_clip_x = x_clip;
        Vout.m_clip_y = y_clip;
        Vout.m_clip_z = z_clip;
        Vout.m_clip_w = w_clip;
        
        if( (flags & RDPV_NORMALIZENORMALS) && 
            (flags & (RDPV_DOLIGHTING | RDPV_NEEDEYENORMAL)) )
        {
            Normalize(le.dvNormal);
        }

        FLOAT fPointSize = 0.0f;
        if( flags & RDPV_DOCOMPUTEPOINTSIZE )
        {
            FLOAT fDist = (FLOAT)sqrt(le.dvPosition.x*le.dvPosition.x +
                                      le.dvPosition.y*le.dvPosition.y +
                                      le.dvPosition.z*le.dvPosition.z);
            if( inFVF & D3DFVF_PSIZE )
            {
                fPointSize = *pPointSize;
            }
            else
            {
                // from D3DRENDERSTATE_POINTSIZE
                fPointSize = m_fPointSize;
            }
            if( flags & RDPV_DOPOINTSCALE )
            {
                fPointSize = (float)Clipper.m_Viewport.dwHeight*
                    fPointSize*(FLOAT)sqrt(1.0f/
                                           (m_fPointAttA + m_fPointAttB*fDist +
                                            m_fPointAttC*fDist*fDist));
            }
            
            fPointSize = max(m_fPointSizeMin, fPointSize);
            fPointSize = min(m_fPointSizeMax, fPointSize);
            FLOAT *pfSOut = &Vout.m_pointsize;
            *pfSOut = fPointSize;
        }

        //
        // Compute clip codes if needed
        //
        if( flags & RDPV_DOCLIPPING )
        {
            RDCLIPCODE clip = Clipper.ComputeClipCodes( &clipIntersection, 
                                                        &clipUnion, x_clip, 
                                                        y_clip, z_clip, 
                                                        w_clip);
            if( clip == 0 )
            {
                Vout.m_clip = 0;
                inv_w_clip = D3DVAL(1)/w_clip;
            }
            else
            {
                if( Clipper.UseGuardBand() )
                {
                    if( (clip & ~RDCLIP_INGUARDBAND) == 0 )
                    {
                        // If vertex is inside the guardband we have to compute
                        // screen coordinates
                        inv_w_clip = D3DVAL(1)/w_clip;
                        Vout.m_clip = (RDCLIPCODE)clip;
                        goto l_DoScreenCoord;
                    }
                }
                Vout.m_clip = (RDCLIPCODE)clip;
                // If vertex is outside the frustum we can not compute screen
                // coordinates. skip to lighting
#if 0
                Vout.m_pos.x = x_clip;
                Vout.m_pos.y = y_clip;
                Vout.m_pos.z = z_clip;
                Vout.m_rhw   = w_clip;
#endif
                goto l_DoLighting;
            }
        }
        else
        {
            // We have to check this only for DONOTCLIP case, because otherwise
            // the vertex with "we = 0" will be clipped and screen coordinates
            // will not be computed
            // "clip" is not zero, if "we" is zero.
            if( !FLOAT_EQZ(w_clip) )
                inv_w_clip = D3DVAL(1)/w_clip;
            else
                inv_w_clip = __HUGE_PWR2;
        }

l_DoScreenCoord:

        Vout.m_pos.x = x_clip * inv_w_clip * Clipper.scaleX +
            Clipper.offsetX;
        Vout.m_pos.y = y_clip * inv_w_clip * Clipper.scaleY +
            Clipper.offsetY;
        Vout.m_pos.z = z_clip * inv_w_clip * Clipper.scaleZ +
            Clipper.offsetZ;
        Vout.m_rhw = inv_w_clip;

l_DoLighting:

        if( flags & RDPV_DOLIGHTING )
        {
            bVertexInEyeSpace = TRUE;

            //
            // If Diffuse color is needed, extract it for color vertex.
            //
            if( flags & RDPV_VERTEXDIFFUSENEEDED )
            {
                const DWORD color = *pDiffuse;
                MakeRDCOLOR3(&m_lighting.vertexDiffuse, color);
                m_lighting.vertexDiffAlpha = color & 0xff000000;
            }

            //
            // If Specular color is needed and provided
            // , extract it for color vertex.
            //
            if( flags & RDPV_VERTEXSPECULARNEEDED )
            {
                const DWORD color = *pSpecular;
                MakeRDCOLOR3(&m_lighting.vertexSpecular, color);
                m_lighting.vertexSpecAlpha = color & 0xff000000;
            }

            //
            // Light the vertex
            //
            LightVertex( &le );

            if( outFVF & D3DFVFP_FOG )
            {
                Vout.m_fog = 
                    (FLOAT)RGBA_GETALPHA( *(m_lighting.pSpecularAlphaSrc) )/255.0f;
            }
        }
        else if( inFVF & (D3DFVF_DIFFUSE | D3DFVF_SPECULAR) )
        {
            if( inFVF & D3DFVF_DIFFUSE )
                m_lighting.outDiffuse = *pDiffuse;
            if( inFVF & D3DFVF_SPECULAR )
            {
                m_lighting.outSpecular = *pSpecular;
                if( outFVF & D3DFVFP_FOG )
                {
                    Vout.m_fog = (FLOAT)RGBA_GETALPHA( *pSpecular )/255.0f;
                }
            }
        }

        //
        // Compute Vertex Fog if needed
        //
        if( flags & RDPV_DOFOG )
        {
            FogVertex( Vout, *pPos, &le,  numVertexBlends,
                       pBlendFactors, bVertexInEyeSpace );
        }

        if( outFVF & D3DFVF_DIFFUSE )
        {
            MakeRDCOLOR4( &Vout.m_diffuse, m_lighting.outDiffuse );
        }
        if( outFVF & D3DFVF_SPECULAR )
        {
            MakeRDCOLOR4( &Vout.m_specular, m_lighting.outSpecular );
        }

        if( flags & (RDPV_DOTEXGEN | RDPV_DOTEXXFORM) )
        {
            for( DWORD dwStage = 0; 
                 dwStage < m_dwNumActiveTextureStages; 
                 dwStage++ )
            {
                DWORD TexXfmFlags = 
                    m_pDev->GetTSS(dwStage)[D3DTSS_TEXTURETRANSFORMFLAGS];
                DWORD TCI = 
                    m_pDev->GetTSS(dwStage)[D3DTSS_TEXCOORDINDEX];
                DWORD TexGenMode = TCI & ~0xFFFF;
                TCI &= 0xFFFF;

                // Perform TexGen
                switch( TexGenMode )
                {
                case D3DTSS_TCI_CAMERASPACENORMAL:
                    Vout.m_tex[dwStage].x = le.dvNormal.x;
                    Vout.m_tex[dwStage].y = le.dvNormal.y;
                    Vout.m_tex[dwStage].z = le.dvNormal.z;
                    Vout.m_tex[dwStage].w = 1.0f;
                    break;
                case D3DTSS_TCI_CAMERASPACEPOSITION:
                    Vout.m_tex[dwStage].x = le.dvPosition.x;
                    Vout.m_tex[dwStage].y = le.dvPosition.y;
                    Vout.m_tex[dwStage].z = le.dvPosition.z;
                    Vout.m_tex[dwStage].w = 1.0f;
                    break;
                case D3DTSS_TCI_CAMERASPACEREFLECTIONVECTOR:
                {
                    FLOAT fNX = le.dvNormal.x;
                    FLOAT fNY = le.dvNormal.y;
                    FLOAT fNZ = le.dvNormal.z;
                    FLOAT fNorm = 0;
                            
                    if( m_pDev->GetRS()[D3DRENDERSTATE_LOCALVIEWER] == TRUE )
                    {
                        FLOAT fX = le.dvPosition.x;
                        FLOAT fY = le.dvPosition.y;
                        FLOAT fZ = le.dvPosition.z;
                        
                        // have to normalize before we reflect, 
                        // result will be normalized
                        FLOAT fDist = (FLOAT)sqrt(fX*fX + fY*fY + fZ*fZ);
                        if( FLOAT_NEZ( fDist ) )
                        {
                            fNorm = 1.0f/fDist;
                        }
                        fX *= fNorm; fY *= fNorm; fZ *= fNorm;
                        FLOAT fDot2 = 2.0f*(fX*fNX + fY*fNY + fZ*fNZ);
                        Vout.m_tex[dwStage].x = fX - fNX*fDot2;
                        Vout.m_tex[dwStage].y = fY - fNY*fDot2;
                        Vout.m_tex[dwStage].z = fZ - fNZ*fDot2;
                    }
                    else
                    {
                        FLOAT fDot2 = 2.0f*fNZ;
                        Vout.m_tex[dwStage].x = -fNX*fDot2;
                        Vout.m_tex[dwStage].y = -fNY*fDot2;
                        Vout.m_tex[dwStage].z = 1.f - fNZ*fDot2;
                    }
                    Vout.m_tex[dwStage].w = 1.0f;
                    break;
                }
                case 0: // No TexGen
                {
                    // Copy the tex coordinate for this stage
                    DWORD n = GetTexCoordDim( inFVF, TCI );
                    float *pCoord = (float *)&Vout.m_tex[dwStage];
                    for( DWORD j = 0; j < n; j++ )
                    {
                        pCoord[j] = pTex[TCI][j];
                    }
                    if( n < 4 ) pCoord[n] = 1.0f;
                    for( j = n+1; j < 4; j++ ) pCoord[j] = 0.0f;
                    break;
                }
                default:
                    DPFERR( "Unknown TexGen mode" );
                    return E_FAIL;
                }

                // Perform TexTransform
                if( ( TexXfmFlags & ~D3DTTFF_PROJECTED ) != D3DTTFF_DISABLE ) 
                {
                    LPD3DMATRIX pM = &m_xfmTex[dwStage];
                    FLOAT fX = Vout.m_tex[dwStage].x;
                    FLOAT fY = Vout.m_tex[dwStage].y;
                    FLOAT fZ = Vout.m_tex[dwStage].z;
                    FLOAT fW = Vout.m_tex[dwStage].w;
                    FLOAT fXout = fX*pM->_11 + fY*pM->_21 + fZ*pM->_31 + 
                        fW*pM->_41;
                    FLOAT fYout = fX*pM->_12 + fY*pM->_22 + fZ*pM->_32 + 
                        fW*pM->_42;
                    FLOAT fZout = fX*pM->_13 + fY*pM->_23 + fZ*pM->_33 + 
                        fW*pM->_43;
                    FLOAT fWout = fX*pM->_14 + fY*pM->_24 + fZ*pM->_34 + 
                        fW*pM->_44;
                    
                    Vout.m_tex[dwStage].x = fXout;
                    Vout.m_tex[dwStage].y = fYout;
                    Vout.m_tex[dwStage].z = fZout;
                    Vout.m_tex[dwStage].w = fWout;
                }
            }
        }
        else
        {
            // Copy the textures over
            // If there is no TexGen or TexTransform
            DWORD i, j;
            DWORD numTex = FVF_TEXCOORD_NUMBER(outFVF);
            for(  i = 0; i < numTex; i++ )
            {
                DWORD n = GetTexCoordDim( outFVF, i );
                // DWORD n = (DWORD)(m_dwTexCoordSizeArray[i] >> 2);
                float *pCoord = (float *)&Vout.m_tex[i];
                for( j = 0; j < n; j++ )
                {
                    pCoord[j] = pTex[i][j];
                }
            }
        }

        //
        // Update the current pointers
        //
        pPos = (RDVECTOR3 *)m_position.Next();
        pPos2 = (RDVECTOR3 *)m_position2.Next();
        pBlendFactors = (float *)m_blendweights.Next();
        pBlendIndices = (DWORD *)m_blendindices.Next();
        pNormal = (RDVECTOR3 *)m_normal.Next();
        pNormal2 = (RDVECTOR3 *)m_normal2.Next();
        pDiffuse = (DWORD *)m_diffuse.Next();
        pSpecular = (DWORD *)m_specular.Next();
        pPointSize = (float *)m_pointsize.Next();
        for( t = 0; t < 8; t++ )
            pTex[t] = (float *)m_tex[t].Next();
    }

    if( flags & RDPV_DOCLIPPING )
    {
        Clipper.m_clipIntersection = clipIntersection;
        Clipper.m_clipUnion = clipUnion;
    }
    else
    {
        Clipper.m_clipIntersection = 0;
        Clipper.m_clipUnion = 0;
    }

    // Returns whether all the vertices were off screen
    return Clipper.m_clipIntersection;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\tnl\sources.inc ===
TARGETNAME = reftnl
TARGETPATH = obj
TARGETTYPE = LIBRARY

INCLUDES = ..;$(INCLUDES)

SOURCES = \
        ..\vstream.cpp  \
        ..\vshader.cpp  \
        ..\xform.cpp    \
        ..\lighting.cpp \
        ..\clipping.cpp \
        ..\reftnl.cpp   \
        ..\procprim.cpp

PRECOMPILED_INCLUDE = ..\pch.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\swrast.inc ===
#
# Contains common settings for pluggable software rasterizers.
#

!ifndef DXGROOT
DXGROOT = $(DXROOT)\dxg
!endif

!ifndef D3D8ROOT
D3D8ROOT = $(DXGROOT)\d3d8
!endif

SWRASTROOT = $(DXGROOT)\swrast

C_DEFINES=$(C_DEFINES) -DDIRECT3D_VERSION=0x0800

INCLUDES = $(SWRASTROOT)\inc;$(D3D8ROOT)\inc;$(DXGROOT)\inc;$(DXROOT)\inc;$(DDK_INC_PATH);$(INCLUDES)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\tnl\vshader.cpp ===
/*==========================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vvm.cpp
 *  Content:    Virtual Vertex Machine implementation
 *
 *
 ***************************************************************************/
#include "pch.cpp"
#pragma hdrstop

float MINUS_MAX()
{
    DWORD v = 0xFF7FFFFF;
    return *(float*)&v;
}

float PLUS_MAX()
{
    DWORD v = 0x7F7FFFFF;
    return *(float*)&v;
}

//-----------------------------------------------------------------------------
// Returns instruction size, based on the op-code
//
UINT GetInstructionLength(DWORD inst)
{
    DWORD opcode = D3DSI_GETOPCODE( inst );
    // returns number of source operands + length of opcode and the destination
    switch (opcode)
    {
    case D3DSIO_MOV :  return 1 + 2;
    case D3DSIO_ADD :  return 2 + 2;
    case D3DSIO_MAD :  return 3 + 2;
    case D3DSIO_MUL :  return 2 + 2;
    case D3DSIO_RCP :  return 1 + 2;
    case D3DSIO_RSQ :  return 1 + 2;
    case D3DSIO_DP3 :  return 2 + 2;
    case D3DSIO_DP4 :  return 2 + 2;
    case D3DSIO_MIN :  return 2 + 2;
    case D3DSIO_MAX :  return 2 + 2;
    case D3DSIO_SLT :  return 2 + 2;
    case D3DSIO_SGE :  return 2 + 2;
    case D3DSIO_EXP :  return 1 + 2;
    case D3DSIO_LOG :  return 1 + 2;
    case D3DSIO_EXPP:  return 1 + 2;
    case D3DSIO_LOGP:  return 1 + 2;
    case D3DSIO_LIT :  return 1 + 2;
    case D3DSIO_DST :  return 2 + 2;
    case D3DSIO_FRC :  return 1 + 2;
    case D3DSIO_M4x4:  return 2 + 2;
    case D3DSIO_M4x3:  return 2 + 2;
    case D3DSIO_M3x4:  return 2 + 2;
    case D3DSIO_M3x3:  return 2 + 2;
    case D3DSIO_M3x2:  return 2 + 2;
    case D3DSIO_NOP :  return 1;
    default: return 1;
    case D3DSIO_COMMENT: return 1 + ((inst & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT);
    }
}

#if 0

//-----------------------------------------------------------------------------
HRESULT CVertexVM::GetDataPointer(DWORD dwMemType, RDVECTOR4 ** pData)
{
    try
    {
        *pData = this->GetDataAddr(dwMemType, 0);
    }
    catch (CD3DException e)
    {
        *pData = NULL;
        return DDERR_INVALIDPARAMS;
    }
    return D3D_OK;
}
#endif

///////////////////////////////////////////////////////////////////////////////
//
//  RefVM implementation.
//
///////////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// Vertex Virtual Machine Opcode implementations
//-----------------------------------------------------------------------------
void
RefVM::WriteResult()
{
    if( m_WriteMask == D3DSP_WRITEMASK_ALL)
    {
        *m_pDest = m_TmpReg;
    }
    else
    {
        if( m_WriteMask & D3DSP_WRITEMASK_0)
            m_pDest->x = m_TmpReg.x;
        if( m_WriteMask & D3DSP_WRITEMASK_1)
            m_pDest->y = m_TmpReg.y;
        if( m_WriteMask & D3DSP_WRITEMASK_2)
            m_pDest->z = m_TmpReg.z;
        if( m_WriteMask & D3DSP_WRITEMASK_3)
            m_pDest->w = m_TmpReg.w;
    }
}
//-----------------------------------------------------------------------------
void
RefVM::InstMov()
{
    SetDestReg();
    SetSrcReg(0);

    if( m_pDest == m_reg.m_a )
    {
        float p = (float)floor(m_Source[0].x);
        *(int*)&m_pDest->x = FTOI(p);
    }
    else
    {
        m_TmpReg = m_Source[0];
        WriteResult();
    }
}
//-----------------------------------------------------------------------------
void
RefVM::InstAdd()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1);

    m_TmpReg.x = m_Source[0].x + m_Source[1].x;
    m_TmpReg.y = m_Source[0].y + m_Source[1].y;
    m_TmpReg.z = m_Source[0].z + m_Source[1].z;
    m_TmpReg.w = m_Source[0].w + m_Source[1].w;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstMad()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1);
    SetSrcReg(2);

    m_TmpReg.x = m_Source[0].x * m_Source[1].x + m_Source[2].x;
    m_TmpReg.y = m_Source[0].y * m_Source[1].y + m_Source[2].y;
    m_TmpReg.z = m_Source[0].z * m_Source[1].z + m_Source[2].z;
    m_TmpReg.w = m_Source[0].w * m_Source[1].w + m_Source[2].w;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstMul()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1);

    m_TmpReg.x = m_Source[0].x * m_Source[1].x;
    m_TmpReg.y = m_Source[0].y * m_Source[1].y;
    m_TmpReg.z = m_Source[0].z * m_Source[1].z;
    m_TmpReg.w = m_Source[0].w * m_Source[1].w;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstRcp()
{
    SetDestReg();
    SetSrcReg(0);

    if( m_Source[0].w == 1.0f )
    {
        // Must be exactly 1.0
        m_TmpReg.x = m_TmpReg.y = m_TmpReg.z = m_TmpReg.w = 1.0f;
    }
    else if( m_Source[0].w == 0 )
    {
        m_TmpReg.x = m_TmpReg.y = m_TmpReg.z = m_TmpReg.w = PLUS_MAX();
    }
    else
    {
        m_TmpReg.x = m_TmpReg.y = m_TmpReg.z = m_TmpReg.w = 1.0f/m_Source[0].w;
    }

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstRsq()
{
    SetDestReg();
    SetSrcReg(0);

    float v = ABSF(m_Source[0].w);
    if( v == 1.0f )
    {
        m_TmpReg.x = m_TmpReg.y = m_TmpReg.z = m_TmpReg.w = 1.0f;
    }
    else if( v == 0 )
    {
        m_TmpReg.x = m_TmpReg.y = m_TmpReg.z = m_TmpReg.w = PLUS_MAX();
    }
    else
    {
        v = (float)(1.0f / sqrt(v));
        m_TmpReg.x = m_TmpReg.y = m_TmpReg.z = m_TmpReg.w = v;
    }

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstDP3()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1);

    m_TmpReg.x =
    m_TmpReg.y =
    m_TmpReg.z =
    m_TmpReg.w = m_Source[0].x * m_Source[1].x +
                 m_Source[0].y * m_Source[1].y +
                 m_Source[0].z * m_Source[1].z;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstDP4()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1);

    m_TmpReg.x =
    m_TmpReg.y =
    m_TmpReg.z =
    m_TmpReg.w = m_Source[0].x * m_Source[1].x +
                 m_Source[0].y * m_Source[1].y +
                 m_Source[0].z * m_Source[1].z +
                 m_Source[0].w * m_Source[1].w;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstSlt()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1);

    m_TmpReg.x = (m_Source[0].x < m_Source[1].x) ? 1.0f : 0.0f;
    m_TmpReg.y = (m_Source[0].y < m_Source[1].y) ? 1.0f : 0.0f;
    m_TmpReg.z = (m_Source[0].z < m_Source[1].z) ? 1.0f : 0.0f;
    m_TmpReg.w = (m_Source[0].w < m_Source[1].w) ? 1.0f : 0.0f;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstSge()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1);

    m_TmpReg.x = (m_Source[0].x >= m_Source[1].x) ? 1.0f : 0.0f;
    m_TmpReg.y = (m_Source[0].y >= m_Source[1].y) ? 1.0f : 0.0f;
    m_TmpReg.z = (m_Source[0].z >= m_Source[1].z) ? 1.0f : 0.0f;
    m_TmpReg.w = (m_Source[0].w >= m_Source[1].w) ? 1.0f : 0.0f;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstMin()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1);

    m_TmpReg.x=(m_Source[0].x < m_Source[1].x) ? m_Source[0].x : m_Source[1].x;
    m_TmpReg.y=(m_Source[0].y < m_Source[1].y) ? m_Source[0].y : m_Source[1].y;
    m_TmpReg.z=(m_Source[0].z < m_Source[1].z) ? m_Source[0].z : m_Source[1].z;
    m_TmpReg.w=(m_Source[0].w < m_Source[1].w) ? m_Source[0].w : m_Source[1].w;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstMax()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1);

    m_TmpReg.x=(m_Source[0].x >= m_Source[1].x) ? m_Source[0].x : m_Source[1].x;
    m_TmpReg.y=(m_Source[0].y >= m_Source[1].y) ? m_Source[0].y : m_Source[1].y;
    m_TmpReg.z=(m_Source[0].z >= m_Source[1].z) ? m_Source[0].z : m_Source[1].z;
    m_TmpReg.w=(m_Source[0].w >= m_Source[1].w) ? m_Source[0].w : m_Source[1].w;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstExp()
{
    SetDestReg();
    SetSrcReg(0);

    float v = m_Source[0].w;

    m_TmpReg.x = m_TmpReg.y = m_TmpReg.z = m_TmpReg.w = (float)pow(2, v);

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstExpP()
{
    SetDestReg();
    SetSrcReg(0);

    float w = m_Source[0].w;
    float v = (float)floor(m_Source[0].w);

    m_TmpReg.x = (float)pow(2, v);
    m_TmpReg.y = w - v;
    // Reduced precision exponent
    float tmp = (float)pow(2, w);
    DWORD tmpd = *(DWORD*)&tmp & 0xffffff00;
    m_TmpReg.z = *(float*)&tmpd;
    m_TmpReg.w = 1;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstLog()
{
    SetDestReg();
    SetSrcReg(0);

    float v = ABSF(m_Source[0].w);
    if (v != 0)
    {
        m_TmpReg.x = m_TmpReg.y = m_TmpReg.z = m_TmpReg.w =
            (float)(log(v)/log(2));
    }
    else
    {
        m_TmpReg.x = m_TmpReg.y = m_TmpReg.z = m_TmpReg.w = MINUS_MAX();
    }

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstLogP()
{
    SetDestReg();
    SetSrcReg(0);

    float v = ABSF(m_Source[0].w);
    if (v != 0)
    {
        int p = (int)(*(DWORD*)&v >> 23) - 127;
        m_TmpReg.x = (float)p;    // exponent
        p = (*(DWORD*)&v & 0x7FFFFF) | 0x3f800000;
        m_TmpReg.y =  *(float*)&p;// mantissa;
        float tmp = (float)(log(v)/log(2));
        DWORD tmpd = *(DWORD*)&tmp & 0xffffff00;
        m_TmpReg.z = *(float*)&tmpd;
        m_TmpReg.w = 1;
    }
    else
    {
        m_TmpReg.x = MINUS_MAX();
        m_TmpReg.y = 1.0f;
        m_TmpReg.z = MINUS_MAX();
        m_TmpReg.w = 1.0f;
    }

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstLit()
{
    SetDestReg();
    SetSrcReg(0);

    m_TmpReg.x = 1;
    m_TmpReg.y = 0;
    m_TmpReg.z = 0;
    m_TmpReg.w = 1;
    float power = m_Source[0].w;
    const float MAXPOWER = 127.9961f;
    if (power < -MAXPOWER)
        power = -MAXPOWER;          // Fits into 8.8 fixed point format
    else
    if (power > MAXPOWER)
        power = MAXPOWER;          // Fits into 8.8 fixed point format

    if (m_Source[0].x > 0)
    {
        m_TmpReg.y = m_Source[0].x;
        if (m_Source[0].y > 0)
        {
            // Allowed approximation is EXP(power * LOG(m_Source[0].y))
            m_TmpReg.z = (float)(pow(m_Source[0].y, power));
        }
    }

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstFrc()
{
    SetDestReg();
    SetSrcReg(0);

    m_TmpReg.x = m_Source[0].x - (float)floor(m_Source[0].x);
    m_TmpReg.y = m_Source[0].y - (float)floor(m_Source[0].y);
    m_TmpReg.z = m_Source[0].z - (float)floor(m_Source[0].z);
    m_TmpReg.w = m_Source[0].w - (float)floor(m_Source[0].w);

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstDst()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1);

    m_TmpReg.x = 1;
    m_TmpReg.y = m_Source[0].y * m_Source[1].y;
    m_TmpReg.z = m_Source[0].z;
    m_TmpReg.w = m_Source[1].w;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstM4x4()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1, 4);
    m_TmpReg.x = m_Source[0].x * m_Source[1].x +
                 m_Source[0].y * m_Source[1].y +
                 m_Source[0].z * m_Source[1].z +
                 m_Source[0].w * m_Source[1].w;
    m_TmpReg.y = m_Source[0].x * m_Source[2].x +
                 m_Source[0].y * m_Source[2].y +
                 m_Source[0].z * m_Source[2].z +
                 m_Source[0].w * m_Source[2].w;
    m_TmpReg.z = m_Source[0].x * m_Source[3].x +
                 m_Source[0].y * m_Source[3].y +
                 m_Source[0].z * m_Source[3].z +
                 m_Source[0].w * m_Source[3].w;
    m_TmpReg.w = m_Source[0].x * m_Source[4].x +
                 m_Source[0].y * m_Source[4].y +
                 m_Source[0].z * m_Source[4].z +
                 m_Source[0].w * m_Source[4].w;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstM4x3()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1, 3);
    m_TmpReg.x = m_Source[0].x * m_Source[1].x +
                 m_Source[0].y * m_Source[1].y +
                 m_Source[0].z * m_Source[1].z +
                 m_Source[0].w * m_Source[1].w;
    m_TmpReg.y = m_Source[0].x * m_Source[2].x +
                 m_Source[0].y * m_Source[2].y +
                 m_Source[0].z * m_Source[2].z +
                 m_Source[0].w * m_Source[2].w;
    m_TmpReg.z = m_Source[0].x * m_Source[3].x +
                 m_Source[0].y * m_Source[3].y +
                 m_Source[0].z * m_Source[3].z +
                 m_Source[0].w * m_Source[3].w;

    WriteResult();
}
//-----------------------------------------------------------------------------
void
RefVM::InstM3x4()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1, 4);
    m_TmpReg.x = m_Source[0].x * m_Source[1].x +
                 m_Source[0].y * m_Source[1].y +
                 m_Source[0].z * m_Source[1].z;
    m_TmpReg.y = m_Source[0].x * m_Source[2].x +
                 m_Source[0].y * m_Source[2].y +
                 m_Source[0].z * m_Source[2].z;
    m_TmpReg.z = m_Source[0].x * m_Source[3].x +
                 m_Source[0].y * m_Source[3].y +
                 m_Source[0].z * m_Source[3].z;
    m_TmpReg.w = m_Source[0].x * m_Source[4].x +
                 m_Source[0].y * m_Source[4].y +
                 m_Source[0].z * m_Source[4].z;

    WriteResult();
}
//-----------------------------------------------------------------------------
void RefVM::InstM3x3()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1, 3);
    m_TmpReg.x = m_Source[0].x * m_Source[1].x +
                 m_Source[0].y * m_Source[1].y +
                 m_Source[0].z * m_Source[1].z;
    m_TmpReg.y = m_Source[0].x * m_Source[2].x +
                 m_Source[0].y * m_Source[2].y +
                 m_Source[0].z * m_Source[2].z;
    m_TmpReg.z = m_Source[0].x * m_Source[3].x +
                 m_Source[0].y * m_Source[3].y +
                 m_Source[0].z * m_Source[3].z;

    WriteResult();
}
//-----------------------------------------------------------------------------
void RefVM::InstM3x2()
{
    SetDestReg();
    SetSrcReg(0);
    SetSrcReg(1, 2);
    m_TmpReg.x = m_Source[0].x * m_Source[1].x +
                 m_Source[0].y * m_Source[1].y +
                 m_Source[0].z * m_Source[1].z;
    m_TmpReg.y = m_Source[0].x * m_Source[2].x +
                 m_Source[0].y * m_Source[2].y +
                 m_Source[0].z * m_Source[2].z;

    WriteResult();
}
//-----------------------------------------------------------------------------
// RefVM::SetData
//     Save data into the specified registers.
//-----------------------------------------------------------------------------
HRESULT
RefVM::SetData( DWORD dwMemType, DWORD dwStart, DWORD dwCount,
                     LPVOID pBuffer )
{
    memcpy( GetDataAddr( dwMemType, dwStart ), pBuffer,
            dwCount * sizeof(RDVECTOR4) );
    return D3D_OK;
}

//-----------------------------------------------------------------------------
// RefVM::GetData
//      Fetch data from the specified registers.
//-----------------------------------------------------------------------------
HRESULT
RefVM::GetData( DWORD dwMemType, DWORD dwStart, DWORD dwCount,
                     LPVOID pBuffer )
{
    memcpy( pBuffer, GetDataAddr( dwMemType, dwStart ),
               dwCount * sizeof(RDVECTOR4) );
    return D3D_OK;
}

//-----------------------------------------------------------------------------
// RefVM::SetDestReg
// - parses destination token
// - computes m_pDest, m_WrideMask, m_dwOffset for the destination
// - current token pointer is andvanced to the next token
//-----------------------------------------------------------------------------
#undef RET_ERR
#define RET_ERR( a )     \
{                        \
    DPFERR( a );         \
    return E_FAIL;       \
}
HRESULT
RefVM::SetDestReg()
{
    DWORD dwCurToken = *m_pCurToken;
    DWORD dwRegType = D3DSI_GETREGTYPE(dwCurToken);
    m_dwRegOffset = D3DSI_GETREGNUM(dwCurToken);
    m_WriteMask = D3DSI_GETWRITEMASK(dwCurToken);
    switch( dwRegType )
    {
    case D3DSPR_TEMP:
        m_pDest = m_reg.m_t;
        break;
    case D3DSPR_RASTOUT:
        m_pDest = m_reg.m_out;
        break;
    case D3DSPR_ATTROUT:
        m_pDest = m_reg.m_col;
        break;
    case D3DSPR_TEXCRDOUT:
        m_pDest = m_reg.m_tex;
        break;
    case D3DSPR_ADDR:
        m_pDest = m_reg.m_a;
        break;
    default:
        RET_ERR( "Invalid register for destination" );
    }
    m_pCurToken++;
    m_pDest += m_dwRegOffset;
    return S_OK;
}

//-----------------------------------------------------------------------------
// RefVM::SetSrcReg
//  Computes m_Source[index] and advances m_pCurToken
//-----------------------------------------------------------------------------
HRESULT
RefVM::SetSrcReg( DWORD index )
{
    const DWORD dwCurToken = *m_pCurToken;
    const DWORD dwRegType = D3DSI_GETREGTYPE( dwCurToken );
    const DWORD dwOffset = D3DSI_GETREGNUM( dwCurToken );
    RDVECTOR4 *src = NULL;
    if( dwRegType == D3DSPR_CONST )
    {
        D3DVS_ADDRESSMODE_TYPE am;
        am = (D3DVS_ADDRESSMODE_TYPE)D3DVS_GETADDRESSMODE( dwCurToken );
        int offset = (int)dwOffset;
        if( am == D3DVS_ADDRMODE_RELATIVE )
        {
            int relOffset = *(int*)&m_reg.m_a[0].x;
            offset += relOffset;
            if( offset < 0 || offset >= RD_MAX_NUMCONSTREG )
                RET_ERR( "Constant register index is out of bounds" );
        }
        src = &m_reg.m_c[offset];
    }
    else
        src = this->GetDataAddr(dwRegType, dwOffset);

    _ASSERT( src != NULL, "src is NULL" );
    RDVECTOR4 *outsrc = &m_Source[index];
    DWORD swizzle = D3DVS_GETSWIZZLE(dwCurToken);
    if( swizzle == D3DVS_NOSWIZZLE )
        *outsrc = *src;
    else
    {
        // Where to take X
        const DWORD dwSrcX = D3DVS_GETSWIZZLECOMP(dwCurToken, 0);
        // Where to take Y
        const DWORD dwSrcY = D3DVS_GETSWIZZLECOMP(dwCurToken, 1);
        // Where to take Z
        const DWORD dwSrcZ = D3DVS_GETSWIZZLECOMP(dwCurToken, 2);
        // Where to take W
        const DWORD dwSrcW = D3DVS_GETSWIZZLECOMP(dwCurToken, 3);
        outsrc->x = ((float*)src)[dwSrcX];
        outsrc->y = ((float*)src)[dwSrcY];
        outsrc->z = ((float*)src)[dwSrcZ];
        outsrc->w = ((float*)src)[dwSrcW];
    }
    if( D3DVS_GETSRCMODIFIER( dwCurToken ) == D3DSPSM_NEG)
    {
        outsrc->x = -outsrc->x;
        outsrc->y = -outsrc->y;
        outsrc->z = -outsrc->z;
        outsrc->w = -outsrc->w;
    }
    m_pCurToken++;
    return S_OK;
}
//-----------------------------------------------------------------------------
// RefVM::SetSrcReg
//  Computes m_Source[index] and advances m_pCurToken
//-----------------------------------------------------------------------------
HRESULT
RefVM::SetSrcReg( DWORD index, DWORD count )
{
    const DWORD dwCurToken = *m_pCurToken;
    const DWORD dwRegType = D3DSI_GETREGTYPE(dwCurToken);
    const DWORD dwOffset = D3DSI_GETREGNUM(dwCurToken);
    RDVECTOR4 *src;
    if (dwRegType == D3DSPR_CONST)
    {
        D3DVS_ADDRESSMODE_TYPE am;
        am = (D3DVS_ADDRESSMODE_TYPE)D3DVS_GETADDRESSMODE(dwCurToken);
        int offset = (int)dwOffset;
        if (am == D3DVS_ADDRMODE_RELATIVE)
        {
            int relOffset = *(int*)&m_reg.m_a[0].x;
            offset += relOffset;
            if (offset < 0 || offset >= RD_MAX_NUMCONSTREG)
                RET_ERR( "Constant register index is out of bounds" );
        }
        src = &m_reg.m_c[offset];
    }
    else
    {
        if (dwOffset >= RD_MAX_NUMCONSTREG)
            RET_ERR( "Constant register index is out of bounds" );
        src = this->GetDataAddr(dwRegType, dwOffset);
    }
    RDVECTOR4 *outsrc = &m_Source[index];
    DWORD swizzle = D3DVS_GETSWIZZLE(dwCurToken);
    // Where to take X
    const DWORD dwSrcX = D3DVS_GETSWIZZLECOMP(dwCurToken, 0);
    // Where to take Y
    const DWORD dwSrcY = D3DVS_GETSWIZZLECOMP(dwCurToken, 1);
    // Where to take Z
    const DWORD dwSrcZ = D3DVS_GETSWIZZLECOMP(dwCurToken, 2);
    // Where to take W
    const DWORD dwSrcW = D3DVS_GETSWIZZLECOMP(dwCurToken, 3);
    for (UINT i=0; i < count; i++)
    {
        if (swizzle == D3DVS_NOSWIZZLE)
            *outsrc = *src;
        else
        {
            outsrc->x = ((float*)src)[dwSrcX];
            outsrc->y = ((float*)src)[dwSrcY];
            outsrc->z = ((float*)src)[dwSrcZ];
            outsrc->w = ((float*)src)[dwSrcW];
        }
        if (D3DVS_GETSRCMODIFIER(dwCurToken) == D3DSPSM_NEG)
        {
            outsrc->x = -outsrc->x;
            outsrc->y = -outsrc->y;
            outsrc->z = -outsrc->z;
            outsrc->w = -outsrc->w;
        }
        outsrc++;
        src++;
    }
    m_pCurToken++;
    return S_OK;
}

//---------------------------------------------------------------------
// RefVM::GetDataAddr
//     Parses binary shader representation, compiles is and returns
//     compiled object
//---------------------------------------------------------------------
RDVECTOR4*
RefVM::GetDataAddr(DWORD dwRegType, DWORD dwElementIndex)
{
    RDVECTOR4* src;
    switch( dwRegType )
    {
    case D3DSPR_TEMP    : src = m_reg.m_t; break;
    case D3DSPR_INPUT   : src = m_reg.m_i; break;
    case D3DSPR_CONST   : src = m_reg.m_c; break;
    case D3DSPR_ADDR    : src = m_reg.m_a; break;
    case D3DSPR_RASTOUT : src = m_reg.m_out; break;
    case D3DSPR_ATTROUT : src = m_reg.m_col; break;
    case D3DSPR_TEXCRDOUT   : src = m_reg.m_tex; break;
    default:
        return NULL;
    }
    return &src[dwElementIndex];
}

//---------------------------------------------------------------------
// RefVM::ExecuteShader()
//      Executes the shader once per vertex.
//---------------------------------------------------------------------
HRESULT
RefVM::ExecuteShader(RefDev *pRD)
{
    if( m_pCurrentShaderCode == NULL )
    {
        RET_ERR( "No current shader set in the Virtual Shader Machine" );
    }

    m_pCurToken = m_pCurrentShaderCode->m_pRawBits;
    DWORD* pEnd = m_pCurToken + m_pCurrentShaderCode->m_dwSize;
    m_pCurToken++;
    m_CurInstIndex = 0;
    while( m_pCurToken < pEnd )
    {
        if( *m_pCurToken == D3DVS_END() ) break;
        DWORD dwInst = *m_pCurToken;
        DWORD dwOpCode = D3DSI_GETOPCODE( dwInst );
        m_pCurToken++;
        switch( dwOpCode )
        {
        case D3DSIO_COMMENT: m_pCurToken += (GetInstructionLength( dwInst ) - 1);
        case D3DSIO_NOP  : ; break;
        case D3DSIO_MOV  : InstMov();  break;
        case D3DSIO_ADD  : InstAdd();  break;
        case D3DSIO_MAD  : InstMad();  break;
        case D3DSIO_MUL  : InstMul();  break;
        case D3DSIO_RCP  : InstRcp();  break;
        case D3DSIO_RSQ  : InstRsq();  break;
        case D3DSIO_DP3  : InstDP3();  break;
        case D3DSIO_DP4  : InstDP4();  break;
        case D3DSIO_MIN  : InstMin();  break;
        case D3DSIO_MAX  : InstMax();  break;
        case D3DSIO_SLT  : InstSlt();  break;
        case D3DSIO_SGE  : InstSge();  break;
        case D3DSIO_EXPP : InstExpP(); break;
        case D3DSIO_LOGP : InstLogP(); break;
        case D3DSIO_EXP  : InstExp();  break;
        case D3DSIO_LOG  : InstLog();  break;
        case D3DSIO_LIT  : InstLit();  break;
        case D3DSIO_DST  : InstDst();  break;
        case D3DSIO_FRC  : InstFrc();  break;
        case D3DSIO_M4x4 : InstM4x4(); break;
        case D3DSIO_M4x3 : InstM4x3(); break;
        case D3DSIO_M3x4 : InstM3x4(); break;
        case D3DSIO_M3x3 : InstM3x3(); break;
        case D3DSIO_M3x2 : InstM3x2(); break;
        default:
            RET_ERR( "Invalid shader opcode" );
        }
        if( dwOpCode != D3DSIO_COMMENT ) m_CurInstIndex++;
    }
    m_CurInstIndex = 0;

    return D3D_OK;
}

#if DBG
//-----------------------------------------------------------------------------
// VertexShaderInstDisAsm - Generates human-readable character string for a
// single vertex shader instruction.  String interface is similar to _snprintf.
//-----------------------------------------------------------------------------
static int VertexShaderInstDisAsm(
    char* pStrRet, int StrSizeRet, DWORD* pShader, DWORD Flags )
{
    DWORD*  pToken = pShader;

    // stage in local string, then copy
    char pStr[256] = "";
#define _ADDSTR( _Str ) { _snprintf( pStr, 256, "%s" _Str , pStr ); }
#define _ADDSTRP( _Str, _Param ) { _snprintf( pStr, 256, "%s" _Str , pStr, _Param ); }

    DWORD Inst = *pToken++;
    DWORD Opcode = (Inst & D3DSI_OPCODE_MASK);
    switch (Opcode)
    {
    case D3DSIO_NOP:  _ADDSTR("NOP");  break;
    case D3DSIO_MOV:  _ADDSTR("MOV");  break;
    case D3DSIO_ADD:  _ADDSTR("ADD");  break;
    case D3DSIO_MAD:  _ADDSTR("MAD");  break;
    case D3DSIO_MUL:  _ADDSTR("MUL");  break;
    case D3DSIO_RCP:  _ADDSTR("RCP");  break;
    case D3DSIO_RSQ:  _ADDSTR("RSQ");  break;
    case D3DSIO_DP3:  _ADDSTR("DP3");  break;
    case D3DSIO_DP4:  _ADDSTR("DP4");  break;
    case D3DSIO_MIN:  _ADDSTR("MIN");  break;
    case D3DSIO_MAX:  _ADDSTR("MAX");  break;
    case D3DSIO_SLT:  _ADDSTR("SLT");  break;
    case D3DSIO_SGE:  _ADDSTR("SGE");  break;
    case D3DSIO_EXP:  _ADDSTR("EXP");  break;
    case D3DSIO_LOG:  _ADDSTR("LOG");  break;
    case D3DSIO_EXPP: _ADDSTR("EXPP"); break;
    case D3DSIO_LOGP: _ADDSTR("LOGP"); break;
    case D3DSIO_LIT:  _ADDSTR("LIT");  break;
    case D3DSIO_DST:  _ADDSTR("DST");  break;
    default        :  _ADDSTR("???");  break;
    }
    if (*pToken & (1L<<31))
    {
        DWORD DstParam = *pToken++;
        switch (DstParam & D3DSP_REGTYPE_MASK)
        {
        case D3DSPR_TEMP     : _ADDSTRP(" T%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_ADDR     : _ADDSTR(" Addr"); break;
        case D3DSPR_RASTOUT  : _ADDSTRP(" R%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_ATTROUT  : _ADDSTRP(" A%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        case D3DSPR_TEXCRDOUT: _ADDSTRP(" T%d", (DstParam & D3DSP_REGNUM_MASK) ); break;
        }
        if (*pToken & (1L<<31)) _ADDSTR(" ");
        while (*pToken & (1L<<31))
        {
            DWORD SrcParam = *pToken++;
            switch (SrcParam & D3DSP_REGTYPE_MASK)
            {
            case D3DSPR_TEMP     : _ADDSTRP(" T%d", (SrcParam & D3DSP_REGNUM_MASK) ); break;
            case D3DSPR_INPUT    : _ADDSTRP(" I%d", (SrcParam & D3DSP_REGNUM_MASK) ); break;
            case D3DSPR_CONST    : _ADDSTRP(" C%d", (SrcParam & D3DSP_REGNUM_MASK) ); break;
            }
            if (*pToken & (1L<<31)) _ADDSTR(",");
        }
    }
    return _snprintf( pStrRet, StrSizeRet, "%s", pStr );
}
#endif // DBG

//---------------------------------------------------------------------
// RefVM::CompileCode
//     Parses binary shader representation, compiles is and returns
//     compiled object
//---------------------------------------------------------------------
#undef RET_ERR
#define RET_ERR( a )     \
{                        \
    DPFERR( a );         \
    delete pShaderCode;  \
    return NULL;         \
}


RDVShaderCode*
RefVM::CompileCode( DWORD dwSize, LPDWORD pBits )
{
    RDVShaderCode* pShaderCode = new RDVShaderCode();
    if( pShaderCode == NULL )
        RET_ERR( "Out of memory allocating ShaderCode" );

    pShaderCode->m_dwSize = dwSize >> 2; // #DWORDs
    pShaderCode->m_pRawBits = new DWORD[pShaderCode->m_dwSize];
    if( pShaderCode->m_pRawBits == NULL )
        RET_ERR( "Out of memory allocating RawBits" );

    memcpy( pShaderCode->m_pRawBits, (LPBYTE)pBits, dwSize );


    // Based on the what output registers are modified, we compute the
    // corresponding FVF id. The id will be used for memory allocation
    // of the output buffer and will be passed to the rasterizer
    UINT64   qwOutFVF = 0;
    DWORD nTexCoord = 0;        // Number of output texture coordinates
    LPDWORD pEnd = NULL;

    // For each texture register stores the combined write mask.
    // Used to find how many floats are written to each texture coordinates
    DWORD TextureWritten[8];
    memset( TextureWritten, 0, sizeof(TextureWritten) );

    m_pCurToken = pShaderCode->m_pRawBits;
    pEnd = m_pCurToken + pShaderCode->m_dwSize;
    m_pCurToken++; // Skip the version number
    pShaderCode->m_InstCount = 0;
    while( m_pCurToken < pEnd )
    {
        if( *m_pCurToken == D3DVS_END() ) break;
        DWORD* pNextToken = m_pCurToken;
        DWORD dwInst = *m_pCurToken;
        DWORD dwOpCode = D3DSI_GETOPCODE(dwInst);
        if( *m_pCurToken == D3DVS_END() ) break;
        m_pCurToken++;
        switch( dwOpCode )
        {
        case D3DSIO_COMMENT:
        case D3DSIO_NOP  : ; break;
        case D3DSIO_MOV  :
        case D3DSIO_ADD  :
        case D3DSIO_MAD  :
        case D3DSIO_MUL  :
        case D3DSIO_RCP  :
        case D3DSIO_RSQ  :
        case D3DSIO_DP3  :
        case D3DSIO_DP4  :
        case D3DSIO_MIN  :
        case D3DSIO_MAX  :
        case D3DSIO_SLT  :
        case D3DSIO_SGE  :
        case D3DSIO_EXP  :
        case D3DSIO_LOG  :
        case D3DSIO_EXPP :
        case D3DSIO_LOGP :
        case D3DSIO_LIT  :
        case D3DSIO_DST  :
        case D3DSIO_FRC  :
        case D3DSIO_M4x4 :
        case D3DSIO_M4x3 :
        case D3DSIO_M3x4 :
        case D3DSIO_M3x3 :
        case D3DSIO_M3x2 :
        {
            // Find out if output register are modified by the command and
            // update the output FVF
            DWORD dwOffset;
            if( FAILED( SetDestReg() ) )
                RET_ERR( "Invalid shader opcode" );

            RDVECTOR4*   m_pOutRegister = NULL;
            if( m_pDest - m_dwRegOffset != m_reg.m_t )
            {
                dwOffset = m_dwRegOffset;
                m_pOutRegister = m_pDest - m_dwRegOffset;
            }
            else
                break;      // Output register is not modified

            if( m_pOutRegister == m_reg.m_out )
            {
                if (dwOffset == D3DSRO_POSITION)
                {
                    qwOutFVF |= D3DFVF_XYZRHW;
                }
                else if (dwOffset == D3DSRO_FOG)
                {
                    qwOutFVF |= D3DFVFP_FOG;
                }
                else if (dwOffset == D3DSRO_POINT_SIZE)
                {
                    qwOutFVF |= D3DFVF_PSIZE;
                }
            }
            else if( m_pOutRegister == m_reg.m_col )
            {
                if( dwOffset == 0 )
                {
                    qwOutFVF |= D3DFVF_DIFFUSE;
                }
                else
                {
                    qwOutFVF |= D3DFVF_SPECULAR;
                }
            }
            else if( m_pOutRegister == m_reg.m_tex )
            {
                if( TextureWritten[dwOffset] == 0 )
                {
                    nTexCoord++;
                }
                TextureWritten[dwOffset] |= m_WriteMask;
            }
            else if( m_pOutRegister != m_reg.m_a )
                RET_ERR( "Invalid output register offset" );
        }
        break;
        default:
            RET_ERR( "Invalid shader opcode" );
        }
        pShaderCode->m_InstCount++;
        m_pCurToken = pNextToken + GetInstructionLength(dwInst);
    }

    // allocate and set instruction array
    if (pShaderCode->m_InstCount)
    {
        pShaderCode->m_pInst = new RDVShaderInst[pShaderCode->m_InstCount];
        if( pShaderCode->m_pInst == NULL )
            RET_ERR( "Out of memory allocating Instructions" );
        memset( pShaderCode->m_pInst, 0,
            sizeof(RDVShaderInst)*pShaderCode->m_InstCount );

        DWORD dwCurInst = 0;
        m_pCurToken = pShaderCode->m_pRawBits;
        pEnd = m_pCurToken + pShaderCode->m_dwSize;
        m_pCurToken++;
        while( m_pCurToken < pEnd )
        {
            DWORD dwInst = *m_pCurToken;
            DWORD dwOpCode = D3DSI_GETOPCODE( dwInst );
            if( *m_pCurToken == D3DVS_END() ) break;
            UINT ilength = GetInstructionLength( dwInst );
            if (dwOpCode == D3DSIO_COMMENT)
            {
                pShaderCode->m_pInst[dwCurInst].m_Tokens[0] = dwInst;
                pShaderCode->m_pInst[dwCurInst].m_pComment = (m_pCurToken+1);
                pShaderCode->m_pInst[dwCurInst].m_CommentSize = ilength - 1;
            }
            else
            {
                memcpy( pShaderCode->m_pInst[dwCurInst].m_Tokens, m_pCurToken,
                    4*ilength );
#if DBG
                VertexShaderInstDisAsm( pShaderCode->m_pInst[dwCurInst].m_String,
                    RD_MAX_SHADERINSTSTRING, pShaderCode->m_pInst[dwCurInst].m_Tokens, 0x0 );
#else // !DBG
                pShaderCode->m_pInst[dwCurInst].m_String[ 0 ] = '\0';
#endif // !DBG
            }
            m_pCurToken += ilength;
            dwCurInst++;
        }
    }

    qwOutFVF |= nTexCoord << D3DFVF_TEXCOUNT_SHIFT;
    if( nTexCoord )
    {
        for( DWORD i = 0; i < nTexCoord; i++ )
        {
            if( TextureWritten[i] == 0 )
                RET_ERR( "Texture coordinates are not continuous" );
            switch( TextureWritten[i] )
            {
            case D3DSP_WRITEMASK_ALL:
                qwOutFVF |= D3DFVF_TEXCOORDSIZE4(i);
                break;
            case D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1 | D3DSP_WRITEMASK_2:
                qwOutFVF |= D3DFVF_TEXCOORDSIZE3(i);
                break;
            case D3DSP_WRITEMASK_0 | D3DSP_WRITEMASK_1:
                qwOutFVF |= D3DFVF_TEXCOORDSIZE2(i);
                break;
            case D3DSP_WRITEMASK_0:
                qwOutFVF |= D3DFVF_TEXCOORDSIZE1(i);
                break;
            default:
                RET_ERR( "Invalid write mask for texture register" );
            }
        }
    }
    pShaderCode->m_qwFVFOut = qwOutFVF;
    return pShaderCode;
}

///////////////////////////////////////////////////////////////////////////////
//
//  RefDev implementation.
//
///////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------
// RefDev::ProcessPrimitiveVVM()
//      Processess and draw the current primitive using the VVM
//---------------------------------------------------------------------
HRESULT
RefDev::ProcessPrimitiveVVM( D3DPRIMITIVETYPE primType,
                             DWORD dwStartVertex,
                             DWORD cVertices,
                             DWORD dwStartIndex,
                             DWORD cIndices )
{
    HRESULT hr = S_OK;
    RDCLIPCODE  clipIntersection = ~0;
    RDCLIPCODE  clipUnion = 0;

    // Save Prim Type for later use
    m_primType      = primType;
    m_dwNumVertices = cVertices;
    m_dwStartVertex = dwStartVertex;
    m_dwNumIndices  = cIndices;
    m_dwStartIndex  = dwStartIndex;

    RDVDeclaration* pDecl = &(m_pCurrentVShader->m_Declaration);
    RDVShaderCode*  pCode = m_pCurrentVShader->m_pCode;
    RDVVMREG* pRegisters = m_RefVM.GetRegisters();

    // Output FVF that was computed at the compile time
    m_qwFVFOut = pCode->m_qwFVFOut;

    //
    // Clipping information depends both on the output FVF computation
    // and the other State, so do it here after both have been computed
    //
    HR_RET( UpdateClipper());

    D3DVALUE scaleX = m_Clipper.scaleX;
    D3DVALUE scaleY = m_Clipper.scaleY;
    D3DVALUE scaleZ = m_Clipper.scaleZ;

    D3DVALUE offsetX = m_Clipper.offsetX;
    D3DVALUE offsetY = m_Clipper.offsetY;
    D3DVALUE offsetZ = m_Clipper.offsetZ;

    //
    // Grow buffers to the requisite size
    //

    // Grow TLVArray if required
    if( FAILED( this->m_TLVArray.Grow( m_dwNumVertices ) ) )
    {
        DPFERR( "Could not grow TL vertex buffer" );
        hr = DDERR_OUTOFMEMORY;
        return hr;
    }

    //
    // Process Vertices
    //
    for( DWORD i = 0; i < m_dwNumVertices; i++ )
    {
        RDVertex& Vout = m_TLVArray[i];
        Vout.SetFVF( pCode->m_qwFVFOut | D3DFVFP_CLIP );

        // Copy vertex elements to the input vertex registers
        for( DWORD j = 0; j < pDecl->m_dwNumElements; j++ )
        {
            RDVElement& ve = pDecl->m_VertexElements[j];
            RDVStream* pStream = &m_VStream[ve.m_dwStreamIndex];
            LPBYTE pData = (LPBYTE)pStream->m_pData + ve.m_dwOffset +
                pStream->m_dwStride * (m_dwStartVertex + i);
            RDVECTOR4* pReg = m_RefVM.GetDataAddr( D3DSPR_INPUT,
                                                      ve.m_dwRegister );

            ve.m_pfnCopy( pData, pReg );
        }

        // Execute the shader
        m_RefVM.ExecuteShader(this);

        // Get the result from the output VVM registers
        float x, y, z, w, inv_w_clip = 0.0f;

        w = pRegisters->m_out[D3DSRO_POSITION].w;
        z = pRegisters->m_out[D3DSRO_POSITION].z;

        // Make clipping rules 0 < x < w;  0 < y < w

        x = (pRegisters->m_out[D3DSRO_POSITION].x + w) * 0.5f;
        y = (pRegisters->m_out[D3DSRO_POSITION].y + w) * 0.5f;

        // Save the clip coordinates
        Vout.m_clip_x = x;
        Vout.m_clip_y = y;
        Vout.m_clip_z = z;
        Vout.m_clip_w = w;

        //
        // Compute clip codes if needed
        //
        if( GetRS()[D3DRENDERSTATE_CLIPPING] )
        {
            RDCLIPCODE clip = m_Clipper.ComputeClipCodes(
                &clipIntersection, &clipUnion, x, y, z, w);
            if( clip == 0 )
            {
                Vout.m_clip = 0;
                inv_w_clip = 1.0f/w;
            }
            else
            {
                if( m_Clipper.UseGuardBand() )
                {
                    if( (clip & ~RDCLIP_INGUARDBAND) == 0 )
                    {
                        // If vertex is inside the guardband we have to compute
                        // screen coordinates
                        inv_w_clip = 1.0f/w;
                        Vout.m_clip = (RDCLIPCODE)clip;
                        goto l_DoScreenCoord;
                    }
                }
                Vout.m_clip = (RDCLIPCODE)clip;
                // If vertex is outside the frustum we can not compute screen
                // coordinates, hence store the clip coordinates
#if 0
                Vout.m_pos.x = x;
                Vout.m_pos.y = y;
                Vout.m_pos.z = z;
                Vout.m_rhw   = w;
#endif
                goto l_DoLighting;
            }
        }
        else
        {
            // We have to check this only for DONOTCLIP case, because otherwise
            // the vertex with "we = 0" will be clipped and screen coordinates
            // will not be computed
            // "clip" is not zero, if "we" is zero.
            if( !FLOAT_EQZ(w) )
                inv_w_clip = D3DVAL(1)/w;
            else
                inv_w_clip = __HUGE_PWR2;
        }
l_DoScreenCoord:
        Vout.m_pos.x = x * inv_w_clip * scaleX + offsetX;
        Vout.m_pos.y = y * inv_w_clip * scaleY + offsetY;
        Vout.m_pos.z = z * inv_w_clip * scaleZ + offsetZ;
        Vout.m_rhw = inv_w_clip;

l_DoLighting:
        if( m_qwFVFOut & D3DFVF_DIFFUSE )
        {
            // Clamp the colors before copying.
            if( FLOAT_LTZ(pRegisters->m_col[0].a) )
                pRegisters->m_col[0].a = 0.0f;
            else if( FLOAT_CMP_PONE(pRegisters->m_col[0].a, >) )
                pRegisters->m_col[0].a = 1.0f;

            if( FLOAT_LTZ(pRegisters->m_col[0].r) )
                pRegisters->m_col[0].r = 0.0f;
            else if( FLOAT_CMP_PONE(pRegisters->m_col[0].r, >) )
                pRegisters->m_col[0].r = 1.0f;

            if( FLOAT_LTZ(pRegisters->m_col[0].g) )
                pRegisters->m_col[0].g = 0.0f;
            else if( FLOAT_CMP_PONE(pRegisters->m_col[0].g, >) )
                pRegisters->m_col[0].g = 1.0f;

            if( FLOAT_LTZ(pRegisters->m_col[0].b) )
                pRegisters->m_col[0].b = 0.0f;
            else if( FLOAT_CMP_PONE(pRegisters->m_col[0].b, >) )
                pRegisters->m_col[0].b = 1.0f;

            memcpy( &Vout.m_diffuse,&(pRegisters->m_col[0]),
                    sizeof(RDVECTOR4) );
        }
        if( m_qwFVFOut & D3DFVF_SPECULAR )
        {
            if( FLOAT_LTZ(pRegisters->m_col[1].a) )
                pRegisters->m_col[1].a = 0.0f;
            else if( FLOAT_CMP_PONE(pRegisters->m_col[1].a, >) )
                pRegisters->m_col[1].a = 1.0f;

            if( FLOAT_LTZ(pRegisters->m_col[1].r) )
                pRegisters->m_col[1].r = 0.0f;
            else if( FLOAT_CMP_PONE(pRegisters->m_col[1].r, >) )
                pRegisters->m_col[1].r = 1.0f;

            if( FLOAT_LTZ(pRegisters->m_col[1].g) )
                pRegisters->m_col[1].g = 0.0f;
            else if( FLOAT_CMP_PONE(pRegisters->m_col[1].g, >) )
                pRegisters->m_col[1].g = 1.0f;

            if( FLOAT_LTZ(pRegisters->m_col[1].b) )
                pRegisters->m_col[1].b = 0.0f;
            else if( FLOAT_CMP_PONE(pRegisters->m_col[1].b, >) )
                pRegisters->m_col[1].b = 1.0f;

            memcpy( &Vout.m_specular,&(pRegisters->m_col[1]),
                    sizeof(RDVECTOR4) );
        }
        if( m_qwFVFOut & D3DFVFP_FOG )
        {
            if( FLOAT_LTZ(pRegisters->m_out[D3DSRO_FOG].x) )
                pRegisters->m_out[D3DSRO_FOG].x = 0.0f;

            if( FLOAT_CMP_PONE(pRegisters->m_out[D3DSRO_FOG].x, >) )
                pRegisters->m_out[D3DSRO_FOG].x = 1.0f;

            Vout.m_fog = pRegisters->m_out[D3DSRO_FOG].x;
        }

        // Copy the textures over
        if( m_qwFVFOut & D3DFVF_PSIZE )
        {
            Vout.m_pointsize = pRegisters->m_out[D3DSRO_POINT_SIZE].x;
        }


        // Copy the textures over

        {
            DWORD i, j;
            DWORD numTex = FVF_TEXCOORD_NUMBER(m_qwFVFOut);
            for(  i = 0; i < numTex; i++ )
            {
                DWORD n = GetTexCoordDim( m_qwFVFOut, i );
                // DWORD n = (DWORD)(m_dwTexCoordSizeArray[i] >> 2);
                float *pCoordDest = (float *)&Vout.m_tex[i];
                float *pCoordSrc = (float *)&pRegisters->m_tex[i];
                for( j = 0; j < n; j++ )
                {
                    pCoordDest[j] = pCoordSrc[j];
                }
            }
        }
    }

    if( GetRS()[D3DRENDERSTATE_CLIPPING] )
    {
        m_Clipper.m_clipIntersection = clipIntersection;
        m_Clipper.m_clipUnion = clipUnion;
    }
    else
    {
        m_Clipper.m_clipIntersection = 0;
        m_Clipper.m_clipUnion = 0;
    }


    //
    // Clip and Draw the primitives
    //

    if( m_dwNumIndices )
    {
        if( !NeedClipping((m_Clipper.UseGuardBand()), m_Clipper.m_clipUnion) )
        {
            if( m_IndexStream.m_dwStride == 4 )
                hr = DrawOneIndexedPrimitive(
                    m_TLVArray,
                    0,
                    (LPDWORD)m_IndexStream.m_pData,
                    m_dwStartIndex,
                    m_dwNumIndices,
                    m_primType );
            else
                hr = DrawOneIndexedPrimitive(
                    m_TLVArray,
                    0,
                    (LPWORD)m_IndexStream.m_pData,
                    m_dwStartIndex,
                    m_dwNumIndices,
                    m_primType );
        }
        else
        {
            if( m_IndexStream.m_dwStride == 4 )
                hr = m_Clipper.DrawOneIndexedPrimitive(
                    m_TLVArray,
                    0,
                    (LPDWORD)m_IndexStream.m_pData,
                    m_dwStartIndex,
                    m_dwNumIndices,
                    m_primType );
            else
                hr = m_Clipper.DrawOneIndexedPrimitive(
                    m_TLVArray,
                    0,
                    (LPWORD)m_IndexStream.m_pData,
                    m_dwStartIndex,
                    m_dwNumIndices,
                    m_primType );
        }
    }
    else
    {
        if( !NeedClipping((m_Clipper.UseGuardBand()), m_Clipper.m_clipUnion) )
        {
            hr = DrawOnePrimitive(
                m_TLVArray,
                0,
                m_primType,
                m_dwNumVertices );
        }
        else
        {
            hr = m_Clipper.DrawOnePrimitive(
                m_TLVArray,
                0,
                m_primType,
                m_dwNumVertices );
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\tnl\vstream.cpp ===
/*============================================================================
 *
 *  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       vshader.cpp
 *  Content:    SetStreamSource and VertexShader
 *              software implementation.
 *
 ****************************************************************************/

#include "pch.cpp"
#pragma hdrstop

/////////////////////////////////////////////////////////////////////////
//
//          Helper functions
//
/////////////////////////////////////////////////////////////////////////

void
Copy_FLOAT1( LPVOID pInputStream, RDVECTOR4* pVertexRegister )
{
    pVertexRegister->x = *(float*)pInputStream;
    pVertexRegister->y = 0;
    pVertexRegister->z = 0;
    pVertexRegister->w = 1;
}

void
Copy_FLOAT2( LPVOID pInputStream, RDVECTOR4* pVertexRegister )
{
    pVertexRegister->x = ((float*)pInputStream)[0];
    pVertexRegister->y = ((float*)pInputStream)[1];
    pVertexRegister->z = 0;
    pVertexRegister->w = 1;
}

void
Copy_FLOAT3( LPVOID pInputStream, RDVECTOR4* pVertexRegister )
{
    pVertexRegister->x = ((float*)pInputStream)[0];
    pVertexRegister->y = ((float*)pInputStream)[1];
    pVertexRegister->z = ((float*)pInputStream)[2];
    pVertexRegister->w = 1;
}

void
Copy_FLOAT4( LPVOID pInputStream, RDVECTOR4* pVertexRegister )
{
    pVertexRegister->x = ((float*)pInputStream)[0];
    pVertexRegister->y = ((float*)pInputStream)[1];
    pVertexRegister->z = ((float*)pInputStream)[2];
    pVertexRegister->w = ((float*)pInputStream)[3];
}

void
Copy_D3DCOLOR( LPVOID pInputStream, RDVECTOR4* pVertexRegister )
{
    const float scale = 1.0f/255.f;
    const DWORD v = ((DWORD*)pInputStream)[0];
    pVertexRegister->a = scale * RGBA_GETALPHA(v);
    pVertexRegister->r = scale * RGBA_GETRED(v);
    pVertexRegister->g = scale * RGBA_GETGREEN(v);
    pVertexRegister->b = scale * RGBA_GETBLUE(v);
}

void
Copy_UBYTE4( LPVOID pInputStream, RDVECTOR4* pVertexRegister )
{
    const BYTE* v = (BYTE *)pInputStream;
    pVertexRegister->x = v[0];
    pVertexRegister->y = v[1];
    pVertexRegister->z = v[2];
    pVertexRegister->w = v[3];
}

void
Copy_SHORT2( LPVOID pInputStream, RDVECTOR4* pVertexRegister )
{
    const SHORT* v = ((SHORT*)pInputStream);
    pVertexRegister->x = v[0];
    pVertexRegister->y = v[1];
    pVertexRegister->z = 0;
    pVertexRegister->w = 1;
}

void
Copy_SHORT4( LPVOID pInputStream, RDVECTOR4* pVertexRegister )
{
    const SHORT* v = ((SHORT*)pInputStream);
    pVertexRegister->x = v[0];
    pVertexRegister->y = v[1];
    pVertexRegister->z = v[2];
    pVertexRegister->w = v[3];
}

inline HRESULT
SetVElement( RDVElement& ve, DWORD dwReg, DWORD dwDataType, DWORD dwOffset )
{
    ve.m_dwOffset = dwOffset;
    ve.m_dwRegister = dwReg;
    ve.m_dwDataType = dwDataType;
    switch( dwDataType )
    {
    case D3DVSDT_FLOAT1:
        ve.m_pfnCopy = Copy_FLOAT1;
        break;
    case D3DVSDT_FLOAT2:
        ve.m_pfnCopy = Copy_FLOAT2;
        break;
    case D3DVSDT_FLOAT3:
        ve.m_pfnCopy = Copy_FLOAT3;
        break;
    case D3DVSDT_FLOAT4:
        ve.m_pfnCopy = Copy_FLOAT4;
        break;
    case D3DVSDT_D3DCOLOR:
        ve.m_pfnCopy = Copy_D3DCOLOR;
        break;
    case D3DVSDT_UBYTE4:
        ve.m_pfnCopy = Copy_UBYTE4;
        break;
    case D3DVSDT_SHORT2:
        ve.m_pfnCopy = Copy_SHORT2;
        break;
    case D3DVSDT_SHORT4:
        ve.m_pfnCopy = Copy_SHORT4;
        break;
    default:
        return E_FAIL;
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
// Based on register and data type the function computes FVF dword and texture
// presence bits:
// - bits  0 - 7 in the qwFVF2 are used as texture presence bits
// - bits 12 - 14 in the qwFVF are used as count of blend weights
//-----------------------------------------------------------------------------
HRESULT
UpdateFVF( DWORD dwRegister, DWORD dwDataType, UINT64* pqwFVF, 
           UINT64* pqwFVF2, DWORD* pdwNumBetas )
{
    DWORD dwNumFloats = 0;
    
    switch( dwRegister )
    {
    case D3DVSDE_POSITION:
        if( dwDataType != D3DVSDT_FLOAT3 )
        {
            DPFERR( "Position register must be FLOAT3 for"
                    "fixed-function pipeline" );
            return DDERR_GENERIC;
        }
        *pqwFVF |= D3DFVF_XYZ;
        break;
    case D3DVSDE_POSITION2:
        if( dwDataType != D3DVSDT_FLOAT3 )
        {
            DPFERR( "Position register must be FLOAT3 for"
                    "fixed-function pipeline" );
            return DDERR_GENERIC;
        }
        *pqwFVF |= D3DFVFP_POSITION2;
        break;
    case D3DVSDE_BLENDWEIGHT:
    {
        int n = 0;
        switch (dwDataType)
        {
        case D3DVSDT_FLOAT1:
            n = 1;
            break;
        case D3DVSDT_FLOAT2:
            n = 2;
            break;
        case D3DVSDT_FLOAT3:
            n = 3;
            break;
        case D3DVSDT_FLOAT4:
            n = 4;
            break;
        default:
            DPFERR( "Invalid data type set for vertex blends" );
            return DDERR_GENERIC;
        }
        // Update number of floats after position
        *pdwNumBetas = *pdwNumBetas + n;
        break;
    }
    case D3DVSDE_NORMAL:
        if( dwDataType != D3DVSDT_FLOAT3 )
        {
            DPFERR( "Normal register must be FLOAT3 for fixed-function"
                    "pipeline" );
            return DDERR_GENERIC;
        }
        *pqwFVF |= D3DFVF_NORMAL;
        break;
    case D3DVSDE_NORMAL2:
        if( dwDataType != D3DVSDT_FLOAT3 )
        {
            DPFERR( "Normal register must be FLOAT3 for fixed-function"
                    "pipeline" );
            return DDERR_GENERIC;
        }
        *pqwFVF |= D3DFVFP_NORMAL2;
        break;
    case D3DVSDE_PSIZE:
        if( dwDataType != D3DVSDT_FLOAT1 )
        {
            DPFERR( "Point size register must be FLOAT1 for fixed-function"
                    "pipeline" );
            return DDERR_GENERIC;

        }
        *pqwFVF |= D3DFVF_PSIZE;
        break;
    case D3DVSDE_DIFFUSE:
        if( dwDataType != D3DVSDT_D3DCOLOR )
        {
            DPFERR( "Diffuse register must be D3DCOLOR for"
                    "fixed-function pipeline" );
            return DDERR_GENERIC;

        }
        *pqwFVF |= D3DFVF_DIFFUSE;
        break;
    case D3DVSDE_SPECULAR:
        if( dwDataType != D3DVSDT_D3DCOLOR )
        {
            DPFERR( "Specular register must be PACKEDBYTE for"
                    "fixed-function pipeline" );
            return DDERR_GENERIC;

        }
        *pqwFVF |= D3DFVF_SPECULAR;
        break;
    case D3DVSDE_BLENDINDICES:
        if ( dwDataType != D3DVSDT_UBYTE4 )
        {
            DPFERR( "Blend Indicex register must be UBYTE4 for"
                    "fixed-function pipeline" );
            return DDERR_GENERIC;
        }
        *pqwFVF |= D3DFVFP_BLENDINDICES;
        break;
    case D3DVSDE_TEXCOORD0:
    case D3DVSDE_TEXCOORD1:
    case D3DVSDE_TEXCOORD2:
    case D3DVSDE_TEXCOORD3:
    case D3DVSDE_TEXCOORD4:
    case D3DVSDE_TEXCOORD5:
    case D3DVSDE_TEXCOORD6:
    case D3DVSDE_TEXCOORD7:
        {
            DWORD dwTextureIndex = dwRegister - D3DVSDE_TEXCOORD0;
            DWORD dwBit = 1 << dwTextureIndex;
            if( *pqwFVF2 & dwBit )
            {
                DPFERR( "Texture register is set second time" );
                return DDERR_GENERIC;

            }
            *pqwFVF2 |= dwBit;
            switch( dwDataType )
            {
            case D3DVSDT_FLOAT1:
                *pqwFVF |= D3DFVF_TEXCOORDSIZE1(dwTextureIndex);
                break;
            case D3DVSDT_FLOAT2:
                *pqwFVF |= D3DFVF_TEXCOORDSIZE2(dwTextureIndex);
                break;
            case D3DVSDT_FLOAT3:
                *pqwFVF |= D3DFVF_TEXCOORDSIZE3(dwTextureIndex);
                break;
            case D3DVSDT_FLOAT4:
                *pqwFVF |= D3DFVF_TEXCOORDSIZE4(dwTextureIndex);
                break;
            default:
                DPFERR( "Invalid data type set for texture register" );
                return DDERR_GENERIC;

                break;
            }
            break;
        }
    default:
        DPFERR( "Invalid register set for fixed-function pipeline" );
        return DDERR_GENERIC;

        break;
    }
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////
//
//          class RDVStreamDecl
//
/////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// RDVStreamDecl::Constructor
//-----------------------------------------------------------------------------
RDVStreamDecl::RDVStreamDecl()
{
    m_dwNumElements = 0;
    m_dwStride = 0;
    m_dwStreamIndex = 0;
    m_bIsStreamTess = FALSE;
}

//-----------------------------------------------------------------------------
// RDVStreamDecl::MakeVElementArray
//-----------------------------------------------------------------------------
HRESULT
RDVStreamDecl::MakeVElementArray( UINT64 qwFVF )
{
    HRESULT hr = S_OK;
    DWORD dwOffset = 0; // In Bytes

    m_dwStride = GetFVFVertexSize( qwFVF );
    m_dwStreamIndex = 0;
    m_dwNumElements = 0;

    dwOffset = 0 + ( qwFVF & D3DFVF_RESERVED0 ? 4 : 0 );

    //
    // Position and Blend Weights
    //
    switch( qwFVF & D3DFVF_POSITION_MASK )
    {
    case D3DFVF_XYZ:
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_POSITION,
                     D3DVSDT_FLOAT3, dwOffset );
        m_dwNumElements++;
        dwOffset += 4*3;
        break;
    case D3DFVF_XYZRHW:
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_POSITION,
                     D3DVSDT_FLOAT4, dwOffset );
        m_dwNumElements++;
        dwOffset += 4*4;
        break;
    case D3DFVF_XYZB1:
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_POSITION,
                     D3DVSDT_FLOAT3, dwOffset );
        m_dwNumElements++;
        dwOffset += 4*3;

        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_BLENDWEIGHT,
                     D3DVSDT_FLOAT1, dwOffset );
        dwOffset += 4*1;
        m_dwNumElements++;
        break;
    case D3DFVF_XYZB2:
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_POSITION,
                     D3DVSDT_FLOAT3, dwOffset );
        m_dwNumElements++;
        dwOffset += 4*3;

        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_BLENDWEIGHT,
                     D3DVSDT_FLOAT2, dwOffset );
        dwOffset += 4*2;
        m_dwNumElements++;
        break;
    case D3DFVF_XYZB3:
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_POSITION,
                     D3DVSDT_FLOAT3, dwOffset );
        m_dwNumElements++;
        dwOffset += 4*3;

        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_BLENDWEIGHT,
                     D3DVSDT_FLOAT3, dwOffset );
        dwOffset += 4*3;
        m_dwNumElements++;
        break;
    case D3DFVF_XYZB4:
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_POSITION,
                     D3DVSDT_FLOAT3, dwOffset );
        m_dwNumElements++;
        dwOffset += 4*3;

        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_BLENDWEIGHT,
                     D3DVSDT_FLOAT4, dwOffset );
        dwOffset += 4*4;
        m_dwNumElements++;
        break;
    case D3DFVF_XYZB5:
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_POSITION,
                     D3DVSDT_FLOAT3, dwOffset );
        m_dwNumElements++;
        dwOffset += 4*3;

        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_BLENDWEIGHT,
                     D3DVSDT_FLOAT4, dwOffset );
        dwOffset += 4*5; // Even though the velement is float4, skip 5 floats.
        m_dwNumElements++;
        break;
    default:
        DPFERR( "Unable to compute offsets, strange FVF bits set" );
        return E_FAIL;
    }


    //
    // Normal
    //
    if( qwFVF & D3DFVF_NORMAL )
    {
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_NORMAL,
                     D3DVSDT_FLOAT3, dwOffset );
        m_dwNumElements++;
        dwOffset += 4*3;
    }

    //
    // Point Size
    //
    if( qwFVF & D3DFVF_PSIZE )
    {
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_PSIZE,
                     D3DVSDT_FLOAT1, dwOffset );
        m_dwNumElements++;
        dwOffset += 4;
    }

    //
    // Diffuse Color
    //
    if( qwFVF & D3DFVF_DIFFUSE )
    {
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_DIFFUSE,
                     D3DVSDT_D3DCOLOR, dwOffset );
        m_dwNumElements++;
        dwOffset += 4;
    }

    //
    // Specular Color
    //
    if( qwFVF & D3DFVF_SPECULAR )
    {
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_SPECULAR,
                     D3DVSDT_D3DCOLOR, dwOffset );
        m_dwNumElements++;
        dwOffset += 4;
    }

    //
    // Texture coordinates
    //
    DWORD dwNumTexCoord = (DWORD)(FVF_TEXCOORD_NUMBER(qwFVF));
    DWORD dwTextureFormats = (DWORD)((qwFVF >> 16) & 0xffff);
    // Texture formats size  00   01   10   11
    static DWORD dwTextureSize[4] = {2*4, 3*4, 4*4, 4};
    static DWORD dwTextureType[4] = {D3DVSDT_FLOAT2, D3DVSDT_FLOAT3,
                                     D3DVSDT_FLOAT4, D3DVSDT_FLOAT1};

    for (DWORD i=0; i < dwNumTexCoord; i++)
    {
        SetVElement( m_Elements[m_dwNumElements], D3DVSDE_TEXCOORD0 + i,
                     dwTextureType[dwTextureFormats & 3], dwOffset );
        dwOffset += dwTextureSize[dwTextureFormats & 3];
        dwTextureFormats >>= 2;
        m_dwNumElements++;
    }

    return hr;
}

//-----------------------------------------------------------------------------
// RDVStreamDecl::Parse
//-----------------------------------------------------------------------------
HRESULT
RDVStreamDecl::Parse( DWORD ** ppToken,
                      BOOL bFixedFunction,
                      BOOL bStreamTess,
                      UINT64* pqwFVF,
                      UINT64* pqwFVF2,
                      DWORD*  pdwNumBetas)
{
    HRESULT hr = S_OK;

    m_bIsStreamTess = bStreamTess;

    DWORD* pToken = *ppToken;
    DWORD dwCurrentOffset = 0;
    while( TRUE )
    {
        DWORD dwToken = *pToken++;
        const DWORD dwTokenType = RDVSD_GETTOKENTYPE( dwToken );
        switch( dwTokenType )
        {
        case D3DVSD_TOKEN_NOP:  break;
        case D3DVSD_TOKEN_TESSELLATOR:
        {
            if( bStreamTess == FALSE )
            {
                DPFERR( "Unexpected Tesselator Token for this stream" );
                return E_FAIL;
            }

            if( m_dwNumElements >= RD_MAX_NUMELEMENTS )
            {
                DPFERR( "Tesselator Stream Token:" );
                DPFERR( "   Number of vertex elements generated"
                        " is greater than max supported"  );
                return DDERR_GENERIC;
            }
            RDVElement& Element = m_Elements[m_dwNumElements++];
            const DWORD dwDataType = RDVSD_GETDATATYPE(dwToken);
            const DWORD dwRegister = RDVSD_GETVERTEXREG(dwToken);
            const DWORD dwRegisterIn = RDVSD_GETVERTEXREGIN(dwToken);
            Element.m_dwToken = dwToken;
            Element.m_dwOffset = dwCurrentOffset;
            Element.m_dwRegister = dwRegister;
            Element.m_dwDataType = dwDataType;
            Element.m_dwStreamIndex = m_dwStreamIndex;
            Element.m_dwRegisterIn = dwRegisterIn;
            Element.m_bIsTessGen = TRUE;

            switch (dwDataType)
            {
            case D3DVSDT_FLOAT2:
                dwCurrentOffset += sizeof(float) * 2;
                Element.m_pfnCopy = Copy_FLOAT2;
                break;
            case D3DVSDT_FLOAT3:
                dwCurrentOffset += sizeof(float) * 3;
                Element.m_pfnCopy = Copy_FLOAT3;
                break;
            default:
                DPFERR( "Invalid element data type in a Tesselator token" );
                return DDERR_GENERIC;
            }
            // Compute input FVF for fixed-function pipeline
            if(  bFixedFunction  )
            {

                hr = UpdateFVF( dwRegister, dwDataType, pqwFVF, pqwFVF2, 
                                pdwNumBetas );
                if( FAILED( hr ) )
                {
                    DPFERR( "UpdateFVF failed" );
                    return DDERR_INVALIDPARAMS;
                }
            }
            else
            {
                if( dwRegister >= RD_MAX_NUMINPUTREG )
                {
                    DPFERR( "D3DVSD_TOKEN_STREAMDATA:"
                            "Invalid register number" );
                    return DDERR_GENERIC;
                }
            }
            break;
        }
        case D3DVSD_TOKEN_STREAMDATA:
        {
            switch( RDVSD_GETDATALOADTYPE( dwToken ) )
            {
            case RDVSD_LOADREGISTER:
            {
                if( m_dwNumElements >= RD_MAX_NUMELEMENTS )
                {
                    DPFERR( "D3DVSD_TOKEN_STREAMDATA:" );
                    DPFERR( "   Number of vertex elements in a stream"
                            "is greater than max supported"  );
                    return DDERR_GENERIC;
                }
                RDVElement& Element = m_Elements[m_dwNumElements++];
                const DWORD dwDataType = RDVSD_GETDATATYPE(dwToken);
                const DWORD dwRegister = RDVSD_GETVERTEXREG(dwToken);
                Element.m_dwToken = dwToken;
                Element.m_dwOffset = dwCurrentOffset;
                Element.m_dwRegister = dwRegister;
                Element.m_dwDataType = dwDataType;
                Element.m_dwStreamIndex = m_dwStreamIndex;

                switch( dwDataType )
                {
                case D3DVSDT_FLOAT1:
                    dwCurrentOffset += sizeof(float);
                    Element.m_pfnCopy = Copy_FLOAT1;
                    break;
                case D3DVSDT_FLOAT2:
                    dwCurrentOffset += sizeof(float) * 2;
                    Element.m_pfnCopy = Copy_FLOAT2;
                    break;
                case D3DVSDT_FLOAT3:
                    dwCurrentOffset += sizeof(float) * 3;
                    Element.m_pfnCopy = Copy_FLOAT3;
                    break;
                case D3DVSDT_FLOAT4:
                    dwCurrentOffset += sizeof(float) * 4;
                    Element.m_pfnCopy = Copy_FLOAT4;
                    break;
                case D3DVSDT_D3DCOLOR:
                    dwCurrentOffset += sizeof(DWORD);
                    Element.m_pfnCopy = Copy_D3DCOLOR;
                    break;
                case D3DVSDT_UBYTE4:
                    dwCurrentOffset += sizeof(DWORD);
                    Element.m_pfnCopy = Copy_UBYTE4;
                    break;
                case D3DVSDT_SHORT2:
                    dwCurrentOffset += sizeof(SHORT) * 2;
                    Element.m_pfnCopy = Copy_SHORT2;
                    break;
                case D3DVSDT_SHORT4:
                    dwCurrentOffset += sizeof(SHORT) * 4;
                    Element.m_pfnCopy = Copy_SHORT4;
                    break;
                default:
                    DPFERR( "D3DVSD_TOKEN_STREAMDATA:"
                            "Invalid element data type" );
                    return DDERR_GENERIC;
                }
                // Compute input FVF for fixed-function pipeline
                if(  bFixedFunction  )
                {

                    hr = UpdateFVF( dwRegister, dwDataType, pqwFVF, pqwFVF2,
                                    pdwNumBetas );
                    if( FAILED( hr ) )
                    {
                        DPFERR( "UpdateFVF failed" );
                        return DDERR_INVALIDPARAMS;
                    }
                }
                else
                {
                    if( dwRegister >= RD_MAX_NUMINPUTREG )
                    {
                        DPFERR( "D3DVSD_TOKEN_STREAMDATA:"
                                "Invalid register number" );
                        return DDERR_GENERIC;
                    }
                }
                break;
            }
            case RDVSD_SKIP:
            {
                const DWORD dwCount = RDVSD_GETSKIPCOUNT( dwToken );
                dwCurrentOffset += dwCount * sizeof(DWORD);
                break;
            }
            default:
                DPFERR( "Invalid data load type" );
                return DDERR_GENERIC;
            }
            break;
        }
        default:
        {
            *ppToken = pToken - 1;
            m_dwStride = dwCurrentOffset;
            return S_OK;
        }
        } // switch
    } // while

    return S_OK;
}


/////////////////////////////////////////////////////////////////////////
//
//          class RDVDeclaration
//
/////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// RDVDeclaration::Destructor
//-----------------------------------------------------------------------------
RDVDeclaration::~RDVDeclaration()
{
    RDVConstantData* pConst = m_pConstants;
    while( pConst )
    {
        RDVConstantData* pNext = 
            static_cast<RDVConstantData *>(pConst->m_pNext);
        delete pConst;
        pConst = pNext;
    }
}

//-----------------------------------------------------------------------------
// RDVDeclaration::MakeVElementArray
//-----------------------------------------------------------------------------
HRESULT
RDVDeclaration::MakeVElementArray( UINT64 qwFVF )
{
    HRESULT hr = S_OK;
    m_qwInputFVF = qwFVF;
    m_dwNumActiveStreams = 1;

    // Go through the FVF and make the elements
    RDVStreamDecl& Stream = m_StreamArray[0];

    hr = Stream.MakeVElementArray( qwFVF );
    if( FAILED( hr ) )
    {
        return hr;
    }

    m_dwNumElements = Stream.m_dwNumElements;
    memcpy( &m_VertexElements, &Stream.m_Elements,
            sizeof( RDVElement ) * m_dwNumElements );

    return hr;
}

//-----------------------------------------------------------------------------
// RDVDeclaration::Parse
//-----------------------------------------------------------------------------
HRESULT
RDVDeclaration::Parse( DWORD* pDecl, BOOL bFixedFunction )
{
    HRESULT hr = S_OK;
    UINT64 qwFVF  = 0;   // FVF for fixed-function pipeline
    UINT64 qwFVF2 = 0;   // Texture presence bits (8 bits)
    DWORD  dwNumBetas = 0; // The number of betas.
    DWORD   dwStreamPresent = 0;    // Bit is set if a stream is used
    DWORD* pToken = pDecl;
    BOOL    bStreamTess = FALSE;

    while( TRUE )
    {
        DWORD dwToken = *pToken++;
        const DWORD dwTokenType = RDVSD_GETTOKENTYPE(dwToken);
        switch( dwTokenType )
        {
        case D3DVSD_TOKEN_NOP:
            break;
        case D3DVSD_TOKEN_STREAM:
        {
            DWORD dwStream;
            if( RDVSD_ISSTREAMTESS(dwToken) )
            {
                if( RDVSD_GETSTREAMNUMBER(dwToken) )
                {
                    DPFERR( "No stream number should be specified for a"
                            " Tesselator stream" );
                    return E_FAIL;
                }
                dwStream = RDVSD_STREAMTESS;
                bStreamTess = TRUE;
            }
            else
            {
                dwStream = RDVSD_GETSTREAMNUMBER(dwToken);
                bStreamTess = FALSE;
            }

            if( dwStream > RDVSD_STREAMTESS )
            {
                DPFERR( "Stream number is too big" );
                return DDERR_INVALIDPARAMS;
            }

            // Has this stream already been declared ?
            if( dwStreamPresent & (1 << dwStream) )
            {
                DPFERR( "Stream already defined in this declaration" );
                return DDERR_INVALIDPARAMS;
            }

            // Mark the stream as seen
            dwStreamPresent |= 1 << dwStream;

            RDVStreamDecl& Stream = m_StreamArray[m_dwNumActiveStreams];
            Stream.m_dwStreamIndex = dwStream;
            hr = Stream.Parse(&pToken, bFixedFunction, bStreamTess,
                              &qwFVF, &qwFVF2, &dwNumBetas);
            if( FAILED( hr ) )
            {
                return hr;
            }

            //
            // Save the stride computed for the tesselator stream
            //
            if( bStreamTess )
            {
                m_dwStreamTessStride = Stream.m_dwStride;
            }

            m_dwNumActiveStreams++;
            break;
        }
        case D3DVSD_TOKEN_STREAMDATA:
        {
            DPFERR( "D3DVSD_TOKEN_STREAMDATA could only be used"
                    "after D3DVSD_TOKEN_STREAM" );
            return DDERR_GENERIC;
        }
        case D3DVSD_TOKEN_CONSTMEM:
        {
            RDVConstantData * cd = new RDVConstantData;
            if( cd == NULL )
            {
                return E_OUTOFMEMORY;
            }
            
            cd->m_dwCount = RDVSD_GETCONSTCOUNT(dwToken);
            cd->m_dwAddress = RDVSD_GETCONSTADDRESS(dwToken);

            if( cd->m_dwCount + cd->m_dwAddress > RD_MAX_NUMCONSTREG )
            {
                delete cd;
                DPFERR( "D3DVSD_TOKEN_CONSTMEM writes outside"
                        "constant memory" );
                return DDERR_GENERIC;
            }

            const DWORD dwSize = cd->m_dwCount << 2;    // number of DWORDs
            cd->m_pData = new DWORD[dwSize];
            if( cd->m_pData == NULL )
            {
                return E_OUTOFMEMORY;
            }
            
            memcpy( cd->m_pData, pToken, dwSize << 2 );
            if( m_pConstants == NULL )
                m_pConstants = cd;
            else
                m_pConstants->Append(cd);
            pToken += dwSize;
            break;
        }
        case D3DVSD_TOKEN_EXT:
        {
            // Skip extension info
            DWORD dwCount = RDVSD_GETEXTCOUNT(dwToken);
            pToken += dwCount;
            break;
        }
        case D3DVSD_TOKEN_END:
        {
            goto l_End;
        }
        default:
        {
            DPFERR( "Invalid declaration token: %10x", dwToken );
            return DDERR_INVALIDPARAMS;
        }
        }
    }

l_End:

    // Now accumulate all the vertex elements into the declaration
    DWORD dwCurrElement = 0;
    m_dwNumElements = 0;

    // Build a VElement List in the Declaration.
    for( DWORD i=0; i<m_dwNumActiveStreams; i++ )
    {
        RDVStreamDecl& Stream = m_StreamArray[i];
        for( DWORD j=0; j<Stream.m_dwNumElements; j++ )
        {
            m_VertexElements[dwCurrElement] = Stream.m_Elements[j];
            dwCurrElement++;
        }
        m_dwNumElements += Stream.m_dwNumElements;
    }

    // If any tesselator tokens were present, then translate the m_dwRegisterIn
    // in the the StreamIndex and Offset for the tesselator tokens.
    if( bStreamTess )
    {
        for( i=0; i<m_dwNumElements; i++ )
        {
            RDVElement& ve = m_VertexElements[i];
            if( ve.m_bIsTessGen )
            {
                for( DWORD j=0; j<m_dwNumElements; j++ )
                {
                    if( m_VertexElements[j].m_dwRegister == ve.m_dwRegisterIn )
                    {
                        ve.m_dwStreamIndexIn =
                            m_VertexElements[j].m_dwStreamIndex;
                        ve.m_dwOffsetIn = m_VertexElements[j].m_dwOffsetIn;
                        break;
                    }
                }
                if( j == m_dwNumElements )
                {
                    DPFERR( "Tesselator input register is not defined in the"
                            " declaration" );
                    return E_FAIL;
                }
            }
        }
    }

    // Validate input for the fixed-function pipeline
    if( bFixedFunction )
    {
        // Pull out the number of blend weights
        BOOL bIsTransformed = (qwFVF & D3DFVF_XYZRHW);
        if( bIsTransformed )
        {
            if( dwNumBetas != 0 )
            {
                
                DPFERR( "Cannot have blend weights along with "
                        "transformed position" );
                return E_FAIL;
            }
        }
        else if( (qwFVF & D3DFVF_XYZ) == 0 )
        {
            // Position must be set
            DPFERR( "Position register must be set" );
            return E_FAIL;
        }
        
        DWORD dwPosMask = bIsTransformed ? 0x2 : 0x1;
        if( dwNumBetas )
        {
            dwPosMask += (dwNumBetas + 1);
        }
        
        m_qwInputFVF |= (qwFVF | 
                         ((DWORD)(D3DFVF_POSITION_MASK) & (dwPosMask << 1)));

        // Compute number of texture coordinates
        DWORD nTexCoord = 0;
        DWORD dwTexturePresenceBits = qwFVF2 & 0xFF;
        while( dwTexturePresenceBits & 1 )
        {
            dwTexturePresenceBits >>= 1;
            nTexCoord++;
        }

        // There should be no gaps in texture coordinates
        if( dwTexturePresenceBits )
        {
            DPFERR( "Texture coordinates should have no gaps" );
            return E_FAIL;
        }

        m_qwInputFVF |= (nTexCoord << D3DFVF_TEXCOUNT_SHIFT);

    }
    return hr;
}
/////////////////////////////////////////////////////////////////////////
//
//          class RDVShader
//
/////////////////////////////////////////////////////////////////////////

RDVShader::RDVShader()
{
    m_pCode = NULL;
}

//-----------------------------------------------------------------------------
// RDVShader::Destructor
//-----------------------------------------------------------------------------
RDVShader::~RDVShader()
{
    delete m_pCode;
}

/////////////////////////////////////////////////////////////////////////
//
//          class RefDev
//
/////////////////////////////////////////////////////////////////////////

//-----------------------------------------------------------------------------
// RefDev::DrawDX8Prim
//-----------------------------------------------------------------------------
HRESULT
RefDev::DrawDX8Prim( LPD3DHAL_DP2DRAWPRIMITIVE pDP )
{
    HRESULT hr = S_OK;

    // Ignore D3DRS_PATCHSEGMENTS for non-triangle primitive types
    if( GetRSf()[D3DRS_PATCHSEGMENTS] > 1.f &&
        pDP->primType >= D3DPT_TRIANGLELIST)
    {
        // Save current data stream pointers and replace with
        // pointer to tessellation output
        hr = LinkTessellatorOutput();
        if(FAILED(hr))
        {
            return hr;
        }

        hr = ProcessTessPrimitive( pDP );

        // Restore back saved pointer
        UnlinkTessellatorOutput();

        return hr;
    }

    // If there is any tesselator output in this vertex-shader
    // then you cannot use DrawPrim. DrawRect/Tri is required.
    if( m_pCurrentVShader->m_Declaration.m_dwStreamTessStride != 0 )
    {
        DPFERR( "Cannot call DrawPrim when the current vertex shader has"
                " tesselator output." );
        return D3DERR_INVALIDCALL;
    }
    
    DWORD cVertices = GetVertexCount( pDP->primType, pDP->PrimitiveCount );

    if( RDVSD_ISLEGACY( m_CurrentVShaderHandle ) )
    {
        //
        // The legacy FVF style: The Zero'th Stream is implied
        //
        UINT64 qwFVF    = m_CurrentVShaderHandle;
        RDVStream& Stream = m_VStream[0];
        DWORD dwStride = Stream.m_dwStride;
        DWORD dwFVFSize = GetFVFVertexSize( qwFVF );

        if( Stream.m_pData == NULL || dwStride == 0 )
        {
            DPFERR( "Zero'th stream doesnt have valid VB set" );
            return DDERR_INVALIDPARAMS;
        }
        if( dwStride < dwFVFSize )
        {
            DPFERR( "The stride set for the vertex stream is less than"
                    " the FVF vertex size" );
            return E_FAIL;
        }

        if( FVF_TRANSFORMED(m_CurrentVShaderHandle) )
        {
            HR_RET( GrowTLVArray( cVertices ) );
            FvfToRDVertex( (Stream.m_pData + pDP->VStart * dwStride),
                           GetTLVArray(), qwFVF, dwStride, cVertices );
            if( GetRS()[D3DRENDERSTATE_CLIPPING] )
            {
                m_qwFVFOut = qwFVF;
                HR_RET( UpdateClipper() );
                HR_RET(m_Clipper.DrawOnePrimitive( GetTLVArray(),
                                                   0,
                                                   pDP->primType,
                                                   cVertices ));
            }
            else
            {
                HR_RET(DrawOnePrimitive( GetTLVArray(),
                                         0,
                                         pDP->primType,
                                         cVertices ));
            }

            return S_OK;
        }
    }

    if( m_pCurrentVShader->IsFixedFunction() )
    {
        //
        // With declaration for Fixed Function pipeline, DX8 style
        //

        HR_RET(ProcessPrimitive( pDP->primType, pDP->VStart,
                                 cVertices, 0, 0 ));

    }
    else
    {
        //
        // Pure Vertex Shader
        //

        HR_RET(ProcessPrimitiveVVM( pDP->primType, pDP->VStart,
                                    cVertices, 0, 0 ));
    }

    return hr;
}

//-----------------------------------------------------------------------------
// RefDev::DrawDX8Prim2
//-----------------------------------------------------------------------------
HRESULT
RefDev::DrawDX8Prim2( LPD3DHAL_DP2DRAWPRIMITIVE2 pDP )
{
    HRESULT hr = S_OK;
    DWORD cVertices = GetVertexCount( pDP->primType, pDP->PrimitiveCount );

    if( !RDVSD_ISLEGACY ( m_CurrentVShaderHandle ) ||
        !FVF_TRANSFORMED( m_CurrentVShaderHandle ) )
    {
        DPFERR( "DrawPrimitives2 should be called with transformed legacy vertices" );
        return E_FAIL;
    }
    //
    // The legacy FVF style: The Zero'th Stream is implied
    //
    UINT64 qwFVF    = m_CurrentVShaderHandle;
    RDVStream& Stream = m_VStream[0];
    DWORD dwStride = Stream.m_dwStride;
    DWORD dwFVFSize = GetFVFVertexSize( qwFVF );

    if( Stream.m_pData == NULL || dwStride == 0 )
    {
        DPFERR( "Zero'th stream doesnt have valid VB set" );
        return DDERR_INVALIDPARAMS;
    }
    if( dwStride < dwFVFSize )
    {
        DPFERR( "The stride set for the vertex stream is less than"
                " the FVF vertex size" );
        return E_FAIL;
    }

    HR_RET( GrowTLVArray( cVertices ) );
    FvfToRDVertex( (Stream.m_pData + pDP->FirstVertexOffset),
                   GetTLVArray(), qwFVF, dwStride, cVertices );

    HR_RET(DrawOnePrimitive( GetTLVArray(), 0, pDP->primType,
                               cVertices ));

    return S_OK;
}

//-----------------------------------------------------------------------------
// RefVP::DrawDX8IndexedPrim
//-----------------------------------------------------------------------------

HRESULT
RefDev::DrawDX8IndexedPrim(
    LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE pDIP )
{
    HRESULT hr = S_OK;

    if( GetRSf()[D3DRS_PATCHSEGMENTS] > 1.f )
    {
        // Save current data stream pointers and replace with
        // pointer to tessellation output
        hr = LinkTessellatorOutput();
        if(FAILED(hr))
        {
            return hr;
        }

        hr = ProcessTessIndexedPrimitive( pDIP );

        // Restore back saved pointer
        UnlinkTessellatorOutput();

        return hr;
    }

    // If there is any tesselator output in this vertex-shader
    // then you cannot use DrawPrim. DrawRect/Tri is required.
    if( m_pCurrentVShader->m_Declaration.m_dwStreamTessStride != 0 )
    {
        DPFERR( "Cannot call DrawIndexedPrim when the current vertex shader"
                " has tesselator output." );
        return D3DERR_INVALIDCALL;
    }
    
    DWORD cIndices = GetVertexCount( pDIP->primType, pDIP->PrimitiveCount );

    if( RDVSD_ISLEGACY( m_CurrentVShaderHandle ) )
    {
        //
        // The legacy FVF style: The Zero'th Stream is implied
        //
        UINT64 qwFVF    = m_CurrentVShaderHandle;
        RDVStream& Stream = m_VStream[0];
        DWORD dwStride = Stream.m_dwStride;
        DWORD dwFVFSize = GetFVFVertexSize( qwFVF );

        if( Stream.m_pData == NULL || dwStride == 0 )
        {
            DPFERR( "Zero'th stream doesnt have valid VB set" );
            return DDERR_INVALIDPARAMS;
        }
        if( dwStride < dwFVFSize )
        {
            DPFERR( "The stride set for the vertex stream is less than"
                    " the FVF vertex size" );
            return E_FAIL;
        }

        if( m_IndexStream.m_pData == NULL )
        {
            DPFERR( "Indices are not available" );
            return E_FAIL;
        }

        if( FVF_TRANSFORMED(m_CurrentVShaderHandle) )
        {
            DWORD cVertices = pDIP->NumVertices + pDIP->MinIndex;
            HR_RET( GrowTLVArray( cVertices ) );
            FvfToRDVertex( (Stream.m_pData + pDIP->BaseVertexIndex * dwStride),
                           GetTLVArray(), qwFVF, dwStride, cVertices );
            if( GetRS()[D3DRENDERSTATE_CLIPPING] )
            {
                m_qwFVFOut = qwFVF;
                HR_RET( UpdateClipper() );
                if( m_IndexStream.m_dwStride == 4 )
                {
                    HR_RET( m_Clipper.DrawOneIndexedPrimitive(
                        GetTLVArray(),
                        0,
                        (LPDWORD)m_IndexStream.m_pData,
                        pDIP->StartIndex,
                        cIndices,
                        pDIP->primType ));
                }
                else
                {
                    HR_RET( m_Clipper.DrawOneIndexedPrimitive(
                        GetTLVArray(),
                        0,
                        (LPWORD)m_IndexStream.m_pData,
                        pDIP->StartIndex,
                        cIndices,
                        pDIP->primType ));
                }
            }
            else
            {
                if( m_IndexStream.m_dwStride == 4 )
                {
                    HR_RET(DrawOneIndexedPrimitive(
                        GetTLVArray(),
                        0,
                        (LPDWORD)m_IndexStream.m_pData,
                        pDIP->StartIndex,
                        cIndices,
                        pDIP->primType ));
                }
                else
                {
                    HR_RET(DrawOneIndexedPrimitive(
                        GetTLVArray(),
                        0,
                        (LPWORD)m_IndexStream.m_pData,
                        pDIP->StartIndex,
                        cIndices,
                        pDIP->primType ));
                }
            }

            return S_OK;
        }
    }


    if( m_pCurrentVShader->IsFixedFunction() )
    {
        //
        // With declaration for Fixed Function pipeline, DX8 style
        //
        HR_RET(ProcessPrimitive( pDIP->primType,
                                 pDIP->BaseVertexIndex,
                                 pDIP->NumVertices + pDIP->MinIndex,
                                 pDIP->StartIndex,
                                 cIndices ));
    }
    else
    {
        //
        // Pure Vertex Shader
        //
        HR_RET(ProcessPrimitiveVVM( pDIP->primType,
                                    pDIP->BaseVertexIndex,
                                    pDIP->NumVertices + pDIP->MinIndex,
                                    pDIP->StartIndex,
                                    cIndices ));
    }

    return hr;
}

//-----------------------------------------------------------------------------
// RefVP::DrawDX8IndexedPrim2
//-----------------------------------------------------------------------------

HRESULT
RefDev::DrawDX8IndexedPrim2(
    LPD3DHAL_DP2DRAWINDEXEDPRIMITIVE2 pDIP )
{
    HRESULT hr = S_OK;
    DWORD cIndices = GetVertexCount( pDIP->primType, pDIP->PrimitiveCount );

    if( !RDVSD_ISLEGACY ( m_CurrentVShaderHandle ) ||
        !FVF_TRANSFORMED( m_CurrentVShaderHandle ) )
    {
        DPFERR( "DrawIndexedPrimitive2 should be called with transformed legacy vertices" );
        return E_FAIL;
    }

    //
    // The legacy FVF style: The Zero'th Stream is implied
    //
    UINT64 qwFVF    = m_CurrentVShaderHandle;
    RDVStream& Stream = m_VStream[0];
    DWORD dwStride = Stream.m_dwStride;
    DWORD dwFVFSize = GetFVFVertexSize( qwFVF );

    if( Stream.m_pData == NULL || dwStride == 0)
    {
        DPFERR( "Zero'th stream doesnt have valid VB set" );
        return DDERR_INVALIDPARAMS;
    }
    if( dwStride < dwFVFSize )
    {
        DPFERR( "The stride set for the vertex stream is less than"
                " the FVF vertex size" );
        return E_FAIL;
    }

    if( m_IndexStream.m_pData == NULL )
    {
        DPFERR( "Indices are not available" );
        return E_FAIL;
    }

    DWORD cVertices = pDIP->NumVertices;
    HR_RET( GrowTLVArray( cVertices ) );
    FvfToRDVertex( (Stream.m_pData + pDIP->BaseVertexOffset +
                    pDIP->MinIndex * dwStride),
                   GetTLVArray(),
                   qwFVF, dwStride,
                   cVertices );

    if( m_IndexStream.m_dwStride == 4 )
    {
        HR_RET(DrawOneIndexedPrimitive(
            GetTLVArray(),
            -(int)pDIP->MinIndex,
            (LPDWORD)( m_IndexStream.m_pData + pDIP->StartIndexOffset),
            0,
            cIndices,
            pDIP->primType ));
    }
    else
    {
        HR_RET(DrawOneIndexedPrimitive(
            GetTLVArray(),
            -(int)pDIP->MinIndex,
            (LPWORD)( m_IndexStream.m_pData + pDIP->StartIndexOffset),
            0,
            cIndices,
            pDIP->primType ));
    }
    return S_OK;
}

//-----------------------------------------------------------------------------
// RefVP::DrawDX8ClippedTriangleFan
//-----------------------------------------------------------------------------

HRESULT
RefDev::DrawDX8ClippedTriFan(
    LPD3DHAL_CLIPPEDTRIANGLEFAN pCTF )
{
    BOOL bWireframe =
        GetRS()[D3DRENDERSTATE_FILLMODE] == D3DFILL_WIREFRAME;

    HRESULT hr = S_OK;
    DWORD cVertices = GetVertexCount( D3DPT_TRIANGLEFAN,
                                      pCTF->PrimitiveCount );

    if( !RDVSD_ISLEGACY ( m_CurrentVShaderHandle ) ||
        !FVF_TRANSFORMED( m_CurrentVShaderHandle ) )
    {
        DPFERR( "DrawPrimitives2 should be called with transformed legacy"
                " vertices" );
        return E_FAIL;
    }
    //
    // The legacy FVF style: The Zero'th Stream is implied
    //
    UINT64 qwFVF    = m_CurrentVShaderHandle;
    RDVStream& Stream = m_VStream[0];
    DWORD dwStride = Stream.m_dwStride;
    DWORD dwFVFSize = GetFVFVertexSize( qwFVF );

    if( Stream.m_pData == NULL || dwStride == 0 )
    {
        DPFERR( "Zero'th stream doesnt have valid VB set" );
        return DDERR_INVALIDPARAMS;
    }
    if( dwStride < dwFVFSize )
    {
        DPFERR( "The stride set for the vertex stream is less than"
                " the FVF vertex size" );
        return E_FAIL;
    }

    HR_RET( GrowTLVArray( cVertices ) );
    FvfToRDVertex( (Stream.m_pData + pCTF->FirstVertexOffset),
                   GetTLVArray(), qwFVF, dwStride, cVertices );

    if( bWireframe )
    {
        HR_RET(DrawOneEdgeFlagTriangleFan( GetTLVArray(), cVertices,
                                             pCTF->dwEdgeFlags ));
    }
    else
    {
        HR_RET(DrawOnePrimitive( GetTLVArray(), 0, D3DPT_TRIANGLEFAN,
                                 cVertices ));
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\ref8\tnl\xform.cpp ===
#include "pch.cpp"
#pragma hdrstop


//---------------------------------------------------------------------
// This function uses Cramer's Rule to calculate the matrix inverse.
// See nt\private\windows\opengl\serever\soft\so_math.c
//
// Returns:
//    0 - if success
//   -1 - if input matrix is singular
//
int Inverse4x4(D3DMATRIX *src, D3DMATRIX *inverse)
{
    double x00, x01, x02;
    double x10, x11, x12;
    double x20, x21, x22;
    double rcp;
    double x30, x31, x32;
    double y01, y02, y03, y12, y13, y23;
    double z02, z03, z12, z13, z22, z23, z32, z33;

#define x03 x01
#define x13 x11
#define x23 x21
#define x33 x31
#define z00 x02
#define z10 x12
#define z20 x22
#define z30 x32
#define z01 x03
#define z11 x13
#define z21 x23
#define z31 x33

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all six 2x2 determinants of 1st two columns */
    y01 = x00*x11 - x10*x01;
    y02 = x00*x21 - x20*x01;
    y03 = x00*x31 - x30*x01;
    y12 = x10*x21 - x20*x11;
    y13 = x10*x31 - x30*x11;
    y23 = x20*x31 - x30*x21;

    /* read 2nd two columns of matrix into registers */
    x02 = src->_13;
    x03 = src->_14;
    x12 = src->_23;
    x13 = src->_24;
    x22 = src->_33;
    x23 = src->_34;
    x32 = src->_43;
    x33 = src->_44;

    /* compute all 3x3 cofactors for 2nd two columns */
    z33 = x02*y12 - x12*y02 + x22*y01;
    z23 = x12*y03 - x32*y01 - x02*y13;
    z13 = x02*y23 - x22*y03 + x32*y02;
    z03 = x22*y13 - x32*y12 - x12*y23;
    z32 = x13*y02 - x23*y01 - x03*y12;
    z22 = x03*y13 - x13*y03 + x33*y01;
    z12 = x23*y03 - x33*y02 - x03*y23;
    z02 = x13*y23 - x23*y13 + x33*y12;

    /* compute all six 2x2 determinants of 2nd two columns */
    y01 = x02*x13 - x12*x03;
    y02 = x02*x23 - x22*x03;
    y03 = x02*x33 - x32*x03;
    y12 = x12*x23 - x22*x13;
    y13 = x12*x33 - x32*x13;
    y23 = x22*x33 - x32*x23;

    /* read 1st two columns of matrix into registers */
    x00 = src->_11;
    x01 = src->_12;
    x10 = src->_21;
    x11 = src->_22;
    x20 = src->_31;
    x21 = src->_32;
    x30 = src->_41;
    x31 = src->_42;

    /* compute all 3x3 cofactors for 1st column */
    z30 = x11*y02 - x21*y01 - x01*y12;
    z20 = x01*y13 - x11*y03 + x31*y01;
    z10 = x21*y03 - x31*y02 - x01*y23;
    z00 = x11*y23 - x21*y13 + x31*y12;

    /* compute 4x4 determinant & its reciprocal */
    rcp = x30*z30 + x20*z20 + x10*z10 + x00*z00;
    if (rcp == (float)0)
    return -1;
    rcp = (float)1/rcp;

    /* compute all 3x3 cofactors for 2nd column */
    z31 = x00*y12 - x10*y02 + x20*y01;
    z21 = x10*y03 - x30*y01 - x00*y13;
    z11 = x00*y23 - x20*y03 + x30*y02;
    z01 = x20*y13 - x30*y12 - x10*y23;

    /* multiply all 3x3 cofactors by reciprocal */
    inverse->_11 = (float)(z00*rcp);
    inverse->_21 = (float)(z01*rcp);
    inverse->_12 = (float)(z10*rcp);
    inverse->_31 = (float)(z02*rcp);
    inverse->_13 = (float)(z20*rcp);
    inverse->_41 = (float)(z03*rcp);
    inverse->_14 = (float)(z30*rcp);
    inverse->_22 = (float)(z11*rcp);
    inverse->_32 = (float)(z12*rcp);
    inverse->_23 = (float)(z21*rcp);
    inverse->_42 = (float)(z13*rcp);
    inverse->_24 = (float)(z31*rcp);
    inverse->_33 = (float)(z22*rcp);
    inverse->_43 = (float)(z23*rcp);
    inverse->_34 = (float)(z32*rcp);
    inverse->_44 = (float)(z33*rcp);
    return 0;
}

//---------------------------------------------------------------------
#define MATRIX_PRODUCT(res, a, b)                                           \
res->_11 = a->_11*b->_11 + a->_12*b->_21 + a->_13*b->_31 + a->_14*b->_41;   \
res->_12 = a->_11*b->_12 + a->_12*b->_22 + a->_13*b->_32 + a->_14*b->_42;   \
res->_13 = a->_11*b->_13 + a->_12*b->_23 + a->_13*b->_33 + a->_14*b->_43;   \
res->_14 = a->_11*b->_14 + a->_12*b->_24 + a->_13*b->_34 + a->_14*b->_44;   \
                                                                            \
res->_21 = a->_21*b->_11 + a->_22*b->_21 + a->_23*b->_31 + a->_24*b->_41;   \
res->_22 = a->_21*b->_12 + a->_22*b->_22 + a->_23*b->_32 + a->_24*b->_42;   \
res->_23 = a->_21*b->_13 + a->_22*b->_23 + a->_23*b->_33 + a->_24*b->_43;   \
res->_24 = a->_21*b->_14 + a->_22*b->_24 + a->_23*b->_34 + a->_24*b->_44;   \
                                                                            \
res->_31 = a->_31*b->_11 + a->_32*b->_21 + a->_33*b->_31 + a->_34*b->_41;   \
res->_32 = a->_31*b->_12 + a->_32*b->_22 + a->_33*b->_32 + a->_34*b->_42;   \
res->_33 = a->_31*b->_13 + a->_32*b->_23 + a->_33*b->_33 + a->_34*b->_43;   \
res->_34 = a->_31*b->_14 + a->_32*b->_24 + a->_33*b->_34 + a->_34*b->_44;   \
                                                                            \
res->_41 = a->_41*b->_11 + a->_42*b->_21 + a->_43*b->_31 + a->_44*b->_41;   \
res->_42 = a->_41*b->_12 + a->_42*b->_22 + a->_43*b->_32 + a->_44*b->_42;   \
res->_43 = a->_41*b->_13 + a->_42*b->_23 + a->_43*b->_33 + a->_44*b->_43;   \
res->_44 = a->_41*b->_14 + a->_42*b->_24 + a->_43*b->_34 + a->_44*b->_44;
//---------------------------------------------------------------------
// result = a*b
// result is the same as a or b
//
void MatrixProduct2(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b)
{
    D3DMATRIX res;
    MATRIX_PRODUCT((&res), a, b);
    *(D3DMATRIX*)result = res;
}
//---------------------------------------------------------------------
// result = a*b.
// "result" pointer  could be equal to "a" or "b"
//
void MatrixProduct(D3DMATRIX *result, D3DMATRIX *a, D3DMATRIX *b)
{
    if (result == a || result == b)
    {
        MatrixProduct2(result, a, b);
        return;
    }
    MATRIX_PRODUCT(result, a, b);
}


///////////////////////////////////////////////////////////////////////////////
//
///////////////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------
// RefVP::UpdateXformData
//             Updates transform data used by ProcessVertices
//---------------------------------------------------------------------
HRESULT
RefVP::UpdateXformData()
{
    HRESULT hr = D3D_OK;
    RDTRANSFORMDATA& TData = m_TransformData;


    // Update Mproj*Mclip
    if( m_dwDirtyFlags &  RDPV_DIRTY_PROJXFM )
    {
        D3DMATRIX MShift;
        ZeroMemory (&MShift, sizeof(D3DMATRIX));
        MShift._11 = 0.5f;
        MShift._22 = 0.5f;
        MShift._41 = 0.5f;
        MShift._42 = 0.5f;
        MShift._44 = 1.0f;
        MShift._33 = 1.0f;

        MatrixProduct(&TData.m_PS, &m_xfmProj, &MShift);
    }

    // Update Mview*Mproj*Mclip
    if( m_dwDirtyFlags & (RDPV_DIRTY_VIEWXFM | RDPV_DIRTY_PROJXFM) )
    {
        MatrixProduct(&TData.m_VPS, &m_xfmView, &TData.m_PS);
        Inverse4x4( (D3DMATRIX *)&TData.m_VPS, (D3DMATRIX *)&TData.m_VPSInv );
    }

    for( DWORD i=0; i< RD_MAX_BLEND_WEIGHTS; i++)
    {
        MatrixProduct(&m_xfmCurrent[i], &m_xfmWorld[i], &TData.m_VPS);
    }

    // Compute xfmToEye (world*view) matrix (needed for lighting and fog)
    // if needed
    if (m_dwDirtyFlags & (RDPV_DIRTY_VIEWXFM  |
                          RDPV_DIRTY_WORLDXFM |
                          RDPV_DIRTY_WORLD1XFM |
                          RDPV_DIRTY_WORLD2XFM |
                          RDPV_DIRTY_WORLD3XFM ))
    {
        m_dwDirtyFlags |= RDPV_DIRTY_INVERSEWORLDVIEW;
    }
        
    if (m_dwTLState & (RDPV_DOLIGHTING | RDPV_DOFOG | RDPV_DOCOMPUTEPOINTSIZE |
                       RDPV_DOTEXGEN) &&
        (m_dwDirtyFlags & RDPV_DIRTY_INVERSEWORLDVIEW))
    {
        for( i=0; i< RD_MAX_BLEND_WEIGHTS; i++)
        {
            MatrixProduct(&m_xfmToEye[i], &m_xfmWorld[i], &m_xfmView);
            Inverse4x4((D3DMATRIX *)&m_xfmToEye[i],
                       (D3DMATRIX *)&m_xfmToEyeInv[i]);
            m_dwDirtyFlags |= RDPV_DIRTY_NEEDXFMLIGHT;
        }
        m_dwDirtyFlags &= ~RDPV_DIRTY_INVERSEWORLDVIEW;
    }

    // Clear the world processed flags
    memset( m_WorldProcessed, 0, sizeof( m_WorldProcessed ) );
    
    // Clear the dirty transform flags
    m_dwDirtyFlags &= ~RDPV_DIRTY_XFORM;
    return hr;
}

void
RefVP::UpdateWorld( DWORD i )
{
    RDTRANSFORMDATA& TData = m_TransformData;
    if( m_WorldProcessed[i] == TRUE ) return;
    MatrixProduct(&m_xfmCurrent[i], &m_xfmWorld[i], &TData.m_VPS);
    if (m_dwTLState & (RDPV_DOLIGHTING | RDPV_DOFOG | RDPV_DOCOMPUTEPOINTSIZE |
                       RDPV_DOTEXGEN))
    {
        MatrixProduct(&m_xfmToEye[i], &m_xfmWorld[i], &m_xfmView);
        Inverse4x4((D3DMATRIX *)&m_xfmToEye[i], 
                   (D3DMATRIX *)&m_xfmToEyeInv[i]);
    }
    m_WorldProcessed[i] = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\inc\allocator.h ===
template< class T>
class allocator;

template<>
class allocator< void>
{
public: // Types
    typedef void* pointer;
    typedef const void* const_pointer;
    typedef void value_type;

    template< class U>
    struct rebind
    {
        typedef allocator< U> other;
    };
};

template< class T>
class allocator
{
public: // Types
    typedef T value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;

    typedef T* pointer;
    typedef T const * const_pointer;
    typedef T& reference;
    typedef T const & const_reference;

    template< class U>
    struct rebind
    {
        typedef allocator< U> other;
    };

public: // Functions
    pointer address( reference r) const
    { return &r; }
    const_pointer address( const_reference r) const
    { return &r; }

    allocator() throw()
    { }
    template< class U>
    allocator( const allocator< U>& Other) throw()
    { }
    ~allocator() throw()
    { }

    template< class U>
    bool operator==( const allocator< U>& Other) throw()
    { return true; }
    template< class U>
    bool operator!=( const allocator< U>& Other) throw()
    { return false; }

    pointer allocate( size_type n, allocator<void>::const_pointer hint= 0)
        throw( bad_alloc)
    {
        void* pRet= NULL;
        try {
            if( n<= max_size())
                pRet= operator new ( n* sizeof(value_type));
        } catch( ... ) {
        }
        if( NULL== pRet)
            throw bad_alloc();
        return reinterpret_cast< pointer>( pRet);
    }
    void deallocate( pointer p, size_type n)
    { operator delete (static_cast<void*>(p)); }

    void construct( pointer p, const T& val)
    { new (p) T( val); }
    void destroy( pointer p)
    { p->~T(); }

    size_type max_size() const throw()
    {
        numeric_limits< size_type> Dummy;
        const size_type uiRet( Dummy.max()- 1); // -1 for realistic safety.
        return (0== sizeof( T)? uiRet: uiRet/ sizeof( T));
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\inc\block.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

////////////////////////////////////////////////////////////////////////////////
//
// block
//
// There should be a block or c_array type in STL, but MSVC might not have one,
// so here it is:
//
////////////////////////////////////////////////////////////////////////////////
template< class T, const size_t N>
struct block
{
    typedef T value_type;

    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;

    typedef pointer iterator;
    typedef const_pointer const_iterator;
    
    struct reverse_iterator
    {
        typedef random_access_iterator_tag iterator_category;
        typedef value_type value_type;
        typedef difference_type difference_type;
        typedef pointer pointer;
        typedef reference reference;

        pointer m_pCur;

        reverse_iterator() throw()
        { }
        reverse_iterator( const iterator& x) throw(): m_pCur( x)
        { }
        operator iterator() const throw()
        { return m_pCur; }
        reference operator*() const throw()
        { return *m_pCur; }
        pointer operator->() const throw()
        { return &(*()); }
        reverse_iterator& operator++() throw()
        {
            --m_pCur;
            return (*this);
        }
        reverse_iterator operator++(int)
        {
            reverse_iterator Tmp( m_pCur);
            ++(*this);
            return Tmp;
        }
        reverse_iterator& operator--()
        {
            ++m_pCur;
            return (*this);
        }
        reverse_iterator operator--(int)
        {
            reverse_iterator Tmp( m_pCur);
            --(*this);
            return Tmp;
        }
        bool operator==( const reverse_iterator& Other) const
        { return (m_pCur== Other.m_pCur); }
        bool operator!=( const reverse_iterator& Other) const
        { return (m_pCur!= Other.m_pCur); }
    };
    struct const_reverse_iterator
    {
        typedef random_access_iterator_tag iterator_category;
        typedef value_type value_type;
        typedef difference_type difference_type;
        typedef const_pointer pointer;
        typedef const_reference reference;

        const_pointer m_pCur;

        const_reverse_iterator() throw()
        { }
        const_reverse_iterator( const const_iterator& x) throw(): m_pCur( x)
        { }
        const_reverse_iterator( const reverse_iterator& x) throw(): m_pCur( x)
        { }
        operator const_iterator() const throw()
        { return m_pCur; }
        reference operator*() const throw()
        { return *m_pCur; }
        pointer operator->() const throw()
        { return &(*()); }
        const_reverse_iterator& operator++() throw()
        {
            --m_pCur;
            return (*this);
        }
        const_reverse_iterator operator++(int)
        {
            const_reverse_iterator Tmp( m_pCur);
            ++(*this);
            return Tmp;
        }
        const_reverse_iterator& operator--()
        {
            ++m_pCur;
            return (*this);
        }
        const_reverse_iterator operator--(int)
        {
            reverse_iterator Tmp( m_pCur);
            --(*this);
            return Tmp;
        }
        bool operator==( const const_reverse_iterator& Other) const
        { return (m_pCur== Other.m_pCur); }
        bool operator!=( const const_reverse_iterator& Other) const
        { return (m_pCur!= Other.m_pCur); }
    };

    iterator begin() throw() { return data; }
    iterator end() throw() { return data+ N; }
    const_iterator begin() const throw() { return data; }
    const_iterator end() const throw() { return data+ N; }

    reverse_iterator rbegin() throw() { return data+ N- 1; }
    reverse_iterator rend() throw() { return data- 1; }
    const_reverse_iterator rbegin() const throw() { return data+ N- 1; }
    const_reverse_iterator rend() const throw() { return data- 1; }

    reference operator[]( size_type n) throw() {
        return data[n];
    }
    const_reference operator[]( size_type n) const throw() {
        return data[n];
    }

    size_type size() const throw() { return N; }
    size_type max_size() const throw() { return N; }
    bool empty() const throw() { return (0==N); }

    void swap( block<T,N>& x) throw() {
        size_type n(N);
        if( n!= 0) do {
            --n;
            swap( data[n], x.data[n]);
        } while( n!= 0);
    }

    T data[N];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\inc\hash_map.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

template< class Key, class T, const size_t Buckets, class HashFun= hash<Key>,
    class EqualKey= equal_to<Key>,
    class Allocator= allocator<pair<Key const, T> > >
class static_hash_map:
    public static_hash_table<pair<const Key, T>, Buckets, Key, HashFun,
        select1st<pair<Key const, T> >, EqualKey, Allocator>
{
public: // Types
    typedef static_hash_map< Key, T, Buckets, HashFun, EqualKey, Allocator>
        map_type;
    typedef static_hash_table<pair<Key const, T>, Buckets, Key, HashFun,
        select1st<pair<Key const, T> >, EqualKey, Allocator> table_type;

    typedef typename table_type::key_type key_type;
    typedef typename Allocator::rebind< T>::other mapped_type;
    typedef typename table_type::value_type value_type;
    typedef typename table_type::hasher hasher;
    typedef typename table_type::key_equal key_equal;
    typedef typename table_type::pointer pointer;
    typedef typename table_type::const_pointer const_pointer;
    typedef typename table_type::reference reference;
    typedef typename table_type::const_reference const_reference;
    typedef typename table_type::size_type size_type;
    typedef typename table_type::difference_type difference_type;
    typedef typename table_type::iterator iterator;
    typedef typename table_type::const_iterator const_iterator;
    typedef typename table_type::reverse_iterator reverse_iterator;
    typedef typename table_type::const_reverse_iterator const_reverse_iterator;
    typedef typename table_type::allocator_type allocator_type;

public: // Functions.
    using table_type::begin;
    using table_type::end;
    using table_type::rbegin;
    using table_type::rend;
    using table_type::size;
    using table_type::max_size;
    using table_type::empty;
    using table_type::bucket_count;
    using table_type::resize;
    using table_type::hash_funct;
    using table_type::key_eq;
    explicit static_hash_map( const HashFun& h= HashFun(),
        const EqualKey& k= EqualKey(),
        const Allocator& A= Allocator())
        :table_type( h, k, select1st< value_type>(), A)
    { }
    template< class InputIterator>
    static_hash_map( InputIterator f, InputIterator l,
        const HashFun& h= HashFun(), const EqualKey& k= EqualKey(),
        const Allocator& A= Allocator())
        :table_type( h, k, select1st< value_type>(), A)
    { insert( f, l); }
    static_hash_map( const map_type& Other): table_type( Other)
    { }
    ~static_hash_map()
    { }
    using table_type::operator=;
    using table_type::get_allocator;
    using table_type::swap;
    pair< iterator, bool> insert( const value_type& x)
    { return table_type::insert_unique( x); }
    template< class InputIterator>
    void insert( InputIterator f, InputIterator l)
    { return table_type::insert_unique( f, l); }
    using table_type::erase;
    using table_type::find;
    using table_type::count;
    using table_type::equal_range;
    mapped_type& operator[]( const key_type& k)
    {
        iterator itEntry( insert( value_type( k, mapped_type())));
        return itEntry->second;
    }
};

// TODO: Global operators.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\inc\dx8sddifw.h ===
////////////////////////////////////////////////////////////////////////////////
//
// DX8SDDIFW
//
// Template library framework for creating a DX8 SDDI pluggable software
// rasterizer.
//
// Two #defines supported:
// DX8SDDIFW_NONAMESPACE: Don't use the DX8SDDIFW namespace. This can cause
//     symbols to bloat up if not needed.
// DX8SDDIFW_NOCATCHALL: Don't use catch( ... ) in certain places to create
//     a more stable driver. There are catch( ... ) clauses in certain areas
//     like DP2 command processing, so that each command succeeds or fails.
//     However, this can cause problems debugging, as Access Violations can
//     be masked and caught without causing the app to freeze or even see an
//     error.
//
////////////////////////////////////////////////////////////////////////////////
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#if !defined( DX8SDDIFW_NONAMESPACE)
namespace DX8SDDIFW
{
#endif // !defined( DX8SDDIFW_NONAMESPACE)

// Since MSVC doesn't have a block type currently, include one. This
// dependency can be removed if a similar type is provided in CRT STL.
#include "block.h"

// Utility functions for clamping a value:
template< class T> inline
void clamp_max( T& Var, const T& ClampMax)
{
    if( Var> ClampMax)
        Var= ClampMax;
}

template< class T> inline
void clamp_min( T& Var, const T& ClampMin)
{
    if( Var< ClampMin)
        Var= ClampMin;
}

template< class T> inline
void clamp( T& Var, const T& ClampMin, const T& ClampMax)
{
    assert( ClampMax>= ClampMin);
    if( Var> ClampMax)
        Var= ClampMax;
    else if( Var< ClampMin)
        Var= ClampMin;
}

////////////////////////////////////////////////////////////////////////////////
//
// CPushValue
//
// This class creates a safe run-time stack which pushes a value upon
// construction and pops the value upon destruction.
//
////////////////////////////////////////////////////////////////////////////////
template< class T>
struct CPushValue
{
protected: // Variables
    T& m_Val;
    T m_OldVal;

public: // Functions
    CPushValue( T& Val, const T& NewVal) : m_Val( Val)
    {
        m_OldVal= Val;
        Val= NewVal;
    }
    ~CPushValue() 
    {
        m_Val= m_OldVal;
    }
};

////////////////////////////////////////////////////////////////////////////////
//
// COSDetector
//
// This class can detect whether the host OS is the Win9X code base or the WinNT
// code base. The difference is important, because driver structures differ
// depending on which OS the rasterizer runs on. We don't want to build 2 lib
// versions, thus requiring the app to link with both.
//
////////////////////////////////////////////////////////////////////////////////
class COSDetector
{
public: // Types
    enum EOS
    {
        Unknown,
        Win9X,
        WinNT
    };

protected: // Variables
    const EOS m_eOS;

protected: // Functions
    static EOS DetermineOS()
    {
        OSVERSIONINFO osvi;
        ZeroMemory( &osvi, sizeof( osvi));
        osvi.dwOSVersionInfoSize= sizeof( osvi);
        if( !GetVersionEx( &osvi))
        {
            const bool Unsupported_OS_probably_Win31( false);
            assert( Unsupported_OS_probably_Win31);
            return EOS::Unknown;
        }
        else if( VER_PLATFORM_WIN32_WINDOWS== osvi.dwPlatformId)
            return EOS::Win9X;
        else if( VER_PLATFORM_WIN32_NT== osvi.dwPlatformId)
            return EOS::WinNT;
        else
        {
            const bool Unsupported_OS( false);
            assert( Unsupported_OS);
            return EOS::Unknown;
        }
    }

public: // Functions
    COSDetector():
        m_eOS( DetermineOS())
    { }
    ~COSDetector()
    { }
    EOS GetOS() const
    { return m_eOS; }
};
extern COSDetector g_OSDetector;

////////////////////////////////////////////////////////////////////////////////
//
// DDRAWI_XXX redefinitions
//
// Some DDRAWI_XXX structures differ depending on whether the binary is being
// compiled for Win9X or WinNT. We'll eliminate this difference, but to do so
// both OS structures need to be seperately defined. The structure which causes
// this is DDRAWI_DDRAWSURFACE_MORE. But for safety, more redefinition is done,
// to try to make developers aware of what's going on. 
//
////////////////////////////////////////////////////////////////////////////////

class PORTABLE_DDRAWSURFACE_LCL;
struct PORTABLE_ATTACHLIST
{
    DWORD                      dwFlags;
    PORTABLE_ATTACHLIST*       lpLink;
    PORTABLE_DDRAWSURFACE_LCL* lpAttached;  // attached surface local obj
    DDRAWI_DDRAWSURFACE_INT*   lpIAttached; // attached surface interface
};

class PORTABLE_DDRAWSURFACE_MORE;
class PORTABLE_DDRAWSURFACE_LCL
{
private:
    PORTABLE_DDRAWSURFACE_MORE*   m_lpSurfMore;
    LPDDRAWI_DDRAWSURFACE_GBL     m_lpGbl;
    ULONG_PTR                     m_hDDSurface;
    PORTABLE_ATTACHLIST*          m_lpAttachList;
    PORTABLE_ATTACHLIST*          m_lpAttachListFrom;
    DWORD                         m_dwLocalRefCnt;
    DWORD                         m_dwProcessId;
    DWORD                         m_dwFlags;
    DDSCAPS                       m_ddsCaps;
    union {
        LPDDRAWI_DDRAWPALETTE_INT m_lpDDPalette;
        LPDDRAWI_DDRAWPALETTE_INT m_lp16DDPalette;
    };
    union {
        LPDDRAWI_DDRAWCLIPPER_LCL m_lpDDClipper;
        LPDDRAWI_DDRAWCLIPPER_INT m_lp16DDClipper;
    };
    DWORD                         m_dwModeCreatedIn;
    DWORD                         m_dwBackBufferCount;
    DDCOLORKEY                    m_ddckCKDestBlt;
    DDCOLORKEY                    m_ddckCKSrcBlt;
    ULONG_PTR                     m_hDC;
    ULONG_PTR                     m_dwReserved1;
    DDCOLORKEY                    m_ddckCKSrcOverlay;
    DDCOLORKEY                    m_ddckCKDestOverlay;
    LPDDRAWI_DDRAWSURFACE_INT     m_lpSurfaceOverlaying;
    DBLNODE                       m_dbnOverlayNode;
    RECT                          m_rcOverlaySrc;
    RECT                          m_rcOverlayDest;
    DWORD                         m_dwClrXparent;
    DWORD                         m_dwAlpha;
    LONG                          m_lOverlayX;
    LONG                          m_lOverlayY;

public:
    PORTABLE_DDRAWSURFACE_MORE*& lpSurfMore()
    { return m_lpSurfMore; }
    LPDDRAWI_DDRAWSURFACE_GBL&   lpGbl()
    { return m_lpGbl; }
    ULONG_PTR&                   hDDSurface()
    { return m_hDDSurface; }
    PORTABLE_ATTACHLIST*&        lpAttachList()
    { return m_lpAttachList; }
    PORTABLE_ATTACHLIST*&        lpAttachListFrom()
    { return m_lpAttachListFrom; }
    DWORD&                       dwLocalRefCnt()
    { return m_dwLocalRefCnt; }
    DWORD&                       dwProcessId()
    { return m_dwProcessId; }
    DWORD&                       dwFlags()
    { return m_dwFlags; }
    DDSCAPS&                     ddsCaps()
    { return m_ddsCaps; }
    LPDDRAWI_DDRAWPALETTE_INT&   lpDDPalette()
    { return m_lpDDPalette; }
    LPDDRAWI_DDRAWPALETTE_INT&   lp16DDPalette()
    { return m_lp16DDPalette; }
    LPDDRAWI_DDRAWCLIPPER_LCL&   lpDDClipper()
    { return m_lpDDClipper; }
    LPDDRAWI_DDRAWCLIPPER_INT&   lp16DDClipper()
    { return m_lp16DDClipper; }
    DWORD&                       dwModeCreatedIn()
    { return m_dwModeCreatedIn; }
    DWORD&                       dwBackBufferCount()
    { return m_dwBackBufferCount; }
    DDCOLORKEY&                  ddckCKDestBlt()
    { return m_ddckCKDestBlt; }
    DDCOLORKEY&                  ddckCKSrcBlt()
    { return m_ddckCKSrcBlt; }
    ULONG_PTR&                   hDC()
    { return m_hDC; }
    ULONG_PTR&                   dwReserved1()
    { return m_dwReserved1; }
    DDCOLORKEY&                  ddckCKSrcOverlay()
    { return m_ddckCKSrcOverlay; }
    DDCOLORKEY&                  ddckCKDestOverlay()
    { return m_ddckCKDestOverlay; }
    LPDDRAWI_DDRAWSURFACE_INT&   lpSurfaceOverlaying()
    { return m_lpSurfaceOverlaying; }
    DBLNODE&                     dbnOverlayNode()
    { return m_dbnOverlayNode; }
    RECT&                        rcOverlaySrc()
    { return m_rcOverlaySrc; }
    RECT&                        rcOverlayDest()
    { return m_rcOverlayDest; }
    DWORD&                       dwClrXparent()
    { return m_dwClrXparent; }
    DWORD&                       dwAlpha()
    { return m_dwAlpha; }
    LONG&                        lOverlayX()
    { return m_lOverlayX; }
    LONG&                        lOverlayY()
    { return m_lOverlayY; }
};

class PORTABLE_DDRAWSURFACE_MORE
{
public:
    struct DDRAWI_DDRAWSURFACE_MORE_WIN9X
    {
        DWORD                       dwSize;
        IUNKNOWN_LIST FAR *         lpIUnknowns;
        LPDDRAWI_DIRECTDRAW_LCL     lpDD_lcl;
        DWORD                       dwPageLockCount;
        DWORD                       dwBytesAllocated;
        LPDDRAWI_DIRECTDRAW_INT     lpDD_int;
        DWORD                       dwMipMapCount;
        LPDDRAWI_DDRAWCLIPPER_INT   lpDDIClipper;
        LPHEAPALIASINFO             lpHeapAliasInfo;
        DWORD                       dwOverlayFlags;
        LPVOID                      rgjunc;
        LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;
        LPDDOVERLAYFX               lpddOverlayFX;
        DDSCAPSEX                   ddsCapsEx;
        DWORD                       dwTextureStage;
        LPVOID                      lpDDRAWReserved;
        LPVOID                      lpDDRAWReserved2;
        LPVOID                      lpDDrawReserved3;
        DWORD                       dwDDrawReserved4;
        LPVOID                      lpDDrawReserved5;
        LPDWORD                     lpGammaRamp;
        LPDWORD                     lpOriginalGammaRamp;
        LPVOID                      lpDDrawReserved6;
        DWORD                       dwSurfaceHandle;
        DWORD                       qwDDrawReserved8[2];
        LPVOID                      lpDDrawReserved9;
        DWORD                       cSurfaces;
        LPDDSURFACEDESC2            pCreatedDDSurfaceDesc2;
        PORTABLE_DDRAWSURFACE_LCL** slist;
        DWORD                       dwFVF;
        LPVOID                      lpVB;
    };
    struct DDRAWI_DDRAWSURFACE_MORE_WINNT
    {
        DWORD                       dwSize;
        IUNKNOWN_LIST FAR *         lpIUnknowns;
        LPDDRAWI_DIRECTDRAW_LCL     lpDD_lcl;
        DWORD                       dwPageLockCount;
        DWORD                       dwBytesAllocated;
        LPDDRAWI_DIRECTDRAW_INT     lpDD_int;
        DWORD                       dwMipMapCount;
        LPDDRAWI_DDRAWCLIPPER_INT   lpDDIClipper;
        LPHEAPALIASINFO             lpHeapAliasInfo;
        DWORD                       dwOverlayFlags;
        LPVOID                      rgjunc;
        LPDDRAWI_DDVIDEOPORT_LCL    lpVideoPort;
        LPDDOVERLAYFX               lpddOverlayFX;
        DDSCAPSEX                   ddsCapsEx;
        DWORD                       dwTextureStage;
        LPVOID                      lpDDRAWReserved;
        LPVOID                      lpDDRAWReserved2;
        LPVOID                      lpDDrawReserved3;
        DWORD                       dwDDrawReserved4;
        LPVOID                      lpDDrawReserved5;
        LPDWORD                     lpGammaRamp;
        LPDWORD                     lpOriginalGammaRamp;
        LPVOID                      lpDDrawReserved6;
        DISPLAYMODEINFO             dmiDDrawReserved7;
        DWORD                       dwSurfaceHandle;
        DWORD                       qwDDrawReserved8[2];
        LPVOID                      lpDDrawReserved9;
        DWORD                       cSurfaces;
        LPDDSURFACEDESC2            pCreatedDDSurfaceDesc2;
        PORTABLE_DDRAWSURFACE_LCL** slist;
        DWORD                       dwFVF;
        LPVOID                      lpVB;
    };

private:
    union {
        DDRAWI_DDRAWSURFACE_MORE_WIN9X m_Win9X;
        DDRAWI_DDRAWSURFACE_MORE_WINNT m_WinNT;
    };

public:
    DWORD&                       dwSize()
    { return m_Win9X.dwSize; }
    IUNKNOWN_LIST FAR *&         lpIUnknowns()
    { return m_Win9X.lpIUnknowns; }
    LPDDRAWI_DIRECTDRAW_LCL&     lpDD_lcl()
    { return m_Win9X.lpDD_lcl; }
    DWORD&                       dwPageLockCount()
    { return m_Win9X.dwPageLockCount; }
    DWORD&                       dwBytesAllocated()
    { return m_Win9X.dwBytesAllocated; }
    LPDDRAWI_DIRECTDRAW_INT&     lpDD_int()
    { return m_Win9X.lpDD_int; }
    DWORD&                       dwMipMapCount()
    { return m_Win9X.dwMipMapCount; }
    LPDDRAWI_DDRAWCLIPPER_INT&   lpDDIClipper()
    { return m_Win9X.lpDDIClipper; }
    LPHEAPALIASINFO&             lpHeapAliasInfo()
    { return m_Win9X.lpHeapAliasInfo; }
    DWORD&                       dwOverlayFlags()
    { return m_Win9X.dwOverlayFlags; }
    LPVOID&                      rgjunc()
    { return m_Win9X.rgjunc; }
    LPDDRAWI_DDVIDEOPORT_LCL&    lpVideoPort()
    { return m_Win9X.lpVideoPort; }
    LPDDOVERLAYFX&               lpddOverlayFX()
    { return m_Win9X.lpddOverlayFX; }
    DDSCAPSEX&                   ddsCapsEx()
    { return m_Win9X.ddsCapsEx; }
    DWORD&                       dwTextureStage()
    { return m_Win9X.dwTextureStage; }
    LPVOID&                      lpDDRAWReserved()
    { return m_Win9X.lpDDRAWReserved; }
    LPVOID&                      lpDDRAWReserved2()
    { return m_Win9X.lpDDRAWReserved2; }
    LPVOID&                      lpDDrawReserved3()
    { return m_Win9X.lpDDrawReserved3; }
    DWORD&                       dwDDrawReserved4()
    { return m_Win9X.dwDDrawReserved4; }
    LPVOID&                      lpDDrawReserved5()
    { return m_Win9X.lpDDrawReserved5; }
    LPDWORD&                     lpGammaRamp()
    { return m_Win9X.lpGammaRamp; }
    LPDWORD&                     lpOriginalGammaRamp()
    { return m_Win9X.lpOriginalGammaRamp; }
    LPVOID&                      lpDDrawReserved6()
    { return m_Win9X.lpDDrawReserved6; }
    DWORD&                       dwSurfaceHandle()
    { switch( g_OSDetector.GetOS()) {
        case( COSDetector::Win9X): return m_Win9X.dwSurfaceHandle;
        case( COSDetector::WinNT): return m_WinNT.dwSurfaceHandle;
        default: assert( 2!= 2); return m_WinNT.dwSurfaceHandle;
    } }
    DWORD&                       qwDDrawReserved8_0_()
    { switch( g_OSDetector.GetOS()) {
        case( COSDetector::Win9X): return m_Win9X.qwDDrawReserved8[0];
        case( COSDetector::WinNT): return m_WinNT.qwDDrawReserved8[0];
        default: assert( 2!= 2); return m_WinNT.qwDDrawReserved8[0];
    } }
    DWORD&                       qwDDrawReserved8_1_()
    { switch( g_OSDetector.GetOS()) {
        case( COSDetector::Win9X): return m_Win9X.qwDDrawReserved8[1];
        case( COSDetector::WinNT): return m_WinNT.qwDDrawReserved8[1];
        default: assert( 2!= 2); return m_WinNT.qwDDrawReserved8[1];
    } }
    LPVOID&                      lpDDrawReserved9()
    { switch( g_OSDetector.GetOS()) {
        case( COSDetector::Win9X): return m_Win9X.lpDDrawReserved9;
        case( COSDetector::WinNT): return m_WinNT.lpDDrawReserved9;
        default: assert( 2!= 2); return m_WinNT.lpDDrawReserved9;
    } }
    DWORD&                       cSurfaces()
    { switch( g_OSDetector.GetOS()) {
        case( COSDetector::Win9X): return m_Win9X.cSurfaces;
        case( COSDetector::WinNT): return m_WinNT.cSurfaces;
        default: assert( 2!= 2); return m_WinNT.cSurfaces;
    } }
    LPDDSURFACEDESC2&            pCreatedDDSurfaceDesc2()
    { switch( g_OSDetector.GetOS()) {
        case( COSDetector::Win9X): return m_Win9X.pCreatedDDSurfaceDesc2;
        case( COSDetector::WinNT): return m_WinNT.pCreatedDDSurfaceDesc2;
        default: assert( 2!= 2); return m_WinNT.pCreatedDDSurfaceDesc2;
    } }
    PORTABLE_DDRAWSURFACE_LCL**& slist()
    { switch( g_OSDetector.GetOS()) {
        case( COSDetector::Win9X): return m_Win9X.slist;
        case( COSDetector::WinNT): return m_WinNT.slist;
        default: assert( 2!= 2); return m_WinNT.slist;
    } }
    DWORD&                       dwFVF()
    { switch( g_OSDetector.GetOS()) {
        case( COSDetector::Win9X): return m_Win9X.dwFVF;
        case( COSDetector::WinNT): return m_WinNT.dwFVF;
        default: assert( 2!= 2); return m_WinNT.dwFVF;
    } }
    LPVOID&                      lpVB()
    { switch( g_OSDetector.GetOS()) {
        case( COSDetector::Win9X): return m_Win9X.lpVB;
        case( COSDetector::WinNT): return m_WinNT.lpVB;
        default: assert( 2!= 2); return m_WinNT.lpVB;
    } }
};

class PORTABLE_CONTEXTCREATEDATA
{
private:
    union {
        LPDDRAWI_DIRECTDRAW_GBL    m_lpDDGbl;
        LPDDRAWI_DIRECTDRAW_LCL    m_lpDDLcl;
    };
    union {
        LPDIRECTDRAWSURFACE        m_lpDDS;
        PORTABLE_DDRAWSURFACE_LCL* m_lpDDSLcl;
    };
    union {
        LPDIRECTDRAWSURFACE        m_lpDDSZ;
        PORTABLE_DDRAWSURFACE_LCL* m_lpDDSZLcl;
    };
    union {
        DWORD                      m_dwPID;
        ULONG_PTR                  m_dwrstates;
    };
    ULONG_PTR                      m_dwhContext;
    HRESULT                        m_ddrval;

public:
    LPDDRAWI_DIRECTDRAW_GBL&        lpDDGbl()
    { return m_lpDDGbl; }
    LPDDRAWI_DIRECTDRAW_LCL&        lpDDLcl()
    { return m_lpDDLcl; }
    LPDIRECTDRAWSURFACE&            lpDDS()
    { return m_lpDDS; }
    PORTABLE_DDRAWSURFACE_LCL*&     lpDDSLcl()
    { return m_lpDDSLcl; }
    LPDIRECTDRAWSURFACE&            lpDDSZ()
    { return m_lpDDSZ; }
    PORTABLE_DDRAWSURFACE_LCL*&     lpDDSZLcl()
    { return m_lpDDSZLcl; }
    DWORD&                          dwPID()
    { return m_dwPID; }
    ULONG_PTR&                      dwrstates()
    { return m_dwrstates; }
    ULONG_PTR&                      dwhContext()
    { return m_dwhContext; }
    HRESULT&                        ddrval()
    { return m_ddrval; }
};

class PORTABLE_SETRENDERTARGETDATA
{
private:
    ULONG_PTR                      m_dwhContext;
    union {
        LPDIRECTDRAWSURFACE        m_lpDDS;
        PORTABLE_DDRAWSURFACE_LCL* m_lpDDSLcl;
    };
    union {
        LPDIRECTDRAWSURFACE        m_lpDDSZ;
        PORTABLE_DDRAWSURFACE_LCL* m_lpDDSZLcl;
    };
    HRESULT                        m_ddrval;

public:
    ULONG_PTR&                      dwhContext()
    { return m_dwhContext; }
    LPDIRECTDRAWSURFACE&            lpDDS()
    { return m_lpDDS; }
    PORTABLE_DDRAWSURFACE_LCL*&     lpDDSLcl()
    { return m_lpDDSLcl; }
    LPDIRECTDRAWSURFACE&            lpDDSZ()
    { return m_lpDDSZ; }
    PORTABLE_DDRAWSURFACE_LCL*&     lpDDSZLcl()
    { return m_lpDDSZLcl; }
    HRESULT&                        ddrval()
    { return m_ddrval; }
};

class PORTABLE_DRAWPRIMITIVES2DATA
{
private:
    ULONG_PTR                      m_dwhContext;
    DWORD                          m_dwFlags;
    DWORD                          m_dwVertexType;
    PORTABLE_DDRAWSURFACE_LCL*     m_lpDDCommands;
    DWORD                          m_dwCommandOffset;
    DWORD                          m_dwCommandLength;
    union {
        PORTABLE_DDRAWSURFACE_LCL* m_lpDDVertex;
        LPVOID                     m_lpVertices;
    };
    DWORD                          m_dwVertexOffset;
    DWORD                          m_dwVertexLength;
    DWORD                          m_dwReqVertexBufSize;
    DWORD                          m_dwReqCommandBufSize;
    LPDWORD                        m_lpdwRStates;
    union {
        DWORD                      m_dwVertexSize;
        HRESULT                    m_ddrval;
    };
    DWORD                          m_dwErrorOffset;

public:
    ULONG_PTR&                      dwhContext()
    { return m_dwhContext; }
    DWORD&                          dwFlags()
    { return m_dwFlags; }
    DWORD&                          dwVertexType()
    { return m_dwVertexType; }
    PORTABLE_DDRAWSURFACE_LCL*&     lpDDCommands()
    { return m_lpDDCommands; }
    DWORD&                          dwCommandOffset()
    { return m_dwCommandOffset; }
    DWORD&                          dwCommandLength()
    { return m_dwCommandLength; }
    PORTABLE_DDRAWSURFACE_LCL*&     lpDDVertex()
    { return m_lpDDVertex; }
    LPVOID&                         lpVertices()
    { return m_lpVertices; }
    DWORD&                          dwVertexOffset()
    { return m_dwVertexOffset; }
    DWORD&                          dwVertexLength()
    { return m_dwVertexLength; }
    DWORD&                          dwReqVertexBufSize()
    { return m_dwReqVertexBufSize; }
    DWORD&                          dwReqCommandBufSize()
    { return m_dwReqCommandBufSize; }    
    LPDWORD&                        lpdwRStates()
    { return m_lpdwRStates; }
    DWORD&                          dwVertexSize()
    { return m_dwVertexSize; }
    HRESULT&                        ddrval()
    { return m_ddrval; }
    DWORD&                          dwErrorOffset()
    { return m_dwErrorOffset; }
};

class PORTABLE_CREATESURFACEEXDATA
{
private:
    DWORD                       m_dwFlags;
    LPDDRAWI_DIRECTDRAW_LCL     m_lpDDLcl;
    PORTABLE_DDRAWSURFACE_LCL*  m_lpDDSLcl;
    HRESULT                     m_ddRVal;

public:
    DWORD&                       dwFlags()
    { return m_dwFlags; }
    LPDDRAWI_DIRECTDRAW_LCL&     lpDDLcl()
    { return m_lpDDLcl; }
    PORTABLE_DDRAWSURFACE_LCL*&  lpDDSLcl()
    { return m_lpDDSLcl; }
    HRESULT&                     ddRVal()
    { return m_ddRVal; }
};

class PORTABLE_CREATESURFACEDATA
{
private:
    LPDDRAWI_DIRECTDRAW_GBL     m_lpDD;
    LPDDSURFACEDESC             m_lpDDSurfaceDesc;
    PORTABLE_DDRAWSURFACE_LCL** m_lplpSList;
    DWORD                       m_dwSCnt;
    HRESULT                     m_ddRVal;
    LPDDHAL_CREATESURFACE       m_CreateSurface;

public:
    LPDDRAWI_DIRECTDRAW_GBL&     lpDD()
    { return m_lpDD; }
    LPDDSURFACEDESC&             lpDDSurfaceDesc()
    { return m_lpDDSurfaceDesc; }
    PORTABLE_DDRAWSURFACE_LCL**& lplpSList()
    { return m_lplpSList; }
    DWORD&                       dwSCnt()
    { return m_dwSCnt; }
    HRESULT&                     ddRVal()
    { return m_ddRVal; }
    LPDDHAL_CREATESURFACE&       CreateSurface()
    { return m_CreateSurface; }
};

class PORTABLE_DESTROYSURFACEDATA
{
private:
    LPDDRAWI_DIRECTDRAW_GBL      m_lpDD;
    PORTABLE_DDRAWSURFACE_LCL*   m_lpDDSurface;
    HRESULT                      m_ddRVal;
    LPDDHALSURFCB_DESTROYSURFACE m_DestroySurface;

public:
    LPDDRAWI_DIRECTDRAW_GBL&      lpDD()
    { return m_lpDD; }
    PORTABLE_DDRAWSURFACE_LCL*&   lpDDSurface()
    { return m_lpDDSurface; }
    HRESULT&                      ddRVal()
    { return m_ddRVal; }
    LPDDHALSURFCB_DESTROYSURFACE& DestroySurface()
    { return m_DestroySurface; }
};

class PORTABLE_LOCKDATA
{
private:
    LPDDRAWI_DIRECTDRAW_GBL    m_lpDD;
    PORTABLE_DDRAWSURFACE_LCL* m_lpDDSurface;
    DWORD                      m_bHasRect;
    RECTL                      m_rArea;
    LPVOID                     m_lpSurfData;
    HRESULT                    m_ddRVal;
    LPDDHALSURFCB_LOCK         m_Lock;
    DWORD                      m_dwFlags;

public:
    LPDDRAWI_DIRECTDRAW_GBL&    lpDD()
    { return m_lpDD; }
    PORTABLE_DDRAWSURFACE_LCL*& lpDDSurface()
    { return m_lpDDSurface; }
    DWORD&                      bHasRect()
    { return m_bHasRect; }
    RECTL&                      rArea()
    { return m_rArea; }
    LPVOID&                     lpSurfData()
    { return m_lpSurfData; }
    HRESULT&                    ddRVal()
    { return m_ddRVal; }
    LPDDHALSURFCB_LOCK&         Lock()
    { return m_Lock; }
    DWORD&                      dwFlags()
    { return m_dwFlags; }
};

class PORTABLE_UNLOCKDATA
{
private:
    LPDDRAWI_DIRECTDRAW_GBL    m_lpDD;
    PORTABLE_DDRAWSURFACE_LCL* m_lpDDSurface;
    HRESULT                    m_ddRVal;
    LPDDHALSURFCB_UNLOCK       m_Unlock;

public:
    LPDDRAWI_DIRECTDRAW_GBL&    lpDD()
    { return m_lpDD; }
    PORTABLE_DDRAWSURFACE_LCL*& lpDDSurface()
    { return m_lpDDSurface; }
    HRESULT&                    ddRVal()
    { return m_ddRVal; }
    LPDDHALSURFCB_UNLOCK&       Unlock()
    { return m_Unlock; }
};

////////////////////////////////////////////////////////////////////////////////
//
// CSurfaceLocker
//
// This class safely locks a surface upon construction and unlocks the surface
// upon destruction. 
//
////////////////////////////////////////////////////////////////////////////////
template< class TSurfacePtr>
class CSurfaceLocker
{
protected: // Variables
    TSurfacePtr m_pSurface;
    void* m_pSData;

public: // Functions
    explicit CSurfaceLocker( const TSurfacePtr& S, DWORD dwLockFlags,
        const RECTL* pRect) : m_pSurface( S)
    { m_pSData= m_pSurface->Lock( dwLockFlags, pRect); }
    ~CSurfaceLocker() 
    { m_pSurface->Unlock(); }
    void* const& GetData() const 
    { return m_pSData; }
};

////////////////////////////////////////////////////////////////////////////////
//
// CEnsureFPUModeForC
//
// This class converts the FPU mode for x86 chips back into the mode compatable
// for C operations. The mode that D3D sets up for rasterizers is single
// precision, for more speed. But, sometimes, the rasterizer needs to do
// double operations and get double precision accuracy. This class sets up the
// mode for as long as the class is in scope.
//
////////////////////////////////////////////////////////////////////////////////
class CEnsureFPUModeForC
{
protected: // Variables
    WORD m_wSaveFP;

public:
    CEnsureFPUModeForC() 
    {
#if defined(_X86_)
        // save floating point mode and set to double precision mode
        // which is compatable with C/ C++
        WORD wTemp, wSave;
        __asm
        {
            fstcw   wSave
            mov ax, wSave
            or ax, 0200h
            mov wTemp, ax
            fldcw   wTemp
        }
        m_wSaveFP= wSave;
#endif
    }
    ~CEnsureFPUModeForC() 
    {
#if defined(_X86_)
        WORD wSave( m_wSaveFP);
        __asm fldcw wSave
#endif
    }
};

////////////////////////////////////////////////////////////////////////////////
//
// SDP2NextCmd
//
// A unary_function which can return the pointer to the next
// DrawPrimitive2 command in a contiguous buffer given a pointer to a valid
// DrawPrimitive2 command in the same buffer, as is a common situation for
// processing DrawPrimitive2 commands within the DrawPrimitive2 function call.
// This class is naturally useful for DrawPrimitive2 command iterators.
// It contains all the possible commands that could be encountered for a DX8SDDI
// driver.
//
////////////////////////////////////////////////////////////////////////////////
struct SDP2NextCmd:
    public unary_function< const D3DHAL_DP2COMMAND*, D3DHAL_DP2COMMAND*>
{
    // This function allows iteration from one D3DHAL_DP2COMMAND* to the next.
    // This operation can be optimized quite a bit if many of the more advanced
    // features aren't supported (as tough to process D3DDP2_OPs might not be
    // encountered).
    D3DHAL_DP2COMMAND* operator()( const D3DHAL_DP2COMMAND* pCur) const 
    {
        const UINT8* pBRet= reinterpret_cast< const UINT8*>(pCur)+
            sizeof( D3DHAL_DP2COMMAND);
        switch( pCur->bCommand)
        {
        //case( D3DDP2OP_POINTS): // <DX8
        //case( D3DDP2OP_INDEXEDLINELIST): // <DX8
        //case( D3DDP2OP_INDEXEDTRIANGLELIST): // <DX8
        //case( D3DDP2OP_RESERVED0): 
        case( D3DDP2OP_RENDERSTATE): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2RENDERSTATE)* pCur->wStateCount;
            break;
        //case( D3DDP2OP_LINELIST): // <DX8
        //case( D3DDP2OP_LINESTRIP): // <DX8
        //case( D3DDP2OP_INDEXEDLINESTRIP): // <DX8
        //case( D3DDP2OP_TRIANGLELIST): // <DX8
        //case( D3DDP2OP_TRIANGLESTRIP): // <DX8
        //case( D3DDP2OP_INDEXEDTRIANGLESTRIP): // <DX8
        //case( D3DDP2OP_TRIANGLEFAN): // <DX8
        //case( D3DDP2OP_INDEXEDTRIANGLEFAN): // <DX8
        //case( D3DDP2OP_TRIANGLEFAN_IMM): // <DX8
        //case( D3DDP2OP_LINELIST_IMM): // <DX8
        case( D3DDP2OP_TEXTURESTAGESTATE): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2TEXTURESTAGESTATE)* pCur->wStateCount;
            break;
        //case( D3DDP2OP_INDEXEDTRIANGLELIST2): // <DX8
        //case( D3DDP2OP_INDEXEDLINELIST2): // <DX8
        case( D3DDP2OP_VIEWPORTINFO): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2VIEWPORTINFO)* pCur->wStateCount;
            break;
        case( D3DDP2OP_WINFO): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2WINFO)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETPALETTE): // DX8 (if support palettized surf/tex)
            pBRet+= sizeof( D3DHAL_DP2SETPALETTE)* pCur->wStateCount;
            break;
        case( D3DDP2OP_UPDATEPALETTE): // DX8 (if support palettized surf/tex)
            assert( pCur->wStateCount== 1);
            pBRet= pBRet+ sizeof( D3DHAL_DP2UPDATEPALETTE)+
                reinterpret_cast< const D3DHAL_DP2UPDATEPALETTE*>(
                pBRet)->wNumEntries* sizeof( DWORD);
            break;
        case( D3DDP2OP_ZRANGE): // DX8 (if support TnL)
            pBRet+= sizeof( D3DHAL_DP2ZRANGE)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETMATERIAL): // DX8 (if support TnL)
            pBRet+= sizeof( D3DHAL_DP2SETMATERIAL)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETLIGHT): // DX8 (if support TnL)
            { WORD wStateCount( pCur->wStateCount);
            if( wStateCount!= 0) do
            {
                const D3DHAL_DP2SETLIGHT* pSL=
                    reinterpret_cast< const D3DHAL_DP2SETLIGHT*>( pBRet);

                if( D3DHAL_SETLIGHT_DATA== pSL->dwDataType)
                    pBRet+= sizeof( D3DLIGHT8);
                pBRet+= sizeof( D3DHAL_DP2SETLIGHT);
            } while( --wStateCount); }
            break;
        case( D3DDP2OP_CREATELIGHT): // DX8 (if support TnL)
            pBRet+= sizeof( D3DHAL_DP2CREATELIGHT)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETTRANSFORM): // DX8 (if support TnL)
            pBRet+= sizeof( D3DHAL_DP2SETTRANSFORM)* pCur->wStateCount;
            break;
        case( D3DDP2OP_EXT): // DX8 (if work seemlessly with TnL extensions)
            { WORD wStateCount( pCur->wStateCount);
            if( wStateCount!= 0) do
            {
                pBRet+= reinterpret_cast< const D3DHAL_DP2EXT*>(pBRet)->dwSize;
            } while( --wStateCount); }
            break;
        case( D3DDP2OP_TEXBLT): // DX8 (if support vidmem texture)
            pBRet+= sizeof( D3DHAL_DP2TEXBLT)* pCur->wStateCount;
            break;
        case( D3DDP2OP_STATESET): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2STATESET)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETPRIORITY): // DX8 (if manage textures)
            pBRet+= sizeof( D3DHAL_DP2SETPRIORITY)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETRENDERTARGET): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2SETRENDERTARGET)* pCur->wStateCount;
            break;
        case( D3DDP2OP_CLEAR): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2CLEAR)- sizeof( RECT)+ sizeof( RECT)*
                pCur->wStateCount;
            break;
        case( D3DDP2OP_SETTEXLOD): // DX8 (if manage textures)
            pBRet+= sizeof( D3DHAL_DP2SETTEXLOD)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETCLIPPLANE): // DX8 (if support user clip planes)
            pBRet+= sizeof( D3DHAL_DP2SETCLIPPLANE)* pCur->wStateCount;
            break;
        case( D3DDP2OP_CREATEVERTEXSHADER): // DX8 (if support vshaders)
            { WORD wStateCount( pCur->wStateCount);
            if( wStateCount!= 0) do
            {
                const D3DHAL_DP2CREATEVERTEXSHADER* pCVS=
                    reinterpret_cast< const D3DHAL_DP2CREATEVERTEXSHADER*>(
                    pBRet);
                pBRet+= sizeof( D3DHAL_DP2CREATEVERTEXSHADER)+
                    pCVS->dwDeclSize+ pCVS->dwCodeSize;
            } while( --wStateCount); }
            break;
        case( D3DDP2OP_DELETEVERTEXSHADER): // DX8 (if support vshaders)
            pBRet+= sizeof( D3DHAL_DP2VERTEXSHADER)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETVERTEXSHADER): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2VERTEXSHADER)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETVERTEXSHADERCONST): // DX8 (if support vshaders)
            { WORD wStateCount( pCur->wStateCount);
            if( wStateCount!= 0) do
            {
                const D3DHAL_DP2SETVERTEXSHADERCONST* pSVSC=
                    reinterpret_cast< const D3DHAL_DP2SETVERTEXSHADERCONST*>(
                    pBRet);
                pBRet+= sizeof( D3DHAL_DP2SETVERTEXSHADERCONST)+
                    4* sizeof( D3DVALUE)* pSVSC->dwCount;
            } while( --wStateCount); }
            break;
        case( D3DDP2OP_SETSTREAMSOURCE): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2SETSTREAMSOURCE)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETSTREAMSOURCEUM): // DX8 All (unless no DrawPrimUP calls)
            pBRet+= sizeof( D3DHAL_DP2SETSTREAMSOURCEUM)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETINDICES): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2SETINDICES)* pCur->wStateCount;
            break;
        case( D3DDP2OP_DRAWPRIMITIVE): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2DRAWPRIMITIVE)* pCur->wPrimitiveCount;
            break;
        case( D3DDP2OP_DRAWINDEXEDPRIMITIVE): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2DRAWINDEXEDPRIMITIVE)*
                pCur->wPrimitiveCount;
            break;
        case( D3DDP2OP_CREATEPIXELSHADER): // DX8 (if support pshaders)
            { WORD wStateCount( pCur->wStateCount);
            if( wStateCount!= 0) do
            {
                const D3DHAL_DP2CREATEPIXELSHADER* pCPS=
                    reinterpret_cast< const D3DHAL_DP2CREATEPIXELSHADER*>(
                    pBRet);
                pBRet+= sizeof( D3DHAL_DP2CREATEPIXELSHADER)+
                    pCPS->dwCodeSize;
            } while( --wStateCount); }
            break;
        case( D3DDP2OP_DELETEPIXELSHADER): // DX8 (if support pshaders)
            pBRet+= sizeof( D3DHAL_DP2PIXELSHADER)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETPIXELSHADER): // DX8 (if support pshaders)
            pBRet+= sizeof( D3DHAL_DP2PIXELSHADER)* pCur->wStateCount;
            break;
        case( D3DDP2OP_SETPIXELSHADERCONST): // DX8 (if support pshaders)
            { WORD wStateCount( pCur->wStateCount);
            if( wStateCount!= 0) do
            {
                const D3DHAL_DP2SETPIXELSHADERCONST* pSPSC=
                    reinterpret_cast< const D3DHAL_DP2SETPIXELSHADERCONST*>(
                    pBRet);
                pBRet+= sizeof( D3DHAL_DP2SETPIXELSHADERCONST)+
                    4* sizeof( D3DVALUE)* pSPSC->dwCount;
            } while( --wStateCount); }
            break;
        case( D3DDP2OP_CLIPPEDTRIANGLEFAN): // DX8 All
            pBRet+= sizeof( D3DHAL_CLIPPEDTRIANGLEFAN)* pCur->wPrimitiveCount;
            break;
        case( D3DDP2OP_DRAWPRIMITIVE2): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2DRAWPRIMITIVE2)* pCur->wPrimitiveCount;
            break;
        case( D3DDP2OP_DRAWINDEXEDPRIMITIVE2): // DX8 All
            pBRet+= sizeof( D3DHAL_DP2DRAWINDEXEDPRIMITIVE2)*
                pCur->wPrimitiveCount;
            break;
        case( D3DDP2OP_DRAWRECTPATCH): // DX8 (if support higher order prims)
            { WORD wPrimitiveCount( pCur->wPrimitiveCount);
            if( wPrimitiveCount!= 0) do
            {
                const D3DHAL_DP2DRAWRECTPATCH* pDRP= 
                    reinterpret_cast< const D3DHAL_DP2DRAWRECTPATCH*>(pBRet);

                pBRet+= sizeof( D3DHAL_DP2DRAWRECTPATCH);

                if((pDRP->Flags& RTPATCHFLAG_HASSEGS)!= 0)
                    pBRet+= 4* sizeof( D3DVALUE);

                if((pDRP->Flags& RTPATCHFLAG_HASINFO)!= 0)
                    pBRet+= sizeof( D3DRECTPATCH_INFO);
            } while( --wPrimitiveCount); }
            break;
        case( D3DDP2OP_DRAWTRIPATCH): // DX8 (if support higher order prims)
            { WORD wPrimitiveCount( pCur->wPrimitiveCount);
            if( wPrimitiveCount!= 0) do
            {
                const D3DHAL_DP2DRAWTRIPATCH* pDTP= 
                    reinterpret_cast< const D3DHAL_DP2DRAWTRIPATCH*>(pBRet);

                pBRet+= sizeof( D3DHAL_DP2DRAWTRIPATCH);

                if((pDTP->Flags& RTPATCHFLAG_HASSEGS)!= 0)
                    pBRet+= 3* sizeof( D3DVALUE);

                if((pDTP->Flags& RTPATCHFLAG_HASINFO)!= 0)
                    pBRet+= sizeof( D3DTRIPATCH_INFO);
            } while( --wPrimitiveCount); }
            break;
        case( D3DDP2OP_VOLUMEBLT): // DX8 (if support vidmem volume texture)
            pBRet+= sizeof( D3DHAL_DP2VOLUMEBLT)* pCur->wStateCount;
            break;
        case( D3DDP2OP_BUFFERBLT): // DX8 (if support vidmem vrtx/indx buffer)
            pBRet+= sizeof( D3DHAL_DP2BUFFERBLT)* pCur->wStateCount;
            break;
        case( D3DDP2OP_MULTIPLYTRANSFORM): // DX8 (if support TnL)
            pBRet+= sizeof( D3DHAL_DP2MULTIPLYTRANSFORM)* pCur->wStateCount;
            break;
        default: {
            const bool Unable_To_Parse_Unrecognized_D3DDP2OP( false);
            assert( Unable_To_Parse_Unrecognized_D3DDP2OP);
            } break;
        }
        return const_cast<D3DHAL_DP2COMMAND*>
            (reinterpret_cast<const D3DHAL_DP2COMMAND*>(pBRet));
    }
};

////////////////////////////////////////////////////////////////////////////////
//
// CDP2CmdIterator & CDP2ConstCmdIterator
//
// These iterators are provided as a convenience to iterate DrawPrimitive2
// commands which are packed in a contiguous chunk of memory, as is typical
// of execute/ command buffers which need to be processed within the
// DrawPrimitive2 function call. The actual iteration logic is encapsulated in
// the template parameter, so that it can be easily extended, if certain
// commands aren't exepected and a better iteration scheme could be used.
//
// Be careful, these iterators are only useful for iterating. They do not
// directly know the size of the data they point to. For completeness, which
// would allow seperate storage of commands, another class would need to be
// created and assigned as the value_type. Dereferencing the iterator only
// returns a D3DHAL_DP2COMMAND without any extra data. Something like:
//
// CDP2Cmd DP2Cmd= *itDP2Cmd; 
//
// is possible; but requires more work and definition of CDP2Cmd.
//
////////////////////////////////////////////////////////////////////////////////
template< class TNextCmd= SDP2NextCmd>
class CDP2CmdIterator
{
public: // Types
    typedef forward_iterator_tag iterator_category;
    typedef D3DHAL_DP2COMMAND    value_type;
    typedef ptrdiff_t            difference_type;
    typedef D3DHAL_DP2COMMAND*   pointer;
    typedef D3DHAL_DP2COMMAND&   reference;

protected: // Variables
    pointer m_pRawCmd;
    TNextCmd m_NextCmd;

public: // Functions
    CDP2CmdIterator( pointer pRaw= NULL) 
        :m_pRawCmd( pRaw) { }
    CDP2CmdIterator( pointer pRaw, const TNextCmd& NextCmd) 
        :m_NextCmd( NextCmd), m_pRawCmd( pRaw) { }
    CDP2CmdIterator( const CDP2CmdIterator< TNextCmd>& Other) 
        :m_NextCmd( Other.m_NextCmd), m_pRawCmd( Other.m_pRawCmd) { }

    reference operator*() const 
    { return *m_pRawCmd; }
    pointer operator->() const 
    { return m_pRawCmd; }
    operator pointer() const 
    { return m_pRawCmd; }

    CDP2CmdIterator< TNextCmd>& operator++() 
    { m_pRawCmd= m_NextCmd( m_pRawCmd); return *this; }
    CDP2CmdIterator< TNextCmd> operator++(int) 
    {
        CDP2CmdIterator< TNextCmd> tmp= *this;
        m_pRawCmd= m_NextCmd( m_pRawCmd);
        return tmp;
    }
    bool operator==( CDP2CmdIterator< TNextCmd>& x) const 
    { return m_pRawCmd== x.m_pRawCmd; }
    bool operator!=( CDP2CmdIterator< TNextCmd>& x) const 
    { return m_pRawCmd!= x.m_pRawCmd; }
};

template< class TNextCmd= SDP2NextCmd>
class CConstDP2CmdIterator
{
public: // Types
    typedef forward_iterator_tag     iterator_category;
    typedef const D3DHAL_DP2COMMAND  value_type;
    typedef ptrdiff_t                difference_type;
    typedef const D3DHAL_DP2COMMAND* pointer;
    typedef const D3DHAL_DP2COMMAND& reference;

protected: // Variables
    pointer m_pRawCmd;
    TNextCmd m_NextCmd;

public: // Functions
    CConstDP2CmdIterator( pointer pRaw= NULL) 
        :m_pRawCmd( pRaw) { }
    CConstDP2CmdIterator( pointer pRaw, const TNextCmd& NextCmd) 
        :m_NextCmd( NextCmd), m_pRawCmd( pRaw) { }
    CConstDP2CmdIterator( const CDP2CmdIterator< TNextCmd>& Other) 
        :m_NextCmd( Other.m_NextCmd), m_pRawCmd( Other.m_pRawCmd) { }
    CConstDP2CmdIterator( const CConstDP2CmdIterator< TNextCmd>& Other) 
        :m_NextCmd( Other.m_NextCmd), m_pRawCmd( Other.m_pRawCmd) { }

    reference operator*() const 
    { return *m_pRawCmd; }
    pointer operator->() const 
    { return m_pRawCmd; }
    operator pointer() const 
    { return m_pRawCmd; }

    CConstDP2CmdIterator< TNextCmd>& operator++() 
    { m_pRawCmd= m_NextCmd( m_pRawCmd); return *this; }
    CConstDP2CmdIterator< TNextCmd> operator++(int) 
    {
        CConstDP2CmdIterator< TNextCmd> tmp= *this;
        m_pRawCmd= m_NextCmd( m_pRawCmd);
        return tmp;
    }
    bool operator==( CConstDP2CmdIterator< TNextCmd>& x) const 
    { return m_pRawCmd== x.m_pRawCmd; }
    bool operator!=( CConstDP2CmdIterator< TNextCmd>& x) const 
    { return m_pRawCmd!= x.m_pRawCmd; }
};

////////////////////////////////////////////////////////////////////////////////
//
// CDP2DataWrap
//
// This class is provided as a convenience to expose the
// PORTABLE_DRAWPRIMITIVES2DATA as a more friendly class. Mostly, it wraps the
// execute/ command buffer with an STL Sequence Container, so that the commands
// can be iterated over without copying and pre-parsing the command data.
//
// <Template Parameters>
// TNextCmd: a unary_function which takes a const D3DHAL_DP2COMMAND* in and
//     returns a D3DHAL_DP2COMMAND* which points to the next command. In
//     essence, a unary_function which enables a forward iterator on a
//     contiguous command buffer.
//
// <Exposed Types>
// TCmds: The Sequence Container type which exposed the commands.
//
// <Exposed Functions>
// CDP2DataWrap( PORTABLE_DRAWPRIMITIVES2DATA& DP2Data): Constructor to wrap the
//     PORTABLE_DRAWPRIMITIVES2DATA.
// const TCmds& GetCommands() const: Accessor function to get at the Sequence
//     Container.
//     
////////////////////////////////////////////////////////////////////////////////
template< class TNextCmd= SDP2NextCmd>
class CDP2DataWrap:
    public PORTABLE_DRAWPRIMITIVES2DATA
{
public: // Types
    class CDP2Cmds
    {
    public: // Types
        typedef CConstDP2CmdIterator< TNextCmd>          const_iterator;
        typedef typename const_iterator::value_type      value_type;
        typedef typename const_iterator::reference       const_reference;
        typedef typename const_iterator::pointer         const_pointer;
        typedef typename const_iterator::difference_type difference_type;
        typedef size_t                                   size_type;

    protected: // Variables
        CDP2DataWrap< TNextCmd>* m_pDP2Data;

    protected: // Functions
        // Allow to call constructor and set member variable.
        friend class CDP2DataWrap< TNextCmd>;

        CDP2Cmds( ) 
            :m_pDP2Data( NULL) { }

    public: // Functions
        const_iterator begin( void) const 
        {
            return const_iterator( reinterpret_cast<D3DHAL_DP2COMMAND*>(
                reinterpret_cast<UINT8*>(m_pDP2Data->lpDDCommands()->lpGbl()->fpVidMem)
                + m_pDP2Data->dwCommandOffset()));
        }
        const_iterator end( void) const 
        {
            return const_iterator( reinterpret_cast<D3DHAL_DP2COMMAND*>(
                reinterpret_cast<UINT8*>(m_pDP2Data->lpDDCommands()->lpGbl()->fpVidMem)
                + m_pDP2Data->dwCommandOffset()+ m_pDP2Data->dwCommandLength()));
        }
        size_type size( void) const 
        {
            size_type N( 0);
            const_iterator itS( begin());
            const_iterator itE( end());
            while( itS!= itE)
            { ++itS; ++N; }
            return N;
        }
        size_type max_size( void) const 
        { return size(); }
        bool empty( void) const 
        { return begin()== end(); }
    };
    typedef CDP2Cmds TCmds;

protected: // Variables
    TCmds m_Cmds;

public: // Functions
    explicit CDP2DataWrap( PORTABLE_DRAWPRIMITIVES2DATA& DP2Data) 
        : PORTABLE_DRAWPRIMITIVES2DATA( DP2Data)
    { m_Cmds.m_pDP2Data= this; }
    const TCmds& GetCommands( void) const 
    { return m_Cmds; }
};

////////////////////////////////////////////////////////////////////////////////
//
// SDP2MFnParser
//
// This class is a functional class, with many too many paramters to squeeze
// into the standard functional classes. It automates the parsing, member fn
// lookup, and dispatching for DrawPrimitive2 commands. This parser uses the
// command number to lookup a member function from a container to call.
//
////////////////////////////////////////////////////////////////////////////////
struct SDP2MFnParser
{
    // <Parameters>
    // MFnCaller: A binary_function type with TDP2CmdFnCtr::value_type,
    //     typically a member function pointer, as the first argument;
    //     TIter, typically a smart DP2 command iterator, as the second
    //     argument; and returns an HRESULT. This function type should call
    //     the member function to process the DP2 command, with the iterator
    //     used to determine the DP2 Cmd data.
    // DP2CmdFnCtr: This can be any Unique, Pair Associative Container,
    //     typically a map, which associates a D3DHAL_DP2OPERATION with a
    //     member function.
    // [itStart, itEnd): These iterators define a standard range of
    //     D3DHAL_DP2COMMAND. The iterators need only be forward iterators,
    //     and be convertable to raw D3DHAL_DP2COMMAND*. Note: itStart is
    //     a reference, so that the caller can determine the current iterator
    //     position upon return of function (when HRESULT!= DD_OK).
    template< class TMFnCaller, class TDP2CmdFnCtr, class TIter>
    HRESULT ParseDP2( TMFnCaller& MFnCaller, TDP2CmdFnCtr& DP2CmdFnCtr,
        TIter& itStart, TIter itEnd) const 
    {
        HRESULT hr( DD_OK);
        while( itStart!= itEnd)
        {
            try
            {
                hr= MFnCaller( DP2CmdFnCtr[ itStart->bCommand], itStart);
            } catch( HRESULT hrEx) {
                hr= hrEx;
#if !defined( DX8SDDIFW_NOCATCHALL)
            } catch ( ... ) {
                const bool Unrecognized_Exception_In_A_DP2_Op_Function( false);
                assert( Unrecognized_Exception_In_A_DP2_Op_Function);
                hr= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
            }

            // Only move on to next command if DD_OK. Otherwise return out
            // to caller. They can always call us back if caller determines
            // error code is a SUCCESS.
            if( DD_OK== hr)
                ++itStart;
            else
                break;
        }
        return hr;
    }
};

////////////////////////////////////////////////////////////////////////////////
//
// CSubStateSet & CMinimalStateSet
//
// This class contains a default implementation of a stateset. It copies/ packs
// a contiguous DP2 command buffer into a memory buffer. To capture, it asks
// the context to record the command buffer with the Context's current state.
// To execute, it fixes up a Fake DrawPrimitives2 point parameter
// and calls the context's DrawPrimitives2 entry point. The context
// needs to be able to handle recursive DrawPrimitives2 calls in order to use
// this default stateset. CStdDrawPrimitives2's DrawPrimitives2 handler
// does this by storing whether it is executing a stateset.
//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyStateSet type.
// TC: The Context type, typically, CMyContext.
//
// <Exposed Types>
// TContext: The Context type passed in as a template parameter.
//
// <Exposed Functions>
// CSubStateSet( TContext&, const D3DHAL_DP2COMMAND*, const D3DHAL_DP2COMMAND*):
//     The constructor which builds a stateset for a Context, from a range of
//     a command buffer. The default implementation will just copy this range.
// CSubStateSet( const CSubStateSet& Other): Standard copy constructor.
// void Capture( TContext&): The state set is instructed to capture the
//     necessary data from the Context, in order to perform an Execute later,
//     which will restore the data fields or state that the state set was
//     constructed with.
// void Execute( TContext&): Restore or rebuild the Context with the data/
//     state that was saved during the Capture operation.
//
////////////////////////////////////////////////////////////////////////////////
template< class TSuper, class TC>
class CSubStateSet
{
public: // Types
    typedef TC TContext;

protected: // Variables
    TContext& m_Context;
    D3DHAL_DP2COMMAND* m_pBeginSS;
    size_t m_uiSSBufferSize;

protected: // Functions
    CSubStateSet( const CSubStateSet< TSuper, TC>& Other)
        :m_Context( Other.m_Context), m_pBeginSS( NULL),
        m_uiSSBufferSize( Other.m_uiSSBufferSize)
    {
        try {
            m_pBeginSS= reinterpret_cast< D3DHAL_DP2COMMAND*>(
                operator new( m_uiSSBufferSize));
        } catch( ... ) {
        }
        if( NULL== m_pBeginSS)
            throw bad_alloc( "Not enough room to copy state set command "
                "buffer.");
        memcpy( m_pBeginSS, Other.m_pBeginSS, m_uiSSBufferSize);
    }
    CSubStateSet( TContext& C, const D3DHAL_DP2COMMAND* pBeginSS, const
        D3DHAL_DP2COMMAND* pEndSS) : m_Context( C), m_pBeginSS( NULL),
        m_uiSSBufferSize( 0)
    {
        // Convert the contiguous command pointers to byte pointers, to
        // calculate the size of buffer needed to copy the data.
        const UINT8* pSBytePtr= reinterpret_cast< const UINT8*>( pBeginSS);
        const UINT8* pEBytePtr= reinterpret_cast< const UINT8*>( pEndSS);
        m_uiSSBufferSize= static_cast< size_t>( pEBytePtr- pSBytePtr);
        try {
            m_pBeginSS= reinterpret_cast< D3DHAL_DP2COMMAND*>(
                operator new( m_uiSSBufferSize));
        } catch( ... ) {
        }
        if( NULL== m_pBeginSS)
            throw bad_alloc( "Not enough room to allocate state set command "
                "buffer.");
        memcpy( m_pBeginSS, pBeginSS, m_uiSSBufferSize);
    }
    ~CSubStateSet()
    {
        operator delete( static_cast< void*>( m_pBeginSS));
    }

public: // Functions
    CSubStateSet< TSuper, TC>& operator=( const CSubStateSet< TSuper, TC>& Oth)
    {
        assert( &m_Context== &Oth.m_Context);
        if( m_uiSSBufferSize<= Oth.m_uiSSBufferSize)
        {
            m_uiSSBufferSize= Oth.m_uiSSBufferSize;
            memcpy( m_pBeginSS, Oth.m_pBeginSS, m_uiSSBufferSize);
        }
        else
        {
            void* pNewBuffer= NULL;
            try {
                pNewBuffer= operator new( Oth.m_uiSSBufferSize);
            } catch( ... ) {
            }
            if( NULL== pNewBuffer)
                throw bad_alloc( "Not enough room to copy state set command "
                    "buffer.");

            operator delete( static_cast< void*>( m_pBeginSS));
            m_pBeginSS= reinterpret_cast< D3DHAL_DP2COMMAND*>( pNewBuffer);
            m_uiSSBufferSize= Oth.m_uiSSBufferSize;
            memcpy( m_pBeginSS, Other.m_pBeginSS, m_uiSSBufferSize);
        }
        return *this;
    }
    void Capture( TContext& Ctx) 
    {
        assert( &m_Context== &Ctx);

        UINT8* pBytePtr= reinterpret_cast< UINT8*>( m_pBeginSS);
        D3DHAL_DP2COMMAND* pEndSS= reinterpret_cast< D3DHAL_DP2COMMAND*>(
            pBytePtr+ m_uiSSBufferSize);

        // Ask Context to record it's current state into the stored command
        // buffer. CStdDrawPrimitives2 can provide an implementation of
        // RecordCommandBuffer for the Context.
        Ctx.RecordCommandBuffer( m_pBeginSS, pEndSS);
    }
    void Execute( TContext& Ctx) 
    {
        assert( &m_Context== &Ctx);

        // Build up a fake PORTABLE_DRAWPRIMITIVES2DATA environment.
        PORTABLE_DDRAWSURFACE_LCL DDSLcl;
        PORTABLE_DDRAWSURFACE_MORE DDSMore;
        DDRAWI_DDRAWSURFACE_GBL DDSGbl;
        memset( &DDSLcl, 0, sizeof( DDSLcl));
        memset( &DDSMore, 0, sizeof( DDSMore));
        memset( &DDSGbl, 0, sizeof( DDSGbl));

        PORTABLE_DRAWPRIMITIVES2DATA FakeDPD;

        FakeDPD.dwhContext()= reinterpret_cast< ULONG_PTR>( &Ctx);
        FakeDPD.dwFlags()= D3DHALDP2_USERMEMVERTICES;
        FakeDPD.dwVertexType()= 0;
        FakeDPD.lpDDCommands()= &DDSLcl;
        FakeDPD.dwCommandOffset()= 0;
        FakeDPD.dwCommandLength()= m_uiSSBufferSize;
        FakeDPD.lpVertices()= NULL;
        FakeDPD.dwVertexOffset()= 0;
        FakeDPD.dwVertexLength()= 0;
        FakeDPD.dwReqVertexBufSize()= 0;
        FakeDPD.dwReqCommandBufSize()= 0;
        FakeDPD.lpdwRStates()= NULL;
        FakeDPD.dwVertexSize()= 0;

        // If the data is not 0, then a union can't be used, as we're
        // writing over valid data.
        DDSLcl.lpGbl()= &DDSGbl;
        DDSLcl.ddsCaps().dwCaps= DDSCAPS2_COMMANDBUFFER| DDSCAPS_SYSTEMMEMORY;
        DDSLcl.lpSurfMore()= &DDSMore;
        DDSGbl.fpVidMem= reinterpret_cast<FLATPTR>( m_pBeginSS);

        // Now call Context's DrawPrimitives2 entry point. CStdDrawPrimitives2
        // can provide an implementation of DrawPrimitives2 for the Context.
        HRESULT hr( Ctx.DrawPrimitives2( FakeDPD));
        assert( SUCCEEDED( hr));
    }
};

//
// <Template Parameters>
// TC: The Context type, typically, CMyContext.
//
template< class TC>
class CMinimalStateSet: public CSubStateSet< CMinimalStateSet, TC>
{
public: // Types
    typedef TC TContext;

public: // Functions
    CMinimalStateSet( const CMinimalStateSet< TC>& Other)
        :CSubStateSet< CMinimalStateSet, TC>( Other)
    { }
    CMinimalStateSet( TContext& C, const D3DHAL_DP2COMMAND* pBeginSS, const
        D3DHAL_DP2COMMAND* pEndSS) :
        CSubStateSet< CMinimalStateSet, TC>( C, pBeginSS, pEndSS) { }
    ~CMinimalStateSet()  { }
};

////////////////////////////////////////////////////////////////////////////////
//
// CStdDrawPrimitives2
//
// This class contains a default implementation of responding to the
// DrawPrimitives2 function call, as well as a function to record state back
// into a command buffer. Upon constuction, it will use the provided ranges
// to bind DP2 operations to both processing and recording member functions.
// In order to process the DrawPrimitives2 function call, it must wrap the
// PORTABLE_DRAWPRIMITIVES2DATA with a convience type which allows commands to
// be walked through with iterators. It will then use the DP2MFnParser to
// parse the DP2 commands and call the member functions.
//
// This class also provides a member function for processing the DP2 StateSet
// operation, and uses it to build up, manage, and execute state sets. In
// order to handle pure device state sets, it creates the appropriate command
// buffer for the Device (based off of caps), constructs a new state set
// on this command buffer, and asks the state set to Capture the current state.
//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TSS: The StateSet type, typically, CMyStateSet or CMinimalStateSet. The
//     StateSet class should be able to be constructed from a command buffer,
//     and then be able to Capture and Execute.
// TSSDB: This can be any Unique, Pair Associative Container, typically a map,
//     which associates a DWORD state set handle to a StateSet type. 
// TDP2D: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA.
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, along with exposing an STL conforming
//     container which provides iterators which ease iterating over the command
//     buffer. This is typically CDP2DataWrap<>.
// TDP2MFC: A map container, which associates a D3DHAL_DP2OPERATION with a
//     member function. A standard array is acceptable, as the number of
//     entries is not variable at runtime. The member function is used to
//     process the command.
// TDP2RMFC: A map container, which associates a D3DHAL_DP2OPERATION with a
//     member function. A standard array is acceptable, as the number of
//     entries is not variable at runtime. The member function is used to
//     record or fill in the command with the current state.
//
// <Exposed Types>
// TDP2Data: The wrapper class type for PORTABLE_DRAWPRIMITIVES2DATA, which is
//     the passed in TDP2D template parameter.
// TDP2DataCmds: The Sequence Container of DP2 commands provided by the
//     TDP2Data wrapper class, which is relied upon to provide iteration over
//     the command buffer. (TDP2Data::TCmds)
// TStateSet: The StateSet type, which was passed in as the TSS template
//     parameter.
// TMFn: The member function type, which all DP2 command processing member
//     functions should conform to. This is mostly exposed as a convience to
//     Context implementors.
// TMFnCaller: An Adaptable Binary Function class which is used to call
//     a TMFn, only being passed the TMFn and DP2 command pointer.
// TDP2CmdBind: A simple type, exposed as a convience to Context implementors,
//     to provide a type that can be passed into the constructor, associating
//     D3DHAL_DP2OPERATIONs with member functions/ TMFn.
// TRMFn: The member function type, which all DP2 command recording member
//     functions should conform to. This is mostly exposed as a convience to
//     Context implementors.
// TRMFnCaller: An Adaptable Binary Function class which is used to call
//     a TRMFn, only being passed the TRMFn and DP2 command pointer.
// TRecDP2CmdBind: A simple type, exposed as a convience to Context implementors,
//     to provide a type that can be passed into the constructor, associating
//     D3DHAL_DP2OPERATIONs with member functions/ TRMFn.
//
// <Exposed Functions>
// CStdDrawPrimitives2(): Default constructor.
// template< class TIter1, class TIter2>
// CStdDrawPrimitives2( TIter1, const TIter1, TIter2, const TIter2): Standard
//     constructor which receives two ranges of D3DHAL_DP2OPERATION bindings.
//     The first range is a range of DP2 command processing bindings. The
//     second range is a range of DP2 command recording bindings.
// void OnBeginDrawPrimitives2( TDP2Data&): A notification function called
//     at the beginning of processing a DrawPrimitives2 entry point.
// void OnEndDrawPrimitives2( TDP2Data&): A notification function called at
//     the end of processing a DrawPrimitives2 entry point.
// void CreateAndCaptureAllState( DWORD): The request to capture all state,
//     which should only be received by pure devices.
// void CreateAndCapturePixelState( DWORD): The request to capture pixel state,
//     which should only be received by pure devices.
// void CreateAndCaptureVertexState( DWORD): The request to capture vertex
//     state, which should only be received by pure devices.
// HRESULT DP2StateSet( TDP2Data&, const D3DHAL_DP2COMMAND*, const void*): The
//     default DP2 command processing member function for D3DDP2OP_STATESET.
// void RecordCommandBuffer( D3DHAL_DP2COMMAND*, D3DHAL_DP2COMMAND*): The
//     request to save or fill in the blanks of the passed in range of command
//     buffer, by using the DP2 command recording functions.
// HRESULT DrawPrimitives2( PORTABLE_DRAWPRIMITIVES2DATA&): The function,
//     typically called by the Driver class to process the DrawPrimitives2
//     entry point.
//
////////////////////////////////////////////////////////////////////////////////
template< class TSuper, 
    class TSS= CMinimalStateSet< TSuper>, class TSSDB= map< DWORD, TSS>,
    class TDP2D= CDP2DataWrap<>,
    class TDP2MFC= block<
        HRESULT(TSuper::*)( TDP2D&, const D3DHAL_DP2COMMAND*, const void*), 66>,
    class TDP2RMFC= block<
        HRESULT(TSuper::*)( const D3DHAL_DP2COMMAND*, void*), 66> >
class CStdDrawPrimitives2
{
public: // Types
    typedef TDP2D TDP2Data;
    typedef typename TDP2Data::TCmds TDP2DataCmds;
    typedef TSS TStateSet;
    typedef HRESULT (TSuper::* TMFn)(TDP2Data&,const D3DHAL_DP2COMMAND*,
        const void*);
    struct TMFnCaller: // Used in conjunction 
        public binary_function< TMFn, const D3DHAL_DP2COMMAND*, HRESULT>
    {
        TSuper& m_Context;
        TDP2Data& m_DP2Data;

        TMFnCaller( TSuper& Context, TDP2Data& DP2Data)
            : m_Context( Context), m_DP2Data( DP2Data)
        { }

        result_type operator()( first_argument_type MFn,
            second_argument_type pDP2Cmd) const
        {
#if defined(DBG) || defined(_DEBUG)
            const D3DHAL_DP2OPERATION Op(
                static_cast< D3DHAL_DP2OPERATION>( pDP2Cmd->bCommand));
#endif
            return (m_Context.*MFn)( m_DP2Data, pDP2Cmd, pDP2Cmd+ 1);
        }
    };
    struct TDP2CmdBind
    {
        D3DHAL_DP2OPERATION m_DP2Op;
        TMFn m_MFn;

        operator D3DHAL_DP2OPERATION() const 
        { return m_DP2Op; }
        operator TMFn() const 
        { return m_MFn; }
    };
    typedef HRESULT (TSuper::* TRMFn)( const D3DHAL_DP2COMMAND*, void*);
    struct TRMFnCaller:
        public binary_function< TRMFn, D3DHAL_DP2COMMAND*, HRESULT>
    {
        TSuper& m_Context;

        TRMFnCaller( TSuper& Context)
            : m_Context( Context)
        { }

        result_type operator()( first_argument_type RMFn,
            second_argument_type pDP2Cmd) const
        {
#if defined(DBG) || defined(_DEBUG)
            const D3DHAL_DP2OPERATION Op(
                static_cast< D3DHAL_DP2OPERATION>( pDP2Cmd->bCommand));
#endif
            return (m_Context.*RMFn)( pDP2Cmd, pDP2Cmd+ 1);
        }
    };
    struct TRecDP2CmdBind
    {
        D3DHAL_DP2OPERATION m_DP2Op;
        TRMFn m_RMFn;

        operator D3DHAL_DP2OPERATION() const 
        { return m_DP2Op; }
        operator TRMFn() const 
        { return m_RMFn; }
    };


protected: // Types
    typedef TSSDB TSSDB;
    typedef TDP2MFC TDP2MFnCtr;
    typedef TDP2RMFC TDP2RecMFnCtr;

protected: // Variables
    static const HRESULT c_hrStateSetBegin;
    static const HRESULT c_hrStateSetEnd;
    TSSDB m_StateSetDB;
    TDP2MFnCtr m_DefFnCtr;
    TDP2RecMFnCtr m_RecFnCtr;
    const D3DHAL_DP2COMMAND* m_pEndStateSet;
    DWORD m_dwStateSetId;
    bool m_bRecordingStateSet;
    bool m_bExecutingStateSet;

protected: // Functions
    // This function is used as a filler. If the assert is hit, step one
    // level up/down in the call stack and check which DP2 Operation has
    // no support, but the app indirectly needs it.
    HRESULT DP2Empty( TDP2Data&, const D3DHAL_DP2COMMAND*, const void*) 
    {
        const bool A_DP2_Op_Requires_A_Supporting_Function( false);
        assert( A_DP2_Op_Requires_A_Supporting_Function);
        return D3DERR_COMMAND_UNPARSED;
    }

    // This function is used as a fake, to prevent actual processing of
    // DP2 Operations while recording a StateSet.
    HRESULT DP2Fake( TDP2Data&, const D3DHAL_DP2COMMAND*, const void*) 
    { return DD_OK; }

    // Notification functions. Overriding is optional.
    void OnBeginDrawPrimitives2( TDP2Data& DP2Data) const 
    { }
    void OnEndDrawPrimitives2( TDP2Data& DP2Data) const 
    { }

    CStdDrawPrimitives2() 
        :m_bRecordingStateSet( false), m_bExecutingStateSet( false),
        m_pEndStateSet( NULL)
    {
        typename TDP2MFnCtr::iterator itCur( m_DefFnCtr.begin());
        while( itCur!= m_DefFnCtr.end())
        {
            *itCur= DP2Empty;
            ++itCur;
        }
        itCur= m_RecFnCtr.begin();
        while( itCur!= m_RecFnCtr.end())
        {
            *itCur= NULL;
            ++itCur;
        }
        m_DefFnCtr[ D3DDP2OP_STATESET]= DP2StateSet;
    }

    // [itSetStart, itSetEnd): A valid range of bindings, which associate
    //     a D3DHAL_DP2OPERATION with a processing member function.
    // [itRecStart, itRecEnd): A valid range of bindings, which associate
    //     a D3DHAL_DP2OPERATION with a recording member function.
    template< class TIter1, class TIter2> // TDP2CmdBind*, TRecDP2CmdBind*
    CStdDrawPrimitives2( TIter1 itSetStart, const TIter1 itSetEnd,
        TIter2 itRecStart, const TIter2 itRecEnd) 
        :m_bRecordingStateSet( false), m_bExecutingStateSet( false),
        m_pEndStateSet( NULL)
    {
        typename TDP2MFnCtr::iterator itCur( m_DefFnCtr.begin());
        while( itCur!= m_DefFnCtr.end())
        {
            *itCur= DP2Empty;
            ++itCur;
        }
        typename TDP2RecMFnCtr::iterator itRCur= m_RecFnCtr.begin();
        while( itRCur!= m_RecFnCtr.end())
        {
            *itRCur= NULL;
            ++itRCur;
        }
        while( itSetStart!= itSetEnd)
        {
            const D3DHAL_DP2OPERATION DP2Op(
                static_cast<D3DHAL_DP2OPERATION>(*itSetStart));

            // This assert will fire if there are duplicate entries for the
            // same DP2OPERATION.
            assert( DP2Empty== m_DefFnCtr[ DP2Op]);
            m_DefFnCtr[ DP2Op]= static_cast<TMFn>(*itSetStart);
            ++itSetStart;
        }
        while( itRecStart!= itRecEnd)
        {
            const D3DHAL_DP2OPERATION DP2Op(
                static_cast<D3DHAL_DP2OPERATION>(*itRecStart));

            // This assert will fire if there are duplicate entries for the
            // same DP2OPERATION.
            assert( NULL== m_RecFnCtr[ DP2Op]);
            m_RecFnCtr[ DP2Op]= static_cast<TRMFn>(*itRecStart);
            ++itRecStart;
        }
        if( DP2Empty== m_DefFnCtr[ D3DDP2OP_STATESET])
            m_DefFnCtr[ D3DDP2OP_STATESET]= DP2StateSet;

        // Supporting these operations is considered the "safe minimal"
        // support necessary to function. It is strongly recommended that
        // these functions are supported, unless you know you can live without.
        assert( m_DefFnCtr[ D3DDP2OP_VIEWPORTINFO]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_WINFO]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_RENDERSTATE]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_CLEAR]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_SETRENDERTARGET]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_SETVERTEXSHADER]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_SETSTREAMSOURCE]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_SETSTREAMSOURCEUM]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_SETINDICES]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_DRAWPRIMITIVE]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_DRAWPRIMITIVE2]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_DRAWINDEXEDPRIMITIVE]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_DRAWINDEXEDPRIMITIVE2]!= DP2Empty);
        assert( m_DefFnCtr[ D3DDP2OP_CLIPPEDTRIANGLEFAN]!= DP2Empty);
        assert( m_RecFnCtr[ D3DDP2OP_VIEWPORTINFO]!= NULL);
        assert( m_RecFnCtr[ D3DDP2OP_WINFO]!= NULL);
        assert( m_RecFnCtr[ D3DDP2OP_RENDERSTATE]!= NULL);
        assert( m_RecFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= NULL);
        assert( m_RecFnCtr[ D3DDP2OP_SETVERTEXSHADER]!= NULL);
        assert( m_RecFnCtr[ D3DDP2OP_SETSTREAMSOURCE]!= NULL);
        assert( m_RecFnCtr[ D3DDP2OP_SETINDICES]!= NULL);
        // To remove this asserting, bind these functions to a different stub,
        // most likely a member function of TSuper, which does nothing; so that
        // they will not be equal to DP2Empty. Or use the default constructor.
    }
    ~CStdDrawPrimitives2() 
    { }

    // To determine number of const registers available to pixel shader.
    static DWORD GetNumPixelShaderConstReg( const DWORD dwPixelShaderVer)
    {
        switch(dwPixelShaderVer)
        {
        case( 0): return 0;
        case( D3DPS_VERSION(1,0)): return 8;
        case( D3DPS_VERSION(1,1)): return 8;
        case( D3DPS_VERSION(254,254)): return 2;
        case( D3DPS_VERSION(255,255)): return 16;
        default: {
                const bool Unrecognizable_Pixel_Shader_Version( false);
                assert( Unrecognizable_Pixel_Shader_Version);
            } break;
        }
        return 0;
    }

public: // Functions
    // Default implementataions for Capturing amounts of state, DX8 
    // pure device style.
    void CreateAndCaptureAllState( DWORD dwStateSetId)
    {
#if defined( D3D_ENABLE_SHADOW_BUFFER)
#if defined( D3D_ENABLE_SHADOW_JITTER)
        typedef block< D3DRENDERSTATETYPE, 78> TAllRSToCapture;
#else // !defined( D3D_ENABLE_SHADOW_JITTER)
        typedef block< D3DRENDERSTATETYPE, 75> TAllRSToCapture;
#endif // !defined( D3D_ENABLE_SHADOW_JITTER)
#else // !defined( D3D_ENABLE_SHADOW_BUFFER)
        typedef block< D3DRENDERSTATETYPE, 73> TAllRSToCapture;
#endif// !defined( D3D_ENABLE_SHADOW_BUFFER)
        const TAllRSToCapture AllRSToCapture=
        {
            D3DRENDERSTATE_SPECULARENABLE,
            D3DRENDERSTATE_ZENABLE,
            D3DRENDERSTATE_FILLMODE,
            D3DRENDERSTATE_SHADEMODE,
            D3DRENDERSTATE_LINEPATTERN,
            D3DRENDERSTATE_ZWRITEENABLE,
            D3DRENDERSTATE_ALPHATESTENABLE,
            D3DRENDERSTATE_LASTPIXEL,
            D3DRENDERSTATE_SRCBLEND,
            D3DRENDERSTATE_DESTBLEND,
            D3DRENDERSTATE_CULLMODE,
            D3DRENDERSTATE_ZFUNC,
            D3DRENDERSTATE_ALPHAREF,
            D3DRENDERSTATE_ALPHAFUNC,
            D3DRENDERSTATE_DITHERENABLE,
            D3DRENDERSTATE_FOGENABLE,
            D3DRENDERSTATE_STIPPLEDALPHA,
            D3DRENDERSTATE_FOGCOLOR,
            D3DRENDERSTATE_FOGTABLEMODE,
            D3DRENDERSTATE_FOGSTART,
            D3DRENDERSTATE_FOGEND,
            D3DRENDERSTATE_FOGDENSITY,
            D3DRENDERSTATE_EDGEANTIALIAS,
            D3DRENDERSTATE_ALPHABLENDENABLE,
            D3DRENDERSTATE_ZBIAS,
            D3DRENDERSTATE_RANGEFOGENABLE,
            D3DRENDERSTATE_STENCILENABLE,
            D3DRENDERSTATE_STENCILFAIL,
            D3DRENDERSTATE_STENCILZFAIL,
            D3DRENDERSTATE_STENCILPASS,
            D3DRENDERSTATE_STENCILFUNC,
            D3DRENDERSTATE_STENCILREF,
            D3DRENDERSTATE_STENCILMASK,
            D3DRENDERSTATE_STENCILWRITEMASK,
            D3DRENDERSTATE_TEXTUREFACTOR,
            D3DRENDERSTATE_WRAP0,
            D3DRENDERSTATE_WRAP1,
            D3DRENDERSTATE_WRAP2,
            D3DRENDERSTATE_WRAP3,
            D3DRENDERSTATE_WRAP4,
            D3DRENDERSTATE_WRAP5,
            D3DRENDERSTATE_WRAP6,
            D3DRENDERSTATE_WRAP7,
            D3DRENDERSTATE_AMBIENT,
            D3DRENDERSTATE_COLORVERTEX,
            D3DRENDERSTATE_FOGVERTEXMODE,
            D3DRENDERSTATE_CLIPPING,
            D3DRENDERSTATE_LIGHTING,
            D3DRENDERSTATE_NORMALIZENORMALS,
            D3DRENDERSTATE_LOCALVIEWER,
            D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
            D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
            D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
            D3DRENDERSTATE_SPECULARMATERIALSOURCE,
            D3DRENDERSTATE_VERTEXBLEND,
            D3DRENDERSTATE_CLIPPLANEENABLE,
            D3DRS_SOFTWAREVERTEXPROCESSING,
            D3DRS_POINTSIZE,
            D3DRS_POINTSIZE_MIN,
            D3DRS_POINTSPRITEENABLE,
            D3DRS_POINTSCALEENABLE,
            D3DRS_POINTSCALE_A,
            D3DRS_POINTSCALE_B,
            D3DRS_POINTSCALE_C,
            D3DRS_MULTISAMPLEANTIALIAS,
            D3DRS_MULTISAMPLEMASK,
            D3DRS_PATCHEDGESTYLE,
            D3DRS_PATCHSEGMENTS,
            D3DRS_POINTSIZE_MAX,
            D3DRS_INDEXEDVERTEXBLENDENABLE,
            D3DRS_COLORWRITEENABLE,
            D3DRS_TWEENFACTOR,
            D3DRS_BLENDOP,
#if defined( D3D_ENABLE_SHADOW_BUFFER)
            D3DRS_ZSLOPESCALE,
            D3DRS_ZCLAMP,
#if defined( D3D_ENABLE_SHADOW_JITTER)
            D3DRS_JITZBIASMIN,
            D3DRS_JITZBIASMAX,
            D3DRS_JITSHADOWSIZE,
#endif // defined( D3D_ENABLE_SHADOW_JITTER)
#endif // defined( D3D_ENABLE_SHADOW_BUFFER)
        };
#if defined( D3D_ENABLE_SHADOW_BUFFER)
#if defined( D3D_ENABLE_SHADOW_JITTER)
        assert( D3DRS_JITSHADOWSIZE== *AllRSToCapture.rbegin());
#else // !defined( D3D_ENABLE_SHADOW_JITTER)
        assert( D3DRS_ZCLAMP== *AllRSToCapture.rbegin());
#endif // !defined( D3D_ENABLE_SHADOW_JITTER)
#else // !defined( D3D_ENABLE_SHADOW_BUFFER)
        assert( D3DRS_BLENDOP== *AllRSToCapture.rbegin());
#endif // !defined( D3D_ENABLE_SHADOW_BUFFER)

#if defined( D3D_ENABLE_SHADOW_BUFFER)
        typedef block< D3DTEXTURESTAGESTATETYPE, 30> TAllTSSToCapture;
#else // !defined( D3D_ENABLE_SHADOW_BUFFER)
        typedef block< D3DTEXTURESTAGESTATETYPE, 27> TAllTSSToCapture;
#endif // !defined( D3D_ENABLE_SHADOW_BUFFER)
        const TAllTSSToCapture AllTSSToCapture=
        {
            D3DTSS_COLOROP,
            D3DTSS_COLORARG1,
            D3DTSS_COLORARG2,
            D3DTSS_ALPHAOP,
            D3DTSS_ALPHAARG1,
            D3DTSS_ALPHAARG2,
            D3DTSS_BUMPENVMAT00,
            D3DTSS_BUMPENVMAT01,
            D3DTSS_BUMPENVMAT10,
            D3DTSS_BUMPENVMAT11,
            D3DTSS_TEXCOORDINDEX,
            D3DTSS_ADDRESSU,
            D3DTSS_ADDRESSV,
            D3DTSS_BORDERCOLOR,
            D3DTSS_MAGFILTER,
            D3DTSS_MINFILTER,
            D3DTSS_MIPFILTER,
            D3DTSS_MIPMAPLODBIAS,
            D3DTSS_MAXMIPLEVEL,
            D3DTSS_MAXANISOTROPY,
            D3DTSS_BUMPENVLSCALE,
            D3DTSS_BUMPENVLOFFSET,
            D3DTSS_TEXTURETRANSFORMFLAGS,
            D3DTSS_ADDRESSW,
            D3DTSS_COLORARG0,
            D3DTSS_ALPHAARG0,
            D3DTSS_RESULTARG,
#if defined( D3D_ENABLE_SHADOW_BUFFER)
            D3DTSS_SHADOWNEARW,
            D3DTSS_SHADOWFARW,
            D3DTSS_SHADOWBUFFERENABLE,
#endif // defined( D3D_ENABLE_SHADOW_BUFFER)
        };
#if defined( D3D_ENABLE_SHADOW_BUFFER)
        assert( D3DTSS_SHADOWBUFFERENABLE== *AllTSSToCapture.rbegin());
#else // !defined( D3D_ENABLE_SHADOW_BUFFER)
        assert( D3DTSS_RESULTARG== *AllTSSToCapture.rbegin());
#endif // !defined( D3D_ENABLE_SHADOW_BUFFER)

        TSuper* pSThis= static_cast< TSuper*>( this);
        typedef typename TSuper::TPerDDrawData TPerDDrawData;
        typedef typename TPerDDrawData::TDriver TDriver;
        const DWORD dwTextureStages( D3DHAL_TSS_MAXSTAGES);
        const DWORD dwTextureMatrices( D3DHAL_TSS_MAXSTAGES);
        const DWORD dwClipPlanes( TDriver::GetCaps().MaxUserClipPlanes);
        const DWORD dwVertexShaderConsts( TDriver::GetCaps().MaxVertexShaderConst);
        const DWORD dwPixelShaderConsts( GetNumPixelShaderConstReg(
            TDriver::GetCaps().PixelShaderVersion));

        // Algorithm to determine maximum SetTransform Index to support.
        DWORD dwWorldMatrices( TDriver::GetCaps().MaxVertexBlendMatrixIndex+ 1);
        if( TDriver::GetCaps().MaxVertexBlendMatrices> dwWorldMatrices)
            dwWorldMatrices= TDriver::GetCaps().MaxVertexBlendMatrices;

        DWORD dwActiveLights( 0);
        size_t uiRecDP2BufferSize( 0);

        // Pass 1: Calculate size of DP2 buffer required.

        // Render States
        if( m_RecFnCtr[ D3DDP2OP_RENDERSTATE]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_RENDERSTATE]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                AllRSToCapture.size()* sizeof( D3DHAL_DP2RENDERSTATE);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_RENDERSTATE]== DP2Empty); }

        // Texture States
        if( m_RecFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= NULL&&
            dwTextureStages!= 0)
        {   assert( m_DefFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+ dwTextureStages*
                AllTSSToCapture.size()* sizeof( D3DHAL_DP2TEXTURESTAGESTATE);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]== DP2Empty); }

        // Viewport
        if( m_RecFnCtr[ D3DDP2OP_VIEWPORTINFO]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_VIEWPORTINFO]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2VIEWPORTINFO);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_VIEWPORTINFO]== DP2Empty); }

        // Transforms
        if( m_RecFnCtr[ D3DDP2OP_SETTRANSFORM]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETTRANSFORM]!= DP2Empty);

            // World, Texture, View, & Projection
            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2SETTRANSFORM)* (dwWorldMatrices+
                dwTextureMatrices+ 2);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETTRANSFORM]== DP2Empty); }

        // Clipplanes
        if( m_RecFnCtr[ D3DDP2OP_SETCLIPPLANE]!= NULL&& dwClipPlanes!= 0)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETCLIPPLANE]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2SETCLIPPLANE)* dwClipPlanes;
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETCLIPPLANE]== DP2Empty); }

        // Material
        if( m_RecFnCtr[ D3DDP2OP_SETMATERIAL]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETMATERIAL]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2SETMATERIAL);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETMATERIAL]== DP2Empty); }

        // Lights
        if( m_RecFnCtr[ D3DDP2OP_CREATELIGHT]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETLIGHT]!= DP2Empty);
            assert( m_DefFnCtr[ D3DDP2OP_CREATELIGHT]!= DP2Empty);

            // Special exception here. First, ask how many active lights there
            // are. We'll then prepare a buffer that the RecFnCtr function
            // will have to know what to do with (as this is the only case
            // that is not obvious how to handle). RecFnCtr will key off
            // bCommand== 0.

            const D3DHAL_DP2COMMAND DP2Cmd= {
                static_cast< D3DHAL_DP2OPERATION>( 0), 0 };
            
            // Ask for how many active lights in DP2ActiveLights.dwIndex;
            D3DHAL_DP2CREATELIGHT DP2ActiveLights= { 0 };
            (pSThis->*m_RecFnCtr[ D3DDP2OP_CREATELIGHT])(
                &DP2Cmd, &DP2ActiveLights);
            dwActiveLights= DP2ActiveLights.dwIndex;
            
            if( dwActiveLights!= 0)
            {
                // Create structures.
                uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+ dwActiveLights*
                    sizeof( D3DHAL_DP2CREATELIGHT);
                // Set structures.
                uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+ dwActiveLights*
                    (2* sizeof( D3DHAL_DP2SETLIGHT)+ sizeof( D3DLIGHT8));
            }
        }
        else {
            assert( m_DefFnCtr[ D3DDP2OP_SETLIGHT]== DP2Empty);
            assert( m_DefFnCtr[ D3DDP2OP_CREATELIGHT]== DP2Empty);
        }

        // Vertex Shader
        if( m_RecFnCtr[ D3DDP2OP_SETVERTEXSHADER]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETVERTEXSHADER]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2VERTEXSHADER);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETVERTEXSHADER]== DP2Empty); }
        
        // Pixel Shader
        if( m_RecFnCtr[ D3DDP2OP_SETPIXELSHADER]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETPIXELSHADER]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2PIXELSHADER);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETPIXELSHADER]== DP2Empty); }

        // Vertex Shader Constants
        if( m_RecFnCtr[ D3DDP2OP_SETVERTEXSHADERCONST]!= NULL&&
            dwVertexShaderConsts!= 0)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETVERTEXSHADERCONST]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2SETVERTEXSHADERCONST)+
                dwVertexShaderConsts* 4* sizeof(D3DVALUE);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETVERTEXSHADERCONST]== DP2Empty); }

        // Pixel Shader Constants
        if( m_RecFnCtr[ D3DDP2OP_SETPIXELSHADERCONST]!= NULL&&
            dwPixelShaderConsts!= 0)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETPIXELSHADERCONST]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2SETPIXELSHADERCONST)+
                dwPixelShaderConsts* 4* sizeof(D3DVALUE);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETPIXELSHADERCONST]== DP2Empty); }

        // Pass 2: Build command buffer for states.
        UINT8* pTempBuffer= NULL;
        try {
            pTempBuffer= reinterpret_cast< UINT8*>( 
                operator new ( uiRecDP2BufferSize));
        } catch ( ... ) {
        }
        if( NULL== pTempBuffer)
            throw bad_alloc( "Not enough room for StateSet");

        D3DHAL_DP2COMMAND* pStartSSet= reinterpret_cast< D3DHAL_DP2COMMAND*>(
            pTempBuffer);
        D3DHAL_DP2COMMAND* pCur= pStartSSet;
        D3DHAL_DP2COMMAND* pEndSSet= reinterpret_cast< D3DHAL_DP2COMMAND*>(
            pTempBuffer+ uiRecDP2BufferSize);

        // Render States
        if( m_RecFnCtr[ D3DDP2OP_RENDERSTATE]!= NULL)
        {
            pCur->bCommand= D3DDP2OP_RENDERSTATE;
            pCur->wStateCount= static_cast< WORD>( AllRSToCapture.size());

            D3DHAL_DP2RENDERSTATE* pParam=
                reinterpret_cast< D3DHAL_DP2RENDERSTATE*>( pCur+ 1);

            TAllRSToCapture::const_iterator itRS( AllRSToCapture.begin());
            while( itRS!= AllRSToCapture.end())
            {
                pParam->RenderState= *itRS;
                ++itRS;
                ++pParam;
            }

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam);
        }

        // Texture States
        if( m_RecFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= NULL&&
            dwTextureStages!= 0)
        {
            pCur->bCommand= D3DDP2OP_TEXTURESTAGESTATE;
            pCur->wStateCount= static_cast< WORD>( dwTextureStages*
                AllTSSToCapture.size());

            D3DHAL_DP2TEXTURESTAGESTATE* pParam=
                reinterpret_cast< D3DHAL_DP2TEXTURESTAGESTATE*>( pCur+ 1);

            for( WORD wStage( 0); wStage< dwTextureStages; ++wStage)
            {
                TAllTSSToCapture::const_iterator itTSS( AllTSSToCapture.begin());
                while( itTSS!= AllTSSToCapture.end())
                {
                    pParam->wStage= wStage;
                    pParam->TSState= *itTSS;
                    ++itTSS;
                    ++pParam;
                }
            }

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam);
        }

        // Viewport
        if( m_RecFnCtr[ D3DDP2OP_VIEWPORTINFO]!= NULL)
        {
            pCur->bCommand= D3DDP2OP_VIEWPORTINFO;
            pCur->wStateCount= 1;

            D3DHAL_DP2VIEWPORTINFO* pParam=
                reinterpret_cast< D3DHAL_DP2VIEWPORTINFO*>( pCur+ 1);

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam+ 1);
        }

        // Transforms
        if( m_RecFnCtr[ D3DDP2OP_SETTRANSFORM]!= NULL)
        {
            pCur->bCommand= D3DDP2OP_SETTRANSFORM;
            pCur->wStateCount= static_cast< WORD>( dwWorldMatrices+
                dwTextureMatrices+ 2);

            D3DHAL_DP2SETTRANSFORM* pParam=
                reinterpret_cast< D3DHAL_DP2SETTRANSFORM*>( pCur+ 1);

            pParam->xfrmType= D3DTRANSFORMSTATE_PROJECTION;
            ++pParam;

            pParam->xfrmType= D3DTRANSFORMSTATE_VIEW;
            ++pParam;

            for( DWORD dwTM( 0); dwTM< dwTextureMatrices; ++dwTM)
            {
                pParam->xfrmType= static_cast< D3DTRANSFORMSTATETYPE>(
                    D3DTRANSFORMSTATE_TEXTURE0+ dwTM);
                ++pParam;
            }

            for( DWORD dwWM( 0); dwWM< dwWorldMatrices; ++dwWM)
            {
                pParam->xfrmType= D3DTS_WORLDMATRIX( dwWM);
                ++pParam;
            }

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam);
        }

        // Clipplanes
        if( m_RecFnCtr[ D3DDP2OP_SETCLIPPLANE]!= NULL&& dwClipPlanes!= 0)
        {
            pCur->bCommand= D3DDP2OP_SETCLIPPLANE;
            pCur->wStateCount= static_cast< WORD>( dwClipPlanes);

            D3DHAL_DP2SETCLIPPLANE* pParam=
                reinterpret_cast< D3DHAL_DP2SETCLIPPLANE*>( pCur+ 1);

            for( DWORD dwCP( 0); dwCP< dwClipPlanes; ++dwCP)
            {
                pParam->dwIndex= dwCP;
                ++pParam;
            }

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam);
        }

        // Material
        if( m_RecFnCtr[ D3DDP2OP_SETMATERIAL]!= NULL)
        {
            pCur->bCommand= D3DDP2OP_SETMATERIAL;
            pCur->wStateCount= 1;

            D3DHAL_DP2SETMATERIAL* pParam=
                reinterpret_cast< D3DHAL_DP2SETMATERIAL*>( pCur+ 1);

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam+ 1);
        }

        // Lights
        if( m_RecFnCtr[ D3DDP2OP_CREATELIGHT]!= NULL&& dwActiveLights!= 0)
        {
            // Special exception here. First, we asked how many active lights
            // there were. The RecFnCtr function will have to know what to do
            // with this buffer. We now give it a chance to fill in the
            // light ids. RecFnCtr will key off bCommand== 0.
            pCur->bCommand= static_cast< D3DHAL_DP2OPERATION>( 0);
            pCur->wStateCount= static_cast< WORD>( dwActiveLights);

            D3DHAL_DP2CREATELIGHT* pParam=
                reinterpret_cast< D3DHAL_DP2CREATELIGHT*>( pCur+ 1);
            (pSThis->*m_RecFnCtr[ D3DDP2OP_CREATELIGHT])(
                pCur, pParam);

            // Change back the bCommand for proper usage later.
            pCur->bCommand= D3DDP2OP_CREATELIGHT;
            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam+ dwActiveLights);

            // Now, with the light ids in the CREATELIGHT structures, we can
            // fill out SETLIGHT structures with ids correctly.
            pCur->bCommand= D3DDP2OP_SETLIGHT;
            pCur->wStateCount= static_cast< WORD>( 2* dwActiveLights);

            D3DHAL_DP2SETLIGHT* pSParam=
                reinterpret_cast< D3DHAL_DP2SETLIGHT*>( pCur+ 1);

            for( DWORD dwL( 0); dwL< dwActiveLights; ++dwL)
            {
                pSParam->dwIndex= pParam->dwIndex;
                pSParam->dwDataType= D3DHAL_SETLIGHT_DATA;
                D3DLIGHT8* pLight= reinterpret_cast< D3DLIGHT8*>( pSParam+ 1);

                pSParam= reinterpret_cast< D3DHAL_DP2SETLIGHT*>( pLight+ 1);
                pSParam->dwIndex= pParam->dwIndex;
                pSParam->dwDataType= D3DHAL_SETLIGHT_DISABLE;
                ++pParam;
                ++pSParam;
            }

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pSParam);
        }

        // Vertex Shader
        if( m_RecFnCtr[ D3DDP2OP_SETVERTEXSHADER]!= NULL)
        {
            pCur->bCommand= D3DDP2OP_SETVERTEXSHADER;
            pCur->wStateCount= 1;

            D3DHAL_DP2VERTEXSHADER* pParam=
                reinterpret_cast< D3DHAL_DP2VERTEXSHADER*>( pCur+ 1);

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam+ 1);
        }
        
        // Pixel Shader
        if( m_RecFnCtr[ D3DDP2OP_SETPIXELSHADER]!= NULL)
        {
            pCur->bCommand= D3DDP2OP_SETPIXELSHADER;
            pCur->wStateCount= 1;

            D3DHAL_DP2PIXELSHADER* pParam=
                reinterpret_cast< D3DHAL_DP2PIXELSHADER*>( pCur+ 1);

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam+ 1);
        }

        // Vertex Shader Constants
        if( m_RecFnCtr[ D3DDP2OP_SETVERTEXSHADERCONST]!= NULL&&
            dwVertexShaderConsts!= 0)
        {
            pCur->bCommand= D3DDP2OP_SETVERTEXSHADERCONST;
            pCur->wStateCount= 1;

            D3DHAL_DP2SETVERTEXSHADERCONST* pParam=
                reinterpret_cast< D3DHAL_DP2SETVERTEXSHADERCONST*>( pCur+ 1);
            pParam->dwRegister= 0;
            pParam->dwCount= dwVertexShaderConsts;

            D3DVALUE* pFloat= reinterpret_cast< D3DVALUE*>( pParam+ 1);
            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>(
                pFloat+ 4* dwVertexShaderConsts);
        }

        // Pixel Shader Constants
        if( m_RecFnCtr[ D3DDP2OP_SETPIXELSHADERCONST]!= NULL&&
            dwPixelShaderConsts!= 0)
        {
            pCur->bCommand= D3DDP2OP_SETPIXELSHADERCONST;
            pCur->wStateCount= 1;

            D3DHAL_DP2SETPIXELSHADERCONST* pParam=
                reinterpret_cast< D3DHAL_DP2SETPIXELSHADERCONST*>( pCur+ 1);
            pParam->dwRegister= 0;
            pParam->dwCount= dwPixelShaderConsts;

            D3DVALUE* pFloat= reinterpret_cast< D3DVALUE*>( pParam+ 1);
            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>(
                pFloat+ 4* dwPixelShaderConsts);
        }

        assert( reinterpret_cast< D3DHAL_DP2COMMAND*>( pCur)== pEndSSet);

        // Finally, build stateset.
        pair< TSSDB::iterator, bool> Ret;
        try {
            Ret= m_StateSetDB.insert( TSSDB::value_type(
                dwStateSetId, TStateSet( *pSThis, pStartSSet, pEndSSet)));
            assert( Ret.second);
        } catch ( ... ) {
            operator delete ( static_cast< void*>( pTempBuffer));
            throw;
        }

        // Now, capture it.
        Ret.first->second.Capture( *pSThis);
    }

    void CreateAndCapturePixelState( DWORD dwStateSetId)
    {
#if defined( D3D_ENABLE_SHADOW_BUFFER)
#if defined( D3D_ENABLE_SHADOW_JITTER)
        typedef block< D3DRENDERSTATETYPE, 44> TPixRSToCapture;
#else // !defined( D3D_ENABLE_SHADOW_JITTER)
        typedef block< D3DRENDERSTATETYPE, 41> TPixRSToCapture;
#endif // !defined( D3D_ENABLE_SHADOW_JITTER)
#else // !defined( D3D_ENABLE_SHADOW_BUFFER)
        typedef block< D3DRENDERSTATETYPE, 39> TPixRSToCapture;
#endif // !defined( D3D_ENABLE_SHADOW_BUFFER)
        const TPixRSToCapture PixRSToCapture=
        {
            D3DRENDERSTATE_ZENABLE,
            D3DRENDERSTATE_FILLMODE,
            D3DRENDERSTATE_SHADEMODE,
            D3DRENDERSTATE_LINEPATTERN,
            D3DRENDERSTATE_ZWRITEENABLE,
            D3DRENDERSTATE_ALPHATESTENABLE,
            D3DRENDERSTATE_LASTPIXEL,
            D3DRENDERSTATE_SRCBLEND,
            D3DRENDERSTATE_DESTBLEND,
            D3DRENDERSTATE_ZFUNC,
            D3DRENDERSTATE_ALPHAREF,
            D3DRENDERSTATE_ALPHAFUNC,
            D3DRENDERSTATE_DITHERENABLE,
            D3DRENDERSTATE_STIPPLEDALPHA,
            D3DRENDERSTATE_FOGSTART,
            D3DRENDERSTATE_FOGEND,
            D3DRENDERSTATE_FOGDENSITY,
            D3DRENDERSTATE_EDGEANTIALIAS,
            D3DRENDERSTATE_ALPHABLENDENABLE,
            D3DRENDERSTATE_ZBIAS,
            D3DRENDERSTATE_STENCILENABLE,
            D3DRENDERSTATE_STENCILFAIL,
            D3DRENDERSTATE_STENCILZFAIL,
            D3DRENDERSTATE_STENCILPASS,
            D3DRENDERSTATE_STENCILFUNC,
            D3DRENDERSTATE_STENCILREF,
            D3DRENDERSTATE_STENCILMASK,
            D3DRENDERSTATE_STENCILWRITEMASK,
            D3DRENDERSTATE_TEXTUREFACTOR,
            D3DRENDERSTATE_WRAP0,
            D3DRENDERSTATE_WRAP1,
            D3DRENDERSTATE_WRAP2,
            D3DRENDERSTATE_WRAP3,
            D3DRENDERSTATE_WRAP4,
            D3DRENDERSTATE_WRAP5,
            D3DRENDERSTATE_WRAP6,
            D3DRENDERSTATE_WRAP7,
            D3DRS_COLORWRITEENABLE,
            D3DRS_BLENDOP,
#if defined( D3D_ENABLE_SHADOW_BUFFER)
            D3DRS_ZSLOPESCALE,
            D3DRS_ZCLAMP,
#if defined( D3D_ENABLE_SHADOW_JITTER)
            D3DRS_JITZBIASMIN,
            D3DRS_JITZBIASMAX,
            D3DRS_JITSHADOWSIZE,
#endif // defined( D3D_ENABLE_SHADOW_JITTER)
#endif // defined( D3D_ENABLE_SHADOW_BUFFER)
        };
#if defined( D3D_ENABLE_SHADOW_BUFFER)
#if defined( D3D_ENABLE_SHADOW_JITTER)
        assert( D3DRS_JITSHADOWSIZE== *PixRSToCapture.rbegin());
#else // !defined( D3D_ENABLE_SHADOW_JITTER)
        assert( D3DRS_ZCLAMP== *PixRSToCapture.rbegin());
#endif // !defined( D3D_ENABLE_SHADOW_JITTER)
#else // !defined( D3D_ENABLE_SHADOW_BUFFER)
        assert( D3DRS_BLENDOP== *PixRSToCapture.rbegin());
#endif // !defined( D3D_ENABLE_SHADOW_BUFFER)

#if defined( D3D_ENABLE_SHADOW_BUFFER)
        typedef block< D3DTEXTURESTAGESTATETYPE, 30> TPixTSSToCapture;
#else // !defined( D3D_ENABLE_SHADOW_BUFFER)
        typedef block< D3DTEXTURESTAGESTATETYPE, 27> TPixTSSToCapture;
#endif // !defined( D3D_ENABLE_SHADOW_BUFFER)
        const TPixTSSToCapture PixTSSToCapture=
        {
            D3DTSS_COLOROP,
            D3DTSS_COLORARG1,
            D3DTSS_COLORARG2,
            D3DTSS_ALPHAOP,
            D3DTSS_ALPHAARG1,
            D3DTSS_ALPHAARG2,
            D3DTSS_BUMPENVMAT00,
            D3DTSS_BUMPENVMAT01,
            D3DTSS_BUMPENVMAT10,
            D3DTSS_BUMPENVMAT11,
            D3DTSS_TEXCOORDINDEX,
            D3DTSS_ADDRESSU,
            D3DTSS_ADDRESSV,
            D3DTSS_BORDERCOLOR,
            D3DTSS_MAGFILTER,
            D3DTSS_MINFILTER,
            D3DTSS_MIPFILTER,
            D3DTSS_MIPMAPLODBIAS,
            D3DTSS_MAXMIPLEVEL,
            D3DTSS_MAXANISOTROPY,
            D3DTSS_BUMPENVLSCALE,
            D3DTSS_BUMPENVLOFFSET,
            D3DTSS_TEXTURETRANSFORMFLAGS,
            D3DTSS_ADDRESSW,
            D3DTSS_COLORARG0,
            D3DTSS_ALPHAARG0,
            D3DTSS_RESULTARG,
#if defined( D3D_ENABLE_SHADOW_BUFFER)
            D3DTSS_SHADOWNEARW,
            D3DTSS_SHADOWFARW,
            D3DTSS_SHADOWBUFFERENABLE,
#endif // defined( D3D_ENABLE_SHADOW_BUFFER)
        };
#if defined( D3D_ENABLE_SHADOW_BUFFER)
        assert( D3DTSS_SHADOWBUFFERENABLE== *PixTSSToCapture.rbegin());
#else // !defined( D3D_ENABLE_SHADOW_BUFFER)
        assert( D3DTSS_RESULTARG== *PixTSSToCapture.rbegin());
#endif // !defined( D3D_ENABLE_SHADOW_BUFFER)

        TSuper* pSThis= static_cast< TSuper*>( this);
        typedef typename TSuper::TPerDDrawData TPerDDrawData;
        typedef typename TPerDDrawData::TDriver TDriver;
        const DWORD dwTextureStages( D3DHAL_TSS_MAXSTAGES);
        const DWORD dwPixelShaderConsts( GetNumPixelShaderConstReg(
            TDriver::GetCaps().PixelShaderVersion));

        size_t uiRecDP2BufferSize( 0);

        // Pass 1: Calculate size of DP2 buffer required.

        // Render States
        if( m_RecFnCtr[ D3DDP2OP_RENDERSTATE]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_RENDERSTATE]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                PixRSToCapture.size()* sizeof( D3DHAL_DP2RENDERSTATE);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_RENDERSTATE]== DP2Empty); }

        // Texture States
        if( m_RecFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= NULL&&
            dwTextureStages!= 0)
        {   assert( m_DefFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+ dwTextureStages*
                PixTSSToCapture.size()* sizeof( D3DHAL_DP2TEXTURESTAGESTATE);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]== DP2Empty); }

        // Pixel Shader
        if( m_RecFnCtr[ D3DDP2OP_SETPIXELSHADER]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETPIXELSHADER]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2PIXELSHADER);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETPIXELSHADER]== DP2Empty); }

        // Pixel Shader Constants
        if( m_RecFnCtr[ D3DDP2OP_SETPIXELSHADERCONST]!= NULL&&
            dwPixelShaderConsts!= 0)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETPIXELSHADERCONST]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2SETPIXELSHADERCONST)+
                dwPixelShaderConsts* 4* sizeof(D3DVALUE);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETPIXELSHADERCONST]== DP2Empty); }

        // Pass 2: Build command buffer for states.
        UINT8* pTempBuffer= NULL;
        try {
            pTempBuffer= reinterpret_cast< UINT8*>( 
                operator new ( uiRecDP2BufferSize));
        } catch ( ... ) {
        }
        if( NULL== pTempBuffer)
            throw bad_alloc( "Not enough room for StateSet");

        D3DHAL_DP2COMMAND* pStartSSet= reinterpret_cast< D3DHAL_DP2COMMAND*>(
            pTempBuffer);
        D3DHAL_DP2COMMAND* pCur= pStartSSet;
        D3DHAL_DP2COMMAND* pEndSSet= reinterpret_cast< D3DHAL_DP2COMMAND*>(
            pTempBuffer+ uiRecDP2BufferSize);

        // Render States
        if( m_RecFnCtr[ D3DDP2OP_RENDERSTATE]!= NULL)
        {
            pCur->bCommand= D3DDP2OP_RENDERSTATE;
            pCur->wStateCount= static_cast< WORD>( PixRSToCapture.size());

            D3DHAL_DP2RENDERSTATE* pParam=
                reinterpret_cast< D3DHAL_DP2RENDERSTATE*>( pCur+ 1);

            TPixRSToCapture::const_iterator itRS( PixRSToCapture.begin());
            while( itRS!= PixRSToCapture.end())
            {
                pParam->RenderState= *itRS;
                ++itRS;
                ++pParam;
            }

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam);
        }

        // Texture States
        if( m_RecFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= NULL&&
            dwTextureStages!= 0)
        {
            pCur->bCommand= D3DDP2OP_TEXTURESTAGESTATE;
            pCur->wStateCount= static_cast< WORD>( dwTextureStages*
                PixTSSToCapture.size());

            D3DHAL_DP2TEXTURESTAGESTATE* pParam=
                reinterpret_cast< D3DHAL_DP2TEXTURESTAGESTATE*>( pCur+ 1);

            for( WORD wStage( 0); wStage< dwTextureStages; ++wStage)
            {
                TPixTSSToCapture::const_iterator itTSS( PixTSSToCapture.begin());
                while( itTSS!= PixTSSToCapture.end())
                {
                    pParam->wStage= wStage;
                    pParam->TSState= *itTSS;
                    ++itTSS;
                    ++pParam;
                }
            }

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam);
        }

        // Pixel Shader
        if( m_RecFnCtr[ D3DDP2OP_SETPIXELSHADER]!= NULL)
        {
            pCur->bCommand= D3DDP2OP_SETPIXELSHADER;
            pCur->wStateCount= 1;

            D3DHAL_DP2PIXELSHADER* pParam=
                reinterpret_cast< D3DHAL_DP2PIXELSHADER*>( pCur+ 1);

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam+ 1);
        }

        // Pixel Shader Constants
        if( m_RecFnCtr[ D3DDP2OP_SETPIXELSHADERCONST]!= NULL&&
            dwPixelShaderConsts!= 0)
        {
            pCur->bCommand= D3DDP2OP_SETPIXELSHADERCONST;
            pCur->wStateCount= 1;

            D3DHAL_DP2SETPIXELSHADERCONST* pParam=
                reinterpret_cast< D3DHAL_DP2SETPIXELSHADERCONST*>( pCur+ 1);
            pParam->dwRegister= 0;
            pParam->dwCount= dwPixelShaderConsts;

            D3DVALUE* pFloat= reinterpret_cast< D3DVALUE*>( pParam+ 1);
            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>(
                pFloat+ 4* dwPixelShaderConsts);
        }

        assert( reinterpret_cast< D3DHAL_DP2COMMAND*>( pCur)== pEndSSet);

        // Finally, build stateset.
        pair< TSSDB::iterator, bool> Ret;
        try {
            Ret= m_StateSetDB.insert( TSSDB::value_type(
                dwStateSetId, TStateSet( *pSThis, pStartSSet, pEndSSet)));
            assert( Ret.second);
        } catch ( ... ) {
            operator delete ( static_cast< void*>( pTempBuffer));
            throw;
        }

        // Now, capture it.
        Ret.first->second.Capture( *pSThis);
    }

    void CreateAndCaptureVertexState( DWORD dwStateSetId)
    {
        typedef block< D3DRENDERSTATETYPE, 38> TVtxRSToCapture;
        const TVtxRSToCapture VtxRSToCapture=
        {
            D3DRENDERSTATE_SPECULARENABLE,
            D3DRENDERSTATE_SHADEMODE,
            D3DRENDERSTATE_CULLMODE,
            D3DRENDERSTATE_FOGENABLE,
            D3DRENDERSTATE_FOGCOLOR,
            D3DRENDERSTATE_FOGTABLEMODE,
            D3DRENDERSTATE_FOGSTART,
            D3DRENDERSTATE_FOGEND,
            D3DRENDERSTATE_FOGDENSITY,
            D3DRENDERSTATE_RANGEFOGENABLE,
            D3DRENDERSTATE_AMBIENT,
            D3DRENDERSTATE_COLORVERTEX,
            D3DRENDERSTATE_FOGVERTEXMODE,
            D3DRENDERSTATE_CLIPPING,
            D3DRENDERSTATE_LIGHTING,
            D3DRENDERSTATE_NORMALIZENORMALS,
            D3DRENDERSTATE_LOCALVIEWER,
            D3DRENDERSTATE_EMISSIVEMATERIALSOURCE,
            D3DRENDERSTATE_AMBIENTMATERIALSOURCE,
            D3DRENDERSTATE_DIFFUSEMATERIALSOURCE,
            D3DRENDERSTATE_SPECULARMATERIALSOURCE,
            D3DRENDERSTATE_VERTEXBLEND,
            D3DRENDERSTATE_CLIPPLANEENABLE,
            D3DRS_SOFTWAREVERTEXPROCESSING,
            D3DRS_POINTSIZE,
            D3DRS_POINTSIZE_MIN,
            D3DRS_POINTSPRITEENABLE,
            D3DRS_POINTSCALEENABLE,
            D3DRS_POINTSCALE_A,
            D3DRS_POINTSCALE_B,
            D3DRS_POINTSCALE_C,
            D3DRS_MULTISAMPLEANTIALIAS,
            D3DRS_MULTISAMPLEMASK,
            D3DRS_PATCHEDGESTYLE,
            D3DRS_PATCHSEGMENTS,
            D3DRS_POINTSIZE_MAX,
            D3DRS_INDEXEDVERTEXBLENDENABLE,
            D3DRS_TWEENFACTOR
        };
        assert( D3DRS_TWEENFACTOR== *VtxRSToCapture.rbegin());
        typedef block< D3DTEXTURESTAGESTATETYPE, 2> TVtxTSSToCapture;
        const TVtxTSSToCapture VtxTSSToCapture=
        {
            D3DTSS_TEXCOORDINDEX,
            D3DTSS_TEXTURETRANSFORMFLAGS
        };
        assert( D3DTSS_TEXTURETRANSFORMFLAGS== *VtxTSSToCapture.rbegin());

        TSuper* pSThis= static_cast< TSuper*>( this);
        typedef typename TSuper::TPerDDrawData TPerDDrawData;
        typedef typename TPerDDrawData::TDriver TDriver;
        const DWORD dwTextureStages( D3DHAL_TSS_MAXSTAGES);
        const DWORD dwVertexShaderConsts( TDriver::GetCaps().MaxVertexShaderConst);
        DWORD dwActiveLights( 0);

        size_t uiRecDP2BufferSize( 0);

        // Pass 1: Calculate size of DP2 buffer required.

        // Render States
        if( m_RecFnCtr[ D3DDP2OP_RENDERSTATE]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_RENDERSTATE]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                VtxRSToCapture.size()* sizeof( D3DHAL_DP2RENDERSTATE);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_RENDERSTATE]== DP2Empty); }

        // Texture States
        if( m_RecFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= NULL&&
            dwTextureStages!= 0)
        {   assert( m_DefFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+ dwTextureStages*
                VtxTSSToCapture.size()* sizeof( D3DHAL_DP2TEXTURESTAGESTATE);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]== DP2Empty); }

        // Lights
        if( m_RecFnCtr[ D3DDP2OP_CREATELIGHT]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETLIGHT]!= DP2Empty);
            assert( m_DefFnCtr[ D3DDP2OP_CREATELIGHT]!= DP2Empty);

            // Special exception here. First, ask how many active lights there
            // are. We'll then prepare a buffer that the RecFnCtr function
            // will have to know what to do with (as this is the only case
            // that is not obvious how to handle). RecFnCtr will key off
            // bCommand== 0.

            const D3DHAL_DP2COMMAND DP2Cmd= {
                static_cast< D3DHAL_DP2OPERATION>( 0), 0 };
            
            // Ask for how many active lights in DP2ActiveLights.dwIndex;
            D3DHAL_DP2CREATELIGHT DP2ActiveLights= { 0 };
            (pSThis->*m_RecFnCtr[ D3DDP2OP_CREATELIGHT])(
                &DP2Cmd, &DP2ActiveLights);
            dwActiveLights= DP2ActiveLights.dwIndex;
            
            if( dwActiveLights!= 0)
            {
                // Create structures.
                uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+ dwActiveLights*
                    sizeof( D3DHAL_DP2CREATELIGHT);
                // Set structures.
                uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+ dwActiveLights*
                    (2* sizeof( D3DHAL_DP2SETLIGHT)+ sizeof( D3DLIGHT8));
            }
        }
        else {
            assert( m_DefFnCtr[ D3DDP2OP_SETLIGHT]== DP2Empty);
            assert( m_DefFnCtr[ D3DDP2OP_CREATELIGHT]== DP2Empty);
        }

        // Vertex Shader
        if( m_RecFnCtr[ D3DDP2OP_SETVERTEXSHADER]!= NULL)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETVERTEXSHADER]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2VERTEXSHADER);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETVERTEXSHADER]== DP2Empty); }
        
        // Vertex Shader Constants
        if( m_RecFnCtr[ D3DDP2OP_SETVERTEXSHADERCONST]!= NULL&&
            dwVertexShaderConsts!= 0)
        {   assert( m_DefFnCtr[ D3DDP2OP_SETVERTEXSHADERCONST]!= DP2Empty);

            uiRecDP2BufferSize+= sizeof( D3DHAL_DP2COMMAND)+
                sizeof( D3DHAL_DP2SETVERTEXSHADERCONST)+
                dwVertexShaderConsts* 4* sizeof(D3DVALUE);
        }
        else { assert( m_DefFnCtr[ D3DDP2OP_SETVERTEXSHADERCONST]== DP2Empty); }

        // Pass 2: Build command buffer for states.
        UINT8* pTempBuffer= NULL;
        try {
            pTempBuffer= reinterpret_cast< UINT8*>( 
                operator new ( uiRecDP2BufferSize));
        } catch ( ... ) {
        }
        if( NULL== pTempBuffer)
            throw bad_alloc( "Not enough room for StateSet");

        D3DHAL_DP2COMMAND* pStartSSet= reinterpret_cast< D3DHAL_DP2COMMAND*>(
            pTempBuffer);
        D3DHAL_DP2COMMAND* pCur= pStartSSet;
        D3DHAL_DP2COMMAND* pEndSSet= reinterpret_cast< D3DHAL_DP2COMMAND*>(
            pTempBuffer+ uiRecDP2BufferSize);

        // Render States
        if( m_RecFnCtr[ D3DDP2OP_RENDERSTATE]!= NULL)
        {
            pCur->bCommand= D3DDP2OP_RENDERSTATE;
            pCur->wStateCount= static_cast< WORD>( VtxRSToCapture.size());

            D3DHAL_DP2RENDERSTATE* pParam=
                reinterpret_cast< D3DHAL_DP2RENDERSTATE*>( pCur+ 1);

            TVtxRSToCapture::const_iterator itRS( VtxRSToCapture.begin());
            while( itRS!= VtxRSToCapture.end())
            {
                pParam->RenderState= *itRS;
                ++itRS;
                ++pParam;
            }

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam);
        }

        // Texture States
        if( m_RecFnCtr[ D3DDP2OP_TEXTURESTAGESTATE]!= NULL&&
            dwTextureStages!= 0)
        {
            pCur->bCommand= D3DDP2OP_TEXTURESTAGESTATE;
            pCur->wStateCount= static_cast< WORD>( dwTextureStages*
                VtxTSSToCapture.size());

            D3DHAL_DP2TEXTURESTAGESTATE* pParam=
                reinterpret_cast< D3DHAL_DP2TEXTURESTAGESTATE*>( pCur+ 1);

            for( WORD wStage( 0); wStage< dwTextureStages; ++wStage)
            {
                TVtxTSSToCapture::const_iterator itTSS( VtxTSSToCapture.begin());
                while( itTSS!= VtxTSSToCapture.end())
                {
                    pParam->wStage= wStage;
                    pParam->TSState= *itTSS;
                    ++itTSS;
                    ++pParam;
                }
            }

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam);
        }

        // Lights
        if( m_RecFnCtr[ D3DDP2OP_CREATELIGHT]!= NULL&& dwActiveLights!= 0)
        {
            // Special exception here. First, we asked how many active lights
            // there were. The RecFnCtr function will have to know what to do
            // with this buffer. We now give it a chance to fill in the
            // light ids. RecFnCtr will key off bCommand== 0.
            pCur->bCommand= static_cast< D3DHAL_DP2OPERATION>( 0);
            pCur->wStateCount= static_cast< WORD>( dwActiveLights);

            D3DHAL_DP2CREATELIGHT* pParam=
                reinterpret_cast< D3DHAL_DP2CREATELIGHT*>( pCur+ 1);
            (pSThis->*m_RecFnCtr[ D3DDP2OP_CREATELIGHT])(
                pCur, pParam);

            // Change back the bCommand for proper usage later.
            pCur->bCommand= D3DDP2OP_CREATELIGHT;
            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam+ dwActiveLights);

            // Now, with the light ids in the CREATELIGHT structures, we can
            // fill out SETLIGHT structures with ids correctly.
            pCur->bCommand= D3DDP2OP_SETLIGHT;
            pCur->wStateCount= static_cast< WORD>( 2* dwActiveLights);

            D3DHAL_DP2SETLIGHT* pSParam=
                reinterpret_cast< D3DHAL_DP2SETLIGHT*>( pCur+ 1);

            for( DWORD dwL( 0); dwL< dwActiveLights; ++dwL)
            {
                pSParam->dwIndex= pParam->dwIndex;
                pSParam->dwDataType= D3DHAL_SETLIGHT_DATA;
                D3DLIGHT8* pLight= reinterpret_cast< D3DLIGHT8*>( pSParam+ 1);

                pSParam= reinterpret_cast< D3DHAL_DP2SETLIGHT*>( pLight+ 1);
                pSParam->dwIndex= pParam->dwIndex;
                pSParam->dwDataType= D3DHAL_SETLIGHT_DISABLE;
                ++pParam;
                ++pSParam;
            }

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pSParam);
        }

        // Vertex Shader
        if( m_RecFnCtr[ D3DDP2OP_SETVERTEXSHADER]!= NULL)
        {
            pCur->bCommand= D3DDP2OP_SETVERTEXSHADER;
            pCur->wStateCount= 1;

            D3DHAL_DP2VERTEXSHADER* pParam=
                reinterpret_cast< D3DHAL_DP2VERTEXSHADER*>( pCur+ 1);

            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>( pParam+ 1);
        }
        
        // Vertex Shader Constants
        if( m_RecFnCtr[ D3DDP2OP_SETVERTEXSHADERCONST]!= NULL&&
            dwVertexShaderConsts!= 0)
        {
            pCur->bCommand= D3DDP2OP_SETVERTEXSHADERCONST;
            pCur->wStateCount= 1;

            D3DHAL_DP2SETVERTEXSHADERCONST* pParam=
                reinterpret_cast< D3DHAL_DP2SETVERTEXSHADERCONST*>( pCur+ 1);
            pParam->dwRegister= 0;
            pParam->dwCount= dwVertexShaderConsts;

            D3DVALUE* pFloat= reinterpret_cast< D3DVALUE*>( pParam+ 1);
            pCur= reinterpret_cast< D3DHAL_DP2COMMAND*>(
                pFloat+ 4* dwVertexShaderConsts);
        }

        assert( reinterpret_cast< D3DHAL_DP2COMMAND*>( pCur)== pEndSSet);

        // Finally, build stateset.
        pair< TSSDB::iterator, bool> Ret;
        try {
            Ret= m_StateSetDB.insert( TSSDB::value_type(
                dwStateSetId, TStateSet( *pSThis, pStartSSet, pEndSSet)));
            assert( Ret.second);
        } catch ( ... ) {
            operator delete ( static_cast< void*>( pTempBuffer));
            throw;
        }

        // Now, capture it.
        Ret.first->second.Capture( *pSThis);
    }

    // This member function handles the DP2OP_STATESET, which communicates back
    // to the DrawPrimitives2 entry point handler to implement state sets.
    HRESULT DP2StateSet( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP) 
    {
        const D3DHAL_DP2STATESET* pParam=
            reinterpret_cast<const D3DHAL_DP2STATESET*>(pP);
        HRESULT hr( DD_OK);
        WORD wStateCount( pCmd->wStateCount);

        TSuper* pSThis= static_cast<TSuper*>(this);
        if( wStateCount!= 0) do
        {
            switch( pParam->dwOperation)
            {
            case( D3DHAL_STATESETCREATE):
                assert( !m_bRecordingStateSet);
                typedef TSuper::TPerDDrawData TPerDDrawData;
                typedef TPerDDrawData::TDriver TDriver;
                assert((TDriver::GetCaps().DevCaps& D3DDEVCAPS_PUREDEVICE)!= 0);

                try {
                    switch( pParam->sbType)
                    {
                    case( D3DSBT_ALL):
                        pSThis->CreateAndCaptureAllState( pParam->dwParam);
                        break;

                    case( D3DSBT_PIXELSTATE):
                        pSThis->CreateAndCapturePixelState( pParam->dwParam);
                        break;

                    case( D3DSBT_VERTEXSTATE):
                        pSThis->CreateAndCaptureVertexState( pParam->dwParam);
                        break;

                    default: {
                        const bool Unrecognized_StateSetCreate_Operation( false);
                        assert( Unrecognized_StateSetCreate_Operation);
                        } break;
                    }
                } catch( bad_alloc ba) {
                    return DDERR_OUTOFMEMORY;
                }
                break;

            case( D3DHAL_STATESETBEGIN):
                assert( 1== wStateCount);
                assert( !m_bRecordingStateSet);

                m_bRecordingStateSet= true;
                hr= c_hrStateSetBegin;
                // Returning this constant will break out of the parsing and
                // notify DrawPrimitive2 entry point handler to create a state
                // set.
                break;

            case( D3DHAL_STATESETCAPTURE):
                if( !m_bRecordingStateSet)
                {
                    // First, find the StateSet to capture.
                    typename TSSDB::iterator itSS(
                        m_StateSetDB.find( pParam->dwParam));
                    assert( itSS!= m_StateSetDB.end());

                    // Capture it.
                    itSS->second.Capture( *pSThis);
                }
                break;

            case( D3DHAL_STATESETDELETE):
                if( !m_bRecordingStateSet)
                {
                    m_StateSetDB.erase( pParam->dwParam);
                }
                break;

            case( D3DHAL_STATESETEND):
                assert( 1== wStateCount);
                assert( m_bRecordingStateSet);
                m_bRecordingStateSet= false;
                m_dwStateSetId= pParam->dwParam;
                m_pEndStateSet= pCmd;
                hr= c_hrStateSetEnd;
                break;

            case( D3DHAL_STATESETEXECUTE):
                if( !m_bRecordingStateSet)
                {
                    // First, find the StateSet to execute.
                    typename TSSDB::iterator itSS(
                        m_StateSetDB.find( pParam->dwParam));
                    assert( itSS!= m_StateSetDB.end());

                    // "Push" value of m_bExecutingStateSet, then set to true.
                    // "Pop" will occur at destruction.
                    CPushValue< bool> m_PushExecutingBit(
                        m_bExecutingStateSet, true);

                    // Execute it.
                    itSS->second.Execute( *pSThis);
                }
                break;

            default: {
                const bool Unrecognized_StateSet_Operation( false);
                assert( Unrecognized_StateSet_Operation);
                } break;
            }

            ++pParam;
        } while( SUCCEEDED( hr) && --wStateCount);

        return hr;
    }

    // This function is used to record the current state of the context/ device
    // into the command buffer.
    void RecordCommandBuffer( D3DHAL_DP2COMMAND* pBeginSS,
        D3DHAL_DP2COMMAND* pEndSS)
    {
        TSuper* pSThis= static_cast<TSuper*>(this);

        CDP2CmdIterator<> itCur( pBeginSS);
        const CDP2CmdIterator<> itEnd( pEndSS);
        SDP2MFnParser DP2Parser;
        TRMFnCaller RMFnCaller( *pSThis);

        HRESULT hr( DD_OK);
        while( itCur!= itEnd)
        {
            hr= DP2Parser.ParseDP2( RMFnCaller, m_RecFnCtr, itCur, itEnd);
            assert( SUCCEEDED( hr));

            // Ignore recording errors, except for debugging. Hopefully
            // the processing of this DP2 command (when appling the state set)
            // won't fault later.
            if( FAILED( hr))
                ++itCur;
        }
    }

    // Primary reason for class, handling of this function for the context.
    HRESULT DrawPrimitives2( PORTABLE_DRAWPRIMITIVES2DATA& dpd) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        TDP2Data DP2Data( dpd);

        // If not currently executing a stateset (which might recursively call
        // this function) notify start of DP2 entry point.
        if( !m_bExecutingStateSet)
            pSThis->OnBeginDrawPrimitives2( DP2Data);

        typename TDP2DataCmds::const_iterator itCur(
            DP2Data.GetCommands().begin() );
        const typename TDP2DataCmds::const_iterator itEnd(
            DP2Data.GetCommands().end() );
        SDP2MFnParser DP2Parser;
        TMFnCaller MFnCaller( *pSThis, DP2Data);

        HRESULT hr( DD_OK);
        do
        {
            hr= DP2Parser.ParseDP2( MFnCaller, m_DefFnCtr,
                itCur, itEnd);

            if( c_hrStateSetBegin== hr)
            {
                typename TDP2DataCmds::const_iterator itStartSSet( ++itCur);

                {
                    TDP2MFnCtr FakeFnCtr;
                    typename TDP2MFnCtr::iterator itCurFake( FakeFnCtr.begin());
                    while( itCurFake!= FakeFnCtr.end())
                        *itCurFake++ = DP2Fake;
                    FakeFnCtr[ D3DDP2OP_STATESET]= DP2StateSet;

                    hr= DP2Parser.ParseDP2( MFnCaller, FakeFnCtr,
                        itCur, itEnd);

                    assert( c_hrStateSetEnd== hr);
                    itCur++;
                }

                try
                {
                    pair< TSSDB::iterator, bool> Ret;
                    Ret= m_StateSetDB.insert( TSSDB::value_type( m_dwStateSetId,
                        TStateSet( *pSThis, itStartSSet, m_pEndStateSet)));

                    // There shouldn't be two statesets with the same Id.
                    assert( Ret.second);
                    hr= S_OK;
                } catch( bad_alloc e) {
                    hr= DDERR_OUTOFMEMORY;
                }
            }
            assert( c_hrStateSetEnd!= hr);
        } while( SUCCEEDED(hr)&& itCur!= itEnd);

        if( FAILED( hr))
        {
            const D3DHAL_DP2COMMAND* pS= itCur;
            const D3DHAL_DP2COMMAND* pE= itEnd;
            dpd.dwErrorOffset()= reinterpret_cast<const UINT8*>(pE)-
                reinterpret_cast<const UINT8*>(pS);
        }

        // If not currently executing a stateset (which might recursively call
        // this function) notify end of DP2 entry point.
        if( !m_bExecutingStateSet)
            pSThis->OnEndDrawPrimitives2( DP2Data);
        return hr;
    }
};

template< class TSuper, class TSS, class TSSDB, class TDP2D, class TDP2MFC,
    class TDP2RMFC>
const HRESULT CStdDrawPrimitives2< TSuper, TSS, TSSDB, TDP2D, TDP2MFC,
    TDP2RMFC>::c_hrStateSetBegin= S_FALSE+ 556;

template< class TSuper, class TSS, class TSSDB, class TDP2D, class TDP2MFC,
    class TDP2RMFC>
const HRESULT CStdDrawPrimitives2< TSuper, TSS, TSSDB, TDP2D, TDP2MFC,
    TDP2RMFC>::c_hrStateSetEnd= S_FALSE+ 557;

////////////////////////////////////////////////////////////////////////////////
//
// CStdDP2ViewportInfoStore,
// CStdDP2WInfoStore,
// CStdDP2SetTransformStore,
// etc: CStdDP2xxxxxStore...
//
// These classes provide default DP2 operation support, typically just storing
// state. They have support for a notification mechanism, which delegates to
// the parent Context.
//
////////////////////////////////////////////////////////////////////////////////

// MSVC doesn't support partial specialization or we could've had something
// elegant like:
//
// template< class TSuper, class TParam>
// class CStdDP2ParamStore {};
//
// for typical support like:
// CStdDP2ParamStore< ..., D3DHAL_DP2VIEWPORTINFO>
// CStdDP2ParamStore< ..., D3DHAL_DP2WINFO>
//
// with partial specializations for exceptions like:
//
// template< class TSuper>
// class CStdDP2ParamStore< TSuper, D3DHAL_DP2RENDERSTATE> {};
// template< class TSuper>
// class CStdDP2ParamStore< TSuper, D3DHAL_DP2TEXTURESTAGESTATE> {};
//
// So, without this support, it'll be easier for each class to have a unique
// name; as MSVC is currently buggy about inheriting from the same named class
// multiple times, even WITH a different template parameter.

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, class TDP2Data= CDP2DataWrap<> >
class CStdDP2ViewportInfoStore
{
protected: // Variables
    D3DHAL_DP2VIEWPORTINFO m_Param;

protected: // Functions
    CStdDP2ViewportInfoStore() 
    { }
    explicit CStdDP2ViewportInfoStore( const D3DHAL_DP2VIEWPORTINFO& P) 
        :m_Param( P)
    { }
    ~CStdDP2ViewportInfoStore() 
    { }

    D3DHAL_DP2VIEWPORTINFO NewDP2ViewportInfo( const D3DHAL_DP2VIEWPORTINFO&
        CurParam, const D3DHAL_DP2VIEWPORTINFO& NewParam) const 
    {   // Tell notifier to store the new param.
        return NewParam;
    }

public: // Fuctions
    void GetDP2ViewportInfo( D3DHAL_DP2VIEWPORTINFO& GetParam) const 
    { GetParam= m_Param; }
    operator D3DHAL_DP2VIEWPORTINFO() const 
    { return m_Param; }
    HRESULT DP2ViewportInfo( TDP2Data&, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2VIEWPORTINFO* pParam=
            reinterpret_cast< const D3DHAL_DP2VIEWPORTINFO*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            m_Param= pSThis->NewDP2ViewportInfo( m_Param, *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    HRESULT RecDP2ViewportInfo( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2VIEWPORTINFO* pParam=
            reinterpret_cast< D3DHAL_DP2VIEWPORTINFO*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            GetDP2ViewportInfo( *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, class TDP2Data= CDP2DataWrap<> >
class CStdDP2WInfoStore
{
protected: // Variables
    D3DHAL_DP2WINFO m_Param;

protected: // Functions
    CStdDP2WInfoStore() 
    { }
    explicit CStdDP2WInfoStore( const D3DHAL_DP2WINFO& P) 
        :m_Param( P)
    { }
    ~CStdDP2WInfoStore() 
    { }

    D3DHAL_DP2WINFO NewDP2WInfo( const D3DHAL_DP2WINFO& CurParam,
        const D3DHAL_DP2WINFO& NewParam) const 
    {   // Tell notifier to store the new param.
        return NewParam;
    }

public: // Fuctions
    void GetDP2WInfo( D3DHAL_DP2WINFO& GetParam) const 
    { GetParam= m_Param; }
    operator D3DHAL_DP2WINFO() const 
    { return m_Param; }
    HRESULT DP2WInfo( TDP2Data&, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2WINFO* pParam=
            reinterpret_cast< const D3DHAL_DP2WINFO*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            m_Param= pSThis->NewDP2WInfo( m_Param, *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    HRESULT RecDP2WInfo( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2WINFO* pParam=
            reinterpret_cast< D3DHAL_DP2WINFO*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            GetDP2WInfo( *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, class TDP2Data= CDP2DataWrap<> >
class CStdDP2ZRangeStore
{
protected: // Variables
    D3DHAL_DP2ZRANGE m_Param;

protected: // Functions
    CStdDP2ZRangeStore() 
    { }
    explicit CStdDP2ZRangeStore( const D3DHAL_DP2ZRANGE& P) 
        :m_Param( P)
    { }
    ~CStdDP2ZRangeStore() 
    { }

    D3DHAL_DP2ZRANGE NewDP2ZRange( const D3DHAL_DP2ZRANGE& CurParam,
        const D3DHAL_DP2ZRANGE& NewParam) const 
    {   // Tell notifier to store the new param.
        return NewParam;
    }

public: // Fuctions
    void GetDP2ZRange( D3DHAL_DP2ZRANGE& GetParam) const 
    { GetParam= m_Param; }
    operator D3DHAL_DP2ZRANGE() const 
    { return m_Param; }
    HRESULT DP2ZRange( TDP2Data&, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2ZRANGE* pParam=
            reinterpret_cast< const D3DHAL_DP2ZRANGE*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            m_Param= pSThis->NewDP2ZRange( m_Param, *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    HRESULT RecDP2ZRange( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2ZRANGE* pParam=
            reinterpret_cast< D3DHAL_DP2ZRANGE*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            GetDP2ZRange( *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, class TDP2Data= CDP2DataWrap<> >
class CStdDP2SetMaterialStore
{
protected: // Variables
    D3DHAL_DP2SETMATERIAL m_Param;

protected: // Functions
    CStdDP2SetMaterialStore() 
    { }
    explicit CStdDP2SetMaterialStore( const D3DHAL_DP2SETMATERIAL& P) 
        :m_Param( P)
    { }
    ~CStdDP2SetMaterialStore() 
    { }

    D3DHAL_DP2SETMATERIAL NewDP2SetMaterial( const D3DHAL_DP2SETMATERIAL& CurParam,
        const D3DHAL_DP2SETMATERIAL& NewParam) const 
    {   // Tell notifier to store the new param.
        return NewParam;
    }

public: // Fuctions
    void GetDP2SetMaterial( D3DHAL_DP2SETMATERIAL& GetParam) const 
    { GetParam= m_Param; }
    operator D3DHAL_DP2SETMATERIAL() const 
    { return m_Param; }
    HRESULT DP2SetMaterial( TDP2Data&, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2SETMATERIAL* pParam=
            reinterpret_cast< const D3DHAL_DP2SETMATERIAL*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            m_Param= pSThis->NewDP2SetMaterial( m_Param, *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    HRESULT RecDP2SetMaterial( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2SETMATERIAL* pParam=
            reinterpret_cast< D3DHAL_DP2SETMATERIAL*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            GetDP2SetMaterial( *pParam);
            ++pParam;
        } while( --wStateCount);
        return DD_OK;
    }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, class TDP2Data= CDP2DataWrap<> >
class CStdDP2SetVertexShaderStore
{
protected: // Variables
    D3DHAL_DP2VERTEXSHADER m_Param;

protected: // Functions
    CStdDP2SetVertexShaderStore() 
    { }
    explicit CStdDP2SetVertexShaderStore( const D3DHAL_DP2VERTEXSHADER& P)
        : m_Param( P)
    { }
    ~CStdDP2SetVertexShaderStore() 
    { }

    D3DHAL_DP2VERTEXSHADER NewDP2SetVertexShader( const D3DHAL_DP2VERTEXSHADER&
        CurParam, const D3DHAL_DP2VERTEXSHADER& NewParam) const 
    {   // Tell notifier to store the new param.
        return NewParam;
    }

public: // Fuctions
    void GetDP2SetVertexShader( D3DHAL_DP2VERTEXSHADER& GetParam) const 
    { GetParam= m_Param; }
    operator D3DHAL_DP2VERTEXSHADER() const 
    { return m_Param; }
    HRESULT DP2SetVertexShader( TDP2Data&, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2VERTEXSHADER* pParam=
            reinterpret_cast< const D3DHAL_DP2VERTEXSHADER*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            m_Param= pSThis->NewDP2SetVertexShader( m_Param, *pParam);

            // If the handle is 0, the Device/ Context needs to invalidate all
            // streams.
            if( 0== m_Param.dwHandle)
            {
                // The CStdDP2VStreamManager provides a default implementation
                // for InvalidateAllVStreams()
                pSThis->InvalidateAllVStreams();
                // The CStdDP2IStreamManager provides a default implementation
                // for InvalidateAllIStreams()
                pSThis->InvalidateAllIStreams();
            }
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    HRESULT RecDP2SetVertexShader( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2VERTEXSHADER* pParam=
            reinterpret_cast< D3DHAL_DP2VERTEXSHADER*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            GetDP2SetVertexShader( *pParam);
            ++pParam;
        } while( wStateCount!= 0);
        return DD_OK;
    }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, class TDP2Data= CDP2DataWrap<> >
class CStdDP2SetPixelShaderStore
{
protected: // Variables
    D3DHAL_DP2PIXELSHADER m_Param;

protected: // Functions
    CStdDP2SetPixelShaderStore() 
    { }
    explicit CStdDP2SetPixelShaderStore( const D3DHAL_DP2PIXELSHADER& P)
        : m_Param( P)
    { }
    ~CStdDP2SetPixelShaderStore() 
    { }

    D3DHAL_DP2PIXELSHADER NewDP2SetPixelShader( const D3DHAL_DP2PIXELSHADER&
        CurParam, const D3DHAL_DP2PIXELSHADER& NewParam) const 
    {   // Tell notifier to store the new param.
        return NewParam;
    }

public: // Fuctions
    void GetDP2SetPixelShader( D3DHAL_DP2PIXELSHADER& GetParam) const 
    { GetParam= m_Param; }
    operator D3DHAL_DP2PIXELSHADER() const 
    { return m_Param; }
    HRESULT DP2SetPixelShader( TDP2Data&, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2PIXELSHADER* pParam=
            reinterpret_cast< const D3DHAL_DP2PIXELSHADER*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            m_Param= pSThis->NewDP2SetPixelShader( m_Param, *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    HRESULT RecDP2SetPixelShader( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2PIXELSHADER* pParam=
            reinterpret_cast< D3DHAL_DP2PIXELSHADER*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            GetDP2SetPixelShader( *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// c_uiWorldMatrices: The number of world transform matrices that should be
//     stored.
// c_uiTextureMatrices: The number of texture transform matrices that should
//     be stored.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, const size_t c_uiWorldMatrices= 256,
    const size_t c_uiTextureMatrices= D3DHAL_TSS_MAXSTAGES,
    class TDP2Data= CDP2DataWrap<> >
class CStdDP2SetTransformStore
{
protected: // Types
    typedef block< D3DMATRIX, 2+ c_uiTextureMatrices+ c_uiWorldMatrices>
        TMatrices;

protected: // Variables
    TMatrices m_Matrices;

private: // Functions
    static bool IsValidTransformType( D3DTRANSFORMSTATETYPE Type)
    {
        // We might not be storing this transform matrix, so we shouldn't
        // record it in a state set and ignore any SET requests.
        if( (Type>= D3DTS_VIEW&& Type<= D3DTS_PROJECTION)||
            (Type>= D3DTS_TEXTURE0&& Type< static_cast< D3DTRANSFORMSTATETYPE>( 
            D3DTS_TEXTURE0+ c_uiTextureMatrices))||
            (Type>= D3DTS_WORLD&& Type< static_cast< D3DTRANSFORMSTATETYPE>(
            D3DTS_WORLDMATRIX( c_uiWorldMatrices))))
            return true;
        return false;
    }
    static size_t TransformTypeToIndex( D3DTRANSFORMSTATETYPE Type)
    {
        assert( Type>= D3DTS_VIEW);
        if( Type< D3DTS_TEXTURE0)
        {
            assert( Type<= D3DTS_PROJECTION);
            return static_cast< size_t>( Type- D3DTS_VIEW);
        }
        else if( Type< D3DTS_WORLD)
        {
            assert( Type< static_cast< D3DTRANSFORMSTATETYPE>( \
                D3DTS_TEXTURE0+ c_uiTextureMatrices));
            return static_cast< size_t>( Type- D3DTS_TEXTURE0+ 2);
        }
        else
        {
            assert( Type< static_cast< D3DTRANSFORMSTATETYPE>( \
                D3DTS_WORLDMATRIX( c_uiWorldMatrices)));
            return static_cast< size_t>( Type- D3DTS_WORLD+
                c_uiTextureMatrices+ 2);
        }
    }

protected: // Functions
    CStdDP2SetTransformStore()
    { }
    template< class TIter> // D3DHAL_DP2SETTRANSFORM*
    CStdDP2SetTransformStore( TIter itStart, const TIter itEnd)
    {
        while( itStart!= itEnd)
        {
            m_Matrices[ TransformTypeToIndex( itStart->xfrmType)]=
                itStart->matrix;
            ++itStart;
        }
    }
    ~CStdDP2SetTransformStore()
    { }

    D3DHAL_DP2SETTRANSFORM NewDP2SetTransform( const D3DHAL_DP2SETTRANSFORM&
        CurParam, const D3DHAL_DP2SETTRANSFORM& NewParam) const 
    {   // Tell notifier to store the new param.
        return NewParam;
    }

public: // Fuctions
    D3DMATRIX GetTransform( D3DTRANSFORMSTATETYPE Type) const
    { return m_Matrices[ TransformTypeToIndex( Type)]; }
    void GetDP2SetTransform( D3DHAL_DP2SETTRANSFORM& GetParam) const 
    { GetParam.matrix= GetTransform( GetParam.xfrmType); }
    HRESULT DP2SetTransform( TDP2Data&, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2SETTRANSFORM* pParam=
            reinterpret_cast<const D3DHAL_DP2SETTRANSFORM*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            if( IsValidTransformType( pParam->xfrmType))
            {
                D3DHAL_DP2SETTRANSFORM CurWrap;
                CurWrap.xfrmType= pParam->xfrmType;
                GetDP2SetTransform( CurWrap);

                D3DHAL_DP2SETTRANSFORM NewState(
                    pSThis->NewDP2SetTransform( CurWrap, *pParam));

                m_Matrices[ TransformTypeToIndex( NewState.xfrmType)]=
                    NewState.matrix;
            }
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    HRESULT RecDP2SetTransform( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2SETTRANSFORM* pParam=
            reinterpret_cast< D3DHAL_DP2SETTRANSFORM*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            if( IsValidTransformType( pParam->xfrmType))
                GetDP2SetTransform( *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// c_uiClipPlanes: The number of user clip planes that should be stored. This
//     should be consistent with the driver cap.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, const size_t c_uiClipPlanes,
    class TDP2Data= CDP2DataWrap<> >
class CStdDP2SetClipPlaneStore
{
protected: // Types
    typedef block< block< D3DVALUE, 4>, c_uiClipPlanes> TClipPlanes;

protected: // Variables
    TClipPlanes m_ClipPlanes;

protected: // Functions
    CStdDP2SetClipPlaneStore()
    { }
    template< class TIter> // D3DHAL_DP2SETCLIPPLANE*
    CStdDP2SetClipPlaneStore( TIter itStart, const TIter itEnd)
    {
        while( itStart!= itEnd)
        {
            m_ClipPlanes[ itStart->dwIndex]= itStart->plane;
            ++itStart;
        }
    }
    ~CStdDP2SetClipPlaneStore()
    { }

    D3DHAL_DP2SETCLIPPLANE NewDP2SetClipPlane( const D3DHAL_DP2SETCLIPPLANE&
        CurParam, const D3DHAL_DP2SETCLIPPLANE& NewParam) const
    {   // Tell notifier to store the new param.
        return NewParam;
    }

public: // Functions
    block< D3DVALUE, 4> GetClipPlane( DWORD dwIndex) const
    { return m_ClipPlanes[ dwIndex]; }
    void GetDP2SetClipPlane( D3DHAL_DP2SETCLIPPLANE& GetParam) const
    { 
        block< D3DVALUE, 4> CP( GetClipPlane( GetParam.dwIndex));
        copy( CP.begin(), CP.end(), &GetParam.plane[ 0]);
    }
    HRESULT DP2SetClipPlane( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2SETCLIPPLANE* pParam=
            reinterpret_cast<const D3DHAL_DP2SETCLIPPLANE*>(pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            if( pParam->dwIndex< m_ClipPlanes.size())
            {
                D3DHAL_DP2SETCLIPPLANE CurWrap;
                CurWrap.dwIndex= pParam->dwIndex;
                GetDP2SetClipPlane( CurWrap);

                D3DHAL_DP2SETCLIPPLANE NewState( 
                    pSThis->NewDP2SetClipPlane( CurWrap, *pParam));

                copy( &NewState.plane[ 0], &NewState.plane[ 4],
                    m_ClipPlanes[ NewState.dwIndex].begin());
            }
            ++pParam;
        } while( --wStateCount);
        return DD_OK;
    }
    HRESULT RecDP2SetClipPlane( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2SETCLIPPLANE* pParam=
            reinterpret_cast< D3DHAL_DP2SETCLIPPLANE*>(pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            if( pParam->dwIndex< m_ClipPlanes.size())
                GetDP2SetClipPlane( *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, class TDP2Data= CDP2DataWrap<> >
class CStdDP2RenderStateStore
{
protected: // Variables
    block< DWORD, D3DHAL_MAX_RSTATES> m_Param;

protected: // Functions
    CStdDP2RenderStateStore() 
    { m_Param[ D3DRENDERSTATE_SCENECAPTURE]= FALSE; }
    template< class TIter> // D3DHAL_DP2RENDERSTATE*
    CStdDP2RenderStateStore( TIter itStart, const TIter itEnd)
    {
        m_Param[ D3DRENDERSTATE_SCENECAPTURE]= FALSE; 
        while( itStart!= itEnd)
        {
            m_Param[ itStart->RenderState]= itStart->dwState;
            itStart++;
        }
    }
    ~CStdDP2RenderStateStore() 
    { }

    D3DHAL_DP2RENDERSTATE NewDP2RenderState( const D3DHAL_DP2RENDERSTATE&
        CurParam, const D3DHAL_DP2RENDERSTATE& NewParam) const 
    {   // Tell notifier to store the new param.
        return NewParam;
    }

    void OnSceneCaptureStart( void) 
    { }
    void OnSceneCaptureEnd( void) 
    { }

public: // Functions
    DWORD GetRenderStateDW( D3DRENDERSTATETYPE RS) const 
    { return m_Param[ RS]; }
    D3DVALUE GetRenderStateDV( D3DRENDERSTATETYPE RS) const 
    { return *(reinterpret_cast< const D3DVALUE*>( &m_Param[ RS])); }
    void GetDP2RenderState( D3DHAL_DP2RENDERSTATE& GetParam) const 
    { GetParam.dwState= GetRenderStateDW( GetParam.RenderState); }
    HRESULT DP2RenderState( TDP2Data& DP2Data, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2RENDERSTATE* pParam=
            reinterpret_cast<const D3DHAL_DP2RENDERSTATE*>(pP);
        WORD wStateCount( pCmd->wStateCount);

        D3DHAL_DP2RENDERSTATE SCap;
        SCap.RenderState= static_cast< D3DRENDERSTATETYPE>(
            D3DRENDERSTATE_SCENECAPTURE);
        GetDP2RenderState( SCap);
        const DWORD dwOldSC( SCap.dwState);

        if((DP2Data.dwFlags()& D3DHALDP2_EXECUTEBUFFER)!= 0)
        {
            // DP2Data.lpdwRStates should be valid.

            if( wStateCount!= 0) do
            {
                if( pParam->RenderState< D3DHAL_MAX_RSTATES)
                {
                    D3DHAL_DP2RENDERSTATE CurWrap;
                    CurWrap.RenderState= pParam->RenderState;
                    GetDP2RenderState( CurWrap);

                    D3DHAL_DP2RENDERSTATE NewState(
                        pSThis->NewDP2RenderState( CurWrap, *pParam));
                    
                    m_Param[ NewState.RenderState]= NewState.dwState;
                    DP2Data.lpdwRStates()[ NewState.RenderState]= NewState.dwState;
                }
                ++pParam;
            } while( --wStateCount!= 0);
            
        }
        else
        {
            if( wStateCount!= 0) do
            {
                if( pParam->RenderState< D3DHAL_MAX_RSTATES)
                {
                    D3DHAL_DP2RENDERSTATE CurWrap;
                    CurWrap.RenderState= pParam->RenderState;
                    GetDP2RenderState( CurWrap);

                    D3DHAL_DP2RENDERSTATE NewState(
                        pSThis->NewDP2RenderState( CurWrap, *pParam));

                    m_Param[ NewState.RenderState]= NewState.dwState;
                }
                ++pParam;
            } while( --wStateCount!= 0);
        }

        GetDP2RenderState( SCap);
        if( FALSE== dwOldSC && TRUE== SCap.dwState)
            OnSceneCaptureStart();
        else if( TRUE== dwOldSC && FALSE== SCap.dwState)
            OnSceneCaptureEnd();

        return DD_OK;
    }
    HRESULT RecDP2RenderState( const D3DHAL_DP2COMMAND* pCmd, void* pP) 
    {
        D3DHAL_DP2RENDERSTATE* pParam=
            reinterpret_cast< D3DHAL_DP2RENDERSTATE*>(pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount) do
        {
            if( pParam->RenderState< D3DHAL_MAX_RSTATES)
                GetDP2RenderState( *pParam);
            ++pParam;
        } while( --wStateCount!= 0);

        return DD_OK;
    }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, class TDP2Data= CDP2DataWrap<> >
class CStdDP2TextureStageStateStore
{
protected: // Variables
    block< block< DWORD, D3DTSS_MAX>, D3DHAL_TSS_MAXSTAGES> m_Param;

protected: // Functions
    CStdDP2TextureStageStateStore() 
    { }
    template< class TIter> // D3DHAL_DP2TEXTURESTAGESTATE*
    CStdDP2TextureStageStateStore( TIter itStart, const TIter itEnd)
    {   
        while( itStart!= itEnd)
        {
            m_Param[ itStart->wStage][ itStart->TSState]= itStart->dwValue();
            ++itStart;
        }
    }
    ~CStdDP2TextureStageStateStore() 
    { }

    D3DHAL_DP2TEXTURESTAGESTATE NewDP2TextureStageState( const 
        D3DHAL_DP2TEXTURESTAGESTATE& CurParam, const
        D3DHAL_DP2TEXTURESTAGESTATE& NewParam) const 
    {   // Tell notifier to store the new param.
        return NewParam;
    }

public: // Functions
    DWORD GetTextureStageStateDW( WORD wStage, WORD wTSState) const 
    { return m_Param[ wStage][ wTSState]; }
    D3DVALUE GetTextureStageStateDV( WORD wStage, WORD wTSState) const 
    { return *(reinterpret_cast< const D3DVALUE*>( &m_Param[ wStage][ wTSState])); }
    void GetDP2TextureStageState( D3DHAL_DP2TEXTURESTAGESTATE& GetParam) const
    { GetParam.dwValue= GetTextureStageStateDW( GetParam.wStage, GetParam.TSState); }
    HRESULT DP2TextureStageState( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2TEXTURESTAGESTATE* pParam=
            reinterpret_cast<const D3DHAL_DP2TEXTURESTAGESTATE*>(pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            if( pParam->wStage< D3DHAL_TSS_MAXSTAGES&& pParam->TSState< D3DTSS_MAX)
            {
                D3DHAL_DP2TEXTURESTAGESTATE CurWrap;
                CurWrap.wStage= pParam->wStage;
                CurWrap.TSState= pParam->TSState;
                GetDP2TextureStageState( CurWrap);

                D3DHAL_DP2TEXTURESTAGESTATE NewState( 
                    pSThis->NewDP2TextureStageState( CurWrap, *pParam));

                m_Param[ NewState.wStage][ NewState.TSState]= NewState.dwValue;
            }
            ++pParam;
        } while( --wStateCount);

        return DD_OK;
    }
    HRESULT RecDP2TextureStageState( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2TEXTURESTAGESTATE* pParam=
            reinterpret_cast< D3DHAL_DP2TEXTURESTAGESTATE*>(pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            if( pParam->wStage< D3DHAL_TSS_MAXSTAGES&& pParam->TSState< D3DTSS_MAX)
                GetDP2TextureStageState( *pParam);
            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
};

//
// The more complex manager classes:
//

////////////////////////////////////////////////////////////////////////////////
//
// CVStream
//
// This class stores everything associated with a vertex stream. This
// implementation allows 4 representations (video, system, user, and none).
// This class is used by a VStream manager class.
//
// <Template Parameters>
// TS: Video memory surface object, typically either CMySurface or
//     IVidMemSurface, etc. A valid pointer to this object is stored, when the
//     stream source is from a video memory surface.
// TSDBE: The SurfDBEntry type, typically, CMySurfDBEntry or CSurfDBEntry. A
//     valid pointer to this object is stored, when the stream source is from
//     a video memory or system memory surface.
//
////////////////////////////////////////////////////////////////////////////////
template< class TS, class TSDBE>
class CVStream
{
public: // Types
    typedef TS TSurface;
    typedef TSDBE TSurfDBEntry;
    enum EMemLocation
    {
        None,
        User,
        System,
        Video
    };

protected: // Variables
    DWORD m_dwHandle;
    TSurface m_Surface;
    TSurfDBEntry m_SurfDBEntry;
    void* m_pUserMemData;
    DWORD m_dwStride;
    DWORD m_dwFVF;
    EMemLocation m_eMemLocation;

public: // Functions
    CVStream()
        : m_dwHandle( 0), m_pUserMemData( NULL), m_dwStride( 0), m_dwFVF( 0),
        m_eMemLocation( None)
    { }
    // Video Memory representation constructor.
    CVStream( DWORD dwHandle, const TSurface& Surface,
        const TSurfDBEntry& SurfDBEntry, DWORD dwStride): m_dwHandle( dwHandle),
        m_Surface( Surface), m_SurfDBEntry( SurfDBEntry), m_pUserMemData( NULL),
        m_dwStride( dwStride), m_dwFVF( 0), m_eMemLocation( Video)
    { }
    // System Memory representation constructor.
    CVStream( DWORD dwHandle, const TSurfDBEntry& SurfDBEntry, DWORD dwStride):
        m_dwHandle( dwHandle), m_SurfDBEntry( SurfDBEntry),
        m_pUserMemData( NULL), m_dwStride( dwStride), m_dwFVF( 0),
        m_eMemLocation( System)
    { }
    // User Memory representation constructor.
    CVStream( void* pUserMem, DWORD dwStride):
        m_dwHandle( 0), m_pUserMemData( pUserMem), m_dwStride( dwStride),
        m_dwFVF( 0), m_eMemLocation( User)
    { }

    EMemLocation GetMemLocation() const
    { return m_eMemLocation; }
    void SetFVF( DWORD dwFVF)
    { m_dwFVF= dwFVF; }
    DWORD GetFVF() const
    { return m_dwFVF; }
    DWORD GetHandle() const
    {
        assert( GetMemLocation()== System|| GetMemLocation()== Video);
        return m_dwHandle;
    }
    DWORD GetStride() const
    {
        assert( GetMemLocation()!= None);
        return m_dwStride;
    }
    TSurface& GetVidMemRepresentation()
    {
        assert( GetMemLocation()== Video);
        return m_Surface;
    }
    const TSurface& GetVidMemRepresentation() const
    {
        assert( GetMemLocation()== Video);
        return m_Surface;
    }
    TSurfDBEntry& GetSurfDBRepresentation()
    {
        assert( GetMemLocation()== Video|| GetMemLocation()== System);
        return m_SurfDBEntry;
    }
    const TSurfDBEntry& GetSurfDBRepresentation() const
    {
        assert( GetMemLocation()== Video|| GetMemLocation()== System);
        return m_SurfDBEntry;
    }
    void* GetUserMemPtr() const
    {
        assert( GetMemLocation()== User);
        return m_pUserMemData;
    }
};

////////////////////////////////////////////////////////////////////////////////
//
// CStdDP2VStreamManager
//
// This class contains DP2 member functions to correctly process 
// D3DDP2OP_SETSTREAMSOURCE & D3DDP2OP_SETSTREAMSOURCEUM. It can also correctly
// record a command buffer operation for D3DDP2OP_SETSTREAMSOURCE. To do this,
// however, it must maintain information for vertex stream, or "manage"
// VStream objects.
//
// This class also contains a function, InvalidateAllStreams, which is needed
// to be called when a D3DDP2OP_SETVERTEXSHADER operation is processed with a
// zero value VERTEXSHADER.
//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TVS: The vertex stream type which represents data associated with a vertex
//     stream. This is typically, CVStream<> or something derived from it.
// c_uiStreams: The number of vertex streams to support. Typically, non-TnL
//     drivers only support 1. This should be consistent with the cap in the
//     driver.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
////////////////////////////////////////////////////////////////////////////////
template< class TSuper,
    class TVS= CVStream< typename TSuper::TPerDDrawData::TDriver::TSurface*, typename TSuper::TPerDDrawData::TSurfDBEntry*>,
    const size_t c_uiStreams= 1, class TDP2Data= CDP2DataWrap<> >
class CStdDP2VStreamManager
{
public: // Types
    typedef TVS TVStream;
    typedef block< TVStream, c_uiStreams> TVStreamDB;

protected: // Variables
    TVStreamDB m_VStreamDB;

protected: // Functions
    CStdDP2VStreamManager() 
    { }
    ~CStdDP2VStreamManager() 
    { }

public: // Fuctions
    TVStream& GetVStream( typename TVStreamDB::size_type uiStream)
    { return m_VStreamDB[ uiStream]; }
    const TVStream& GetVStream( typename TVStreamDB::size_type uiStream) const
    { return m_VStreamDB[ uiStream]; }
    HRESULT DP2SetStreamSource( TDP2Data&, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        const D3DHAL_DP2SETSTREAMSOURCE* pParam=
            reinterpret_cast< const D3DHAL_DP2SETSTREAMSOURCE*>( pP);
        TSuper* pSThis= static_cast<TSuper*>(this);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            if( pParam->dwStream< m_VStreamDB.size())
            {
                if( 0== pParam->dwVBHandle)
                    m_VStreamDB[ pParam->dwStream]= TVStream();
                else
                {
                    typename TSuper::TPerDDrawData::TSurfDBEntry* pDBEntry=
                        pSThis->GetPerDDrawData().GetSurfDBEntry(
                        pParam->dwVBHandle);
                    if( pDBEntry!= NULL)
                    {
                        if((pDBEntry->GetLCLddsCaps().dwCaps&
                            DDSCAPS_VIDEOMEMORY)!= 0)
                        {
                            // Assign in a video memory representation.
                            m_VStreamDB[ pParam->dwStream]=
                                TVStream( pParam->dwVBHandle, pSThis->
                                GetPerDDrawData().GetDriver().GetSurface(
                                *pDBEntry), pDBEntry, pParam->dwStride);
                        }
                        else
                        {
                            // Assign in a system memory representation.
                            m_VStreamDB[ pParam->dwStream]=
                                TVStream( pParam->dwVBHandle,
                                pDBEntry, pParam->dwStride);
                        }
                    }
                    else
                    {
                        // Handle invalid, reset stream.
                        m_VStreamDB[ pParam->dwStream]= TVStream();
                    }
                }
            }

            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    HRESULT DP2SetStreamSourceUM( TDP2Data& DP2Data, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        const D3DHAL_DP2SETSTREAMSOURCEUM* pParam=
            reinterpret_cast< const D3DHAL_DP2SETSTREAMSOURCEUM*>( pP);
        TSuper* pSThis= static_cast<TSuper*>(this);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            if( pParam->dwStream< m_VStreamDB.size())
            {
                if( DP2Data.lpVertices()!= NULL)
                {
                    // Assign in a user memory representation.
                    m_VStreamDB[ pParam->dwStream]=
                        TVStream( DP2Data.lpVertices(), pParam->dwStride);
                }
                else
                {
                    // Reset stream.
                    m_VStreamDB[ pParam->dwStream]= TVStream();
                }
            }

            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    HRESULT RecDP2SetStreamSource( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2SETSTREAMSOURCE* pParam=
            reinterpret_cast< D3DHAL_DP2SETSTREAMSOURCE*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            const DWORD dwStream( pParam->dwStream);
            if( dwStream< m_VStreamDB.size())
            {
                const TVStream& VStream( m_VStreamDB[ dwStream]);
                switch( VStream.GetMemLocation())
                {
                case( TVStream::EMemLocation::None): ;
                case( TVStream::EMemLocation::User): ;
                    pParam->dwVBHandle= 0;
                    pParam->dwStride= 0;
                    break;

                case( TVStream::EMemLocation::System): ;
                case( TVStream::EMemLocation::Video): ;
                    pParam->dwVBHandle= VStream.GetHandle();
                    pParam->dwStride= VStream.GetStride();
                    break;

                default: {
                    const bool Unrecognized_VStream_enum( false);
                    assert( Unrecognized_VStream_enum);
                    }
                }
            }

            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    void InvalidateAllVStreams()
    {
        fill( m_VStreamDB.begin(), m_VStreamDB.end(), TVStream());
    }
};

////////////////////////////////////////////////////////////////////////////////
//
// CIStream
//
// This class stores everything associated with a index stream. This
// implementation allows 3 representations (video, system, and none).
// This class is used by a IStream manager class.
//
// <Template Parameters>
// TS: Video memory surface object, typically either CMySurface or
//     IVidMemSurface, etc. A valid pointer to this object is stored, when the
//     stream source is from a video memory surface.
// TSDBE: The SurfDBEntry type, typically, CMySurfDBEntry or CSurfDBEntry. A
//     valid pointer to this object is stored, when the stream source is from
//     a video memory or system memory surface.
//
////////////////////////////////////////////////////////////////////////////////
template< class TS, class TSDBE>
class CIStream
{
public: // Types
    typedef TS TSurface;
    typedef TSDBE TSurfDBEntry;
    enum EMemLocation
    {
        None,
        System,
        Video
    };

protected: // Variables
    DWORD m_dwHandle;
    TSurface m_Surface;
    TSurfDBEntry m_SurfDBEntry;
    DWORD m_dwStride;
    EMemLocation m_eMemLocation;

public: // Functions
    CIStream():
        m_dwHandle( 0), m_dwStride( 0), m_eMemLocation( None)
    { }
    // Video Memory representation constructor.
    CIStream( DWORD dwHandle, const TSurface& Surface,
        const TSurfDBEntry& SurfDBEntry, DWORD dwStride): m_dwHandle( dwHandle),
        m_Surface( Surface), m_SurfDBEntry( SurfDBEntry), m_dwStride( dwStride),
        m_eMemLocation( Video)
    { }
    // System Memory representation constructor.
    CIStream( DWORD dwHandle, const TSurfDBEntry& SurfDBEntry, DWORD dwStride):
        m_dwHandle( dwHandle), m_SurfDBEntry( SurfDBEntry),
        m_dwStride( dwStride), m_eMemLocation( System)
    { }

    EMemLocation GetMemLocation() const
    { return m_eMemLocation; }
    DWORD GetHandle() const
    {
        assert( GetMemLocation()== System|| GetMemLocation()== Video);
        return m_dwHandle;
    }
    DWORD GetStride() const
    {
        assert( GetMemLocation()!= None);
        return m_dwStride;
    }
    const TSurface& GetVidMemRepresentation() const
    {
        assert( GetMemLocation()== Video);
        return m_Surface;
    }
    TSurface& GetVidMemRepresentation()
    {
        assert( GetMemLocation()== Video);
        return m_Surface;
    }
    const TSurfDBEntry& GetSurfDBRepresentation() const
    {
        assert( GetMemLocation()== Video|| GetMemLocation()== System);
        return m_SurfDBEntry;
    }
    TSurfDBEntry& GetSurfDBRepresentation()
    {
        assert( GetMemLocation()== Video|| GetMemLocation()== System);
        return m_SurfDBEntry;
    }
};

////////////////////////////////////////////////////////////////////////////////
//
// CStdDP2IStreamManager
//
// This class contains DP2 member functions to correctly process 
// D3DDP2OP_SETINDICES. It can also correctly record a command buffer operation
// for D3DDP2OP_SETINDICES. To do this, however, it must maintain information
// for index streams, or "manage" IStream objects.
//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TIS: The index stream type which represents data associated with a index
//     stream. This is typically, CIStream<> or something derived from it.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
////////////////////////////////////////////////////////////////////////////////
template< class TSuper,
    class TIS= CIStream< typename TSuper::TPerDDrawData::TDriver::TSurface*, typename TSuper::TPerDDrawData::TSurfDBEntry*>,
    class TDP2Data= CDP2DataWrap<> >
class CStdDP2IStreamManager
{
public: // Types
    typedef TIS TIStream;
    typedef block< TIStream, 1> TIStreamDB;

protected: // Variables
    TIStreamDB m_IStreamDB;

protected: // Functions
    CStdDP2IStreamManager() 
    { }
    ~CStdDP2IStreamManager() 
    { }

public: // Fuctions
    TIStream& GetIStream( typename TIStreamDB::size_type uiStream)
    { return m_IStreamDB[ uiStream]; }
    const TIStream& GetIStream( typename TIStreamDB::size_type uiStream) const
    { return m_IStreamDB[ uiStream]; }
    HRESULT DP2SetIndices( TDP2Data&, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        const D3DHAL_DP2SETINDICES* pParam=
            reinterpret_cast< const D3DHAL_DP2SETINDICES*>( pP);
        TSuper* pSThis= static_cast<TSuper*>(this);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            // For ease of extension in case multiple IStreams are supported
            // later.
            const DWORD dwStream( 0);

            if( dwStream< m_IStreamDB.size())
            {
                if( 0== pParam->dwVBHandle)
                    m_IStreamDB[ dwStream]= TIStream();
                else
                {
                    typename TSuper::TPerDDrawData::TSurfDBEntry* pDBEntry=
                        pSThis->GetPerDDrawData().GetSurfDBEntry(
                        pParam->dwVBHandle);
                    if( pDBEntry!= NULL)
                    {
                        if((pDBEntry->GetLCLddsCaps().dwCaps&
                            DDSCAPS_VIDEOMEMORY)!= 0)
                        {
                            // Assign in a video memory representation.
                            m_IStreamDB[ dwStream]=
                                TIStream( pParam->dwVBHandle, pSThis->
                                GetPerDDrawData().GetDriver().GetSurface(
                                *pDBEntry), pDBEntry, pParam->dwStride);
                        }
                        else
                        {
                            // Assign in a system memory representation.
                            m_IStreamDB[ dwStream]=
                                TIStream( pParam->dwVBHandle,
                                pDBEntry, pParam->dwStride);
                        }
                    }
                    else
                    {
                        // Handle invalid, reset stream.
                        m_IStreamDB[ dwStream]= TIStream();
                    }
                }
            }

            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    HRESULT RecDP2SetIndices( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2SETINDICES* pParam=
            reinterpret_cast< D3DHAL_DP2SETINDICES*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0) do
        {
            const DWORD dwStream( 0);
            if( dwStream< m_IStreamDB.size())
            {
                const TIStream& IStream( m_IStreamDB[ dwStream]);
                switch( IStream.GetMemLocation())
                {
                case( TIStream::EMemLocation::None): ;
                    pParam->dwVBHandle= 0;
                    pParam->dwStride= 0;
                    break;

                case( TIStream::EMemLocation::System): ;
                case( TIStream::EMemLocation::Video): ;
                    pParam->dwVBHandle= IStream.GetHandle();
                    pParam->dwStride= IStream.GetStride();
                    break;

                default: {
                    const bool Unrecognized_IStream_enum( false);
                    assert( Unrecognized_IStream_enum);
                    }
                }
            }

            ++pParam;
        } while( --wStateCount!= 0);
        return DD_OK;
    }
    void InvalidateAllIStreams()
    {
        fill( m_IStreamDB.begin(), m_IStreamDB.end(), TIStream());
    }
};

class CPalDBEntry
{
protected: // Types
    typedef block< DWORD, 256> TPalEntries;

protected: // Variables
    DWORD m_dwFlags;
    TPalEntries m_PalEntries;

public: // Functions
    CPalDBEntry() : m_dwFlags( 0)
    { fill( m_PalEntries.begin(), m_PalEntries.end(), 0); }
    ~CPalDBEntry() 
    { }
    void SetFlags( DWORD dwFlags) 
    { m_dwFlags= dwFlags; }
    DWORD GetFlags() 
    { return m_dwFlags; }
    DWORD* GetEntries() 
    { return m_PalEntries.begin(); }
    template< class ForwardIterator>
    void Update( TPalEntries::size_type uiStart, ForwardIterator f,
        ForwardIterator l) 
    { copy( f, l, m_PalEntries.begin()+ uiStart); }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TPDBE: This is the palette database entry type, or whatever is associated
//     with a palette. This type is typically, CPalDBEntry or something
//     derived from it.
// TPDB: This can be any Unique, Pair Associative Container, typically a map,
//     which associates a DWORD palette handle to a palette type.
// TSPDB: This can be any Unique, Pair Associative Container, typically a map,
//     which associates a DWORD surface handle to a DWORD palette handle.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, class TPDBE= CPalDBEntry, class TPDB= map< DWORD, TPDBE>,
    class TDP2Data= CDP2DataWrap<> >
class CStdDP2PaletteManager
{
public: // Types
    typedef TPDBE TPalDBEntry;
    typedef TPDB TPalDB;

protected: // Variables
    TPalDB m_PalDB;

protected: // Functions
    CStdDP2PaletteManager() 
    { }
    ~CStdDP2PaletteManager() 
    { }

public: // Functions
    void UpdatePalette( const D3DHAL_DP2UPDATEPALETTE* pParam)
    {
        typename TPalDB::iterator itPal( 
            m_PalDB.find( pParam->dwPaletteHandle));

        if( m_PalDB.end()== itPal)
            itPal= m_PalDB.insert( TPalDB::value_type( pParam->dwPaletteHandle,
                TPalDBEntry())).first;

        const DWORD* pEStart= reinterpret_cast< const DWORD*>( pParam+ 1);
        itPal->second.Update( pParam->wStartIndex, pEStart,
            pEStart+ pParam->wNumEntries);
    }
    void SetPalette( const D3DHAL_DP2SETPALETTE* pParam)
    {
        TSuper* pSThis= static_cast< TSuper*>( this);
        typedef typename TSuper::TPerDDrawData TPerDDrawData;
        typename TPerDDrawData::TSurfDBEntry* pSurfDBEntry=
            pSThis->GetPerDDrawData().GetSurfDBEntry( pParam->dwSurfaceHandle);
        assert( NULL!= pSurfDBEntry);

        if( 0== pParam->dwPaletteHandle)
        {
            // Disassociate the surface with any palette.
            pSurfDBEntry->SetPalette( NULL);
        }
        else
        {
            typename TPalDB::iterator itPal( 
                m_PalDB.find( pParam->dwPaletteHandle));

            if( m_PalDB.end()== itPal)
                itPal= m_PalDB.insert( TPalDB::value_type( pParam->dwPaletteHandle,
                    TPalDBEntry())).first;

            itPal->second.SetFlags( pParam->dwPaletteFlags);
            pSurfDBEntry->SetPalette( &itPal->second);
        }
    }
    HRESULT DP2SetPalette( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2SETPALETTE* pParam=
            reinterpret_cast<const D3DHAL_DP2SETPALETTE*>(pP);
        WORD wStateCount( pCmd->wStateCount);

        try
        {
            if( wStateCount!= 0) do
            {
                pSThis->SetPalette( pParam);
                ++pParam;
            } while( --wStateCount);
        } catch ( bad_alloc ba)
        { return E_OUTOFMEMORY; }

        return DD_OK;
    }
    HRESULT DP2UpdatePalette( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP) 
    {
        TSuper* pSThis= static_cast<TSuper*>(this);
        const D3DHAL_DP2UPDATEPALETTE* pParam=
            reinterpret_cast<const D3DHAL_DP2UPDATEPALETTE*>(pP);
        WORD wStateCount( pCmd->wStateCount);

        try
        {
            if( wStateCount!= 0)
                pSThis->UpdatePalette( pParam);
        } catch ( bad_alloc ba)
        { return E_OUTOFMEMORY; }

        return DD_OK;
    }
};

class CLightDBEntry:
    public D3DLIGHT8
{
protected: // Variables
    bool m_bEnabled;

public: // Functions
    CLightDBEntry()
        : m_bEnabled( false)
    {
        // Default light settings:
        Type= D3DLIGHT_DIRECTIONAL;
        Diffuse.r= 1.0f; Diffuse.g= 1.0f; Diffuse.b= 1.0f; Diffuse.a= 0.0f;
        Specular.r= 0.0f; Specular.g= 0.0f; Specular.b= 0.0f; Specular.a= 0.0f;
        Ambient.r= 0.0f; Ambient.g= 0.0f; Ambient.b= 0.0f; Ambient.a= 0.0f;
        Position.x= 0.0f; Position.y= 0.0f; Position.z= 0.0f;
        Direction.x= 0.0f; Direction.y= 0.0f; Direction.z= 1.0f;
        Range= 0.0f;
        Falloff= 0.0f;
        Attenuation0= 0.0f;
        Attenuation1= 0.0f;
        Attenuation2= 0.0f;
        Theta= 0.0f;
        Phi= 0.0f;
    }
    operator const D3DLIGHT8&() const
    { return *static_cast< const D3DLIGHT8*>( this); }
    CLightDBEntry& operator=( const D3DLIGHT8& Other)
    {
        *static_cast< D3DLIGHT8*>( this)= Other;
        return *this;
    }
    void SetEnabled( bool bEn)
    { m_bEnabled= bEn; }
    bool GetEnabled() const
    { return m_bEnabled; }
};

//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TLDBE: This is the light database entry type, or whatever is associated
//     with a light. This type is typically, CLightDBEntry or something
//     derived from it or convertable to D3DLIGHT8, at least.
// TLDB: This can be any Unique, Pair Associative Container, typically a map,
//     which associates a DWORD light id to a light type.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
template< class TSuper, class TLDBE= CLightDBEntry,
    class TLDB= map< DWORD, TLDBE>, class TDP2Data= CDP2DataWrap<> >
class CStdDP2LightManager
{
public: // Types
    typedef TLDBE TLightDBEntry;
    typedef TLDB TLightDB;

protected: // Variables
    TLightDB m_LightDB;

protected: // Functions
    CStdDP2LightManager() 
    { }
    ~CStdDP2LightManager() 
    { }

public: // Functions
    void CreateLight( DWORD dwId)
    {
        pair< typename TLightDB::iterator, bool> Ret= m_LightDB.insert( 
            typename TLightDB::value_type( dwId, TLightDBEntry()));
    }
    void EnableLight( DWORD dwId, bool bEnable)
    {
        typename TLightDB::iterator itLight( m_LightDB.find( dwId));
        assert( itLight!= m_LightDB.end());

        itLight->second.SetEnabled( bEnable);
    }
    void UpdateLight( DWORD dwId, const D3DLIGHT8& LightValue)
    {
        typename TLightDB::iterator itLight( m_LightDB.find( dwId));
        assert( itLight!= m_LightDB.end());

        itLight->second= LightValue;
    }
    HRESULT DP2CreateLight( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP) 
    {
        TSuper* pSThis= static_cast< TSuper*>( this);
        const D3DHAL_DP2CREATELIGHT* pParam=
            reinterpret_cast< const D3DHAL_DP2CREATELIGHT*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        try
        {
            if( wStateCount!= 0) do
            {
                pSThis->CreateLight( pParam->dwIndex);
                ++pParam;
            } while( --wStateCount);
        } catch ( bad_alloc ba)
        { return E_OUTOFMEMORY; }

        return D3D_OK;
    }
    HRESULT DP2SetLight( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP) 
    {
        TSuper* pSThis= static_cast< TSuper*>( this);
        const D3DHAL_DP2SETLIGHT* pParam=
            reinterpret_cast< const D3DHAL_DP2SETLIGHT*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        try
        {
            if( wStateCount!= 0) do
            {
                if( m_LightDB.end()== m_LightDB.find( pParam->dwIndex))
                {
                    const bool SetLight_without_succeeded_CreateLight( false);
                    assert( SetLight_without_succeeded_CreateLight);
                    return DDERR_INVALIDPARAMS;
                }

                bool bEnable( false);
                switch( pParam->dwDataType)
                {
                case( D3DHAL_SETLIGHT_DATA):
                    const D3DLIGHT8* pL= reinterpret_cast< const D3DLIGHT8*>(
                        pParam+ 1);
                    pSThis->UpdateLight( pParam->dwIndex, *pL);
                    pParam= reinterpret_cast< const D3DHAL_DP2SETLIGHT*>(
                        pL+ 1);
                    break;

                case( D3DHAL_SETLIGHT_ENABLE):
                    bEnable= true; // Fall-through.
                case( D3DHAL_SETLIGHT_DISABLE):
                    pSThis->EnableLight( pParam->dwIndex, bEnable);
                    ++pParam;
                    break;

                default: {
                        const bool Unrecognized_D3DHAL_SETLIGHT_data_type( false);
                        assert( Unrecognized_D3DHAL_SETLIGHT_data_type);
                        return DDERR_INVALIDPARAMS;
                    }
                }
            } while( --wStateCount);
        } catch ( bad_alloc ba)
        { return E_OUTOFMEMORY; }

        return D3D_OK;
    }
    HRESULT RecDP2CreateLight( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2CREATELIGHT* pParam=
            reinterpret_cast< D3DHAL_DP2CREATELIGHT*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        // Special case here, the default state set capturing, will ask how
        // many active lights are needed to be recorded, and their id's. In
        // order to support the default state set, we must process this
        // specially.
        if( 0== pCmd->bCommand)
        {
            // Now, we're either being asked how many lights or what their
            // id's are.
            if( 0== wStateCount)
                pParam->dwIndex= m_LightDB.size();
            else
            {
                assert( m_LightDB.size()== wStateCount);
                typename TLightDB::const_iterator itCur( m_LightDB.begin());
                do
                {
                    pParam->dwIndex= itCur.first;
                    ++pParam;
                    ++itCur;
                } while( --wStateCount!= 0);
            }
            return D3D_OK;
        }

        // Otherwise, recording creation is easy,
        // leave the command buffer as is.
        return D3D_OK;
    }
    HRESULT RecDP2SetLight( const D3DHAL_DP2COMMAND* pCmd, void* pP)
    {
        D3DHAL_DP2SETLIGHT* pParam=
            reinterpret_cast< D3DHAL_DP2SETLIGHT*>( pP);
        WORD wStateCount( pCmd->wStateCount);

        const typename TLightDB::const_iterator itEnd( m_LightDB.end());
        typename TLightDB::const_iterator itLight( itEnd);
        if( wStateCount!= 0) do
        {
            if( itLight!= itEnd&& itLight->first!= pParam->dwIndex)
                itLight= m_LightDB.find( pParam->dwIndex);
            assert( itLight!= itEnd);

            switch( pParam->dwDataType)
            {
            case( D3DHAL_SETLIGHT_DATA):
                D3DLIGHT8* pL= reinterpret_cast< D3DLIGHT8*>( pParam+ 1);
                *pL= itLight->second;
                pParam= reinterpret_cast< D3DHAL_DP2SETLIGHT*>( pL+ 1);
                break;

            case( D3DHAL_SETLIGHT_ENABLE):
            case( D3DHAL_SETLIGHT_DISABLE):
                pParam->dwDataType= ( itLight->second.GetEnabled()? 
                    D3DHAL_SETLIGHT_ENABLE: D3DHAL_SETLIGHT_DISABLE);
                ++pParam;
                break;

            default: {
                    const bool Unrecognized_D3DHAL_SETLIGHT_data_type( false);
                    assert( Unrecognized_D3DHAL_SETLIGHT_data_type);
                    return DDERR_INVALIDPARAMS;
                }
            }
        } while( --wStateCount!= 0);

        return D3D_OK;
    }
};

template< class TS, class TSDBE>
class CRTarget
{
public: // Types
    typedef TS TSurface;
    typedef TSDBE TSurfDBEntry;
    enum EMemLocation
    {
        None,
        Video
    };

protected: // Variables
    DWORD m_dwHandle;
    TSurface m_Surface;
    TSurfDBEntry m_SurfDBEntry;
    EMemLocation m_eMemLocation;

public: // Functions
    CRTarget(): m_eMemLocation( None)
    { }
    // Video Memory representation constructor.
    CRTarget( DWORD dwHandle, const TSurface& Surface,
        const TSurfDBEntry& SurfDBEntry): m_dwHandle( dwHandle),
        m_Surface( Surface), m_SurfDBEntry( SurfDBEntry), m_eMemLocation( Video)
    { }
    ~CRTarget()
    { }

    bool operator==( const CRTarget& Other) const
    {
        const EMemLocation MemLocation( GetMemLocation());
        return MemLocation== Other.GetMemLocation()&&
            (None== MemLocation|| GetHandle()== Other.GetHandle());
    }
    bool operator!=( const CRTarget& Other) const
    { return !(*this== Other); }

    DWORD GetHandle() const
    {
        assert( GetMemLocation()!= None);
        return m_dwHandle;
    }
    TSurface& GetVidMemRepresentation()
    {
        assert( GetMemLocation()== Video);
        return m_Surface;
    }
    const TSurface& GetVidMemRepresentation() const
    {
        assert( GetMemLocation()== Video);
        return m_Surface;
    }
    TSurfDBEntry& GetSurfDBRepresentation()
    {
        assert( GetMemLocation()== Video);
        return m_SurfDBEntry;
    }
    const TSurfDBEntry& GetSurfDBRepresentation() const
    {
        assert( GetMemLocation()== Video);
        return m_SurfDBEntry;
    }
    EMemLocation GetMemLocation() const
    { return m_eMemLocation; }
    void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& Rect)
    {
        if( GetMemLocation()!= None)
            GetVidMemRepresentation()->Clear( DP2Clear, Rect);
    }
};

////////////////////////////////////////////////////////////////////////////////
//
// CSubContext
//
// This provides a base implementation for a context. It provides
// implementations for dealing with the SetRenderTarget and Clear
// DrawPrimitive2 commands; and also a minimal implementation for
// GetDriverState.
//
// <Template Parameters>
// TSuper: Standard parent type which is inheriting from this child class.
//     In this case, it should typically be the CMyContext type.
// TPDDD: The PerDDrawData type, typically CMyPerDDrawData or
//     CMinimalPerDDrawData<>.
// TDP2Data: This is some kind of wrapper class for PORTABLE_DRAWPRIMITIVES2DATA
//     The type is expected to inherit or emulate PORTABLE_DRAWPRIMITIVES2DATA's
//     fields/ member variables, and should typically be consistent with
//     CStdDrawPrimitives2< xxx >::TDP2Data.
//
// <Exposed Types>
// TPerDDrawData: The PerDDrawData type, passed in as the template parameter,
//     TPDDD.
// TDriver: This is equal to TPerDDrawData::TDriver. This type is exposed
//     only as a convience to the implementation to get at TDriver::TSurface.
// TSurface: This is equal to TDriver::TSurface. This type is exposed only
//     as a convience to the implementation.
//
// <Exposed Functions>
// CSubContext( TPerDDrawData&, TSurface*, TSurface*, DWORD): Constructor,
//     a typical SDDI Context isnt' expected to be created without this data.
// ~CSubContext(): Standard destructor.
// TPerDDrawData& GetPerDDrawData() const: Trivial accessor function to get at
//     the PerDDrawData.
// TSurface* GetRTarget() const: Trivial accessor function to get at the
//     current render target.
// TSurface* GetZBuffer() const: Trivial accessor function to get at the
//     current z/ stencil buffer.
// HRESULT DP2SetRenderTarget( TDP2Data&, const D3DHAL_DP2COMMAND*, const void*):
//     The default DP2 command processing member function for
//     D3DDP2OP_SETRENDERTARGET.
// void NewRenderTarget( TSurface*, TSurface*) const: Notification mechanism
//     called just before new render targets are saved into the member
//     variables. This notification mechanism is called by DP2SetRenderTarget.
// HRESULT DP2Clear( TDP2Data&, const D3DHAL_DP2COMMAND*, const void*):
//     The default DP2 command processing member function for D3DDP2OP_CLEAR.
//     This function relies on TSurface having a member function Clear.
// HRESULT GetDriverState( DDHAL_GETDRIVERSTATEDATA&): A minimal implementation
//     of GetDriverState, which should return S_FALSE if the id isn't
//     understood. This function should be overriden to add understanding for
//     custom ids.
//
////////////////////////////////////////////////////////////////////////////////
template< class TSuper, class TPDDD,
    class TRT= CRTarget< typename TPDDD::TDriver::TSurface*, typename TPDDD::TSurfDBEntry*>,
    class TDP2Data= CDP2DataWrap<> >
class CSubContext
{
public: // Types
    typedef TPDDD TPerDDrawData;
    typedef TRT TRTarget;

protected: // Variables
    TPerDDrawData& m_PerDDrawData;
    TRTarget m_ColorBuffer;
    TRTarget m_DepthBuffer;

protected: // Functions
    void NewColorBuffer() const 
    {
        // Override this notification mechanism to provide color buffer
        // state managing.
    }
    void NewDepthBuffer() const
    {
        // Override this notification mechanism to provide depth buffer
        // state managing.
    }

    CSubContext( TPerDDrawData& PerDDrawData, PORTABLE_CONTEXTCREATEDATA& ccd):
        m_PerDDrawData( PerDDrawData)
    {
        // To set the render targets, we must convert the structures to our
        // SurfDBEntry representation.
        typename TPerDDrawData::TDriver& Driver= PerDDrawData.GetDriver();

        if( ccd.lpDDSLcl()!= NULL)
        {
            typename TPerDDrawData::TDriver::TSurface* pSurface=
                Driver.GetSurface( *ccd.lpDDSLcl());
            if( pSurface!= NULL)
            {
                const DWORD dwHandle(
                    ccd.lpDDSLcl()->lpSurfMore()->dwSurfaceHandle());

                m_ColorBuffer= TRTarget( dwHandle, pSurface,
                    PerDDrawData.GetSurfDBEntry( dwHandle));
            }
        }
        if( ccd.lpDDSZLcl()!= NULL)
        {
            typename TPerDDrawData::TDriver::TSurface* pSurface=
                Driver.GetSurface( *ccd.lpDDSZLcl());
            if( pSurface!= NULL)
            {
                const DWORD dwHandle(
                    ccd.lpDDSZLcl()->lpSurfMore()->dwSurfaceHandle());

                m_DepthBuffer= TRTarget( dwHandle, pSurface,
                    PerDDrawData.GetSurfDBEntry( dwHandle));
            }
        }
    }
    ~CSubContext() 
    { }

public: // Functions
    TPerDDrawData& GetPerDDrawData() const  { return m_PerDDrawData; }
    const TRTarget& GetColorBuffer() const { return m_ColorBuffer; }
    TRTarget& GetColorBuffer() { return m_ColorBuffer; }
    const TRTarget& GetDepthBuffer() const { return m_DepthBuffer; }
    TRTarget& GetDepthBuffer() { return m_DepthBuffer; }

    HRESULT DP2SetRenderTarget( TDP2Data& DP2Data, const D3DHAL_DP2COMMAND*
        pCmd, const void* pP) 
    {
        const D3DHAL_DP2SETRENDERTARGET* pParam=
            reinterpret_cast< const D3DHAL_DP2SETRENDERTARGET*>( pP);
        TSuper* pSThis= static_cast< TSuper*>( this);
        WORD wStateCount( pCmd->wStateCount);

        if( wStateCount!= 0)
        {
            TPerDDrawData& PerDDrawData= GetPerDDrawData();
            typename TPerDDrawData::TDriver& Driver= PerDDrawData.GetDriver();

            do
            {
                // To set the render targets, we must convert the handles to our
                // SurfDBEntry representation.
                typename TPerDDrawData::TSurfDBEntry* pSurfDBEntry=
                    PerDDrawData.GetSurfDBEntry( pParam->hRenderTarget);
                if( pSurfDBEntry!= NULL)
                {
                    // We can immediately convert the SurfDBEntry representation to our
                    // Video Memory object, because Render Targets MUST be VM.
                    typename TPerDDrawData::TDriver::TSurface* pSurface=
                        Driver.GetSurface( *pSurfDBEntry);
                    if( pSurface!= NULL)
                    {
                        m_ColorBuffer= TRTarget( pParam->hRenderTarget,
                            pSurface, pSurfDBEntry);
                        pSThis->NewColorBuffer();
                    }
                }

                pSurfDBEntry= PerDDrawData.GetSurfDBEntry( pParam->hZBuffer);
                if( pSurfDBEntry!= NULL)
                {
                    // We can immediately convert the SurfDBEntry representation to our
                    // Video Memory object, because Render Targets MUST be VM.
                    typename TPerDDrawData::TDriver::TSurface* pSurface=
                        Driver.GetSurface( *pSurfDBEntry);
                    if( pSurface!= NULL)
                    {
                        m_DepthBuffer= TRTarget( pParam->hZBuffer,
                            pSurface, pSurfDBEntry);
                        pSThis->NewDepthBuffer();
                    }
                }
            } while( --wStateCount!= 0);
        }
        return DD_OK;
    }
    HRESULT DP2Clear( TDP2Data& DP2Data, const D3DHAL_DP2COMMAND* pCmd,
        const void* pP) 
    {
        const D3DHAL_DP2CLEAR* pParam= reinterpret_cast< const D3DHAL_DP2CLEAR*>
            ( pP);

        TSuper* pSThis= static_cast< TSuper*>( this);
        const D3DHAL_DP2VIEWPORTINFO CurViewport( *pSThis);
        RECT ViewportRect;
        ViewportRect.left= CurViewport.dwX;
        ViewportRect.top= CurViewport.dwY;
        ViewportRect.right= CurViewport.dwX+ CurViewport.dwWidth;
        ViewportRect.bottom= CurViewport.dwY+ CurViewport.dwHeight;

        TRTarget& ColorBuffer= GetColorBuffer();
        TRTarget& DepthBuffer= GetDepthBuffer();
        const bool bClearBoth(!(ColorBuffer== DepthBuffer));

        if( 0== pCmd->wStateCount)
        {
            if( TRTarget::EMemLocation::None!= ColorBuffer.GetMemLocation())
                ColorBuffer.Clear( *pParam, ViewportRect);
            if( TRTarget::EMemLocation::None!= DepthBuffer.GetMemLocation()&&
                bClearBoth)
                DepthBuffer.Clear( *pParam, ViewportRect);
        }
        else
        {
            WORD wStateCount( pCmd->wStateCount);
            const RECT* pRect= pParam->Rects;

            if((pParam->dwFlags& D3DCLEAR_COMPUTERECTS)!= 0)
            {
                // Clip rect to viewport.
                RECT rcClipped( *pRect);
                do
                {
                    clamp_min( rcClipped.left, ViewportRect.left);
                    clamp_min( rcClipped.top, ViewportRect.top);
                    clamp( rcClipped.right, rcClipped.left, ViewportRect.right);
                    clamp( rcClipped.bottom, rcClipped.top, ViewportRect.bottom);

                    if( TRTarget::EMemLocation::None!=
                        ColorBuffer.GetMemLocation())
                        ColorBuffer.Clear( *pParam, rcClipped);
                    if( TRTarget::EMemLocation::None!=
                        DepthBuffer.GetMemLocation()&& bClearBoth)
                        DepthBuffer.Clear( *pParam, rcClipped);
                    pRect++;
                } while( --wStateCount);
            }
            else
            {
                do
                {
                    if( TRTarget::EMemLocation::None!=
                        ColorBuffer.GetMemLocation())
                        ColorBuffer.Clear( *pParam, *pRect);
                    if( TRTarget::EMemLocation::None!=
                        DepthBuffer.GetMemLocation()&& bClearBoth)
                        DepthBuffer.Clear( *pParam, *pRect);
                    pRect++;
                }  while( --wStateCount);
            }
        }
        return DD_OK;
    }

    // A minimal implementation of GetDriverState, which should return S_FALSE
    // if the id isn't understood. Override this function to add understanding.
    HRESULT GetDriverState( DDHAL_GETDRIVERSTATEDATA& gdsd)
    { return S_FALSE; }
};

////////////////////////////////////////////////////////////////////////////////
//
// CMinimalContext
//
// This class contains a minimal implementation of a Context for a driver,
// which supports only one stream, no TnL, and legacy pixel shading. This
// Context still needs an implementation of the primitive drawing functions,
// which it uses a Rasterizer class for. CMinimalContext takes care of most
// of the responsibilities of a SDDI driver, except rasterization. 
//
// <Template Parameters>
// TPDDD: The PerDDrawData type, typically CMyPerDDrawData or
//     CMinimalPerDDrawData<>.
// TR: The Rasterizer type, typically CMyRasterizer.
//
////////////////////////////////////////////////////////////////////////////////
template< class TPDDD, class TR>
class CMinimalContext:
    public CSubContext< CMinimalContext< TPDDD, TR>, TPDDD>,
    public CStdDrawPrimitives2< CMinimalContext< TPDDD, TR> >,
    public CStdDP2ViewportInfoStore< CMinimalContext< TPDDD, TR> >,
    public CStdDP2WInfoStore< CMinimalContext< TPDDD, TR> >,
    public CStdDP2RenderStateStore< CMinimalContext< TPDDD, TR> >,
    public CStdDP2TextureStageStateStore< CMinimalContext< TPDDD, TR> >,
    public CStdDP2SetVertexShaderStore< CMinimalContext< TPDDD, TR> >,
    public CStdDP2VStreamManager< CMinimalContext< TPDDD, TR> >,
    public CStdDP2IStreamManager< CMinimalContext< TPDDD, TR> >
{
public: // Types
    typedef TPDDD TPerDDrawData;
    typedef TR TRasterizer;
    typedef block< TDP2CmdBind, 15> TDP2Bindings;
    typedef block< TRecDP2CmdBind, 7> TRecDP2Bindings;

protected: // Variables
    TRasterizer m_Rasterizer;
    static const TDP2Bindings c_DP2Bindings;
    static const TRecDP2Bindings c_RecDP2Bindings;

public: // Functions
    CMinimalContext( TPerDDrawData& PDDD, PORTABLE_CONTEXTCREATEDATA& ccd)
        : CSubContext< CMinimalContext< TPDDD, TR>, TPDDD>( PDDD, ccd),
        CStdDrawPrimitives2< CMinimalContext< TPDDD, TR>>(
            c_DP2Bindings.begin(), c_DP2Bindings.end(),
            c_RecDP2Bindings.begin(), c_RecDP2Bindings.end())
    {
        // These keep the arrays in sync with their typedef.
        assert( D3DDP2OP_CLIPPEDTRIANGLEFAN== *c_DP2Bindings.rbegin());
        assert( D3DDP2OP_SETINDICES== *c_RecDP2Bindings.rbegin());
    }
    ~CMinimalContext()  { }

    // Provide this function to ease minimal implementations.
    HRESULT ValidateTextureStageState( const D3DHAL_VALIDATETEXTURESTAGESTATEDATA&
        vsssd) const
    { return DD_OK; }

    HRESULT DP2DrawPrimitive( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_DP2DRAWPRIMITIVE* pParam= reinterpret_cast<
            const D3DHAL_DP2DRAWPRIMITIVE*>(pP);
        return m_Rasterizer.DrawPrimitive( *this, *pCmd, pParam);
    }
    HRESULT DP2DrawPrimitive2( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_DP2DRAWPRIMITIVE2* pParam= reinterpret_cast<
            const D3DHAL_DP2DRAWPRIMITIVE2*>(pP);
        return m_Rasterizer.DrawPrimitive2( *this, *pCmd, pParam);
    }
    HRESULT DP2DrawIndexedPrimitive( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_DP2DRAWINDEXEDPRIMITIVE* pParam= reinterpret_cast<
            const D3DHAL_DP2DRAWINDEXEDPRIMITIVE*>(pP);
        return m_Rasterizer.DrawIndexedPrimitive( *this, *pCmd, pParam);
    }
    HRESULT DP2DrawIndexedPrimitive2( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_DP2DRAWINDEXEDPRIMITIVE2* pParam= reinterpret_cast<
            const D3DHAL_DP2DRAWINDEXEDPRIMITIVE2*>(pP);
        return m_Rasterizer.DrawIndexedPrimitive2( *this, *pCmd, pParam);
    }
    HRESULT DP2ClippedTriangleFan( TDP2Data& DP2Data,
        const D3DHAL_DP2COMMAND* pCmd, const void* pP)
    {
        const D3DHAL_CLIPPEDTRIANGLEFAN* pParam= reinterpret_cast<
            const D3DHAL_CLIPPEDTRIANGLEFAN*>(pP);
        return m_Rasterizer.ClippedTriangleFan( *this, *pCmd, pParam);
    }
};

// These tables require TConstDP2Bindings to be changed also, with the number
// of bindings.
template< class TPDDD, class TR>
const typename CMinimalContext< TPDDD, TR>::TDP2Bindings
    CMinimalContext< TPDDD, TR>::c_DP2Bindings=
{
    D3DDP2OP_VIEWPORTINFO,          DP2ViewportInfo,
    D3DDP2OP_WINFO,                 DP2WInfo,
    D3DDP2OP_RENDERSTATE,           DP2RenderState,
    D3DDP2OP_TEXTURESTAGESTATE,     DP2TextureStageState,
    D3DDP2OP_CLEAR,                 DP2Clear,
    D3DDP2OP_SETRENDERTARGET,       DP2SetRenderTarget,
    D3DDP2OP_SETVERTEXSHADER,       DP2SetVertexShader,
    D3DDP2OP_SETSTREAMSOURCE,       DP2SetStreamSource,
    D3DDP2OP_SETSTREAMSOURCEUM,     DP2SetStreamSourceUM,
    D3DDP2OP_SETINDICES,            DP2SetIndices,
    D3DDP2OP_DRAWPRIMITIVE,         DP2DrawPrimitive,
    D3DDP2OP_DRAWPRIMITIVE2,        DP2DrawPrimitive2,
    D3DDP2OP_DRAWINDEXEDPRIMITIVE,  DP2DrawIndexedPrimitive,
    D3DDP2OP_DRAWINDEXEDPRIMITIVE2, DP2DrawIndexedPrimitive2,
    D3DDP2OP_CLIPPEDTRIANGLEFAN,    DP2ClippedTriangleFan
};

// These tables require TConstRecDP2Bindings to be changed also, with the number
// of bindings.
template< class TPDDD, class TR>
const typename CMinimalContext< TPDDD, TR>::TRecDP2Bindings
    CMinimalContext< TPDDD, TR>::c_RecDP2Bindings=
{
    D3DDP2OP_VIEWPORTINFO,          RecDP2ViewportInfo,
    D3DDP2OP_WINFO,                 RecDP2WInfo,
    D3DDP2OP_RENDERSTATE,           RecDP2RenderState,
    D3DDP2OP_TEXTURESTAGESTATE,     RecDP2TextureStageState,
    D3DDP2OP_SETVERTEXSHADER,       RecDP2SetVertexShader,
    D3DDP2OP_SETSTREAMSOURCE,       RecDP2SetStreamSource,
    D3DDP2OP_SETINDICES,            RecDP2SetIndices
};

class IVidMemSurface
{
protected: // Variables
    DWORD m_dwHandle;

protected: // Functions
    IVidMemSurface( DWORD dwHandle) : m_dwHandle( dwHandle) { }

public: // Functions
    DWORD GetHandle() const 
    { return m_dwHandle; }
    virtual ~IVidMemSurface() 
    { }
    virtual void* Lock( DWORD dwFlags, const RECTL* pRect)= 0;
    virtual void Unlock( void)= 0;
    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC)= 0;
};

struct SD3DDataConv
{
    // A( 0), R( 1), G( 2), B( 3), Z( 4), S( 5)
    typedef block< DWORD, 6> TMasks;
    // A( 0), R( 1), G( 2), B( 3), Z( 4), ZBits( 5), S( 6), SBits( 7)
    typedef block< signed char, 8> TD3DBitShftRgt;
    TMasks m_ToSurfMasks;
    TD3DBitShftRgt m_D3DBitShftRgt;

    SD3DDataConv()
    {
        fill( m_ToSurfMasks.begin(), m_ToSurfMasks.end(),
            static_cast< TMasks::value_type>( 0));
        fill( m_D3DBitShftRgt.begin(), m_D3DBitShftRgt.end(),
            static_cast< TD3DBitShftRgt::value_type>( 0));
    }
    SD3DDataConv( const DDPIXELFORMAT& PF) 
    { (*this)= PF; }
    SD3DDataConv& operator=( const DDPIXELFORMAT& PF) 
    {
        const block< signed char, 4> D3DHighBitPos= {31,23,15,7};

        fill( m_ToSurfMasks.begin(), m_ToSurfMasks.end(),
            static_cast< TMasks::value_type>( 0));
        fill( m_D3DBitShftRgt.begin(), m_D3DBitShftRgt.end(),
            static_cast< TD3DBitShftRgt::value_type>( 0));

        // Alpha
        if((PF.dwFlags& DDPF_ALPHA)!= 0)
        {
            assert( PF.dwAlphaBitDepth< 32);
            m_ToSurfMasks[ 0]= (0x1<< PF.dwAlphaBitDepth)- 1;
        }
        else if((PF.dwFlags& DDPF_ALPHAPIXELS)!= 0)
            m_ToSurfMasks[ 0]= PF.dwRGBAlphaBitMask;

        // RGB Color
        if((PF.dwFlags& DDPF_RGB)!= 0)
        {
            m_ToSurfMasks[ 1]= PF.dwRBitMask;
            m_ToSurfMasks[ 2]= PF.dwGBitMask;
            m_ToSurfMasks[ 3]= PF.dwBBitMask;
        }

        // Z
        if((PF.dwFlags& DDPF_ZBUFFER)!= 0)
        {
            m_D3DBitShftRgt[ 5]= PF.dwZBufferBitDepth;
            if( 32== PF.dwZBufferBitDepth)
                m_ToSurfMasks[ 4]= 0xFFFFFFFF;
            else
                m_ToSurfMasks[ 4]= (0x1<< PF.dwZBufferBitDepth)- 1;
        }
        else if((PF.dwFlags& DDPF_ZPIXELS)!= 0)
        {
            DWORD dwZBitMask( PF.dwRGBZBitMask);
            m_ToSurfMasks[ 5]= PF.dwRGBZBitMask;

            while((dwZBitMask& 1)== 0)
            {
                m_D3DBitShftRgt[ 4]--;
                dwZBitMask>>= 1;
            }

            while((dwZBitMask& 1)!= 0)
            {
                dwZBitMask>>= 1;
                m_D3DBitShftRgt[ 5]++;
            }
        }

        // Stensil
        if((PF.dwFlags& DDPF_STENCILBUFFER)!= 0)
        {
            DWORD dwSBitMask( PF.dwStencilBitMask);
            m_ToSurfMasks[ 6]= PF.dwStencilBitMask;

            while((dwSBitMask& 1)== 0)
            {
                m_D3DBitShftRgt[ 6]--;
                dwSBitMask>>= 1;
            }

            while((dwSBitMask& 1)!= 0)
            {
                dwSBitMask>>= 1;
                m_D3DBitShftRgt[ 7]++;
            }
        }

        block< signed char, 4>::const_iterator itD3DBitPos( D3DHighBitPos.begin());
        TD3DBitShftRgt::iterator itBitShftRgt( m_D3DBitShftRgt.begin());
        TMasks::const_iterator itToSurfMask( m_ToSurfMasks.begin());

        while( itD3DBitPos!= D3DHighBitPos.end())
        {
            signed char iBitPos( 31);
            TMasks::value_type dwMask( 0x80000000);

            while((dwMask& *itToSurfMask)== 0 && iBitPos>= 0)
            {
                dwMask>>= 1;
                iBitPos--;
            }

            *itBitShftRgt= ( iBitPos>= 0? *itD3DBitPos- iBitPos: 0);

            ++itD3DBitPos;
            ++itToSurfMask;
            ++itBitShftRgt;
        }
        return *this;
    }
    // SurfData, ValidMask
    pair< UINT32, UINT32> ConvColor( D3DCOLOR D3DColor) const 
    {
        pair< UINT32, UINT32> RetVal( 0, 0);

        const block< DWORD, 4> FromD3DMasks= {0xFF000000,0xFF0000,0xFF00,0xFF};

        TD3DBitShftRgt::const_iterator itBitShftRgt( m_D3DBitShftRgt.begin());
        block< DWORD, 4>::const_iterator itFromMask( FromD3DMasks.begin());
        TMasks::const_iterator itToMask( m_ToSurfMasks.begin());
        while( itFromMask!= FromD3DMasks.end())
        {
            const UINT32 uiTmp( D3DColor& *itFromMask);
            
            RetVal.first|= *itToMask& (*itBitShftRgt>= 0?
                uiTmp>> *itBitShftRgt: uiTmp<< *itBitShftRgt);
            RetVal.second|= *itToMask;

            ++itBitShftRgt;
            ++itToMask;
            ++itFromMask;
        }
        return RetVal;
    }
    // SurfData, ValidMask
    pair< UINT32, UINT32> ConvZ( D3DVALUE D3DZ) const 
    {
        CEnsureFPUModeForC FPUMode;

        if( D3DZ> 1.0f)
            D3DZ= 1.0f;
        else if( D3DZ< 0.0f)
            D3DZ= 0.0f;

        pair< UINT32, UINT32> RetVal( 0, 0);

        const UINT32 uiMaxZ( m_D3DBitShftRgt[ 5]== 32? 0xFFFFFFFF:
            (0x1<< m_D3DBitShftRgt[ 5])- 1);

        const UINT32 uiZVal( static_cast<UINT32>( 
            static_cast< DOUBLE>(D3DZ)* static_cast< DOUBLE>(uiMaxZ)+ 0.5));

        RetVal.first|= m_ToSurfMasks[ 4]& (m_D3DBitShftRgt[ 4]>= 0?
            uiZVal>> m_D3DBitShftRgt[ 4]: uiZVal<< m_D3DBitShftRgt[ 4]);
        RetVal.second|= m_ToSurfMasks[ 4];
        return RetVal;
    }
    // SurfData, ValidMask
    pair< UINT32, UINT32> ConvS( DWORD D3DStensil) const 
    {
        pair< UINT32, UINT32> RetVal( 0, 0);

        RetVal.first|= m_ToSurfMasks[ 5]& (m_D3DBitShftRgt[ 6]>= 0?
            D3DStensil>> m_D3DBitShftRgt[ 6]: D3DStensil<< m_D3DBitShftRgt[ 6]);
        RetVal.second|= m_ToSurfMasks[ 5];
        return RetVal;
    }
};

class CGenSurface:
    public IVidMemSurface
{
public: // Types
    typedef unsigned int TLocks;

protected: // Variables
    SD3DDataConv m_D3DDataConv;
    DWORD m_dwCaps;
    TLocks m_uiLocks;

    // Regular data
    void* m_pData;
    LONG m_lPitch;
    size_t m_uiBytes;
    WORD m_wWidth;
    WORD m_wHeight;

    unsigned char m_ucBPP;

public: // Functions
    CGenSurface( const DDSURFACEDESC& SDesc, PORTABLE_DDRAWSURFACE_LCL& DDSurf)
        :IVidMemSurface( DDSurf.lpSurfMore()->dwSurfaceHandle()),
        m_dwCaps( SDesc.ddsCaps.dwCaps), m_uiLocks( 0), m_pData( NULL),
        m_lPitch( 0), m_uiBytes( 0), m_wWidth( DDSurf.lpGbl()->wWidth),
        m_wHeight( DDSurf.lpGbl()->wHeight), m_ucBPP( 0)
    {
        size_t uiBytesPerPixel( 0);

        // Certain data needs to be written into the DDSurf description,
        // so that the DXG runtime and the app will know characteristics
        // about the surface. (fpVidMem, lPitch, etc.)

        // DO NOT STORE &DDSurf! This is considered illegal. The typical
        // implementation contains a surfaceDB which contains copies of the
        // DDRAWI_ structures.

        if((SDesc.dwFlags& DDSD_PIXELFORMAT)!= 0)
        {
            // CGenSurface can only be used for byte-aligned pixels.
            assert( 8== SDesc.ddpfPixelFormat.dwRGBBitCount ||
                16== SDesc.ddpfPixelFormat.dwRGBBitCount ||
                24== SDesc.ddpfPixelFormat.dwRGBBitCount ||
                32== SDesc.ddpfPixelFormat.dwRGBBitCount);

            m_D3DDataConv= SDesc.ddpfPixelFormat;
            m_ucBPP= static_cast<unsigned char>(
                SDesc.ddpfPixelFormat.dwRGBBitCount>> 3);

            // Align the Pitch/ Width.
            DDSurf.lpGbl()->lPitch= m_lPitch= ((m_ucBPP* m_wWidth+ 7)& ~7);
            m_uiBytes= m_lPitch* m_wHeight;
        }
        else if((m_dwCaps& DDSCAPS_EXECUTEBUFFER)!= 0)
        {
            // Execute buffers are considered linear and byte-sized.
            m_lPitch= DDSurf.lpGbl()->lPitch;
            m_uiBytes= m_lPitch* m_wHeight;
        }
        else
        {
            const bool Unsupported_Surface_In_Allocation_Routine2( false);
            assert( Unsupported_Surface_In_Allocation_Routine2);
        }

        // It would've been nice to have the initial proctection NOACCESS, but
        // it seems the HAL needs to read to the region, initially.
        m_pData= VirtualAlloc( NULL, m_uiBytes, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
        if( m_pData== NULL)
            throw bad_alloc( "Not enough memory to allocate Surface data");
        DDSurf.lpGbl()->fpVidMem= reinterpret_cast<FLATPTR>(m_pData);
    }
    virtual ~CGenSurface() 
    {
        // Warning: m_uiLocks doesn't have to be 0. The run-time will destroy
        // a surface without un-locking it.
        assert( m_pData!= NULL);
        VirtualFree( m_pData, 0, MEM_DECOMMIT| MEM_RELEASE);
    }
    virtual void* Lock( DWORD dwFlags, const RECTL* pRect) 
    {
        // Typically, m_uiLocks!= 0 equals bad design or bug. But, it is valid.
        // Second Dummy removes vc6 unrefd variable warning.
        numeric_limits< TLocks> Dummy; Dummy;
        assert( Dummy.max()!= m_uiLocks);
        ++m_uiLocks;

        if( pRect!= NULL)
        {
            // If it is either a 1) VB, 2) IB or 3) CB then the rect has a
            // special meaning. rect.top - rect.bottom gives the range of
            // memory desired, because of being linear.
            if((m_dwCaps& DDSCAPS_EXECUTEBUFFER)!= 0)
            {
                return static_cast<void*>( reinterpret_cast<UINT8*>(
                    m_pData)+ pRect->top);
            }
            else
            {
                return static_cast<void*>( reinterpret_cast<UINT8*>(
                    m_pData)+ pRect->top* m_lPitch+ pRect->left* m_ucBPP);
            }
        }
        else
            return m_pData;
    }
    virtual void Unlock( void) 
    {
        assert( 0!= m_uiLocks);
        --m_uiLocks;
    }
    virtual void Clear( const D3DHAL_DP2CLEAR& DP2Clear, const RECT& RC) 
    {
        // A VB, IB, or CB should never be asked to 'Clear'. Only
        // RenderTargets and ZBuffers, etc.
        assert((m_dwCaps& DDSCAPS_EXECUTEBUFFER)== 0);

        // Check for empty RECT.
        if((RC.left>= RC.right) || (RC.top>= RC.bottom))
            return;

        assert( 1<= m_ucBPP && 4>= m_ucBPP);
        UINT32 ui32BitFill( 0), ui32BitValidMask( 0);
        UINT32 ui32BitSMask( 4== m_ucBPP? 0xFFFFFFFF: (1<< (m_ucBPP* 8))- 1);

        pair< UINT32, UINT32> RetVal;
        if((DP2Clear.dwFlags& D3DCLEAR_TARGET)!= 0)
        {
            RetVal= m_D3DDataConv.ConvColor( DP2Clear.dwFillColor);
            ui32BitFill|= RetVal.first;
            ui32BitValidMask|= RetVal.second;
        }
        if((DP2Clear.dwFlags& D3DCLEAR_ZBUFFER)!= 0)
        {
            RetVal= m_D3DDataConv.ConvZ( DP2Clear.dvFillDepth);
            ui32BitFill|= RetVal.first;
            ui32BitValidMask|= RetVal.second;
        }
        if((DP2Clear.dwFlags& D3DCLEAR_STENCIL)!= 0)
        {
            RetVal= m_D3DDataConv.ConvS( DP2Clear.dwFillStencil);
            ui32BitFill|= RetVal.first;
            ui32BitValidMask|= RetVal.second;
        }

        RECTL RectL;
        RectL.top= RC.top;
        RectL.left= RC.left;
        RectL.bottom= RC.bottom;
        RectL.right= RC.right;
        unsigned int iRow( RC.bottom- RC.top);
        const unsigned int iCols( RC.right- RC.left);

        // New scope for SurfaceLocker.
        { 
            CSurfaceLocker< CGenSurface*> MySLocker( this, 0, &RectL);
            UINT8* pSData= reinterpret_cast<UINT8*>( MySLocker.GetData());

            if( 3== m_ucBPP)
            {
                UINT32 ui32FillData[3];
                ui32FillData[0]= ((ui32BitFill& 0xFFFFFF)<< 8)|
                    ((ui32BitFill& 0xFF0000)>> 16);
                ui32FillData[1]= ((ui32BitFill& 0x00FFFF)<< 16)|
                    ((ui32BitFill& 0xFFFF00)>> 8);
                ui32FillData[2]= ((ui32BitFill& 0x0000FF)<< 24)|
                    ((ui32BitFill& 0xFFFFFF)>> 0);

                // Little-endian implementation.
                UINT8 ui8FillData[3];
                ui8FillData[0]= (0xFF& ui32BitFill);
                ui8FillData[1]= (0xFF00& ui32BitFill)>> 8;
                ui8FillData[2]= (0xFF0000& ui32BitFill)>> 16;

                if( ui32BitSMask== ui32BitValidMask)
                {
                    // Only fill, no need to read, modify, write.
                    do
                    {
                        UINT32* p32Data= reinterpret_cast<UINT32*>(pSData);

                        // We've packed 4 pixels of data in 3 UINT32.
                        unsigned int iCol( iCols>> 2); // (>> 2) == (/ 4)

                        // Unroll.
                        if( iCol!= 0) do
                        {
                            p32Data[ 0]= ui32FillData[0];
                            p32Data[ 1]= ui32FillData[1];
                            p32Data[ 2]= ui32FillData[2];
                            p32Data[ 3]= ui32FillData[0];
                            p32Data[ 4]= ui32FillData[1];
                            p32Data[ 5]= ui32FillData[2];
                            p32Data[ 6]= ui32FillData[0];
                            p32Data[ 7]= ui32FillData[1];
                            p32Data[ 8]= ui32FillData[2];
                            p32Data[ 9]= ui32FillData[0];
                            p32Data[10]= ui32FillData[1];
                            p32Data[11]= ui32FillData[2];
                            p32Data+= 12;
                        } while( --iCol);

                        iCol= iCols& 0x3; // (% 4) == (& 0x3)
                        if( iCol!= 0) {
                            UINT8* p8Data= reinterpret_cast<UINT8*>(p32Data);
                            do
                            {
                                p8Data[0]= ui8FillData[0];
                                p8Data[1]= ui8FillData[1];
                                p8Data[2]= ui8FillData[2];
                                p8Data+= 3;
                            } while( --iCol);
                        }

                        pSData+= m_lPitch;
                    } while( --iRow);
                }
                else
                {
                    const UINT32 ui32BitMask= ~ui32BitValidMask;
                    UINT32 ui32MaskData[3];
                    ui32MaskData[0]= ((ui32BitMask& 0xFFFFFF)<< 8)|
                        ((ui32BitMask& 0xFF0000)>> 16);
                    ui32MaskData[1]= ((ui32BitMask& 0x00FFFF)<< 16)|
                        ((ui32BitMask& 0xFFFF00)>> 8);
                    ui32MaskData[2]= ((ui32BitMask& 0x0000FF)<< 24)|
                        ((ui32BitMask& 0xFFFFFF)>> 0);

                    UINT8 ui8MaskData[3];
                    ui8MaskData[0]= (0xFF& ui32BitMask);
                    ui8MaskData[1]= (0xFF00& ui32BitMask)>> 8;
                    ui8MaskData[2]= (0xFF0000& ui32BitMask)>> 16;

                    // Need to mask in the data.
                    do
                    {
                        UINT32* p32Data= reinterpret_cast<UINT32*>(pSData);

                        // We've packed 4 pixels of data in 3 UINT32.
                        int iCol( iCols>> 2); // (>> 2) == (/ 4)

                        // Unroll.
                        if( iCol!= 0) do
                        {
                            p32Data[ 0]= (p32Data[ 0]& ui32MaskData[0])| ui32FillData[0];
                            p32Data[ 1]= (p32Data[ 1]& ui32MaskData[1])| ui32FillData[1];
                            p32Data[ 2]= (p32Data[ 2]& ui32MaskData[2])| ui32FillData[2];
                            p32Data[ 3]= (p32Data[ 3]& ui32MaskData[0])| ui32FillData[0];
                            p32Data[ 4]= (p32Data[ 4]& ui32MaskData[1])| ui32FillData[1];
                            p32Data[ 5]= (p32Data[ 5]& ui32MaskData[2])| ui32FillData[2];
                            p32Data[ 6]= (p32Data[ 6]& ui32MaskData[0])| ui32FillData[0];
                            p32Data[ 7]= (p32Data[ 7]& ui32MaskData[1])| ui32FillData[1];
                            p32Data[ 8]= (p32Data[ 8]& ui32MaskData[2])| ui32FillData[2];
                            p32Data[ 9]= (p32Data[ 9]& ui32MaskData[0])| ui32FillData[0];
                            p32Data[10]= (p32Data[10]& ui32MaskData[1])| ui32FillData[1];
                            p32Data[11]= (p32Data[11]& ui32MaskData[2])| ui32FillData[2];
                            p32Data+= 12;
                        } while( --iCol);

                        iCol= iCols& 0x3; // (% 4) == (& 0x3)
                        if( iCol!= 0) {
                            UINT8* p8Data= reinterpret_cast<UINT8*>(p32Data);
                            do
                            {
                                p8Data[0]= (p8Data[0]& ui8MaskData[0])| ui8FillData[0];
                                p8Data[1]= (p8Data[1]& ui8MaskData[1])| ui8FillData[1];
                                p8Data[2]= (p8Data[2]& ui8MaskData[2])| ui8FillData[2];
                                p8Data+= 3;
                            } while( --iCol);
                        }

                        pSData+= m_lPitch;
                    } while( --iRow);
                }
            }
            else
            {
                unsigned int uiPakedPixels;
                unsigned int uiPixelsLeft;
                UINT32 ui32FillData;
                UINT32 ui32MaskData;
                if( 1== m_ucBPP)
                {
                    uiPakedPixels= iCols>> 6;
                    uiPixelsLeft= iCols& 0x3F;
                    ui32FillData= (ui32BitFill& 0xFF)|
                        ((ui32BitFill& 0xFF)<< 8)|
                        ((ui32BitFill& 0xFF)<< 16)|
                        ((ui32BitFill& 0xFF)<< 24);
                    ui32MaskData= (~ui32BitValidMask& 0xFF)|
                        ((~ui32BitValidMask& 0xFF)<< 8)|
                        ((~ui32BitValidMask& 0xFF)<< 16)|
                        ((~ui32BitValidMask& 0xFF)<< 24);
                }
                else if( 2== m_ucBPP)
                {
                    uiPakedPixels= iCols>> 5;
                    uiPixelsLeft= iCols& 0x1F;
                    ui32FillData= (ui32BitFill& 0xFFFF)|
                        ((ui32BitFill& 0xFFFF)<< 16);
                    ui32MaskData= (~ui32BitValidMask& 0xFFFF)|
                        ((~ui32BitValidMask& 0xFFFF)<< 16);
                }
                else if( 4== m_ucBPP)
                {
                    uiPakedPixels= iCols>> 4;
                    uiPixelsLeft= iCols& 0xF;
                    ui32FillData= ui32BitFill;
                    ui32MaskData= ~ui32BitValidMask;
                }

                if( ui32BitSMask== ui32BitValidMask)
                {
                    // Only fill, no need to read, modify, write.
                    do
                    {
                        UINT32* p32Data= reinterpret_cast<UINT32*>(pSData);

                        // We've packed pixels of data in a UINT32.
                        unsigned int iCol( uiPakedPixels);

                        // Unroll.
                        if( iCol!= 0) do
                        {
                            p32Data[ 0]= ui32FillData;
                            p32Data[ 1]= ui32FillData;
                            p32Data[ 2]= ui32FillData;
                            p32Data[ 3]= ui32FillData;
                            p32Data[ 4]= ui32FillData;
                            p32Data[ 5]= ui32FillData;
                            p32Data[ 6]= ui32FillData;
                            p32Data[ 7]= ui32FillData;
                            p32Data[ 8]= ui32FillData;
                            p32Data[ 9]= ui32FillData;
                            p32Data[10]= ui32FillData;
                            p32Data[11]= ui32FillData;
                            p32Data[12]= ui32FillData;
                            p32Data[13]= ui32FillData;
                            p32Data[14]= ui32FillData;
                            p32Data[15]= ui32FillData;
                            p32Data+= 16;
                        } while( --iCol);

                        iCol= uiPixelsLeft;
                        if( iCol!= 0) {
                            if( 1== m_ucBPP)
                            {
                                UINT8 ui8FillData= ui32FillData& 0xFF;
                                UINT8* p8Data= reinterpret_cast<UINT8*>(p32Data);
                                do
                                {
                                    p8Data[0]= ui8FillData;
                                    p8Data++;
                                } while( --iCol);
                            }
                            else if( 2== m_ucBPP)
                            {
                                UINT16 ui16FillData= ui32FillData& 0xFFFF;
                                UINT16* p16Data= reinterpret_cast<UINT16*>(p32Data);
                                do
                                {
                                    p16Data[0]= ui16FillData;
                                    p16Data++;
                                } while( --iCol);
                            }
                            else if( 4== m_ucBPP)
                            {
                                do
                                {
                                    p32Data[0]= ui32FillData;
                                    p32Data++;
                                } while( --iCol);
                            }
                        }

                        pSData+= m_lPitch;
                    } while( --iRow);
                }
                else
                {
                    // Need to mask in the data.
                    do
                    {
                        UINT32* p32Data= reinterpret_cast<UINT32*>(pSData);

                        // We've packed pixels of data in a UINT32.
                        unsigned int iCol( uiPakedPixels);

                        // Unroll.
                        if( iCol!= 0) do
                        {
                            p32Data[ 0]= (p32Data[ 0]& ui32MaskData)| ui32FillData;
                            p32Data[ 1]= (p32Data[ 1]& ui32MaskData)| ui32FillData;
                            p32Data[ 2]= (p32Data[ 2]& ui32MaskData)| ui32FillData;
                            p32Data[ 3]= (p32Data[ 3]& ui32MaskData)| ui32FillData;
                            p32Data[ 4]= (p32Data[ 4]& ui32MaskData)| ui32FillData;
                            p32Data[ 5]= (p32Data[ 5]& ui32MaskData)| ui32FillData;
                            p32Data[ 6]= (p32Data[ 6]& ui32MaskData)| ui32FillData;
                            p32Data[ 7]= (p32Data[ 7]& ui32MaskData)| ui32FillData;
                            p32Data[ 8]= (p32Data[ 8]& ui32MaskData)| ui32FillData;
                            p32Data[ 9]= (p32Data[ 9]& ui32MaskData)| ui32FillData;
                            p32Data[10]= (p32Data[10]& ui32MaskData)| ui32FillData;
                            p32Data[11]= (p32Data[11]& ui32MaskData)| ui32FillData;
                            p32Data[12]= (p32Data[12]& ui32MaskData)| ui32FillData;
                            p32Data[13]= (p32Data[13]& ui32MaskData)| ui32FillData;
                            p32Data[14]= (p32Data[14]& ui32MaskData)| ui32FillData;
                            p32Data[15]= (p32Data[15]& ui32MaskData)| ui32FillData;
                            p32Data+= 16;
                        } while( --iCol);

                        iCol= uiPixelsLeft;
                        if( iCol!= 0) {
                            if( 1== m_ucBPP)
                            {
                                UINT8 ui8FillData= ui32FillData& 0xFF;
                                UINT8 ui8MaskData= ui32MaskData& 0xFF;
                                UINT8* p8Data= reinterpret_cast<UINT8*>(p32Data);
                                do
                                {
                                    p8Data[0]= (p8Data[0]& ui8MaskData)| ui8FillData;
                                    p8Data++;
                                } while( --iCol);
                            }
                            else if( 2== m_ucBPP)
                            {
                                UINT16 ui16FillData= ui32FillData& 0xFFFF;
                                UINT16 ui16MaskData= ui32MaskData& 0xFFFF;
                                UINT16* p16Data= reinterpret_cast<UINT16*>(p32Data);
                                do
                                {
                                    p16Data[0]= (p16Data[0]& ui16MaskData)| ui16FillData;
                                    p16Data++;
                                } while( --iCol);
                            }
                            else if( 4== m_ucBPP)
                            {
                                do
                                {
                                    p32Data[0]= (p32Data[0]& ui32MaskData)| ui32FillData;
                                    p32Data++;
                                } while( --iCol);
                            }
                        }

                        pSData+= m_lPitch;
                    } while( --iRow);
                }
            }
        }
    }

    static IVidMemSurface* CreateSurf( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& DDSurf)
    {
        return new CGenSurface( SDesc, DDSurf);
    }
};

struct SPixelFormat: public DDPIXELFORMAT
{
    SPixelFormat( D3DFORMAT D3DFmt) 
    {
        ZeroMemory( static_cast< DDPIXELFORMAT*>(this),
            sizeof(DDPIXELFORMAT));
        dwSize= sizeof(DDPIXELFORMAT);

        // Convert away
        if( HIWORD( static_cast< DWORD>(D3DFmt))!= 0)
        {
            dwFlags= DDPF_FOURCC;
            dwFourCC= static_cast< DWORD>(D3DFmt);
        }
        else switch( D3DFmt)
        {
        case( D3DFMT_R8G8B8):
            dwFlags           = DDPF_RGB;
            dwRBitMask        = 0x00ff0000;
            dwGBitMask        = 0x0000ff00;
            dwBBitMask        = 0x000000ff;
            dwRGBBitCount     = 24;
            break;

        case( D3DFMT_A8R8G8B8):
            dwFlags           = DDPF_RGB| DDPF_ALPHAPIXELS;
            dwRGBAlphaBitMask = 0xFF000000;
            dwRBitMask        = 0x00ff0000;
            dwGBitMask        = 0x0000ff00;
            dwBBitMask        = 0x000000ff;
            dwRGBBitCount     = 32;
            break;

        case( D3DFMT_X8R8G8B8):
            dwFlags           = DDPF_RGB;
            dwRBitMask        = 0x00ff0000;
            dwGBitMask        = 0x0000ff00;
            dwBBitMask        = 0x000000ff;
            dwRGBBitCount     = 32;
            break;

        case( D3DFMT_R5G6B5):
            dwFlags           = DDPF_RGB;
            dwRBitMask        = 0x0000f800;
            dwGBitMask        = 0x000007e0;
            dwBBitMask        = 0x0000001f;
            dwRGBBitCount     = 16;
            break;

        case( D3DFMT_X1R5G5B5):
            dwFlags           = DDPF_RGB;
            dwRBitMask        = 0x00007c00;
            dwGBitMask        = 0x000003e0;
            dwBBitMask        = 0x0000001f;
            dwRGBBitCount     = 16;
            break;

        case( D3DFMT_A1R5G5B5):
            dwFlags           = DDPF_RGB| DDPF_ALPHAPIXELS;
            dwRGBAlphaBitMask = 0x00008000;
            dwRBitMask        = 0x00007c00;
            dwGBitMask        = 0x000003e0;
            dwBBitMask        = 0x0000001f;
            dwRGBBitCount     = 16;
            break;

        case( D3DFMT_A4R4G4B4):
            dwFlags           = DDPF_RGB| DDPF_ALPHAPIXELS;
            dwRGBAlphaBitMask = 0x0000f000;
            dwRBitMask        = 0x00000f00;
            dwGBitMask        = 0x000000f0;
            dwBBitMask        = 0x0000000f;
            dwRGBBitCount     = 16;
            break;

        case( D3DFMT_X4R4G4B4):
            dwFlags           = DDPF_RGB;
            dwRBitMask        = 0x00000f00;
            dwGBitMask        = 0x000000f0;
            dwBBitMask        = 0x0000000f;
            dwRGBBitCount     = 16;
            break;

        case( D3DFMT_R3G3B2):
            dwFlags           = DDPF_RGB;
            dwRBitMask        = 0x000000e0;
            dwGBitMask        = 0x0000001c;
            dwBBitMask        = 0x00000003;
            dwRGBBitCount     = 8;
            break;

        case( D3DFMT_A8R3G3B2):
            dwFlags           = DDPF_RGB| DDPF_ALPHAPIXELS;
            dwRGBAlphaBitMask = 0x0000FF00;
            dwRBitMask        = 0x000000e0;
            dwGBitMask        = 0x0000001c;
            dwBBitMask        = 0x00000003;
            dwRGBBitCount     = 16;
            break;

        case( D3DFMT_A8P8):
            dwFlags            = DDPF_RGB| DDPF_ALPHAPIXELS| DDPF_PALETTEINDEXED8;
            dwRGBAlphaBitMask  = 0x0000FF00;
            dwRGBBitCount      = 16;
            break;

        case( D3DFMT_P8):
            dwFlags            = DDPF_RGB| DDPF_PALETTEINDEXED8;
            dwRGBBitCount      = 8;
            break;

        case( D3DFMT_L8):
            dwFlags             = DDPF_LUMINANCE;
            dwLuminanceBitMask  = 0x000000FF;
            dwLuminanceBitCount = 8;
            break;

        case( D3DFMT_A8L8):
            dwFlags                 = DDPF_LUMINANCE| DDPF_ALPHAPIXELS;
            dwLuminanceAlphaBitMask = 0x0000FF00;
            dwLuminanceBitMask      = 0x000000FF;
            dwLuminanceBitCount     = 16;
            break;

        case( D3DFMT_A4L4):
            dwFlags                 = DDPF_LUMINANCE| DDPF_ALPHAPIXELS;
            dwLuminanceAlphaBitMask = 0x000000F0;
            dwLuminanceBitMask      = 0x0000000F;
            dwLuminanceBitCount     = 8;
            break;

        case( D3DFMT_V8U8):
            dwFlags                = DDPF_BUMPDUDV;
            dwBumpDvBitMask        = 0x0000FF00;
            dwBumpDuBitMask        = 0x000000FF;
            dwBumpBitCount         = 16;
            break;

        case( D3DFMT_L6V5U5):
            dwFlags                = DDPF_BUMPDUDV| DDPF_BUMPLUMINANCE;
            dwBumpLuminanceBitMask = 0x0000FC00;
            dwBumpDvBitMask        = 0x000003E0;
            dwBumpDuBitMask        = 0x0000001F;
            dwBumpBitCount         = 16;
            break;

        case( D3DFMT_X8L8V8U8):
            dwFlags                = DDPF_BUMPDUDV| DDPF_BUMPLUMINANCE;
            dwBumpLuminanceBitMask = 0x00FF0000;
            dwBumpDvBitMask        = 0x0000FF00;
            dwBumpDuBitMask        = 0x000000FF;
            dwBumpBitCount         = 32;
            break;

        case( D3DFMT_A8):
            dwFlags                = DDPF_ALPHA;
            dwAlphaBitDepth        = 8;
            break;

        case( D3DFMT_D16):
        case( D3DFMT_D16_LOCKABLE):
            dwFlags                = DDPF_ZBUFFER;
            dwZBufferBitDepth      = 16;
            dwZBitMask             = 0xFFFF;
            break;

        case( D3DFMT_D32):
            dwFlags                = DDPF_ZBUFFER;
            dwZBufferBitDepth      = 32;
            dwZBitMask             = 0xFFFFFFFF;
            break;

        case( D3DFMT_D15S1):
            dwFlags                = DDPF_ZBUFFER| DDPF_STENCILBUFFER;
            dwZBufferBitDepth      = 16;
            dwZBitMask             = 0xFFFE;
            dwStencilBitDepth      = 1;
            dwStencilBitMask       = 0x0001;
            break;

        case( D3DFMT_D24S8):
            dwFlags                = DDPF_ZBUFFER| DDPF_STENCILBUFFER;
            dwZBufferBitDepth      = 32;
            dwZBitMask             = 0xFFFFFF00;
            dwStencilBitDepth      = 8;
            dwStencilBitMask       = 0xFF;
            break;

        case( D3DFMT_S1D15):
            dwFlags                = DDPF_ZBUFFER| DDPF_STENCILBUFFER;
            dwZBufferBitDepth      = 16;
            dwZBitMask             = 0x7FFF;
            dwStencilBitDepth      = 1;
            dwStencilBitMask       = 0x8000;
            break;

        case( D3DFMT_S8D24):
            dwFlags                = DDPF_ZBUFFER| DDPF_STENCILBUFFER;
            dwZBufferBitDepth      = 32;
            dwZBitMask             = 0x00FFFFFF;
            dwStencilBitDepth      = 8;
            dwStencilBitMask       = 0xFF000000;
            break;

        case( D3DFMT_X8D24):
            dwFlags                = DDPF_ZBUFFER;
            dwZBufferBitDepth      = 32;
            dwZBitMask             = 0x00FFFFFF;
            break;

        case( D3DFMT_D24X8):
            dwFlags                = DDPF_ZBUFFER;
            dwZBufferBitDepth      = 32;
            dwZBitMask             = 0xFFFFFF00;
            break;

        case( D3DFMT_D24X4S4):
            dwFlags                = DDPF_ZBUFFER| DDPF_STENCILBUFFER;
            dwZBufferBitDepth      = 32;
            dwZBitMask             = 0xFFFFFF00;
            dwStencilBitDepth      = 4;
            dwStencilBitMask       = 0x0000000F;
            break;

        case( D3DFMT_X4S4D24):
            dwFlags                = DDPF_ZBUFFER| DDPF_STENCILBUFFER;
            dwZBufferBitDepth      = 32;
            dwZBitMask             = 0x00FFFFFF;
            dwStencilBitDepth      = 4;
            dwStencilBitMask       = 0x0F000000;
            break;

        default:
            const bool Unrecognized_D3DFmt( false);
            assert( Unrecognized_D3DFmt);
            dwFlags= DDPF_FOURCC;
            dwFourCC= static_cast< DWORD>(D3DFmt);
            break;
        }
    }
};

struct SMatchSDesc:
    public unary_function< const DDSURFACEDESC&, bool>
{
    const DDSURFACEDESC& m_SDesc;

    SMatchSDesc( const DDSURFACEDESC& SDesc) : m_SDesc( SDesc) { }

    result_type operator()( argument_type Arg) const 
    {
        if((Arg.dwFlags& DDSD_CAPS)!= 0&& ((m_SDesc.dwFlags& DDSD_CAPS)== 0 ||
            (m_SDesc.ddsCaps.dwCaps& Arg.ddsCaps.dwCaps)!= Arg.ddsCaps.dwCaps))
                return false;
        if((Arg.dwFlags& DDSD_PIXELFORMAT)!= 0&&
            ((m_SDesc.dwFlags& DDSD_PIXELFORMAT)== 0 ||
            m_SDesc.ddpfPixelFormat.dwFlags!= Arg.ddpfPixelFormat.dwFlags ||
            m_SDesc.ddpfPixelFormat.dwFourCC!= Arg.ddpfPixelFormat.dwFourCC ||
            m_SDesc.ddpfPixelFormat.dwRGBBitCount!= Arg.ddpfPixelFormat.dwRGBBitCount ||
            m_SDesc.ddpfPixelFormat.dwRBitMask!= Arg.ddpfPixelFormat.dwRBitMask ||
            m_SDesc.ddpfPixelFormat.dwGBitMask!= Arg.ddpfPixelFormat.dwGBitMask ||
            m_SDesc.ddpfPixelFormat.dwBBitMask!= Arg.ddpfPixelFormat.dwBBitMask ||
            m_SDesc.ddpfPixelFormat.dwRGBZBitMask!= Arg.ddpfPixelFormat.dwRGBZBitMask))
                return false;

        return true;
    }
};

////////////////////////////////////////////////////////////////////////////////
//
// CSurfaceAllocator
//
////////////////////////////////////////////////////////////////////////////////
template< class TMatchFn= SMatchSDesc>
class CIVidMemAllocator
{
public: // Types
    typedef IVidMemSurface TSurface;
    typedef TSurface* (*TCreateSurfFn)( const DDSURFACEDESC&,
        PORTABLE_DDRAWSURFACE_LCL&);
    typedef vector< pair< DDSURFACEDESC, TCreateSurfFn> > TCreateSurfFns;

protected: // Types
    TCreateSurfFns m_CreateSurfFns;
    struct SAdaptedMatchFn: public TMatchFn
    {
        typedef typename TCreateSurfFns::value_type argument_type;
        using typename TMatchFn::result_type;

        SAdaptedMatchFn( const DDSURFACEDESC& SDesc) : TMatchFn( SDesc) {}

        result_type operator()( argument_type Arg) const 
        { return (*static_cast< const TMatchFn*>(this))( Arg.first); }
    };

public: // Functions
    CIVidMemAllocator()  { }
    template< class TIter>
    CIVidMemAllocator( TIter itStart, const TIter itEnd)
    {
        while( itStart!= itEnd)
        {
            m_CreateSurfFns.push_back(
                typename TCreateSurfFns::value_type( *itStart, *itStart));
            itStart++;
        }
    }
    ~CIVidMemAllocator()  { }

    TSurface* CreateSurf( const DDSURFACEDESC& SDesc,
        PORTABLE_DDRAWSURFACE_LCL& Surf) const
    {
        if( m_CreateSurfFns.empty())
            return new CGenSurface( SDesc, Surf);

        typename TCreateSurfFns::const_iterator itFound( 
            find_if( m_CreateSurfFns.begin(), m_CreateSurfFns.end(),
            SAdaptedMatchFn( SDesc) ) );

        if( itFound!= m_CreateSurfFns.end())
            return (itFound->second)( SDesc, Surf);

        // Warning, no specifications matched. If creation functions were
        // provided, there should also be a "default" specification or
        // DDSURFACEDESC with empty flags?, in order to "match rest".
        const bool No_Default_CreateSurface_Function_Found( false);
        assert( No_Default_CreateSurface_Function_Found);
        return new CGenSurface( SDesc, Surf);
    }

};

////////////////////////////////////////////////////////////////////////////////
//
// CPerDDrawData
//
////////////////////////////////////////////////////////////////////////////////
template< class THV= vector< DWORD> >
class CSurfDBEntry
{
public: // Types
    typedef THV THandleVector;

protected: // Variables
    DWORD m_LCLdwFlags;
    DDSCAPS m_LCLddsCaps;
    DWORD m_LCLdwBackBufferCount;
    DWORD m_MOREdwMipMapCount;
    DDSCAPSEX m_MOREddsCapsEx;
    DWORD m_MOREdwSurfaceHandle;
    DWORD m_MOREdwFVF;
    DWORD m_GBLdwGlobalFlags;
    ULONG_PTR m_GBLfpVidMem;
    LONG m_GBLlPitch;
    WORD m_GBLwHeight;
    WORD m_GBLwWidth;
    ULONG_PTR m_GBLdwReserved1;
    DDPIXELFORMAT m_GBLddpfSurface;
    THandleVector m_AttachedTo;
    THandleVector m_AttachedFrom;

public: // Functions
    CSurfDBEntry()  { }
    explicit CSurfDBEntry( PORTABLE_DDRAWSURFACE_LCL& DDSurf)
    { 
        try{
            (*this)= DDSurf;
        } catch( ... ) {
            m_AttachedTo.clear();
            m_AttachedFrom.clear();
            throw;
        }
    }
    ~CSurfDBEntry()  { }
    CSurfDBEntry< THV>& operator=( PORTABLE_DDRAWSURFACE_LCL& DDSurf)
    {
        // DO NOT STORE &DDSurf. This is considered illegal.
        m_LCLdwFlags= DDSurf.dwFlags();
        m_LCLddsCaps= DDSurf.ddsCaps();
        m_LCLdwBackBufferCount= DDSurf.dwBackBufferCount();
        m_MOREdwMipMapCount= DDSurf.lpSurfMore()->dwMipMapCount();
        m_MOREddsCapsEx= DDSurf.lpSurfMore()->ddsCapsEx();
        m_MOREdwSurfaceHandle= DDSurf.lpSurfMore()->dwSurfaceHandle();
        m_MOREdwFVF= DDSurf.lpSurfMore()->dwFVF();
        m_GBLdwGlobalFlags= DDSurf.lpGbl()->dwGlobalFlags;
        m_GBLfpVidMem= DDSurf.lpGbl()->fpVidMem;
        m_GBLlPitch= DDSurf.lpGbl()->lPitch;
        m_GBLwHeight= DDSurf.lpGbl()->wHeight;
        m_GBLwWidth= DDSurf.lpGbl()->wWidth;
        m_GBLdwReserved1= DDSurf.lpGbl()->dwReserved1;
        m_GBLddpfSurface= DDSurf.lpGbl()->ddpfSurface;
 
        const DWORD dwMyHandle( DDSurf.lpSurfMore()->dwSurfaceHandle());
        m_AttachedTo.clear();
        m_AttachedFrom.clear();

        PORTABLE_ATTACHLIST* pAl, *pNextAl;
        if((pAl= DDSurf.lpAttachList())!= NULL)
        {
            pNextAl= pAl;
            do
            {
                if( pNextAl->lpAttached!= NULL&& dwMyHandle!=
                    pNextAl->lpAttached->lpSurfMore()->dwSurfaceHandle())
                {
                    m_AttachedTo.push_back(
                        pNextAl->lpAttached->lpSurfMore()->dwSurfaceHandle());
                }
                pNextAl= pNextAl->lpLink;
            } while( pNextAl!= pAl && pNextAl!= NULL);
        }
        if((pAl= DDSurf.lpAttachListFrom())!= NULL)
        {
            pNextAl= pAl;
            do
            {
                if( pNextAl->lpAttached!= NULL&& dwMyHandle!=
                    pNextAl->lpAttached->lpSurfMore()->dwSurfaceHandle())
                {
                    m_AttachedFrom.push_back(
                        pNextAl->lpAttached->lpSurfMore()->dwSurfaceHandle());
                }
                pNextAl= pNextAl->lpLink;
            } while( pNextAl!= pAl && pNextAl!= NULL);
        }
        return *this;
    }
    DWORD GetLCLdwFlags( void) const 
    { return m_LCLdwFlags; }
    const DDSCAPS& GetLCLddsCaps( void) const 
    { return m_LCLddsCaps; }
    DWORD GetLCLdwBackBufferCount( void) const 
    { return m_LCLdwBackBufferCount; }
    DWORD GetMOREdwMipMapCount( void) const 
    { return m_MOREdwMipMapCount; }
    const DDSCAPSEX& GetMOREddsCapsEx( void) const 
    { return m_MOREddsCapsEx; }
    DWORD GetMOREdwSurfaceHandle( void) const 
    { return m_MOREdwSurfaceHandle; }
    DWORD GetMOREdwFVF( void) const 
    { return m_MOREdwFVF; }
    DWORD GetGBLdwGlobalFlags( void) const 
    { return m_GBLdwGlobalFlags; }
    ULONG_PTR GetGBLfpVidMem( void) const 
    { return m_GBLfpVidMem; }
    LONG GetGBLlPitch( void) const 
    { return m_GBLlPitch; }
    WORD GetGBLwHeight( void) const 
    { return m_GBLwHeight; }
    WORD GetGBLwWidth( void) const 
    { return m_GBLwWidth; }
    ULONG_PTR GetGBLdwReserved1( void) const 
    { return m_GBLdwReserved1; }
    const DDPIXELFORMAT& GetGBLddpfSurface( void) const 
    { return m_GBLddpfSurface; }
    const THandleVector& GetAttachedTo( void) const 
    { return m_AttachedTo; }
    const THandleVector& GetAttachedFrom( void) const 
    { return m_AttachedFrom; }
};

template< class TPDBE= CPalDBEntry, class THV= vector< DWORD> >
class CSurfDBEntryWPal:
    public CSurfDBEntry< THV>
{
public: // Types
    typedef TPDBE TPalDBEntry;

protected: // Variables
    TPalDBEntry* m_pPalDBEntry;

public: // Functions
    CSurfDBEntryWPal():
        m_pPalDBEntry( NULL)
    { }
    explicit CSurfDBEntryWPal( PORTABLE_DDRAWSURFACE_LCL& DDSurf):
        CSurfDBEntry< THV>( DDSurf), m_pPalDBEntry( NULL)
    { }
    ~CSurfDBEntryWPal()
    { }
    CSurfDBEntryWPal< TPDBE, THV>& operator=( PORTABLE_DDRAWSURFACE_LCL& DDSurf)
    {
        CSurfDBEntry< THV>* pSub= static_cast< CSurfDBEntry< THV>*>( this);
        // DO NOT STORE &DDSurf. This is considered illegal.
        *pSub= DDSurf;
        return *this;
    }
    void SetPalette( TPalDBEntry* pPalDBEntry)
    { m_pPalDBEntry= pPalDBEntry; }
    TPalDBEntry* GetPalette() const
    { return m_pPalDBEntry; }
};

template< class TSuper, class TD, class TSDBE= CSurfDBEntry<>,
    class TSDB= map< DWORD, TSDBE>,
    class TFS= set< PORTABLE_DDRAWSURFACE_LCL*> >
class CSubPerDDrawData
{
public: // Types
    typedef TD TDriver;
    typedef TSDBE TSurfDBEntry;
    typedef TSDB TSurfDB;

protected: // Variables
    TDriver& m_Driver;
    TSurfDB m_SurfDB;

protected: // Functions
    CSubPerDDrawData( TDriver& Driver, const DDRAWI_DIRECTDRAW_LCL& DDLcl) 
        :m_Driver( Driver)
    { }
    ~CSubPerDDrawData()  { }

public: // Functions
    TDriver& GetDriver( void) const  { return m_Driver; }
    TSurfDBEntry* GetSurfDBEntry( DWORD dwH) 
    {
        typename TSurfDB::iterator itSurf( m_SurfDB.find( dwH));
        if( itSurf!= m_SurfDB.end())
            return &itSurf->second;
        else
            return NULL;
    }
    const TSurfDBEntry* GetSurfDBEntry( DWORD dwH) const 
    {
        typename TSurfDB::const_iterator itSurf( m_SurfDB.find( dwH));
        if( itSurf!= m_SurfDB.end())
            return &itSurf->second;
        else
            return NULL;
    }

    bool PreProcessFullSurface( PORTABLE_DDRAWSURFACE_LCL& DDSLcl) const 
    {
        // DO NOT STORE &DDSLcl. This is considered illegal.
        // It is only valid for the duration of the call.
        return false;
    }
    bool PreProcessIndividualSurface( PORTABLE_DDRAWSURFACE_LCL& DDSLcl) const
        
    {
        // DO NOT STORE &DDSLcl. This is considered illegal.
        // It is only valid for the duration of the call.
        return false;
    }
    void ProcessIndividualSurface( PORTABLE_DDRAWSURFACE_LCL& DDSLcl)
    {
        // DO NOT STORE &DDSLcl. This is considered illegal.
        // It is only valid for the duration of the call.
        pair< TSurfDB::iterator, bool> Ret= m_SurfDB.insert( 
            TSurfDB::value_type( DDSLcl.lpSurfMore()->dwSurfaceHandle(),
            TSurfDBEntry( DDSLcl)));

        // If not added, update data.
        if( !Ret.second) Ret.first->second= DDSLcl;
    }
    void ProcessFullSurface( PORTABLE_DDRAWSURFACE_LCL& DDSLcl)
    {
        // DO NOT STORE &DDSLcl. This is considered illegal.
        // It is only valid for the duration of the call.
        TSuper* pSThis= static_cast<TSuper*>(this);
        typedef TFS TFoundSet;
        TFoundSet FoundSet;
        typename TFoundSet::size_type OldSetSize( FoundSet.size());

        // First traverse all over the attach lists looking for new surfaces.
        PORTABLE_ATTACHLIST* pAl, *pNextAl;
        FoundSet.insert( &DDSLcl);
        typename TFoundSet::size_type NewSetSize( FoundSet.size());
        while( OldSetSize!= NewSetSize)
        {
            OldSetSize= NewSetSize;

            typename TFoundSet::iterator itSurf( FoundSet.begin());
            while( itSurf!= FoundSet.end())
            {
                if((pAl= (*itSurf)->lpAttachList())!= NULL)
                {
                    pNextAl= pAl;
                    do
                    {
                        if( pNextAl->lpAttached!= NULL)
                            FoundSet.insert( pNextAl->lpAttached);

                        pNextAl= pNextAl->lpLink;
                    } while( pNextAl!= pAl && pNextAl!= NULL);
                }
                if((pAl= (*itSurf)->lpAttachListFrom())!= NULL)
                {
                    pNextAl= pAl;
                    do
                    {
                        if( pNextAl->lpAttached!= NULL)
                            FoundSet.insert( pNextAl->lpAttached);

                        pNextAl= pNextAl->lpLink;
                    } while( pNextAl!= pAl && pNextAl!= NULL);
                }
                itSurf++;                
            }
            NewSetSize= FoundSet.size();
        }

        // After all surfaces have been found, add them to the DB.
        typename TFoundSet::iterator itSurf( FoundSet.begin());
        while( itSurf!= FoundSet.end())
        {
            if( !pSThis->PreProcessIndividualSurface( *(*itSurf)))
                ProcessIndividualSurface( *(*itSurf));

            itSurf++;
        }
    }

    // Notification that a system or video memory surface was created. At the
    // least, we have to keep track of the surface handles.
    void SurfaceCreated( PORTABLE_DDRAWSURFACE_LCL& DDSLcl)
    {
        // DO NOT STORE &DDSLcl. This is considered illegal.
        // It is only valid for the duration of the call.
        TSuper* pSThis= static_cast<TSuper*>(this);

        // If true is returned, then a super structure was recognized and
        // processed. Otherwise, false indicates no recognition, and all
        // surfaces will be scoured.
        if( !pSThis->PreProcessFullSurface( DDSLcl))
            pSThis->ProcessFullSurface( DDSLcl);
    }
    bool SurfaceDestroyed( PORTABLE_DDRAWSURFACE_LCL& DDSLcl) 
    {
        // DO NOT STORE &DDSLcl. This is considered illegal.
        // It is only valid for the duration of the call.

        // No need to assert removal, as we might not be tracking this type
        // of surface. Someone could override and filter out surfaces.
        m_SurfDB.erase( DDSLcl.lpSurfMore()->dwSurfaceHandle());

        // Return true to tell driver to delete this object. So,
        // if DB is empty, odds are good to delete this.
        return m_SurfDB.empty();
    }
};

template< class TD>
class CMinimalPerDDrawData:
    public CSubPerDDrawData< CMinimalPerDDrawData< TD>, TD>
{
public:
    CMinimalPerDDrawData( TDriver& Driver, DDRAWI_DIRECTDRAW_LCL& DDLcl) 
        :CSubPerDDrawData< CMinimalPerDDrawData< TD>, TD>( Driver, DDLcl)
    { }
    ~CMinimalPerDDrawData()  { }
};

////////////////////////////////////////////////////////////////////////////////
//
// CSubDriver
//
////////////////////////////////////////////////////////////////////////////////
template< class T>
struct SFakeEntryPointHook
{
    SFakeEntryPointHook( T& t, const char* szEntryPoint)  { }
    ~SFakeEntryPointHook()  { }
};

template< class TD, class TC, class TSA= CIVidMemAllocator<>,
    class TPDDD= CMinimalPerDDrawData< TD>,
    class TCs= set< TC*>,
    class TPDDDs= map< LPDDRAWI_DIRECTDRAW_LCL, TPDDD>,
    class TSs= set< TSA::TSurface*>,
    class TEntryPointHook= SFakeEntryPointHook< TD> >
class CSubDriver
{
public: // Types
    typedef TD TDriver;
    typedef TC TContext;
    typedef TCs TContexts;
    typedef TPDDD TPerDDrawData;
    typedef TPDDDs TPerDDrawDatas;
    typedef TSA TSurfAlloc;
    typedef typename TSurfAlloc::TSurface TSurface;
    typedef TSs TSurfaces;

    class CSurfaceCapWrap
    {
    protected:
        DDSURFACEDESC m_SDesc;
    public:
        CSurfaceCapWrap()  { }
        CSurfaceCapWrap( const D3DFORMAT D3DFmt, const DWORD dwSupportedOps,
            const DWORD dwPrivateFmtBitCount= 0,
            const WORD wFlipMSTypes= 0, const WORD wBltMSTypes= 0) 
        {
            ZeroMemory( &m_SDesc, sizeof( m_SDesc));
            m_SDesc.dwSize= sizeof( m_SDesc);

            m_SDesc.ddpfPixelFormat.dwFlags= DDPF_D3DFORMAT;
            m_SDesc.ddpfPixelFormat.dwFourCC= static_cast<DWORD>(D3DFmt);
            m_SDesc.ddpfPixelFormat.dwOperations= dwSupportedOps;
            m_SDesc.ddpfPixelFormat.dwPrivateFormatBitCount= dwPrivateFmtBitCount;
            m_SDesc.ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes= wFlipMSTypes;
            m_SDesc.ddpfPixelFormat.MultiSampleCaps.wBltMSTypes= wBltMSTypes;
        }
        CSurfaceCapWrap( const D3DFORMAT D3DFmt, const bool bTexture,
            const bool bVolTexture, const bool bCubeTexture,
            const bool bOffScreenTarget, const bool bSameFmtTarget,
            const bool bZStencil, const bool bZStencilWithColor,
            const bool bSameFmtUpToAlpha, const bool b3DAccel,
            const DWORD dwPrivateFmtBitCount= 0,
            const WORD wFlipMSTypes= 0, const WORD wBltMSTypes= 0) 
        {
            ZeroMemory( &m_SDesc, sizeof( m_SDesc));
            m_SDesc.dwSize= sizeof( m_SDesc);

            DWORD dwOps( 0);
            if( bTexture) dwOps|= D3DFORMAT_OP_TEXTURE;
            if( bVolTexture) dwOps|= D3DFORMAT_OP_VOLUMETEXTURE;
            if( bCubeTexture) dwOps|= D3DFORMAT_OP_CUBETEXTURE;
            if( bOffScreenTarget) dwOps|= D3DFORMAT_OP_OFFSCREEN_RENDERTARGET;
            if( bSameFmtTarget) dwOps|= D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET;
            if( bZStencil) dwOps|= D3DFORMAT_OP_ZSTENCIL;
            if( bZStencilWithColor) dwOps|= D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH;
            if( bSameFmtUpToAlpha) dwOps|= D3DFORMAT_OP_SAME_FORMAT_UP_TO_ALPHA_RENDERTARGET;
            if( b3DAccel) dwOps|= D3DFORMAT_OP_3DACCELERATION;

            m_SDesc.ddpfPixelFormat.dwFlags= DDPF_D3DFORMAT;
            m_SDesc.ddpfPixelFormat.dwFourCC= static_cast<DWORD>(D3DFmt);
            m_SDesc.ddpfPixelFormat.dwOperations= dwOps;
            m_SDesc.ddpfPixelFormat.dwPrivateFormatBitCount= dwPrivateFmtBitCount;
            m_SDesc.ddpfPixelFormat.MultiSampleCaps.wFlipMSTypes= wFlipMSTypes;
            m_SDesc.ddpfPixelFormat.MultiSampleCaps.wBltMSTypes= wBltMSTypes;
        }
        ~CSurfaceCapWrap()  { }
        operator DDSURFACEDESC() const 
        { return m_SDesc; }
    };

private:
    // Stubs for secondary entry points.
    DWORD static APIENTRY ContextCreateStub( LPD3DHAL_CONTEXTCREATEDATA pccd) 
    {
        return sm_pGlobalDriver->ContextCreate(
            *reinterpret_cast< PORTABLE_CONTEXTCREATEDATA*>( pccd));
    }
    DWORD static APIENTRY ContextDestroyStub( LPD3DHAL_CONTEXTDESTROYDATA pcdd) 
    { return sm_pGlobalDriver->ContextDestroy( *pcdd); }
    DWORD static APIENTRY ContextDestroyAllStub( LPD3DHAL_CONTEXTDESTROYALLDATA pcdad) 
    { return sm_pGlobalDriver->ContextDestroyAll( *pcdad); }
    DWORD static APIENTRY SceneCaptureStub( LPD3DHAL_SCENECAPTUREDATA pscd) 
    { return sm_pGlobalDriver->SceneCapture( *pscd); }
    DWORD static APIENTRY RenderStateStub( LPD3DHAL_RENDERSTATEDATA prsd) 
    { return sm_pGlobalDriver->RenderState( *prsd); }
    DWORD static APIENTRY RenderPrimitiveStub( LPD3DHAL_RENDERPRIMITIVEDATA prpd) 
    { return sm_pGlobalDriver->RenderPrimitive( *prpd); }
    DWORD static APIENTRY TextureCreateStub( LPD3DHAL_TEXTURECREATEDATA ptcd) 
    { return sm_pGlobalDriver->TextureCreate( *ptcd); }
    DWORD static APIENTRY TextureDestroyStub( LPD3DHAL_TEXTUREDESTROYDATA ptdd) 
    { return sm_pGlobalDriver->TextureDestroy( *ptdd); }
    DWORD static APIENTRY TextureSwapStub( LPD3DHAL_TEXTURESWAPDATA ptsd) 
    { return sm_pGlobalDriver->TextureSwap( *ptsd); }
    DWORD static APIENTRY TextureGetSurfStub( LPD3DHAL_TEXTUREGETSURFDATA ptgsd) 
    { return sm_pGlobalDriver->TextureGetSurf( *ptgsd); }
    DWORD static APIENTRY GetStateStub( LPD3DHAL_GETSTATEDATA pgsd) 
    { return sm_pGlobalDriver->GetState( *pgsd); }
    DWORD static APIENTRY SetRenderTargetStub( LPD3DHAL_SETRENDERTARGETDATA psrtd) 
    {
        return sm_pGlobalDriver->SetRenderTarget(
            *reinterpret_cast< PORTABLE_SETRENDERTARGETDATA*>( psrtd));
    }
    DWORD static APIENTRY ClearStub( LPD3DHAL_CLEARDATA pcd) 
    { return sm_pGlobalDriver->Clear( *pcd); }
    DWORD static APIENTRY DrawOnePrimitiveStub( LPD3DHAL_DRAWONEPRIMITIVEDATA pdopd) 
    { return sm_pGlobalDriver->DrawOnePrimitive( *pdopd); }
    DWORD static APIENTRY DrawOneIndexedPrimitiveStub( LPD3DHAL_DRAWONEINDEXEDPRIMITIVEDATA pdoipd) 
    { return sm_pGlobalDriver->DrawOneIndexedPrimitive( *pdoipd); }
    DWORD static APIENTRY DrawPrimitivesStub( LPD3DHAL_DRAWPRIMITIVESDATA pdpd) 
    { return sm_pGlobalDriver->DrawPrimitives( *pdpd); }
    DWORD static APIENTRY Clear2Stub( LPD3DHAL_CLEAR2DATA pc2d) 
    { return sm_pGlobalDriver->Clear2( *pc2d); }
    DWORD static APIENTRY ValidateTextureStageStateStub( LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA pvtssd) 
    { return sm_pGlobalDriver->ValidateTextureStageState( *pvtssd); }
    DWORD static APIENTRY DrawPrimitives2Stub( LPD3DHAL_DRAWPRIMITIVES2DATA pdpd) 
    {
        return sm_pGlobalDriver->DrawPrimitives2(
            *reinterpret_cast< PORTABLE_DRAWPRIMITIVES2DATA*>( pdpd));
    }
    DWORD static APIENTRY GetDriverStateStub( LPDDHAL_GETDRIVERSTATEDATA pgdsd) 
    { return sm_pGlobalDriver->GetDriverState( *pgdsd); }
    DWORD static APIENTRY CreateSurfaceExStub( LPDDHAL_CREATESURFACEEXDATA pcsxd) 
    {
        return sm_pGlobalDriver->CreateSurfaceEx(
            *reinterpret_cast< PORTABLE_CREATESURFACEEXDATA*>( pcsxd));
    }
    DWORD static APIENTRY CreateSurfaceStub( LPDDHAL_CREATESURFACEDATA pcsd) 
    {
        return sm_pGlobalDriver->CreateSurface(
            *reinterpret_cast< PORTABLE_CREATESURFACEDATA*>( pcsd));
    }
    DWORD static APIENTRY DestroySurfaceStub( LPDDHAL_DESTROYSURFACEDATA pdsd) 
    {
        return sm_pGlobalDriver->DestroySurface(
            *reinterpret_cast< PORTABLE_DESTROYSURFACEDATA*>( pdsd));
    }
    DWORD static APIENTRY LockStub( LPDDHAL_LOCKDATA pld) 
    {
        return sm_pGlobalDriver->Lock(
            *reinterpret_cast< PORTABLE_LOCKDATA*>( pld));
    }
    DWORD static APIENTRY UnlockStub( LPDDHAL_UNLOCKDATA pud) 
    {
        return sm_pGlobalDriver->Unlock(
            *reinterpret_cast< PORTABLE_UNLOCKDATA*>( pud));
    }

protected:
    TSurfAlloc m_SurfAlloc;
    TContexts m_Contexts;
    TPerDDrawDatas m_PerDDrawDatas;
    TSurfaces m_Surfaces;
    typedef vector< DDSURFACEDESC> TSupportedSurfaces;
    TSupportedSurfaces m_SupportedSurfaces;

    template< class TIter> // DDSURFACEDESC*
    CSubDriver( TIter itStart, const TIter itEnd, TSurfAlloc SA= TSurfAlloc()):
        m_SurfAlloc( SA)
    {
        // Copy supported surfaces formats into a guarenteed contiguous storage
        // for passing to D3D.
        while( itStart!= itEnd)
            m_SupportedSurfaces.push_back( *itStart++);
    }
    ~CSubDriver()  { }
    // Binds a VidMem DDRAWI object together with an internal driver surface object.
    void static AssociateSurface( PORTABLE_DDRAWSURFACE_LCL& DDSurf,
        TSurface* pSurf) 
    {
        assert((DDSurf.ddsCaps().dwCaps& DDSCAPS_VIDEOMEMORY)!= 0);
        DDSurf.lpGbl()->dwReserved1= reinterpret_cast< ULONG_PTR>(pSurf);
    }

public:
    // The global driver static member pointer. Only one Driver object, and
    // this points to it.
    static TDriver* sm_pGlobalDriver;

    TSurface* GetSurface( PORTABLE_DDRAWSURFACE_LCL& DDSurf,
        bool bCheck= true) const 
    {
        TSurface* pSurface= reinterpret_cast< TSurface*>(
            DDSurf.lpGbl()->dwReserved1);
        assert( bCheck&& m_Surfaces.find( pSurface)!= m_Surfaces.end());
        return pSurface;
    }
    TSurface* GetSurface( const typename TPerDDrawData::TSurfDBEntry& DBEntry,
        bool bCheck= true) const 
    {
        TSurface* pSurface= reinterpret_cast< TSurface*>(
            DBEntry.GetGBLdwReserved1());
        assert( bCheck&& m_Surfaces.find( pSurface)!= m_Surfaces.end());
        return pSurface;
    }

    // Secondary entry points with C++ friendly parameters.
    DWORD ContextCreate( PORTABLE_CONTEXTCREATEDATA& ccd) throw()
    {
        try
        {
            TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "ContextCreate");

            ccd.ddrval()= DD_OK;
            TDriver* pSThis= static_cast<TDriver*>(this);

            // We should already have a PerDDrawData at this point, as the
            // surfaces to initialize the context had to be created already,
            // and the PerDDrawData should've been created there.
            typename TPerDDrawDatas::iterator itPerDDrawData(
                m_PerDDrawDatas.find( ccd.lpDDLcl()));
            assert( itPerDDrawData!= m_PerDDrawDatas.end());

            // Create the new context, passing in a ref to the PerDDrawData object.
            auto_ptr< TContext> pNewContext( new TContext(
                itPerDDrawData->second, ccd));

            // Keep track of our new context.
            pair< TContexts::iterator, bool> RetVal( m_Contexts.insert(
                pNewContext.get()));
            assert( RetVal.second); // Assure that there wasn't a duplicate.

            // Ownership now has been transfered to m_Contexts & D3D.
            ccd.dwhContext()= reinterpret_cast<ULONG_PTR>( pNewContext.release());
        } catch( bad_alloc e) {
            ccd.ddrval()= D3DHAL_OUTOFCONTEXTS;
        } catch( HRESULT hr) {
            ccd.ddrval()= hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            const bool ContextCreate_Unrecognized_Exception( false);
            assert( ContextCreate_Unrecognized_Exception);
            ccd.ddrval()= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return DDHAL_DRIVER_HANDLED;
    }
    DWORD ContextDestroy( D3DHAL_CONTEXTDESTROYDATA& cdd) throw()
    {
        try
        {
            TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "ContextDestroy");

            cdd.ddrval= DD_OK;

            // Ownership now has been transfered to local auto_ptr.
            auto_ptr< TContext> pContext(
                reinterpret_cast<TContext*>(cdd.dwhContext));

            // Remove tracking of this context.
            typename TContexts::size_type Ret( m_Contexts.erase( pContext.get()));
            assert( Ret!= 0);
        } catch( HRESULT hr) {
            cdd.ddrval= hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            const bool ContextDestroy_Unrecognized_Exception( false);
            assert( ContextDestroy_Unrecognized_Exception);
            cdd.ddrval= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return DDHAL_DRIVER_HANDLED;
    }
    DWORD ContextDestroyAll( D3DHAL_CONTEXTDESTROYALLDATA& cdad) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "ContextDestroyAll");
        const bool ContextDestroyAll_thought_to_be_depreciated_entry_point( false);
        assert( ContextDestroyAll_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD SceneCapture( D3DHAL_SCENECAPTUREDATA& scd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "SceneCapture");
        const bool SceneCapture_thought_to_be_depreciated_entry_point( false);
        assert( SceneCapture_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD RenderState( D3DHAL_RENDERSTATEDATA& rsd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "RenderState");
        const bool RenderState_thought_to_be_depreciated_entry_point( false);
        assert( RenderState_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD RenderPrimitive( D3DHAL_RENDERPRIMITIVEDATA& rpd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "RenderPrimitive");
        const bool RenderPrimitive_thought_to_be_depreciated_entry_point( false);
        assert( RenderPrimitive_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD TextureCreate( D3DHAL_TEXTURECREATEDATA& tcd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "TextureCreate");
        const bool TextureCreate_thought_to_be_depreciated_entry_point( false);
        assert( TextureCreate_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD TextureDestroy( D3DHAL_TEXTUREDESTROYDATA& tdd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "TextureDestroy");
        const bool TextureDestroy_thought_to_be_depreciated_entry_point( false);
        assert( TextureDestroy_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD TextureSwap( D3DHAL_TEXTURESWAPDATA& tsd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "TextureSwap");
        const bool TextureSwap_thought_to_be_depreciated_entry_point( false);
        assert( TextureSwap_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD TextureGetSurf( D3DHAL_TEXTUREGETSURFDATA& tgsd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "TextureGetSurf");
        const bool TextureGetSurf_thought_to_be_depreciated_entry_point( false);
        assert( TextureGetSurf_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD GetState( D3DHAL_GETSTATEDATA& gsd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "GetState");
        const bool GetState_thought_to_be_depreciated_entry_point( false);
        assert( GetState_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD SetRenderTarget( PORTABLE_SETRENDERTARGETDATA& srtd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "SetRenderTarget");
        const bool SetRenderTarget_thought_to_be_depreciated_entry_point( false);
        assert( SetRenderTarget_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD Clear( D3DHAL_CLEARDATA& cd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "Clear");
        const bool Clear_thought_to_be_depreciated_entry_point( false);
        assert( Clear_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD DrawOnePrimitive( D3DHAL_DRAWONEPRIMITIVEDATA& dopd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "DrawOnePrimitive");
        const bool DrawOnePrimitive_thought_to_be_depreciated_entry_point( false);
        assert( DrawOnePrimitive_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD DrawOneIndexedPrimitive( D3DHAL_DRAWONEINDEXEDPRIMITIVEDATA& doipd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "DrawOneIndexedPrimitive");
        const bool DrawOneIndexedPrimitive_thought_to_be_depreciated_entry_point( false);
        assert( DrawOneIndexedPrimitive_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD DrawPrimitives( D3DHAL_DRAWPRIMITIVESDATA& dpd) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "DrawPrimitives");
        const bool DrawPrimitives_thought_to_be_depreciated_entry_point( false);
        assert( DrawPrimitives_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD Clear2( D3DHAL_CLEAR2DATA& c2d) const throw()
    {
        TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "Clear2");
        const bool Clear2_thought_to_be_depreciated_entry_point( false);
        assert( Clear2_thought_to_be_depreciated_entry_point);
        return DDHAL_DRIVER_NOTHANDLED;
    }
    DWORD ValidateTextureStageState( D3DHAL_VALIDATETEXTURESTAGESTATEDATA& vtssd) const throw()
    { 
        try
        {
            TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "ValidateTextureStageState");

            vtssd.ddrval= DD_OK;
            TContext* pContext= reinterpret_cast<TContext*>(vtssd.dwhContext);

            // Make sure we've created this context.
            assert( m_Contexts.find( pContext)!= m_Contexts.end());

            // Pass entry point to context.
            vtssd.ddrval= pContext->ValidateTextureStageState( vtssd);
        } catch( HRESULT hr) {
            vtssd.ddrval= hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            const bool ValidateTextureStageState_Unrecognized_Exception( false);
            assert( ValidateTextureStageState_Unrecognized_Exception);
            vtssd.ddrval= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return DDHAL_DRIVER_HANDLED;
    }
    DWORD DrawPrimitives2( PORTABLE_DRAWPRIMITIVES2DATA& dpd) const throw()
    {
        try
        {
            TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "DrawPrimitives2");

            dpd.ddrval()= DD_OK;
            TContext* pContext= reinterpret_cast<TContext*>(dpd.dwhContext());

            // Make sure we've created this context.
            assert( m_Contexts.find( pContext)!= m_Contexts.end());

            // Pass entry point to context.
            dpd.ddrval()= pContext->DrawPrimitives2( dpd);
        } catch( HRESULT hr) {
            dpd.ddrval()= hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            const bool DrawPrimitives2_Unrecognized_Exception( false);
            assert( DrawPrimitives2_Unrecognized_Exception);
            dpd.ddrval()= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return DDHAL_DRIVER_HANDLED;
    }
    DWORD GetDriverState( DDHAL_GETDRIVERSTATEDATA& gdsd) const throw()
    {
        // This entry point is hooked up to IDirect3DDevice8::GetInfo(
        //   DWORD DevInfoId, VOID* pDevInfoStruct, DWORD DevInfoStructSize).
        // gdsd.dwFlags= DevInfoId
        // gdsd.lpdwStates= pDevInfoStruct
        // gdsd.dwLength= DevInfoStructSize
        //
        // This entry point can be used for driver defined/ extended state
        // passing. Currently no DevInfoIds are pre-defined. S_FALSE should
        // be returned if nothing is done or the Id is not understood.
        try
        {
            TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "GetDriverState");

            gdsd.ddRVal= DD_OK;
            TContext* pContext= reinterpret_cast< TContext*>( gdsd.dwhContext);

            // Make sure we've created this context.
            assert( m_Contexts.find( pContext)!= m_Contexts.end());

            // Pass entry point to context.
            gdsd.ddRVal= pContext->GetDriverState( gdsd);
        } catch( HRESULT hr) {
            gdsd.ddRVal= hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            const bool GetDriverState_Unrecognized_Exception( false);
            assert( GetDriverState_Unrecognized_Exception);
            gdsd.ddRVal= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return DDHAL_DRIVER_HANDLED;
    }
    DWORD CreateSurfaceEx( PORTABLE_CREATESURFACEEXDATA& csxd) throw()
    {
        try
        {
            TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "CreateSurfaceEx");

            TDriver* pSThis= static_cast<TDriver*>(this);
            csxd.ddRVal()= DD_OK;
            
            // Upon CreateSurfaceEx, we must detect whether this is a creation
            // or destruction notification and pass it to the associated
            // PerDDrawData.

            // Get PerDDrawData for this DDraw object.
            typename TPerDDrawDatas::iterator itPerDDrawData( m_PerDDrawDatas.find(
                csxd.lpDDLcl()));

            if( 0== csxd.lpDDSLcl()->lpGbl()->fpVidMem)
            {   // System Memory Surface Destruction,
                // Pass notification to PerDDrawData, if exists. PerDDraw data
                // will return bool indicating whether to delete it or not.
                if( itPerDDrawData!= m_PerDDrawDatas.end() &&
                    itPerDDrawData->second.SurfaceDestroyed( *csxd.lpDDSLcl()))
                    m_PerDDrawDatas.erase( itPerDDrawData);
            }
            else
            {   // Video or System Memory Surface Creation
                // If we don't have PerDDrawData for this DDraw object yet,
                // we must create it.
                if( itPerDDrawData== m_PerDDrawDatas.end())
                {
                    // Typically, storing pointers to DDRAWI objects is illegal,
                    // but this case has been deemed okay. Otherwise, we
                    // couldn't have the concept of "per DDraw" data, as
                    // "per DDraw" would be hard to figure out; as nothing
                    // guarentees uniqueness between the DDRAWI objects, besides
                    // the pointers.
                    itPerDDrawData= m_PerDDrawDatas.insert( 
                        TPerDDrawDatas::value_type( csxd.lpDDLcl(),
                        TPerDDrawData( *pSThis, *csxd.lpDDLcl())) ).first;
                }

                // Now pass notification to PerDDrawData.
                // DO NOT STORE csxd.lpDDSLcl. This is considered illegal.
                // It is only valid for the duration of the call.
                itPerDDrawData->second.SurfaceCreated( *csxd.lpDDSLcl());
            }
        } catch( bad_alloc e) {
            csxd.ddRVal()= DDERR_OUTOFMEMORY;
        } catch( HRESULT hr) {
            csxd.ddRVal()= hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            const bool CreateSurfaceEx_Unrecognized_Exception( false);
            assert( CreateSurfaceEx_Unrecognized_Exception);
            csxd.ddRVal()= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return DDHAL_DRIVER_HANDLED;
    }
    DWORD CreateSurface( PORTABLE_CREATESURFACEDATA& csd) throw()
    {
        try
        {
            TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "CreateSurface");

            TDriver* pSThis= static_cast<TDriver*>(this);
            csd.ddRVal()= DD_OK;

            // Upon CreateSurface, we must allocate memory for the "video"
            // memory surface and also associate our internal representation
            // with the surface.

            DWORD dwS( 0);
            try
            {
                // For each surface we're asked to create...
                while( dwS< csd.dwSCnt())
                {
                    // Get PerDDrawData for this DDraw object.
                    const LPDDRAWI_DIRECTDRAW_LCL pDDLcl(
                        csd.lplpSList()[ dwS]->lpSurfMore()->lpDD_lcl());
                    typename TPerDDrawDatas::iterator itPerDDrawData(
                        m_PerDDrawDatas.find( pDDLcl));

                    // If we don't have PerDDrawData for this DDraw object yet,
                    // we must create it.
                    if( itPerDDrawData== m_PerDDrawDatas.end())
                    {
                        // Typically, storing pointers to DDRAWI objects is
                        // illegal, but this case has been deemed okay.
                        // Otherwise, we couldn't have the concept of
                        // "per DDraw" data, as "per DDraw" would be hard to
                        // figure out; as nothing guarentees uniqueness
                        // between the DDRAWI objects, besides the pointers.
                        itPerDDrawData= m_PerDDrawDatas.insert( 
                            TPerDDrawDatas::value_type( pDDLcl,
                            TPerDDrawData( *pSThis, *pDDLcl)) ).first;
                    }

                    // Create the new surface, by using the surface allocator.
                    // DO NOT STORE csd.lplpSList[ dwS]. This is considered
                    // illegal. It is only valid for the duration of the call.
                    auto_ptr< TSurface> pNewSurf(
                        m_SurfAlloc.CreateSurf( *csd.lpDDSurfaceDesc(),
                        *csd.lplpSList()[ dwS]));

                    // Add the pointer to our set of VM surfaces for tracking.
                    m_Surfaces.insert( pNewSurf.get());

                    // Bind the internal representation to the DDRAWI object.
                    AssociateSurface( *csd.lplpSList()[ dwS], pNewSurf.get());

                    pNewSurf.release();
                    dwS++;
                }
            } catch( ... ) {
                // dwS will point to failed alloc, then deallocate the
                // succeeded allocations.

                // Bind NULL to the DDRAWI object and blank out fpVidMem, just
                // in case.
                AssociateSurface( *csd.lplpSList()[ dwS], NULL);
                csd.lplpSList()[ dwS]->lpGbl()->fpVidMem= NULL;
                if( dwS!= 0) do
                {
                    --dwS;

                    TSurface* pSurface= GetSurface( *csd.lplpSList()[ dwS]);
                    m_Surfaces.erase( pSurface);
                    delete pSurface;

                    // Bind NULL to the DDRAWI object and blank out fpVidMem,
                    // to avoid DDraw in thinking the surface was allocated.
                    AssociateSurface( *csd.lplpSList()[ dwS], NULL);
                    csd.lplpSList()[ dwS]->lpGbl()->fpVidMem= NULL;
                } while( dwS!= 0);

                throw; // Re-throw the exception.
            }

            // We wait till CreateSurfaceEx to make the handle association.
        } catch( bad_alloc e) {
            csd.ddRVal()= DDERR_OUTOFMEMORY;
        } catch( HRESULT hr) {
            csd.ddRVal()= hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            const bool CreateSurface_Unrecognized_Exception( false);
            assert( CreateSurface_Unrecognized_Exception);
            csd.ddRVal()= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return DDHAL_DRIVER_HANDLED;
    }
    DWORD DestroySurface( PORTABLE_DESTROYSURFACEDATA& dsd) throw()
    { 
        try
        {
            TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "DestroySurface");

            dsd.ddRVal()= DD_OK;

            // Retrieve 
            TSurface* pSurface= GetSurface( *dsd.lpDDSurface());

            // Surface object must be destroyed before the DB entry. This is
            // a requirement so that a link (pointer) can safely be
            // established between the DB entry and the object.
            m_Surfaces.erase( pSurface);
            delete pSurface;

            // Pass destruction notice to PerDDrawData. If it returns true,
            // then PerDDrawData indicates that it should be destroyed.
            typename TPerDDrawDatas::iterator itPerDDrawData( m_PerDDrawDatas.find(
                dsd.lpDDSurface()->lpSurfMore()->lpDD_lcl()));
            if( itPerDDrawData!= m_PerDDrawDatas.end() &&
                itPerDDrawData->second.SurfaceDestroyed( *dsd.lpDDSurface()))
                m_PerDDrawDatas.erase( itPerDDrawData);
        } catch( HRESULT hr) {
            dsd.ddRVal()= hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            const bool DestroySurface_Unrecognized_Exception( false);
            assert( DestroySurface_Unrecognized_Exception);
            dsd.ddRVal()= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return DDHAL_DRIVER_HANDLED;
    }
    DWORD Lock( PORTABLE_LOCKDATA& ld) const throw()
    { 
        // Typically, an application requesting a "Lock" of a multisampled
        // surface is not allowed. It would require a MSLock or a new version
        // of Lock to get access to the multisampled bits. However, these
        // surfaces still need to be able to "Present" the bits or "Blt" the
        // bits to the Primary, typically. This requires a workaround:
        // The runtime WILL lock the surface (not for the app), expecting the
        // rasterizer to subsample the multisampled bits into an equivalent
        // non-multisampled area and return this smaller area out of Lock,
        // so that the runtime can "Present" the bits, or whatever.

        try
        {
            TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "Lock");

            ld.ddRVal()= DD_OK;

            // First, retrieve surface object bound to this structure.
            TSurface* pSurface= GetSurface( *ld.lpDDSurface());

            // Pass control to object's Lock function.
            ld.lpSurfData()= pSurface->Lock( ld.dwFlags(), (ld.bHasRect()?
                &ld.rArea(): NULL));
        } catch( HRESULT hr) {
            ld.ddRVal()= hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            const bool Lock_Unrecognized_Exception( false);
            assert( Lock_Unrecognized_Exception);
            ld.ddRVal()= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return DDHAL_DRIVER_HANDLED;
    }
    DWORD Unlock( PORTABLE_UNLOCKDATA& ud) const throw()
    { 
        try
        {
            TEntryPointHook EntryPointHook( *sm_pGlobalDriver, "Unlock");

            ud.ddRVal()= DD_OK;

            // First, retrieve surface object bound to this structure.
            TSurface* pSurface= GetSurface( *ud.lpDDSurface());

            // Pass control to object's Unlock function.
            pSurface->Unlock();
        } catch( HRESULT hr) {
            ud.ddRVal()= hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            const bool Unlock_Unrecognized_Exception( false);
            assert( Unlock_Unrecognized_Exception);
            ud.ddRVal()= E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return DDHAL_DRIVER_HANDLED;
    }

    // Main entry point of driver.
    // Should be called by a bridge function, only.
    HRESULT GetSWInfo( D3DCAPS8& Caps8, D3D8_SWCALLBACKS& Callbacks,
        DWORD& dwNumTextures, DDSURFACEDESC*& pTexList) throw()
    {
        // This static member variable should be initialized to be NULL or
        // point it to the global class.
        assert( NULL== sm_pGlobalDriver|| \
            static_cast< TDriver*>( this)== sm_pGlobalDriver);
        sm_pGlobalDriver= static_cast< TDriver*>( this);

        Callbacks.CreateContext            = ContextCreateStub; // Needed.
        Callbacks.ContextDestroy           = ContextDestroyStub; // Needed.
        Callbacks.ContextDestroyAll        = ContextDestroyAllStub; // Unused in DX8DDI?
        Callbacks.SceneCapture             = SceneCaptureStub; // Unused in DX8DDI, now a render state.
        Callbacks.RenderState              = RenderStateStub; // Unused in DX8DDI?
        Callbacks.RenderPrimitive          = RenderPrimitiveStub; // Unused in DX8DDI?
        Callbacks.TextureCreate            = TextureCreateStub; // Unused in DX8DDI?
        Callbacks.TextureDestroy           = TextureDestroyStub; // Unused in DX8DDI?
        Callbacks.TextureSwap              = TextureSwapStub; // Unused in DX8DDI?
        Callbacks.TextureGetSurf           = TextureGetSurfStub; // Unused in DX8DDI?
        Callbacks.GetState                 = GetStateStub; // Unused in DX8DDI?
        Callbacks.SetRenderTarget          = SetRenderTargetStub; // Unused in DX8DDI?
        Callbacks.Clear                    = ClearStub; // Unused in DX8DDI?
        Callbacks.DrawOnePrimitive         = DrawOnePrimitiveStub; // Unused in DX8DDI?
        Callbacks.DrawOneIndexedPrimitive  = DrawOneIndexedPrimitiveStub; // Unused in DX8DDI?
        Callbacks.DrawPrimitives           = DrawPrimitivesStub; // Unused in DX8DDI?
        Callbacks.Clear2                   = Clear2Stub; // Unused in DX8DDI?
        Callbacks.ValidateTextureStageState= ValidateTextureStageStateStub; // Optional?
        Callbacks.DrawPrimitives2          = DrawPrimitives2Stub; // Needed.
        Callbacks.GetDriverState           = GetDriverStateStub; // Optional?
        Callbacks.CreateSurfaceEx          = CreateSurfaceExStub; // Needed.
        Callbacks.CreateSurface            = CreateSurfaceStub; // Needed.
        Callbacks.DestroySurface           = DestroySurfaceStub; // Needed.
        Callbacks.Lock                     = LockStub; // Needed.
        Callbacks.Unlock                   = UnlockStub; // Needed.

        try {
            Caps8= sm_pGlobalDriver->GetCaps();

            // There needs to be support for some surfaces, at least.
            assert( !m_SupportedSurfaces.empty());

            dwNumTextures= m_SupportedSurfaces.size();
            pTexList= &(*m_SupportedSurfaces.begin());
        } catch( bad_alloc ba) {
            return E_OUTOFMEMORY;
        } catch( HRESULT hr) {
            return hr;
#if !defined( DX8SDDIFW_NOCATCHALL)
        } catch( ... ) {
            return E_UNEXPECTED;
#endif // !defined( DX8SDDIFW_NOCATCHALL)
        }
        return S_OK;
    }
};

template< class TD, class TR>
class CMinimalDriver:
    public CSubDriver< TD, CMinimalContext< CMinimalPerDDrawData< TD>, TR> >
{
public: // Types
    typedef TR TRasterizer;

protected:
    template< class TIter> // DDSURFACEDESC*
    CMinimalDriver( TIter itStart, const TIter itEnd) :
        CSubDriver< TD, TContext>( itStart, itEnd)
    { /* TODO: Check caps? */ }
    ~CMinimalDriver() 
    { }
};

#if !defined( DX8SDDIFW_NONAMESPACE)
}
#endif // !defined( DX8SDDIFW_NONAMESPACE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\inc\ctrtest.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

template< class TSortedAssociativeContainer, const size_t c_uiNodes>
class CSortedAssociativeContainerTester
{
protected:
    typedef TSortedAssociativeContainer TTest;
    typedef block< pair< TTest::key_type, TTest::value_type::second_type>, c_uiNodes> TNodes;
    struct SAssureOrdered:
        public unary_function< TTest::value_type, bool>
    {
        TNodes::value_type m_LstVal;
        TTest::value_compare m_Cmp;
        size_t m_uiNodes;

        SAssureOrdered( const TTest::value_compare& Cmp): m_Cmp( Cmp),
            m_uiNodes( 0)
        { }
        result_type operator()( const argument_type& Arg)
        {
            result_type Ret( false);

            if( 1!= ++m_uiNodes)
                Ret= m_Cmp( Arg, m_LstVal);
            m_LstVal.first= Arg.first;
            m_LstVal.second= Arg.second;
            return Ret;
        }
    };
    struct SAssureUnOrdered:
        public unary_function< TTest::value_type, bool>
    {
        TNodes::value_type m_LstVal;
        TTest::value_compare m_Cmp;
        size_t m_uiNodes;

        SAssureUnOrdered( const TTest::value_compare& Cmp): m_Cmp( Cmp),
            m_uiNodes( 0)
        { }
        result_type operator()( const argument_type& Arg)
        {
            result_type Ret( false);

            if( 1!= ++m_uiNodes)
                Ret= !m_Cmp( Arg, m_LstVal);
            m_LstVal.first= Arg.first;
            m_LstVal.second= Arg.second;
            return Ret;
        }
    };

protected:
    TTest m_Ctr;
    size_t m_uiPerm;
    TNodes m_Nodes;
    struct TestFailure
    {
        size_t m_uiPerm;
        TestFailure( size_t uiPerm): m_uiPerm( uiPerm) { }
    };

public:
    CSortedAssociativeContainerTester( const TTest& X= TTest()): m_Ctr( X), m_uiPerm( 0)
    {
        TTest::key_type Key( 0);
        // TTest::mapped_type Val( c_uiNodes- 1);
        TTest::value_type::second_type Val( c_uiNodes- 1);
        
        TNodes::iterator itCur( m_Nodes.begin());
        while( itCur!= m_Nodes.end())
        {
            *itCur= TNodes::value_type( Key, Val);
            ++itCur;
            ++Key;
            --Val;
        }
    }
    void Test()
    {
        do
        {
            //try
            {
                TTest NewCtr( m_Ctr);

                if( !NewCtr.empty())
                    throw TestFailure( m_uiPerm);

                if( NewCtr.size()!= 0)
                    throw TestFailure( m_uiPerm);

                if( NewCtr.begin()!= NewCtr.end())
                    throw TestFailure( m_uiPerm);

                if( NewCtr.rbegin()!= NewCtr.rend())
                    throw TestFailure( m_uiPerm);

                if( !NewCtr.valid())
                    throw TestFailure( m_uiPerm);

                TNodes::iterator itCur( m_Nodes.begin());
                while( itCur!= m_Nodes.end())
                {
                    NewCtr.insert( *itCur);
                    ++itCur;

                    if( !NewCtr.valid())
                        throw TestFailure( m_uiPerm);

                    if( NewCtr.size()!= itCur- m_Nodes.begin())
                        throw TestFailure( m_uiPerm);

                    {
                        TTest::difference_type Dist( 0);
                        TTest::iterator f( NewCtr.begin());
                        TTest::iterator l( NewCtr.end());
                        for( ; f!= l; ++f)
                            ++Dist;
                        
                        if( NewCtr.size()!= Dist)
                            throw TestFailure( m_uiPerm);

                        for( ; Dist!= 0; --Dist)
                            --f;
                        
                        if( NewCtr.begin()!= f)
                            throw TestFailure( m_uiPerm);
                    }

                    {
                        TTest::difference_type Dist( 0);
                        TTest::reverse_iterator f( NewCtr.rbegin());
                        TTest::reverse_iterator l( NewCtr.rend());
                        for( ; f!= l; ++f)
                            ++Dist;
                        
                        if( NewCtr.size()!= Dist)
                            throw TestFailure( m_uiPerm);

                        for( ; Dist!= 0; --Dist)
                            --f;
                        
                        if( NewCtr.rbegin()!= f)
                            throw TestFailure( m_uiPerm);
                    }

                    if( NewCtr.end()!= find_if( NewCtr.begin(), NewCtr.end(),
                        SAssureOrdered( NewCtr.value_comp())))
                        throw TestFailure( m_uiPerm);

                    if( NewCtr.rend()!= find_if( NewCtr.rbegin(), NewCtr.rend(),
                        SAssureUnOrdered( NewCtr.value_comp())))
                        throw TestFailure( m_uiPerm);

                    TNodes::iterator itCur2( m_Nodes.begin());
                    while( itCur2!= itCur)
                    {
                        if( NewCtr.end()== NewCtr.find( itCur2->first))
                            throw TestFailure( m_uiPerm);
                        ++itCur2;
                    }

                    TTest NotherCtr( NewCtr);

                    if( !NotherCtr.valid())
                        throw TestFailure( m_uiPerm);

                    itCur2= m_Nodes.begin();
                    while( itCur2!= itCur)
                    {
                        if( 1!= NotherCtr.erase( itCur2->first))
                            throw TestFailure( m_uiPerm);

                        if( !NotherCtr.valid())
                            throw TestFailure( m_uiPerm);

                        ++itCur2;
                        {
                            TTest::difference_type Dist( 0);
                            TTest::iterator f( NotherCtr.begin());
                            TTest::iterator l( NotherCtr.end());
                            for( ; f!= l; ++f)
                                ++Dist;
                        
                            if( NotherCtr.size()!= Dist)
                                throw TestFailure( m_uiPerm);

                            for( ; Dist!= 0; --Dist)
                                --f;
                            
                            if( NotherCtr.begin()!= f)
                                throw TestFailure( m_uiPerm);
                        }

                        {
                            TTest::difference_type Dist( 0);
                            TTest::reverse_iterator f( NotherCtr.rbegin());
                            TTest::reverse_iterator l( NotherCtr.rend());
                            for( ; f!= l; ++f)
                                ++Dist;
                        
                            if( NotherCtr.size()!= Dist)
                                throw TestFailure( m_uiPerm);

                            for( ; Dist!= 0; --Dist)
                                --f;
                            
                            if( NotherCtr.rbegin()!= f)
                                throw TestFailure( m_uiPerm);
                        }


                        if( NotherCtr.end()!= find_if( NotherCtr.begin(), NotherCtr.end(),
                            SAssureOrdered( NotherCtr.value_comp())))
                            throw TestFailure( m_uiPerm);

                        if( NotherCtr.rend()!= find_if( NotherCtr.rbegin(), NotherCtr.rend(),
                            SAssureUnOrdered( NotherCtr.value_comp())))
                            throw TestFailure( m_uiPerm);

                        TNodes::iterator itCur3( itCur2);
                        while( itCur3!= itCur)
                        {
                            if( NotherCtr.end()== NotherCtr.find( itCur3->first))
                                throw TestFailure( m_uiPerm);
                            ++itCur3;
                        }
                    }
                    if( !NotherCtr.empty())
                        throw TestFailure( m_uiPerm);
                }
            }
            /*catch( TestFailure TF)
            { assert( false); }
            catch( bad_alloc BA)
            { assert( false); }
            catch( ... )
            { assert( false); }*/
            ++m_uiPerm;
        } while( false /*next_permutation( m_Nodes.begin(), m_Nodes.end(),
            m_Ctr.value_comp())*/);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\inc\hash_table.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

template< class Key>
class hash
{
private:
    hash() {}
};

template<>
class hash< char>:
    public unary_function< char, size_t>
{
public:
    result_type operator()( argument_type Arg) const
    { return static_cast<result_type>(Arg); }
};
template<>
class hash< unsigned char>:
    public unary_function< unsigned char, size_t>
{
public:
    result_type operator()( argument_type Arg) const
    { return static_cast<result_type>(Arg); }
};
template<>
class hash< signed char>:
    public unary_function< signed char, size_t>
{
public:
    result_type operator()( argument_type Arg) const
    { return static_cast<result_type>(Arg); }
};
template<>
class hash< short>:
    public unary_function< short, size_t>
{
public:
  result_type operator()( argument_type Arg) const
  { return static_cast<result_type>(Arg); }
};
template<>
class hash< unsigned short>:
    public unary_function< unsigned short, size_t>
{
public:
  result_type operator()( argument_type Arg) const
  { return static_cast<result_type>(Arg); }
};
template<>
class hash< int>:
    public unary_function< int, size_t>
{
public:
  result_type operator()( argument_type Arg) const
  { return static_cast<result_type>(Arg); }
};
template<>
class hash< unsigned int>:
    public unary_function< unsigned int, size_t>
{
public:
  result_type operator()( argument_type Arg) const
  { return static_cast<result_type>(Arg); }
};
template<>
class hash< long>:
    public unary_function< long, size_t>
{
public:
  result_type operator()( argument_type Arg) const
  { return static_cast<result_type>(Arg); }
};
template<>
class hash< unsigned long>:
    public unary_function< unsigned long, size_t>
{
public:
  result_type operator()( argument_type Arg) const
  { return static_cast<result_type>(Arg); }
};

template< class T, const size_t Buckets, class Key, class HashFun,
    class ExtractKey, class EqualKey, class Allocator>
class static_hash_table:
    public list< T, Allocator>
{
public: // Types
    typedef static_hash_table< T, Buckets, Key, HashFun, ExtractKey, EqualKey,
        Allocator> table_type;
    typedef list< T, Allocator> list_type;

    typedef Key key_type;
    using list_type::value_type;
    typedef HashFun hasher;
    typedef EqualKey key_equal;
    typedef ExtractKey key_extract;
    using list_type::pointer;
    using list_type::const_pointer;
    using list_type::reference;
    using list_type::const_reference;
    using list_type::size_type;
    using list_type::difference_type;
    using list_type::iterator;
    using list_type::const_iterator;
    using list_type::reverse_iterator;
    using list_type::const_reverse_iterator;

protected: // Types
    typedef block< iterator, Buckets+ 1> table_buckets_type;

protected: // Variables
    table_buckets_type m_buckets;
    hasher m_hasher;
    key_equal m_key_equal;
    key_extract m_key_extract;

public: // Functions
    using list_type::begin;
    using list_type::end;
    using list_type::rbegin;
    using list_type::rend;
    using list_type::size;
    using list_type::max_size;
    using list_type::empty;
    size_type bucket_count() const
    { return m_buckets.size()- 1; }
    void resize( size_type n)
    { const bool NYI( false); assert( NYI); /* TODO: NYI */ }
    hasher hash_funct() const
    { return m_hasher; }
    key_equal key_eq() const
    { return m_key_equal; }
    static_hash_table( const HashFun& H, const EqualKey& EqK,
        const ExtractKey& ExK, const allocator_type& A): list_type( A),
        m_hasher( H), m_key_equal( EqK), m_key_extract( ExK)
    {
        fill( m_buckets.begin(), m_buckets.end(), end());
    }
    static_hash_table( const table_type& HT): list_type( HT.get_allocator())
    {
        fill( m_buckets.begin(), m_buckets.end(), end());
        (*this)= HT;
    }
    ~static_hash_table()
    {
    }
    table_type& operator=( const table_type& Other)
    {
        if( this!= &Other)
        {
            clear();
            m_hasher= Other.m_hasher;
            m_key_equal= Other.m_key_equal;
            m_key_extract= Other.m_key_extract;
            // TODO: insert_equal( Other.begin(), Other.end());
            insert_unique( Other.begin(), Other.end());
        }
        return *this;
    }
    using list_type::get_allocator;
    void swap( table_type& Other)
    {
        const bool NYI( false); assert( NYI); 
        /* TODO: NYI
        swap( m_hasher, Other.m_hasher);
        swap( m_key_equal, Other.m_key_equal);
        swap( m_key_extract, Other.m_key_extract);
        if( m_Allocator== Other.m_Allocator)
        {
            list_type::swap( Other);
            m_buckets.swap( Other.m_buckets);
        }
        else
            insert_equal( Other.begin(), Other.end());
        */
    }
    pair< iterator, bool> insert_unique( const value_type& NewVal)
    {
        const key_type NewKey( m_key_extract( NewVal));
        const size_t uiBucket( m_hasher( NewKey)% bucket_count());

        table_buckets_type::iterator itBucket( m_buckets.begin());
        itBucket+= uiBucket;
        table_buckets_type::iterator itNextBucket( itBucket);
        ++itNextBucket;

        for( iterator itFound( *itBucket); itFound!= *itNextBucket; ++itFound)
            if( m_key_equal( NewKey, m_key_extract( *itFound)))
                return pair< iterator, bool>( itFound, false);
        
        iterator itInsertPos( *itNextBucket);

        table_buckets_type::iterator itBeginFill( m_buckets.begin());
        if( begin()!= itInsertPos)
        {
            iterator itPrevNode( itInsertPos);
            itBeginFill+= ( m_hasher( m_key_extract( *(--itPrevNode)))%
                bucket_count())+ 1;
        }
        
        iterator itNewNode( insert( itInsertPos, NewVal));
        fill( itBeginFill, ++itBucket, itNewNode);
        return pair< iterator, bool>( itNewNode, true);
    }
    template <class InputIterator>
    void insert_unique( InputIterator f, InputIterator l)
    {
        while( f!= l)
        {
            insert_unique( *f);
            ++f;
        }
    }
    iterator insert_equal( const value_type& NewVal)
    {
        // TODO: NYI
        const bool NYI( false); assert( NYI); 
        return end();
    }
    template< class InputIterator>
    void insert_equal( InputIterator f, InputIterator l)
    {
        while( f!= l)
        {
            insert_equal( *f);
            ++f;
        }
    }
    void erase( iterator pos)
    {
        table_buckets_type::iterator itBeginFill( m_buckets.begin());
        if( begin()!= pos)
        {
            iterator itPrevNode( pos);
            itBeginFill+= ( m_hasher( m_key_extract( *(--itPrevNode)))%
                bucket_count())+ 1;
        }
        table_buckets_type::iterator itEndFill( m_buckets.begin());
        itEndFill+= ( m_hasher( m_key_extract( *pos))% bucket_count())+ 1;

        iterator itNextNode( pos);
        ++itNextNode;
        fill( itBeginFill, itEndFill, itNextNode);
        list_type::erase( pos);
    }
    size_type erase( const key_type& k)
    {
        size_type uiErased( 0);
        const size_type uiBucket( m_hasher( k)% bucket_count());

        table_buckets_type::iterator itBucket( m_buckets.begin());
        itBucket+= uiBucket;
        table_buckets_type::iterator itNextBucket( itBucket);
        ++itNextBucket;

        iterator itChk( *itBucket);
        // Only the first in the bucket could modify the bucket values.
        if( itChk!= *itNextBucket)
        {
            if( m_key_equal( k, m_key_extract( *itChk)))
            {
                iterator itDel( itChk);
                ++itChk;
                erase( itDel);
                ++uiErased;
            }
            else
                ++itChk;
        }
        while( itChk!= *itNextBucket)
        {
            if( m_key_equal( k, m_key_extract( *itChk)))
            {
                iterator itDel( itChk);
                ++itChk;
                list_type::erase( itDel);
                ++uiErased;
            }
            else
                ++itChk;
        }
        return uiErased;
    }
    void erase( iterator f, iterator l)
    {
        while( f!= l)
        {
            erase( f);
            ++f;
        }
    }
    iterator find( const key_type& k)
    {
        const size_type uiBucket( m_hasher( k)% bucket_count());

        table_buckets_type::iterator itBucket( m_buckets.begin());
        itBucket+= uiBucket;
        table_buckets_type::iterator itNextBucket( itBucket);
        ++itNextBucket;

        for( iterator itFound( *itBucket); itFound!= *itNextBucket; ++itFound)
            if( m_key_equal( k, m_key_extract( *itFound)))
                return itFound;

        return end();
    } 
    const_iterator find( const key_type& k) const
    {
        const size_type uiBucket( m_hasher( k)% bucket_count());

        table_buckets_type::const_iterator itBucket( m_buckets.begin());
        itBucket+= uiBucket;
        table_buckets_type::const_iterator itNextBucket( itBucket);
        ++itNextBucket;

        for( const_iterator itFound( *itBucket); itFound!= *itNextBucket; ++itFound)
            if( m_key_equal( k, m_key_extract( *itFound)))
                return itFound;

        return end();
    }
    size_type count( const key_type& k) const
    {
        // TODO: NYI
        const bool NYI( false); assert( NYI); 
        return 0;
    }
    pair< iterator, iterator> equal_range( const key_type& k)
    {
        // TODO: NYI
        const bool NYI( false); assert( NYI); 
        return pair< iterator, iterator>( end(), end());
    }
    pair< const_iterator, const_iterator> equal_range( const key_type& k) const
    {
        // TODO: NYI
        const bool NYI( false); assert( NYI); 
        return pair< const_iterator, const_iterator>( end(), end());
    }
    void clear()
    {
        if( 0!= size())
        {
            fill( m_buckets.begin(), m_buckets.end(), end());
            list_type::clear();
        }
    }
};

// TODO: Global operators.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\inc\list.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

template< class T, class Allocator= allocator< T> >
class list
{
public: // Types
    typedef list< T, Allocator> list_type;
    typedef Allocator allocator_type;
    typedef typename allocator_type::value_type value_type;
    typedef typename allocator_type::pointer pointer;
    typedef typename allocator_type::const_pointer const_pointer;
    typedef typename allocator_type::reference reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef typename allocator_type::size_type size_type;
    typedef typename allocator_type::difference_type difference_type;

protected: // Types
    struct list_node;
    typedef typename Allocator::rebind< list_node>::other
        list_node_allocator_type;
    typedef typename list_node_allocator_type::pointer list_node_pointer;
    typedef typename list_node_allocator_type::const_pointer
        list_node_const_pointer;
    struct list_node
    {
        list_node_pointer m_pNext;
        list_node_pointer m_pPrev;
        value_type m_Value;

        list_node()
        { }
        list_node( const value_type& Val): m_Value( Val)
        { }
        list_node( const list_node_pointer& pN, const list_node_pointer& pP,
            const value_type& Val): m_pNext( pN), m_pPrev( pP), m_Value( Val)
        { }
        ~list_node()
        { }
    };
    
public: // Types
    class iterator;
    class const_iterator;
    class reverse_iterator;
    class const_reverse_iterator;
    friend class iterator;
    class iterator
    {
    public: // Types
        typedef bidirectional_iterator_tag iterator_category;
        typedef value_type value_type;
        typedef difference_type difference_type;
        typedef pointer pointer;
        typedef reference reference;
        friend class const_iterator;
        friend class reverse_iterator;
        friend class const_reverse_iterator;
        friend class list< T, Allocator>;

    protected: // Variables
        list_node_pointer m_pNode;

    public: // Functions
        iterator()
        { }
        explicit iterator( const list_node_pointer& pNode)
            :m_pNode( pNode)
        { }
        iterator( const iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        iterator( const reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        reference operator*() const
        { return m_pNode->m_Value; }
        pointer operator->() const
        { return &m_pNode->m_Value; }
        iterator& operator++()
        {
            m_pNode= m_pNode->m_pNext;
            return (*this);
        }
        iterator operator++(int)
        {
            iterator Tmp( *this);
            ++(*this);
            return Tmp;
        }
        iterator& operator--()
        {
            m_pNode= m_pNode->m_pPrev;
            return (*this);
        }
        iterator operator--(int)
        {
            iterator Tmp( *this);
            --(*this);
            return Tmp;
        }
        bool operator==( const iterator& Other) const
        { return (m_pNode== Other.m_pNode); }
        bool operator!=( const iterator& Other) const
        { return (m_pNode!= Other.m_pNode); }
    };
    friend class const_iterator;
    class const_iterator
    {
    public: // Types
        typedef bidirectional_iterator_tag iterator_category;
        typedef value_type value_type;
        typedef difference_type difference_type;
        typedef const_pointer pointer;
        typedef const_reference reference;
        friend class const_reverse_iterator;
        friend class list< T, Allocator>;

    protected: // Variables
        list_node_const_pointer m_pNode;

    public: // Functions
        const_iterator()
        { }
        explicit const_iterator( const list_node_const_pointer& pNode)
            :m_pNode( pNode)
        { }
        const_iterator( const iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_iterator( const const_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_iterator( const reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_iterator( const const_reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        reference operator*() const
        { return m_pNode->m_Value; }
        pointer operator->() const
        { return &m_pNode->m_Value; }
        const_iterator& operator++()
        {
            m_pNode= m_pNode->m_pNext;
            return (*this);
        }
        const_iterator operator++(int)
        {
            const_iterator Tmp( *this);
            ++(*this);
            return Tmp;
        }
        const_iterator& operator--()
        {
            m_pNode= m_pNode->m_pPrev;
            return (*this);
        }
        const_iterator operator--(int)
        {
            const_iterator Tmp( *this);
            --(*this);
            return Tmp;
        }
        bool operator==( const const_iterator& Other) const
        { return (m_pNode== Other.m_pNode); }
        bool operator!=( const const_iterator& Other) const
        { return (m_pNode!= Other.m_pNode); }
    };
    friend class reverse_iterator;
    class reverse_iterator
    {
    public: // Types
        typedef bidirectional_iterator_tag iterator_category;
        typedef value_type value_type;
        typedef difference_type difference_type;
        typedef pointer pointer;
        typedef reference reference;
        friend class iterator;
        friend class const_iterator;
        friend class const_reverse_iterator;
        friend class list< T, Allocator>;

    protected: // Variables
        list_node_pointer m_pNode;

    public: // Functions
        reverse_iterator()
        { }
        explicit reverse_iterator( const list_node_pointer& pNode)
            :m_pNode( pNode)
        { }
        reverse_iterator( const iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        reverse_iterator( const reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        reference operator*() const
        { return m_pNode->m_Value; }
        pointer operator->() const
        { return &m_pNode->m_Value; }
        reverse_iterator& operator++()
        {
            m_pNode= m_pNode->m_pPrev;
            return (*this);
        }
        reverse_iterator operator++(int)
        {
            reverse_iterator Tmp( *this);
            ++(*this);
            return Tmp;
        }
        reverse_iterator& operator--()
        {
            m_pNode= m_pNode->m_pNext;
            return (*this);
        }
        reverse_iterator operator--(int)
        {
            reverse_iterator Tmp( *this);
            --(*this);
            return Tmp;
        }
        bool operator==( const reverse_iterator& Other) const
        { return (m_pNode== Other.m_pNode); }
        bool operator!=( const reverse_iterator& Other) const
        { return (m_pNode!= Other.m_pNode); }
    };
    friend class const_reverse_iterator;
    class const_reverse_iterator
    {
    public: // Types
        typedef bidirectional_iterator_tag iterator_category;
        typedef value_type value_type;
        typedef difference_type difference_type;
        typedef const_pointer pointer;
        typedef const_reference reference;
        friend class const_iterator;
        friend class list< T, Allocator>;

    protected: // Variables
        list_node_const_pointer m_pNode;

    public: // Functions
        const_reverse_iterator()
        { }
        explicit const_reverse_iterator( const list_node_const_pointer& pNode)
            :m_pNode( pNode)
        { }
        const_reverse_iterator( const iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_reverse_iterator( const const_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_reverse_iterator( const reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_reverse_iterator( const const_reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        reference operator*() const
        { return m_pNode->m_Value; }
        pointer operator->() const
        { return &m_pNode->m_Value; }
        const_reverse_iterator& operator++()
        {
            m_pNode= m_pNode->m_pPrev;
            return (*this);
        }
        const_reverse_iterator operator++(int)
        {
            const_reverse_iterator Tmp( *this);
            ++(*this);
            return Tmp;
        }
        const_reverse_iterator& operator--()
        {
            m_pNode= m_pNode->m_pNext;
            return (*this);
        }
        const_reverse_iterator operator--(int)
        {
            const_reverse_iterator Tmp( *this);
            --(*this);
            return Tmp;
        }
        bool operator==( const const_reverse_iterator& Other) const
        { return (m_pNode== Other.m_pNode); }
        bool operator!=( const const_reverse_iterator& Other) const
        { return (m_pNode!= Other.m_pNode); }
    };

protected: // Variables
    list_node_pointer m_pHead;
    size_type m_uiNodes;
    list_node_allocator_type m_Allocator;

protected: // Functions
    void BuildHeadNode()
    {
        m_pHead= m_Allocator.allocate( 1);
        new (&m_pHead->m_pNext) list_node_pointer( m_pHead);
        new (&m_pHead->m_pPrev) list_node_pointer( m_pHead);
    }
    void DestroyHeadNode()
    {
        m_pHead->m_pNext.~list_node_pointer();
        m_pHead->m_pPrev.~list_node_pointer();
        m_Allocator.deallocate( m_pHead, 1);
    }

public: // Functions
    iterator begin()
    { return iterator( m_pHead->m_pNext); }
    iterator end()
    { return iterator( m_pHead); }
    reverse_iterator rbegin()
    { return reverse_iterator( m_pHead->m_pPrev); }
    reverse_iterator rend()
    { return reverse_iterator( m_pHead); }
    const_iterator begin() const
    { return const_iterator( m_pHead->m_pNext); }
    const_iterator end() const
    { return const_iterator( m_pHead); }
    const_reverse_iterator rbegin() const
    { return const_reverse_iterator( m_pHead->m_pPrev); }
    const_reverse_iterator rend() const
    { return const_reverse_iterator( m_pHead->m_pPrev); }
    size_type size() const
    { return m_uiNodes; }
    size_type max_size() const
    { return m_Allocator.max_size(); }
    bool empty() const
    { return (0== m_uiNodes); }
    explicit list( const Allocator& A= Allocator())
        : m_pHead( NULL), m_uiNodes( 0), m_Allocator( A)
    {
        BuildHeadNode();
    }
    explicit list( size_type n, const T& x= T(), const Allocator& A= Allocator())
        : m_pHead( NULL), m_uiNodes( 0), m_Allocator( A)
    {
        BuildHeadNode();
        try {
            insert( begin(), n, x);
        } catch( ... ) {
            clear();
            DestroyHeadNode();
            throw;
        }
    }
    list( const list_type& Other)
        : m_pHead( NULL), m_uiNodes( 0), m_Allocator( Other.m_Allocator)
    {
        BuildHeadNode();
        try {
            insert( begin(), Other.begin(), Other.end());
        } catch( ... ) {
            clear();
            DestroyHeadNode();
            throw;
        }
    }
    template< class InputIterator>
    list( InputIterator f, InputIterator l, const Allocator& A= Allocator())
        : m_pHead( NULL), m_uiNodes( 0), m_Allocator( Other.m_Allocator)
    {
        BuildHeadNode();
        try {
            insert( begin(), f, l);
        } catch( ... ) {
            clear();
            DestroyHeadNode();
            throw;
        }
    }
    ~list()
    { 
        clear();
        DestroyHeadNode();
    }
    list_type& operator=( const list_type& Other)
    {
        if( this!= &Other)
        {
            // TODO: Better exception handling.
            iterator itMyCur( begin());
            iterator itMyEnd( end());
            const_iterator itOtherCur( Other.begin());
            const_iterator itOtherEnd( Other.end());
            while( itMyCur!= itMyEnd && itOtherCur!= itOtherEnd)
            {
                *itMyCur= *itOtherCur;
                ++itMyCur;
                ++itOtherCur;
            }
            erase( itMyCur, itMyEnd);
            insert( itMyCur, itOtherCur, itOtherEnd);
        }
        return (*this);
    }
    allocator_type get_allocator() const
    { return m_Allocator; }
    void swap( list_type& Other)
    {
        if( m_Allocator== Other.m_Allocator)
        {
            swap( m_pHead, Other.m_pHead);
            swap( m_uiNodes, Other.m_uiNodes);
        }
        else
        {
            iterator itMyCur( begin());
            splice( itMyCur, Other);
            itMyCur.splice( Other.begin(), *this, itMyCur, end());
        }
    }
    reference front()
    { return *begin(); }
    const_reference front() const
    { return *begin(); }
    reference back()
    { return *(--end()); }
    const_reference back() const
    { return *(--end()); }
    void push_front( const T& t)
    { insert( begin(), t); }
    void pop_front()
    { erase( begin()); }
    void push_back( const T& t)
    { insert( end(), t); }
    void pop_back()
    { erase( --end()); }
    iterator insert( iterator pos, const T& t)
    {
        list_node_pointer pNode( pos.m_pNode);
        list_node_pointer pPrev( pNode->m_pPrev);
        m_Allocator.construct( pNode->m_pPrev= m_Allocator.allocate( 1),
            list_node( pNode, pPrev, t));
        pNode= pNode->m_pPrev;
        pNode->m_pPrev->m_pNext= pNode;
        ++m_uiNodes;
        return iterator( pNode);
    }
    template< class InputIterator>
    void insert( iterator pos, InputIterator f, InputIterator l)
    {
        // TODO: Optimize
        while( f!= l)
        {
            insert( pos, *f);
            ++f;
        }
    }
    void insert( iterator pos, size_type n, const T& x)
    {
        // TODO: Optimize
        if( n!= 0) do
        {
            insert( pos, x);
        } while( --n!= 0);
    }
    iterator erase( iterator pos)
    {
        list_node_pointer pNode( pos.m_pNode);
        list_node_pointer pNext( pNode->m_pNext);
        pNode->m_pPrev->m_pNext= pNext;
        pNext->m_pPrev= pNode->m_pPrev;
        m_Allocator.destroy( pNode);
        m_Allocator.deallocate( pNode, 1);
        --m_uiNodes;
        return iterator( pNext);
    }
    iterator erase( iterator f, iterator l)
    {
        // TODO: Optimize
        while( f!= l)
        {
            iterator d( f);
            ++f;
            erase( d);
        }
        return f;
    }
    void clear()
    {
        if( 0!= size())
        {
            list_node_pointer pNode( m_pHead->m_pNext);
            list_node_pointer pNext( pNode->m_pNext);
            do
            {
                m_Allocator.destroy( pNode);
                m_Allocator.deallocate( pNode, 1);
                pNode= pNext;
                pNext= pNext->m_pNext;
            } while( pNode!= m_pHead);
            m_pHead->m_pPrev= m_pHead->m_pNext= m_pHead;
        }
    }
    void resize( size_type n, T t= T())
    {
        const size_type CurSize( m_uiNodes);
        if( CurSize< n)
            insert( end(), n- CurSize, t);
        else if( CurSize> n)
        {
            iterator itStartRange;

            if( n> CurSize/ 2)
            {
                itStartRange= end();
                size_type dist( CurSize- n+ 1);
                do {
                    --itStartRange;
                } while( --dist!= 0);
            }
            else
            {
                itStartRange= begin();
                size_type dist( n);
                if( dist!= 0) do {
                    ++itStartRange;
                } while( ++dist!= 0);
            }
            erase( itStartRange, end());
        }
    }
    template< class InputIterator>
    void assign( InputIterator f, InputIterator l)
    {
        iterator itMyCur( begin());
        iterator itMyEnd( end());
        while( itMyCur!= itMyEnd && f!= l)
        {
            *itMyCur= *f;
            ++itMyCur;
            ++f;
        }
        erase( itMyCur, itMyEnd);
        insert( itMyCur, f, l);
    }
    void assign( size_type n, const T& x= T())
    {
        iterator itMyCur( begin());
        iterator itMyEnd( end());
        while( itMyCur!= itMyEnd && f!= l)
        {
            *itMyCur= *x;
            ++itMyCur;
            ++f;
        }
        erase( itMyCur, itMyEnd);
        insert( itMyCur, n, x);
    }
/* TODO:
    void splice( iterator pos, list_type& x)
    {
        if( !x.empty())
        {
            _Splice(_P, _X, _X.begin(), _X.end());
            _Size += _X._Size;
            _X._Size = 0;
        }
    }
    void splice(iterator _P, _Myt& _X, iterator _F)
        {iterator _L = _F;
        if (_P != _F && _P != ++_L)
            {_Splice(_P, _X, _F, _L);
            ++_Size;
            --_X._Size; }}
    void splice(iterator _P, _Myt& _X, iterator _F, iterator _L)
        {if (_F != _L)
            {if (&_X != this)
                {difference_type _N = 0;
                _Distance(_F, _L, _N);
                _Size += _N;
                _X._Size -= _N; }
            _Splice(_P, _X, _F, _L); }}
    void remove(const T& _V)
        {iterator _L = end();
        for (iterator _F = begin(); _F != _L; )
            if (*_F == _V)
                erase(_F++);
            else
                ++_F; }
    typedef binder2nd<not_equal_to<T> > _Pr1;
    void remove_if(_Pr1 _Pr)
        {iterator _L = end();
        for (iterator _F = begin(); _F != _L; )
            if (_Pr(*_F))
                erase(_F++);
            else
                ++_F; }
    void unique()
        {iterator _F = begin(), _L = end();
        if (_F != _L)
            for (iterator _M = _F; ++_M != _L; _M = _F)
                if (*_F == *_M)
                    erase(_M);
                else
                    _F = _M; }
    typedef not_equal_to<T> _Pr2;
    void unique(_Pr2 _Pr)
        {iterator _F = begin(), _L = end();
        if (_F != _L)
            for (iterator _M = _F; ++_M != _L; _M = _F)
                if (_Pr(*_F, *_M))
                    erase(_M);
                else
                    _F = _M; }
    void merge(_Myt& _X)
        {if (&_X != this)
            {iterator _F1 = begin(), _L1 = end();
            iterator _F2 = _X.begin(), _L2 = _X.end();
            while (_F1 != _L1 && _F2 != _L2)
                if (*_F2 < *_F1)
                    {iterator _Mid2 = _F2;
                    _Splice(_F1, _X, _F2, ++_Mid2);
                    _F2 = _Mid2; }
                else
                    ++_F1;
            if (_F2 != _L2)
                _Splice(_L1, _X, _F2, _L2);
            _Size += _X._Size;
            _X._Size = 0; }}
    typedef greater<T> _Pr3;
    void merge(_Myt& _X, _Pr3 _Pr)
        {if (&_X != this)
            {iterator _F1 = begin(), _L1 = end();
            iterator _F2 = _X.begin(), _L2 = _X.end();
            while (_F1 != _L1 && _F2 != _L2)
                if (_Pr(*_F2, *_F1))
                    {iterator _Mid2 = _F2;
                    _Splice(_F1, _X, _F2, ++_Mid2);
                    _F2 = _Mid2; }
                else
                    ++_F1;
            if (_F2 != _L2)
                _Splice(_L1, _X, _F2, _L2);
            _Size += _X._Size;
            _X._Size = 0; }}
    void sort()
        {if (2 <= size())
            {const size_t _MAXN = 15;
            _Myt _X(allocator), Allocator[_MAXN + 1];
            size_t _N = 0;
            while (!empty())
                {_X.splice(_X.begin(), *this, begin());
                size_t _I;
                for (_I = 0; _I < _N && !Allocator[_I].empty(); ++_I)
                    {Allocator[_I].merge(_X);
                    Allocator[_I].swap(_X); }
                if (_I == _MAXN)
                    Allocator[_I].merge(_X);
                else
                    {Allocator[_I].swap(_X);
                    if (_I == _N)
                        ++_N; }}
            while (0 < _N)
                merge(Allocator[--_N]); }}
    void sort(_Pr3 _Pr)
        {if (2 <= size())
            {const size_t _MAXN = 15;
            _Myt _X(allocator), Allocator[_MAXN + 1];
            size_t _N = 0;
            while (!empty())
                {_X.splice(_X.begin(), *this, begin());
                size_t _I;
                for (_I = 0; _I < _N && !Allocator[_I].empty(); ++_I)
                    {Allocator[_I].merge(_X, _Pr);
                    Allocator[_I].swap(_X); }
                if (_I == _MAXN)
                    Allocator[_I].merge(_X, _Pr);
                else
                    {Allocator[_I].swap(_X);
                    if (_I == _N)
                        ++_N; }}
            while (0 < _N)
                merge(Allocator[--_N], _Pr); }}
    void reverse()
        {if (2 <= size())
            {iterator _L = end();
            for (iterator _F = ++begin(); _F != _L; )
                {iterator _M = _F;
                _Splice(begin(), *this, _M, ++_F); }}}
protected:
    _Nodeptr _Buynode(_Nodeptr _Narg = 0, _Nodeptr _Parg = 0)
        {_Nodeptr _S = (_Nodeptr)allocator._Charalloc(
            1 * sizeof (list_node));
        _Acc::_Next(_S) = _Narg != 0 ? _Narg : _S;
        _Acc::_Prev(_S) = _Parg != 0 ? _Parg : _S;
        return (_S); }
    void _Freenode(_Nodeptr _S)
        {allocator.deallocate(_S, 1); }
    void _Splice(iterator _P, _Myt& _X, iterator _F, iterator _L)
        {if (allocator == _X.allocator)
            {_Acc::_Next(_Acc::_Prev(_L._Mynode())) =
                _P._Mynode();
            _Acc::_Next(_Acc::_Prev(_F._Mynode())) =
                _L._Mynode();
            _Acc::_Next(_Acc::_Prev(_P._Mynode())) =
                _F._Mynode();
            _Nodeptr _S = _Acc::_Prev(_P._Mynode());
            _Acc::_Prev(_P._Mynode()) =
                _Acc::_Prev(_L._Mynode());
            _Acc::_Prev(_L._Mynode()) =
                _Acc::_Prev(_F._Mynode());
            _Acc::_Prev(_F._Mynode()) = _S; }
        else
            {insert(_P, _F, _L);
            _X.erase(_F, _L); }}
    void _Xran() const
        {_THROW(out_of_range, "invalid list<T> subscript"); }
*/
};
        // list TEMPLATE OPERATORS
template< class T, class Allocator> inline
bool operator==( const list< T, Allocator>& x, const list< T, Allocator>& y)
{
    return (x.size()== y.size()&& equal(x.begin(), x.end(), y.begin()));
}

template< class T, class Allocator> inline
bool operator!=( const list< T, Allocator>& x, const list< T, Allocator>& y)
{
    return !(x== y);
}

template< class T, class Allocator> inline
bool operator<( const list< T, Allocator>& x, const list< T, Allocator>& y)
{
    return lexicographical_compare( x.begin(), x.end(), y.begin(), y.end());
}

template< class T, class Allocator> inline
bool operator>( const list< T, Allocator>& x, const list< T, Allocator>& y)
{
    return y< x;
}

template< class T, class Allocator> inline
bool operator<=( const list< T, Allocator>& x, const list< T, Allocator>& y)
{
    return !(y< x);
}

template< class T, class Allocator> inline
bool operator>=( const list< T, Allocator>& x, const list< T, Allocator>& y)
{
    return !(x< y);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\inc\map.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

template< class Key, class T, class Compare= less<Key>,
    class Allocator= allocator<pair<const Key,T> > >
class map:
    public RBTree< Key, pair<const Key,T>, select1st<pair<const Key,T> >,
        Compare, Allocator>
{
public: // Types
    typedef map< Key, T, Compare, Allocator> map_type;
    typedef RBTree< Key, pair<const Key,T>, select1st<pair<const Key,T> >,
        Compare, Allocator> tree_type;

    typedef typename tree_type::key_type key_type;
    typedef typename Allocator::rebind< T>::other mapped_type;
    typedef typename tree_type::value_type value_type;
    typedef typename tree_type::key_compare key_compare;
    struct value_compare:
        public binary_function< value_type, value_type, bool>
    {
        key_compare m_key_compare;
        explicit value_compare( const key_compare& KC): m_key_compare( KC)
        { }

        result_type operator()( const first_argument_type& Arg1,
            const second_argument_type& Arg2) const
        {
            return m_key_compare( Arg1.first, Arg2.first);
        }
    };
    typedef typename tree_type::pointer pointer;
    typedef typename tree_type::const_pointer const_pointer;
    typedef typename tree_type::reference reference;
    typedef typename tree_type::const_reference const_reference;
    typedef typename tree_type::size_type size_type;
    typedef typename tree_type::difference_type difference_type;
    typedef typename tree_type::iterator iterator;
    typedef typename tree_type::const_iterator const_iterator;
    typedef typename tree_type::reverse_iterator reverse_iterator;
    typedef typename tree_type::const_reverse_iterator const_reverse_iterator;
    typedef typename tree_type::allocator_type allocator_type;

public: // Functions
    using tree_type::begin;
    using tree_type::end;
    using tree_type::rbegin;
    using tree_type::rend;
    using tree_type::size;
    using tree_type::max_size;
    using tree_type::empty;
    using tree_type::key_comp;
    value_compare value_comp() const
    { return value_compare( key_comp()); }
    explicit map( const Compare& comp= Compare(),
        const Allocator& A= Allocator()): tree_type( comp,
        select1st<pair<const Key,T> >(), A)
    { }
    template< class InputIterator>
    map( InputIterator f, InputIterator l, const Compare comp= Compare(),
        const Allocator& A= Allocator()): tree_type( comp,
        select1st<pair<const Key,T> >(), A)
    {
        insert_unique( f, l);
    }
    map( const map_type& Other): tree_type( Other)
    { }
    ~map()
    { }
    map_type& operator=( const map_type& Other)
    {
        tree_type::operator=( Other);
        return *this;
    }
    using tree_type::get_allocator;
    void swap( const map_type& Other)
    { tree_type::swap( Other); }
    pair< iterator, bool> insert( const value_type& x)
    { return insert_unique( x); }
    iterator insert( iterator pos, const value_type& x)
    { return insert_unique( x); }
    template< class InputIterator>
    void insert( InputIterator f, InputIterator l)
    { insert_unique( f, l); }
    using tree_type::erase;
    using tree_type::find;
    using tree_type::count;
    using tree_type::lower_bound;
    using tree_type::upper_bound;
    using tree_type::equal_range;
    mapped_type& operator[]( const key_type& k)
    {
        iterator itEntry( insert( value_type( k, mapped_type())));
        return itEntry->second;
    }
};

template< class Key, class T, class Compare, class Allocator> inline
bool operator==( const map< Key, T, Compare, Allocator>& x,
    const map< Key, T, Compare, Allocator>& y)
{
    return x.size()== y.size()&& equal( x.begin(), x.end(), y.begin());
}
template< class Key, class T, class Compare, class Allocator> inline
bool operator!=( const map< Key, T, Compare, Allocator>& x,
    const map< Key, T, Compare, Allocator>& y)
{
    return !(x== y);
}
template< class Key, class T, class Compare, class Allocator> inline
bool operator<( const map< Key, T, Compare, Allocator>& x,
    const map< Key, T, Compare, Allocator>& y)
{
    return lexicographical_compare( x.begin(), x.end(), y.begin(), y.end());
}
template< class Key, class T, class Compare, class Allocator> inline
bool operator>( const map< Key, T, Compare, Allocator>& x,
    const map< Key, T, Compare, Allocator>& y)
{
    return y< x;
}
template< class Key, class T, class Compare, class Allocator> inline
bool operator<=( const map< Key, T, Compare, Allocator>& x,
    const map< Key, T, Compare, Allocator>& y)
{
    return !(y< x);
}
template< class Key, class T, class Compare, class Allocator> inline
bool operator>=( const map< Key, T, Compare, Allocator>& x,
    const map< Key, T, Compare, Allocator>& y)
{
    return !(x< y);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\cspan\cbldfncs.h ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void C_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);

void C_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
void C_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\inc\set.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

template< class Key, class Compare= less<Key>, class Allocator= allocator<Key> >
class set:
    public RBTree< Key, Key, identity<Key>, Compare, Allocator>
{
public: // Types
    typedef set< Key, Compare, Allocator> set_type;
    typedef RBTree< Key, Key, identity<Key>, Compare, Allocator> tree_type;

    typedef typename tree_type::value_type value_type;
    typedef typename tree_type::key_type key_type;
    typedef typename tree_type::key_compare key_compare;
    typedef typename tree_type::key_compare value_compare;
    typedef typename tree_type::pointer pointer;
    typedef typename tree_type::const_pointer const_pointer;
    typedef typename tree_type::reference reference;
    typedef typename tree_type::const_reference const_reference;
    typedef typename tree_type::size_type size_type;
    typedef typename tree_type::difference_type difference_type;
    typedef typename tree_type::iterator iterator;
    typedef typename tree_type::const_iterator const_iterator;
    typedef typename tree_type::reverse_iterator reverse_iterator;
    typedef typename tree_type::const_reverse_iterator const_reverse_iterator;
    typedef typename tree_type::allocator_type allocator_type;

public: // Functions
    using tree_type::begin;
    using tree_type::end;
    using tree_type::rbegin;
    using tree_type::rend;
    using tree_type::size;
    using tree_type::max_size;
    using tree_type::empty;
    using tree_type::key_comp;
    value_compare value_comp() const
    { return key_comp(); }
    explicit set( const Compare& comp= Compare(),
        const Allocator& A= Allocator()): tree_type( comp, identity<Key>(), A)
    { }
    template< class InputIterator>
    set( InputIterator f, InputIterator l, const Compare comp= Compare(),
        const Allocator& A= Allocator()): tree_type( comp, identity<Key>(), A)
    {
        insert_unique( f, l);
    }
    set( const set_type& Other): tree_type( Other)
    { }
    ~set()
    { }
    set_type& operator=( const set_type& Other)
    {
        tree_type::operator=( Other);
        return *this;
    }
    using tree_type::get_allocator;
    void swap( const set_type& Other)
    { tree_type::swap( Other); }
    pair< iterator, bool> insert( const value_type& x)
    { return insert_unique( x); }
    iterator insert( iterator pos, const value_type& x)
    { return insert_unique( x); }
    template< class InputIterator>
    void insert( InputIterator f, InputIterator l)
    { insert_unique( f, l); }
    using tree_type::erase;
    using tree_type::find;
    using tree_type::count;
    using tree_type::lower_bound;
    using tree_type::upper_bound;
    using tree_type::equal_range;
};

template< class Key, class Compare, class Allocator>
bool operator==( const set< Key, Compare, Allocator>& x,
    const set< Key, Compare, Allocator>& y)
{
    return x.size()== y.size()&& equal( x.begin(), x.end(), y.begin());
}
template< class Key, class Compare, class Allocator>
bool operator!=( const set< Key, Compare, Allocator>& x,
    const set< Key, Compare, Allocator>& y)
{
    return !(x== y);
}
template< class Key, class Compare, class Allocator>
bool operator<( const set< Key, Compare, Allocator>& x,
    const set< Key, Compare, Allocator>& y)
{
    return lexicographical_compare( x.begin(), x.end(), y.begin(), y.end());
}
template< class Key, class Compare, class Allocator>
bool operator>( const set< Key, Compare, Allocator>& x,
    const set< Key, Compare, Allocator>& y)
{
    return y< x;
}
template< class Key, class Compare, class Allocator>
bool operator<=( const set< Key, Compare, Allocator>& x,
    const set< Key, Compare, Allocator>& y)
{
    return !(y< x);
}
template< class Key, class Compare, class Allocator>
bool operator>=( const set< Key, Compare, Allocator>& x,
    const set< Key, Compare, Allocator>& y)
{
    return !(x< y);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\cspan\cbufread.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color buffer reading routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
D3DCOLOR C_BufRead_B8G8R8(PUINT8 pBits);
D3DCOLOR C_BufRead_B8G8R8X8(PUINT8 pBits);
D3DCOLOR C_BufRead_B8G8R8A8(PUINT8 pBits);
D3DCOLOR C_BufRead_B5G6R5(PUINT8 pBits);
D3DCOLOR C_BufRead_B5G5R5(PUINT8 pBits);
D3DCOLOR C_BufRead_B5G5R5A1(PUINT8 pBits);
D3DCOLOR C_BufRead_Palette8(PUINT8 pBits);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\cspan\cbufwrt.h ===
//-----------------------------------------------------------------------------
//
// This file contains the output color writing routine headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.
void C_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
void C_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\cspan\cloop.h ===
//-----------------------------------------------------------------------------
//
// This file contains C span loop headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void C_LoopAny(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\cspan\cspnpars.h ===
//----------------------------------------------------------------------------
//
// cspnpars.h
//
// Top-level span rendering routine declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANPARS_H_
#define _SPANPARS_H_

HRESULT C_RenderSpansAny(PD3DI_RASTCTX pCtx);

#endif // #ifndef _SPANPARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\rgb.inc ===
RGBRASTROOT = $(SWRASTROOT)\rgb

MAJORCOMP = d3d
MINORCOMP = rgbrast

INCLUDES = $(RGBRASTROOT)\pch\$(_OBJ_DIR)\$(TARGET_DIRECTORY);$(RGBRASTROOT)\pch;$(INCLUDES)

# RGB needs __cdecl default.
386_STDCALL=0

# The framework, and hence RGB require these.
USE_NATIVE_EH=1
USE_STL=1

# Uncomment out if would like to use CRT debugging.
#
#!IF "$(NTDEBUG)" == "ntsd"
#DEBUG_CRTS=1
#!ENDIF

# Disable MASM 5.x compatibility
NOMASMCOMPATIBILITY = 1

# Use MASM 6.11d for assembly since 6.11a doesn't handle the MMX
# macros properly.
386_ASSEMBLER_NAME = ml611d
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\cspan\cspnutil.h ===
//----------------------------------------------------------------------------
//
// cspnutil.h
//
// Sundry span utility declarations.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#ifndef _SPANUTIL_H_
#define _SPANUTIL_H_

#ifdef _X86_
// warning C4035: 'imul32h' : no return value
#pragma warning( disable : 4035 )
#endif

//-----------------------------------------------------------------------------
//
// imul32h
//
// Returns the upper 32 bits of a 32 bit by 32 bit signed multiply.
//
//-----------------------------------------------------------------------------
inline INT32 imul32h(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        mov eax, edx
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 32);
#endif
}

//-----------------------------------------------------------------------------
//
// imul32h_s20
//
// Returns (x*y)>>20
//
//-----------------------------------------------------------------------------
inline INT32 imul32h_s20(INT32 x, INT32 y)
{
#ifdef _X86_
    _asm
    {
        mov eax, x
        mov edx, y
        imul edx
        shrd eax, edx, 20
    }
#else
    return (INT32)(((LONGLONG)x * y) >> 20);
#endif
}


#ifdef _X86_
// in general, we want to look at these warnings
#pragma warning( default : 4035 )
#endif

#endif // #ifndef _SPANUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\inc\tree.h ===
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

template< class Key, class T, class ExtractKey, class CompareKey, class Allocator>
class RBTree
{
public: // Types
    typedef RBTree< Key, T, ExtractKey, CompareKey, Allocator> tree_type;
    typedef Allocator allocator_type;

    typedef Key key_type;
    typedef typename allocator_type::value_type value_type;
    typedef CompareKey key_compare;
    typedef ExtractKey key_extract;
    typedef typename allocator_type::pointer pointer;
    typedef typename allocator_type::const_pointer const_pointer;
    typedef typename allocator_type::reference reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef typename allocator_type::size_type size_type;
    typedef typename allocator_type::difference_type difference_type;

protected: // Types
    struct tree_node;
    typedef typename Allocator::rebind< tree_node>::other
        tree_node_allocator_type;
    typedef typename tree_node_allocator_type::pointer tree_node_pointer;
    typedef typename tree_node_allocator_type::const_pointer
        tree_node_const_pointer;
    struct tree_node
    {
        tree_node_pointer m_pLeft;
        tree_node_pointer m_pParent;
        tree_node_pointer m_pRight;
        value_type m_Value;
        bool m_bRed;

        tree_node( const tree_node_pointer& pP, const value_type& v, bool bRed)
            :m_pLeft( NULL), m_pParent( pP), m_pRight( NULL), m_Value( v),
            m_bRed( bRed)
        { }
        ~tree_node()
        { }
    };
    template< class TPointer>
    struct NextInOrderNode:
        public unary_function< TPointer, TPointer>
    {
        result_type operator()( argument_type Arg, const bool bCouldBeEnd) const
        {
            if( bCouldBeEnd&& Arg->m_bRed&& Arg->m_pParent->m_pParent== Arg)
                Arg= Arg->m_pLeft;
            else if( Arg->m_pRight!= NULL)
            {
                Arg= Arg->m_pRight;
                while( Arg->m_pLeft!= NULL)
                    Arg= Arg->m_pLeft;
            }
            else
            {
                TPointer pP;
                while( Arg== (pP= Arg->m_pParent)->m_pRight)
                    Arg= pP;
                if( bCouldBeEnd|| Arg->m_pRight!= pP)
                    Arg= pP;
            }
            return Arg;
        }
    };
    template< class TPointer>
    struct PrevInOrderNode:
        public unary_function< TPointer, TPointer>
    {
        result_type operator()( argument_type Arg, const bool bCouldBeEnd) const
        {
            if( bCouldBeEnd&& Arg->m_bRed&& Arg->m_pParent->m_pParent== Arg)
                Arg= Arg->m_pRight;
            else if( Arg->m_pLeft!= NULL)
            {
                Arg= Arg->m_pLeft;
                while( Arg->m_pRight!= NULL)
                    Arg= Arg->m_pRight;
            }
            else
            {
                TPointer pP;
                while( Arg== (pP= Arg->m_pParent)->m_pLeft)
                    Arg= pP;
                if( bCouldBeEnd|| Arg->m_pLeft!= pP)
                    Arg= pP;
            }
            return Arg;
        }
    };

public: // Types
    class iterator;
    class const_iterator;
    class reverse_iterator;
    class const_reverse_iterator;
    friend class iterator;
    class iterator
    {
    public: // Types
        typedef bidirectional_iterator_tag iterator_category;
        typedef value_type value_type;
        typedef difference_type difference_type;
        typedef pointer pointer;
        typedef reference reference;
        friend class const_iterator;
        friend class reverse_iterator;
        friend class const_reverse_iterator;
        friend class RBTree< Key, T, ExtractKey, CompareKey, Allocator>;

    protected:
        tree_node_pointer m_pNode;
        NextInOrderNode< tree_node_pointer> m_fnNext;
        PrevInOrderNode< tree_node_pointer> m_fnPrev;

    public:
        iterator()
        { }
        explicit iterator( const tree_node_pointer& pN)
            :m_pNode( pN)
        { }
        iterator( const iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        iterator( const reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        reference operator*() const
        { return m_pNode->m_Value; }
        pointer operator->() const
        { return &**this; }
        iterator& operator++()
        {
            // end()++ is not valid.
            m_pNode= m_fnNext( m_pNode, false);
            return (*this);
        }
        iterator operator++( int)
        {
            iterator Temp( *this);
            ++(*this);
            return Temp;
        }
        iterator& operator--()
        {
            // end()-- is valid.
            m_pNode= m_fnPrev( m_pNode, true);
            return (*this);
        }
        iterator operator--( int)
        {
            iterator Temp( *this);
            --(*this);
            return (Temp);
        }
        bool operator==( const iterator& Other) const
        { return m_pNode== Other.m_pNode; }
        bool operator!=( const iterator& Other) const
        { return m_pNode!= Other.m_pNode; }
    };
    friend class const_iterator;
    class const_iterator
    {
    public: // Types
        typedef bidirectional_iterator_tag iterator_category;
        typedef value_type value_type;
        typedef difference_type difference_type;
        typedef const_pointer pointer;
        typedef const_reference reference;
        friend class const_reverse_iterator;
        friend class RBTree< Key, T, ExtractKey, CompareKey, Allocator>;

    protected:
        tree_node_const_pointer m_pNode;
        NextInOrderNode< tree_node_const_pointer> m_fnNext;
        PrevInOrderNode< tree_node_const_pointer> m_fnPrev;

    public:
        const_iterator()
        { }
        explicit const_iterator( const tree_node_const_pointer& pN)
            :m_pNode( pN)
        { }
        const_iterator( const iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_iterator( const const_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_iterator( const reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_iterator( const const_reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        reference operator*() const
        { return m_pNode->m_Value; }
        pointer operator->() const
        { return &**this; }
        const_iterator& operator++()
        {
            // end()++ is not valid.
            m_pNode= m_fnNext( m_pNode, false);
            return (*this);
        }
        const_iterator operator++( int)
        {
            iterator Temp( *this);
            ++(*this);
            return Temp;
        }
        const_iterator& operator--()
        {
            // end()-- is valid.
            m_pNode= m_fnPrev( m_pNode, true);
            return (*this);
        }
        const_iterator operator--( int)
        {
            iterator Temp( *this);
            --(*this);
            return (Temp);
        }
        bool operator==( const const_iterator& Other) const
        { return m_pNode== Other.m_pNode; }
        bool operator!=( const const_iterator& Other) const
        { return m_pNode!= Other.m_pNode; }
    };
    friend class reverse_iterator;
    class reverse_iterator
    {
    public: // Types
        typedef bidirectional_iterator_tag iterator_category;
        typedef value_type value_type;
        typedef difference_type difference_type;
        typedef pointer pointer;
        typedef reference reference;
        friend class iterator;
        friend class const_iterator;
        friend class const_reverse_iterator;
        friend class RBTree< Key, T, ExtractKey, CompareKey, Allocator>;

    protected:
        tree_node_pointer m_pNode;
        PrevInOrderNode< tree_node_pointer> m_fnNext;
        NextInOrderNode< tree_node_pointer> m_fnPrev;

    public:
        reverse_iterator()
        { }
        explicit reverse_iterator( const tree_node_pointer& pN)
            :m_pNode( pN)
        { }
        reverse_iterator( const iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        reverse_iterator( const reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        reference operator*() const
        { return m_pNode->m_Value; }
        pointer operator->() const
        { return &**this; }
        reverse_iterator& operator++()
        {
            // rend()++ is not valid.
            m_pNode= m_fnNext( m_pNode, false);
            return (*this);
        }
        reverse_iterator operator++( int)
        {
            iterator Temp( *this);
            ++(*this);
            return Temp;
        }
        reverse_iterator& operator--()
        {
            // rend()-- is valid.
            m_pNode= m_fnPrev( m_pNode, true);
            return (*this);
        }
        reverse_iterator operator--( int)
        {
            iterator Temp( *this);
            --(*this);
            return (Temp);
        }
        bool operator==( const reverse_iterator& Other) const
        { return m_pNode== Other.m_pNode; }
        bool operator!=( const reverse_iterator& Other) const
        { return m_pNode!= Other.m_pNode; }
    };
    friend class const_reverse_iterator;
    class const_reverse_iterator
    {
    public: // Types
        typedef bidirectional_iterator_tag iterator_category;
        typedef value_type value_type;
        typedef difference_type difference_type;
        typedef const_pointer pointer;
        typedef const_reference reference;
        friend class const_iterator;
        friend class RBTree< Key, T, ExtractKey, CompareKey, Allocator>;

    protected:
        tree_node_const_pointer m_pNode;
        PrevInOrderNode< tree_node_const_pointer> m_fnNext;
        NextInOrderNode< tree_node_const_pointer> m_fnPrev;

    public:
        const_reverse_iterator()
        { }
        explicit const_reverse_iterator( const tree_node_const_pointer& pN)
            :m_pNode( pN)
        { }
        const_reverse_iterator( const iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_reverse_iterator( const const_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_reverse_iterator( const reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        const_reverse_iterator( const const_reverse_iterator& Other)
            :m_pNode( Other.m_pNode)
        { }
        reference operator*() const
        { return m_pNode->m_Value; }
        pointer operator->() const
        { return &**this; }
        const_reverse_iterator& operator++()
        {
            // rend()++ is not valid.
            m_pNode= m_fnNext( m_pNode, false);
            return (*this);
        }
        const_reverse_iterator operator++( int)
        {
            iterator Temp( *this);
            ++(*this);
            return Temp;
        }
        const_reverse_iterator& operator--()
        {
            // rend()-- is valid.
            m_pNode= m_fnPrev( m_pNode, true);
            return (*this);
        }
        const_reverse_iterator operator--( int)
        {
            iterator Temp( *this);
            --(*this);
            return (Temp);
        }
        bool operator==( const const_reverse_iterator& Other) const
        { return m_pNode== Other.m_pNode; }
        bool operator!=( const const_reverse_iterator& Other) const
        { return m_pNode!= Other.m_pNode; }
    };

protected: // Variables
    tree_node_pointer m_pHead;
    size_type m_uiNodes;
    key_compare m_key_compare;
    key_extract m_key_extract;
    tree_node_allocator_type m_allocator;

protected: // Functions
    void BuildHeadNode()
    {
        m_pHead= m_allocator.allocate( 1);
        new (&m_pHead->m_pLeft) tree_node_pointer( m_pHead);
        new (&m_pHead->m_pParent) tree_node_pointer( NULL);
        new (&m_pHead->m_pRight) tree_node_pointer( m_pHead);
        new (&m_pHead->m_bRed) bool( true);
    }
    void DestroyHeadNode()
    {
        m_pHead->m_pLeft.~list_node_pointer();
        m_pHead->m_pParent.~list_node_pointer();
        m_pHead->m_pRight.~list_node_pointer();
        m_allocator.deallocate( m_pHead, 1);
    }
    void RotateLeft( tree_node_pointer pX)
    {
        tree_node_pointer pY( pX->m_pRight);
        pX->m_pRight= pY->m_pLeft;
        if( pY->m_pLeft!= NULL)
            pY->m_pLeft->m_pParent= pX;
        pY->m_pParent= pX->m_pParent;
        if( pX== m_pHead->m_pParent)
            m_pHead->m_pParent= pY;
        else if( pX== pX->m_pParent->m_pLeft)
            pX->m_pParent->m_pLeft= pY;
        else
            pX->m_pParent->m_pRight= pY;
        pY->m_pLeft= pX;
        pX->m_pParent= pY;
    }
    void RotateRight( tree_node_pointer pX)
    {
        tree_node_pointer pY( pX->m_pLeft);
        pX->m_pLeft= pY->m_pRight;
        if( pY->m_pRight!= NULL)
            pY->m_pRight->m_pParent= pX;
        pY->m_pParent= pX->m_pParent;
        if( pX== m_pHead->m_pParent)
            m_pHead->m_pParent= pY;
        else if( pX== pX->m_pParent->m_pRight)
            pX->m_pParent->m_pRight= pY;
        else
            pX->m_pParent->m_pLeft= pY;
        pY->m_pRight= pX;
        pX->m_pParent= pY;
    }
    void RecDelete( tree_node_pointer pX)
    {
        for( tree_node_pointer pY( pX); pY!= NULL; pX= pY)
        {
            RecDelete( pY->m_pRight);
            pY= pY->m_pLeft;
            m_allocator.destroy( pX);
            m_allocator.deallocate( pX, 1);
        }
    }
    tree_node_pointer lowerbound( const key_type& k) const
    {
        tree_node_pointer pX( m_pHead->m_pParent);
        tree_node_pointer pY( m_pHead);
        while( pX!= NULL)
        {
            if( m_key_compare( m_key_extract( pX->m_Value), k))
                pX= pX->m_pRight;
            else
            {
                pY= pX;
                pX= pX->m_pLeft;
            }
        }
        return pY;
    }
    tree_node_pointer upperbound( const key_type& k) const
    {
        tree_node_pointer pX( m_pHead->m_pParent);
        tree_node_pointer pY( m_pHead);
        while( pX!= NULL)
        {
            if( m_key_compare( k, m_key_extract( pX->m_Value)))
            {
                pY= pX;
                pX= pX->m_pLeft;
            }
            else
                pX= pX->m_pRight;
        }
        return pY;
    }
    iterator Insert( tree_node_pointer pX,
        tree_node_pointer pY, const value_type& V)
    {
        tree_node_pointer pZ( m_allocator.allocate( 1));
        m_allocator.construct( pZ, tree_node( pY, V, true));
        ++m_uiNodes;

        if( pY== m_pHead|| pX!= NULL||
            m_key_compare( m_key_extract( V), m_key_extract( pY->m_Value)))
        {
            pY->m_pLeft= pZ;
            if( pY== m_pHead)
            {
                m_pHead->m_pParent= pZ;
                m_pHead->m_pRight= pZ;
            }
            else if( pY== m_pHead->m_pLeft)
                m_pHead->m_pLeft= pZ;
        }
        else
        {
            pY->m_pRight= pZ;
            if( pY== m_pHead->m_pRight)
                m_pHead->m_pRight= pZ;
        }

        for( pX= pZ; pX!= m_pHead->m_pParent&& pX->m_pParent->m_bRed; )
        {
            if( pX->m_pParent== pX->m_pParent->m_pParent->m_pLeft)
            {
                pY= pX->m_pParent->m_pParent->m_pRight;
                if( pY!= NULL&& pY->m_bRed)
                {
                    pX->m_pParent->m_bRed= false;
                    pY->m_bRed= false;
                    pX->m_pParent->m_pParent->m_bRed= true;
                    pX= pX->m_pParent->m_pParent;
                }
                else
                {
                    if( pX== pX->m_pParent->m_pRight)
                    {
                        pX= pX->m_pParent;
                        RotateLeft( pX);
                    }
                    pX->m_pParent->m_bRed= false;
                    pX->m_pParent->m_pParent->m_bRed= true;
                    RotateRight( pX->m_pParent->m_pParent);
                }
            }
            else
            {
                pY= pX->m_pParent->m_pParent->m_pLeft;
                if( pY!= NULL&& pY->m_bRed)
                {
                    pX->m_pParent->m_bRed= false;
                    pY->m_bRed= false;
                    pX->m_pParent->m_pParent->m_bRed= true;
                    pX= pX->m_pParent->m_pParent;
                }
                else
                {
                    if( pX== pX->m_pParent->m_pLeft)
                    {
                        pX= pX->m_pParent;
                        RotateRight( pX);
                    }
                    pX->m_pParent->m_bRed= false;
                    pX->m_pParent->m_pParent->m_bRed= true;
                    RotateLeft( pX->m_pParent->m_pParent);
                }
            }
        }
        m_pHead->m_pParent->m_bRed= false;
        return iterator( pZ);
    }

public: // Functions
    iterator begin()
    { return iterator( m_pHead->m_pLeft); }
    const_iterator begin() const
    { return const_iterator( m_pHead->m_pLeft); }
    iterator end()
    { return iterator( m_pHead); }
    const_iterator end() const
    { return const_iterator( m_pHead); }
    reverse_iterator rbegin()
    { return reverse_iterator( m_pHead->m_pRight); }
    const_reverse_iterator rbegin() const
    { return const_reverse_iterator( m_pHead->m_pRight); }
    reverse_iterator rend()
    { return reverse_iterator( m_pHead); }
    const_reverse_iterator rend() const
    { return const_reverse_iterator( m_pHead); }
    size_type size() const
    { return m_uiNodes; }
    size_type max_size() const
    { return m_allocator.max_size(); }
    bool empty() const
    { return 0== size(); }
    key_compare key_comp() const
    { return m_key_compare; }
    explicit RBTree( const CompareKey& CmpKey= CompareKey(), const ExtractKey&
        ExKey= ExtractKey(), const Allocator& A= Allocator()): m_pHead( NULL),
        m_uiNodes( 0), m_key_compare( CmpKey), m_key_extract( ExKey),
        m_allocator( A)
    {
        BuildHeadNode();
    }
    RBTree( const tree_type& Other): m_pHead( NULL), m_uiNodes( 0),
        m_key_compare( Other.m_key_compare), m_key_extract( Other.m_key_extract),
        m_allocator( Other.m_allocator)
    {
        BuildHeadNode();
        try {
            *this= Other;
        } catch( ... ) {
            clear();
            DestroyHeadNode();
            throw;
        }
    }
    ~RBTree()
    {
        clear();
        DestroyHeadNode();
    }
    tree_type& operator=( const tree_type& x)
    {
        if( this!= &x)
        {
            erase( begin(), end());
            m_key_compare= x.m_key_compare;
            m_key_extract= x.m_key_extract;
            insert_equal( x.begin(), x.end());
        }
        return (*this);
    }
    allocator_type get_allocator() const
    { return m_allocator; }
    void swap( const tree_type& x)
    {
        swap( m_key_compare, x.m_key_compare);
        swap( m_key_extract, x.m_key_extract);
        if( m_allocator== x.m_allocator)
        {
            swap( m_pHead, x.m_pHead);
            swap( m_uiNodes, x.m_uiNodes);
        }
        else
        {
            tree_type Temp( *this);
            *this= x;
            x= Temp;
        }
    }
//
// Global ::swap was always called instead of this method. Now that we always instantiate it,
// as required by the Standard, it confilcts with the global definition
//
// An overload (see the end of this file) is now called instead of this friend function
//
//    friend void swap( tree_type& x, tree_type& y)
//    { x.swap( y); }
    pair< iterator, bool> insert_unique( const value_type& x)
    {
        tree_node_pointer pA( m_pHead->m_pParent);
        tree_node_pointer pB( m_pHead);

        const key_type XKey( m_key_extract( x));
        bool bCmp( true);
        while( pA!= NULL)
        {
            pB= pA;
            bCmp= m_key_compare( XKey, m_key_extract( pA->m_Value));
            pA= (bCmp? pA->m_pLeft: pA->m_pRight);
        }

        iterator itP( pB);
        if( bCmp)
        {
            if( itP== begin())
                return pair< iterator, bool>( Insert( pA, pB, x), true);
            else
                --itP;
        }
        if( m_key_compare( m_key_extract( itP.m_pNode->m_Value), XKey))
            return pair< iterator, bool>( Insert( pA, pB, x), true);
        return pair< iterator, bool>( itP, false);
    }
    iterator insert_unique( iterator pP, const value_type& x)
    {
        return insert_unique( x).first;
    }
    template< class ForwardIterator>
    void insert_unique( ForwardIterator f, ForwardIterator l)
    {
        while( f!= l)
        {
            insert_unique( *f);
            ++f;
        }
    }
    iterator insert_equal( const value_type& x)
    {
        tree_node_pointer pA( m_pHead->m_pParent);
        tree_node_pointer pB( m_pHead);

        const key_type XKey( m_key_extract( x));
        bool bCmp( true);
        while( pA!= NULL)
        {
            pB= pA;
            bCmp= m_key_compare( XKey, m_key_extract( pA->m_Value));
            pA= (bCmp? pA->m_pLeft: pA->m_pRight);
        }

        return iterator( Insert( pA, pB, x));
    }
    iterator insert_equal( iterator pP, const value_type& x)
    {
        return insert_equal( x);
    }
    template< class ForwardIterator>
    void insert_equal( ForwardIterator f, ForwardIterator l)
    {
        while( f!= l)
        {
            insert_equal( *f);
            ++f;
        }
    }
    iterator erase( iterator itDel)
    {
        tree_node_pointer pW;
        tree_node_pointer pX;
        tree_node_pointer pY( itDel.m_pNode);
        tree_node_pointer pZ( pY);
        ++itDel;
        if( pY->m_pLeft== NULL)
            pX= pY->m_pRight;
        else if( pY->m_pRight== NULL)
            pX= pY->m_pLeft;
        else
        {
            pY= pY->m_pRight;
            while( pY->m_pLeft!= NULL)
                pY= pY->m_pLeft;
            pX= pY->m_pRight;
        }
        tree_node_pointer pXParent( pY);
        if( pY!= pZ)
        {
            pZ->m_pLeft->m_pParent= pY;
            pY->m_pLeft= pZ->m_pLeft;

            if( pY== pZ->m_pRight)
                (pX!= NULL? pX->m_pParent= pXParent= pY: pXParent= pY);
            else
            {
                (pX!= NULL? pX->m_pParent= pXParent= pY->m_pParent: pXParent= pY->m_pParent);
                pY->m_pParent->m_pLeft= pX;
                pY->m_pRight= pZ->m_pRight;
                pZ->m_pRight->m_pParent= pY;
            }
            
            if( m_pHead->m_pParent== pZ)
                m_pHead->m_pParent= pY;
            else if( pZ->m_pParent->m_pLeft== pZ)
                pZ->m_pParent->m_pLeft= pY;
            else
                pZ->m_pParent->m_pRight= pY;

            pY->m_pParent= pZ->m_pParent;
            const bool bTmp( pY->m_bRed);
            pY->m_bRed= pZ->m_bRed;
            pZ->m_bRed= bTmp;
            pY= pZ;
        }
        else
        {
            (pX!= NULL? pX->m_pParent= pXParent= pY->m_pParent: pXParent= pY->m_pParent);
            if( m_pHead->m_pParent== pZ)
                m_pHead->m_pParent= pX;
            else if( pZ->m_pParent->m_pLeft== pZ)
                pZ->m_pParent->m_pLeft= pX;
            else
                pZ->m_pParent->m_pRight= pX;

            if( m_pHead->m_pLeft== pZ)
            {
                if( pZ->m_pRight== NULL)
                    m_pHead->m_pLeft= pZ->m_pParent;
                else
                {
                    m_pHead->m_pLeft= pX;
                    while( m_pHead->m_pLeft->m_pLeft!= NULL)
                        m_pHead->m_pLeft= m_pHead->m_pLeft->m_pLeft;
                }
            }
            if( m_pHead->m_pRight== pZ)
            {
                if( pZ->m_pLeft== NULL)
                    m_pHead->m_pRight= pZ->m_pParent;
                else
                {
                    m_pHead->m_pRight= pX;
                    while( m_pHead->m_pRight->m_pRight!= NULL)
                        m_pHead->m_pRight= m_pHead->m_pRight->m_pRight;
                }
            }
        }
        if( !pY->m_bRed)
        {
            while( pX!= m_pHead->m_pParent&& (pX== NULL|| !pX->m_bRed))
            {
                if( pX== pXParent->m_pLeft)
                {
                    pW= pXParent->m_pRight;
                    if( pW->m_bRed)
                    {
                        pW->m_bRed= false;
                        pXParent->m_bRed= true;
                        RotateLeft( pXParent);
                        pW= pXParent->m_pRight;
                    }
                    if( (pW->m_pLeft== NULL|| !pW->m_pLeft->m_bRed)&&
                        (pW->m_pRight== NULL|| !pW->m_pRight->m_bRed) )
                    {
                        pW->m_bRed= true;
                        pX= pXParent;
                        pXParent= pXParent->m_pParent;
                    }
                    else
                    {
                        if( pW->m_pRight== NULL|| !pW->m_pRight->m_bRed)
                        {
                            pW->m_pLeft->m_bRed= false;
                            pW->m_bRed= true;
                            RotateRight( pW);
                            pW= pXParent->m_pRight;
                        }
                        pW->m_bRed= pXParent->m_bRed;
                        pXParent->m_bRed= false;
                        pW->m_pRight->m_bRed= false;
                        RotateLeft( pXParent);
                        break;
                    }
                }
                else
                {
                    pW= pXParent->m_pLeft;
                    if( pW->m_bRed)
                    {
                        pW->m_bRed= false;
                        pXParent->m_bRed= true;
                        RotateRight( pXParent);
                        pW= pXParent->m_pLeft;
                    }
                    if( (pW->m_pLeft== NULL|| !pW->m_pLeft->m_bRed)&&
                        (pW->m_pRight== NULL|| !pW->m_pRight->m_bRed) )
                    {
                        pW->m_bRed= true;
                        pX= pXParent;
                        pXParent= pXParent->m_pParent;
                    }
                    else
                    {
                        if( pW->m_pLeft== NULL|| !pW->m_pLeft->m_bRed)
                        {
                            pW->m_pRight->m_bRed= false;
                            pW->m_bRed= true;
                            RotateLeft( pW);
                            pW= pXParent->m_pLeft;
                        }
                        pW->m_bRed= pXParent->m_bRed;
                        pXParent->m_bRed= false;
                        pW->m_pLeft->m_bRed= false;
                        RotateRight( pXParent);
                        break;
                    }
                }
            }
            if( pX!= NULL)
                pX->m_bRed= false;
        }
        m_allocator.destroy( pY);
        m_allocator.deallocate( pY, 1);
        --m_uiNodes;
        return itDel;
    }
    iterator erase( iterator f, iterator l)
    {
        if( 0== size()|| f!= begin() || l!= end())
        {
            while( f!= l)
                f= erase( f);
            return f;
        }
        clear();
        return begin();
    }
    size_type erase( const key_type& k)
    {
        const pair< iterator, iterator> EqRng( equal_range( k));
        size_type n( 0);
        iterator itCur( EqRng.first);
        while( itCur!= EqRng.second)
        {
            ++itCur;
            ++n;
        }
        erase( EqRng.first, EqRng.second);
        return n;
    }
    void clear()
    {
        RecDelete( m_pHead->m_pParent);
        m_uiNodes= 0;
        m_pHead->m_pParent= NULL;
        m_pHead->m_pRight= m_pHead->m_pLeft= m_pHead;
    }
    iterator find( const key_type& k)
    {
        iterator itLB( lower_bound( k));
        return( itLB== end()|| m_key_compare( k, m_key_extract(
            itLB.m_pNode->m_Value))? end(): itLB);
    }
    const_iterator find( const key_type& k) const
    {
        const_iterator itLB( lower_bound( k));
        return( itLB== end()|| m_key_compare( k, m_key_extract(
            itLB.m_pNode->m_Value))? end(): itLB);
    }
    size_type count( const key_type& k) const
    {
        const pair< const_iterator, const_iterator> EqRng( equal_range( k));
        size_type n( 0);
        const_iterator itCur( EqRng.first);
        while( itCur!= EqRng.second)
        {
            ++itCur;
            ++n;
        }
        return n;
    }
    iterator lower_bound( const key_type& k)
    { return iterator( lowerbound( k)); }
    const_iterator lower_bound( const key_type& k) const
    { return const_iterator( lowerbound( k)); }
    iterator upper_bound( const key_type& k)
    { return iterator( upperbound( k)); }
    const_iterator upper_bound( const key_type& k) const
    { return const_iterator( upperbound( k)); }
    pair< iterator, iterator> equal_range( const key_type& k)
    { return pair< iterator, iterator>( lower_bound( k), upper_bound( k)); }
    pair< const_iterator, const_iterator> equal_range( const key_type& k) const
    { return pair< const_iterator, const_iterator>( lower_bound( k), upper_bound( k)); }
#if 0
    pair< bool, int> InValid( tree_node_pointer pNode, tree_node_pointer pParent, bool bParentRed)
    {
        pair< bool, int> RightRet( false, 1);
        if( pNode->m_pRight!= NULL)
            RightRet= InValid( pNode->m_pRight, pNode, pNode->m_bRed);

        pair< bool, int> LeftRet( false, 1);
        if( pNode->m_pLeft!= NULL)
            LeftRet= InValid( pNode->m_pLeft, pNode, pNode->m_bRed);

        return pair< bool, int>( pNode->m_pParent!= pParent|| RightRet.first|| LeftRet.first||
            RightRet.second!= LeftRet.second|| (bParentRed&& pNode->m_bRed),
            RightRet.second+ (pNode->m_bRed? 0: 1));
    }
    bool valid()
    {
        if( m_pHead->m_pParent!= NULL)
        {
            bool bInvalid( InValid( m_pHead->m_pParent, m_pHead, m_pHead->m_bRed).first);

            tree_node_pointer pChk= m_pHead->m_pParent;
            while( pChk->m_pLeft!= NULL)
                pChk= pChk->m_pLeft;
            bInvalid|= (pChk!= m_pHead->m_pLeft);

            pChk= m_pHead->m_pParent;
            while( pChk->m_pRight!= NULL)
                pChk= pChk->m_pRight;
            bInvalid|= (pChk!= m_pHead->m_pRight);

            return !bInvalid;
        }
        else
            return true;
    }
#endif
};

template< class Key, class T, class ExtractKey, class CompareKey, class Allocator>
void swap(RBTree<Key,T,ExtractKey,CompareKey,Allocator>& x, RBTree<Key,T,ExtractKey,CompareKey, Allocator>& y)
{
	x.swap(y);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\cspan\cbufwrt.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the output buffer color writing routines.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop
#include "cbufwrt.h"

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.

extern UINT16 g_uDitherTable[16];
//-----------------------------------------------------------------------------
//
// Write_B8G8R8X8_NoDither
//
// Writes output in BGR-888 format, aligned to 32 bits.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B8G8R8X8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    // Must write 0 for the unspecified alpha channel to be compatible with DX5
    // for destination color keying
    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                             pCtx->SI.uBB>>8, 0x00);

    PUINT32 pSurface = (PUINT32)pS->pSurface;
    *pSurface = uARGB;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B8G8R8A8_NoDither
//
// Writes output in BGRA-8888 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B8G8R8A8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT32 uARGB = RGBA_MAKE(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8,
                             pCtx->SI.uBB>>8, pCtx->SI.uBA>>8);

    PUINT32 pSurface = (PUINT32)pS->pSurface;
    *pSurface = uARGB;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G6R5_NoDither
//
// Writes output in BGR-565 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G6R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  0) & 0xf800) |
        ((pCtx->SI.uBG >>  5) & 0x07e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G6R5_Dither
//
// Writes output in BGR-565 format, dithered.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G6R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 2;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min< UINT16>((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min< UINT16>((uG >> 8) + ((uG & 0xff) > uDither), 0x3f);
    uR = min< UINT16>((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 11);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5_NoDither
//
// Writes output in BGR-555 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    // Must write 0 for the unspecified alpha channel to be compatible with DX5
    // for destination color keying
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  1) & 0x7c00) |
        ((pCtx->SI.uBG >>  6) & 0x03e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5_Dither
//
// Writes output in BGR-555 format, dithered.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 3;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min< UINT16>((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min< UINT16>((uG >> 8) + ((uG & 0xff) > uDither), 0x1f);
    uR = min< UINT16>((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    // Must write 0 for the unspecified alpha channel to be compatible with DX5
    // for destination color keying
    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 10);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5A1_NoDither
//
// Writes output in BGRA-1555 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5A1_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    *(PUINT16)pS->pSurface =
        ((pCtx->SI.uBR >>  1) & 0x7c00) |
        ((pCtx->SI.uBG >>  6) & 0x03e0) |
        ((pCtx->SI.uBB >> 11) & 0x001f) |
        ((pCtx->SI.uBA >>  0) & 0x8000);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B5G5R5A1_Dither
//
// Writes output in BGRA-1555 format, dithered.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B5G5R5A1_Dither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uDither = g_uDitherTable[pCtx->SI.uDitherOffset];
    UINT16 uB = pCtx->SI.uBB >> 3;     // 8.8 >> 3 = 8.5
    UINT16 uG = pCtx->SI.uBG >> 3;
    UINT16 uR = pCtx->SI.uBR >> 3;

    uB = min< UINT16>((uB >> 8) + ((uB & 0xff) > uDither), 0x1f);
    uG = min< UINT16>((uG >> 8) + ((uG & 0xff) > uDither), 0x1f);
    uR = min< UINT16>((uR >> 8) + ((uR & 0xff) > uDither), 0x1f);

    *(PUINT16)pS->pSurface = uB | (uG << 5) | (uR << 10) | (pCtx->SI.uBA & 0x8000);

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_B8G8R8_NoDither
//
// Writes output in BGR-888 format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_B8G8R8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    PUINT8 pSurface = (PUINT8)pS->pSurface;
    *pSurface++ = pCtx->SI.uBB>>8;
    *pSurface++ = pCtx->SI.uBG>>8;
    *pSurface++ = pCtx->SI.uBR>>8;

    // just returns for C, since we really can't loop with function calls
}

//-----------------------------------------------------------------------------
//
// Write_Palette8_NoDither
//
// Writes output to the RGB8 palette format.
//
//-----------------------------------------------------------------------------
void C_BufWrite_Palette8_NoDither(PD3DI_RASTCTX pCtx, PD3DI_RASTPRIM pP, PD3DI_RASTSPAN pS)
{
    UINT16 uMapIdx = MAKE_RGB8(pCtx->SI.uBR>>8, pCtx->SI.uBG>>8, pCtx->SI.uBB>>8);

    *(PUINT8)pS->pSurface = (UINT8)(pCtx->pRampMap[uMapIdx]);

    // just returns for C, since we really can't loop with function calls
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\cspan\cbldfncs.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the source and destination alpha blend functions.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop
#include "cbldfncs.h"

//-----------------------------------------------------------------------------
//
// SrcBlendZero
//
// (0, 0, 0, 0) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = 0;
    *pG = 0;
    *pB = 0;
    *pA = 0;
}

//-----------------------------------------------------------------------------
//
// SrcBlendOne
//
// (1, 1, 1, 1) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = pCtx->SI.uBR;
    *pG = pCtx->SI.uBG;
    *pB = pCtx->SI.uBB;
    *pA = pCtx->SI.uBA;
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcColor
//
// (Rs, Gs, Bs, As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (pCtx->SI.uBR>>8)*(pCtx->SI.uBR>>8);
    *pG = (pCtx->SI.uBG>>8)*(pCtx->SI.uBG>>8);
    *pB = (pCtx->SI.uBB>>8)*(pCtx->SI.uBB>>8);
    *pA = (pCtx->SI.uBA>>8)*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvSrcColor
//
// (1-Rs, 1-Gs, 1-Bs, 1-As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (pCtx->SI.uBR>>8))*(pCtx->SI.uBR>>8);
    *pG = (0xff - (pCtx->SI.uBG>>8))*(pCtx->SI.uBG>>8);
    *pB = (0xff - (pCtx->SI.uBB>>8))*(pCtx->SI.uBB>>8);
    *pA = (0xff - (pCtx->SI.uBA>>8))*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcAlpha
//
// (As, As, As, As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = pCtx->SI.uBA>>8;
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvSrcAlpha
//
// (1-As, 1-As, 1-As, 1-As) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (pCtx->SI.uBA>>8);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendDestAlpha
//
// (Ad, Ad, Ad, Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvDestAlpha
//
// (1-Ad, 1-Ad, 1-Ad, 1-Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = f*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendDestColor
//
// (Rd, Gd, Bd, Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (UINT16)RGBA_GETRED(DestC)  *(pCtx->SI.uBR>>8);
    *pG = (UINT16)RGBA_GETGREEN(DestC)*(pCtx->SI.uBG>>8);
    *pB = (UINT16)RGBA_GETBLUE(DestC) *(pCtx->SI.uBB>>8);
    *pA = (UINT16)RGBA_GETALPHA(DestC)*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendInvDestColor
//
// (1-Rd, 1-Gd, 1-Bd, 1-Ad) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (UINT16)RGBA_GETRED(DestC)  )*(pCtx->SI.uBR>>8);
    *pG = (0xff - (UINT16)RGBA_GETGREEN(DestC))*(pCtx->SI.uBG>>8);
    *pB = (0xff - (UINT16)RGBA_GETBLUE(DestC) )*(pCtx->SI.uBB>>8);
    *pA = (0xff - (UINT16)RGBA_GETALPHA(DestC))*(pCtx->SI.uBA>>8);
}

//-----------------------------------------------------------------------------
//
// SrcBlendSrcAlphaSat
//
// f = min(as, 1-Ad); (f, f, f, 1) * Src
//
//-----------------------------------------------------------------------------
void C_SrcBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = min< UINT16>(pCtx->SI.uBA>>8, 0xff - (UINT16)RGBA_GETALPHA(DestC));
    *pR = f*(pCtx->SI.uBR>>8);
    *pG = f*(pCtx->SI.uBG>>8);
    *pB = f*(pCtx->SI.uBB>>8);
    *pA = pCtx->SI.uBA;
}

//-----------------------------------------------------------------------------
//
// DestBlendZero
//
// (0, 0, 0, 0) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_Zero(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = 0;
    *pG = 0;
    *pB = 0;
    *pA = 0;
}

//-----------------------------------------------------------------------------
//
// DestBlendOne
//
// (1, 1, 1, 1) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_One(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = ((UINT16)RGBA_GETRED(DestC)  <<8);
    *pG = ((UINT16)RGBA_GETGREEN(DestC)<<8);
    *pB = ((UINT16)RGBA_GETBLUE(DestC) <<8);
    *pA = ((UINT16)RGBA_GETALPHA(DestC)<<8);
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcColor
//
// (Rs, Gs, Bs, As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_SrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (pCtx->SI.uBR>>8)*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (pCtx->SI.uBG>>8)*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (pCtx->SI.uBB>>8)*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (pCtx->SI.uBA>>8)*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvSrcColor
//
// (1-Rs, 1-Gs, 1-Bs, 1-As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvSrcColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (pCtx->SI.uBR>>8))*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (0xff - (pCtx->SI.uBG>>8))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (0xff - (pCtx->SI.uBB>>8))*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (0xff - (pCtx->SI.uBA>>8))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcAlpha
//
// (As, As, As, As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_SrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = pCtx->SI.uBA>>8;
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvSrcAlpha
//
// (1-As, 1-As, 1-As, 1-As) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvSrcAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (pCtx->SI.uBA>>8);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendDestAlpha
//
// (Ad, Ad, Ad, Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_DestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvDestAlpha
//
// (1-Ad, 1-Ad, 1-Ad, 1-Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvDestAlpha(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = 0xff - (UINT16)RGBA_GETALPHA(DestC);
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = f*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendDestColor
//
// (Rd, Gd, Bd, Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_DestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = ((UINT16)RGBA_GETRED(DestC)  )*((UINT16)RGBA_GETRED(DestC)  );
    *pG = ((UINT16)RGBA_GETGREEN(DestC))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = ((UINT16)RGBA_GETBLUE(DestC) )*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = ((UINT16)RGBA_GETALPHA(DestC))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendInvDestColor
//
// (1-Rd, 1-Gd, 1-Bd, 1-Ad) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_InvDestColor(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    *pR = (0xff - (UINT16)RGBA_GETRED(DestC)  )*((UINT16)RGBA_GETRED(DestC)  );
    *pG = (0xff - (UINT16)RGBA_GETGREEN(DestC))*((UINT16)RGBA_GETGREEN(DestC));
    *pB = (0xff - (UINT16)RGBA_GETBLUE(DestC) )*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (0xff - (UINT16)RGBA_GETALPHA(DestC))*((UINT16)RGBA_GETALPHA(DestC));
}

//-----------------------------------------------------------------------------
//
// DestBlendSrcAlphaSat
//
// f = min(As, 1-Ad); (f, f, f, 1) * Dest
//
//-----------------------------------------------------------------------------
void C_DestBlend_SrcAlphaSat(PUINT16 pR, PUINT16 pG, PUINT16 pB, PUINT16 pA, D3DCOLOR DestC, PD3DI_RASTCTX pCtx)
{
    UINT16 f = min< UINT16>(pCtx->SI.uBA>>8, 0xff - (UINT16)RGBA_GETALPHA(DestC));
    *pR = f*((UINT16)RGBA_GETRED(DestC)  );
    *pG = f*((UINT16)RGBA_GETGREEN(DestC));
    *pB = f*((UINT16)RGBA_GETBLUE(DestC) );
    *pA = (UINT16)RGBA_GETALPHA(DestC)<<8;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\cspan\ctexfilt.h ===
//-----------------------------------------------------------------------------
//
// This file contains texture filtering function headers.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

void TexFiltBilinear(D3DCOLOR *pOut, INT32 iUFrac, INT32 iVFrac, UINT32 uTex00, UINT32 uTex10,
                     UINT32 uTex01, UINT32 uTex11);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\cspan\cspnpars.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the general span parsing code.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop


//-----------------------------------------------------------------------------
//
// C_RenderSpansAny
//
// All mode general span routine.
//
//-----------------------------------------------------------------------------
HRESULT C_RenderSpansAny(PD3DI_RASTCTX pCtx)
{
    PD3DI_RASTPRIM pP = pCtx->pPrim;

    while (pP)
    {
        UINT16 uSpans = pP->uSpans;
        PD3DI_RASTSPAN pS = (PD3DI_RASTSPAN)(pP + 1);

        while (uSpans-- > 0)
        {
            pCtx->pfnBegin(pCtx, pP, pS);

            pS++;
        }
        pP = pP->pNext;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\cspan\cbufread.cpp ===
//-----------------------------------------------------------------------------
//
// This file contains the output buffer color reading routines for Blending.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//-----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop
#include "cbufread.h"

// Names are read LSB to MSB, so B5G6R5 means five bits of blue starting
// at the LSB, then six bits of green, then five bits of red.

//-----------------------------------------------------------------------------
//
// Read_B8G8R8
//
// Reads output buffer in BGR-888 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B8G8R8(PUINT8 pBits)
{
    return (*pBits | (*(pBits+1))<<8 | (*(pBits+2))<<16 | 0xff000000);
}

//-----------------------------------------------------------------------------
//
// Read_B8G8R8X8
//
// Reads output buffer in BGR-888x8 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B8G8R8X8(PUINT8 pBits)
{
    PUINT32 pSurface = (PUINT32)pBits;
    return *pSurface | 0xff000000;
}

//-----------------------------------------------------------------------------
//
// Read_B8G8R8A8
//
// Reads output in BGRA-8888 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B8G8R8A8(PUINT8 pBits)
{
    PUINT32 pSurface = (PUINT32)pBits;
    return *pSurface;
}

//-----------------------------------------------------------------------------
//
// Read_B5G6R5
//
// Reads output in BGR-565 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B5G6R5(PUINT8 pBits)
{
    UINT16 uPixel = *(PUINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( uPixel >> 8 ) & 0xf8,
                (( uPixel >> 3) & 0xfc ),
                (( uPixel << 3) & 0xf8 ),
                0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_B5G5R5
//
// Reads output in BGR-555 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B5G5R5(PUINT8 pBits)
{
    UINT16 uPixel = *(PUINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( uPixel >> 7 ) & 0xf8,
                (( uPixel >> 2) & 0xf8 ),
                (( uPixel << 3) & 0xf8 ),
                0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_B5G5R5A1
//
// Reads output in BGRA-1555 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_B5G5R5A1(PUINT8 pBits)
{
    INT16 iPixel = *(PINT16)pBits;

    D3DCOLOR Color = RGBA_MAKE(( iPixel >> 7 ) & 0xf8,
                (( iPixel >> 2) & 0xf8 ),
                (( iPixel << 3) & 0xf8 ),
                (iPixel >> 15) & 0xff);
    return Color;
}

//-----------------------------------------------------------------------------
//
// Read_Palette8
//
// Reads output in Palette8 format.
//
//-----------------------------------------------------------------------------
D3DCOLOR C_BufRead_Palette8(PUINT8 pBits)
{
    // ATTENTION - This is not correct. But We assume Palette8 format will
    // normally not be used for alpha blending.
    return (D3DCOLOR)0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\cspan\cspnutil.cpp ===
//----------------------------------------------------------------------------
//
// cspnutil.cpp
//
// Sundry span utilities.
//
// Copyright (C) Microsoft Corporation, 1997.
//
//----------------------------------------------------------------------------

#include "rgb_pch.h"
#pragma hdrstop

// don't have anything to put in this file, yet
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\cspan\makefile.inc ===
!include ..\rgbrule.mk

$(GENTGT)\ccrbd_mh.h: ccrbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\ccrgn_mh.h: ccrgn_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctest_mh.h: ctest_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctxa_mh.h: ctxa_mh.mh ctexaddr.mh $(RAST_STD_M4)


$(GENTGT)\ctxbd_mh.h: ctxbd_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctxrd_mh.h: ctxrd_mh.mh $(RAST_STD_M4)

$(GENTGT)\ctstf_mh.h: ctstf_mh.mh $(RAST_STD_M4)

$(GENTGT)\catest_mh.h: catest_mh.mh $(RAST_STD_M4)

$(GENTGT)\cbeadtbl.cpp: cbeadtbl.mcp $(RGBRASTROOT)\pch\bead.mh $(RAST_STD_M4)

$(GENTGT)\cclrbld.cpp: cclrbld.mcp $(RAST_STD_M4)

$(GENTGT)\cclrgen.cpp: cclrgen.mcp $(RAST_STD_M4)

$(GENTGT)\cloop.cpp: cloop.mcp ctexaddr.mh $(RAST_STD_M4)

$(GENTGT)\ctest.cpp: ctest.mcp $(RAST_STD_M4)

$(GENTGT)\ctxaddr.cpp: ctxaddr.mcp ctexaddr.mh $(RAST_STD_M4)

$(GENTGT)\ctxblend.cpp: ctxblend.mcp $(RAST_STD_M4)

$(GENTGT)\ctexread.cpp: ctexread.mcp $(RAST_STD_M4)

$(GENTGT)\catest.cpp: catest.mcp $(RAST_STD_M4)

$(GENTGT)\ctstfail.cpp: ctstfail.mcp ctexaddr.mh $(RAST_STD_M4)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\dll\main.cpp ===
#include "rgb_pch.h"
#pragma hdrstop

namespace RGB_RAST_LIB_NAMESPACE
{
auto_ptr< CRGBDriver> g_pRGBDriver;
}

CRGBDriver* CRGBDriver::sm_pGlobalDriver= NULL;

DX8SDDIFW::COSDetector DX8SDDIFW::g_OSDetector;

HRESULT APIENTRY
D3D8GetSWInfo( D3DCAPS8* pCaps, PD3D8_SWCALLBACKS pCallbacks,
    DWORD* pNumTextures, DDSURFACEDESC** ppTexList)
{
    return g_pRGBDriver->GetSWInfo( *pCaps, *pCallbacks, *pNumTextures, *ppTexList);
}

BOOL WINAPI DllMain( HINSTANCE hInstance, DWORD dwReason, LPVOID lpvReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            try {
                CRGBDriver::InitSupportedSurfaceArray();
                g_pRGBDriver= auto_ptr< CRGBDriver>( new CRGBDriver);
            } catch( ...) {
            }
            if( g_pRGBDriver.get()== NULL)
                return FALSE;
            break;

        // DLL_PROCESS_DETACH will be called if ATTACH returned FALSE.
        case DLL_PROCESS_DETACH:
            break;

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\multimedia\directx\dxg\swrast\rgb\lib\main.cpp ===
#include "rgb_pch.h"
#pragma hdrstop

// #include <d3d8rgbrast.h>
// Need to share some kind of header which has:
// #ifndef __D3D8RGBRAST_H__
// #define __D3D8RGBRAST_H__
//
// #ifdef __cplusplus
// extern "C" {
// #endif //__cplusplus
//
// extern void* D3D8RGBRasterizer;
//
// #ifdef __cplusplus
// }
// #endif //__cplusplus
//
// #endif //__D3D8RGBRAST_H__

#ifdef __cplusplus
extern "C" {
#endif //__cplusplus

extern void* D3D8RGBRasterizer;

#ifdef __cplusplus
}
#endif //__cplusplus

namespace RGB_RAST_LIB_NAMESPACE
{
auto_ptr< CRGBDriver> g_pRGBDriver;

HRESULT APIENTRY
GetSWInfo( D3DCAPS8* pCaps, PD3D8_SWCALLBACKS pCallbacks,
    DWORD* pNumTextures, DDSURFACEDESC** ppTexList)
{
    if( g_pRGBDriver.get()!= NULL)
        return g_pRGBDriver->GetSWInfo( *pCaps, *pCallbacks, *pNumTextures, *ppTexList);
    else
    {
        try {
            CRGBDriver::InitSupportedSurfaceArray();
            g_pRGBDriver= auto_ptr< CRGBDriver>( new CRGBDriver);
        } catch( ... )
        {